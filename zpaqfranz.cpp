///////// EXPERIMENTAL BUILD
///////// The source is a mess
///////// Strongly in development
/////////
///////// https://github.com/fcorbelli/zpaqfranz
///////// https://sourceforge.net/projects/zpaqfranz/

///////// I had to reluctantly move parts of the comments and some times even delete them, 
///////// I apologize with the authors, it's not a foolish attempt to take over their jobs
///////// but a LASAGNA-code style (spaghetti on steroids)


#define ZPAQ_VERSION "55.6-experimental"

#if defined(_WIN64)
#define ZSFX_VERSION "SFX64 v55.1,"
#endif

#if defined(_WIN32) && (!defined(_WIN64))
#define ZSFX_VERSION "SFX32 v55.1,"
#endif

#if (!defined(_WIN32)) && (!defined(_WIN64))
#define ZSFX_VERSION ""
#endif


/*
                         __                     
  _____ __   __ _  __ _ / _|_ __ __ _ _ __  ____
 |_  / '_ \ / _` |/ _` | |_| '__/ _` | '_ \|_  /
  / /| |_) | (_| | (_| |  _| | | (_| | | | |/ / 
 /___| .__/ \__,_|\__, |_| |_|  \__,_|_| |_/___|
     |_|             |_|                        
                                                                    

## This is zpaqfranz, a patched  but (maybe) compatible fork of ZPAQ version 7.15 
(http://mattmahoney.net/dc/zpaq.html)

Ancient version is in FreeBSD /ports/archivers/paq (v 6.57 of 2014)

From branch 51 all source code merged in one zpaqfranz.cpp
aiming to make it as easy as possible to compile on "strange" systems (NAS, vSphere etc).

So be patient if the source is not linear, 
updating and compilation are now trivial.
 
The source is composed of the fusion of different software 
from different authors, therefore there is no uniform style of programming. 

I have made a number of efforts to maintain compatibility 
with unmodified version (7.15), even at the cost 
of expensive on inelegant workarounds.

So don't be surprised if it looks like what in Italy 
we call "zibaldone" or in Emilia-Romagna "mappazzone".
Jun 2021: starting to fix the mess (refactoring). Work in progress.
Jul 2021: source cleaned a bit. From 52+ XXHASH64 as checksum algo
Sep 2021: refactoring in progress...

Windows binary builds (32 and 64 bit) on github/sourceforge

## **Provided as-is, with no warranty whatsoever, by Franco Corbelli, franco@francocorbelli.com**


####      Key differences against 7.15 by zpaqfranz -diff or here 
####  https://github.com/fcorbelli/zpaqfranz/blob/main/differences715.txt 

Portions of software by other authors, mentioned later, are included.
As far as I know this is allowed by the licenses. 

**I apologize if I have unintentionally violated any rule.**
**Report it and I will fix as soon as possible.**

- Include mod by data man and reg2s patch from encode.su forum 
- Crc32.h Copyright (c) 2011-2019 Stephan Brumme 
- xxhash64 by Stephan Brumme https://create.stephan-brumme.com/xxhash/
- part of hash-library (MD5, SHA-3) by Stephan Brumme https://github.com/stbrumme/hash-library
- Slicing-by-16 contributed by Bulat Ziganshin 
- xxHash Extremely Fast Hash algorithm, Copyright (C) 2012-2020 Yann Collet 
- crc32c.c Copyright (C) 2013 Mark Adler
- Embedded Artistry https://github.com/embeddedartistry
- wyhash (experimental) WangYi  https://github.com/wangyi-fudan/wyhash  
- https://github.com/System-Glitch/SHA256
- https://github.com/BLAKE3-team/BLAKE3
- The Whirlpool algorithm was developed by Paulo S. L. M. Barreto and Vincent Rijmen
- Nilsimsa implementation by Sepehr Laal
- Thanks for testing on various Unixes to https://github.com/dertuxmalwieder
- JFLarvoire for usefun (yes, usefun) informations https://github.com/JFLarvoire/SysToolsLib/blob/master/C/MsvcLibX/src/readlink.c

 
FreeBSD port, quick and dirty to get a /usr/local/bin/zpaqfranz
```
mkdir /tmp/testme
cd /tmp/testme
wget http://www.francocorbelli.it/zpaqfranz/zpaqfranz-51.30.tar.gz
tar -xvf zpaqfranz-51.30.tar.gz
make install clean
```

NOTE1: -, not -- (into switch)
NOTE2: switches ARE case sensitive.   -maxsize <> -MAXSIZE


# How to build
My main development platforms are Windows and FreeBSD. 
I rarely use Linux or MacOS, so changes may be needed.

As explained the program is single file, 
be careful to link the pthread library.

DEFINEs
(nothing)							// Compile for Windows
-DHWBLAKE3 blake3_windows_gnu.S		// On Win64 enable HW accelerated BLAKE3 (with assembly)
-Dunix 								// Compile on "something different from Windows"
-DSOLARIS        					// Solaris is similar, but not equal, to BSD Unix
-DHWSHA1							// On Win64 enable HW SHA1 (-flaghw)

-DEBUG								// Old 7.15
-NOJIT								// Old 7.15, not x86 CPU

HIDDEN GEMS
If the executable is named "dir" act (just about) like Windows' dir

WARNINGS
Some strange warning with some compilers 
(too old, or too new).

My very own reporting
https://gcc.gnu.org/bugzilla/show_bug.cgi?id=101558

Original bug
https://gcc.gnu.org/bugzilla/show_bug.cgi?id=96963


Please note: on Windows there are embedded SFXs modules

Targets
```
Windows 64 (g++ 7.3.0)
g++ -O3  zpaqfranz.cpp -o zpaqfranz 

Windows 64 (g++ 10.3.0) MSYS2
g++ -O3  zpaqfranz.cpp -o zpaqfranz -pthread -static

Windows 64 (g++, Hardware Blake3 implementation)
In this case, of course, linking the .S file is mandatory
g++ -O3 -DHWBLAKE3 blake3_windows_gnu.S zpaqfranz.cpp -o zpaqfranz -pthread -static

Windows 64 (g++, Hardware Blake3 implementation PLUS HW SHA1)
g++ -O3 -DHWBLAKE3 -DHWSHA1 blake3_windows_gnu.s zpaqfranz.cpp sha1ugo.obj -o zpaqfranzhw -pthread -static

Windows 32 (g++ 7.3.0 64 bit)
c:\mingw32\bin\g++ -m32 -O3 zpaqfranz.cpp -o zpaqfranz32 -pthread -static

FreeBSD (11.x) gcc 7
gcc7 -O3 -march=native -Dunix zpaqfranz.cpp -lstdc++ -pthread -o zpaqfranz -static -lm

FreeBSD (12.1) gcc 9.3.0
g++ -O3 -march=native -Dunix zpaqfranz.cpp  -pthread -o zpaqfranz -static-libstdc++ -static-libgcc

FreeBSD (11.4) gcc 10.2.0
g++ -O3 -march=native -Dunix zpaqfranz.cpp  -pthread -o zpaqfranz -static-libstdc++ -static-libgcc -Wno-stringop-overflow

FreeBSD (11.3) clang 6.0.0
clang++ -march=native -Dunix zpaqfranz.cpp  -pthread -o zpaqfranz -static

OpenBSD 6.6 clang++ 8.0.1
clang++ -Dunix -O3 -march=native zpaqfranz.cpp -o zpaqfranz -pthread -static

Debian Linux (10/11) gcc 8.3.0
ubuntu 21.04 desktop-amd64 gcc  10.3.0
manjaro 21.07 gcc 11.1.0
g++ -O3 -Dunix zpaqfranz.cpp  -pthread -o zpaqfranz -static

QNAP NAS TS-431P3 (Annapurna AL314) gcc 7.4.0
g++ -Dunix zpaqfranz.cpp  -pthread -o zpaqfranz -Wno-psabi

Fedora 34 gcc 11.2.1
Typically you will need some library (out of a fresh Fedora box)
sudo dnf install glibc-static libstdc++-static -y;
Then you can compile, via Makefile or "by hand"
(do not forget... sudo!)

CentoOS
Please note:
"Red Hat discourages the use of static linking for security reasons. 
Use static linking only when necessary, especially against libraries provided by Red Hat. "
Therefore a -static linking is often a nightmare on CentOS => change the Makefile
g++ -O3 -Dunix zpaqfranz.cpp  -pthread -o zpaqfranz

Solaris 11.4 gcc 7.3.0
OmniOS r151042 gcc 7.5.0
g++ -O3 -march=native -DSOLARIS zpaqfranz.cpp -o zpaqfranz  -pthread -static-libgcc -lkstat

MacOS 11.0 gcc (clang) 12.0.5
Please note:
The -std=c++11 is required, unless you have to change half a dozen lines. No -static here
"Apple does not support statically linked binaries on Mac OS X. 
(...)
Rather, we strive to ensure binary 
compatibility in each dynamically linked system library and framework
(AHAHAHAHAHAH, note by me)
Warning: Shipping a statically linked binary entails a significant compatibility risk. 
We strongly recommend that you not do this...
Short version: Apple does not like -static, so compile with
g++ -Dunix  -O3 -march=native zpaqfranz.cpp -o zpaqfranz -pthread  -std=c++11


Beware of #definitions
g++ -dM -E - < /dev/null
sometimes __sun, sometimes not




============
General Makefile (note: remove -static on some systems)


CXX=g++
CPPFLAGS+=-Dunix
CXXFLAGS=-O3 -march=native
PREFIX=/usr/local
BINDIR=$(PREFIX)/bin

all: zpaqfranz

zpaqfranz: 
        $(CXX) $(CPPFLAGS) $(CXXFLAGS) zpaqfranz.cpp -o $@ -pthread -static 

install: zpaqfranz
        install -m 0755 -d $(DESTDIR)$(BINDIR)
        install -m 0755 zpaqfranz $(DESTDIR)$(BINDIR)
		install -m 0755 zpaqfranz $(DESTDIR)$(BINDIR)/dir
        
clean:
        rm -f zpaqfranz

check: zpaqfranz
        ./zpaqfranz a ./archive.zpaq *  -xxh3 -test -verify
        rm ./archive.zpaq 
		
*/



#define FRANZOFFSET 		50
#define FRANZOFFSETSHA256 	76 
#define FRANZMAXPATH 		240

#define FRANZO_NONE			0
#define FRANZO_CRC_32 		1
#define	FRANZO_XXHASH64		2
#define FRANZO_SHA_1		3
#define FRANZO_SHA_256		4
#define	FRANZO_XXH3			5
#define	FRANZO_BLAKE3		6
#define FRANZO_SHA3			7
#define FRANZO_MD5			8

#define _FILE_OFFSET_BITS 64  // In Linux make sizeof(off_t) == 8. Define BEFORE including windows.h!!!

#ifndef UNICODE
	#define UNICODE  // For Windows
#endif

#ifndef DEBUG
	#define NDEBUG 1
#endif

#if defined(__unix__) || (defined(__APPLE__) && defined(__MACH__))
	#ifndef unix
		#define unix 1
	#endif
#endif

#include <assert.h>
#include <time.h>
#include <pthread.h>
#include <math.h>
#include <stdio.h>
#include <string.h>
#include <unistd.h>
#include <algorithm>
#include <string>
#include <vector>
#include <map>
#include <stdexcept>
#include <cstddef>

#ifdef unix
	#ifndef NOJIT
		#include <sys/mman.h>
	#endif

	#define PTHREAD 1
	#include <termios.h>
	#include <sys/param.h>
	#include <sys/types.h>
	#include <sys/stat.h>
	#include <sys/time.h>
	#include <dirent.h>
	#include <utime.h>
	
	#include <sys/ioctl.h>
	#include <fcntl.h>
	#include <stdarg.h>

	#ifdef BSD
		#include <sys/sysctl.h>
		#include <sys/mount.h>
		// macos
		///#include <curses.h>

	#endif

#else  // Assume Windows
	
	#include <conio.h>
	#include <windows.h>
	#include <io.h>
	#include <sys/stat.h>
	using namespace std;

#endif

#ifdef HWSHA1
/*
Hardware-accelerated calc of SHA-1


This is a "piece" of 7-zip by Igor Pavlov
(I am sure you know)

No really useful, just for fun (!)
NO CPU capability checks, straight -hw switch
Why? Because I use AMD 5950X 


C:\zpaqfranz>zpaqfranzhw b -sha1
zpaqfranz v55.6g-experimental (HW BLAKE3,SHA1), SFX64 v55.1, compiled Jul 25 2022
(...)
       SHA-1:   951.61 MB/s (done     4.65 GB)

C:\zpaqfranz>zpaqfranzhw b -sha1 -hw
zpaqfranz v55.6g-experimental (HW BLAKE3,SHA1), SFX64 v55.1, compiled Jul 25 2022
(...)
       SHA-1:     1.86 GB/s (done     9.29 GB)


You will need to link the .obj and use the -DHWSHA1

https://github.com/nidud/asmc
asmc64.exe sha1ugo.asm 
g++ -O3 -s  zpaqfranz.cpp -o zpaqfranz blake3_windows_gnu.s sha1ugo.obj 

In fact does not change very much against original SHA-1 implementation:
about two time faster (on AMD Ryzen) BUT higher latency

Short version:  not worth the effort for the GA release
*/

#define MY_ALIGN(n) __attribute__ ((aligned(n)))
#define MY_NO_INLINE __attribute__((noinline))
#define MY_FAST_CALL

typedef unsigned char 			Byte;
typedef short 					Int16;
typedef int 					Int32;
typedef long long int 			Int64;
typedef unsigned short 			UInt16;
typedef unsigned int 			UInt32;
typedef unsigned long long int 	UInt64;
typedef int 					BoolInt;


#define SHA1_NUM_BLOCK_WORDS  16
#define SHA1_NUM_DIGEST_WORDS  5
#define SHA1_BLOCK_SIZE   (SHA1_NUM_BLOCK_WORDS * 4)
#define SHA1_DIGEST_SIZE  (SHA1_NUM_DIGEST_WORDS * 4)
typedef void (MY_FAST_CALL *SHA1_FUNC_UPDATE_BLOCKS)(UInt32 state[5], const Byte *data, size_t numBlocks);

typedef struct
{
  SHA1_FUNC_UPDATE_BLOCKS func_UpdateBlocks;
  UInt64 count;
  UInt64 __pad_2[2];
  UInt32 state[SHA1_NUM_DIGEST_WORDS];
  UInt32 __pad_3[3];
  Byte buffer[SHA1_BLOCK_SIZE];
} CSha1;

void Sha1Prepare(bool i_flaghardware=false);

void Sha1_InitState(CSha1 *p);
void Sha1_Init(CSha1 *p);
void Sha1_Update(CSha1 *p, const Byte *data, size_t size);
void Sha1_Final			(CSha1 *p, Byte *digest);
void Sha1_PrepareBlock(const CSha1 *p, Byte *block, unsigned size);
void Sha1_GetBlockDigest(const CSha1 *p, const Byte *data, Byte *destDigest);

void MY_FAST_CALL Sha1_UpdateBlocks(UInt32 state[5], const Byte *data, size_t numBlocks);

extern "C" void MY_FAST_CALL Sha1_UpdateBlocks_HW(UInt32 state[5], const Byte *data, size_t numBlocks);

static SHA1_FUNC_UPDATE_BLOCKS g_FUNC_UPDATE_BLOCKS = Sha1_UpdateBlocks;
static SHA1_FUNC_UPDATE_BLOCKS g_FUNC_UPDATE_BLOCKS_HW;

#define rotlFixed(x, n) (((x) << (n)) | ((x) >> (32 - (n))))
#define rotrFixed(x, n) (((x) >> (n)) | ((x) << (32 - (n))))

#define STEP_PRE  20
#define STEP_MAIN 20
#define kNumW 16
#define w(i) W[(i)&15]

#define w0(i) (W[i] = GetBe32(data + (size_t)(i) * 4))
#define w1(i) (w(i) = rotlFixed(w((size_t)(i)-3) ^ w((size_t)(i)-8) ^ w((size_t)(i)-14) ^ w((size_t)(i)-16), 1))

#define sha1_f0(x,y,z)  ( 0x5a827999 + (z^(x&(y^z))) )
#define sha1_f1(x,y,z)  ( 0x6ed9eba1 + (x^y^z) )
#define sha1_f2(x,y,z)  ( 0x8f1bbcdc + ((x&y)|(z&(x|y))) )
#define sha1_f3(x,y,z)  ( 0xca62c1d6 + (x^y^z) )

#define T5(a,b,c,d,e, fx, ww) \
    e += fx(b,c,d) + ww + rotlFixed(a, 5); \
    b = rotlFixed(b, 30); \

#define M5(i, fx, wx0, wx1) \
    T5 ( a,b,c,d,e, fx, wx0((i)  ) ); \
    T5 ( e,a,b,c,d, fx, wx1((i)+1) ); \
    T5 ( d,e,a,b,c, fx, wx1((i)+2) ); \
    T5 ( c,d,e,a,b, fx, wx1((i)+3) ); \
    T5 ( b,c,d,e,a, fx, wx1((i)+4) ); \

#define R5(i, fx, wx) \
    M5 ( i, fx, wx, wx) \


#if STEP_PRE > 5

  #define R20_START \
    R5 (  0, sha1_f0, w0); \
    R5 (  5, sha1_f0, w0); \
    R5 ( 10, sha1_f0, w0); \
    M5 ( 15, sha1_f0, w0, w1); \
  
  #elif STEP_PRE == 5
  
  #define R20_START \
    { size_t i; for (i = 0; i < 15; i += STEP_PRE) \
      { R5(i, sha1_f0, w0); } } \
    M5 ( 15, sha1_f0, w0, w1); \

#else

  #if STEP_PRE == 1
    #define R_PRE R1
  #elif STEP_PRE == 2
    #define R_PRE R2
  #elif STEP_PRE == 4
    #define R_PRE R4
  #endif

  #define R20_START \
    { size_t i; for (i = 0; i < 16; i += STEP_PRE) \
      { R_PRE(i, sha1_f0, w0); } } \
    R4 ( 16, sha1_f0, w1); \

#endif

#if STEP_MAIN > 5

  #define R20(ii, fx) \
    R5 ( (ii)     , fx, w1); \
    R5 ( (ii) + 5 , fx, w1); \
    R5 ( (ii) + 10, fx, w1); \
    R5 ( (ii) + 15, fx, w1); \

#else

  #if STEP_MAIN == 1
    #define R_MAIN R1
  #elif STEP_MAIN == 2
    #define R_MAIN R2
  #elif STEP_MAIN == 4
    #define R_MAIN R4
  #elif STEP_MAIN == 5
    #define R_MAIN R5
  #endif

  #define R20(ii, fx)  \
    { size_t i; for (i = (ii); i < (ii) + 20; i += STEP_MAIN) \
      { R_MAIN(i, fx, w1); } } \

#endif


#define SetUi32(p, v) { *(UInt32 *)(void *)(p) = (v); }
#define GetBe32(p) ( \
    ((UInt32)((const Byte *)(p))[0] << 24) | \
    ((UInt32)((const Byte *)(p))[1] << 16) | \
    ((UInt32)((const Byte *)(p))[2] <<  8) | \
             ((const Byte *)(p))[3] )
#define SetBe32(p, v) { Byte *_ppp_ = (Byte *)(p); UInt32 _vvv_ = (v); \
    _ppp_[0] = (Byte)(_vvv_ >> 24); \
    _ppp_[1] = (Byte)(_vvv_ >> 16); \
    _ppp_[2] = (Byte)(_vvv_ >> 8); \
    _ppp_[3] = (Byte)_vvv_; }


void Sha1_InitState(CSha1 *p)
{
	p->count = 0;
	p->state[0] = 0x67452301;
	p->state[1] = 0xEFCDAB89;
	p->state[2] = 0x98BADCFE;
	p->state[3] = 0x10325476;
	p->state[4] = 0xC3D2E1F0;
}

void Sha1_Init(CSha1 *p)
{
	p->func_UpdateBlocks =     g_FUNC_UPDATE_BLOCKS;
	Sha1_InitState(p);
}


MY_NO_INLINE
void MY_FAST_CALL Sha1_UpdateBlocks(UInt32 state[5], const Byte *data, size_t numBlocks)
{
	UInt32 a, b, c, d, e;
	UInt32 W[kNumW];
	// if (numBlocks != 0x1264378347) return;
	if (numBlocks==0)
		return;

	a = state[0];
	b = state[1];
	c = state[2];
	d = state[3];
	e = state[4];

	do
	{
		#if STEP_PRE < 5 || STEP_MAIN < 5
		UInt32 tmp;
		#endif

		R20_START
		R20(20, sha1_f1);
		R20(40, sha1_f2);
		R20(60, sha1_f3);

		a += state[0];
		b += state[1];
		c += state[2];
		d += state[3];
		e += state[4];

		state[0] = a;
		state[1] = b;
		state[2] = c;
		state[3] = d;
		state[4] = e;

		data += 64;
	}
	while (--numBlocks);
}

void Sha1_Update(CSha1 *p, const Byte *data, size_t size)
{
	if (size==0)
		return;

	unsigned pos = (unsigned)p->count & 0x3F;
	unsigned num;

	p->count += size;

	num=64-pos;
	if (num > size)
	{
		memcpy(p->buffer + pos, data, size);
		return;
	}

	if (pos != 0)
	{
		size -= num;
		memcpy(p->buffer + pos, data, num);
		data += num;
		p->func_UpdateBlocks(p->state, p->buffer, 1);
	}

	size_t numBlocks = size >> 6;
	p->func_UpdateBlocks(p->state, data, numBlocks);
	size &= 0x3F;
	if (size==0)
	  return;
	data += (numBlocks << 6);
	memcpy(p->buffer, data, size);
}


void Sha1_Final(CSha1 *p, Byte *digest)
{
	unsigned pos = (unsigned)p->count & 0x3F;
  
	p->buffer[pos++] = 0x80;

	if (pos > (64 - 8))
	{
		while (pos != 64) 
			p->buffer[pos++]=0; 
		// memset(&p->buf.buffer[pos], 0, 64 - pos);
		p->func_UpdateBlocks(p->state, p->buffer, 1);
		pos = 0;
	}

	memset(&p->buffer[pos], 0, (64 - 8) - pos);
  
	UInt64 numBits = (p->count << 3);
    SetBe32(p->buffer + 64 - 8, (UInt32)(numBits >> 32));
    SetBe32(p->buffer + 64 - 4, (UInt32)(numBits));
 
	p->func_UpdateBlocks(p->state, p->buffer, 1);

	SetBe32(digest,      p->state[0]);
	SetBe32(digest + 4,  p->state[1]);
	SetBe32(digest + 8,  p->state[2]);
	SetBe32(digest + 12, p->state[3]);
	SetBe32(digest + 16, p->state[4]);
	Sha1_InitState(p);
}


void Sha1_PrepareBlock(const CSha1 *p, Byte *block, unsigned size)
{
	const UInt64 numBits = (p->count + size) << 3;
	SetBe32(&((UInt32 *)(void *)block)[SHA1_NUM_BLOCK_WORDS - 2], (UInt32)(numBits >> 32));
	SetBe32(&((UInt32 *)(void *)block)[SHA1_NUM_BLOCK_WORDS - 1], (UInt32)(numBits));
	// SetBe32((UInt32 *)(block + size), 0x80000000);
	SetUi32((UInt32 *)(void *)(block + size), 0x80);
	size += 4;
	while (size != (SHA1_NUM_BLOCK_WORDS - 2) * 4)
	{
		*((UInt32 *)(void *)(block + size)) = 0;
		size += 4;
	}
}

void Sha1_GetBlockDigest(const CSha1 *p, const Byte *data, Byte *destDigest)
{
	MY_ALIGN (16)
	UInt32 st[SHA1_NUM_DIGEST_WORDS];

	st[0] = p->state[0];
	st[1] = p->state[1];
	st[2] = p->state[2];
	st[3] = p->state[3];
	st[4] = p->state[4];

	p->func_UpdateBlocks(st, data, 1);

	SetBe32(destDigest + 0    , st[0]);
	SetBe32(destDigest + 1 * 4, st[1]);
	SetBe32(destDigest + 2 * 4, st[2]);
	SetBe32(destDigest + 3 * 4, st[3]);
	SetBe32(destDigest + 4 * 4, st[4]);
}


void Sha1Prepare(bool i_flaghardware)
{
	SHA1_FUNC_UPDATE_BLOCKS f, f_hw;
	f = Sha1_UpdateBlocks;
	if (i_flaghardware)
		f = f_hw = Sha1_UpdateBlocks_HW;
	g_FUNC_UPDATE_BLOCKS    = f;
	g_FUNC_UPDATE_BLOCKS_HW = f_hw;
}
#endif  // HWSHA1
/*
	Section: libzpaq
*/


namespace libzpaq {

// 1, 2, 4, 8 byte unsigned integers
typedef uint8_t U8;
typedef uint16_t U16;
typedef uint32_t U32;
typedef uint64_t U64;

// Tables for parsing ZPAQL source code
extern const char* compname[256];    // list of ZPAQL component types
extern const int compsize[256];      // number of bytes to encode a component
extern const char* opcodelist[272];  // list of ZPAQL instructions

// Callback for error handling
extern void error(const char* msg);

// Virtual base classes for input and output
// get() and put() must be overridden to read or write 1 byte.
// read() and write() may be overridden to read or write n bytes more
// efficiently than calling get() or put() n times.
class Reader {
public:
  virtual int get() = 0;  // should return 0..255, or -1 at EOF
  virtual int read(char* buf, int n); // read to buf[n], return no. read
  virtual ~Reader() {}
};

class Writer {
public:
  virtual void put(int c) = 0;  // should output low 8 bits of c
  virtual void write(const char* buf, int n);  // write buf[n]
  virtual ~Writer() {}
};

// Read 16 bit little-endian number
int toU16(const char* p);

// An Array of T is cleared and aligned on a 64 byte address
//   with no constructors called. No copy or assignment.
// Array<T> a(n, ex=0);  - creates n<<ex elements of type T
// a[i] - index
// a(i) - index mod n, n must be a power of 2
// a.size() - gets n
template <typename T>
class Array {
  T *data;     // user location of [0] on a 64 byte boundary
  size_t n;    // user size
  int offset;  // distance back in bytes to start of actual allocation
  void operator=(const Array&);  // no assignment
  Array(const Array&);  // no copy
public:
  Array(size_t sz=0, int ex=0): data(0), n(0), offset(0) {
    resize(sz, ex);} // [0..sz-1] = 0
  void resize(size_t sz, int ex=0); // change size, erase content to zeros
  ~Array() {resize(0);}  // free memory
  size_t size() const {return n;}  // get size
  int isize() const {return int(n);}  // get size as an int
  T& operator[](size_t i) {assert(n>0 && i<n); return data[i];}
  T& operator()(size_t i) {assert(n>0 && (n&(n-1))==0); return data[i&(n-1)];}
};

// Change size to sz<<ex elements of 0
template<typename T>
void Array<T>::resize(size_t sz, int ex) {
  assert(size_t(-1)>0);  // unsigned type?
  while (ex>0) {
    if (sz>sz*2) error("Array too big");
    sz*=2, --ex;
  }
  if (n>0) {
    assert(offset>0 && offset<=64);
    assert((char*)data-offset);
    ::free((char*)data-offset);
  }
  n=0;
  offset=0;
  if (sz==0) return;
  n=sz;
  const size_t nb=128+n*sizeof(T);  // test for overflow
  if (nb<=128 || (nb-128)/sizeof(T)!=n) n=0, error("Array too big");
  data=(T*)::calloc(nb, 1);
  if (!data) n=0, error("Out of memory");
  offset=64-(((char*)data-(char*)0)&63);
  assert(offset>0 && offset<=64);
  data=(T*)((char*)data+offset);
}



//////////////////////////// SHA1 ////////////////////////////

// SHA1 code, see http://en.wikipedia.org/wiki/SHA-1



#define SHA1CHUNK 64
class SHA1 
{
public:
	void put(int c);
	void write(const char* buf, int64_t n); // hash buf[0..n-1]
	double size() const {return len/8;}     // size in bytes
	uint64_t usize() const {return len/8;}  // size in bytes
	const char* result();  // get hash and reset
	SHA1() {init();}
private:
#ifdef HWSHA1
	int				bufpos;				// 7-Zip SHA1 is rather different from
	CSha1			myhasher;			// the original 7.15. So I put an input buffer
	unsigned char 	w_hw[SHA1CHUNK];	// Slower, in fact, but it works
#endif
	U32 w[16];        // input buffer
	U64 len;          // length in bits
	U32 h[5];         // hash state
	char hbuf[20];    // result
	void process();   // hash 1 block
	void init();      // reset, but don't clear hbuf
};
// Start a new hash

#ifdef HWSHA1
/// This "thing" seems weird, and not very optimized
/// Must be a "plug in" replacment
void SHA1::init() 
{
	len=0;
	bufpos=0;
	Sha1_Init(&myhasher);
}
void SHA1::put(int c) 
{ 	
	w_hw[bufpos++]=c;
	if (bufpos==SHA1CHUNK)
	{
		Sha1_Update(&myhasher,(const Byte*)w_hw,SHA1CHUNK);
		bufpos=0;
	}
	len+=8;
}
// Return old result and start a new hash
const char* SHA1::result() 
{
	Sha1_Update(&myhasher,(const Byte*)w_hw,bufpos);
	Sha1_Final(&myhasher,(Byte*)hbuf);
	init();
	return hbuf;
}
// Hash buf[0..n-1]
void SHA1::write(const char* buf, int64_t n) 
{
	Sha1_Update(&myhasher,(const Byte*)buf,n);
	len+=n*8;
}

// Hash 1 block of 64 bytes
void SHA1::process() 
{
}

#else

///	zpaq 7.15 use a very, very, very good implementation of SHA1,
///	but full of very dirty tricks


void SHA1::init() 
{
	len=0;
	memset(w, 0, sizeof(w));
	h[0]=0x67452301;
	h[1]=0xEFCDAB89;
	h[2]=0x98BADCFE;
	h[3]=0x10325476;
	h[4]=0xC3D2E1F0;
}


void SHA1::put(int c) 
{ 	
	U32& r=w[U32(len)>>5&15];
	r=(r<<8)|(c&255);
    len+=8;
	if ((U32(len)&511)==0)
		process();
}
// Return old result and start a new hash
const char* SHA1::result() 
{
	// pad and append length
	const U64 s=len;
	put(0x80);
	while ((len&511)!=448)
	put(0);
	put(s>>56);
	put(s>>48);
	put(s>>40);
	put(s>>32);
	put(s>>24);
	put(s>>16);
	put(s>>8);
	put(s);
	// copy h to hbuf
	for (unsigned int i=0; i<5; ++i) 
	{
		hbuf[4*i]=h[i]>>24;
		hbuf[4*i+1]=h[i]>>16;
		hbuf[4*i+2]=h[i]>>8;
		hbuf[4*i+3]=h[i];
	}
	init();
	return hbuf;
	
}

// Hash buf[0..n-1]
void SHA1::write(const char* buf, int64_t n) 
{
  const unsigned char* p=(const unsigned char*) buf;
  for (; n>0 && (U32(len)&511)!=0; --n) put(*p++);
  for (; n>=64; n-=64) {
    for (unsigned int i=0; i<16; ++i)
      w[i]=p[0]<<24|p[1]<<16|p[2]<<8|p[3], p+=4;
    len+=512;
	process();
  }
  for (; n>0; --n) put(*p++);
}

// Hash 1 block of 64 bytes
void SHA1::process() 
{
  U32 a=h[0], b=h[1], c=h[2], d=h[3], e=h[4];
  static const U32 k[4]={0x5A827999, 0x6ED9EBA1, 0x8F1BBCDC, 0xCA62C1D6};
  #define f(a,b,c,d,e,i) \
    if (i>=16) \
      w[(i)&15]^=w[(i-3)&15]^w[(i-8)&15]^w[(i-14)&15], \
      w[(i)&15]=w[(i)&15]<<1|w[(i)&15]>>31; \
    e+=(a<<5|a>>27)+k[(i)/20]+w[(i)&15] \
      +((i)%40>=20 ? b^c^d : i>=40 ? (b&c)|(d&(b|c)) : d^(b&(c^d))); \
    b=b<<30|b>>2;
  #define r(i) f(a,b,c,d,e,i) f(e,a,b,c,d,i+1) f(d,e,a,b,c,i+2) \
               f(c,d,e,a,b,i+3) f(b,c,d,e,a,i+4)
  r(0)  r(5)  r(10) r(15) r(20) r(25) r(30) r(35)
  r(40) r(45) r(50) r(55) r(60) r(65) r(70) r(75)
  #undef f
  #undef r
  h[0]+=a; h[1]+=b; h[2]+=c; h[3]+=d; h[4]+=e;
}

#endif


//////////////////////////// SHA256 //////////////////////////

// For computing SHA-256 checksums
// http://en.wikipedia.org/wiki/SHA-2
class SHA256 {
public:
  void put(int c) {  // hash 1 byte
    unsigned& r=w[len0>>5&15];
    r=(r<<8)|(c&255);
    if (!(len0+=8)) ++len1;
    if ((len0&511)==0) process();
  }
  void write(const char* buf, int64_t n); // hash buf[0..n-1]
  double size() const {return len0/8+len1*536870912.0;} // size in bytes
  uint64_t usize() const {return len0/8+(U64(len1)<<29);} //size in bytes
  const char* result();  // get hash and reset
  SHA256() {init();}
private:
  void init();           // reset, but don't clear hbuf
  unsigned len0, len1;   // length in bits (low, high)
  unsigned s[8];         // hash state
  unsigned w[16];        // input buffer
  char hbuf[32];         // result
  void process();        // hash 1 block
};

//////////////////////////// AES /////////////////////////////

// For encrypting with AES in CTR mode.
// The i'th 16 byte block is encrypted by XOR with AES(i)
// (i is big endian or MSB first, starting with 0).
class AES_CTR {
  U32 Te0[256], Te1[256], Te2[256], Te3[256], Te4[256]; // encryption tables
  U32 ek[60];  // round key
  int Nr;  // number of rounds (10, 12, 14 for AES 128, 192, 256)
  U32 iv0, iv1;  // first 8 bytes in CTR mode
public:
  AES_CTR(const char* key, int keylen, const char* iv=0);
    // Schedule: keylen is 16, 24, or 32, iv is 8 bytes or NULL
  void encrypt(U32 s0, U32 s1, U32 s2, U32 s3, unsigned char* ct);
  void encrypt(char* buf, int n, U64 offset);  // encrypt n bytes of buf
};

//////////////////////////// stretchKey //////////////////////

// Strengthen password pw[0..pwlen-1] and salt[0..saltlen-1]
// to produce key buf[0..buflen-1]. Uses O(n*r*p) time and 128*r*n bytes
// of memory. n must be a power of 2 and r <= 8.
void scrypt(const char* pw, int pwlen,
            const char* salt, int saltlen,
            int n, int r, int p, char* buf, int buflen);

// Generate a strong key out[0..31] key[0..31] and salt[0..31].
// Calls scrypt(key, 32, salt, 32, 16384, 8, 1, out, 32);
void stretchKey(char* out, const char* key, const char* salt);

//////////////////////////// random //////////////////////////

// Fill buf[0..n-1] with n cryptographic random bytes. The first
// byte is never '7' or 'z'.
void random(char* buf, int n);

//////////////////////////// ZPAQL ///////////////////////////

// Symbolic constants, instruction size, and names
typedef enum {NONE,CONS,CM,ICM,MATCH,AVG,MIX2,MIX,ISSE,SSE} CompType;
extern const int compsize[256];
class Decoder;  // forward

// A ZPAQL machine COMP+HCOMP or PCOMP.
class ZPAQL {
public:
  ZPAQL();
  ~ZPAQL();
  void clear();           // Free memory, erase program, reset machine state
  void inith();           // Initialize as HCOMP to run
  void initp();           // Initialize as PCOMP to run
  double memory();        // Return memory requirement in bytes
  void run(U32 input);    // Execute with input
  int read(Reader* in2);  // Read header
  bool write(Writer* out2, bool pp); // If pp write PCOMP else HCOMP header
  int step(U32 input, int mode);  // Trace execution (defined externally)

  Writer* output;         // Destination for OUT instruction, or 0 to suppress
  SHA1* sha1;             // Points to checksum computer
  U32 H(int i) {return h(i);}  // get element of h

  void flush();           // write outbuf[0..bufptr-1] to output and sha1
  void outc(int ch) {     // output byte ch (0..255) or -1 at EOS
    if (ch<0 || (outbuf[bufptr]=ch, ++bufptr==outbuf.isize())) flush();
  }

  // ZPAQ1 block header
  Array<U8> header;   // hsize[2] hh hm ph pm n COMP (guard) HCOMP (guard)
  int cend;           // COMP in header[7...cend-1]
  int hbegin, hend;   // HCOMP/PCOMP in header[hbegin...hend-1]

private:
  // Machine state for executing HCOMP
  Array<U8> m;        // memory array M for HCOMP
  Array<U32> h;       // hash array H for HCOMP
  Array<U32> r;       // 256 element register array
  Array<char> outbuf; // output buffer
  int bufptr;         // number of bytes in outbuf
  U32 a, b, c, d;     // machine registers
  int f;              // condition flag
  int pc;             // program counter
  int rcode_size;     // length of rcode
  U8* rcode;          // JIT code for run()

  // Support code
  int assemble();  // put JIT code in rcode
  void init(int hbits, int mbits);  // initialize H and M sizes
  int execute();  // interpret 1 instruction, return 0 after HALT, else 1
  void run0(U32 input);  // default run() if not JIT
  void div(U32 x) {if (x) a/=x; else a=0;}
  void mod(U32 x) {if (x) a%=x; else a=0;}
  void swap(U32& x) {a^=x; x^=a; a^=x;}
  void swap(U8& x)  {a^=x; x^=a; a^=x;}
  void err();  // exit with run time error
};

///////////////////////// Component //////////////////////////

// A Component is a context model, indirect context model, match model,
// fixed weight mixer, adaptive 2 input mixer without or with current
// partial byte as context, adaptive m input mixer (without or with),
// or SSE (without or with).

struct Component {
  size_t limit;   // max count for cm
  size_t cxt;     // saved context
  size_t a, b, c; // multi-purpose variables
  Array<U32> cm;  // cm[cxt] -> p in bits 31..10, n in 9..0; MATCH index
  Array<U8> ht;   // ICM/ISSE hash table[0..size1][0..15] and MATCH buf
  Array<U16> a16; // MIX weights
  void init();    // initialize to all 0
  Component() {init();}
};

////////////////////////// StateTable ////////////////////////

// Next state table
class StateTable {
public:
  U8 ns[1024]; // state*4 -> next state if 0, if 1, n0, n1
  int next(int state, int y) {  // next state for bit y
    assert(state>=0 && state<256);
    assert(y>=0 && y<4);
    return ns[state*4+y];
  }
  int cminit(int state) {  // initial probability of 1 * 2^23
    assert(state>=0 && state<256);
    return ((ns[state*4+3]*2+1)<<22)/(ns[state*4+2]+ns[state*4+3]+1);
  }
  StateTable();
};

///////////////////////// Predictor //////////////////////////

// A predictor guesses the next bit
class Predictor {
public:
  Predictor(ZPAQL&);
  ~Predictor();
  void init();          // build model
  int predict();        // probability that next bit is a 1 (0..4095)
  void update(int y);   // train on bit y (0..1)
  int stat(int);        // Defined externally
  bool isModeled() {    // n>0 components?
    assert(z.header.isize()>6);
    return z.header[6]!=0;
  }
private:

  // Predictor state
  int c8;               // last 0...7 bits.
  int hmap4;            // c8 split into nibbles
  int p[256];           // predictions
  U32 h[256];           // unrolled copy of z.h
  ZPAQL& z;             // VM to compute context hashes, includes H, n
  Component comp[256];  // the model, includes P
  bool initTables;      // are tables initialized?

  // Modeling support functions
  int predict0();       // default
  void update0(int y);  // default
  int dt2k[256];        // division table for match: dt2k[i] = 2^12/i
  int dt[1024];         // division table for cm: dt[i] = 2^16/(i+1.5)
  U16 squasht[4096];    // squash() lookup table
  short stretcht[32768];// stretch() lookup table
  StateTable st;        // next, cminit functions
  U8* pcode;            // JIT code for predict() and update()
  int pcode_size;       // length of pcode

  // reduce prediction error in cr.cm
  void train(Component& cr, int y) {
    assert(y==0 || y==1);
    U32& pn=cr.cm(cr.cxt);
    U32 count=pn&0x3ff;
    int error=y*32767-(cr.cm(cr.cxt)>>17);
    pn+=(error*dt[count]&-1024)+(count<cr.limit);
  }

  // x -> floor(32768/(1+exp(-x/64)))
  int squash(int x) {
    assert(initTables);
    assert(x>=-2048 && x<=2047);
    return squasht[x+2048];
  }

  // x -> round(64*log((x+0.5)/(32767.5-x))), approx inverse of squash
  int stretch(int x) {
    assert(initTables);
    assert(x>=0 && x<=32767);
    return stretcht[x];
  }

  // bound x to a 12 bit signed int
  int clamp2k(int x) {
    if (x<-2048) return -2048;
    else if (x>2047) return 2047;
    else return x;
  }

  // bound x to a 20 bit signed int
  int clamp512k(int x) {
    if (x<-(1<<19)) return -(1<<19);
    else if (x>=(1<<19)) return (1<<19)-1;
    else return x;
  }

  // Get cxt in ht, creating a new row if needed
  size_t find(Array<U8>& ht, int sizebits, U32 cxt);

  // Put JIT code in pcode
  int assemble_p();
};

//////////////////////////// Decoder /////////////////////////

// Decoder decompresses using an arithmetic code
class Decoder: public Reader {
public:
  Reader* in;        // destination
  Decoder(ZPAQL& z);
  int decompress();  // return a byte or EOF
  int skip();        // skip to the end of the segment, return next byte
  void init();       // initialize at start of block
  int stat(int x) {return pr.stat(x);}
  int get() {        // return 1 byte of buffered input or EOF
    if (rpos==wpos) {
      rpos=0;
      wpos=in ? in->read(&buf[0], BUFSIZE) : 0;
      assert(wpos<=BUFSIZE);
    }
    return rpos<wpos ? U8(buf[rpos++]) : -1;
  }
  int buffered() {return wpos-rpos;}  // how far read ahead?
private:
  U32 low, high;     // range
  U32 curr;          // last 4 bytes of archive or remaining bytes in subblock
  U32 rpos, wpos;    // read, write position in buf
  Predictor pr;      // to get p
  enum {BUFSIZE=1<<16};
  Array<char> buf;   // input buffer of size BUFSIZE bytes
  int decode(int p); // return decoded bit (0..1) with prob. p (0..65535)
};

/////////////////////////// PostProcessor ////////////////////

class PostProcessor {
  int state;   // input parse state: 0=INIT, 1=PASS, 2..4=loading, 5=POST
  int hsize;   // header size
  int ph, pm;  // sizes of H and M in z
public:
  ZPAQL z;     // holds PCOMP
  PostProcessor(): state(0), hsize(0), ph(0), pm(0) {}
  void init(int h, int m);  // ph, pm sizes of H and M
  int write(int c);  // Input a byte, return state
  int getState() const {return state;}
  void setOutput(Writer* out) {z.output=out;}
  void setSHA1(SHA1* sha1ptr) {z.sha1=sha1ptr;}
};

//////////////////////// Decompresser ////////////////////////

// For decompression and listing archive contents
class Decompresser {
public:
  Decompresser(): z(), dec(z), pp(), state(BLOCK), decode_state(FIRSTSEG) {}
  void setInput(Reader* in) {dec.in=in;}
  bool findBlock(double* memptr = 0);
  void hcomp(Writer* out2) {z.write(out2, false);}
  bool findFilename(Writer* = 0);
  void readComment(Writer* = 0);
  void setOutput(Writer* out) {pp.setOutput(out);}
  void setSHA1(SHA1* sha1ptr) {pp.setSHA1(sha1ptr);}
  bool decompress(int n = -1);  // n bytes, -1=all, return true until done
  bool pcomp(Writer* out2) {return pp.z.write(out2, true);}
  void readSegmentEnd(char* sha1string = 0);
  int stat(int x) {return dec.stat(x);}
  int buffered() {return dec.buffered();}
private:
  ZPAQL z;
  Decoder dec;
  PostProcessor pp;
  enum {BLOCK, FILENAME, COMMENT, DATA, SEGEND} state;  // expected next
  enum {FIRSTSEG, SEG, SKIP} decode_state;  // which segment in block?
};

/////////////////////////// decompress() /////////////////////

void decompress(Reader* in, Writer* out);

//////////////////////////// Encoder /////////////////////////

// Encoder compresses using an arithmetic code
class Encoder {
public:
  Encoder(ZPAQL& z):
    out(0), low(1), high(0xFFFFFFFF), pr(z) {}
  void init();
  void compress(int c);  // c is 0..255 or EOF
  int stat(int x) {return pr.stat(x);}
  Writer* out;  // destination
private:
  U32 low, high; // range
  Predictor pr;  // to get p
  Array<char> buf; // unmodeled input
  void encode(int y, int p); // encode bit y (0..1) with prob. p (0..65535)
};

//////////////////////////// Compiler ////////////////////////

// Input ZPAQL source code with args and store the compiled code
// in hz and pz and write pcomp_cmd to out2.

class Compiler {
public:
  Compiler(const char* in, int* args, ZPAQL& hz, ZPAQL& pz, Writer* out2);
private:
  const char* in;  // ZPAQL source code
  int* args;       // Array of up to 9 args, default NULL = all 0
  ZPAQL& hz;       // Output of COMP and HCOMP sections
  ZPAQL& pz;       // Output of PCOMP section
  Writer* out2;    // Output ... of "PCOMP ... ;"
  int line;        // Input line number for reporting errors
  int state;       // parse state: 0=space -1=word >0 (nest level)

  // Symbolic constants
  typedef enum {NONE,CONS,CM,ICM,MATCH,AVG,MIX2,MIX,ISSE,SSE,
    JT=39,JF=47,JMP=63,LJ=255,
    POST=256,PCOMP,END,IF,IFNOT,ELSE,ENDIF,DO,
    WHILE,UNTIL,FOREVER,IFL,IFNOTL,ELSEL,SEMICOLON} CompType;

  void syntaxError(const char* msg, const char* expected=0); // error()
  void next();                     // advance in to next token
  bool matchToken(const char* tok);// in==token?
  int rtoken(int low, int high);   // return token which must be in range
  int rtoken(const char* list[]);  // return token by position in list
  void rtoken(const char* s);      // return token which must be s
  int compile_comp(ZPAQL& z);      // compile either HCOMP or PCOMP

  // Stack of n elements
  class Stack {
    libzpaq::Array<U16> s;
    size_t top;
  public:
    Stack(int n): s(n), top(0) {}
    void push(const U16& x) {
      if (top>=s.size()) error("IF or DO nested too deep");
      s[top++]=x;
    }
    U16 pop() {
      if (top<=0) error("unmatched IF or DO");
      return s[--top];
    }
  };

  Stack if_stack, do_stack;
};

//////////////////////// Compressor //////////////////////////

class Compressor {
public:
  Compressor(): enc(z), in(0), state(INIT), verify(false) {}
  void setOutput(Writer* out) {enc.out=out;}
  void writeTag();
  void startBlock(int level);  // level=1,2,3
  void startBlock(const char* hcomp);     // ZPAQL byte code
  void startBlock(const char* config,     // ZPAQL source code
                  int* args,              // NULL or int[9] arguments
                  Writer* pcomp_cmd = 0); // retrieve preprocessor command
  void setVerify(bool v) {verify = v;}    // check postprocessing?
  void hcomp(Writer* out2) {z.write(out2, false);}
  bool pcomp(Writer* out2) {return pz.write(out2, true);}
  void startSegment(const char* filename = 0, const char* comment = 0);
  void setInput(Reader* i) {in=i;}
  void postProcess(const char* pcomp = 0, int len = 0);  // byte code
  bool compress(int n = -1);  // n bytes, -1=all, return true until done
  void endSegment(const char* sha1string = 0);
  char* endSegmentChecksum(int64_t* size = 0, bool dosha1=true);
  int64_t getSize() {return sha1.usize();}
  const char* getChecksum() {return sha1.result();}
  void endBlock();
  int stat(int x) {return enc.stat(x);}
private:
  ZPAQL z, pz;  // model and test postprocessor
  Encoder enc;  // arithmetic encoder containing predictor
  Reader* in;   // input source
  SHA1 sha1;    // to test pz output
  char sha1result[20];  // sha1 output
  enum {INIT, BLOCK1, SEG1, BLOCK2, SEG2} state;
  bool verify;  // if true then test by postprocessing
};

/////////////////////////// StringBuffer /////////////////////

// For (de)compressing to/from a string. Writing appends bytes
// which can be later read.
class StringBuffer: public libzpaq::Reader, public libzpaq::Writer {
  unsigned char* p;  // allocated memory, not NUL terminated, may be NULL
  size_t al;         // number of bytes allocated, 0 iff p is NULL
  size_t wpos;       // index of next byte to write, wpos <= al
  size_t rpos;       // index of next byte to read, rpos < wpos or return EOF.
  size_t limit;      // max size, default = -1
  const size_t init; // initial size on first use after reset

  // Increase capacity to a without changing size
  void reserve(size_t a) {
    assert(!al==!p);
    if (a<=al) return;
    unsigned char* q=0;
    if (a>0) q=(unsigned char*)(p ? realloc(p, a) : malloc(a));
    if (a>0 && !q) error("Out of memory");
    p=q;
    al=a;
  }

  // Enlarge al to make room to write at least n bytes.
  void lengthen(size_t n) {
    assert(wpos<=al);
    if (wpos+n>limit || wpos+n<wpos) error("StringBuffer overflow");
    if (wpos+n<=al) return;
    size_t a=al;
    while (wpos+n>=a) a=a*2+init;
    reserve(a);
  }

  // No assignment or copy
  void operator=(const StringBuffer&);
  StringBuffer(const StringBuffer&);

public:

  // Direct access to data
  unsigned char* data() {assert(p || wpos==0); return p;}

  // Allocate no memory initially
  StringBuffer(size_t n=0):
      p(0), al(0), wpos(0), rpos(0), limit(size_t(-1)), init(n>128?n:128) {}

  // Set output limit
  void setLimit(size_t n) {limit=n;}

  // Free memory
  ~StringBuffer() {if (p) free(p);}

  // Return number of bytes written.
  size_t size() const {return wpos;}

  // Return number of bytes left to read
  size_t remaining() const {return wpos-rpos;}

  // Reset size to 0 and free memory.
  void reset() {
    if (p) free(p);
    p=0;
    al=rpos=wpos=0;
  }

  // Write a single byte.
  void put(int c) {  // write 1 byte
    lengthen(1);
    assert(p);
    assert(wpos<al);
    p[wpos++]=c;
    assert(wpos<=al);
  }

  // Write buf[0..n-1]. If buf is NULL then advance write pointer only.
  void write(const char* buf, int n) {
    if (n<1) return;
    lengthen(n);
    assert(p);
    assert(wpos+n<=al);
    if (buf) memcpy(p+wpos, buf, n);
    wpos+=n;
  }

  // Read a single byte. Return EOF (-1) at end.
  int get() {
    assert(rpos<=wpos);
    assert(rpos==wpos || p);
    return rpos<wpos ? p[rpos++] : -1;
  }

  // Read up to n bytes into buf[0..] or fewer if EOF is first.
  // Return the number of bytes actually read.
  // If buf is NULL then advance read pointer without reading.
  int read(char* buf, int n) {
    assert(rpos<=wpos);
    assert(wpos<=al);
    assert(!al==!p);
    if (rpos+n>wpos) n=wpos-rpos;
    if (n>0 && buf) memcpy(buf, p+rpos, n);
    rpos+=n;
    return n;
  }

  // Return the entire string as a read-only array.
  const char* c_str() const {return (const char*)p;}

  // Truncate the string to size i.
  void resize(size_t i) {
    wpos=i;
    if (rpos>wpos) rpos=wpos;
  }

  // Swap efficiently (init is not swapped)
  void swap(StringBuffer& s) {
    std::swap(p, s.p);
    std::swap(al, s.al);
    std::swap(wpos, s.wpos);
    std::swap(rpos, s.rpos);
    std::swap(limit, s.limit);
  }
};

/////////////////////////// compress() ///////////////////////

// Compress in to out in multiple blocks. Default method is "14,128,0"
// Default filename is "". Comment is appended to input size.
// dosha1 means save the SHA-1 checksum.
void compress(Reader* in, Writer* out, const char* method,
     const char* filename=0, const char* comment=0, bool dosha1=true);

// Same as compress() but output is 1 block, ignoring block size parameter.
void compressBlock(StringBuffer* in, Writer* out, const char* method,
     const char* filename=0, const char* comment=0, bool dosha1=true);


// Read 16 bit little-endian number
int toU16(const char* p) {
  return (p[0]&255)+256*(p[1]&255);
}

// Default read() and write()
int Reader::read(char* buf, int n) {
  int i=0, c;
  while (i<n && (c=get())>=0)
    buf[i++]=c;
  return i;
}

void Writer::write(const char* buf, int n) {
  for (int i=0; i<n; ++i)
    put(U8(buf[i]));
}

///////////////////////// allocx //////////////////////

// Allocate newsize > 0 bytes of executable memory and update
// p to point to it and newsize = n. Free any previously
// allocated memory first. If newsize is 0 then free only.
// Call error in case of failure. If NOJIT, ignore newsize
// and set p=0, n=0 without allocating memory.
void allocx(U8* &p, int &n, int newsize) {
#ifdef NOJIT
  p=0;
  n=0;
#else
  if (p || n) {
    if (p)
#ifdef unix
      munmap(p, n);
#else // Windows
      VirtualFree(p, 0, MEM_RELEASE);
#endif
    p=0;
    n=0;
  }
  if (newsize>0) {
#ifdef unix
    p=(U8*)mmap(0, newsize, PROT_READ|PROT_WRITE|PROT_EXEC,
                MAP_PRIVATE|MAP_ANON, -1, 0);
    if ((void*)p==MAP_FAILED) p=0;
#else
    p=(U8*)VirtualAlloc(0, newsize, MEM_RESERVE|MEM_COMMIT,
                        PAGE_EXECUTE_READWRITE);
#endif
    if (p)
      n=newsize;
    else {
      n=0;
      error("allocx failed");
    }
  }
#endif
}




//////////////////////////// SHA256 //////////////////////////

void SHA256::init() {
  len0=len1=0;
  s[0]=0x6a09e667;
  s[1]=0xbb67ae85;
  s[2]=0x3c6ef372;
  s[3]=0xa54ff53a;
  s[4]=0x510e527f;
  s[5]=0x9b05688c;
  s[6]=0x1f83d9ab;
  s[7]=0x5be0cd19;
  memset(w, 0, sizeof(w));
}

void SHA256::process() {

  #define ror(a,b) ((a)>>(b)|(a<<(32-(b))))

  #define m(i) \
     w[(i)&15]+=w[(i-7)&15] \
       +(ror(w[(i-15)&15],7)^ror(w[(i-15)&15],18)^(w[(i-15)&15]>>3)) \
       +(ror(w[(i-2)&15],17)^ror(w[(i-2)&15],19)^(w[(i-2)&15]>>10))

  #define r(a,b,c,d,e,f,g,h,i) { \
    unsigned t1=ror(e,14)^e; \
    t1=ror(t1,5)^e; \
    h+=ror(t1,6)+((e&f)^(~e&g))+k[i]+w[(i)&15]; } \
    d+=h; \
    {unsigned t1=ror(a,9)^a; \
    t1=ror(t1,11)^a; \
    h+=ror(t1,2)+((a&b)^(c&(a^b))); }

  #define mr(a,b,c,d,e,f,g,h,i) m(i); r(a,b,c,d,e,f,g,h,i);

  #define r8(i) \
    r(a,b,c,d,e,f,g,h,i);   \
    r(h,a,b,c,d,e,f,g,i+1); \
    r(g,h,a,b,c,d,e,f,i+2); \
    r(f,g,h,a,b,c,d,e,i+3); \
    r(e,f,g,h,a,b,c,d,i+4); \
    r(d,e,f,g,h,a,b,c,i+5); \
    r(c,d,e,f,g,h,a,b,i+6); \
    r(b,c,d,e,f,g,h,a,i+7);

  #define mr8(i) \
    mr(a,b,c,d,e,f,g,h,i);   \
    mr(h,a,b,c,d,e,f,g,i+1); \
    mr(g,h,a,b,c,d,e,f,i+2); \
    mr(f,g,h,a,b,c,d,e,i+3); \
    mr(e,f,g,h,a,b,c,d,i+4); \
    mr(d,e,f,g,h,a,b,c,i+5); \
    mr(c,d,e,f,g,h,a,b,i+6); \
    mr(b,c,d,e,f,g,h,a,i+7);

  static const unsigned k[64]={
    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5,
    0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
    0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3,
    0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
    0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc,
    0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
    0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7,
    0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
    0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13,
    0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
    0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3,
    0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
    0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5,
    0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
    0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,
    0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2};

  unsigned a=s[0];
  unsigned b=s[1];
  unsigned c=s[2];
  unsigned d=s[3];
  unsigned e=s[4];
  unsigned f=s[5];
  unsigned g=s[6];
  unsigned h=s[7];

  r8(0);
  r8(8);
  mr8(16);
  mr8(24);
  mr8(32);
  mr8(40);
  mr8(48);
  mr8(56);

  s[0]+=a;
  s[1]+=b;
  s[2]+=c;
  s[3]+=d;
  s[4]+=e;
  s[5]+=f;
  s[6]+=g;
  s[7]+=h;

  #undef mr8
  #undef r8
  #undef mr
  #undef r
  #undef m
  #undef ror
}

// Return old result and start a new hash
const char* SHA256::result() {

  // pad and append length
  const unsigned s1=len1, s0=len0;
  put(0x80);
  while ((len0&511)!=448) put(0);
  put(s1>>24);
  put(s1>>16);
  put(s1>>8);
  put(s1);
  put(s0>>24);
  put(s0>>16);
  put(s0>>8);
  put(s0);

  // copy s to hbuf
  for (unsigned int i=0; i<8; ++i) {
    hbuf[4*i]=s[i]>>24;
    hbuf[4*i+1]=s[i]>>16;
    hbuf[4*i+2]=s[i]>>8;
    hbuf[4*i+3]=s[i];
  }

  // return hash prior to clearing state
  init();
  return hbuf;
}

void SHA256::write(const char* buf, int64_t n) 
{
	for (int64_t i=0;i<n;i++)
		put(*(buf+i));
}


//////////////////////////// AES /////////////////////////////

// Some AES code is derived from libtomcrypt 1.17 (public domain).

#define Te4_0 0x000000FF & Te4
#define Te4_1 0x0000FF00 & Te4
#define Te4_2 0x00FF0000 & Te4
#define Te4_3 0xFF000000 & Te4

// Extract byte n of x
static inline unsigned byte(unsigned x, unsigned n) {return (x>>(8*n))&255;}

// x = y[0..3] MSB first
static inline void LOAD32H(U32& x, const char* y) {
  const unsigned char* u=(const unsigned char*)y;
  x=u[0]<<24|u[1]<<16|u[2]<<8|u[3];
}

// y[0..3] = x MSB first
static inline void STORE32H(U32& x, unsigned char* y) {
  y[0]=x>>24;
  y[1]=x>>16;
  y[2]=x>>8;
  y[3]=x;
}

#define setup_mix(temp) \
  ((Te4_3[byte(temp, 2)]) ^ (Te4_2[byte(temp, 1)]) ^ \
   (Te4_1[byte(temp, 0)]) ^ (Te4_0[byte(temp, 3)]))

// Initialize encryption tables and round key. keylen is 16, 24, or 32.
AES_CTR::AES_CTR(const char* key, int keylen, const char* iv) {
  assert(key  != NULL);
  assert(keylen==16 || keylen==24 || keylen==32);

  // Initialize IV (default 0)
  iv0=iv1=0;
  if (iv) {
    LOAD32H(iv0, iv);
    LOAD32H(iv1, iv+4);
  }

  // Initialize encryption tables
  for (unsigned int i=0; i<256; ++i) {
    unsigned s1=
    "\x63\x7c\x77\x7b\xf2\x6b\x6f\xc5\x30\x01\x67\x2b\xfe\xd7\xab\x76"
    "\xca\x82\xc9\x7d\xfa\x59\x47\xf0\xad\xd4\xa2\xaf\x9c\xa4\x72\xc0"
    "\xb7\xfd\x93\x26\x36\x3f\xf7\xcc\x34\xa5\xe5\xf1\x71\xd8\x31\x15"
    "\x04\xc7\x23\xc3\x18\x96\x05\x9a\x07\x12\x80\xe2\xeb\x27\xb2\x75"
    "\x09\x83\x2c\x1a\x1b\x6e\x5a\xa0\x52\x3b\xd6\xb3\x29\xe3\x2f\x84"
    "\x53\xd1\x00\xed\x20\xfc\xb1\x5b\x6a\xcb\xbe\x39\x4a\x4c\x58\xcf"
    "\xd0\xef\xaa\xfb\x43\x4d\x33\x85\x45\xf9\x02\x7f\x50\x3c\x9f\xa8"
    "\x51\xa3\x40\x8f\x92\x9d\x38\xf5\xbc\xb6\xda\x21\x10\xff\xf3\xd2"
    "\xcd\x0c\x13\xec\x5f\x97\x44\x17\xc4\xa7\x7e\x3d\x64\x5d\x19\x73"
    "\x60\x81\x4f\xdc\x22\x2a\x90\x88\x46\xee\xb8\x14\xde\x5e\x0b\xdb"
    "\xe0\x32\x3a\x0a\x49\x06\x24\x5c\xc2\xd3\xac\x62\x91\x95\xe4\x79"
    "\xe7\xc8\x37\x6d\x8d\xd5\x4e\xa9\x6c\x56\xf4\xea\x65\x7a\xae\x08"
    "\xba\x78\x25\x2e\x1c\xa6\xb4\xc6\xe8\xdd\x74\x1f\x4b\xbd\x8b\x8a"
    "\x70\x3e\xb5\x66\x48\x03\xf6\x0e\x61\x35\x57\xb9\x86\xc1\x1d\x9e"
    "\xe1\xf8\x98\x11\x69\xd9\x8e\x94\x9b\x1e\x87\xe9\xce\x55\x28\xdf"
    "\x8c\xa1\x89\x0d\xbf\xe6\x42\x68\x41\x99\x2d\x0f\xb0\x54\xbb\x16"
    [i]&255;
    unsigned s2=s1<<1;
    if (s2>=0x100) s2^=0x11b;
    unsigned s3=s1^s2;
    Te0[i]=s2<<24|s1<<16|s1<<8|s3;
    Te1[i]=s3<<24|s2<<16|s1<<8|s1;
    Te2[i]=s1<<24|s3<<16|s2<<8|s1;
    Te3[i]=s1<<24|s1<<16|s3<<8|s2;
    Te4[i]=s1<<24|s1<<16|s1<<8|s1;
  }

  // setup the forward key
  Nr = 10 + ((keylen/8)-2)*2;  // 10, 12, or 14 rounds
  int i = 0;
  U32* rk = &ek[0];
  U32 temp;
  static const U32 rcon[10] = {
    0x01000000UL, 0x02000000UL, 0x04000000UL, 0x08000000UL,
    0x10000000UL, 0x20000000UL, 0x40000000UL, 0x80000000UL,
    0x1B000000UL, 0x36000000UL};  // round constants

  LOAD32H(rk[0], key   );
  LOAD32H(rk[1], key +  4);
  LOAD32H(rk[2], key +  8);
  LOAD32H(rk[3], key + 12);
  if (keylen == 16) {
    for (;;) {
      temp  = rk[3];
      rk[4] = rk[0] ^ setup_mix(temp) ^ rcon[i];
      rk[5] = rk[1] ^ rk[4];
      rk[6] = rk[2] ^ rk[5];
      rk[7] = rk[3] ^ rk[6];
      if (++i == 10) {
         break;
      }
      rk += 4;
    }
  }
  else if (keylen == 24) {
    LOAD32H(rk[4], key + 16);
    LOAD32H(rk[5], key + 20);
    for (;;) {
      temp = rk[5];
      rk[ 6] = rk[ 0] ^ setup_mix(temp) ^ rcon[i];
      rk[ 7] = rk[ 1] ^ rk[ 6];
      rk[ 8] = rk[ 2] ^ rk[ 7];
      rk[ 9] = rk[ 3] ^ rk[ 8];
      if (++i == 8) {
        break;
      }
      rk[10] = rk[ 4] ^ rk[ 9];
      rk[11] = rk[ 5] ^ rk[10];
      rk += 6;
    }
  }
  else if (keylen == 32) {
    LOAD32H(rk[4], key + 16);
    LOAD32H(rk[5], key + 20);
    LOAD32H(rk[6], key + 24);
    LOAD32H(rk[7], key + 28);
    for (;;) {
      temp = rk[7];
      rk[ 8] = rk[ 0] ^ setup_mix(temp) ^ rcon[i];
      rk[ 9] = rk[ 1] ^ rk[ 8];
      rk[10] = rk[ 2] ^ rk[ 9];
      rk[11] = rk[ 3] ^ rk[10];
      if (++i == 7) {
        break;
      }
      temp = rk[11];
      rk[12] = rk[ 4] ^ setup_mix(temp<<24|temp>>8);
      rk[13] = rk[ 5] ^ rk[12];
      rk[14] = rk[ 6] ^ rk[13];
      rk[15] = rk[ 7] ^ rk[14];
      rk += 8;
    }
  }
}

// Encrypt to ct[16]
void AES_CTR::encrypt(U32 s0, U32 s1, U32 s2, U32 s3, unsigned char* ct) {
  int r = Nr >> 1;
  U32 *rk = &ek[0];
  U32 t0=0, t1=0, t2=0, t3=0;
  s0 ^= rk[0];
  s1 ^= rk[1];
  s2 ^= rk[2];
  s3 ^= rk[3];
  for (;;) {
    t0 =
      Te0[byte(s0, 3)] ^
      Te1[byte(s1, 2)] ^
      Te2[byte(s2, 1)] ^
      Te3[byte(s3, 0)] ^
      rk[4];
    t1 =
      Te0[byte(s1, 3)] ^
      Te1[byte(s2, 2)] ^
      Te2[byte(s3, 1)] ^
      Te3[byte(s0, 0)] ^
      rk[5];
    t2 =
      Te0[byte(s2, 3)] ^
      Te1[byte(s3, 2)] ^
      Te2[byte(s0, 1)] ^
      Te3[byte(s1, 0)] ^
      rk[6];
    t3 =
      Te0[byte(s3, 3)] ^
      Te1[byte(s0, 2)] ^
      Te2[byte(s1, 1)] ^
      Te3[byte(s2, 0)] ^
      rk[7];

    rk += 8;
    if (--r == 0) {
      break;
    }

    s0 =
      Te0[byte(t0, 3)] ^
      Te1[byte(t1, 2)] ^
      Te2[byte(t2, 1)] ^
      Te3[byte(t3, 0)] ^
      rk[0];
    s1 =
      Te0[byte(t1, 3)] ^
      Te1[byte(t2, 2)] ^
      Te2[byte(t3, 1)] ^
      Te3[byte(t0, 0)] ^
      rk[1];
    s2 =
      Te0[byte(t2, 3)] ^
      Te1[byte(t3, 2)] ^
      Te2[byte(t0, 1)] ^
      Te3[byte(t1, 0)] ^
      rk[2];
    s3 =
      Te0[byte(t3, 3)] ^
      Te1[byte(t0, 2)] ^
      Te2[byte(t1, 1)] ^
      Te3[byte(t2, 0)] ^
      rk[3];
  }

  // apply last round and map cipher state to byte array block:
  s0 =
    (Te4_3[byte(t0, 3)]) ^
    (Te4_2[byte(t1, 2)]) ^
    (Te4_1[byte(t2, 1)]) ^
    (Te4_0[byte(t3, 0)]) ^
    rk[0];
  STORE32H(s0, ct);
  s1 =
    (Te4_3[byte(t1, 3)]) ^
    (Te4_2[byte(t2, 2)]) ^
    (Te4_1[byte(t3, 1)]) ^
    (Te4_0[byte(t0, 0)]) ^
    rk[1];
  STORE32H(s1, ct+4);
  s2 =
    (Te4_3[byte(t2, 3)]) ^
    (Te4_2[byte(t3, 2)]) ^
    (Te4_1[byte(t0, 1)]) ^
    (Te4_0[byte(t1, 0)]) ^
    rk[2];
  STORE32H(s2, ct+8);
  s3 =
    (Te4_3[byte(t3, 3)]) ^
    (Te4_2[byte(t0, 2)]) ^
    (Te4_1[byte(t1, 1)]) ^
    (Te4_0[byte(t2, 0)]) ^ 
    rk[3];
  STORE32H(s3, ct+12);
}

// Encrypt or decrypt slice buf[0..n-1] at offset by XOR with AES(i) where
// i is the 128 bit big-endian distance from the start in 16 byte blocks.
void AES_CTR::encrypt(char* buf, int n, U64 offset) {
  for (U64 i=offset/16; i<=(offset+n)/16; ++i) {
    unsigned char ct[16];
    encrypt(iv0, iv1, i>>32, i, ct);
    for (int j=0; j<16; ++j) {
      const int k=i*16-offset+j;
      if (k>=0 && k<n)
        buf[k]^=ct[j];
    }
  }
}

#undef setup_mix
#undef Te4_3
#undef Te4_2
#undef Te4_1
#undef Te4_0

//////////////////////////// stretchKey //////////////////////

// PBKDF2(pw[0..pwlen], salt[0..saltlen], c) to buf[0..dkLen-1]
// using HMAC-SHA256, for the special case of c = 1 iterations
// output size dkLen a multiple of 32, and pwLen <= 64.
static void pbkdf2(const char* pw, int pwLen, const char* salt, int saltLen,
                    char* buf, int dkLen) {
  assert(dkLen%32==0);
  assert(pwLen<=64);

  libzpaq::SHA256 sha256;
  char b[32];
  for (int i=1; i*32<=dkLen; ++i) {
    for (int j=0; j<pwLen; ++j) sha256.put(pw[j]^0x36);
    for (int j=pwLen; j<64; ++j) sha256.put(0x36);
    for (int j=0; j<saltLen; ++j) sha256.put(salt[j]);
    for (int j=24; j>=0; j-=8) sha256.put(i>>j);
    memcpy(b, sha256.result(), 32);
    for (int j=0; j<pwLen; ++j) sha256.put(pw[j]^0x5c);
    for (int j=pwLen; j<64; ++j) sha256.put(0x5c);
    for (int j=0; j<32; ++j) sha256.put(b[j]);
    memcpy(buf+i*32-32, sha256.result(), 32);
  }
}

// Hash b[0..15] using 8 rounds of salsa20
// Modified from http://cr.yp.to/salsa20.html (public domain) to 8 rounds
static void salsa8(U32* b) {
  unsigned x[16]={0};
  memcpy(x, b, 64);
  for (unsigned int i=0; i<4; ++i) {
    #define R(a,b) (((a)<<(b))+((a)>>(32-b)))
    x[ 4] ^= R(x[ 0]+x[12], 7);  x[ 8] ^= R(x[ 4]+x[ 0], 9);
    x[12] ^= R(x[ 8]+x[ 4],13);  x[ 0] ^= R(x[12]+x[ 8],18);
    x[ 9] ^= R(x[ 5]+x[ 1], 7);  x[13] ^= R(x[ 9]+x[ 5], 9);
    x[ 1] ^= R(x[13]+x[ 9],13);  x[ 5] ^= R(x[ 1]+x[13],18);
    x[14] ^= R(x[10]+x[ 6], 7);  x[ 2] ^= R(x[14]+x[10], 9);
    x[ 6] ^= R(x[ 2]+x[14],13);  x[10] ^= R(x[ 6]+x[ 2],18);
    x[ 3] ^= R(x[15]+x[11], 7);  x[ 7] ^= R(x[ 3]+x[15], 9);
    x[11] ^= R(x[ 7]+x[ 3],13);  x[15] ^= R(x[11]+x[ 7],18);
    x[ 1] ^= R(x[ 0]+x[ 3], 7);  x[ 2] ^= R(x[ 1]+x[ 0], 9);
    x[ 3] ^= R(x[ 2]+x[ 1],13);  x[ 0] ^= R(x[ 3]+x[ 2],18);
    x[ 6] ^= R(x[ 5]+x[ 4], 7);  x[ 7] ^= R(x[ 6]+x[ 5], 9);
    x[ 4] ^= R(x[ 7]+x[ 6],13);  x[ 5] ^= R(x[ 4]+x[ 7],18);
    x[11] ^= R(x[10]+x[ 9], 7);  x[ 8] ^= R(x[11]+x[10], 9);
    x[ 9] ^= R(x[ 8]+x[11],13);  x[10] ^= R(x[ 9]+x[ 8],18);
    x[12] ^= R(x[15]+x[14], 7);  x[13] ^= R(x[12]+x[15], 9);
    x[14] ^= R(x[13]+x[12],13);  x[15] ^= R(x[14]+x[13],18);
    #undef R
  }
  for (unsigned int i=0; i<16; ++i) b[i]+=x[i];
}

// BlockMix_{Salsa20/8, r} on b[0..128*r-1]
static void blockmix(U32* b, int r) {
  assert(r<=8);
  U32 x[16];
  U32 y[256];
  memcpy(x, b+32*r-16, 64);
  for (int i=0; i<2*r; ++i) {
    for (int j=0; j<16; ++j) x[j]^=b[i*16+j];
    salsa8(x);
    memcpy(&y[i*16], x, 64);
  }
  for (int i=0; i<r; ++i) memcpy(b+i*16, &y[i*32], 64);
  for (int i=0; i<r; ++i) memcpy(b+(i+r)*16, &y[i*32+16], 64);
}

// Mix b[0..128*r-1]. Uses 128*r*n bytes of memory and O(r*n) time
static void smix(char* b, int r, int n) {
  libzpaq::Array<U32> x(32*r), v(32*r*n);
  for (int i=0; i<r*128; ++i) x[i/4]+=(b[i]&255)<<i%4*8;
  for (int i=0; i<n; ++i) {
    memcpy(&v[i*r*32], &x[0], r*128);
    blockmix(&x[0], r);
  }
  for (int i=0; i<n; ++i) {
    U32 j=x[(2*r-1)*16]&(n-1);
    for (int k=0; k<r*32; ++k) x[k]^=v[j*r*32+k];
    blockmix(&x[0], r);
  }
  for (int i=0; i<r*128; ++i) b[i]=x[i/4]>>(i%4*8);
}

// Strengthen password pw[0..pwlen-1] and salt[0..saltlen-1]
// to produce key buf[0..buflen-1]. Uses O(n*r*p) time and 128*r*n bytes
// of memory. n must be a power of 2 and r <= 8.
void scrypt(const char* pw, int pwlen,
            const char* salt, int saltlen,
            int n, int r, int p, char* buf, int buflen) {
  assert(r<=8);
  assert(n>0 && (n&(n-1))==0);  // power of 2?
  libzpaq::Array<char> b(p*r*128);
  pbkdf2(pw, pwlen, salt, saltlen,  &b[0], p*r*128);
  for (int i=0; i<p; ++i) smix(&b[i*r*128], r, n);
  pbkdf2(pw, pwlen, &b[0], p*r*128,  buf, buflen);
}

// Stretch key in[0..31], assumed to be SHA256(password), with
// NUL terminate salt to produce new key out[0..31]
void stretchKey(char* out, const char* in, const char* salt) {
  scrypt(in, 32, salt, 32, 1<<14, 8, 1, out, 32);
}

//////////////////////////// random //////////////////////////

// Put n cryptographic random bytes in buf[0..n-1].
// The first byte will not be 'z' or '7' (start of a ZPAQ archive).
// For a pure random number, discard the first byte.
// In VC++, must link to advapi32.lib.

void random(char* buf, int n) {
#ifdef unix
  FILE* in=fopen("/dev/urandom", "rb");
  if (in && int(fread(buf, 1, n, in))==n)
    fclose(in);
  else {
    error("key generation failed");
  }
#else
  HCRYPTPROV h;
  if (CryptAcquireContext(&h, NULL, NULL, PROV_RSA_FULL,
      CRYPT_VERIFYCONTEXT) && CryptGenRandom(h, n, (BYTE*)buf))
    CryptReleaseContext(h, 0);
  else {
    fprintf(stderr, "CryptGenRandom: error %d\n", int(GetLastError()));
    error("key generation failed");
  }
#endif
  if (n>=1 && (buf[0]=='z' || buf[0]=='7'))
    buf[0]^=0x80;
}

//////////////////////////// Component ///////////////////////

// A Component is a context model, indirect context model, match model,
// fixed weight mixer, adaptive 2 input mixer without or with current
// partial byte as context, adaptive m input mixer (without or with),
// or SSE (without or with).

const int compsize[256]={0,2,3,2,3,4,6,6,3,5};

void Component::init() {
  limit=cxt=a=b=c=0;
  cm.resize(0);
  ht.resize(0);
  a16.resize(0);
}

////////////////////////// StateTable ////////////////////////

// sns[i*4] -> next state if 0, next state if 1, n0, n1
static const U8 sns[1024]={
     1,     2,     0,     0,     3,     5,     1,     0,
     4,     6,     0,     1,     7,     9,     2,     0,
     8,    11,     1,     1,     8,    11,     1,     1,
    10,    12,     0,     2,    13,    15,     3,     0,
    14,    17,     2,     1,    14,    17,     2,     1,
    16,    19,     1,     2,    16,    19,     1,     2,
    18,    20,     0,     3,    21,    23,     4,     0,
    22,    25,     3,     1,    22,    25,     3,     1,
    24,    27,     2,     2,    24,    27,     2,     2,
    26,    29,     1,     3,    26,    29,     1,     3,
    28,    30,     0,     4,    31,    33,     5,     0,
    32,    35,     4,     1,    32,    35,     4,     1,
    34,    37,     3,     2,    34,    37,     3,     2,
    36,    39,     2,     3,    36,    39,     2,     3,
    38,    41,     1,     4,    38,    41,     1,     4,
    40,    42,     0,     5,    43,    33,     6,     0,
    44,    47,     5,     1,    44,    47,     5,     1,
    46,    49,     4,     2,    46,    49,     4,     2,
    48,    51,     3,     3,    48,    51,     3,     3,
    50,    53,     2,     4,    50,    53,     2,     4,
    52,    55,     1,     5,    52,    55,     1,     5,
    40,    56,     0,     6,    57,    45,     7,     0,
    58,    47,     6,     1,    58,    47,     6,     1,
    60,    63,     5,     2,    60,    63,     5,     2,
    62,    65,     4,     3,    62,    65,     4,     3,
    64,    67,     3,     4,    64,    67,     3,     4,
    66,    69,     2,     5,    66,    69,     2,     5,
    52,    71,     1,     6,    52,    71,     1,     6,
    54,    72,     0,     7,    73,    59,     8,     0,
    74,    61,     7,     1,    74,    61,     7,     1,
    76,    63,     6,     2,    76,    63,     6,     2,
    78,    81,     5,     3,    78,    81,     5,     3,
    80,    83,     4,     4,    80,    83,     4,     4,
    82,    85,     3,     5,    82,    85,     3,     5,
    66,    87,     2,     6,    66,    87,     2,     6,
    68,    89,     1,     7,    68,    89,     1,     7,
    70,    90,     0,     8,    91,    59,     9,     0,
    92,    77,     8,     1,    92,    77,     8,     1,
    94,    79,     7,     2,    94,    79,     7,     2,
    96,    81,     6,     3,    96,    81,     6,     3,
    98,   101,     5,     4,    98,   101,     5,     4,
   100,   103,     4,     5,   100,   103,     4,     5,
    82,   105,     3,     6,    82,   105,     3,     6,
    84,   107,     2,     7,    84,   107,     2,     7,
    86,   109,     1,     8,    86,   109,     1,     8,
    70,   110,     0,     9,   111,    59,    10,     0,
   112,    77,     9,     1,   112,    77,     9,     1,
   114,    97,     8,     2,   114,    97,     8,     2,
   116,    99,     7,     3,   116,    99,     7,     3,
    62,   101,     6,     4,    62,   101,     6,     4,
    80,    83,     5,     5,    80,    83,     5,     5,
   100,    67,     4,     6,   100,    67,     4,     6,
   102,   119,     3,     7,   102,   119,     3,     7,
   104,   121,     2,     8,   104,   121,     2,     8,
    86,   123,     1,     9,    86,   123,     1,     9,
    70,   124,     0,    10,   125,    59,    11,     0,
   126,    77,    10,     1,   126,    77,    10,     1,
   128,    97,     9,     2,   128,    97,     9,     2,
    60,    63,     8,     3,    60,    63,     8,     3,
    66,    69,     3,     8,    66,    69,     3,     8,
   104,   131,     2,     9,   104,   131,     2,     9,
    86,   133,     1,    10,    86,   133,     1,    10,
    70,   134,     0,    11,   135,    59,    12,     0,
   136,    77,    11,     1,   136,    77,    11,     1,
   138,    97,    10,     2,   138,    97,    10,     2,
   104,   141,     2,    10,   104,   141,     2,    10,
    86,   143,     1,    11,    86,   143,     1,    11,
    70,   144,     0,    12,   145,    59,    13,     0,
   146,    77,    12,     1,   146,    77,    12,     1,
   148,    97,    11,     2,   148,    97,    11,     2,
   104,   151,     2,    11,   104,   151,     2,    11,
    86,   153,     1,    12,    86,   153,     1,    12,
    70,   154,     0,    13,   155,    59,    14,     0,
   156,    77,    13,     1,   156,    77,    13,     1,
   158,    97,    12,     2,   158,    97,    12,     2,
   104,   161,     2,    12,   104,   161,     2,    12,
    86,   163,     1,    13,    86,   163,     1,    13,
    70,   164,     0,    14,   165,    59,    15,     0,
   166,    77,    14,     1,   166,    77,    14,     1,
   168,    97,    13,     2,   168,    97,    13,     2,
   104,   171,     2,    13,   104,   171,     2,    13,
    86,   173,     1,    14,    86,   173,     1,    14,
    70,   174,     0,    15,   175,    59,    16,     0,
   176,    77,    15,     1,   176,    77,    15,     1,
   178,    97,    14,     2,   178,    97,    14,     2,
   104,   181,     2,    14,   104,   181,     2,    14,
    86,   183,     1,    15,    86,   183,     1,    15,
    70,   184,     0,    16,   185,    59,    17,     0,
   186,    77,    16,     1,   186,    77,    16,     1,
    74,    97,    15,     2,    74,    97,    15,     2,
   104,    89,     2,    15,   104,    89,     2,    15,
    86,   187,     1,    16,    86,   187,     1,    16,
    70,   188,     0,    17,   189,    59,    18,     0,
   190,    77,    17,     1,    86,   191,     1,    17,
    70,   192,     0,    18,   193,    59,    19,     0,
   194,    77,    18,     1,    86,   195,     1,    18,
    70,   196,     0,    19,   193,    59,    20,     0,
   197,    77,    19,     1,    86,   198,     1,    19,
    70,   196,     0,    20,   199,    77,    20,     1,
    86,   200,     1,    20,   201,    77,    21,     1,
    86,   202,     1,    21,   203,    77,    22,     1,
    86,   204,     1,    22,   205,    77,    23,     1,
    86,   206,     1,    23,   207,    77,    24,     1,
    86,   208,     1,    24,   209,    77,    25,     1,
    86,   210,     1,    25,   211,    77,    26,     1,
    86,   212,     1,    26,   213,    77,    27,     1,
    86,   214,     1,    27,   215,    77,    28,     1,
    86,   216,     1,    28,   217,    77,    29,     1,
    86,   218,     1,    29,   219,    77,    30,     1,
    86,   220,     1,    30,   221,    77,    31,     1,
    86,   222,     1,    31,   223,    77,    32,     1,
    86,   224,     1,    32,   225,    77,    33,     1,
    86,   226,     1,    33,   227,    77,    34,     1,
    86,   228,     1,    34,   229,    77,    35,     1,
    86,   230,     1,    35,   231,    77,    36,     1,
    86,   232,     1,    36,   233,    77,    37,     1,
    86,   234,     1,    37,   235,    77,    38,     1,
    86,   236,     1,    38,   237,    77,    39,     1,
    86,   238,     1,    39,   239,    77,    40,     1,
    86,   240,     1,    40,   241,    77,    41,     1,
    86,   242,     1,    41,   243,    77,    42,     1,
    86,   244,     1,    42,   245,    77,    43,     1,
    86,   246,     1,    43,   247,    77,    44,     1,
    86,   248,     1,    44,   249,    77,    45,     1,
    86,   250,     1,    45,   251,    77,    46,     1,
    86,   252,     1,    46,   253,    77,    47,     1,
    86,   254,     1,    47,   253,    77,    48,     1,
    86,   254,     1,    48,     0,     0,     0,     0
};

// Initialize next state table ns[state*4] -> next if 0, next if 1, n0, n1
StateTable::StateTable() {
  memcpy(ns, sns, sizeof(ns));
}

/////////////////////////// ZPAQL //////////////////////////

// Write header to out2, return true if HCOMP/PCOMP section is present.
// If pp is true, then write only the postprocessor code.
bool ZPAQL::write(Writer* out2, bool pp) {
  if (header.size()<=6) return false;
  assert(header[0]+256*header[1]==cend-2+hend-hbegin);
  assert(cend>=7);
  assert(hbegin>=cend);
  assert(hend>=hbegin);
  assert(out2);
  if (!pp) {  // if not a postprocessor then write COMP
    for (int i=0; i<cend; ++i)
      out2->put(header[i]);
  }
  else {  // write PCOMP size only
    out2->put((hend-hbegin)&255);
    out2->put((hend-hbegin)>>8);
  }
  for (int i=hbegin; i<hend; ++i)
    out2->put(header[i]);
  return true;
}

// Read header from in2
int ZPAQL::read(Reader* in2) {

  // Get header size and allocate
  int hsize=in2->get();
  hsize+=in2->get()*256;
  header.resize(hsize+300);
  cend=hbegin=hend=0;
  header[cend++]=hsize&255;
  header[cend++]=hsize>>8;
  while (cend<7) header[cend++]=in2->get(); // hh hm ph pm n

  // Read COMP
  int n=header[cend-1];
  for (int i=0; i<n; ++i) {
    int type=in2->get();  // component type
    if (type<0 || type>255) error("unexpected end of file");
    header[cend++]=type;  // component type
    int size=compsize[type];
    if (size<1) error("Invalid component type");
    if (cend+size>hsize) error("COMP overflows header");
    for (int j=1; j<size; ++j)
      header[cend++]=in2->get();
  }
  if ((header[cend++]=in2->get())!=0) error("missing COMP END");

  // Insert a guard gap and read HCOMP
  hbegin=hend=cend+128;
  if (hend>hsize+129) error("missing HCOMP");
  while (hend<hsize+129) {
    assert(hend<header.isize()-8);
    int op=in2->get();
    if (op==-1) error("unexpected end of file");
    header[hend++]=op;
  }
  if ((header[hend++]=in2->get())!=0) error("missing HCOMP END");
  assert(cend>=7 && cend<header.isize());
  assert(hbegin==cend+128 && hbegin<header.isize());
  assert(hend>hbegin && hend<header.isize());
  assert(hsize==header[0]+256*header[1]);
  assert(hsize==cend-2+hend-hbegin);
  allocx(rcode, rcode_size, 0);  // clear JIT code
  return cend+hend-hbegin;
}

// Free memory, but preserve output, sha1 pointers
void ZPAQL::clear() {
  cend=hbegin=hend=0;  // COMP and HCOMP locations
  a=b=c=d=f=pc=0;      // machine state
  header.resize(0);
  h.resize(0);
  m.resize(0);
  r.resize(0);
  allocx(rcode, rcode_size, 0);
}

// Constructor
ZPAQL::ZPAQL() {
  output=0;
  sha1=0;
  rcode=0;
  rcode_size=0;
  clear();
  outbuf.resize(1<<14);
  bufptr=0;
}

ZPAQL::~ZPAQL() {
  allocx(rcode, rcode_size, 0);
}

// Initialize machine state as HCOMP
void ZPAQL::inith() {
  assert(header.isize()>6);
  assert(output==0);
  assert(sha1==0);
  init(header[2], header[3]); // hh, hm
}

// Initialize machine state as PCOMP
void ZPAQL::initp() {
  assert(header.isize()>6);
  init(header[4], header[5]); // ph, pm
}

// Flush pending output
void ZPAQL::flush() {
  if (output) output->write(&outbuf[0], bufptr);
  if (sha1) sha1->write(&outbuf[0], bufptr);
  bufptr=0;
}

// pow(2, x)
static double pow2(int x) {
  double r=1;
  for (; x>0; x--) r+=r;
  return r;
}

// Return memory requirement in bytes
double ZPAQL::memory() {
  double mem=pow2(header[2]+2)+pow2(header[3])  // hh hm
            +pow2(header[4]+2)+pow2(header[5])  // ph pm
            +header.size();
  int cp=7;  // start of comp list
  for (unsigned int i=0; i<header[6]; ++i) {  // n
    assert(cp<cend);
    double size=pow2(header[cp+1]); // sizebits
    switch(header[cp]) {
      case CM: mem+=4*size; break;
      case ICM: mem+=64*size+1024; break;
      case MATCH: mem+=4*size+pow2(header[cp+2]); break; // bufbits
      case MIX2: mem+=2*size; break;
      case MIX: mem+=4*size*header[cp+3]; break; // m
      case ISSE: mem+=64*size+2048; break;
      case SSE: mem+=128*size; break;
    }
    cp+=compsize[header[cp]];
  }
  return mem;
}

// Initialize machine state to run a program.
void ZPAQL::init(int hbits, int mbits) {
  assert(header.isize()>0);
  assert(cend>=7);
  assert(hbegin>=cend+128);
  assert(hend>=hbegin);
  assert(hend<header.isize()-130);
  assert(header[0]+256*header[1]==cend-2+hend-hbegin);
  assert(bufptr==0);
  assert(outbuf.isize()>0);
  if (hbits>32) error("H too big");
  if (mbits>32) error("M too big");
  h.resize(1, hbits);
  m.resize(1, mbits);
  r.resize(256);
  a=b=c=d=pc=f=0;
}

// Run program on input by interpreting header
void ZPAQL::run0(U32 input) {
  assert(cend>6);
  assert(hbegin>=cend+128);
  assert(hend>=hbegin);
  assert(hend<header.isize()-130);
  assert(m.size()>0);
  assert(h.size()>0);
  assert(header[0]+256*header[1]==cend+hend-hbegin-2);
  pc=hbegin;
  a=input;
  while (execute()) ;
}

// Execute one instruction, return 0 after HALT else 1
int ZPAQL::execute() {
  switch(header[pc++]) {
    case 0: err(); break; // ERROR
    case 1: ++a; break; // A++
    case 2: --a; break; // A--
    case 3: a = ~a; break; // A!
    case 4: a = 0; break; // A=0
    case 7: a = r[header[pc++]]; break; // A=R N
    case 8: swap(b); break; // B<>A
    case 9: ++b; break; // B++
    case 10: --b; break; // B--
    case 11: b = ~b; break; // B!
    case 12: b = 0; break; // B=0
    case 15: b = r[header[pc++]]; break; // B=R N
    case 16: swap(c); break; // C<>A
    case 17: ++c; break; // C++
    case 18: --c; break; // C--
    case 19: c = ~c; break; // C!
    case 20: c = 0; break; // C=0
    case 23: c = r[header[pc++]]; break; // C=R N
    case 24: swap(d); break; // D<>A
    case 25: ++d; break; // D++
    case 26: --d; break; // D--
    case 27: d = ~d; break; // D!
    case 28: d = 0; break; // D=0
    case 31: d = r[header[pc++]]; break; // D=R N
    case 32: swap(m(b)); break; // *B<>A
    case 33: ++m(b); break; // *B++
    case 34: --m(b); break; // *B--
    case 35: m(b) = ~m(b); break; // *B!
    case 36: m(b) = 0; break; // *B=0
    case 39: if (f) pc+=((header[pc]+128)&255)-127; else ++pc; break; // JT N
    case 40: swap(m(c)); break; // *C<>A
    case 41: ++m(c); break; // *C++
    case 42: --m(c); break; // *C--
    case 43: m(c) = ~m(c); break; // *C!
    case 44: m(c) = 0; break; // *C=0
    case 47: if (!f) pc+=((header[pc]+128)&255)-127; else ++pc; break; // JF N
    case 48: swap(h(d)); break; // *D<>A
    case 49: ++h(d); break; // *D++
    case 50: --h(d); break; // *D--
    case 51: h(d) = ~h(d); break; // *D!
    case 52: h(d) = 0; break; // *D=0
    case 55: r[header[pc++]] = a; break; // R=A N
    case 56: return 0  ; // HALT
    case 57: outc(a&255); break; // OUT
    case 59: a = (a+m(b)+512)*773; break; // HASH
    case 60: h(d) = (h(d)+a+512)*773; break; // HASHD
    case 63: pc+=((header[pc]+128)&255)-127; break; // JMP N
    case 64: break; // A=A
    case 65: a = b; break; // A=B
    case 66: a = c; break; // A=C
    case 67: a = d; break; // A=D
    case 68: a = m(b); break; // A=*B
    case 69: a = m(c); break; // A=*C
    case 70: a = h(d); break; // A=*D
    case 71: a = header[pc++]; break; // A= N
    case 72: b = a; break; // B=A
    case 73: break; // B=B
    case 74: b = c; break; // B=C
    case 75: b = d; break; // B=D
    case 76: b = m(b); break; // B=*B
    case 77: b = m(c); break; // B=*C
    case 78: b = h(d); break; // B=*D
    case 79: b = header[pc++]; break; // B= N
    case 80: c = a; break; // C=A
    case 81: c = b; break; // C=B
    case 82: break; // C=C
    case 83: c = d; break; // C=D
    case 84: c = m(b); break; // C=*B
    case 85: c = m(c); break; // C=*C
    case 86: c = h(d); break; // C=*D
    case 87: c = header[pc++]; break; // C= N
    case 88: d = a; break; // D=A
    case 89: d = b; break; // D=B
    case 90: d = c; break; // D=C
    case 91: break; // D=D
    case 92: d = m(b); break; // D=*B
    case 93: d = m(c); break; // D=*C
    case 94: d = h(d); break; // D=*D
    case 95: d = header[pc++]; break; // D= N
    case 96: m(b) = a; break; // *B=A
    case 97: m(b) = b; break; // *B=B
    case 98: m(b) = c; break; // *B=C
    case 99: m(b) = d; break; // *B=D
    case 100: break; // *B=*B
    case 101: m(b) = m(c); break; // *B=*C
    case 102: m(b) = h(d); break; // *B=*D
    case 103: m(b) = header[pc++]; break; // *B= N
    case 104: m(c) = a; break; // *C=A
    case 105: m(c) = b; break; // *C=B
    case 106: m(c) = c; break; // *C=C
    case 107: m(c) = d; break; // *C=D
    case 108: m(c) = m(b); break; // *C=*B
    case 109: break; // *C=*C
    case 110: m(c) = h(d); break; // *C=*D
    case 111: m(c) = header[pc++]; break; // *C= N
    case 112: h(d) = a; break; // *D=A
    case 113: h(d) = b; break; // *D=B
    case 114: h(d) = c; break; // *D=C
    case 115: h(d) = d; break; // *D=D
    case 116: h(d) = m(b); break; // *D=*B
    case 117: h(d) = m(c); break; // *D=*C
    case 118: break; // *D=*D
    case 119: h(d) = header[pc++]; break; // *D= N
    case 128: a += a; break; // A+=A
    case 129: a += b; break; // A+=B
    case 130: a += c; break; // A+=C
    case 131: a += d; break; // A+=D
    case 132: a += m(b); break; // A+=*B
    case 133: a += m(c); break; // A+=*C
    case 134: a += h(d); break; // A+=*D
    case 135: a += header[pc++]; break; // A+= N
    case 136: a -= a; break; // A-=A
    case 137: a -= b; break; // A-=B
    case 138: a -= c; break; // A-=C
    case 139: a -= d; break; // A-=D
    case 140: a -= m(b); break; // A-=*B
    case 141: a -= m(c); break; // A-=*C
    case 142: a -= h(d); break; // A-=*D
    case 143: a -= header[pc++]; break; // A-= N
    case 144: a *= a; break; // A*=A
    case 145: a *= b; break; // A*=B
    case 146: a *= c; break; // A*=C
    case 147: a *= d; break; // A*=D
    case 148: a *= m(b); break; // A*=*B
    case 149: a *= m(c); break; // A*=*C
    case 150: a *= h(d); break; // A*=*D
    case 151: a *= header[pc++]; break; // A*= N
    case 152: div(a); break; // A/=A
    case 153: div(b); break; // A/=B
    case 154: div(c); break; // A/=C
    case 155: div(d); break; // A/=D
    case 156: div(m(b)); break; // A/=*B
    case 157: div(m(c)); break; // A/=*C
    case 158: div(h(d)); break; // A/=*D
    case 159: div(header[pc++]); break; // A/= N
    case 160: mod(a); break; // A%=A
    case 161: mod(b); break; // A%=B
    case 162: mod(c); break; // A%=C
    case 163: mod(d); break; // A%=D
    case 164: mod(m(b)); break; // A%=*B
    case 165: mod(m(c)); break; // A%=*C
    case 166: mod(h(d)); break; // A%=*D
    case 167: mod(header[pc++]); break; // A%= N
    case 168: a &= a; break; // A&=A
    case 169: a &= b; break; // A&=B
    case 170: a &= c; break; // A&=C
    case 171: a &= d; break; // A&=D
    case 172: a &= m(b); break; // A&=*B
    case 173: a &= m(c); break; // A&=*C
    case 174: a &= h(d); break; // A&=*D
    case 175: a &= header[pc++]; break; // A&= N
    case 176: a &= ~ a; break; // A&~A
    case 177: a &= ~ b; break; // A&~B
    case 178: a &= ~ c; break; // A&~C
    case 179: a &= ~ d; break; // A&~D
    case 180: a &= ~ m(b); break; // A&~*B
    case 181: a &= ~ m(c); break; // A&~*C
    case 182: a &= ~ h(d); break; // A&~*D
    case 183: a &= ~ header[pc++]; break; // A&~ N
    case 184: a |= a; break; // A|=A
    case 185: a |= b; break; // A|=B
    case 186: a |= c; break; // A|=C
    case 187: a |= d; break; // A|=D
    case 188: a |= m(b); break; // A|=*B
    case 189: a |= m(c); break; // A|=*C
    case 190: a |= h(d); break; // A|=*D
    case 191: a |= header[pc++]; break; // A|= N
    case 192: a ^= a; break; // A^=A
    case 193: a ^= b; break; // A^=B
    case 194: a ^= c; break; // A^=C
    case 195: a ^= d; break; // A^=D
    case 196: a ^= m(b); break; // A^=*B
    case 197: a ^= m(c); break; // A^=*C
    case 198: a ^= h(d); break; // A^=*D
    case 199: a ^= header[pc++]; break; // A^= N
    case 200: a <<= (a&31); break; // A<<=A
    case 201: a <<= (b&31); break; // A<<=B
    case 202: a <<= (c&31); break; // A<<=C
    case 203: a <<= (d&31); break; // A<<=D
    case 204: a <<= (m(b)&31); break; // A<<=*B
    case 205: a <<= (m(c)&31); break; // A<<=*C
    case 206: a <<= (h(d)&31); break; // A<<=*D
    case 207: a <<= (header[pc++]&31); break; // A<<= N
    case 208: a >>= (a&31); break; // A>>=A
    case 209: a >>= (b&31); break; // A>>=B
    case 210: a >>= (c&31); break; // A>>=C
    case 211: a >>= (d&31); break; // A>>=D
    case 212: a >>= (m(b)&31); break; // A>>=*B
    case 213: a >>= (m(c)&31); break; // A>>=*C
    case 214: a >>= (h(d)&31); break; // A>>=*D
    case 215: a >>= (header[pc++]&31); break; // A>>= N
    case 216: f = 1; break; // A==A
    case 217: f = (a == b); break; // A==B
    case 218: f = (a == c); break; // A==C
    case 219: f = (a == d); break; // A==D
    case 220: f = (a == U32(m(b))); break; // A==*B
    case 221: f = (a == U32(m(c))); break; // A==*C
    case 222: f = (a == h(d)); break; // A==*D
    case 223: f = (a == U32(header[pc++])); break; // A== N
    case 224: f = 0; break; // A<A
    case 225: f = (a < b); break; // A<B
    case 226: f = (a < c); break; // A<C
    case 227: f = (a < d); break; // A<D
    case 228: f = (a < U32(m(b))); break; // A<*B
    case 229: f = (a < U32(m(c))); break; // A<*C
    case 230: f = (a < h(d)); break; // A<*D
    case 231: f = (a < U32(header[pc++])); break; // A< N
    case 232: f = 0; break; // A>A
    case 233: f = (a > b); break; // A>B
    case 234: f = (a > c); break; // A>C
    case 235: f = (a > d); break; // A>D
    case 236: f = (a > U32(m(b))); break; // A>*B
    case 237: f = (a > U32(m(c))); break; // A>*C
    case 238: f = (a > h(d)); break; // A>*D
    case 239: f = (a > U32(header[pc++])); break; // A> N
    case 255: if((pc=hbegin+header[pc]+256*header[pc+1])>=hend)err();break;//LJ
    default: err();
  }
  return 1;
}

// Print illegal instruction error message and exit
void ZPAQL::err() {
  error("ZPAQL execution error");
}

///////////////////////// Predictor /////////////////////////

// sdt2k[i]=2048/i;
static const int sdt2k[256]={
     0,  2048,  1024,   682,   512,   409,   341,   292,
   256,   227,   204,   186,   170,   157,   146,   136,
   128,   120,   113,   107,   102,    97,    93,    89,
    85,    81,    78,    75,    73,    70,    68,    66,
    64,    62,    60,    58,    56,    55,    53,    52,
    51,    49,    48,    47,    46,    45,    44,    43,
    42,    41,    40,    40,    39,    38,    37,    37,
    36,    35,    35,    34,    34,    33,    33,    32,
    32,    31,    31,    30,    30,    29,    29,    28,
    28,    28,    27,    27,    26,    26,    26,    25,
    25,    25,    24,    24,    24,    24,    23,    23,
    23,    23,    22,    22,    22,    22,    21,    21,
    21,    21,    20,    20,    20,    20,    20,    19,
    19,    19,    19,    19,    18,    18,    18,    18,
    18,    18,    17,    17,    17,    17,    17,    17,
    17,    16,    16,    16,    16,    16,    16,    16,
    16,    15,    15,    15,    15,    15,    15,    15,
    15,    14,    14,    14,    14,    14,    14,    14,
    14,    14,    14,    13,    13,    13,    13,    13,
    13,    13,    13,    13,    13,    13,    12,    12,
    12,    12,    12,    12,    12,    12,    12,    12,
    12,    12,    12,    11,    11,    11,    11,    11,
    11,    11,    11,    11,    11,    11,    11,    11,
    11,    11,    11,    10,    10,    10,    10,    10,
    10,    10,    10,    10,    10,    10,    10,    10,
    10,    10,    10,    10,    10,     9,     9,     9,
     9,     9,     9,     9,     9,     9,     9,     9,
     9,     9,     9,     9,     9,     9,     9,     9,
     9,     9,     9,     9,     8,     8,     8,     8,
     8,     8,     8,     8,     8,     8,     8,     8,
     8,     8,     8,     8,     8,     8,     8,     8,
     8,     8,     8,     8,     8,     8,     8,     8
};

// sdt[i]=(1<<17)/(i*2+3)*2;
static const int sdt[1024]={
 87380, 52428, 37448, 29126, 23830, 20164, 17476, 15420,
 13796, 12482, 11396, 10484,  9708,  9038,  8456,  7942,
  7488,  7084,  6720,  6392,  6096,  5824,  5576,  5348,
  5140,  4946,  4766,  4598,  4442,  4296,  4160,  4032,
  3912,  3798,  3692,  3590,  3494,  3404,  3318,  3236,
  3158,  3084,  3012,  2944,  2880,  2818,  2758,  2702,
  2646,  2594,  2544,  2496,  2448,  2404,  2360,  2318,
  2278,  2240,  2202,  2166,  2130,  2096,  2064,  2032,
  2000,  1970,  1940,  1912,  1884,  1858,  1832,  1806,
  1782,  1758,  1736,  1712,  1690,  1668,  1648,  1628,
  1608,  1588,  1568,  1550,  1532,  1514,  1496,  1480,
  1464,  1448,  1432,  1416,  1400,  1386,  1372,  1358,
  1344,  1330,  1316,  1304,  1290,  1278,  1266,  1254,
  1242,  1230,  1218,  1208,  1196,  1186,  1174,  1164,
  1154,  1144,  1134,  1124,  1114,  1106,  1096,  1086,
  1078,  1068,  1060,  1052,  1044,  1036,  1028,  1020,
  1012,  1004,   996,   988,   980,   974,   966,   960,
   952,   946,   938,   932,   926,   918,   912,   906,
   900,   894,   888,   882,   876,   870,   864,   858,
   852,   848,   842,   836,   832,   826,   820,   816,
   810,   806,   800,   796,   790,   786,   782,   776,
   772,   768,   764,   758,   754,   750,   746,   742,
   738,   734,   730,   726,   722,   718,   714,   710,
   706,   702,   698,   694,   690,   688,   684,   680,
   676,   672,   670,   666,   662,   660,   656,   652,
   650,   646,   644,   640,   636,   634,   630,   628,
   624,   622,   618,   616,   612,   610,   608,   604,
   602,   598,   596,   594,   590,   588,   586,   582,
   580,   578,   576,   572,   570,   568,   566,   562,
   560,   558,   556,   554,   550,   548,   546,   544,
   542,   540,   538,   536,   532,   530,   528,   526,
   524,   522,   520,   518,   516,   514,   512,   510,
   508,   506,   504,   502,   500,   498,   496,   494,
   492,   490,   488,   488,   486,   484,   482,   480,
   478,   476,   474,   474,   472,   470,   468,   466,
   464,   462,   462,   460,   458,   456,   454,   454,
   452,   450,   448,   448,   446,   444,   442,   442,
   440,   438,   436,   436,   434,   432,   430,   430,
   428,   426,   426,   424,   422,   422,   420,   418,
   418,   416,   414,   414,   412,   410,   410,   408,
   406,   406,   404,   402,   402,   400,   400,   398,
   396,   396,   394,   394,   392,   390,   390,   388,
   388,   386,   386,   384,   382,   382,   380,   380,
   378,   378,   376,   376,   374,   372,   372,   370,
   370,   368,   368,   366,   366,   364,   364,   362,
   362,   360,   360,   358,   358,   356,   356,   354,
   354,   352,   352,   350,   350,   348,   348,   348,
   346,   346,   344,   344,   342,   342,   340,   340,
   340,   338,   338,   336,   336,   334,   334,   332,
   332,   332,   330,   330,   328,   328,   328,   326,
   326,   324,   324,   324,   322,   322,   320,   320,
   320,   318,   318,   316,   316,   316,   314,   314,
   312,   312,   312,   310,   310,   310,   308,   308,
   308,   306,   306,   304,   304,   304,   302,   302,
   302,   300,   300,   300,   298,   298,   298,   296,
   296,   296,   294,   294,   294,   292,   292,   292,
   290,   290,   290,   288,   288,   288,   286,   286,
   286,   284,   284,   284,   284,   282,   282,   282,
   280,   280,   280,   278,   278,   278,   276,   276,
   276,   276,   274,   274,   274,   272,   272,   272,
   272,   270,   270,   270,   268,   268,   268,   268,
   266,   266,   266,   266,   264,   264,   264,   262,
   262,   262,   262,   260,   260,   260,   260,   258,
   258,   258,   258,   256,   256,   256,   256,   254,
   254,   254,   254,   252,   252,   252,   252,   250,
   250,   250,   250,   248,   248,   248,   248,   248,
   246,   246,   246,   246,   244,   244,   244,   244,
   242,   242,   242,   242,   242,   240,   240,   240,
   240,   238,   238,   238,   238,   238,   236,   236,
   236,   236,   234,   234,   234,   234,   234,   232,
   232,   232,   232,   232,   230,   230,   230,   230,
   230,   228,   228,   228,   228,   228,   226,   226,
   226,   226,   226,   224,   224,   224,   224,   224,
   222,   222,   222,   222,   222,   220,   220,   220,
   220,   220,   220,   218,   218,   218,   218,   218,
   216,   216,   216,   216,   216,   216,   214,   214,
   214,   214,   214,   212,   212,   212,   212,   212,
   212,   210,   210,   210,   210,   210,   210,   208,
   208,   208,   208,   208,   208,   206,   206,   206,
   206,   206,   206,   204,   204,   204,   204,   204,
   204,   204,   202,   202,   202,   202,   202,   202,
   200,   200,   200,   200,   200,   200,   198,   198,
   198,   198,   198,   198,   198,   196,   196,   196,
   196,   196,   196,   196,   194,   194,   194,   194,
   194,   194,   194,   192,   192,   192,   192,   192,
   192,   192,   190,   190,   190,   190,   190,   190,
   190,   188,   188,   188,   188,   188,   188,   188,
   186,   186,   186,   186,   186,   186,   186,   186,
   184,   184,   184,   184,   184,   184,   184,   182,
   182,   182,   182,   182,   182,   182,   182,   180,
   180,   180,   180,   180,   180,   180,   180,   178,
   178,   178,   178,   178,   178,   178,   178,   176,
   176,   176,   176,   176,   176,   176,   176,   176,
   174,   174,   174,   174,   174,   174,   174,   174,
   172,   172,   172,   172,   172,   172,   172,   172,
   172,   170,   170,   170,   170,   170,   170,   170,
   170,   170,   168,   168,   168,   168,   168,   168,
   168,   168,   168,   166,   166,   166,   166,   166,
   166,   166,   166,   166,   166,   164,   164,   164,
   164,   164,   164,   164,   164,   164,   162,   162,
   162,   162,   162,   162,   162,   162,   162,   162,
   160,   160,   160,   160,   160,   160,   160,   160,
   160,   160,   158,   158,   158,   158,   158,   158,
   158,   158,   158,   158,   158,   156,   156,   156,
   156,   156,   156,   156,   156,   156,   156,   154,
   154,   154,   154,   154,   154,   154,   154,   154,
   154,   154,   152,   152,   152,   152,   152,   152,
   152,   152,   152,   152,   152,   150,   150,   150,
   150,   150,   150,   150,   150,   150,   150,   150,
   150,   148,   148,   148,   148,   148,   148,   148,
   148,   148,   148,   148,   148,   146,   146,   146,
   146,   146,   146,   146,   146,   146,   146,   146,
   146,   144,   144,   144,   144,   144,   144,   144,
   144,   144,   144,   144,   144,   142,   142,   142,
   142,   142,   142,   142,   142,   142,   142,   142,
   142,   142,   140,   140,   140,   140,   140,   140,
   140,   140,   140,   140,   140,   140,   140,   138,
   138,   138,   138,   138,   138,   138,   138,   138,
   138,   138,   138,   138,   138,   136,   136,   136,
   136,   136,   136,   136,   136,   136,   136,   136,
   136,   136,   136,   134,   134,   134,   134,   134,
   134,   134,   134,   134,   134,   134,   134,   134,
   134,   132,   132,   132,   132,   132,   132,   132,
   132,   132,   132,   132,   132,   132,   132,   132,
   130,   130,   130,   130,   130,   130,   130,   130,
   130,   130,   130,   130,   130,   130,   130,   128,
   128,   128,   128,   128,   128,   128,   128,   128,
   128,   128,   128,   128,   128,   128,   128,   126
};

// ssquasht[i]=int(32768.0/(1+exp((i-2048)*(-1.0/64))));
// Middle 1344 of 4096 entries only.
static const U16 ssquasht[1344]={
     0,     0,     0,     0,     0,     0,     0,     1,
     1,     1,     1,     1,     1,     1,     1,     1,
     1,     1,     1,     1,     1,     1,     1,     1,
     1,     1,     1,     1,     1,     1,     1,     1,
     1,     1,     1,     1,     1,     1,     1,     1,
     1,     1,     1,     1,     1,     1,     1,     1,
     1,     1,     1,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     3,     3,     3,
     3,     3,     3,     3,     3,     3,     3,     3,
     3,     3,     3,     3,     3,     3,     3,     3,
     4,     4,     4,     4,     4,     4,     4,     4,
     4,     4,     4,     4,     4,     4,     5,     5,
     5,     5,     5,     5,     5,     5,     5,     5,
     5,     5,     6,     6,     6,     6,     6,     6,
     6,     6,     6,     6,     7,     7,     7,     7,
     7,     7,     7,     7,     8,     8,     8,     8,
     8,     8,     8,     8,     9,     9,     9,     9,
     9,     9,    10,    10,    10,    10,    10,    10,
    10,    11,    11,    11,    11,    11,    12,    12,
    12,    12,    12,    13,    13,    13,    13,    13,
    14,    14,    14,    14,    15,    15,    15,    15,
    15,    16,    16,    16,    17,    17,    17,    17,
    18,    18,    18,    18,    19,    19,    19,    20,
    20,    20,    21,    21,    21,    22,    22,    22,
    23,    23,    23,    24,    24,    25,    25,    25,
    26,    26,    27,    27,    28,    28,    28,    29,
    29,    30,    30,    31,    31,    32,    32,    33,
    33,    34,    34,    35,    36,    36,    37,    37,
    38,    38,    39,    40,    40,    41,    42,    42,
    43,    44,    44,    45,    46,    46,    47,    48,
    49,    49,    50,    51,    52,    53,    54,    54,
    55,    56,    57,    58,    59,    60,    61,    62,
    63,    64,    65,    66,    67,    68,    69,    70,
    71,    72,    73,    74,    76,    77,    78,    79,
    81,    82,    83,    84,    86,    87,    88,    90,
    91,    93,    94,    96,    97,    99,   100,   102,
   103,   105,   107,   108,   110,   112,   114,   115,
   117,   119,   121,   123,   125,   127,   129,   131,
   133,   135,   137,   139,   141,   144,   146,   148,
   151,   153,   155,   158,   160,   163,   165,   168,
   171,   173,   176,   179,   182,   184,   187,   190,
   193,   196,   199,   202,   206,   209,   212,   215,
   219,   222,   226,   229,   233,   237,   240,   244,
   248,   252,   256,   260,   264,   268,   272,   276,
   281,   285,   289,   294,   299,   303,   308,   313,
   318,   323,   328,   333,   338,   343,   349,   354,
   360,   365,   371,   377,   382,   388,   394,   401,
   407,   413,   420,   426,   433,   440,   446,   453,
   460,   467,   475,   482,   490,   497,   505,   513,
   521,   529,   537,   545,   554,   562,   571,   580,
   589,   598,   607,   617,   626,   636,   646,   656,
   666,   676,   686,   697,   708,   719,   730,   741,
   752,   764,   776,   788,   800,   812,   825,   837,
   850,   863,   876,   890,   903,   917,   931,   946,
   960,   975,   990,  1005,  1020,  1036,  1051,  1067,
  1084,  1100,  1117,  1134,  1151,  1169,  1186,  1204,
  1223,  1241,  1260,  1279,  1298,  1318,  1338,  1358,
  1379,  1399,  1421,  1442,  1464,  1486,  1508,  1531,
  1554,  1577,  1600,  1624,  1649,  1673,  1698,  1724,
  1749,  1775,  1802,  1829,  1856,  1883,  1911,  1940,
  1968,  1998,  2027,  2057,  2087,  2118,  2149,  2181,
  2213,  2245,  2278,  2312,  2345,  2380,  2414,  2450,
  2485,  2521,  2558,  2595,  2633,  2671,  2709,  2748,
  2788,  2828,  2869,  2910,  2952,  2994,  3037,  3080,
  3124,  3168,  3213,  3259,  3305,  3352,  3399,  3447,
  3496,  3545,  3594,  3645,  3696,  3747,  3799,  3852,
  3906,  3960,  4014,  4070,  4126,  4182,  4240,  4298,
  4356,  4416,  4476,  4537,  4598,  4660,  4723,  4786,
  4851,  4916,  4981,  5048,  5115,  5183,  5251,  5320,
  5390,  5461,  5533,  5605,  5678,  5752,  5826,  5901,
  5977,  6054,  6131,  6210,  6289,  6369,  6449,  6530,
  6613,  6695,  6779,  6863,  6949,  7035,  7121,  7209,
  7297,  7386,  7476,  7566,  7658,  7750,  7842,  7936,
  8030,  8126,  8221,  8318,  8415,  8513,  8612,  8712,
  8812,  8913,  9015,  9117,  9221,  9324,  9429,  9534,
  9640,  9747,  9854,  9962, 10071, 10180, 10290, 10401,
 10512, 10624, 10737, 10850, 10963, 11078, 11192, 11308,
 11424, 11540, 11658, 11775, 11893, 12012, 12131, 12251,
 12371, 12491, 12612, 12734, 12856, 12978, 13101, 13224,
 13347, 13471, 13595, 13719, 13844, 13969, 14095, 14220,
 14346, 14472, 14599, 14725, 14852, 14979, 15106, 15233,
 15361, 15488, 15616, 15744, 15872, 16000, 16128, 16256,
 16384, 16511, 16639, 16767, 16895, 17023, 17151, 17279,
 17406, 17534, 17661, 17788, 17915, 18042, 18168, 18295,
 18421, 18547, 18672, 18798, 18923, 19048, 19172, 19296,
 19420, 19543, 19666, 19789, 19911, 20033, 20155, 20276,
 20396, 20516, 20636, 20755, 20874, 20992, 21109, 21227,
 21343, 21459, 21575, 21689, 21804, 21917, 22030, 22143,
 22255, 22366, 22477, 22587, 22696, 22805, 22913, 23020,
 23127, 23233, 23338, 23443, 23546, 23650, 23752, 23854,
 23955, 24055, 24155, 24254, 24352, 24449, 24546, 24641,
 24737, 24831, 24925, 25017, 25109, 25201, 25291, 25381,
 25470, 25558, 25646, 25732, 25818, 25904, 25988, 26072,
 26154, 26237, 26318, 26398, 26478, 26557, 26636, 26713,
 26790, 26866, 26941, 27015, 27089, 27162, 27234, 27306,
 27377, 27447, 27516, 27584, 27652, 27719, 27786, 27851,
 27916, 27981, 28044, 28107, 28169, 28230, 28291, 28351,
 28411, 28469, 28527, 28585, 28641, 28697, 28753, 28807,
 28861, 28915, 28968, 29020, 29071, 29122, 29173, 29222,
 29271, 29320, 29368, 29415, 29462, 29508, 29554, 29599,
 29643, 29687, 29730, 29773, 29815, 29857, 29898, 29939,
 29979, 30019, 30058, 30096, 30134, 30172, 30209, 30246,
 30282, 30317, 30353, 30387, 30422, 30455, 30489, 30522,
 30554, 30586, 30618, 30649, 30680, 30710, 30740, 30769,
 30799, 30827, 30856, 30884, 30911, 30938, 30965, 30992,
 31018, 31043, 31069, 31094, 31118, 31143, 31167, 31190,
 31213, 31236, 31259, 31281, 31303, 31325, 31346, 31368,
 31388, 31409, 31429, 31449, 31469, 31488, 31507, 31526,
 31544, 31563, 31581, 31598, 31616, 31633, 31650, 31667,
 31683, 31700, 31716, 31731, 31747, 31762, 31777, 31792,
 31807, 31821, 31836, 31850, 31864, 31877, 31891, 31904,
 31917, 31930, 31942, 31955, 31967, 31979, 31991, 32003,
 32015, 32026, 32037, 32048, 32059, 32070, 32081, 32091,
 32101, 32111, 32121, 32131, 32141, 32150, 32160, 32169,
 32178, 32187, 32196, 32205, 32213, 32222, 32230, 32238,
 32246, 32254, 32262, 32270, 32277, 32285, 32292, 32300,
 32307, 32314, 32321, 32327, 32334, 32341, 32347, 32354,
 32360, 32366, 32373, 32379, 32385, 32390, 32396, 32402,
 32407, 32413, 32418, 32424, 32429, 32434, 32439, 32444,
 32449, 32454, 32459, 32464, 32468, 32473, 32478, 32482,
 32486, 32491, 32495, 32499, 32503, 32507, 32511, 32515,
 32519, 32523, 32527, 32530, 32534, 32538, 32541, 32545,
 32548, 32552, 32555, 32558, 32561, 32565, 32568, 32571,
 32574, 32577, 32580, 32583, 32585, 32588, 32591, 32594,
 32596, 32599, 32602, 32604, 32607, 32609, 32612, 32614,
 32616, 32619, 32621, 32623, 32626, 32628, 32630, 32632,
 32634, 32636, 32638, 32640, 32642, 32644, 32646, 32648,
 32650, 32652, 32653, 32655, 32657, 32659, 32660, 32662,
 32664, 32665, 32667, 32668, 32670, 32671, 32673, 32674,
 32676, 32677, 32679, 32680, 32681, 32683, 32684, 32685,
 32686, 32688, 32689, 32690, 32691, 32693, 32694, 32695,
 32696, 32697, 32698, 32699, 32700, 32701, 32702, 32703,
 32704, 32705, 32706, 32707, 32708, 32709, 32710, 32711,
 32712, 32713, 32713, 32714, 32715, 32716, 32717, 32718,
 32718, 32719, 32720, 32721, 32721, 32722, 32723, 32723,
 32724, 32725, 32725, 32726, 32727, 32727, 32728, 32729,
 32729, 32730, 32730, 32731, 32731, 32732, 32733, 32733,
 32734, 32734, 32735, 32735, 32736, 32736, 32737, 32737,
 32738, 32738, 32739, 32739, 32739, 32740, 32740, 32741,
 32741, 32742, 32742, 32742, 32743, 32743, 32744, 32744,
 32744, 32745, 32745, 32745, 32746, 32746, 32746, 32747,
 32747, 32747, 32748, 32748, 32748, 32749, 32749, 32749,
 32749, 32750, 32750, 32750, 32750, 32751, 32751, 32751,
 32752, 32752, 32752, 32752, 32752, 32753, 32753, 32753,
 32753, 32754, 32754, 32754, 32754, 32754, 32755, 32755,
 32755, 32755, 32755, 32756, 32756, 32756, 32756, 32756,
 32757, 32757, 32757, 32757, 32757, 32757, 32757, 32758,
 32758, 32758, 32758, 32758, 32758, 32759, 32759, 32759,
 32759, 32759, 32759, 32759, 32759, 32760, 32760, 32760,
 32760, 32760, 32760, 32760, 32760, 32761, 32761, 32761,
 32761, 32761, 32761, 32761, 32761, 32761, 32761, 32762,
 32762, 32762, 32762, 32762, 32762, 32762, 32762, 32762,
 32762, 32762, 32762, 32763, 32763, 32763, 32763, 32763,
 32763, 32763, 32763, 32763, 32763, 32763, 32763, 32763,
 32763, 32764, 32764, 32764, 32764, 32764, 32764, 32764,
 32764, 32764, 32764, 32764, 32764, 32764, 32764, 32764,
 32764, 32764, 32764, 32764, 32765, 32765, 32765, 32765,
 32765, 32765, 32765, 32765, 32765, 32765, 32765, 32765,
 32765, 32765, 32765, 32765, 32765, 32765, 32765, 32765,
 32765, 32765, 32765, 32765, 32765, 32765, 32766, 32766,
 32766, 32766, 32766, 32766, 32766, 32766, 32766, 32766,
 32766, 32766, 32766, 32766, 32766, 32766, 32766, 32766,
 32766, 32766, 32766, 32766, 32766, 32766, 32766, 32766,
 32766, 32766, 32766, 32766, 32766, 32766, 32766, 32766,
 32766, 32766, 32766, 32766, 32766, 32766, 32766, 32766,
 32766, 32766, 32767, 32767, 32767, 32767, 32767, 32767
};

// stdt[i]=count of -i or i in botton or top of stretcht[]
static const U8 stdt[712]={
    64,   128,   128,   128,   128,   128,   127,   128,
   127,   128,   127,   127,   127,   127,   126,   126,
   126,   126,   126,   125,   125,   124,   125,   124,
   123,   123,   123,   123,   122,   122,   121,   121,
   120,   120,   119,   119,   118,   118,   118,   116,
   117,   115,   116,   114,   114,   113,   113,   112,
   112,   111,   110,   110,   109,   108,   108,   107,
   106,   106,   105,   104,   104,   102,   103,   101,
   101,   100,    99,    98,    98,    97,    96,    96,
    94,    94,    94,    92,    92,    91,    90,    89,
    89,    88,    87,    86,    86,    84,    84,    84,
    82,    82,    81,    80,    79,    79,    78,    77,
    76,    76,    75,    74,    73,    73,    72,    71,
    70,    70,    69,    68,    67,    67,    66,    65,
    65,    64,    63,    62,    62,    61,    61,    59,
    59,    59,    57,    58,    56,    56,    55,    54,
    54,    53,    52,    52,    51,    51,    50,    49,
    49,    48,    48,    47,    47,    45,    46,    44,
    45,    43,    43,    43,    42,    41,    41,    40,
    40,    40,    39,    38,    38,    37,    37,    36,
    36,    36,    35,    34,    34,    34,    33,    32,
    33,    32,    31,    31,    30,    31,    29,    30,
    28,    29,    28,    28,    27,    27,    27,    26,
    26,    25,    26,    24,    25,    24,    24,    23,
    23,    23,    23,    22,    22,    21,    22,    21,
    20,    21,    20,    19,    20,    19,    19,    19,
    18,    18,    18,    18,    17,    17,    17,    17,
    16,    16,    16,    16,    15,    15,    15,    15,
    15,    14,    14,    14,    14,    13,    14,    13,
    13,    13,    12,    13,    12,    12,    12,    11,
    12,    11,    11,    11,    11,    11,    10,    11,
    10,    10,    10,    10,     9,    10,     9,     9,
     9,     9,     9,     8,     9,     8,     9,     8,
     8,     8,     7,     8,     8,     7,     7,     8,
     7,     7,     7,     6,     7,     7,     6,     6,
     7,     6,     6,     6,     6,     6,     6,     5,
     6,     5,     6,     5,     5,     5,     5,     5,
     5,     5,     5,     5,     4,     5,     4,     5,
     4,     4,     5,     4,     4,     4,     4,     4,
     4,     3,     4,     4,     3,     4,     4,     3,
     3,     4,     3,     3,     3,     4,     3,     3,
     3,     3,     3,     3,     2,     3,     3,     3,
     2,     3,     2,     3,     3,     2,     2,     3,
     2,     2,     3,     2,     2,     2,     2,     3,
     2,     2,     2,     2,     2,     2,     1,     2,
     2,     2,     2,     1,     2,     2,     2,     1,
     2,     1,     2,     2,     1,     2,     1,     2,
     1,     1,     2,     1,     1,     2,     1,     1,
     2,     1,     1,     1,     1,     2,     1,     1,
     1,     1,     1,     1,     1,     1,     1,     1,
     1,     1,     1,     1,     1,     1,     1,     1,
     1,     1,     0,     1,     1,     1,     1,     0,
     1,     1,     1,     0,     1,     1,     1,     0,
     1,     1,     0,     1,     1,     0,     1,     0,
     1,     1,     0,     1,     0,     1,     0,     1,
     0,     1,     0,     1,     0,     1,     0,     1,
     0,     1,     0,     1,     0,     1,     0,     0,
     1,     0,     1,     0,     0,     1,     0,     1,
     0,     0,     1,     0,     0,     1,     0,     0,
     1,     0,     0,     1,     0,     0,     0,     1,
     0,     0,     1,     0,     0,     0,     1,     0,
     0,     0,     1,     0,     0,     0,     1,     0,
     0,     0,     0,     1,     0,     0,     0,     0,
     1,     0,     0,     0,     0,     1,     0,     0,
     0,     0,     0,     1,     0,     0,     0,     0,
     0,     1,     0,     0,     0,     0,     0,     0,
     1,     0,     0,     0,     0,     0,     0,     0,
     1,     0,     0,     0,     0,     0,     0,     0,
     0,     0,     1,     0,     0,     0,     0,     0,
     0,     0,     0,     0,     1,     0,     0,     0,
     0,     0,     0,     0,     0,     0,     0,     0,
     0,     1,     0,     0,     0,     0,     0,     0,
     0,     0,     0,     0,     0,     0,     0,     0,
     0,     1,     0,     0,     0,     0,     0,     0,
     0,     0,     0,     0,     0,     0,     0,     0,
     0,     0,     0,     0,     0,     0,     0,     1,
     0,     0,     0,     0,     0,     0,     0,     0,
     0,     0,     0,     0,     0,     0,     0,     0,
     0,     0,     0,     0,     0,     0,     0,     0,
     0,     0,     0,     0,     0,     0,     0,     1,
     0,     0,     0,     0,     0,     0,     0,     0,
     0,     0,     0,     0,     0,     0,     0,     0,
     0,     0,     0,     0,     0,     0,     0,     0,
     0,     0,     0,     0,     0,     0,     0,     0,
     0,     0,     0,     0,     0,     0,     0,     0,
     0,     0,     0,     0,     0,     0,     0,     0,
     0,     0,     0,     0,     0,     0,     0,     0,
     0,     0,     0,     0,     0,     0,     0,     0,
     0,     0,     0,     0,     0,     0,     1,     0
};

Predictor::Predictor(ZPAQL& zr):
    c8(1), hmap4(1), z(zr) {
  assert(sizeof(U8)==1);
  assert(sizeof(U16)==2);
  assert(sizeof(U32)==4);
  assert(sizeof(U64)==8);
  assert(sizeof(short)==2);
  assert(sizeof(int)==4);
  pcode=0;
  pcode_size=0;
  initTables=false;
}

Predictor::~Predictor() {
  allocx(pcode, pcode_size, 0);  // free executable memory
}

// Initialize the predictor with a new model in z
void Predictor::init() {

  // Clear old JIT code if any
  allocx(pcode, pcode_size, 0);

  // Initialize context hash function
  z.inith();

  // Initialize model independent tables
  if (!initTables && isModeled()) {
    initTables=true;
    memcpy(dt2k, sdt2k, sizeof(dt2k));
    memcpy(dt, sdt, sizeof(dt));

    // ssquasht[i]=int(32768.0/(1+exp((i-2048)*(-1.0/64))));
    // Copy middle 1344 of 4096 entries.
    memset(squasht, 0, 1376*2);
    memcpy(squasht+1376, ssquasht, 1344*2);
    for (int i=2720; i<4096; ++i) squasht[i]=32767;

    // sstretcht[i]=int(log((i+0.5)/(32767.5-i))*64+0.5+100000)-100000;
    int k=16384;
    for (unsigned int i=0; i<712; ++i)
      for (int j=stdt[i]; j>0; --j)
        stretcht[k++]=i;
    assert(k==32768);
    for (unsigned int i=0; i<16384; ++i)
      stretcht[i]=-stretcht[32767-i];

#ifndef NDEBUG
    // Verify floating point math for squash() and stretch()
    U32 sqsum=0, stsum=0;
    for (int i=32767; i>=0; --i)
      stsum=stsum*3+stretch(i);
    for (int i=4095; i>=0; --i)
      sqsum=sqsum*3+squash(i-2048);
    assert(stsum==3887533746u);
    assert(sqsum==2278286169u);
#endif
  }

  // Initialize predictions
  for (unsigned int i=0; i<256; ++i) h[i]=p[i]=0;

  // Initialize components
  for (unsigned int i=0; i<256; ++i)  // clear old model
    comp[i].init();
  int n=z.header[6]; // hsize[0..1] hh hm ph pm n (comp)[n] END 0[128] (hcomp) END
  const U8* cp=&z.header[7];  // start of component list
  for (int i=0; i<n; ++i) {
    assert(cp<&z.header[z.cend]);
    assert(cp>&z.header[0] && cp<&z.header[z.header.isize()-8]);
    Component& cr=comp[i];
    switch(cp[0]) {
      case CONS:  // c
        p[i]=(cp[1]-128)*4;
        break;
      case CM: // sizebits limit
        if (cp[1]>32) error("max size for CM is 32");
        cr.cm.resize(1, cp[1]);  // packed CM (22 bits) + CMCOUNT (10 bits)
        cr.limit=cp[2]*4;
        for (size_t j=0; j<cr.cm.size(); ++j)
          cr.cm[j]=0x80000000;
        break;
      case ICM: // sizebits
        if (cp[1]>26) error("max size for ICM is 26");
        cr.limit=1023;
        cr.cm.resize(256);
        cr.ht.resize(64, cp[1]);
        for (size_t j=0; j<cr.cm.size(); ++j)
          cr.cm[j]=st.cminit(j);
        break;
      case MATCH:  // sizebits
        if (cp[1]>32 || cp[2]>32) error("max size for MATCH is 32 32");
        cr.cm.resize(1, cp[1]);  // index
        cr.ht.resize(1, cp[2]);  // buf
        cr.ht(0)=1;
        break;
      case AVG: // j k wt
        if (cp[1]>=i) error("AVG j >= i");
        if (cp[2]>=i) error("AVG k >= i");
        break;
      case MIX2:  // sizebits j k rate mask
        if (cp[1]>32) error("max size for MIX2 is 32");
        if (cp[3]>=i) error("MIX2 k >= i");
        if (cp[2]>=i) error("MIX2 j >= i");
        cr.c=(size_t(1)<<cp[1]); // size (number of contexts)
        cr.a16.resize(1, cp[1]);  // wt[size][m]
        for (size_t j=0; j<cr.a16.size(); ++j)
          cr.a16[j]=32768;
        break;
      case MIX: {  // sizebits j m rate mask
        if (cp[1]>32) error("max size for MIX is 32");
        if (cp[2]>=i) error("MIX j >= i");
        if (cp[3]<1 || cp[3]>i-cp[2]) error("MIX m not in 1..i-j");
        int m=cp[3];  // number of inputs
        assert(m>=1);
        cr.c=(size_t(1)<<cp[1]); // size (number of contexts)
        cr.cm.resize(m, cp[1]);  // wt[size][m]
        for (size_t j=0; j<cr.cm.size(); ++j)
          cr.cm[j]=65536/m;
        break;
      }
      case ISSE:  // sizebits j
        if (cp[1]>32) error("max size for ISSE is 32");
        if (cp[2]>=i) error("ISSE j >= i");
        cr.ht.resize(64, cp[1]);
        cr.cm.resize(512);
        for (int j=0; j<256; ++j) {
          cr.cm[j*2]=1<<15;
          cr.cm[j*2+1]=clamp512k(stretch(st.cminit(j)>>8)*1024);
        }
        break;
      case SSE: // sizebits j start limit
        if (cp[1]>32) error("max size for SSE is 32");
        if (cp[2]>=i) error("SSE j >= i");
        if (cp[3]>cp[4]*4) error("SSE start > limit*4");
        cr.cm.resize(32, cp[1]);
        cr.limit=cp[4]*4;
        for (size_t j=0; j<cr.cm.size(); ++j)
          cr.cm[j]=squash((j&31)*64-992)<<17|cp[3];
        break;
      default: error("unknown component type");
    }
    assert(compsize[*cp]>0);
    cp+=compsize[*cp];
    assert(cp>=&z.header[7] && cp<&z.header[z.cend]);
  }
}

// Return next bit prediction using interpreted COMP code
int Predictor::predict0() {
  assert(initTables);
  assert(c8>=1 && c8<=255);

  // Predict next bit
  int n=z.header[6];
  assert(n>0 && n<=255);
  const U8* cp=&z.header[7];
  assert(cp[-1]==n);
  for (int i=0; i<n; ++i) {
    assert(cp>&z.header[0] && cp<&z.header[z.header.isize()-8]);
    Component& cr=comp[i];
    switch(cp[0]) {
      case CONS:  // c
        break;
      case CM:  // sizebits limit
        cr.cxt=h[i]^hmap4;
        p[i]=stretch(cr.cm(cr.cxt)>>17);
        break;
      case ICM: // sizebits
        assert((hmap4&15)>0);
        if (c8==1 || (c8&0xf0)==16) cr.c=find(cr.ht, cp[1]+2, h[i]+16*c8);
        cr.cxt=cr.ht[cr.c+(hmap4&15)];
        p[i]=stretch(cr.cm(cr.cxt)>>8);
        break;
      case MATCH: // sizebits bufbits: a=len, b=offset, c=bit, cxt=bitpos,
                  //                   ht=buf, limit=pos
        assert(cr.cm.size()==(size_t(1)<<cp[1]));
        assert(cr.ht.size()==(size_t(1)<<cp[2]));
        assert(cr.a<=255);
        assert(cr.c==0 || cr.c==1);
        assert(cr.cxt<8);
        assert(cr.limit<cr.ht.size());
        if (cr.a==0) p[i]=0;
        else {
          cr.c=(cr.ht(cr.limit-cr.b)>>(7-cr.cxt))&1; // predicted bit
          p[i]=stretch(dt2k[cr.a]*(cr.c*-2+1)&32767);
        }
        break;
      case AVG: // j k wt
        p[i]=(p[cp[1]]*cp[3]+p[cp[2]]*(256-cp[3]))>>8;
        break;
      case MIX2: { // sizebits j k rate mask
                   // c=size cm=wt[size] cxt=input
        cr.cxt=((h[i]+(c8&cp[5]))&(cr.c-1));
        assert(cr.cxt<cr.a16.size());
        int w=cr.a16[cr.cxt];
        assert(w>=0 && w<65536);
        p[i]=(w*p[cp[2]]+(65536-w)*p[cp[3]])>>16;
        assert(p[i]>=-2048 && p[i]<2048);
      }
        break;
      case MIX: {  // sizebits j m rate mask
                   // c=size cm=wt[size][m] cxt=index of wt in cm
        int m=cp[3];
        assert(m>=1 && m<=i);
        cr.cxt=h[i]+(c8&cp[5]);
        cr.cxt=(cr.cxt&(cr.c-1))*m; // pointer to row of weights
        assert(cr.cxt<=cr.cm.size()-m);
        int* wt=(int*)&cr.cm[cr.cxt];
        p[i]=0;
        for (int j=0; j<m; ++j)
          p[i]+=(wt[j]>>8)*p[cp[2]+j];
        p[i]=clamp2k(p[i]>>8);
      }
        break;
      case ISSE: { // sizebits j -- c=hi, cxt=bh
        assert((hmap4&15)>0);
        if (c8==1 || (c8&0xf0)==16)
          cr.c=find(cr.ht, cp[1]+2, h[i]+16*c8);
        cr.cxt=cr.ht[cr.c+(hmap4&15)];  // bit history
        int *wt=(int*)&cr.cm[cr.cxt*2];
        p[i]=clamp2k((wt[0]*p[cp[2]]+wt[1]*64)>>16);
      }
        break;
      case SSE: { // sizebits j start limit
        cr.cxt=(h[i]+c8)*32;
        int pq=p[cp[2]]+992;
        if (pq<0) pq=0;
        if (pq>1983) pq=1983;
        int wt=pq&63;
        pq>>=6;
        assert(pq>=0 && pq<=30);
        cr.cxt+=pq;
        p[i]=stretch(((cr.cm(cr.cxt)>>10)*(64-wt)+(cr.cm(cr.cxt+1)>>10)*wt)>>13);
        cr.cxt+=wt>>5;
      }
        break;
      default:
        error("component predict not implemented");
    }
    cp+=compsize[cp[0]];
    assert(cp<&z.header[z.cend]);
    assert(p[i]>=-2048 && p[i]<2048);
  }
  assert(cp[0]==NONE);
  return squash(p[n-1]);
}

// Update model with decoded bit y (0...1)
void Predictor::update0(int y) {
  assert(initTables);
  assert(y==0 || y==1);
  assert(c8>=1 && c8<=255);
  assert(hmap4>=1 && hmap4<=511);

  // Update components
  const U8* cp=&z.header[7];
  int n=z.header[6];
  assert(n>=1 && n<=255);
  assert(cp[-1]==n);
  for (int i=0; i<n; ++i) {
    Component& cr=comp[i];
    switch(cp[0]) {
      case CONS:  // c
        break;
      case CM:  // sizebits limit
        train(cr, y);
        break;
      case ICM: { // sizebits: cxt=ht[b]=bh, ht[c][0..15]=bh row, cxt=bh
        cr.ht[cr.c+(hmap4&15)]=st.next(cr.ht[cr.c+(hmap4&15)], y);
        U32& pn=cr.cm(cr.cxt);
        pn+=int(y*32767-(pn>>8))>>2;
      }
        break;
      case MATCH: // sizebits bufbits:
                  //   a=len, b=offset, c=bit, cm=index, cxt=bitpos
                  //   ht=buf, limit=pos
      {
        assert(cr.a<=255);
        assert(cr.c==0 || cr.c==1);
        assert(cr.cxt<8);
        assert(cr.cm.size()==(size_t(1)<<cp[1]));
        assert(cr.ht.size()==(size_t(1)<<cp[2]));
        assert(cr.limit<cr.ht.size());
        if (int(cr.c)!=y) cr.a=0;  // mismatch?
        cr.ht(cr.limit)+=cr.ht(cr.limit)+y;
        if (++cr.cxt==8) {
          cr.cxt=0;
          ++cr.limit;
          cr.limit&=(1<<cp[2])-1;
          if (cr.a==0) {  // look for a match
            cr.b=cr.limit-cr.cm(h[i]);
            if (cr.b&(cr.ht.size()-1))
              while (cr.a<255
                     && cr.ht(cr.limit-cr.a-1)==cr.ht(cr.limit-cr.a-cr.b-1))
                ++cr.a;
          }
          else cr.a+=cr.a<255;
          cr.cm(h[i])=cr.limit;
        }
      }
        break;
      case AVG:  // j k wt
        break;
      case MIX2: { // sizebits j k rate mask
                   // cm=wt[size], cxt=input
        assert(cr.a16.size()==cr.c);
        assert(cr.cxt<cr.a16.size());
        int err=(y*32767-squash(p[i]))*cp[4]>>5;
        int w=cr.a16[cr.cxt];
        w+=(err*(p[cp[2]]-p[cp[3]])+(1<<12))>>13;
        if (w<0) w=0;
        if (w>65535) w=65535;
        cr.a16[cr.cxt]=w;
      }
        break;
      case MIX: {   // sizebits j m rate mask
                    // cm=wt[size][m], cxt=input
        int m=cp[3];
        assert(m>0 && m<=i);
        assert(cr.cm.size()==m*cr.c);
        assert(cr.cxt+m<=cr.cm.size());
        int err=(y*32767-squash(p[i]))*cp[4]>>4;
        int* wt=(int*)&cr.cm[cr.cxt];
        for (int j=0; j<m; ++j)
          wt[j]=clamp512k(wt[j]+((err*p[cp[2]+j]+(1<<12))>>13));
      }
        break;
      case ISSE: { // sizebits j  -- c=hi, cxt=bh
        assert(cr.cxt==cr.ht[cr.c+(hmap4&15)]);
        int err=y*32767-squash(p[i]);
        int *wt=(int*)&cr.cm[cr.cxt*2];
        wt[0]=clamp512k(wt[0]+((err*p[cp[2]]+(1<<12))>>13));
        wt[1]=clamp512k(wt[1]+((err+16)>>5));
        cr.ht[cr.c+(hmap4&15)]=st.next(cr.cxt, y);
      }
        break;
      case SSE:  // sizebits j start limit
        train(cr, y);
        break;
      default:
        assert(0);
    }
    cp+=compsize[cp[0]];
    assert(cp>=&z.header[7] && cp<&z.header[z.cend] 
           && cp<&z.header[z.header.isize()-8]);
  }
  assert(cp[0]==NONE);

  // Save bit y in c8, hmap4
  c8+=c8+y;
  if (c8>=256) {
    z.run(c8-256);
    hmap4=1;
    c8=1;
    for (int i=0; i<n; ++i) h[i]=z.H(i);
  }
  else if (c8>=16 && c8<32)
    hmap4=(hmap4&0xf)<<5|y<<4|1;
  else
    hmap4=(hmap4&0x1f0)|(((hmap4&0xf)*2+y)&0xf);
}

// Find cxt row in hash table ht. ht has rows of 16 indexed by the
// low sizebits of cxt with element 0 having the next higher 8 bits for
// collision detection. If not found after 3 adjacent tries, replace the
// row with lowest element 1 as priority. Return index of row.
size_t Predictor::find(Array<U8>& ht, int sizebits, U32 cxt) {
  assert(initTables);
  assert(ht.size()==size_t(16)<<sizebits);
  int chk=cxt>>sizebits&255;
  size_t h0=(cxt*16)&(ht.size()-16);
  if (ht[h0]==chk) return h0;
  size_t h1=h0^16;
  if (ht[h1]==chk) return h1;
  size_t h2=h0^32;
  if (ht[h2]==chk) return h2;
  if (ht[h0+1]<=ht[h1+1] && ht[h0+1]<=ht[h2+1])
    return memset(&ht[h0], 0, 16), ht[h0]=chk, h0;
  else if (ht[h1+1]<ht[h2+1])
    return memset(&ht[h1], 0, 16), ht[h1]=chk, h1;
  else
    return memset(&ht[h2], 0, 16), ht[h2]=chk, h2;
}

/////////////////////// Decoder ///////////////////////

Decoder::Decoder(ZPAQL& z):
    in(0), low(1), high(0xFFFFFFFF), curr(0), rpos(0), wpos(0),
    pr(z), buf(BUFSIZE) {
}

void Decoder::init() {
  pr.init();
  if (pr.isModeled()) low=1, high=0xFFFFFFFF, curr=0;
  else low=high=curr=0;
}

// Return next bit of decoded input, which has 16 bit probability p of being 1
int Decoder::decode(int p) {
  assert(pr.isModeled());
  assert(p>=0 && p<65536);
  assert(high>low && low>0);
  if (curr<low || curr>high) error("archive corrupted");
  assert(curr>=low && curr<=high);
  U32 mid=low+U32(((high-low)*U64(U32(p)))>>16);  // split range
  assert(high>mid && mid>=low);
  int y;
  if (curr<=mid) y=1, high=mid;  // pick half
  else y=0, low=mid+1;
  while ((high^low)<0x1000000) { // shift out identical leading bytes
    high=high<<8|255;
    low=low<<8;
    low+=(low==0);
    int c=get();
    if (c<0) error("unexpected end of file");
    curr=curr<<8|c;
  }
  return y;
}

// Decompress 1 byte or -1 at end of input
int Decoder::decompress() {
  if (pr.isModeled()) {  // n>0 components?
    if (curr==0) {  // segment initialization
      for (int i=0; i<4; ++i)
        curr=curr<<8|get();
    }
    if (decode(0)) {
      if (curr!=0) error("decoding end of stream");
      return -1;
    }
    else {
      int c=1;
      while (c<256) {  // get 8 bits
        int p=pr.predict()*2+1;
        c+=c+decode(p);
        pr.update(c&1);
      }
      return c-256;
    }
  }
  else {
    if (curr==0) {
      for (int i=0; i<4; ++i) curr=curr<<8|get();
      if (curr==0) return -1;
    }
    --curr;
    return get();
  }
}

// Find end of compressed data and return next byte
int Decoder::skip() {
  int c=-1;
  if (pr.isModeled()) {
    while (curr==0)  // at start?
      curr=get();
    while (curr && (c=get())>=0)  // find 4 zeros
      curr=curr<<8|c;
    while ((c=get())==0) ;  // might be more than 4
    return c;
  }
  else {
    if (curr==0)  // at start?
      for (int i=0; i<4 && (c=get())>=0; ++i) curr=curr<<8|c;
    while (curr>0) {
      while (curr>0) {
        --curr;
        if (get()<0) return error("skipped to EOF"), -1;
      }
      for (int i=0; i<4 && (c=get())>=0; ++i) curr=curr<<8|c;
    }
    if (c>=0) c=get();
    return c;
  }
}

////////////////////// PostProcessor //////////////////////

// Copy ph, pm from block header
void PostProcessor::init(int h, int m) {
  state=hsize=0;
  ph=h;
  pm=m;
  z.clear();
}

// (PASS=0 | PROG=1 psize[0..1] pcomp[0..psize-1]) data... EOB=-1
// Return state: 1=PASS, 2..4=loading PROG, 5=PROG loaded
int PostProcessor::write(int c) {
  assert(c>=-1 && c<=255);
  switch (state) {
    case 0:  // initial state
      if (c<0) error("Unexpected EOS");
      state=c+1;  // 1=PASS, 2=PROG
      if (state>2) error("unknown post processing type");
      if (state==1) z.clear();
      break;
    case 1:  // PASS
      z.outc(c);
      break;
    case 2: // PROG
      if (c<0) error("Unexpected EOS");
      hsize=c;  // low byte of size
      state=3;
      break;
    case 3:  // PROG psize[0]
      if (c<0) error("Unexpected EOS");
      hsize+=c*256;  // high byte of psize
      if (hsize<1) error("Empty PCOMP");
      z.header.resize(hsize+300);
      z.cend=8;
      z.hbegin=z.hend=z.cend+128;
      z.header[4]=ph;
      z.header[5]=pm;
      state=4;
      break;
    case 4:  // PROG psize[0..1] pcomp[0...]
      if (c<0) error("Unexpected EOS");
      assert(z.hend<z.header.isize());
      z.header[z.hend++]=c;  // one byte of pcomp
      if (z.hend-z.hbegin==hsize) {  // last byte of pcomp?
        hsize=z.cend-2+z.hend-z.hbegin;
        z.header[0]=hsize&255;  // header size with empty COMP
        z.header[1]=hsize>>8;
        z.initp();
        state=5;
      }
      break;
    case 5:  // PROG ... data
      z.run(c);
      if (c<0) z.flush();
      break;
  }
  return state;
}

/////////////////////// Decompresser /////////////////////

// Find the start of a block and return true if found. Set memptr
// to memory used.
bool Decompresser::findBlock(double* memptr) {
  assert(state==BLOCK);

  // Find start of block
  U32 h1=0x3D49B113, h2=0x29EB7F93, h3=0x2614BE13, h4=0x3828EB13;
  // Rolling hashes initialized to hash of first 13 bytes
  int c;
  while ((c=dec.get())!=-1) {
    h1=h1*12+c;
    h2=h2*20+c;
    h3=h3*28+c;
    h4=h4*44+c;
    if (h1==0xB16B88F1 && h2==0xFF5376F1 && h3==0x72AC5BF1 && h4==0x2F909AF1)
      break;  // hash of 16 byte string
  }
  if (c==-1) return false;

  // Read header
  if ((c=dec.get())!=1 && c!=2) error("unsupported ZPAQ level");
  if (dec.get()!=1) error("unsupported ZPAQL type");
  z.read(&dec);
  if (c==1 && z.header.isize()>6 && z.header[6]==0)
    error("ZPAQ level 1 requires at least 1 component");
  if (memptr) *memptr=z.memory();
  state=FILENAME;
  decode_state=FIRSTSEG;
  return true;
}

// Read the start of a segment (1) or end of block code (255).
// If a segment is found, write the filename and return true, else false.
bool Decompresser::findFilename(Writer* filename) {
  assert(state==FILENAME);
  int c=dec.get();
  if (c==1) {  // segment found
    while (true) {
      c=dec.get();
      if (c==-1) error("unexpected EOF");
      if (c==0) {
        state=COMMENT;
        return true;
      }
      if (filename) filename->put(c);
    }
  }
  else if (c==255) {  // end of block found
    state=BLOCK;
    return false;
  }
  else
    error("missing segment or end of block");
  return false;
}

// Read the comment from the segment header
void Decompresser::readComment(Writer* comment) {
  assert(state==COMMENT);
  state=DATA;
  while (true) {
    int c=dec.get();
    if (c==-1) error("unexpected EOF");
    if (c==0) break;
    if (comment) comment->put(c);
  }
  if (dec.get()!=0) error("missing reserved byte");
}

// Decompress n bytes, or all if n < 0. Return false if done
bool Decompresser::decompress(int n) {
  assert(state==DATA);
  if (decode_state==SKIP) error("decompression after skipped segment");
  assert(decode_state!=SKIP);

  // Initialize models to start decompressing block
  if (decode_state==FIRSTSEG) {
    dec.init();
    assert(z.header.size()>5);
    pp.init(z.header[4], z.header[5]);
    decode_state=SEG;
  }

  // Decompress and load PCOMP into postprocessor
  while ((pp.getState()&3)!=1)
    pp.write(dec.decompress());

  // Decompress n bytes, or all if n < 0
  while (n) {
    int c=dec.decompress();
    pp.write(c);
    if (c==-1) {
      state=SEGEND;
      return false;
    }
    if (n>0) --n;
  }
  return true;
}

// Read end of block. If a SHA1 checksum is present, write 1 and the
// 20 byte checksum into sha1string, else write 0 in first byte.
// If sha1string is 0 then discard it.
void Decompresser::readSegmentEnd(char* sha1string) {
  assert(state==DATA || state==SEGEND);

  // Skip remaining data if any and get next byte
  int c=0;
  if (state==DATA) {
    c=dec.skip();
    decode_state=SKIP;
  }
  else if (state==SEGEND)
    c=dec.get();
  state=FILENAME;

  // Read checksum
  if (c==254) {
    if (sha1string) sha1string[0]=0;  // no checksum
  }
  else if (c==253) {
    if (sha1string) sha1string[0]=1;
    for (int i=1; i<=20; ++i) {
      c=dec.get();
      if (sha1string) sha1string[i]=c;
    }
  }
  else
    error("missing end of segment marker");
}

/////////////////////////// decompress() //////////////////////

void decompress(Reader* in, Writer* out) {
  Decompresser d;
  d.setInput(in);
  d.setOutput(out);
  while (d.findBlock()) {       // don't calculate memory
    while (d.findFilename()) {  // discard filename
      d.readComment();          // discard comment
      d.decompress();           // to end of segment
      d.readSegmentEnd();       // discard sha1string
    }
  }
}

/////////////////////////// Encoder ///////////////////////////

// Initialize for start of block
void Encoder::init() {
  low=1;
  high=0xFFFFFFFF;
  pr.init();
  if (!pr.isModeled()) low=0, buf.resize(1<<16);
}

// compress bit y having probability p/64K
void Encoder::encode(int y, int p) {
  assert(out);
  assert(p>=0 && p<65536);
  assert(y==0 || y==1);
  assert(high>low && low>0);
  U32 mid=low+U32(((high-low)*U64(U32(p)))>>16);  // split range
  assert(high>mid && mid>=low);
  if (y) high=mid; else low=mid+1; // pick half
  while ((high^low)<0x1000000) { // write identical leading bytes
    out->put(high>>24);  // same as low>>24
    high=high<<8|255;
    low=low<<8;
    low+=(low==0); // so we don't code 4 0 bytes in a row
  }
}

// compress byte c (0..255 or -1=EOS)
void Encoder::compress(int c) {
  assert(out);
  if (pr.isModeled()) {
    if (c==-1)
      encode(1, 0);
    else {
      assert(c>=0 && c<=255);
      encode(0, 0);
      for (int i=7; i>=0; --i) {
        int p=pr.predict()*2+1;
        assert(p>0 && p<65536);
        int y=c>>i&1;
        encode(y, p);
        pr.update(y);
      }
    }
  }
  else {
    if (low && (c<0 || low==buf.size())) {
      out->put((low>>24)&255);
      out->put((low>>16)&255);
      out->put((low>>8)&255);
      out->put(low&255);
      out->write(&buf[0], low);
      low=0;
    }
    if (c>=0) buf[low++]=c;
  }
}

//////////////////////////// Compiler /////////////////////////

// Component names
const char* compname[256]=
  {"","const","cm","icm","match","avg","mix2","mix","isse","sse",0};

// Opcodes
const char* opcodelist[272]={
"error","a++",  "a--",  "a!",   "a=0",  "",     "",     "a=r",
"b<>a", "b++",  "b--",  "b!",   "b=0",  "",     "",     "b=r",
"c<>a", "c++",  "c--",  "c!",   "c=0",  "",     "",     "c=r",
"d<>a", "d++",  "d--",  "d!",   "d=0",  "",     "",     "d=r",
"*b<>a","*b++", "*b--", "*b!",  "*b=0", "",     "",     "jt",
"*c<>a","*c++", "*c--", "*c!",  "*c=0", "",     "",     "jf",
"*d<>a","*d++", "*d--", "*d!",  "*d=0", "",     "",     "r=a",
"halt", "out",  "",     "hash", "hashd","",     "",     "jmp",
"a=a",  "a=b",  "a=c",  "a=d",  "a=*b", "a=*c", "a=*d", "a=",
"b=a",  "b=b",  "b=c",  "b=d",  "b=*b", "b=*c", "b=*d", "b=",
"c=a",  "c=b",  "c=c",  "c=d",  "c=*b", "c=*c", "c=*d", "c=",
"d=a",  "d=b",  "d=c",  "d=d",  "d=*b", "d=*c", "d=*d", "d=",
"*b=a", "*b=b", "*b=c", "*b=d", "*b=*b","*b=*c","*b=*d","*b=",
"*c=a", "*c=b", "*c=c", "*c=d", "*c=*b","*c=*c","*c=*d","*c=",
"*d=a", "*d=b", "*d=c", "*d=d", "*d=*b","*d=*c","*d=*d","*d=",
"",     "",     "",     "",     "",     "",     "",     "",
"a+=a", "a+=b", "a+=c", "a+=d", "a+=*b","a+=*c","a+=*d","a+=",
"a-=a", "a-=b", "a-=c", "a-=d", "a-=*b","a-=*c","a-=*d","a-=",
"a*=a", "a*=b", "a*=c", "a*=d", "a*=*b","a*=*c","a*=*d","a*=",
"a/=a", "a/=b", "a/=c", "a/=d", "a/=*b","a/=*c","a/=*d","a/=",
"a%=a", "a%=b", "a%=c", "a%=d", "a%=*b","a%=*c","a%=*d","a%=",
"a&=a", "a&=b", "a&=c", "a&=d", "a&=*b","a&=*c","a&=*d","a&=",
"a&~a", "a&~b", "a&~c", "a&~d", "a&~*b","a&~*c","a&~*d","a&~",
"a|=a", "a|=b", "a|=c", "a|=d", "a|=*b","a|=*c","a|=*d","a|=",
"a^=a", "a^=b", "a^=c", "a^=d", "a^=*b","a^=*c","a^=*d","a^=",
"a<<=a","a<<=b","a<<=c","a<<=d","a<<=*b","a<<=*c","a<<=*d","a<<=",
"a>>=a","a>>=b","a>>=c","a>>=d","a>>=*b","a>>=*c","a>>=*d","a>>=",
"a==a", "a==b", "a==c", "a==d", "a==*b","a==*c","a==*d","a==",
"a<a",  "a<b",  "a<c",  "a<d",  "a<*b", "a<*c", "a<*d", "a<",
"a>a",  "a>b",  "a>c",  "a>d",  "a>*b", "a>*c", "a>*d", "a>",
"",     "",     "",     "",     "",     "",     "",     "",
"",     "",     "",     "",     "",     "",     "",     "lj",
"post", "pcomp","end",  "if",   "ifnot","else", "endif","do",
"while","until","forever","ifl","ifnotl","elsel",";",    0};

// Advance in to start of next token. Tokens are delimited by white
// space. Comments inclosed in ((nested) parenthsis) are skipped.
void Compiler::next() {
  assert(in);
  for (; *in; ++in) {
    if (*in=='\n') ++line;
    if (*in=='(') state+=1+(state<0);
    else if (state>0 && *in==')') --state;
    else if (state<0 && *in<=' ') state=0;
    else if (state==0 && *in>' ') {state=-1; break;}
  }
  if (!*in) error("unexpected end of config");
}

// convert to lower case
int tolower(int c) {return (c>='A' && c<='Z') ? c+'a'-'A' : c;}

// return true if in==word up to white space or '(', case insensitive
bool Compiler::matchToken(const char* word) {
  const char* a=in;
  for (; (*a>' ' && *a!='(' && *word); ++a, ++word)
    if (tolower(*a)!=tolower(*word)) return false;
  return !*word && (*a<=' ' || *a=='(');
}

// Print error message and exit
void Compiler::syntaxError(const char* msg, const char* expected) {
  Array<char> sbuf(128);  // error message to report
  char* s=&sbuf[0];
  strcat(s, "Config line ");
  for (int i=strlen(s), r=1000000; r; r/=10)  // append line number
    if (line/r) s[i++]='0'+line/r%10;
  strcat(s, " at ");
  for (int i=strlen(s); i<40 && *in>' '; ++i)  // append token found
    s[i]=*in++;
  strcat(s, ": ");
  strncat(s, msg, 40);  // append message
  if (expected) {
    strcat(s, ", expected: ");
    strncat(s, expected, 20);  // append expected token if any
  }
  error(s);
}

// Read a token, which must be in the NULL terminated list or else
// exit with an error. If found, return its index.
int Compiler::rtoken(const char* list[]) {
  assert(in);
  assert(list);
  next();
  for (int i=0; list[i]; ++i)
    if (matchToken(list[i]))
      return i;
  syntaxError("unexpected");
  assert(0);
  return -1; // not reached
}

// Read a token which must be the specified value s
void Compiler::rtoken(const char* s) {
  assert(s);
  next();
  if (!matchToken(s)) syntaxError("expected", s);
}

// Read a number in (low...high) or exit with an error
// For numbers like $N+M, return arg[N-1]+M
int Compiler::rtoken(int low, int high) {
  next();
  int r=0;
  if (in[0]=='$' && in[1]>='1' && in[1]<='9') {
    if (in[2]=='+') r=atoi(in+3);
    if (args) r+=args[in[1]-'1'];
  }
  else if (in[0]=='-' || (in[0]>='0' && in[0]<='9')) r=atoi(in);
  else syntaxError("expected a number");
  if (r<low) syntaxError("number too low");
  if (r>high) syntaxError("number too high");
  return r;
}

// Compile HCOMP or PCOMP code. Exit on error. Return
// code for end token (POST, PCOMP, END)
int Compiler::compile_comp(ZPAQL& z) {
  int op=0;
  const int comp_begin=z.hend;
  while (true) {
    op=rtoken(opcodelist);
    if (op==POST || op==PCOMP || op==END) break;
    int operand=-1; // 0...255 if 2 bytes
    int operand2=-1;  // 0...255 if 3 bytes
    if (op==IF) {
      op=JF;
      operand=0; // set later
      if_stack.push(z.hend+1); // save jump target location
    }
    else if (op==IFNOT) {
      op=JT;
      operand=0;
      if_stack.push(z.hend+1); // save jump target location
    }
    else if (op==IFL || op==IFNOTL) {  // long if
      if (op==IFL) z.header[z.hend++]=(JT);
      if (op==IFNOTL) z.header[z.hend++]=(JF);
      z.header[z.hend++]=(3);
      op=LJ;
      operand=operand2=0;
      if_stack.push(z.hend+1);
    }
    else if (op==ELSE || op==ELSEL) {
      if (op==ELSE) op=JMP, operand=0;
      if (op==ELSEL) op=LJ, operand=operand2=0;
      int a=if_stack.pop();  // conditional jump target location
      assert(a>comp_begin && a<int(z.hend));
      if (z.header[a-1]!=LJ) {  // IF, IFNOT
        assert(z.header[a-1]==JT || z.header[a-1]==JF || z.header[a-1]==JMP);
        int j=z.hend-a+1+(op==LJ); // offset at IF
        assert(j>=0);
        if (j>127) syntaxError("IF too big, try IFL, IFNOTL");
        z.header[a]=j;
      }
      else {  // IFL, IFNOTL
        int j=z.hend-comp_begin+2+(op==LJ);
        assert(j>=0);
        z.header[a]=j&255;
        z.header[a+1]=(j>>8)&255;
      }
      if_stack.push(z.hend+1);  // save JMP target location
    }
    else if (op==ENDIF) {
      int a=if_stack.pop();  // jump target address
      assert(a>comp_begin && a<int(z.hend));
      int j=z.hend-a-1;  // jump offset
      assert(j>=0);
      if (z.header[a-1]!=LJ) {
        assert(z.header[a-1]==JT || z.header[a-1]==JF || z.header[a-1]==JMP);
        if (j>127) syntaxError("IF too big, try IFL, IFNOTL, ELSEL\n");
        z.header[a]=j;
      }
      else {
        assert(a+1<int(z.hend));
        j=z.hend-comp_begin;
        z.header[a]=j&255;
        z.header[a+1]=(j>>8)&255;
      }
    }
    else if (op==DO) {
      do_stack.push(z.hend);
    }
    else if (op==WHILE || op==UNTIL || op==FOREVER) {
      int a=do_stack.pop();
      assert(a>=comp_begin && a<int(z.hend));
      int j=a-z.hend-2;
      assert(j<=-2);
      if (j>=-127) {  // backward short jump
        if (op==WHILE) op=JT;
        if (op==UNTIL) op=JF;
        if (op==FOREVER) op=JMP;
        operand=j&255;
      }
      else {  // backward long jump
        j=a-comp_begin;
        assert(j>=0 && j<int(z.hend)-comp_begin);
        if (op==WHILE) {
          z.header[z.hend++]=(JF);
          z.header[z.hend++]=(3);
        }
        if (op==UNTIL) {
          z.header[z.hend++]=(JT);
          z.header[z.hend++]=(3);
        }
        op=LJ;
        operand=j&255;
        operand2=j>>8;
      }
    }
    else if ((op&7)==7) { // 2 byte operand, read N
      if (op==LJ) {
        operand=rtoken(0, 65535);
        operand2=operand>>8;
        operand&=255;
      }
      else if (op==JT || op==JF || op==JMP) {
        operand=rtoken(-128, 127);
        operand&=255;
      }
      else
        operand=rtoken(0, 255);
    }
    if (op>=0 && op<=255)
      z.header[z.hend++]=(op);
    if (operand>=0)
      z.header[z.hend++]=(operand);
    if (operand2>=0)
      z.header[z.hend++]=(operand2);
    if (z.hend>=z.header.isize()-130 || z.hend-z.hbegin+z.cend-2>65535)
      syntaxError("program too big");
  }
  z.header[z.hend++]=(0); // END
  return op;
}

// Compile a configuration file. Store COMP/HCOMP section in hcomp.
// If there is a PCOMP section, store it in pcomp and store the PCOMP
// command in pcomp_cmd. Replace "$1..$9+n" with args[0..8]+n

Compiler::Compiler(const char* in_, int* args_, ZPAQL& hz_, ZPAQL& pz_,
                   Writer* out2_): in(in_), args(args_), hz(hz_), pz(pz_),
                   out2(out2_), if_stack(1000), do_stack(1000) {
  line=1;
  state=0;
  hz.clear();
  pz.clear();
  hz.header.resize(68000); 

  // Compile the COMP section of header
  rtoken("comp");
  hz.header[2]=rtoken(0, 255);  // hh
  hz.header[3]=rtoken(0, 255);  // hm
  hz.header[4]=rtoken(0, 255);  // ph
  hz.header[5]=rtoken(0, 255);  // pm
  const int n=hz.header[6]=rtoken(0, 255);  // n
  hz.cend=7;
  for (int i=0; i<n; ++i) {
    rtoken(i, i);
    CompType type=CompType(rtoken(compname));
    hz.header[hz.cend++]=type;
    int clen=libzpaq::compsize[type&255];
    if (clen<1 || clen>10) syntaxError("invalid component");
    for (int j=1; j<clen; ++j)
      hz.header[hz.cend++]=rtoken(0, 255);  // component arguments
  }
  hz.header[hz.cend++];  // end
  hz.hbegin=hz.hend=hz.cend+128;

  // Compile HCOMP
  rtoken("hcomp");
  int op=compile_comp(hz);

  // Compute header size
  int hsize=hz.cend-2+hz.hend-hz.hbegin;
  hz.header[0]=hsize&255;
  hz.header[1]=hsize>>8;

  // Compile POST 0 END
  if (op==POST) {
    rtoken(0, 0);
    rtoken("end");
  }

  // Compile PCOMP pcomp_cmd ; program... END
  else if (op==PCOMP) {
    pz.header.resize(68000);
    pz.header[4]=hz.header[4];  // ph
    pz.header[5]=hz.header[5];  // pm
    pz.cend=8;
    pz.hbegin=pz.hend=pz.cend+128;

    // get pcomp_cmd ending with ";" (case sensitive)
    next();
    while (*in && *in!=';') {
      if (out2)
        out2->put(*in);
      ++in;
    }
    if (*in) ++in;

    // Compile PCOMP
    op=compile_comp(pz);
    int len=pz.cend-2+pz.hend-pz.hbegin;  // insert header size
    assert(len>=0);
    pz.header[0]=len&255;
    pz.header[1]=len>>8;
    if (op!=END)
      syntaxError("expected END");
  }
  else if (op!=END)
    syntaxError("expected END or POST 0 END or PCOMP cmd ; ... END");
}

///////////////////// Compressor //////////////////////

// Write 13 byte start tag
// "\x37\x6B\x53\x74\xA0\x31\x83\xD3\x8C\xB2\x28\xB0\xD3"
void Compressor::writeTag() {
  assert(state==INIT);
  enc.out->put(0x37);
  enc.out->put(0x6b);
  enc.out->put(0x53);
  enc.out->put(0x74);
  enc.out->put(0xa0);
  enc.out->put(0x31);
  enc.out->put(0x83);
  enc.out->put(0xd3);
  enc.out->put(0x8c);
  enc.out->put(0xb2);
  enc.out->put(0x28);
  enc.out->put(0xb0);
  enc.out->put(0xd3);
}

void Compressor::startBlock(int level) {

  // Model 1 - min.cfg
  static const char models[]={
  26,0,1,2,0,0,2,3,16,8,19,0,0,96,4,28,
  59,10,59,112,25,10,59,10,59,112,56,0,

  // Model 2 - mid.cfg
  69,0,3,3,0,0,8,3,5,8,13,0,8,17,1,8,
  18,2,8,18,3,8,19,4,4,22,24,7,16,0,7,24,
  (char)-1,0,17,104,74,4,95,1,59,112,10,25,59,112,10,25,
  59,112,10,25,59,112,10,25,59,112,10,25,59,10,59,112,
  25,69,(char)-49,8,112,56,0,

  // Model 3 - max.cfg
  (char)-60,0,5,9,0,0,22,1,(char)-96,3,5,8,13,1,8,16,
  2,8,18,3,8,19,4,8,19,5,8,20,6,4,22,24,
  3,17,8,19,9,3,13,3,13,3,13,3,14,7,16,0,
  15,24,(char)-1,7,8,0,16,10,(char)-1,6,0,15,16,24,0,9,
  8,17,32,(char)-1,6,8,17,18,16,(char)-1,9,16,19,32,(char)-1,6,
  0,19,20,16,0,0,17,104,74,4,95,2,59,112,10,25,
  59,112,10,25,59,112,10,25,59,112,10,25,59,112,10,25,
  59,10,59,112,10,25,59,112,10,25,69,(char)-73,32,(char)-17,64,47,
  14,(char)-25,91,47,10,25,60,26,48,(char)-122,(char)-105,20,112,63,9,70,
  (char)-33,0,39,3,25,112,26,52,25,25,74,10,4,59,112,25,
  10,4,59,112,25,10,4,59,112,25,65,(char)-113,(char)-44,72,4,59,
  112,8,(char)-113,(char)-40,8,68,(char)-81,60,60,25,69,(char)-49,9,112,25,25,
  25,25,25,112,56,0,

  0,0}; // 0,0 = end of list

  if (level<1) error("compression level must be at least 1");
  const char* p=models;
  int i;
  for (i=1; i<level && toU16(p); ++i)
    p+=toU16(p)+2;
  if (toU16(p)<1) error("compression level too high");
  startBlock(p);
}

// Memory reader
class MemoryReader: public Reader {
  const char* p;
public:
  MemoryReader(const char* p_): p(p_) {}
  int get() {return *p++&255;}
};

void Compressor::startBlock(const char* hcomp) {
  assert(state==INIT);
  MemoryReader m(hcomp);
  z.read(&m);
  pz.sha1=&sha1;
  assert(z.header.isize()>6);
  enc.out->put('z');
  enc.out->put('P');
  enc.out->put('Q');
  enc.out->put(1+(z.header[6]==0));  // level 1 or 2
  enc.out->put(1);
  z.write(enc.out, false);
  state=BLOCK1;
}

void Compressor::startBlock(const char* config, int* args, Writer* pcomp_cmd) {
  assert(state==INIT);
  Compiler(config, args, z, pz, pcomp_cmd);
  pz.sha1=&sha1;
  assert(z.header.isize()>6);
  enc.out->put('z');
  enc.out->put('P');
  enc.out->put('Q');
  enc.out->put(1+(z.header[6]==0));  // level 1 or 2
  enc.out->put(1);
  z.write(enc.out, false);
  state=BLOCK1;
}

// Write a segment header
void Compressor::startSegment(const char* filename, const char* comment) {
  assert(state==BLOCK1 || state==BLOCK2);
  enc.out->put(1);
  while (filename && *filename)
    enc.out->put(*filename++);
  enc.out->put(0);
  while (comment && *comment)
    enc.out->put(*comment++);
  enc.out->put(0);
  enc.out->put(0);
  if (state==BLOCK1) state=SEG1;
  if (state==BLOCK2) state=SEG2;
}

// Initialize encoding and write pcomp to first segment
// If len is 0 then length is encoded in pcomp[0..1]
// if pcomp is 0 then get pcomp from pz.header
void Compressor::postProcess(const char* pcomp, int len) {
  if (state==SEG2) return;
  assert(state==SEG1);
  enc.init();
  if (!pcomp) {
    len=pz.hend-pz.hbegin;
    if (len>0) {
      assert(pz.header.isize()>pz.hend);
      assert(pz.hbegin>=0);
      pcomp=(const char*)&pz.header[pz.hbegin];
    }
    assert(len>=0);
  }
  else if (len==0) {
    len=toU16(pcomp);
    pcomp+=2;
  }
  if (len>0) {
    enc.compress(1);
    enc.compress(len&255);
    enc.compress((len>>8)&255);
    for (int i=0; i<len; ++i)
      enc.compress(pcomp[i]&255);
    if (verify)
      pz.initp();
  }
  else
    enc.compress(0);
  state=SEG2;
}

// Compress n bytes, or to EOF if n < 0
bool Compressor::compress(int n) {
  if (state==SEG1)
    postProcess();
  assert(state==SEG2);

  const int BUFSIZE=1<<14;
  char buf[BUFSIZE];  // input buffer
  while (n) {
    int nbuf=BUFSIZE;  // bytes read into buf
    if (n>=0 && n<nbuf) nbuf=n;
    int nr=in->read(buf, nbuf);
    if (nr<0 || nr>BUFSIZE || nr>nbuf) error("invalid read size");
    if (nr<=0) return false;
    if (n>=0) n-=nr;
    for (int i=0; i<nr; ++i) {
      int ch=U8(buf[i]);
      enc.compress(ch);
      if (verify) {
        if (pz.hend) pz.run(ch);
        else sha1.put(ch);
      }
    }
  }
  return true;
}

// End segment, write sha1string if present
void Compressor::endSegment(const char* sha1string) {
  if (state==SEG1)
    postProcess();
  assert(state==SEG2);
  enc.compress(-1);
  if (verify && pz.hend) {
    pz.run(-1);
    pz.flush();
  }
  enc.out->put(0);
  enc.out->put(0);
  enc.out->put(0);
  enc.out->put(0);
  if (sha1string) {
    enc.out->put(253);
    for (int i=0; i<20; ++i)
      enc.out->put(sha1string[i]);
  }
  else
    enc.out->put(254);
  state=BLOCK2;
}

// End segment, write checksum and size is verify is true
char* Compressor::endSegmentChecksum(int64_t* size, bool dosha1) {
  if (state==SEG1)
    postProcess();
  assert(state==SEG2);
  enc.compress(-1);
  if (verify && pz.hend) {
    pz.run(-1);
    pz.flush();
  }
  enc.out->put(0);
  enc.out->put(0);
  enc.out->put(0);
  enc.out->put(0);
  if (verify) {
    if (size) *size=sha1.usize();
    memcpy(sha1result, sha1.result(), 20);
  }
  if (verify && dosha1) {
    enc.out->put(253);
    for (int i=0; i<20; ++i)
      enc.out->put(sha1result[i]);
  }
  else
    enc.out->put(254);
  state=BLOCK2;
  return verify ? sha1result : 0;
}

// End block
void Compressor::endBlock() {
  assert(state==BLOCK2);
  enc.out->put(255);
  state=INIT;
}

/////////////////////////// compress() ///////////////////////

void compress(Reader* in, Writer* out, const char* method,
              const char* filename, const char* comment, bool dosha1) {

  // Get block size
  int bs=4;
  if (method && method[0] && method[1]>='0' && method[1]<='9') {
    bs=method[1]-'0';
    if (method[2]>='0' && method[2]<='9') bs=bs*10+method[2]-'0';
    if (bs>11) bs=11;
  }
  bs=(0x100000<<bs)-4096;

  // Compress in blocks
  StringBuffer sb(bs);
  sb.write(0, bs);
  int n=0;
  while (in && (n=in->read((char*)sb.data(), bs))>0) {
    sb.resize(n);
    compressBlock(&sb, out, method, filename, comment, dosha1);
    filename=0;
    comment=0;
    sb.resize(0);
  }
}

//////////////////////// ZPAQL::assemble() ////////////////////

#ifndef NOJIT
/*
assemble();

Assembles the ZPAQL code in hcomp[0..hlen-1] and stores x86-32 or x86-64
code in rcode[0..rcode_size-1]. Execution begins at rcode[0]. It will not
write beyond the end of rcode, but in any case it returns the number of
bytes that would have been written. It returns 0 in case of error.

The assembled code implements int run() and returns 0 if successful,
1 if the ZPAQL code executes an invalid instruction or jumps out of
bounds, or 2 if OUT throws bad_alloc, or 3 for other OUT exceptions.

A ZPAQL virtual machine has the following state. All values are
unsigned and initially 0:

  a, b, c, d: 32 bit registers (pointed to by their respective parameters)
  f: 1 bit flag register (pointed to)
  r[0..255]: 32 bit registers
  m[0..msize-1]: 8 bit registers, where msize is a power of 2
  h[0..hsize-1]: 32 bit registers, where hsize is a power of 2
  out: pointer to a Writer
  sha1: pointer to a SHA1

Generally a ZPAQL machine is used to compute contexts which are
placed in h. A second machine might post-process, and write its
output to out and sha1. In either case, a machine is called with
its input in a, representing a single byte (0..255) or
(for a postprocessor) EOF (0xffffffff). Execution returs after a
ZPAQL halt instruction.

ZPAQL instructions are 1 byte unless the last 3 bits are 1.
In this case, a second operand byte follows. Opcode 255 is
the only 3 byte instruction. They are organized:

  00dddxxx = unary opcode xxx on destination ddd (ddd < 111)
  00111xxx = special instruction xxx
  01dddsss = assignment: ddd = sss (ddd < 111)
  1xxxxsss = operation xxxx from sss to a

The meaning of sss and ddd are as follows:

  000 = a   (accumulator)
  001 = b
  010 = c
  011 = d
  100 = *b  (means m[b mod msize])
  101 = *c  (means m[c mod msize])
  110 = *d  (means h[d mod hsize])
  111 = n   (constant 0..255 in second byte of instruction)

For example, 01001110 assigns *d to b. The other instructions xxx
are as follows:

Group 00dddxxx where ddd < 111 and xxx is:
  000 = ddd<>a, swap with a (except 00000000 is an error, and swap
        with *b or *c leaves the high bits of a unchanged)
  001 = ddd++, increment
  010 = ddd--, decrement
  011 = ddd!, not (invert all bits)
  100 = ddd=0, clear (set all bits of ddd to 0)
  101 = not used (error)
  110 = not used
  111 = ddd=r n, assign from r[n] to ddd, n=0..255 in next opcode byte
Except:
  00100111 = jt n, jump if f is true (n = -128..127, relative to next opcode)
  00101111 = jf n, jump if f is false (n = -128..127)
  00110111 = r=a n, assign r[n] = a (n = 0..255)

Group 00111xxx where xxx is:
  000 = halt (return)
  001 = output a
  010 = not used
  011 = hash: a = (a + *b + 512) * 773
  100 = hashd: *d = (*d + a + 512) * 773
  101 = not used
  110 = not used
  111 = unconditional jump (n = -128 to 127, relative to next opcode)
  
Group 1xxxxsss where xxxx is:
  0000 = a += sss (add, subtract, multiply, divide sss to a)
  0001 = a -= sss
  0010 = a *= sss
  0011 = a /= sss (unsigned, except set a = 0 if sss is 0)
  0100 = a %= sss (remainder, except set a = 0 if sss is 0)
  0101 = a &= sss (bitwise AND)
  0110 = a &= ~sss (bitwise AND with complement of sss)
  0111 = a |= sss (bitwise OR)
  1000 = a ^= sss (bitwise XOR)
  1001 = a <<= (sss % 32) (left shift by low 5 bits of sss)
  1010 = a >>= (sss % 32) (unsigned, zero bits shifted in)
  1011 = a == sss (compare, set f = true if equal or false otherwise)
  1100 = a < sss (unsigned compare, result in f)
  1101 = a > sss (unsigned compare)
  1110 = not used
  1111 = not used except 11111111 is a 3 byte jump to the absolute address
         in the next 2 bytes in little-endian (LSB first) order.

assemble() translates ZPAQL to 32 bit x86 code to be executed by run().
Registers are mapped as follows:

  eax = source sss from *b, *c, *d or sometimes n
  ecx = pointer to destination *b, *c, *d, or spare
  edx = a
  ebx = f (1 for true, 0 for false)
  esp = stack pointer
  ebp = d
  esi = b
  edi = c

run() saves non-volatile registers (ebp, esi, edi, ebx) on the stack,
loads a, b, c, d, f, and executes the translated instructions.
A halt instruction saves a, b, c, d, f, pops the saved registers
and returns. Invalid instructions or jumps outside of the range
of the ZPAQL code call libzpaq::error().

In 64 bit mode, the following additional registers are used:

  r12 = h
  r14 = r
  r15 = m

*/

// Called by out
static int flush1(ZPAQL* z) {
  try {
    z->flush();
    return 0;
  }
  catch(std::bad_alloc& x) {
    return 2;
  }
  catch(...) {
    return 3;
  }
}

// return true if op is an undefined ZPAQL instruction
static bool iserr(int op) {
  return op==0 || (op>=120 && op<=127) || (op>=240 && op<=254)
    || op==58 || (op<64 && (op%8==5 || op%8==6));
}

// Return length of ZPAQL instruction at hcomp[0]. Assume 0 padding at end.
// A run of identical ++ or -- is counted as 1 instruction.
static int oplen(const U8* hcomp) {
  if (*hcomp==255) return 3;
  if (*hcomp%8==7) return 2;
  if (*hcomp<51 && (*hcomp%8-1)/2==0) {  // ++ or -- opcode
    int i;
    for (i=1; i<127 && hcomp[i]==hcomp[0]; ++i);
    return i;
  }
  return 1;
}

// Write k bytes of x to rcode[o++] MSB first
static void put(U8* rcode, int n, int& o, U32 x, int k) {
  while (k-->0) {
    if (o<n) rcode[o]=(x>>(k*8))&255;
    ++o;
  }
}

// Write 4 bytes of x to rcode[o++] LSB first
static void put4lsb(U8* rcode, int n, int& o, U32 x) {
  for (int k=0; k<4; ++k) {
    if (o<n) rcode[o]=(x>>(k*8))&255;
    ++o;
  }
}

// Write a 1-4 byte x86 opcode without or with an 4 byte operand
// to rcode[o...]
#define put1(x) put(rcode, rcode_size, o, (x), 1)
#define put2(x) put(rcode, rcode_size, o, (x), 2)
#define put3(x) put(rcode, rcode_size, o, (x), 3)
#define put4(x) put(rcode, rcode_size, o, (x), 4)
#define put5(x,y) put4(x), put1(y)
#define put6(x,y) put4(x), put2(y)
#define put4r(x) put4lsb(rcode, rcode_size, o, x)
#define puta(x) t=U32(size_t(x)), put4r(t)
#define put1a(x,y) put1(x), puta(y)
#define put2a(x,y) put2(x), puta(y)
#define put3a(x,y) put3(x), puta(y)
#define put4a(x,y) put4(x), puta(y)
#define put5a(x,y,z) put4(x), put1(y), puta(z)
#define put2l(x,y) put2(x), t=U32(size_t(y)), put4r(t), \
  t=U32(size_t(y)>>(S*4)), put4r(t)

// Assemble ZPAQL in in the HCOMP section of header to rcode,
// but do not write beyond rcode_size. Return the number of
// bytes output or that would have been output.
// Execution starts at rcode[0] and returns 1 if successful or 0
// in case of a ZPAQL execution error.
int ZPAQL::assemble() {

  // x86? (not foolproof)
  const int S=sizeof(char*);      // 4 = x86, 8 = x86-64
  U32 t=0x12345678;
  if (*(char*)&t!=0x78 || (S!=4 && S!=8))
    error("JIT supported only for x86-32 and x86-64");

  const U8* hcomp=&header[hbegin];
  const int hlen=hend-hbegin+2;
  const int msize=m.size();
  const int hsize=h.size();
  static const int regcode[8]={2,6,7,5}; // a,b,c,d.. -> edx,esi,edi,ebp,eax..
  Array<int> it(hlen);            // hcomp -> rcode locations
  int done=0;  // number of instructions assembled (0..hlen)
  int o=5;  // rcode output index, reserve space for jmp

  // Code for the halt instruction (restore registers and return)
  const int halt=o;
  if (S==8) {
    put2l(0x48b9, &a);        // mov rcx, a
    put2(0x8911);             // mov [rcx], edx
    put2l(0x48b9, &b);        // mov rcx, b
    put2(0x8931);             // mov [rcx], esi
    put2l(0x48b9, &c);        // mov rcx, c
    put2(0x8939);             // mov [rcx], edi
    put2l(0x48b9, &d);        // mov rcx, d
    put2(0x8929);             // mov [rcx], ebp
    put2l(0x48b9, &f);        // mov rcx, f
    put2(0x8919);             // mov [rcx], ebx
    put4(0x4883c408);         // add rsp, 8
    put2(0x415f);             // pop r15
    put2(0x415e);             // pop r14
    put2(0x415d);             // pop r13
    put2(0x415c);             // pop r12
  }
  else {
    put2a(0x8915, &a);        // mov [a], edx
    put2a(0x8935, &b);        // mov [b], esi
    put2a(0x893d, &c);        // mov [c], edi
    put2a(0x892d, &d);        // mov [d], ebp
    put2a(0x891d, &f);        // mov [f], ebx
    put3(0x83c40c);           // add esp, 12
  }
  put1(0x5b);                 // pop ebx
  put1(0x5f);                 // pop edi
  put1(0x5e);                 // pop esi
  put1(0x5d);                 // pop ebp
  put1(0xc3);                 // ret

  // Code for the out instruction.
  // Store a=edx at outbuf[bufptr++]. If full, call flush1().
  const int outlabel=o;
  if (S==8) {
    put2l(0x48b8, &outbuf[0]);// mov rax, outbuf.p
    put2l(0x49ba, &bufptr);   // mov r10, &bufptr
    put3(0x418b0a);           // mov rcx, [r10]
    put3(0x881408);           // mov [rax+rcx], dl
    put2(0xffc1);             // inc rcx
    put3(0x41890a);           // mov [r10], ecx
    put2a(0x81f9, outbuf.size());  // cmp rcx, outbuf.size()
    put2(0x7403);             // jz L1
    put2(0x31c0);             // xor eax, eax
    put1(0xc3);               // ret

    put1(0x55);               // L1: push rbp ; call flush1(this)
    put1(0x57);               // push rdi
    put1(0x56);               // push rsi
    put1(0x52);               // push rdx
    put1(0x51);               // push rcx
    put3(0x4889e5);           // mov rbp, rsp
    put4(0x4883c570);         // add rbp, 112
#if defined(unix) && !defined(__CYGWIN__)
    put2l(0x48bf, this);      // mov rdi, this
#else  // Windows
    put2l(0x48b9, this);      // mov rcx, this
#endif
    put2l(0x49bb, &flush1);   // mov r11, &flush1
    put3(0x41ffd3);           // call r11
    put1(0x59);               // pop rcx
    put1(0x5a);               // pop rdx
    put1(0x5e);               // pop rsi
    put1(0x5f);               // pop rdi
    put1(0x5d);               // pop rbp
  }
  else {
    put1a(0xb8, &outbuf[0]);  // mov eax, outbuf.p
    put2a(0x8b0d, &bufptr);   // mov ecx, [bufptr]
    put3(0x881408);           // mov [eax+ecx], dl
    put2(0xffc1);             // inc ecx
    put2a(0x890d, &bufptr);   // mov [bufptr], ecx
    put2a(0x81f9, outbuf.size());  // cmp ecx, outbuf.size()
    put2(0x7403);             // jz L1
    put2(0x31c0);             // xor eax, eax
    put1(0xc3);               // ret
    put3(0x83ec0c);           // L1: sub esp, 12
    put4(0x89542404);         // mov [esp+4], edx
    put3a(0xc70424, this);    // mov [esp], this
    put1a(0xb8, &flush1);     // mov eax, &flush1
    put2(0xffd0);             // call eax
    put4(0x8b542404);         // mov edx, [esp+4]
    put3(0x83c40c);           // add esp, 12
  }
  put1(0xc3);               // ret

  // Set it[i]=1 for each ZPAQL instruction reachable from the previous
  // instruction + 2 if reachable by a jump (or 3 if both).
  it[0]=2;
  assert(hlen>0 && hcomp[hlen-1]==0);  // ends with error
  do {
    done=0;
    const int NONE=0x80000000;
    for (int i=0; i<hlen; ++i) {
      int op=hcomp[i];
      if (it[i]) {
        int next1=i+oplen(hcomp+i), next2=NONE; // next and jump targets
        if (iserr(op)) next1=NONE;  // error
        if (op==56) next1=NONE, next2=0;  // halt
        if (op==255) next1=NONE, next2=hcomp[i+1]+256*hcomp[i+2]; // lj
        if (op==39||op==47||op==63)next2=i+2+(hcomp[i+1]<<24>>24);// jt,jf,jmp
        if (op==63) next1=NONE;  // jmp
        if ((next2<0 || next2>=hlen) && next2!=NONE) next2=hlen-1; // error
        if (next1>=0 && next1<hlen && !(it[next1]&1)) it[next1]|=1, ++done;
        if (next2>=0 && next2<hlen && !(it[next2]&2)) it[next2]|=2, ++done;
      }
    }
  } while (done>0);

  // Set it[i] bits 2-3 to 4, 8, or 12 if a comparison
  //  (==, <, > respectively) does not need to save the result in f,
  // or if a conditional jump (jt, jf) does not need to read f.
  // This is true if a comparison is followed directly by a jt/jf,
  // the jt/jf is not a jump target, the byte before is not a jump
  // target (for a 2 byte comparison), and for the comparison instruction
  // if both paths after the jt/jf lead to another comparison or error
  // before another jt/jf. At most hlen steps are traced because after
  // that it must be an infinite loop.
  for (int i=0; i<hlen; ++i) {
    const int op1=hcomp[i]; // 216..239 = comparison
    const int i2=i+1+(op1%8==7);  // address of next instruction
    const int op2=hcomp[i2];  // 39,47 = jt,jf
    if (it[i] && op1>=216 && op1<240 && (op2==39 || op2==47)
        && it[i2]==1 && (i2==i+1 || it[i+1]==0)) {
      int code=(op1-208)/8*4; // 4,8,12 is ==,<,>
      it[i2]+=code;  // OK to test CF, ZF instead of f
      for (int j=0; j<2 && code; ++j) {  // trace each path from i2
        int k=i2+2; // branch not taken
        if (j==1) k=i2+2+(hcomp[i2+1]<<24>>24);  // branch taken
        for (int l=0; l<hlen && code; ++l) {  // trace at most hlen steps
          if (k<0 || k>=hlen) break;  // out of bounds, pass
          const int op=hcomp[k];
          if (op==39 || op==47) code=0;  // jt,jf, fail
          else if (op>=216 && op<240) break;  // ==,<,>, pass
          else if (iserr(op)) break;  // error, pass
          else if (op==255) k=hcomp[k+1]+256*hcomp[k+2]; // lj
          else if (op==63) k=k+2+(hcomp[k+1]<<24>>24);  // jmp
          else if (op==56) k=0;  // halt
          else k=k+1+(op%8==7);  // ordinary instruction
        }
      }
      it[i]+=code;  // if > 0 then OK to not save flags in f (bl)
    }
  }

  // Start of run(): Save x86 and load ZPAQL registers
  const int start=o;
  assert(start>=16);
  put1(0x55);          // push ebp/rbp
  put1(0x56);          // push esi/rsi
  put1(0x57);          // push edi/rdi
  put1(0x53);          // push ebx/rbx
  if (S==8) {
    put2(0x4154);      // push r12
    put2(0x4155);      // push r13
    put2(0x4156);      // push r14
    put2(0x4157);      // push r15
    put4(0x4883ec08);  // sub rsp, 8
    put2l(0x48b8, &a); // mov rax, a
    put2(0x8b10);      // mov edx, [rax]
    put2l(0x48b8, &b); // mov rax, b
    put2(0x8b30);      // mov esi, [rax]
    put2l(0x48b8, &c); // mov rax, c
    put2(0x8b38);      // mov edi, [rax]
    put2l(0x48b8, &d); // mov rax, d
    put2(0x8b28);      // mov ebp, [rax]
    put2l(0x48b8, &f); // mov rax, f
    put2(0x8b18);      // mov ebx, [rax]
    put2l(0x49bc, &h[0]);   // mov r12, h
    put2l(0x49bd, &outbuf[0]); // mov r13, outbuf.p
    put2l(0x49be, &r[0]);   // mov r14, r
    put2l(0x49bf, &m[0]);   // mov r15, m
  }
  else {
    put3(0x83ec0c);    // sub esp, 12
    put2a(0x8b15, &a); // mov edx, [a]
    put2a(0x8b35, &b); // mov esi, [b]
    put2a(0x8b3d, &c); // mov edi, [c]
    put2a(0x8b2d, &d); // mov ebp, [d]
    put2a(0x8b1d, &f); // mov ebx, [f]
  }

  // Assemble in multiple passes until every byte of hcomp has a translation
  for (int istart=0; istart<hlen; ++istart) {
    int inc=0;
    for (int i=istart; i<hlen && it[i]; i+=inc) {
      const int code=it[i];
      inc=oplen(hcomp+i);

      // If already assembled, then assemble a jump to it
      U32 t;
      assert(it.isize()>i);
      assert(i>=0 && i<hlen);
      if (code>=16) {
        if (i>istart) {
          int a=code-o;
          if (a>-120 && a<120)
            put2(0xeb00+((a-2)&255)); // jmp short o
          else
            put1a(0xe9, a-5);  // jmp near o
        }
        break;
      }

      // Else assemble the instruction at hcomp[i] to rcode[o]
      else {
        assert(i>=0 && i<it.isize());
        assert(it[i]>0 && it[i]<16);
        assert(o>=16);
        it[i]=o;
        ++done;
        const int op=hcomp[i];
        const int arg=hcomp[i+1]+((op==255)?256*hcomp[i+2]:0);
        const int ddd=op/8%8;
        const int sss=op%8;

        // error instruction: return 1
        if (iserr(op)) {
          put1a(0xb8, 1);         // mov eax, 1
          put1a(0xe9, halt-o-4);  // jmp near halt
          continue;
        }

        // Load source *b, *c, *d, or hash (*b) into eax except:
        // {a,b,c,d}=*d, a{+,-,*,&,|,^,=,==,>,>}=*d: load address to eax
        // {a,b,c,d}={*b,*c}: load source into ddd
        if (op==59 || (op>=64 && op<240 && op%8>=4 && op%8<7)) {
          put2(0x89c0+8*regcode[sss-3+(op==59)]);  // mov eax, {esi,edi,ebp}
          const int sz=(sss==6?hsize:msize)-1;
          if (sz>=128) put1a(0x25, sz);            // and eax, dword msize-1
          else put3(0x83e000+sz);                  // and eax, byte msize-1
          const int move=(op>=64 && op<112); // = or else ddd is eax
          if (sss<6) { // ddd={a,b,c,d,*b,*c}
            if (S==8) put5(0x410fb604+8*move*regcode[ddd],0x07);
                                                   // movzx ddd, byte [r15+rax]
            else put3a(0x0fb680+8*move*regcode[ddd], &m[0]);
                                                   // movzx ddd, byte [m+eax]
          }
          else if ((0x06587000>>(op/8))&1) {// {*b,*c,*d,a/,a%,a&~,a<<,a>>}=*d
            if (S==8) put4(0x418b0484);            // mov eax, [r12+rax*4]
            else put3a(0x8b0485, &h[0]);           // mov eax, [h+eax*4]
          }
        }

        // Load destination address *b, *c, *d or hashd (*d) into ecx
        if ((op>=32 && op<56 && op%8<5) || (op>=96 && op<120) || op==60) {
          put2(0x89c1+8*regcode[op/8%8-3-(op==60)]);// mov ecx,{esi,edi,ebp}
          const int sz=(ddd==6||op==60?hsize:msize)-1;
          if (sz>=128) put2a(0x81e1, sz);   // and ecx, dword sz
          else put3(0x83e100+sz);           // and ecx, byte sz
          if (op/8%8==6 || op==60) { // *d
            if (S==8) put4(0x498d0c8c);     // lea rcx, [r12+rcx*4]
            else put3a(0x8d0c8d, &h[0]);    // lea ecx, [ecx*4+h]
          }
          else { // *b, *c
            if (S==8) put4(0x498d0c0f);     // lea rcx, [r15+rcx]
            else put2a(0x8d89, &m[0]);      // lea ecx, [ecx+h]
          }
        }

        // Translate by opcode
        switch((op/8)&31) {
          case 0:  // ddd = a
          case 1:  // ddd = b
          case 2:  // ddd = c
          case 3:  // ddd = d
            switch(sss) {
              case 0:  // ddd<>a (swap)
                put2(0x87d0+regcode[ddd]);   // xchg edx, ddd
                break;
              case 1:  // ddd++
                put3(0x83c000+256*regcode[ddd]+inc); // add ddd, inc
                break;
              case 2:  // ddd--
                put3(0x83e800+256*regcode[ddd]+inc); // sub ddd, inc
                break;
              case 3:  // ddd!
                put2(0xf7d0+regcode[ddd]);   // not ddd
                break;
              case 4:  // ddd=0
                put2(0x31c0+9*regcode[ddd]); // xor ddd,ddd
                break;
              case 7:  // ddd=r n
                if (S==8)
                  put3a(0x418b86+8*regcode[ddd], arg*4); // mov ddd, [r14+n*4]
                else
                  put2a(0x8b05+8*regcode[ddd], (&r[arg]));//mov ddd, [r+n]
                break;
            }
            break;
          case 4:  // ddd = *b
          case 5:  // ddd = *c
            switch(sss) {
              case 0:  // ddd<>a (swap)
                put2(0x8611);                // xchg dl, [ecx]
                break;
              case 1:  // ddd++
                put3(0x800100+inc);          // add byte [ecx], inc
                break;
              case 2:  // ddd--
                put3(0x802900+inc);          // sub byte [ecx], inc
                break;
              case 3:  // ddd!
                put2(0xf611);                // not byte [ecx]
                break;
              case 4:  // ddd=0
                put2(0x31c0);                // xor eax, eax
                put2(0x8801);                // mov [ecx], al
                break;
              case 7:  // jt, jf
              {
                assert(code>=0 && code<16);
                static const unsigned char jtab[2][4]={{5,4,2,7},{4,5,3,6}};
                               // jnz,je,jb,ja, jz,jne,jae,jbe
                if (code<4) put2(0x84db);    // test bl, bl
                if (arg>=128 && arg-257-i>=0 && o-it[arg-257-i]<120)
                  put2(0x7000+256*jtab[op==47][code/4]); // jx short 0
                else
                  put2a(0x0f80+jtab[op==47][code/4], 0); // jx near 0
                break;
              }
            }
            break;
          case 6:  // ddd = *d
            switch(sss) {
              case 0:  // ddd<>a (swap)
                put2(0x8711);             // xchg edx, [ecx]
                break;
              case 1:  // ddd++
                put3(0x830100+inc);       // add dword [ecx], inc
                break;
              case 2:  // ddd--
                put3(0x832900+inc);       // sub dword [ecx], inc
                break;
              case 3:  // ddd!
                put2(0xf711);             // not dword [ecx]
                break;
              case 4:  // ddd=0
                put2(0x31c0);             // xor eax, eax
                put2(0x8901);             // mov [ecx], eax
                break;
              case 7:  // ddd=r n
                if (S==8)
                  put3a(0x418996, arg*4); // mov [r14+n*4], edx
                else
                  put2a(0x8915, &r[arg]); // mov [r+n], edx
                break;
            }
            break;
          case 7:  // special
            switch(op) {
              case 56: // halt
                put2(0x31c0);             // xor eax, eax  ; return 0
                put1a(0xe9, halt-o-4);    // jmp near halt
                break;
              case 57:  // out
                put1a(0xe8, outlabel-o-4);// call outlabel
                put3(0x83f800);           // cmp eax, 0  ; returned error code
                put2(0x7405);             // je L1:
                put1a(0xe9, halt-o-4);    // jmp near halt ; L1:
                break;
              case 59:  // hash: a = (a + *b + 512) * 773
                put3a(0x8d8410, 512);     // lea edx, [eax+edx+512]
                put2a(0x69d0, 773);       // imul edx, eax, 773
                break;
              case 60:  // hashd: *d = (*d + a + 512) * 773
                put2(0x8b01);             // mov eax, [ecx]
                put3a(0x8d8410, 512);     // lea eax, [eax+edx+512]
                put2a(0x69c0, 773);       // imul eax, eax, 773
                put2(0x8901);             // mov [ecx], eax
                break;
              case 63:  // jmp
                put1a(0xe9, 0);           // jmp near 0 (fill in target later)
                break;
            }
            break;
          case 8:   // a=
          case 9:   // b=
          case 10:  // c=
          case 11:  // d=
            if (sss==7)  // n
              put1a(0xb8+regcode[ddd], arg);         // mov ddd, n
            else if (sss==6) { // *d
              if (S==8)
                put4(0x418b0484+(regcode[ddd]<<11)); // mov ddd, [r12+rax*4]
              else
                put3a(0x8b0485+(regcode[ddd]<<11),&h[0]);// mov ddd, [h+eax*4]
            }
            else if (sss<4) // a, b, c, d
              put2(0x89c0+regcode[ddd]+8*regcode[sss]);// mov ddd,sss
            break;
          case 12:  // *b=
          case 13:  // *c=
            if (sss==7) put3(0xc60100+arg);          // mov byte [ecx], n
            else if (sss==0) put2(0x8811);           // mov byte [ecx], dl
            else {
              if (sss<4) put2(0x89c0+8*regcode[sss]);// mov eax, sss
              put2(0x8801);                          // mov byte [ecx], al
            }
            break;
          case 14:  // *d=
            if (sss<7) put2(0x8901+8*regcode[sss]);  // mov [ecx], sss
            else put2a(0xc701, arg);                 // mov dword [ecx], n
            break;
          case 15: break; // not used
          case 16:  // a+=
            if (sss==6) {
              if (S==8) put4(0x41031484);            // add edx, [r12+rax*4]
              else put3a(0x031485, &h[0]);           // add edx, [h+eax*4]
            }
            else if (sss<7) put2(0x01c2+8*regcode[sss]);// add edx, sss
            else if (arg>=128) put2a(0x81c2, arg);   // add edx, n
            else put3(0x83c200+arg);                 // add edx, byte n
            break;
          case 17:  // a-=
            if (sss==6) {
              if (S==8) put4(0x412b1484);            // sub edx, [r12+rax*4]
              else put3a(0x2b1485, &h[0]);           // sub edx, [h+eax*4]
            }
            else if (sss<7) put2(0x29c2+8*regcode[sss]);// sub edx, sss
            else if (arg>=128) put2a(0x81ea, arg);   // sub edx, n
            else put3(0x83ea00+arg);                 // sub edx, byte n
            break;
          case 18:  // a*=
            if (sss==6) {
              if (S==8) put5(0x410faf14,0x84);       // imul edx, [r12+rax*4]
              else put4a(0x0faf1485, &h[0]);         // imul edx, [h+eax*4]
            }
            else if (sss<7) put3(0x0fafd0+regcode[sss]);// imul edx, sss
            else if (arg>=128) put2a(0x69d2, arg);   // imul edx, n
            else put3(0x6bd200+arg);                 // imul edx, byte n
            break;
          case 19:  // a/=
          case 20:  // a%=
            if (sss<7) put2(0x89c1+8*regcode[sss]);  // mov ecx, sss
            else put1a(0xb9, arg);                   // mov ecx, n
            put2(0x85c9);                            // test ecx, ecx
            put3(0x0f44d1);                          // cmovz edx, ecx
            put2(0x7408-2*(op/8==20));               // jz (over rest)
            put2(0x89d0);                            // mov eax, edx
            put2(0x31d2);                            // xor edx, edx
            put2(0xf7f1);                            // div ecx
            if (op/8==19) put2(0x89c2);              // mov edx, eax
            break;
          case 21:  // a&=
            if (sss==6) {
              if (S==8) put4(0x41231484);            // and edx, [r12+rax*4]
              else put3a(0x231485, &h[0]);           // and edx, [h+eax*4]
            }
            else if (sss<7) put2(0x21c2+8*regcode[sss]);// and edx, sss
            else if (arg>=128) put2a(0x81e2, arg);   // and edx, n
            else put3(0x83e200+arg);                 // and edx, byte n
            break;
          case 22:  // a&~
            if (sss==7) {
              if (arg<128) put3(0x83e200+(~arg&255));// and edx, byte ~n
              else put2a(0x81e2, ~arg);              // and edx, ~n
            }
            else {
              if (sss<4) put2(0x89c0+8*regcode[sss]);// mov eax, sss
              put2(0xf7d0);                          // not eax
              put2(0x21c2);                          // and edx, eax
            }
            break;
          case 23:  // a|=
            if (sss==6) {
              if (S==8) put4(0x410b1484);            // or edx, [r12+rax*4]
              else put3a(0x0b1485, &h[0]);           // or edx, [h+eax*4]
            }
            else if (sss<7) put2(0x09c2+8*regcode[sss]);// or edx, sss
            else if (arg>=128) put2a(0x81ca, arg);   // or edx, n
            else put3(0x83ca00+arg);                 // or edx, byte n
            break;
          case 24:  // a^=
            if (sss==6) {
              if (S==8) put4(0x41331484);            // xor edx, [r12+rax*4]
              else put3a(0x331485, &h[0]);           // xor edx, [h+eax*4]
            }
            else if (sss<7) put2(0x31c2+8*regcode[sss]);// xor edx, sss
            else if (arg>=128) put2a(0x81f2, arg);   // xor edx, byte n
            else put3(0x83f200+arg);                 // xor edx, n
            break;
          case 25:  // a<<=
          case 26:  // a>>=
            if (sss==7)  // sss = n
              put3(0xc1e200+8*256*(op/8==26)+arg);   // shl/shr n
            else {
              put2(0x89c1+8*regcode[sss]);           // mov ecx, sss
              put2(0xd3e2+8*(op/8==26));             // shl/shr edx, cl
            }
            break;
          case 27:  // a==
          case 28:  // a<
          case 29:  // a>
            if (sss==6) {
              if (S==8) put4(0x413b1484);            // cmp edx, [r12+rax*4]
              else put3a(0x3b1485, &h[0]);           // cmp edx, [h+eax*4]
            }
            else if (sss==7)  // sss = n
              put2a(0x81fa, arg);                    // cmp edx, dword n
            else
              put2(0x39c2+8*regcode[sss]);           // cmp edx, sss
            if (code<4) {
              if (op/8==27) put3(0x0f94c3);          // setz bl
              if (op/8==28) put3(0x0f92c3);          // setc bl
              if (op/8==29) put3(0x0f97c3);          // seta bl
            }
            break;
          case 30:  // not used
          case 31:  // 255 = lj
            if (op==255) put1a(0xe9, 0);             // jmp near
            break;
        }
      }
    }
  }

  // Finish first pass
  const int rsize=o;
  if (o>rcode_size) return rsize;

  // Fill in jump addresses (second pass)
  for (int i=0; i<hlen; ++i) {
    if (it[i]<16) continue;
    int op=hcomp[i];
    if (op==39 || op==47 || op==63 || op==255) {  // jt, jf, jmp, lj
      int target=hcomp[i+1];
      if (op==255) target+=hcomp[i+2]*256;  // lj
      else {
        if (target>=128) target-=256;
        target+=i+2;
      }
      if (target<0 || target>=hlen) target=hlen-1;  // runtime ZPAQL error
      o=it[i];
      assert(o>=16 && o<rcode_size);
      if ((op==39 || op==47) && rcode[o]==0x84) o+=2;  // jt, jf -> skip test
      assert(o>=16 && o<rcode_size);
      if (rcode[o]==0x0f) ++o;  // first byte of jz near, jnz near
      assert(o<rcode_size);
      op=rcode[o++];  // x86 opcode
      target=it[target]-o;
      if ((op>=0x72 && op<0x78) || op==0xeb) {  // jx, jmp short
        --target;
        if (target<-128 || target>127)
          error("Cannot code x86 short jump");
        assert(o<rcode_size);
        rcode[o]=target&255;
      }
      else if ((op>=0x82 && op<0x88) || op==0xe9) // jx, jmp near
      {
        target-=4;
        puta(target);
      }
      else assert(false);  // not a x86 jump
    }
  }

  // Jump to start
  o=0;
  put1a(0xe9, start-5);  // jmp near start
  return rsize;
}

//////////////////////// Predictor::assemble_p() /////////////////////

// Assemble the ZPAQL code in the HCOMP section of z.header to pcomp and
// return the number of bytes of x86 or x86-64 code written, or that would
// be written if pcomp were large enough. The code for predict() begins
// at pr.pcomp[0] and update() at pr.pcomp[5], both as jmp instructions.

// The assembled code is equivalent to int predict(Predictor*)
// and void update(Predictor*, int y); The Preditor address is placed in
// edi/rdi. The update bit y is placed in ebp/rbp.

int Predictor::assemble_p() {
  Predictor& pr=*this;
  U8* rcode=pr.pcode;         // x86 output array
  int rcode_size=pcode_size;  // output size
  int o=0;                    // output index in pcode
  const int S=sizeof(char*);  // 4 or 8
  U8* hcomp=&pr.z.header[0];  // The code to translate
#define off(x)  ((char*)&(pr.x)-(char*)&pr)
#define offc(x) ((char*)&(pr.comp[i].x)-(char*)&pr)

  // test for little-endian (probably x86)
  U32 t=0x12345678;
  if (*(char*)&t!=0x78 || (S!=4 && S!=8))
    error("JIT supported only for x86-32 and x86-64");

  // Initialize for predict(). Put predictor address in edi/rdi
  put1a(0xe9, 5);             // jmp predict
  put1a(0, 0x90909000);       // reserve space for jmp update
  put1(0x53);                 // push ebx/rbx
  put1(0x55);                 // push ebp/rbp
  put1(0x56);                 // push esi/rsi
  put1(0x57);                 // push edi/rdi
  if (S==4)
    put4(0x8b7c2414);         // mov edi,[esp+0x14] ; pr
  else {
#if !defined(unix) || defined(__CYGWIN__)
    put3(0x4889cf);           // mov rdi, rcx (1st arg in Win64)
#endif
  }

  // Code predict() for each component
  const int n=hcomp[6];  // number of components
  U8* cp=hcomp+7;
  for (int i=0; i<n; ++i, cp+=compsize[cp[0]]) {
    if (cp-hcomp>=pr.z.cend) error("comp too big");
    if (cp[0]<1 || cp[0]>9) error("invalid component");
    assert(compsize[cp[0]]>0 && compsize[cp[0]]<8);
    switch (cp[0]) {

      case CONS:  // c
        break;

      case CM:  // sizebits limit
        // Component& cr=comp[i];
        // cr.cxt=h[i]^hmap4;
        // p[i]=stretch(cr.cm(cr.cxt)>>17);

        put2a(0x8b87, off(h[i]));              // mov eax, [edi+&h[i]]
        put2a(0x3387, off(hmap4));             // xor eax, [edi+&hmap4]
        put1a(0x25, (1<<cp[1])-1);             // and eax, size-1
        put2a(0x8987, offc(cxt));              // mov [edi+cxt], eax
        if (S==8) put1(0x48);                  // rex.w (esi->rsi)
        put2a(0x8bb7, offc(cm));               // mov esi, [edi+&cm]
        put3(0x8b0486);                        // mov eax, [esi+eax*4]
        put3(0xc1e811);                        // shr eax, 17
        put4a(0x0fbf8447, off(stretcht));      // movsx eax,word[edi+eax*2+..]
        put2a(0x8987, off(p[i]));              // mov [edi+&p[i]], eax
        break;

      case ISSE:  // sizebits j -- c=hi, cxt=bh
        // assert((hmap4&15)>0);
        // if (c8==1 || (c8&0xf0)==16)
        //   cr.c=find(cr.ht, cp[1]+2, h[i]+16*c8);
        // cr.cxt=cr.ht[cr.c+(hmap4&15)];  // bit history
        // int *wt=(int*)&cr.cm[cr.cxt*2];
        // p[i]=clamp2k((wt[0]*p[cp[2]]+wt[1]*64)>>16);

      case ICM: // sizebits
        // assert((hmap4&15)>0);
        // if (c8==1 || (c8&0xf0)==16) cr.c=find(cr.ht, cp[1]+2, h[i]+16*c8);
        // cr.cxt=cr.ht[cr.c+(hmap4&15)];
        // p[i]=stretch(cr.cm(cr.cxt)>>8);
        //
        // Find cxt row in hash table ht. ht has rows of 16 indexed by the low
        // sizebits of cxt with element 0 having the next higher 8 bits for
        // collision detection. If not found after 3 adjacent tries, replace
        // row with lowest element 1 as priority. Return index of row.
        //
        // size_t Predictor::find(Array<U8>& ht, int sizebits, U32 cxt) {
        //  assert(ht.size()==size_t(16)<<sizebits);
        //  int chk=cxt>>sizebits&255;
        //  size_t h0=(cxt*16)&(ht.size()-16);
        //  if (ht[h0]==chk) return h0;
        //  size_t h1=h0^16;
        //  if (ht[h1]==chk) return h1;
        //  size_t h2=h0^32;
        //  if (ht[h2]==chk) return h2;
        //  if (ht[h0+1]<=ht[h1+1] && ht[h0+1]<=ht[h2+1])
        //    return memset(&ht[h0], 0, 16), ht[h0]=chk, h0;
        //  else if (ht[h1+1]<ht[h2+1])
        //    return memset(&ht[h1], 0, 16), ht[h1]=chk, h1;
        //  else
        //    return memset(&ht[h2], 0, 16), ht[h2]=chk, h2;
        // }

        if (S==8) put1(0x48);                  // rex.w
        put2a(0x8bb7, offc(ht));               // mov esi, [edi+&ht]
        put2(0x8b07);                          // mov eax, edi ; c8
        put2(0x89c1);                          // mov ecx, eax ; c8
        put3(0x83f801);                        // cmp eax, 1
        put2(0x740a);                          // je L1
        put1a(0x25, 240);                      // and eax, 0xf0
        put3(0x83f810);                        // cmp eax, 16
        put2(0x7576);                          // jne L2 ; skip find()
           // L1: ; find cxt in ht, return index in eax
        put3(0xc1e104);                        // shl ecx, 4
        put2a(0x038f, off(h[i]));              // add [edi+&h[i]]
        put2(0x89c8);                          // mov eax, ecx ; cxt
        put3(0xc1e902+cp[1]);                  // shr ecx, sizebits+2
        put2a(0x81e1, 255);                    // and eax, 255 ; chk
        put3(0xc1e004);                        // shl eax, 4
        put1a(0x25, (64<<cp[1])-16);           // and eax, ht.size()-16 = h0
        put3(0x3a0c06);                        // cmp cl, [esi+eax] ; ht[h0]
        put2(0x744d);                          // je L3 ; match h0
        put3(0x83f010);                        // xor eax, 16 ; h1
        put3(0x3a0c06);                        // cmp cl, [esi+eax]
        put2(0x7445);                          // je L3 ; match h1
        put3(0x83f030);                        // xor eax, 48 ; h2
        put3(0x3a0c06);                        // cmp cl, [esi+eax]
        put2(0x743d);                          // je L3 ; match h2
          // No checksum match, so replace the lowest priority among h0,h1,h2
        put3(0x83f021);                        // xor eax, 33 ; h0+1
        put3(0x8a1c06);                        // mov bl, [esi+eax] ; ht[h0+1]
        put2(0x89c2);                          // mov edx, eax ; h0+1
        put3(0x83f220);                        // xor edx, 32  ; h2+1
        put3(0x3a1c16);                        // cmp bl, [esi+edx]
        put2(0x7708);                          // ja L4 ; test h1 vs h2
        put3(0x83f230);                        // xor edx, 48  ; h1+1
        put3(0x3a1c16);                        // cmp bl, [esi+edx]
        put2(0x7611);                          // jbe L7 ; replace h0
          // L4: ; h0 is not lowest, so replace h1 or h2
        put3(0x83f010);                        // xor eax, 16 ; h1+1
        put3(0x8a1c06);                        // mov bl, [esi+eax]
        put3(0x83f030);                        // xor eax, 48 ; h2+1
        put3(0x3a1c06);                        // cmp bl, [esi+eax]
        put2(0x7303);                          // jae L7
        put3(0x83f030);                        // xor eax, 48 ; h1+1
          // L7: ; replace row pointed to by eax = h0,h1,h2
        put3(0x83f001);                        // xor eax, 1
        put3(0x890c06);                        // mov [esi+eax], ecx ; chk
        put2(0x31c9);                          // xor ecx, ecx
        put4(0x894c0604);                      // mov [esi+eax+4], ecx
        put4(0x894c0608);                      // mov [esi+eax+8], ecx
        put4(0x894c060c);                      // mov [esi+eax+12], ecx
          // L3: ; save nibble context (in eax) in c
        put2a(0x8987, offc(c));                // mov [edi+c], eax
        put2(0xeb06);                          // jmp L8
          // L2: ; get nibble context
        put2a(0x8b87, offc(c));                // mov eax, [edi+c]
          // L8: ; nibble context is in eax
        put2a(0x8b97, off(hmap4));             // mov edx, [edi+&hmap4]
        put3(0x83e20f);                        // and edx, 15  ; hmap4
        put2(0x01d0);                          // add eax, edx ; c+(hmap4&15)
        put4(0x0fb61406);                      // movzx edx, byte [esi+eax]
        put2a(0x8997, offc(cxt));              // mov [edi+&cxt], edx ; cxt=bh
        if (S==8) put1(0x48);                  // rex.w
        put2a(0x8bb7, offc(cm));               // mov esi, [edi+&cm] ; cm

        // esi points to cm[256] (ICM) or cm[512] (ISSE) with 23 bit
        // prediction (ICM) or a pair of 20 bit signed weights (ISSE).
        // cxt = bit history bh (0..255) is in edx.
        if (cp[0]==ICM) {
          put3(0x8b0496);                      // mov eax, [esi+edx*4];cm[bh]
          put3(0xc1e808);                      // shr eax, 8
          put4a(0x0fbf8447, off(stretcht));    // movsx eax,word[edi+eax*2+..]
        }
        else {  // ISSE
          put2a(0x8b87, off(p[cp[2]]));        // mov eax, [edi+&p[j]]
          put4(0x0faf04d6);                    // imul eax, [esi+edx*8] ;wt[0]
          put4(0x8b4cd604);                    // mov ecx, [esi+edx*8+4];wt[1]
          put3(0xc1e106);                      // shl ecx, 6
          put2(0x01c8);                        // add eax, ecx
          put3(0xc1f810);                      // sar eax, 16
          put1a(0xb9, 2047);                   // mov ecx, 2047
          put2(0x39c8);                        // cmp eax, ecx
          put3(0x0f4fc1);                      // cmovg eax, ecx
          put1a(0xb9, -2048);                  // mov ecx, -2048
          put2(0x39c8);                        // cmp eax, ecx
          put3(0x0f4cc1);                      // cmovl eax, ecx

        }
        put2a(0x8987, off(p[i]));              // mov [edi+&p[i]], eax
        break;

      case MATCH: // sizebits bufbits: a=len, b=offset, c=bit, cxt=bitpos,
                  //                   ht=buf, limit=pos
        // assert(cr.cm.size()==(size_t(1)<<cp[1]));
        // assert(cr.ht.size()==(size_t(1)<<cp[2]));
        // assert(cr.a<=255);
        // assert(cr.c==0 || cr.c==1);
        // assert(cr.cxt<8);
        // assert(cr.limit<cr.ht.size());
        // if (cr.a==0) p[i]=0;
        // else {
        //   cr.c=(cr.ht(cr.limit-cr.b)>>(7-cr.cxt))&1; // predicted bit
        //   p[i]=stretch(dt2k[cr.a]*(cr.c*-2+1)&32767);
        // }

        if (S==8) put1(0x48);          // rex.w
        put2a(0x8bb7, offc(ht));       // mov esi, [edi+&ht]

        // If match length (a) is 0 then p[i]=0
        put2a(0x8b87, offc(a));        // mov eax, [edi+&a]
        put2(0x85c0);                  // test eax, eax
        put2(0x7449);                  // jz L2 ; p[i]=0

        // Else put predicted bit in c
        put1a(0xb9, 7);                // mov ecx, 7
        put2a(0x2b8f, offc(cxt));      // sub ecx, [edi+&cxt]
        put2a(0x8b87, offc(limit));    // mov eax, [edi+&limit]
        put2a(0x2b87, offc(b));        // sub eax, [edi+&b]
        put1a(0x25, (1<<cp[2])-1);     // and eax, ht.size()-1
        put4(0x0fb60406);              // movzx eax, byte [esi+eax]
        put2(0xd3e8);                  // shr eax, cl
        put3(0x83e001);                // and eax, 1  ; predicted bit
        put2a(0x8987, offc(c));        // mov [edi+&c], eax ; c

        // p[i]=stretch(dt2k[cr.a]*(cr.c*-2+1)&32767);
        put2a(0x8b87, offc(a));        // mov eax, [edi+&a]
        put3a(0x8b8487, off(dt2k));    // mov eax, [edi+eax*4+&dt2k] ; weight
        put2(0x7402);                  // jz L1 ; z if c==0
        put2(0xf7d8);                  // neg eax
        put1a(0x25, 0x7fff);           // L1: and eax, 32767
        put4a(0x0fbf8447, off(stretcht)); //movsx eax, word [edi+eax*2+...]
        put2a(0x8987, off(p[i]));      // L2: mov [edi+&p[i]], eax
        break;

      case AVG: // j k wt
        // p[i]=(p[cp[1]]*cp[3]+p[cp[2]]*(256-cp[3]))>>8;

        put2a(0x8b87, off(p[cp[1]]));  // mov eax, [edi+&p[j]]
        put2a(0x2b87, off(p[cp[2]]));  // sub eax, [edi+&p[k]]
        put2a(0x69c0, cp[3]);          // imul eax, wt
        put3(0xc1f808);                // sar eax, 8
        put2a(0x0387, off(p[cp[2]]));  // add eax, [edi+&p[k]]
        put2a(0x8987, off(p[i]));      // mov [edi+&p[i]], eax
        break;

      case MIX2:   // sizebits j k rate mask
                   // c=size cm=wt[size] cxt=input
        // cr.cxt=((h[i]+(c8&cp[5]))&(cr.c-1));
        // assert(cr.cxt<cr.a16.size());
        // int w=cr.a16[cr.cxt];
        // assert(w>=0 && w<65536);
        // p[i]=(w*p[cp[2]]+(65536-w)*p[cp[3]])>>16;
        // assert(p[i]>=-2048 && p[i]<2048);

        put2(0x8b07);                  // mov eax, [edi] ; c8
        put1a(0x25, cp[5]);            // and eax, mask
        put2a(0x0387, off(h[i]));      // add eax, [edi+&h[i]]
        put1a(0x25, (1<<cp[1])-1);     // and eax, size-1
        put2a(0x8987, offc(cxt));      // mov [edi+&cxt], eax ; cxt
        if (S==8) put1(0x48);          // rex.w
        put2a(0x8bb7, offc(a16));      // mov esi, [edi+&a16]
        put4(0x0fb70446);              // movzx eax, word [edi+eax*2] ; w
        put2a(0x8b8f, off(p[cp[2]]));  // mov ecx, [edi+&p[j]]
        put2a(0x8b97, off(p[cp[3]]));  // mov edx, [edi+&p[k]]
        put2(0x29d1);                  // sub ecx, edx
        put3(0x0fafc8);                // imul ecx, eax
        put3(0xc1e210);                // shl edx, 16
        put2(0x01d1);                  // add ecx, edx
        put3(0xc1f910);                // sar ecx, 16
        put2a(0x898f, off(p[i]));      // mov [edi+&p[i]]
        break;

      case MIX:    // sizebits j m rate mask
                   // c=size cm=wt[size][m] cxt=index of wt in cm
        // int m=cp[3];
        // assert(m>=1 && m<=i);
        // cr.cxt=h[i]+(c8&cp[5]);
        // cr.cxt=(cr.cxt&(cr.c-1))*m; // pointer to row of weights
        // assert(cr.cxt<=cr.cm.size()-m);
        // int* wt=(int*)&cr.cm[cr.cxt];
        // p[i]=0;
        // for (int j=0; j<m; ++j)
        //   p[i]+=(wt[j]>>8)*p[cp[2]+j];
        // p[i]=clamp2k(p[i]>>8);

        put2(0x8b07);                          // mov eax, [edi] ; c8
        put1a(0x25, cp[5]);                    // and eax, mask
        put2a(0x0387, off(h[i]));              // add eax, [edi+&h[i]]
        put1a(0x25, (1<<cp[1])-1);             // and eax, size-1
        put2a(0x69c0, cp[3]);                  // imul eax, m
        put2a(0x8987, offc(cxt));              // mov [edi+&cxt], eax ; cxt
        if (S==8) put1(0x48);                  // rex.w
        put2a(0x8bb7, offc(cm));               // mov esi, [edi+&cm]
        if (S==8) put1(0x48);                  // rex.w
        put3(0x8d3486);                        // lea esi, [esi+eax*4] ; wt

        // Unroll summation loop: esi=wt[0..m-1]
        for (int k=0; k<cp[3]; k+=8) {
          const int tail=cp[3]-k;  // number of elements remaining

          // pack 8 elements of wt in xmm1, 8 elements of p in xmm3
          put4a(0xf30f6f8e, k*4);              // movdqu xmm1, [esi+k*4]
          if (tail>3) put4a(0xf30f6f96, k*4+16);//movdqu xmm2, [esi+k*4+16]
          put5(0x660f72e1,0x08);               // psrad xmm1, 8
          if (tail>3) put5(0x660f72e2,0x08);   // psrad xmm2, 8
          put4(0x660f6bca);                    // packssdw xmm1, xmm2
          put4a(0xf30f6f9f, off(p[cp[2]+k]));  // movdqu xmm3, [edi+&p[j+k]]
          if (tail>3)
            put4a(0xf30f6fa7,off(p[cp[2]+k+4]));//movdqu xmm4, [edi+&p[j+k+4]]
          put4(0x660f6bdc);                    // packssdw, xmm3, xmm4
          if (tail>0 && tail<8) {  // last loop, mask extra weights
            put4(0x660f76ed);                  // pcmpeqd xmm5, xmm5 ; -1
            put5(0x660f73dd, 16-tail*2);       // psrldq xmm5, 16-tail*2
            put4(0x660fdbcd);                  // pand xmm1, xmm5
          }
          if (k==0) {  // first loop, initialize sum in xmm0
            put4(0xf30f6fc1);                  // movdqu xmm0, xmm1
            put4(0x660ff5c3);                  // pmaddwd xmm0, xmm3
          }
          else {  // accumulate sum in xmm0
            put4(0x660ff5cb);                  // pmaddwd xmm1, xmm3
            put4(0x660ffec1);                  // paddd xmm0, xmm1
          }
        }

        // Add up the 4 elements of xmm0 = p[i] in the first element
        put4(0xf30f6fc8);                      // movdqu xmm1, xmm0
        put5(0x660f73d9,0x08);                 // psrldq xmm1, 8
        put4(0x660ffec1);                      // paddd xmm0, xmm1
        put4(0xf30f6fc8);                      // movdqu xmm1, xmm0
        put5(0x660f73d9,0x04);                 // psrldq xmm1, 4
        put4(0x660ffec1);                      // paddd xmm0, xmm1
        put4(0x660f7ec0);                      // movd eax, xmm0 ; p[i]
        put3(0xc1f808);                        // sar eax, 8
        put1a(0x3d, 2047);                     // cmp eax, 2047
        put2(0x7e05);                          // jle L1
        put1a(0xb8, 2047);                     // mov eax, 2047
        put1a(0x3d, -2048);                    // L1: cmp eax, -2048
        put2(0x7d05);                          // jge, L2
        put1a(0xb8, -2048);                    // mov eax, -2048
        put2a(0x8987, off(p[i]));              // L2: mov [edi+&p[i]], eax
        break;

      case SSE:  // sizebits j start limit
        // cr.cxt=(h[i]+c8)*32;
        // int pq=p[cp[2]]+992;
        // if (pq<0) pq=0;
        // if (pq>1983) pq=1983;
        // int wt=pq&63;
        // pq>>=6;
        // assert(pq>=0 && pq<=30);
        // cr.cxt+=pq;
        // p[i]=stretch(((cr.cm(cr.cxt)>>10)*(64-wt)       // p0
        //               +(cr.cm(cr.cxt+1)>>10)*wt)>>13);  // p1
        // // p = p0*(64-wt)+p1*wt = (p1-p0)*wt + p0*64
        // cr.cxt+=wt>>5;

        put2a(0x8b8f, off(h[i]));      // mov ecx, [edi+&h[i]]
        put2(0x030f);                  // add ecx, [edi]  ; c0
        put2a(0x81e1, (1<<cp[1])-1);   // and ecx, size-1
        put3(0xc1e105);                // shl ecx, 5  ; cxt in 0..size*32-32
        put2a(0x8b87, off(p[cp[2]]));  // mov eax, [edi+&p[j]] ; pq
        put1a(0x05, 992);              // add eax, 992
        put2(0x31d2);                  // xor edx, edx ; 0
        put2(0x39d0);                  // cmp eax, edx
        put3(0x0f4cc2);                // cmovl eax, edx
        put1a(0xba, 1983);             // mov edx, 1983
        put2(0x39d0);                  // cmp eax, edx
        put3(0x0f4fc2);                // cmovg eax, edx ; pq in 0..1983
        put2(0x89c2);                  // mov edx, eax
        put3(0x83e23f);                // and edx, 63  ; wt in 0..63
        put3(0xc1e806);                // shr eax, 6   ; pq in 0..30
        put2(0x01c1);                  // add ecx, eax ; cxt in 0..size*32-2
        if (S==8) put1(0x48);          // rex.w
        put2a(0x8bb7, offc(cm));       // mov esi, [edi+cm]
        put3(0x8b048e);                // mov eax, [esi+ecx*4] ; cm[cxt]
        put4(0x8b5c8e04);              // mov ebx, [esi+ecx*4+4] ; cm[cxt+1]
        put3(0x83fa20);                // cmp edx, 32  ; wt
        put3(0x83d9ff);                // sbb ecx, -1  ; cxt+=wt>>5
        put2a(0x898f, offc(cxt));      // mov [edi+cxt], ecx  ; cxt saved
        put3(0xc1e80a);                // shr eax, 10 ; p0 = cm[cxt]>>10
        put3(0xc1eb0a);                // shr ebx, 10 ; p1 = cm[cxt+1]>>10
        put2(0x29c3);                  // sub ebx, eax, ; p1-p0
        put3(0x0fafda);                // imul ebx, edx ; (p1-p0)*wt
        put3(0xc1e006);                // shr eax, 6
        put2(0x01d8);                  // add eax, ebx ; p in 0..2^28-1
        put3(0xc1e80d);                // shr eax, 13  ; p in 0..32767
        put4a(0x0fbf8447, off(stretcht));  // movsx eax, word [edi+eax*2+...]
        put2a(0x8987, off(p[i]));      // mov [edi+&p[i]], eax
        break;

      default:
        error("invalid ZPAQ component");
    }
  }

  // return squash(p[n-1])
  put2a(0x8b87, off(p[n-1]));          // mov eax, [edi+...]
  put1a(0x05, 0x800);                  // add eax, 2048
  put4a(0x0fbf8447, off(squasht[0]));  // movsx eax, word [edi+eax*2+...]
  put1(0x5f);                          // pop edi
  put1(0x5e);                          // pop esi
  put1(0x5d);                          // pop ebp
  put1(0x5b);                          // pop ebx
  put1(0xc3);                          // ret

  // Initialize for update() Put predictor address in edi/rdi
  // and bit y=0..1 in ebp
  int save_o=o;
  o=5;
  put1a(0xe9, save_o-10);      // jmp update
  o=save_o;
  put1(0x53);                  // push ebx/rbx
  put1(0x55);                  // push ebp/rbp
  put1(0x56);                  // push esi/rsi
  put1(0x57);                  // push edi/rdi
  if (S==4) {
    put4(0x8b7c2414);          // mov edi,[esp+0x14] ; (1st arg = pr)
    put4(0x8b6c2418);          // mov ebp,[esp+0x18] ; (2nd arg = y)
  }
  else {
#if defined(unix) && !defined(__CYGWIN__)  // (1st arg already in rdi)
    put3(0x4889f5);            // mov rbp, rsi (2nd arg in Linux-64)
#else
    put3(0x4889cf);            // mov rdi, rcx (1st arg in Win64)
    put3(0x4889d5);            // mov rbp, rdx (2nd arg)
#endif
  }

  // Code update() for each component
  cp=hcomp+7;
  for (int i=0; i<n; ++i, cp+=compsize[cp[0]]) {
    assert(cp-hcomp<pr.z.cend);
    assert (cp[0]>=1 && cp[0]<=9);
    assert(compsize[cp[0]]>0 && compsize[cp[0]]<8);
    switch (cp[0]) {

      case CONS:  // c
        break;

      case SSE:  // sizebits j start limit
      case CM:   // sizebits limit
        // train(cr, y);
        //
        // reduce prediction error in cr.cm
        // void train(Component& cr, int y) {
        //   assert(y==0 || y==1);
        //   U32& pn=cr.cm(cr.cxt);
        //   U32 count=pn&0x3ff;
        //   int error=y*32767-(cr.cm(cr.cxt)>>17);
        //   pn+=(error*dt[count]&-1024)+(count<cr.limit);

        if (S==8) put1(0x48);          // rex.w (esi->rsi)
        put2a(0x8bb7, offc(cm));       // mov esi,[edi+cm]  ; cm
        put2a(0x8b87, offc(cxt));      // mov eax,[edi+cxt] ; cxt
        put1a(0x25, pr.comp[i].cm.size()-1);  // and eax, size-1
        if (S==8) put1(0x48);          // rex.w
        put3(0x8d3486);                // lea esi,[esi+eax*4] ; &cm[cxt]
        put2(0x8b06);                  // mov eax,[esi] ; cm[cxt]
        put2(0x89c2);                  // mov edx, eax  ; cm[cxt]
        put3(0xc1e811);                // shr eax, 17   ; cm[cxt]>>17
        put2(0x89e9);                  // mov ecx, ebp  ; y
        put3(0xc1e10f);                // shl ecx, 15   ; y*32768
        put2(0x29e9);                  // sub ecx, ebp  ; y*32767
        put2(0x29c1);                  // sub ecx, eax  ; error
        put2a(0x81e2, 0x3ff);          // and edx, 1023 ; count
        put3a(0x8b8497, off(dt));      // mov eax,[edi+edx*4+dt] ; dt[count]
        put3(0x0fafc8);                // imul ecx, eax ; error*dt[count]
        put2a(0x81e1, 0xfffffc00);     // and ecx, -1024
        put2a(0x81fa, cp[2+2*(cp[0]==SSE)]*4); // cmp edx, limit*4
        put2(0x110e);                  // adc [esi], ecx ; pn+=...
        break;

      case ICM:   // sizebits: cxt=bh, ht[c][0..15]=bh row
        // cr.ht[cr.c+(hmap4&15)]=st.next(cr.ht[cr.c+(hmap4&15)], y);
        // U32& pn=cr.cm(cr.cxt);
        // pn+=int(y*32767-(pn>>8))>>2;

      case ISSE:  // sizebits j  -- c=hi, cxt=bh
        // assert(cr.cxt==cr.ht[cr.c+(hmap4&15)]);
        // int err=y*32767-squash(p[i]);
        // int *wt=(int*)&cr.cm[cr.cxt*2];
        // wt[0]=clamp512k(wt[0]+((err*p[cp[2]]+(1<<12))>>13));
        // wt[1]=clamp512k(wt[1]+((err+16)>>5));
        // cr.ht[cr.c+(hmap4&15)]=st.next(cr.cxt, y);

        // update bit history bh to next(bh,y=ebp) in ht[c+(hmap4&15)]
        put3(0x8b4700+off(hmap4));     // mov eax, [edi+&hmap4]
        put3(0x83e00f);                // and eax, 15
        put2a(0x0387, offc(c));        // add eax [edi+&c] ; cxt
        if (S==8) put1(0x48);          // rex.w
        put2a(0x8bb7, offc(ht));       // mov esi, [edi+&ht]
        put4(0x0fb61406);              // movzx edx, byte [esi+eax] ; bh
        put4(0x8d5c9500);              // lea ebx, [ebp+edx*4] ; index to st
        put4a(0x0fb69c1f, off(st));    // movzx ebx,byte[edi+ebx+st]; next bh
        put3(0x881c06);                // mov [esi+eax], bl ; save next bh
        if (S==8) put1(0x48);          // rex.w
        put2a(0x8bb7, offc(cm));       // mov esi, [edi+&cm]

        // ICM: update cm[cxt=edx=bit history] to reduce prediction error
        // esi = &cm
        if (cp[0]==ICM) {
          if (S==8) put1(0x48);        // rex.w
          put3(0x8d3496);              // lea esi, [esi+edx*4] ; &cm[bh]
          put2(0x8b06);                // mov eax, [esi] ; pn
          put3(0xc1e808);              // shr eax, 8 ; pn>>8
          put2(0x89e9);                // mov ecx, ebp ; y
          put3(0xc1e10f);              // shl ecx, 15
          put2(0x29e9);                // sub ecx, ebp ; y*32767
          put2(0x29c1);                // sub ecx, eax
          put3(0xc1f902);              // sar ecx, 2
          put2(0x010e);                // add [esi], ecx
        }

        // ISSE: update weights. edx=cxt=bit history (0..255), esi=cm[512]
        else {
          put2a(0x8b87, off(p[i]));    // mov eax, [edi+&p[i]]
          put1a(0x05, 2048);           // add eax, 2048
          put4a(0x0fb78447, off(squasht)); // movzx eax, word [edi+eax*2+..]
          put2(0x89e9);                // mov ecx, ebp ; y
          put3(0xc1e10f);              // shl ecx, 15
          put2(0x29e9);                // sub ecx, ebp ; y*32767
          put2(0x29c1);                // sub ecx, eax ; err
          put2a(0x8b87, off(p[cp[2]]));// mov eax, [edi+&p[j]]
          put3(0x0fafc1);              // imul eax, ecx
          put1a(0x05, (1<<12));        // add eax, 4096
          put3(0xc1f80d);              // sar eax, 13
          put3(0x0304d6);              // add eax, [esi+edx*8] ; wt[0]
          put1a(0x3d, (1<<19)-1);      // cmp eax, (1<<19)-1
          put2(0x7e05);                // jle L1
          put1a(0xb8, (1<<19)-1);      // mov eax, (1<<19)-1
          put1a(0x3d, 0xfff80000);     // cmp eax, -1<<19
          put2(0x7d05);                // jge L2
          put1a(0xb8, 0xfff80000);     // mov eax, -1<<19
          put3(0x8904d6);              // L2: mov [esi+edx*8], eax
          put3(0x83c110);              // add ecx, 16 ; err
          put3(0xc1f905);              // sar ecx, 5
          put4(0x034cd604);            // add ecx, [esi+edx*8+4] ; wt[1]
          put2a(0x81f9, (1<<19)-1);    // cmp ecx, (1<<19)-1
          put2(0x7e05);                // jle L3
          put1a(0xb9, (1<<19)-1);      // mov ecx, (1<<19)-1
          put2a(0x81f9, 0xfff80000);   // cmp ecx, -1<<19
          put2(0x7d05);                // jge L4
          put1a(0xb9, 0xfff80000);     // mov ecx, -1<<19
          put4(0x894cd604);            // L4: mov [esi+edx*8+4], ecx
        }
        break;

      case MATCH: // sizebits bufbits:
                  //   a=len, b=offset, c=bit, cm=index, cxt=bitpos
                  //   ht=buf, limit=pos
        // assert(cr.a<=255);
        // assert(cr.c==0 || cr.c==1);
        // assert(cr.cxt<8);
        // assert(cr.cm.size()==(size_t(1)<<cp[1]));
        // assert(cr.ht.size()==(size_t(1)<<cp[2]));
        // if (int(cr.c)!=y) cr.a=0;  // mismatch?
        // cr.ht(cr.limit)+=cr.ht(cr.limit)+y;
        // if (++cr.cxt==8) {
        //   cr.cxt=0;
        //   ++cr.limit;
        //   cr.limit&=(1<<cp[2])-1;
        //   if (cr.a==0) {  // look for a match
        //     cr.b=cr.limit-cr.cm(h[i]);
        //     if (cr.b&(cr.ht.size()-1))
        //       while (cr.a<255
        //              && cr.ht(cr.limit-cr.a-1)==cr.ht(cr.limit-cr.a-cr.b-1))
        //         ++cr.a;
        //   }
        //   else cr.a+=cr.a<255;
        //   cr.cm(h[i])=cr.limit;
        // }

        // Set pointers ebx=&cm, esi=&ht
        if (S==8) put1(0x48);          // rex.w
        put2a(0x8bb7, offc(ht));       // mov esi, [edi+&ht]
        if (S==8) put1(0x48);          // rex.w
        put2a(0x8b9f, offc(cm));       // mov ebx, [edi+&cm]

        // if (c!=y) a=0;
        put2a(0x8b87, offc(c));        // mov eax, [edi+&c]
        put2(0x39e8);                  // cmp eax, ebp ; y
        put2(0x7408);                  // jz L1
        put2(0x31c0);                  // xor eax, eax
        put2a(0x8987, offc(a));        // mov [edi+&a], eax

        // ht(limit)+=ht(limit)+y  (1E)
        put2a(0x8b87, offc(limit));    // mov eax, [edi+&limit]
        put4(0x0fb60c06);              // movzx, ecx, byte [esi+eax]
        put2(0x01c9);                  // add ecx, ecx
        put2(0x01e9);                  // add ecx, ebp
        put3(0x880c06);                // mov [esi+eax], cl

        // if (++cxt==8)
        put2a(0x8b87, offc(cxt));      // mov eax, [edi+&cxt]
        put2(0xffc0);                  // inc eax
        put3(0x83e007);                // and eax,byte +0x7
        put2a(0x8987, offc(cxt));      // mov [edi+&cxt],eax
        put2a(0x0f85, 0x9b);           // jnz L8

        // ++limit;
        // limit&=bufsize-1;
        put2a(0x8b87, offc(limit));    // mov eax,[edi+&limit]
        put2(0xffc0);                  // inc eax
        put1a(0x25, (1<<cp[2])-1);     // and eax, bufsize-1
        put2a(0x8987, offc(limit));    // mov [edi+&limit],eax

        // if (a==0)
        put2a(0x8b87, offc(a));        // mov eax, [edi+&a]
        put2(0x85c0);                  // test eax,eax
        put2(0x755c);                  // jnz L6

        //   b=limit-cm(h[i])
        put2a(0x8b8f, off(h[i]));      // mov ecx,[edi+h[i]]
        put2a(0x81e1, (1<<cp[1])-1);   // and ecx, size-1
        put2a(0x8b87, offc(limit));    // mov eax,[edi-&limit]
        put3(0x2b048b);                // sub eax,[ebx+ecx*4]
        put2a(0x8987, offc(b));        // mov [edi+&b],eax

        //   if (b&(bufsize-1))
        put1a(0xa9, (1<<cp[2])-1);     // test eax, bufsize-1
        put2(0x7448);                  // jz L7

        //      while (a<255 && ht(limit-a-1)==ht(limit-a-b-1)) ++a;
        put1(0x53);                    // push ebx
        put2a(0x8b9f, offc(limit));    // mov ebx,[edi+&limit]
        put2(0x89da);                  // mov edx,ebx
        put2(0x29c3);                  // sub ebx,eax  ; limit-b
        put2(0x31c9);                  // xor ecx,ecx  ; a=0
        put2a(0x81f9, 0xff);           // L2: cmp ecx,0xff ; while
        put2(0x741c);                  // jz L3 ; break
        put2(0xffca);                  // dec edx
        put2(0xffcb);                  // dec ebx
        put2a(0x81e2, (1<<cp[2])-1);   // and edx, bufsize-1
        put2a(0x81e3, (1<<cp[2])-1);   // and ebx, bufsize-1
        put3(0x8a0416);                // mov al,[esi+edx]
        put3(0x3a041e);                // cmp al,[esi+ebx]
        put2(0x7504);                  // jnz L3 ; break
        put2(0xffc1);                  // inc ecx
        put2(0xebdc);                  // jmp short L2 ; end while
        put1(0x5b);                    // L3: pop ebx
        put2a(0x898f, offc(a));        // mov [edi+&a],ecx
        put2(0xeb0e);                  // jmp short L7

        // a+=(a<255)
        put1a(0x3d, 0xff);             // L6: cmp eax, 0xff ; a
        put3(0x83d000);                // adc eax, 0
        put2a(0x8987, offc(a));        // mov [edi+&a],eax

        // cm(h[i])=limit
        put2a(0x8b87, off(h[i]));      // L7: mov eax,[edi+&h[i]]
        put1a(0x25, (1<<cp[1])-1);     // and eax, size-1
        put2a(0x8b8f, offc(limit));    // mov ecx,[edi+&limit]
        put3(0x890c83);                // mov [ebx+eax*4],ecx
                                       // L8:
        break;

      case AVG:  // j k wt
        break;

      case MIX2: // sizebits j k rate mask
                 // cm=wt[size], cxt=input
        // assert(cr.a16.size()==cr.c);
        // assert(cr.cxt<cr.a16.size());
        // int err=(y*32767-squash(p[i]))*cp[4]>>5;
        // int w=cr.a16[cr.cxt];
        // w+=(err*(p[cp[2]]-p[cp[3]])+(1<<12))>>13;
        // if (w<0) w=0;
        // if (w>65535) w=65535;
        // cr.a16[cr.cxt]=w;

        // set ecx=err
        put2a(0x8b87, off(p[i]));      // mov eax, [edi+&p[i]]
        put1a(0x05, 2048);             // add eax, 2048
        put4a(0x0fb78447, off(squasht));//movzx eax, word [edi+eax*2+&squasht]
        put2(0x89e9);                  // mov ecx, ebp ; y
        put3(0xc1e10f);                // shl ecx, 15
        put2(0x29e9);                  // sub ecx, ebp ; y*32767
        put2(0x29c1);                  // sub ecx, eax
        put2a(0x69c9, cp[4]);          // imul ecx, rate
        put3(0xc1f905);                // sar ecx, 5  ; err

        // Update w
        put2a(0x8b87, offc(cxt));      // mov eax, [edi+&cxt]
        if (S==8) put1(0x48);          // rex.w
        put2a(0x8bb7, offc(a16));      // mov esi, [edi+&a16]
        if (S==8) put1(0x48);          // rex.w
        put3(0x8d3446);                // lea esi, [esi+eax*2] ; &w
        put2a(0x8b87, off(p[cp[2]]));  // mov eax, [edi+&p[j]]
        put2a(0x2b87, off(p[cp[3]]));  // sub eax, [edi+&p[k]] ; p[j]-p[k]
        put3(0x0fafc1);                // imul eax, ecx  ; * err
        put1a(0x05, 1<<12);            // add eax, 4096
        put3(0xc1f80d);                // sar eax, 13
        put3(0x0fb716);                // movzx edx, word [esi] ; w
        put2(0x01d0);                  // add eax, edx
        put1a(0xba, 0xffff);           // mov edx, 65535
        put2(0x39d0);                  // cmp eax, edx
        put3(0x0f4fc2);                // cmovg eax, edx
        put2(0x31d2);                  // xor edx, edx
        put2(0x39d0);                  // cmp eax, edx
        put3(0x0f4cc2);                // cmovl eax, edx
        put3(0x668906);                // mov word [esi], ax
        break;

      case MIX: // sizebits j m rate mask
                // cm=wt[size][m], cxt=input
        // int m=cp[3];
        // assert(m>0 && m<=i);
        // assert(cr.cm.size()==m*cr.c);
        // assert(cr.cxt+m<=cr.cm.size());
        // int err=(y*32767-squash(p[i]))*cp[4]>>4;
        // int* wt=(int*)&cr.cm[cr.cxt];
        // for (int j=0; j<m; ++j)
        //   wt[j]=clamp512k(wt[j]+((err*p[cp[2]+j]+(1<<12))>>13));

        // set ecx=err
        put2a(0x8b87, off(p[i]));      // mov eax, [edi+&p[i]]
        put1a(0x05, 2048);             // add eax, 2048
        put4a(0x0fb78447, off(squasht));//movzx eax, word [edi+eax*2+&squasht]
        put2(0x89e9);                  // mov ecx, ebp ; y
        put3(0xc1e10f);                // shl ecx, 15
        put2(0x29e9);                  // sub ecx, ebp ; y*32767
        put2(0x29c1);                  // sub ecx, eax
        put2a(0x69c9, cp[4]);          // imul ecx, rate
        put3(0xc1f904);                // sar ecx, 4  ; err

        // set esi=wt
        put2a(0x8b87, offc(cxt));      // mov eax, [edi+&cxt] ; cxt
        if (S==8) put1(0x48);          // rex.w
        put2a(0x8bb7, offc(cm));       // mov esi, [edi+&cm]
        if (S==8) put1(0x48);          // rex.w
        put3(0x8d3486);                // lea esi, [esi+eax*4] ; wt

        for (int k=0; k<cp[3]; ++k) {
          put2a(0x8b87,off(p[cp[2]+k]));//mov eax, [edi+&p[cp[2]+k]
          put3(0x0fafc1);              // imul eax, ecx
          put1a(0x05, 1<<12);          // add eax, 1<<12
          put3(0xc1f80d);              // sar eax, 13
          put2(0x0306);                // add eax, [esi]
          put1a(0x3d, (1<<19)-1);      // cmp eax, (1<<19)-1
          put2(0x7e05);                // jge L1
          put1a(0xb8, (1<<19)-1);      // mov eax, (1<<19)-1
          put1a(0x3d, 0xfff80000);     // cmp eax, -1<<19
          put2(0x7d05);                // jle L2
          put1a(0xb8, 0xfff80000);     // mov eax, -1<<19
          put2(0x8906);                // L2: mov [esi], eax
          if (k<cp[3]-1) {
            if (S==8) put1(0x48);      // rex.w
            put3(0x83c604);            // add esi, 4
          }
        }
        break;

      default:
        error("invalid ZPAQ component");
    }
  }

  // return from update()
  put1(0x5f);                 // pop edi
  put1(0x5e);                 // pop esi
  put1(0x5d);                 // pop ebp
  put1(0x5b);                 // pop ebx
  put1(0xc3);                 // ret

  return o;
}

#endif // ifndef NOJIT

// Return a prediction of the next bit in range 0..32767
// Use JIT code starting at pcode[0] if available, or else create it.
int Predictor::predict() {
#ifdef NOJIT
  return predict0();
#else
  if (!pcode) {
    allocx(pcode, pcode_size, (z.cend*100+4096)&-4096);
    int n=assemble_p();
    if (n>pcode_size) {
      allocx(pcode, pcode_size, n);
      n=assemble_p();
    }
    if (!pcode || n<15 || pcode_size<15)
      error("run JIT failed");
  }
  assert(pcode && pcode[0]);
  return ((int(*)(Predictor*))&pcode[10])(this);
#endif
}

// Update the model with bit y = 0..1
// Use the JIT code starting at pcode[5].
void Predictor::update(int y) {
#ifdef NOJIT
  update0(y);
#else
  assert(pcode && pcode[5]);
  ((void(*)(Predictor*, int))&pcode[5])(this, y);

  // Save bit y in c8, hmap4 (not implemented in JIT)
  c8+=c8+y;
  if (c8>=256) {
    z.run(c8-256);
    hmap4=1;
    c8=1;
    for (int i=0; i<z.header[6]; ++i) h[i]=z.H(i);
  }
  else if (c8>=16 && c8<32)
    hmap4=(hmap4&0xf)<<5|y<<4|1;
  else
    hmap4=(hmap4&0x1f0)|(((hmap4&0xf)*2+y)&0xf);
#endif
}

// Execute the ZPAQL code with input byte or -1 for EOF.
// Use JIT code at rcode if available, or else create it.
void ZPAQL::run(U32 input) {
#ifdef NOJIT
  run0(input);
#else
  if (!rcode) {
    allocx(rcode, rcode_size, (hend*10+4096)&-4096);
    int n=assemble();
    if (n>rcode_size) {
      allocx(rcode, rcode_size, n);
      n=assemble();
    }
    if (!rcode || n<10 || rcode_size<10)
      error("run JIT failed");
  }
  a=input;
  const U32 rc=((int(*)())(&rcode[0]))();
  if (rc==0) return;
  else if (rc==1) libzpaq::error("Bad ZPAQL opcode");
  else if (rc==2) libzpaq::error("Out of memory");
  else if (rc==3) libzpaq::error("Write error");
  else libzpaq::error("ZPAQL execution error");
#endif
}

////////////////////////// divsufsort ///////////////////////////////

/*
 * divsufsort.c for libdivsufsort-lite
 * Copyright (c) 2003-2008 Yuta Mori All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following
 * conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

/*- Constants -*/
#define INLINE_divsuf __inline
#if defined(ALPHABET_SIZE) && (ALPHABET_SIZE < 1)
# undef ALPHABET_SIZE
#endif
#if !defined(ALPHABET_SIZE)
# define ALPHABET_SIZE (256)
#endif
#define BUCKET_A_SIZE (ALPHABET_SIZE)
#define BUCKET_B_SIZE (ALPHABET_SIZE * ALPHABET_SIZE)
#if defined(SS_INSERTIONSORT_THRESHOLD)
# if SS_INSERTIONSORT_THRESHOLD < 1
#  undef SS_INSERTIONSORT_THRESHOLD
#  define SS_INSERTIONSORT_THRESHOLD (1)
# endif
#else
# define SS_INSERTIONSORT_THRESHOLD (8)
#endif
#if defined(SS_BLOCKSIZE)
# if SS_BLOCKSIZE < 0
#  undef SS_BLOCKSIZE
#  define SS_BLOCKSIZE (0)
# elif 32768 <= SS_BLOCKSIZE
#  undef SS_BLOCKSIZE
#  define SS_BLOCKSIZE (32767)
# endif
#else
# define SS_BLOCKSIZE (1024)
#endif
/* minstacksize = log(SS_BLOCKSIZE) / log(3) * 2 */
#if SS_BLOCKSIZE == 0
# define SS_MISORT_STACKSIZE (96)
#elif SS_BLOCKSIZE <= 4096
# define SS_MISORT_STACKSIZE (16)
#else
# define SS_MISORT_STACKSIZE (24)
#endif
#define SS_SMERGE_STACKSIZE (32)
#define TR_INSERTIONSORT_THRESHOLD (8)
#define TR_STACKSIZE (64)


/*- Macros -*/
#ifndef SWAP
# define SWAP(_a, _b) do { t = (_a); (_a) = (_b); (_b) = t; } while(0)
#endif /* SWAP */
#ifndef MIN
# define MIN(_a, _b) (((_a) < (_b)) ? (_a) : (_b))
#endif /* MIN */
#ifndef MAX
# define MAX(_a, _b) (((_a) > (_b)) ? (_a) : (_b))
#endif /* MAX */
#define STACK_PUSH(_a, _b, _c, _d)\
  do {\
    assert(ssize < STACK_SIZE);\
    stack[ssize].a = (_a), stack[ssize].b = (_b),\
    stack[ssize].c = (_c), stack[ssize++].d = (_d);\
  } while(0)
#define STACK_PUSH5(_a, _b, _c, _d, _e)\
  do {\
    assert(ssize < STACK_SIZE);\
    stack[ssize].a = (_a), stack[ssize].b = (_b),\
    stack[ssize].c = (_c), stack[ssize].d = (_d), stack[ssize++].e = (_e);\
  } while(0)
#define STACK_POP(_a, _b, _c, _d)\
  do {\
    assert(0 <= ssize);\
    if(ssize == 0) { return; }\
    (_a) = stack[--ssize].a, (_b) = stack[ssize].b,\
    (_c) = stack[ssize].c, (_d) = stack[ssize].d;\
  } while(0)
#define STACK_POP5(_a, _b, _c, _d, _e)\
  do {\
    assert(0 <= ssize);\
    if(ssize == 0) { return; }\
    (_a) = stack[--ssize].a, (_b) = stack[ssize].b,\
    (_c) = stack[ssize].c, (_d) = stack[ssize].d, (_e) = stack[ssize].e;\
  } while(0)
#define BUCKET_A(_c0) bucket_A[(_c0)]
#if ALPHABET_SIZE == 256
#define BUCKET_B(_c0, _c1) (bucket_B[((_c1) << 8) | (_c0)])
#define BUCKET_BSTAR(_c0, _c1) (bucket_B[((_c0) << 8) | (_c1)])
#else
#define BUCKET_B(_c0, _c1) (bucket_B[(_c1) * ALPHABET_SIZE + (_c0)])
#define BUCKET_BSTAR(_c0, _c1) (bucket_B[(_c0) * ALPHABET_SIZE + (_c1)])
#endif


/*- Private Functions -*/

static const int lg_table[256]= {
 -1,0,1,1,2,2,2,2,3,3,3,3,3,3,3,3,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,
  5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
  6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,
  6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,
  7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
  7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
  7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
  7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7
};

#if (SS_BLOCKSIZE == 0) || (SS_INSERTIONSORT_THRESHOLD < SS_BLOCKSIZE)

static INLINE_divsuf
int
ss_ilg(int n) {
#if SS_BLOCKSIZE == 0
  return (n & 0xffff0000) ?
          ((n & 0xff000000) ?
            24 + lg_table[(n >> 24) & 0xff] :
            16 + lg_table[(n >> 16) & 0xff]) :
          ((n & 0x0000ff00) ?
             8 + lg_table[(n >>  8) & 0xff] :
             0 + lg_table[(n >>  0) & 0xff]);
#elif SS_BLOCKSIZE < 256
  return lg_table[n];
#else
  return (n & 0xff00) ?
          8 + lg_table[(n >> 8) & 0xff] :
          0 + lg_table[(n >> 0) & 0xff];
#endif
}

#endif /* (SS_BLOCKSIZE == 0) || (SS_INSERTIONSORT_THRESHOLD < SS_BLOCKSIZE) */

#if SS_BLOCKSIZE != 0

static const int sqq_table[256] = {
  0,  16,  22,  27,  32,  35,  39,  42,  45,  48,  50,  53,  55,  57,  59,  61,
 64,  65,  67,  69,  71,  73,  75,  76,  78,  80,  81,  83,  84,  86,  87,  89,
 90,  91,  93,  94,  96,  97,  98,  99, 101, 102, 103, 104, 106, 107, 108, 109,
110, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126,
128, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142,
143, 144, 144, 145, 146, 147, 148, 149, 150, 150, 151, 152, 153, 154, 155, 155,
156, 157, 158, 159, 160, 160, 161, 162, 163, 163, 164, 165, 166, 167, 167, 168,
169, 170, 170, 171, 172, 173, 173, 174, 175, 176, 176, 177, 178, 178, 179, 180,
181, 181, 182, 183, 183, 184, 185, 185, 186, 187, 187, 188, 189, 189, 190, 191,
192, 192, 193, 193, 194, 195, 195, 196, 197, 197, 198, 199, 199, 200, 201, 201,
202, 203, 203, 204, 204, 205, 206, 206, 207, 208, 208, 209, 209, 210, 211, 211,
212, 212, 213, 214, 214, 215, 215, 216, 217, 217, 218, 218, 219, 219, 220, 221,
221, 222, 222, 223, 224, 224, 225, 225, 226, 226, 227, 227, 228, 229, 229, 230,
230, 231, 231, 232, 232, 233, 234, 234, 235, 235, 236, 236, 237, 237, 238, 238,
239, 240, 240, 241, 241, 242, 242, 243, 243, 244, 244, 245, 245, 246, 246, 247,
247, 248, 248, 249, 249, 250, 250, 251, 251, 252, 252, 253, 253, 254, 254, 255
};

static INLINE_divsuf
int
ss_isqrt(int x) {
  int y, e;

  if(x >= (SS_BLOCKSIZE * SS_BLOCKSIZE)) { return SS_BLOCKSIZE; }
  e = (x & 0xffff0000) ?
        ((x & 0xff000000) ?
          24 + lg_table[(x >> 24) & 0xff] :
          16 + lg_table[(x >> 16) & 0xff]) :
        ((x & 0x0000ff00) ?
           8 + lg_table[(x >>  8) & 0xff] :
           0 + lg_table[(x >>  0) & 0xff]);

  if(e >= 16) {
    y = sqq_table[x >> ((e - 6) - (e & 1))] << ((e >> 1) - 7);
    if(e >= 24) { y = (y + 1 + x / y) >> 1; }
    y = (y + 1 + x / y) >> 1;
  } else if(e >= 8) {
    y = (sqq_table[x >> ((e - 6) - (e & 1))] >> (7 - (e >> 1))) + 1;
  } else {
    return sqq_table[x] >> 4;
  }

  return (x < (y * y)) ? y - 1 : y;
}

#endif /* SS_BLOCKSIZE != 0 */


/*---------------------------------------------------------------------------*/

/* Compares two suffixes. */
static INLINE_divsuf
int
ss_compare(const unsigned char *T,
           const int *p1, const int *p2,
           int depth) {
  const unsigned char *U1, *U2, *U1n, *U2n;

  for(U1 = T + depth + *p1,
      U2 = T + depth + *p2,
      U1n = T + *(p1 + 1) + 2,
      U2n = T + *(p2 + 1) + 2;
      (U1 < U1n) && (U2 < U2n) && (*U1 == *U2);
      ++U1, ++U2) {
  }

  return U1 < U1n ?
        (U2 < U2n ? *U1 - *U2 : 1) :
        (U2 < U2n ? -1 : 0);
}


/*---------------------------------------------------------------------------*/

#if (SS_BLOCKSIZE != 1) && (SS_INSERTIONSORT_THRESHOLD != 1)

/* Insertionsort for small size groups */
static
void
ss_insertionsort(const unsigned char *T, const int *PA,
                 int *first, int *last, int depth) {
  int *i, *j;
  int t;
  int r;

  for(i = last - 2; first <= i; --i) {
    for(t = *i, j = i + 1; 0 < (r = ss_compare(T, PA + t, PA + *j, depth));) {
      do { *(j - 1) = *j; } while((++j < last) && (*j < 0));
      if(last <= j) { break; }
    }
    if(r == 0) { *j = ~*j; }
    *(j - 1) = t;
  }
}

#endif /* (SS_BLOCKSIZE != 1) && (SS_INSERTIONSORT_THRESHOLD != 1) */


/*---------------------------------------------------------------------------*/

#if (SS_BLOCKSIZE == 0) || (SS_INSERTIONSORT_THRESHOLD < SS_BLOCKSIZE)

static INLINE_divsuf
void
ss_fixdown(const unsigned char *Td, const int *PA,
           int *SA, int i, int size) {
  int j, k;
  int v;
  int c, d, e;

  for(v = SA[i], c = Td[PA[v]]; (j = 2 * i + 1) < size; SA[i] = SA[k], i = k) {
    d = Td[PA[SA[k = j++]]];
    if(d < (e = Td[PA[SA[j]]])) { k = j; d = e; }
    if(d <= c) { break; }
  }
  SA[i] = v;
}

/* Simple top-down heapsort. */
static
void
ss_heapsort(const unsigned char *Td, const int *PA, int *SA, int size) {
  int i, m;
  int t;

  m = size;
  if((size % 2) == 0) {
    m--;
    if(Td[PA[SA[m / 2]]] < Td[PA[SA[m]]]) { SWAP(SA[m], SA[m / 2]); }
  }

  for(i = m / 2 - 1; 0 <= i; --i) { ss_fixdown(Td, PA, SA, i, m); }
  if((size % 2) == 0) { SWAP(SA[0], SA[m]); ss_fixdown(Td, PA, SA, 0, m); }
  for(i = m - 1; 0 < i; --i) {
    t = SA[0], SA[0] = SA[i];
    ss_fixdown(Td, PA, SA, 0, i);
    SA[i] = t;
  }
}


/*---------------------------------------------------------------------------*/

/* Returns the median of three elements. */
static INLINE_divsuf
int *
ss_median3(const unsigned char *Td, const int *PA,
           int *v1, int *v2, int *v3) {
  int *t;
  if(Td[PA[*v1]] > Td[PA[*v2]]) { SWAP(v1, v2); }
  if(Td[PA[*v2]] > Td[PA[*v3]]) {
    if(Td[PA[*v1]] > Td[PA[*v3]]) { return v1; }
    else { return v3; }
  }
  return v2;
}

/* Returns the median of five elements. */
static INLINE_divsuf
int *
ss_median5(const unsigned char *Td, const int *PA,
           int *v1, int *v2, int *v3, int *v4, int *v5) {
  int *t;
  if(Td[PA[*v2]] > Td[PA[*v3]]) { SWAP(v2, v3); }
  if(Td[PA[*v4]] > Td[PA[*v5]]) { SWAP(v4, v5); }
  if(Td[PA[*v2]] > Td[PA[*v4]]) { SWAP(v2, v4); SWAP(v3, v5); }
  if(Td[PA[*v1]] > Td[PA[*v3]]) { SWAP(v1, v3); }
  if(Td[PA[*v1]] > Td[PA[*v4]]) { SWAP(v1, v4); SWAP(v3, v5); }
  if(Td[PA[*v3]] > Td[PA[*v4]]) { return v4; }
  return v3;
}

/* Returns the pivot element. */
static INLINE_divsuf
int *
ss_pivot(const unsigned char *Td, const int *PA, int *first, int *last) {
  int *middle;
  int t;

  t = last - first;
  middle = first + t / 2;

  if(t <= 512) {
    if(t <= 32) {
      return ss_median3(Td, PA, first, middle, last - 1);
    } else {
      t >>= 2;
      return ss_median5(Td, PA, first, first + t, middle, last - 1 - t, last - 1);
    }
  }
  t >>= 3;
  first  = ss_median3(Td, PA, first, first + t, first + (t << 1));
  middle = ss_median3(Td, PA, middle - t, middle, middle + t);
  last   = ss_median3(Td, PA, last - 1 - (t << 1), last - 1 - t, last - 1);
  return ss_median3(Td, PA, first, middle, last);
}


/*---------------------------------------------------------------------------*/

/* Binary partition for substrings. */
static INLINE_divsuf
int *
ss_partition(const int *PA,
                    int *first, int *last, int depth) {
  int *a, *b;
  int t;
  for(a = first - 1, b = last;;) {
    for(; (++a < b) && ((PA[*a] + depth) >= (PA[*a + 1] + 1));) { *a = ~*a; }
    for(; (a < --b) && ((PA[*b] + depth) <  (PA[*b + 1] + 1));) { }
    if(b <= a) { break; }
    t = ~*b;
    *b = *a;
    *a = t;
  }
  if(first < a) { *first = ~*first; }
  return a;
}

/* Multikey introsort for medium size groups. */
static
void
ss_mintrosort(const unsigned char *T, const int *PA,
              int *first, int *last,
              int depth) {
#define STACK_SIZE SS_MISORT_STACKSIZE
  struct { int *a, *b, c; int d; } stack[STACK_SIZE];
  const unsigned char *Td;
  int *a, *b, *c, *d, *e, *f;
  int s, t;
  int ssize;
  int limit;
  int v, x = 0;

  for(ssize = 0, limit = ss_ilg(last - first);;) {

    if((last - first) <= SS_INSERTIONSORT_THRESHOLD) {
#if 1 < SS_INSERTIONSORT_THRESHOLD
      if(1 < (last - first)) { ss_insertionsort(T, PA, first, last, depth); }
#endif
      STACK_POP(first, last, depth, limit);
      continue;
    }

    Td = T + depth;
    if(limit-- == 0) { ss_heapsort(Td, PA, first, last - first); }
    if(limit < 0) {
      for(a = first + 1, v = Td[PA[*first]]; a < last; ++a) {
        if((x = Td[PA[*a]]) != v) {
          if(1 < (a - first)) { break; }
          v = x;
          first = a;
        }
      }
      if(Td[PA[*first] - 1] < v) {
        first = ss_partition(PA, first, a, depth);
      }
      if((a - first) <= (last - a)) {
        if(1 < (a - first)) {
          STACK_PUSH(a, last, depth, -1);
          last = a, depth += 1, limit = ss_ilg(a - first);
        } else {
          first = a, limit = -1;
        }
      } else {
        if(1 < (last - a)) {
          STACK_PUSH(first, a, depth + 1, ss_ilg(a - first));
          first = a, limit = -1;
        } else {
          last = a, depth += 1, limit = ss_ilg(a - first);
        }
      }
      continue;
    }

    /* choose pivot */
    a = ss_pivot(Td, PA, first, last);
    v = Td[PA[*a]];
    SWAP(*first, *a);

    /* partition */
    for(b = first; (++b < last) && ((x = Td[PA[*b]]) == v);) { }
    if(((a = b) < last) && (x < v)) {
      for(; (++b < last) && ((x = Td[PA[*b]]) <= v);) {
        if(x == v) { SWAP(*b, *a); ++a; }
      }
    }
    for(c = last; (b < --c) && ((x = Td[PA[*c]]) == v);) { }
    if((b < (d = c)) && (x > v)) {
      for(; (b < --c) && ((x = Td[PA[*c]]) >= v);) {
        if(x == v) { SWAP(*c, *d); --d; }
      }
    }
    for(; b < c;) {
      SWAP(*b, *c);
      for(; (++b < c) && ((x = Td[PA[*b]]) <= v);) {
        if(x == v) { SWAP(*b, *a); ++a; }
      }
      for(; (b < --c) && ((x = Td[PA[*c]]) >= v);) {
        if(x == v) { SWAP(*c, *d); --d; }
      }
    }

    if(a <= d) {
      c = b - 1;

      if((s = a - first) > (t = b - a)) { s = t; }
      for(e = first, f = b - s; 0 < s; --s, ++e, ++f) { SWAP(*e, *f); }
      if((s = d - c) > (t = last - d - 1)) { s = t; }
      for(e = b, f = last - s; 0 < s; --s, ++e, ++f) { SWAP(*e, *f); }

      a = first + (b - a), c = last - (d - c);
      b = (v <= Td[PA[*a] - 1]) ? a : ss_partition(PA, a, c, depth);

      if((a - first) <= (last - c)) {
        if((last - c) <= (c - b)) {
          STACK_PUSH(b, c, depth + 1, ss_ilg(c - b));
          STACK_PUSH(c, last, depth, limit);
          last = a;
        } else if((a - first) <= (c - b)) {
          STACK_PUSH(c, last, depth, limit);
          STACK_PUSH(b, c, depth + 1, ss_ilg(c - b));
          last = a;
        } else {
          STACK_PUSH(c, last, depth, limit);
          STACK_PUSH(first, a, depth, limit);
          first = b, last = c, depth += 1, limit = ss_ilg(c - b);
        }
      } else {
        if((a - first) <= (c - b)) {
          STACK_PUSH(b, c, depth + 1, ss_ilg(c - b));
          STACK_PUSH(first, a, depth, limit);
          first = c;
        } else if((last - c) <= (c - b)) {
          STACK_PUSH(first, a, depth, limit);
          STACK_PUSH(b, c, depth + 1, ss_ilg(c - b));
          first = c;
        } else {
          STACK_PUSH(first, a, depth, limit);
          STACK_PUSH(c, last, depth, limit);
          first = b, last = c, depth += 1, limit = ss_ilg(c - b);
        }
      }
    } else {
      limit += 1;
      if(Td[PA[*first] - 1] < v) {
        first = ss_partition(PA, first, last, depth);
        limit = ss_ilg(last - first);
      }
      depth += 1;
    }
  }
#undef STACK_SIZE
}

#endif /* (SS_BLOCKSIZE == 0) || (SS_INSERTIONSORT_THRESHOLD < SS_BLOCKSIZE) */


/*---------------------------------------------------------------------------*/

#if SS_BLOCKSIZE != 0

static INLINE_divsuf
void
ss_blockswap(int *a, int *b, int n) {
  int t;
  for(; 0 < n; --n, ++a, ++b) {
    t = *a, *a = *b, *b = t;
  }
}

static INLINE_divsuf
void
ss_rotate(int *first, int *middle, int *last) {
  int *a, *b, t;
  int l, r;
  l = middle - first, r = last - middle;
  for(; (0 < l) && (0 < r);) {
    if(l == r) { ss_blockswap(first, middle, l); break; }
    if(l < r) {
      a = last - 1, b = middle - 1;
      t = *a;
      do {
        *a-- = *b, *b-- = *a;
        if(b < first) {
          *a = t;
          last = a;
          if((r -= l + 1) <= l) { break; }
          a -= 1, b = middle - 1;
          t = *a;
        }
      } while(1);
    } else {
      a = first, b = middle;
      t = *a;
      do {
        *a++ = *b, *b++ = *a;
        if(last <= b) {
          *a = t;
          first = a + 1;
          if((l -= r + 1) <= r) { break; }
          a += 1, b = middle;
          t = *a;
        }
      } while(1);
    }
  }
}


/*---------------------------------------------------------------------------*/

static
void
ss_inplacemerge(const unsigned char *T, const int *PA,
                int *first, int *middle, int *last,
                int depth) {
  const int *p;
  int *a, *b;
  int len, half;
  int q, r;
  int x;

  for(;;) {
    if(*(last - 1) < 0) { x = 1; p = PA + ~*(last - 1); }
    else                { x = 0; p = PA +  *(last - 1); }
    for(a = first, len = middle - first, half = len >> 1, r = -1;
        0 < len;
        len = half, half >>= 1) {
      b = a + half;
      q = ss_compare(T, PA + ((0 <= *b) ? *b : ~*b), p, depth);
      if(q < 0) {
        a = b + 1;
        half -= (len & 1) ^ 1;
      } else {
        r = q;
      }
    }
    if(a < middle) {
      if(r == 0) { *a = ~*a; }
      ss_rotate(a, middle, last);
      last -= middle - a;
      middle = a;
      if(first == middle) { break; }
    }
    --last;
    if(x != 0) { while(*--last < 0) { } }
    if(middle == last) { break; }
  }
}


/*---------------------------------------------------------------------------*/

/* Merge-forward with internal buffer. */
static
void
ss_mergeforward(const unsigned char *T, const int *PA,
                int *first, int *middle, int *last,
                int *buf, int depth) {
  int *a, *b, *c, *bufend;
  int t;
  int r;

  bufend = buf + (middle - first) - 1;
  ss_blockswap(buf, first, middle - first);

  for(t = *(a = first), b = buf, c = middle;;) {
    r = ss_compare(T, PA + *b, PA + *c, depth);
    if(r < 0) {
      do {
        *a++ = *b;
        if(bufend <= b) { *bufend = t; return; }
        *b++ = *a;
      } while(*b < 0);
    } else if(r > 0) {
      do {
        *a++ = *c, *c++ = *a;
        if(last <= c) {
          while(b < bufend) { *a++ = *b, *b++ = *a; }
          *a = *b, *b = t;
          return;
        }
      } while(*c < 0);
    } else {
      *c = ~*c;
      do {
        *a++ = *b;
        if(bufend <= b) { *bufend = t; return; }
        *b++ = *a;
      } while(*b < 0);

      do {
        *a++ = *c, *c++ = *a;
        if(last <= c) {
          while(b < bufend) { *a++ = *b, *b++ = *a; }
          *a = *b, *b = t;
          return;
        }
      } while(*c < 0);
    }
  }
}

/* Merge-backward with internal buffer. */
static
void
ss_mergebackward(const unsigned char *T, const int *PA,
                 int *first, int *middle, int *last,
                 int *buf, int depth) {
  const int *p1, *p2;
  int *a, *b, *c, *bufend;
  int t;
  int r;
  int x;

  bufend = buf + (last - middle) - 1;
  ss_blockswap(buf, middle, last - middle);

  x = 0;
  if(*bufend < 0)       { p1 = PA + ~*bufend; x |= 1; }
  else                  { p1 = PA +  *bufend; }
  if(*(middle - 1) < 0) { p2 = PA + ~*(middle - 1); x |= 2; }
  else                  { p2 = PA +  *(middle - 1); }
  for(t = *(a = last - 1), b = bufend, c = middle - 1;;) {
    r = ss_compare(T, p1, p2, depth);
    if(0 < r) {
      if(x & 1) { do { *a-- = *b, *b-- = *a; } while(*b < 0); x ^= 1; }
      *a-- = *b;
      if(b <= buf) { *buf = t; break; }
      *b-- = *a;
      if(*b < 0) { p1 = PA + ~*b; x |= 1; }
      else       { p1 = PA +  *b; }
    } else if(r < 0) {
      if(x & 2) { do { *a-- = *c, *c-- = *a; } while(*c < 0); x ^= 2; }
      *a-- = *c, *c-- = *a;
      if(c < first) {
        while(buf < b) { *a-- = *b, *b-- = *a; }
        *a = *b, *b = t;
        break;
      }
      if(*c < 0) { p2 = PA + ~*c; x |= 2; }
      else       { p2 = PA +  *c; }
    } else {
      if(x & 1) { do { *a-- = *b, *b-- = *a; } while(*b < 0); x ^= 1; }
      *a-- = ~*b;
      if(b <= buf) { *buf = t; break; }
      *b-- = *a;
      if(x & 2) { do { *a-- = *c, *c-- = *a; } while(*c < 0); x ^= 2; }
      *a-- = *c, *c-- = *a;
      if(c < first) {
        while(buf < b) { *a-- = *b, *b-- = *a; }
        *a = *b, *b = t;
        break;
      }
      if(*b < 0) { p1 = PA + ~*b; x |= 1; }
      else       { p1 = PA +  *b; }
      if(*c < 0) { p2 = PA + ~*c; x |= 2; }
      else       { p2 = PA +  *c; }
    }
  }
}

/* D&C based merge. */
static
void
ss_swapmerge(const unsigned char *T, const int *PA,
             int *first, int *middle, int *last,
             int *buf, int bufsize, int depth) {
#define STACK_SIZE SS_SMERGE_STACKSIZE
#define GETIDX(a) ((0 <= (a)) ? (a) : (~(a)))
#define MERGE_CHECK(a, b, c)\
  do {\
    if(((c) & 1) ||\
       (((c) & 2) && (ss_compare(T, PA + GETIDX(*((a) - 1)), PA + *(a), depth) == 0))) {\
      *(a) = ~*(a);\
    }\
    if(((c) & 4) && ((ss_compare(T, PA + GETIDX(*((b) - 1)), PA + *(b), depth) == 0))) {\
      *(b) = ~*(b);\
    }\
  } while(0)
  struct { int *a, *b, *c; int d; } stack[STACK_SIZE];
  int *l, *r, *lm, *rm;
  int m, len, half;
  int ssize;
  int check, next;

  for(check = 0, ssize = 0;;) {
    if((last - middle) <= bufsize) {
      if((first < middle) && (middle < last)) {
        ss_mergebackward(T, PA, first, middle, last, buf, depth);
      }
      MERGE_CHECK(first, last, check);
      STACK_POP(first, middle, last, check);
      continue;
    }

    if((middle - first) <= bufsize) {
      if(first < middle) {
        ss_mergeforward(T, PA, first, middle, last, buf, depth);
      }
      MERGE_CHECK(first, last, check);
      STACK_POP(first, middle, last, check);
      continue;
    }

    for(m = 0, len = MIN(middle - first, last - middle), half = len >> 1;
        0 < len;
        len = half, half >>= 1) {
      if(ss_compare(T, PA + GETIDX(*(middle + m + half)),
                       PA + GETIDX(*(middle - m - half - 1)), depth) < 0) {
        m += half + 1;
        half -= (len & 1) ^ 1;
      }
    }

    if(0 < m) {
      lm = middle - m, rm = middle + m;
      ss_blockswap(lm, middle, m);
      l = r = middle, next = 0;
      if(rm < last) {
        if(*rm < 0) {
          *rm = ~*rm;
          if(first < lm) { for(; *--l < 0;) { } next |= 4; }
          next |= 1;
        } else if(first < lm) {
          for(; *r < 0; ++r) { }
          next |= 2;
        }
      }

      if((l - first) <= (last - r)) {
        STACK_PUSH(r, rm, last, (next & 3) | (check & 4));
        middle = lm, last = l, check = (check & 3) | (next & 4);
      } else {
        if((next & 2) && (r == middle)) { next ^= 6; }
        STACK_PUSH(first, lm, l, (check & 3) | (next & 4));
        first = r, middle = rm, check = (next & 3) | (check & 4);
      }
    } else {
      if(ss_compare(T, PA + GETIDX(*(middle - 1)), PA + *middle, depth) == 0) {
        *middle = ~*middle;
      }
      MERGE_CHECK(first, last, check);
      STACK_POP(first, middle, last, check);
    }
  }
#undef STACK_SIZE
}

#endif /* SS_BLOCKSIZE != 0 */


/*---------------------------------------------------------------------------*/

/* Substring sort */
static
void
sssort(const unsigned char *T, const int *PA,
       int *first, int *last,
       int *buf, int bufsize,
       int depth, int n, int lastsuffix) {
  int *a;
#if SS_BLOCKSIZE != 0
  int *b, *middle, *curbuf;
  int j, k, curbufsize, limit;
#endif
  int i;

  if(lastsuffix != 0) { ++first; }

#if SS_BLOCKSIZE == 0
  ss_mintrosort(T, PA, first, last, depth);
#else
  if((bufsize < SS_BLOCKSIZE) &&
      (bufsize < (last - first)) &&
      (bufsize < (limit = ss_isqrt(last - first)))) {
    if(SS_BLOCKSIZE < limit) { limit = SS_BLOCKSIZE; }
    buf = middle = last - limit, bufsize = limit;
  } else {
    middle = last, limit = 0;
  }
  for(a = first, i = 0; SS_BLOCKSIZE < (middle - a); a += SS_BLOCKSIZE, ++i) {
#if SS_INSERTIONSORT_THRESHOLD < SS_BLOCKSIZE
    ss_mintrosort(T, PA, a, a + SS_BLOCKSIZE, depth);
#elif 1 < SS_BLOCKSIZE
    ss_insertionsort(T, PA, a, a + SS_BLOCKSIZE, depth);
#endif
    curbufsize = last - (a + SS_BLOCKSIZE);
    curbuf = a + SS_BLOCKSIZE;
    if(curbufsize <= bufsize) { curbufsize = bufsize, curbuf = buf; }
    for(b = a, k = SS_BLOCKSIZE, j = i; j & 1; b -= k, k <<= 1, j >>= 1) {
      ss_swapmerge(T, PA, b - k, b, b + k, curbuf, curbufsize, depth);
    }
  }
#if SS_INSERTIONSORT_THRESHOLD < SS_BLOCKSIZE
  ss_mintrosort(T, PA, a, middle, depth);
#elif 1 < SS_BLOCKSIZE
  ss_insertionsort(T, PA, a, middle, depth);
#endif
  for(k = SS_BLOCKSIZE; i != 0; k <<= 1, i >>= 1) {
    if(i & 1) {
      ss_swapmerge(T, PA, a - k, a, middle, buf, bufsize, depth);
      a -= k;
    }
  }
  if(limit != 0) {
#if SS_INSERTIONSORT_THRESHOLD < SS_BLOCKSIZE
    ss_mintrosort(T, PA, middle, last, depth);
#elif 1 < SS_BLOCKSIZE
    ss_insertionsort(T, PA, middle, last, depth);
#endif
    ss_inplacemerge(T, PA, first, middle, last, depth);
  }
#endif

  if(lastsuffix != 0) {
    /* Insert last type B* suffix. */
    int PAi[2]; PAi[0] = PA[*(first - 1)], PAi[1] = n - 2;
    for(a = first, i = *(first - 1);
        (a < last) && ((*a < 0) || (0 < ss_compare(T, &(PAi[0]), PA + *a, depth)));
        ++a) {
      *(a - 1) = *a;
    }
    *(a - 1) = i;
  }
}


/*---------------------------------------------------------------------------*/

static INLINE_divsuf
int
tr_ilg(int n) {
  return (n & 0xffff0000) ?
          ((n & 0xff000000) ?
            24 + lg_table[(n >> 24) & 0xff] :
            16 + lg_table[(n >> 16) & 0xff]) :
          ((n & 0x0000ff00) ?
             8 + lg_table[(n >>  8) & 0xff] :
             0 + lg_table[(n >>  0) & 0xff]);
}


/*---------------------------------------------------------------------------*/

/* Simple insertionsort for small size groups. */
static
void
tr_insertionsort(const int *ISAd, int *first, int *last) {
  int *a, *b;
  int t, r;

  for(a = first + 1; a < last; ++a) {
    for(t = *a, b = a - 1; 0 > (r = ISAd[t] - ISAd[*b]);) {
      do { *(b + 1) = *b; } while((first <= --b) && (*b < 0));
      if(b < first) { break; }
    }
    if(r == 0) { *b = ~*b; }
    *(b + 1) = t;
  }
}


/*---------------------------------------------------------------------------*/

static INLINE_divsuf
void
tr_fixdown(const int *ISAd, int *SA, int i, int size) {
  int j, k;
  int v;
  int c, d, e;

  for(v = SA[i], c = ISAd[v]; (j = 2 * i + 1) < size; SA[i] = SA[k], i = k) {
    d = ISAd[SA[k = j++]];
    if(d < (e = ISAd[SA[j]])) { k = j; d = e; }
    if(d <= c) { break; }
  }
  SA[i] = v;
}

/* Simple top-down heapsort. */
static
void
tr_heapsort(const int *ISAd, int *SA, int size) {
  int i, m;
  int t;

  m = size;
  if((size % 2) == 0) {
    m--;
    if(ISAd[SA[m / 2]] < ISAd[SA[m]]) { SWAP(SA[m], SA[m / 2]); }
  }

  for(i = m / 2 - 1; 0 <= i; --i) { tr_fixdown(ISAd, SA, i, m); }
  if((size % 2) == 0) { SWAP(SA[0], SA[m]); tr_fixdown(ISAd, SA, 0, m); }
  for(i = m - 1; 0 < i; --i) {
    t = SA[0], SA[0] = SA[i];
    tr_fixdown(ISAd, SA, 0, i);
    SA[i] = t;
  }
}


/*---------------------------------------------------------------------------*/

/* Returns the median of three elements. */
static INLINE_divsuf
int *
tr_median3(const int *ISAd, int *v1, int *v2, int *v3) {
  int *t;
  if(ISAd[*v1] > ISAd[*v2]) { SWAP(v1, v2); }
  if(ISAd[*v2] > ISAd[*v3]) {
    if(ISAd[*v1] > ISAd[*v3]) { return v1; }
    else { return v3; }
  }
  return v2;
}

/* Returns the median of five elements. */
static INLINE_divsuf
int *
tr_median5(const int *ISAd,
           int *v1, int *v2, int *v3, int *v4, int *v5) {
  int *t;
  if(ISAd[*v2] > ISAd[*v3]) { SWAP(v2, v3); }
  if(ISAd[*v4] > ISAd[*v5]) { SWAP(v4, v5); }
  if(ISAd[*v2] > ISAd[*v4]) { SWAP(v2, v4); SWAP(v3, v5); }
  if(ISAd[*v1] > ISAd[*v3]) { SWAP(v1, v3); }
  if(ISAd[*v1] > ISAd[*v4]) { SWAP(v1, v4); SWAP(v3, v5); }
  if(ISAd[*v3] > ISAd[*v4]) { return v4; }
  return v3;
}

/* Returns the pivot element. */
static INLINE_divsuf
int *
tr_pivot(const int *ISAd, int *first, int *last) {
  int *middle;
  int t;

  t = last - first;
  middle = first + t / 2;

  if(t <= 512) {
    if(t <= 32) {
      return tr_median3(ISAd, first, middle, last - 1);
    } else {
      t >>= 2;
      return tr_median5(ISAd, first, first + t, middle, last - 1 - t, last - 1);
    }
  }
  t >>= 3;
  first  = tr_median3(ISAd, first, first + t, first + (t << 1));
  middle = tr_median3(ISAd, middle - t, middle, middle + t);
  last   = tr_median3(ISAd, last - 1 - (t << 1), last - 1 - t, last - 1);
  return tr_median3(ISAd, first, middle, last);
}


/*---------------------------------------------------------------------------*/

typedef struct _trbudget_t trbudget_t;
struct _trbudget_t {
  int chance;
  int remain;
  int incval;
  int count;
};

static INLINE_divsuf
void
trbudget_init(trbudget_t *budget, int chance, int incval) {
  budget->chance = chance;
  budget->remain = budget->incval = incval;
}

static INLINE_divsuf
int
trbudget_check(trbudget_t *budget, int size) {
  if(size <= budget->remain) { budget->remain -= size; return 1; }
  if(budget->chance == 0) { budget->count += size; return 0; }
  budget->remain += budget->incval - size;
  budget->chance -= 1;
  return 1;
}


/*---------------------------------------------------------------------------*/

static INLINE_divsuf
void
tr_partition(const int *ISAd,
             int *first, int *middle, int *last,
             int **pa, int **pb, int v) {
  int *a, *b, *c, *d, *e, *f;
  int t, s;
  int x = 0;

  for(b = middle - 1; (++b < last) && ((x = ISAd[*b]) == v);) { }
  if(((a = b) < last) && (x < v)) {
    for(; (++b < last) && ((x = ISAd[*b]) <= v);) {
      if(x == v) { SWAP(*b, *a); ++a; }
    }
  }
  for(c = last; (b < --c) && ((x = ISAd[*c]) == v);) { }
  if((b < (d = c)) && (x > v)) {
    for(; (b < --c) && ((x = ISAd[*c]) >= v);) {
      if(x == v) { SWAP(*c, *d); --d; }
    }
  }
  for(; b < c;) {
    SWAP(*b, *c);
    for(; (++b < c) && ((x = ISAd[*b]) <= v);) {
      if(x == v) { SWAP(*b, *a); ++a; }
    }
    for(; (b < --c) && ((x = ISAd[*c]) >= v);) {
      if(x == v) { SWAP(*c, *d); --d; }
    }
  }

  if(a <= d) {
    c = b - 1;
    if((s = a - first) > (t = b - a)) { s = t; }
    for(e = first, f = b - s; 0 < s; --s, ++e, ++f) { SWAP(*e, *f); }
    if((s = d - c) > (t = last - d - 1)) { s = t; }
    for(e = b, f = last - s; 0 < s; --s, ++e, ++f) { SWAP(*e, *f); }
    first += (b - a), last -= (d - c);
  }
  *pa = first, *pb = last;
}

static
void
tr_copy(int *ISA, const int *SA,
        int *first, int *a, int *b, int *last,
        int depth) {
  /* sort suffixes of middle partition
     by using sorted order of suffixes of left and right partition. */
  int *c, *d, *e;
  int s, v;

  v = b - SA - 1;
  for(c = first, d = a - 1; c <= d; ++c) {
    if((0 <= (s = *c - depth)) && (ISA[s] == v)) {
      *++d = s;
      ISA[s] = d - SA;
    }
  }
  for(c = last - 1, e = d + 1, d = b; e < d; --c) {
    if((0 <= (s = *c - depth)) && (ISA[s] == v)) {
      *--d = s;
      ISA[s] = d - SA;
    }
  }
}

static
void
tr_partialcopy(int *ISA, const int *SA,
               int *first, int *a, int *b, int *last,
               int depth) {
  int *c, *d, *e;
  int s, v;
  int rank, lastrank, newrank = -1;

  v = b - SA - 1;
  lastrank = -1;
  for(c = first, d = a - 1; c <= d; ++c) {
    if((0 <= (s = *c - depth)) && (ISA[s] == v)) {
      *++d = s;
      rank = ISA[s + depth];
      if(lastrank != rank) { lastrank = rank; newrank = d - SA; }
      ISA[s] = newrank;
    }
  }

  lastrank = -1;
  for(e = d; first <= e; --e) {
    rank = ISA[*e];
    if(lastrank != rank) { lastrank = rank; newrank = e - SA; }
    if(newrank != rank) { ISA[*e] = newrank; }
  }

  lastrank = -1;
  for(c = last - 1, e = d + 1, d = b; e < d; --c) {
    if((0 <= (s = *c - depth)) && (ISA[s] == v)) {
      *--d = s;
      rank = ISA[s + depth];
      if(lastrank != rank) { lastrank = rank; newrank = d - SA; }
      ISA[s] = newrank;
    }
  }
}

static
void
tr_introsort(int *ISA, const int *ISAd,
             int *SA, int *first, int *last,
             trbudget_t *budget) {
#define STACK_SIZE TR_STACKSIZE
  struct { const int *a; int *b, *c; int d, e; }stack[STACK_SIZE];
  int *a, *b, *c;
  int t;
  int v, x = 0;
  int incr = ISAd - ISA;
  int limit, next;
  int ssize, trlink = -1;

  for(ssize = 0, limit = tr_ilg(last - first);;) {

    if(limit < 0) {
      if(limit == -1) {
        /* tandem repeat partition */
        tr_partition(ISAd - incr, first, first, last, &a, &b, last - SA - 1);

        /* update ranks */
        if(a < last) {
          for(c = first, v = a - SA - 1; c < a; ++c) { ISA[*c] = v; }
        }
        if(b < last) {
          for(c = a, v = b - SA - 1; c < b; ++c) { ISA[*c] = v; }
        }

        /* push */
        if(1 < (b - a)) {
          STACK_PUSH5(NULL, a, b, 0, 0);
          STACK_PUSH5(ISAd - incr, first, last, -2, trlink);
          trlink = ssize - 2;
        }
        if((a - first) <= (last - b)) {
          if(1 < (a - first)) {
            STACK_PUSH5(ISAd, b, last, tr_ilg(last - b), trlink);
            last = a, limit = tr_ilg(a - first);
          } else if(1 < (last - b)) {
            first = b, limit = tr_ilg(last - b);
          } else {
            STACK_POP5(ISAd, first, last, limit, trlink);
          }
        } else {
          if(1 < (last - b)) {
            STACK_PUSH5(ISAd, first, a, tr_ilg(a - first), trlink);
            first = b, limit = tr_ilg(last - b);
          } else if(1 < (a - first)) {
            last = a, limit = tr_ilg(a - first);
          } else {
            STACK_POP5(ISAd, first, last, limit, trlink);
          }
        }
      } else if(limit == -2) {
        /* tandem repeat copy */
        a = stack[--ssize].b, b = stack[ssize].c;
        if(stack[ssize].d == 0) {
          tr_copy(ISA, SA, first, a, b, last, ISAd - ISA);
        } else {
          if(0 <= trlink) { stack[trlink].d = -1; }
          tr_partialcopy(ISA, SA, first, a, b, last, ISAd - ISA);
        }
        STACK_POP5(ISAd, first, last, limit, trlink);
      } else {
        /* sorted partition */
        if(0 <= *first) {
          a = first;
          do { ISA[*a] = a - SA; } while((++a < last) && (0 <= *a));
          first = a;
        }
        if(first < last) {
          a = first; do { *a = ~*a; } while(*++a < 0);
          next = (ISA[*a] != ISAd[*a]) ? tr_ilg(a - first + 1) : -1;
          if(++a < last) { for(b = first, v = a - SA - 1; b < a; ++b) { ISA[*b] = v; } }

          /* push */
          if(trbudget_check(budget, a - first)) {
            if((a - first) <= (last - a)) {
              STACK_PUSH5(ISAd, a, last, -3, trlink);
              ISAd += incr, last = a, limit = next;
            } else {
              if(1 < (last - a)) {
                STACK_PUSH5(ISAd + incr, first, a, next, trlink);
                first = a, limit = -3;
              } else {
                ISAd += incr, last = a, limit = next;
              }
            }
          } else {
            if(0 <= trlink) { stack[trlink].d = -1; }
            if(1 < (last - a)) {
              first = a, limit = -3;
            } else {
              STACK_POP5(ISAd, first, last, limit, trlink);
            }
          }
        } else {
          STACK_POP5(ISAd, first, last, limit, trlink);
        }
      }
      continue;
    }

    if((last - first) <= TR_INSERTIONSORT_THRESHOLD) {
      tr_insertionsort(ISAd, first, last);
      limit = -3;
      continue;
    }

    if(limit-- == 0) {
      tr_heapsort(ISAd, first, last - first);
      for(a = last - 1; first < a; a = b) {
        for(x = ISAd[*a], b = a - 1; (first <= b) && (ISAd[*b] == x); --b) { *b = ~*b; }
      }
      limit = -3;
      continue;
    }

    /* choose pivot */
    a = tr_pivot(ISAd, first, last);
    SWAP(*first, *a);
    v = ISAd[*first];

    /* partition */
    tr_partition(ISAd, first, first + 1, last, &a, &b, v);
    if((last - first) != (b - a)) {
      next = (ISA[*a] != v) ? tr_ilg(b - a) : -1;

      /* update ranks */
      for(c = first, v = a - SA - 1; c < a; ++c) { ISA[*c] = v; }
      if(b < last) { for(c = a, v = b - SA - 1; c < b; ++c) { ISA[*c] = v; } }

      /* push */
      if((1 < (b - a)) && (trbudget_check(budget, b - a))) {
        if((a - first) <= (last - b)) {
          if((last - b) <= (b - a)) {
            if(1 < (a - first)) {
              STACK_PUSH5(ISAd + incr, a, b, next, trlink);
              STACK_PUSH5(ISAd, b, last, limit, trlink);
              last = a;
            } else if(1 < (last - b)) {
              STACK_PUSH5(ISAd + incr, a, b, next, trlink);
              first = b;
            } else {
              ISAd += incr, first = a, last = b, limit = next;
            }
          } else if((a - first) <= (b - a)) {
            if(1 < (a - first)) {
              STACK_PUSH5(ISAd, b, last, limit, trlink);
              STACK_PUSH5(ISAd + incr, a, b, next, trlink);
              last = a;
            } else {
              STACK_PUSH5(ISAd, b, last, limit, trlink);
              ISAd += incr, first = a, last = b, limit = next;
            }
          } else {
            STACK_PUSH5(ISAd, b, last, limit, trlink);
            STACK_PUSH5(ISAd, first, a, limit, trlink);
            ISAd += incr, first = a, last = b, limit = next;
          }
        } else {
          if((a - first) <= (b - a)) {
            if(1 < (last - b)) {
              STACK_PUSH5(ISAd + incr, a, b, next, trlink);
              STACK_PUSH5(ISAd, first, a, limit, trlink);
              first = b;
            } else if(1 < (a - first)) {
              STACK_PUSH5(ISAd + incr, a, b, next, trlink);
              last = a;
            } else {
              ISAd += incr, first = a, last = b, limit = next;
            }
          } else if((last - b) <= (b - a)) {
            if(1 < (last - b)) {
              STACK_PUSH5(ISAd, first, a, limit, trlink);
              STACK_PUSH5(ISAd + incr, a, b, next, trlink);
              first = b;
            } else {
              STACK_PUSH5(ISAd, first, a, limit, trlink);
              ISAd += incr, first = a, last = b, limit = next;
            }
          } else {
            STACK_PUSH5(ISAd, first, a, limit, trlink);
            STACK_PUSH5(ISAd, b, last, limit, trlink);
            ISAd += incr, first = a, last = b, limit = next;
          }
        }
      } else {
        if((1 < (b - a)) && (0 <= trlink)) { stack[trlink].d = -1; }
        if((a - first) <= (last - b)) {
          if(1 < (a - first)) {
            STACK_PUSH5(ISAd, b, last, limit, trlink);
            last = a;
          } else if(1 < (last - b)) {
            first = b;
          } else {
            STACK_POP5(ISAd, first, last, limit, trlink);
          }
        } else {
          if(1 < (last - b)) {
            STACK_PUSH5(ISAd, first, a, limit, trlink);
            first = b;
          } else if(1 < (a - first)) {
            last = a;
          } else {
            STACK_POP5(ISAd, first, last, limit, trlink);
          }
        }
      }
    } else {
      if(trbudget_check(budget, last - first)) {
        limit = tr_ilg(last - first), ISAd += incr;
      } else {
        if(0 <= trlink) { stack[trlink].d = -1; }
        STACK_POP5(ISAd, first, last, limit, trlink);
      }
    }
  }
#undef STACK_SIZE
}



/*---------------------------------------------------------------------------*/

/* Tandem repeat sort */
static
void
trsort(int *ISA, int *SA, int n, int depth) {
  int *ISAd;
  int *first, *last;
  trbudget_t budget;
  int t, skip, unsorted;

  trbudget_init(&budget, tr_ilg(n) * 2 / 3, n);
/*  trbudget_init(&budget, tr_ilg(n) * 3 / 4, n); */
  for(ISAd = ISA + depth; -n < *SA; ISAd += ISAd - ISA) {
    first = SA;
    skip = 0;
    unsorted = 0;
    do {
      if((t = *first) < 0) { first -= t; skip += t; }
      else {
        if(skip != 0) { *(first + skip) = skip; skip = 0; }
        last = SA + ISA[t] + 1;
        if(1 < (last - first)) {
          budget.count = 0;
          tr_introsort(ISA, ISAd, SA, first, last, &budget);
          if(budget.count != 0) { unsorted += budget.count; }
          else { skip = first - last; }
        } else if((last - first) == 1) {
          skip = -1;
        }
        first = last;
      }
    } while(first < (SA + n));
    if(skip != 0) { *(first + skip) = skip; }
    if(unsorted == 0) { break; }
  }
}


/*---------------------------------------------------------------------------*/

/* Sorts suffixes of type B*. */
static
int
sort_typeBstar(const unsigned char *T, int *SA,
               int *bucket_A, int *bucket_B,
               int n) {
  int *PAb, *ISAb, *buf;
  int i, j, k, t, m, bufsize;
  int c0, c1;

  /* Initialize bucket arrays. */
  for(i = 0; i < BUCKET_A_SIZE; ++i) { bucket_A[i] = 0; }
  for(i = 0; i < BUCKET_B_SIZE; ++i) { bucket_B[i] = 0; }

  /* Count the number of occurrences of the first one or two characters of each
     type A, B and B* suffix. Moreover, store the beginning position of all
     type B* suffixes into the array SA. */
  for(i = n - 1, m = n, c0 = T[n - 1]; 0 <= i;) {
    /* type A suffix. */
    do { ++BUCKET_A(c1 = c0); } while((0 <= --i) && ((c0 = T[i]) >= c1));
    if(0 <= i) {
      /* type B* suffix. */
      ++BUCKET_BSTAR(c0, c1);
      SA[--m] = i;
      /* type B suffix. */
      for(--i, c1 = c0; (0 <= i) && ((c0 = T[i]) <= c1); --i, c1 = c0) {
        ++BUCKET_B(c0, c1);
      }
    }
  }
  m = n - m;
/*
note:
  A type B* suffix is lexicographically smaller than a type B suffix that
  begins with the same first two characters.
*/

  /* Calculate the index of start/end point of each bucket. */
  for(c0 = 0, i = 0, j = 0; c0 < ALPHABET_SIZE; ++c0) {
    t = i + BUCKET_A(c0);
    BUCKET_A(c0) = i + j; /* start point */
    i = t + BUCKET_B(c0, c0);
    for(c1 = c0 + 1; c1 < ALPHABET_SIZE; ++c1) {
      j += BUCKET_BSTAR(c0, c1);
      BUCKET_BSTAR(c0, c1) = j; /* end point */
      i += BUCKET_B(c0, c1);
    }
  }

  if(0 < m) {
    /* Sort the type B* suffixes by their first two characters. */
    PAb = SA + n - m; ISAb = SA + m;
    for(i = m - 2; 0 <= i; --i) {
      t = PAb[i], c0 = T[t], c1 = T[t + 1];
      SA[--BUCKET_BSTAR(c0, c1)] = i;
    }
    t = PAb[m - 1], c0 = T[t], c1 = T[t + 1];
    SA[--BUCKET_BSTAR(c0, c1)] = m - 1;

    /* Sort the type B* substrings using sssort. */
    buf = SA + m, bufsize = n - (2 * m);
    for(c0 = ALPHABET_SIZE - 2, j = m; 0 < j; --c0) {
      for(c1 = ALPHABET_SIZE - 1; c0 < c1; j = i, --c1) {
        i = BUCKET_BSTAR(c0, c1);
        if(1 < (j - i)) {
          sssort(T, PAb, SA + i, SA + j,
                 buf, bufsize, 2, n, *(SA + i) == (m - 1));
        }
      }
    }

    /* Compute ranks of type B* substrings. */
    for(i = m - 1; 0 <= i; --i) {
      if(0 <= SA[i]) {
        j = i;
        do { ISAb[SA[i]] = i; } while((0 <= --i) && (0 <= SA[i]));
        SA[i + 1] = i - j;
        if(i <= 0) { break; }
      }
      j = i;
      do { ISAb[SA[i] = ~SA[i]] = j; } while(SA[--i] < 0);
      ISAb[SA[i]] = j;
    }

    /* Construct the inverse suffix array of type B* suffixes using trsort. */
    trsort(ISAb, SA, m, 1);

    /* Set the sorted order of tyoe B* suffixes. */
    for(i = n - 1, j = m, c0 = T[n - 1]; 0 <= i;) {
      for(--i, c1 = c0; (0 <= i) && ((c0 = T[i]) >= c1); --i, c1 = c0) { }
      if(0 <= i) {
        t = i;
        for(--i, c1 = c0; (0 <= i) && ((c0 = T[i]) <= c1); --i, c1 = c0) { }
        SA[ISAb[--j]] = ((t == 0) || (1 < (t - i))) ? t : ~t;
      }
    }

    /* Calculate the index of start/end point of each bucket. */
    BUCKET_B(ALPHABET_SIZE - 1, ALPHABET_SIZE - 1) = n; /* end point */
    for(c0 = ALPHABET_SIZE - 2, k = m - 1; 0 <= c0; --c0) {
      i = BUCKET_A(c0 + 1) - 1;
      for(c1 = ALPHABET_SIZE - 1; c0 < c1; --c1) {
        t = i - BUCKET_B(c0, c1);
        BUCKET_B(c0, c1) = i; /* end point */

        /* Move all type B* suffixes to the correct position. */
        for(i = t, j = BUCKET_BSTAR(c0, c1);
            j <= k;
            --i, --k) { SA[i] = SA[k]; }
      }
      BUCKET_BSTAR(c0, c0 + 1) = i - BUCKET_B(c0, c0) + 1; /* start point */
      BUCKET_B(c0, c0) = i; /* end point */
    }
  }

  return m;
}

/* Constructs the suffix array by using the sorted order of type B* suffixes. */
static
void
construct_SA(const unsigned char *T, int *SA,
             int *bucket_A, int *bucket_B,
             int n, int m) {
  int *i, *j, *k;
  int s;
  int c0, c1, c2;

  if(0 < m) {
    /* Construct the sorted order of type B suffixes by using
       the sorted order of type B* suffixes. */
    for(c1 = ALPHABET_SIZE - 2; 0 <= c1; --c1) {
      /* Scan the suffix array from right to left. */
      for(i = SA + BUCKET_BSTAR(c1, c1 + 1),
          j = SA + BUCKET_A(c1 + 1) - 1, k = NULL, c2 = -1;
          i <= j;
          --j) {
        if(0 < (s = *j)) {
          assert(T[s] == c1);
          assert(((s + 1) < n) && (T[s] <= T[s + 1]));
          assert(T[s - 1] <= T[s]);
          *j = ~s;
          c0 = T[--s];
          if((0 < s) && (T[s - 1] > c0)) { s = ~s; }
          if(c0 != c2) {
            if(0 <= c2) { BUCKET_B(c2, c1) = k - SA; }
            k = SA + BUCKET_B(c2 = c0, c1);
          }
          assert(k < j);
          *k-- = s;
        } else {
          assert(((s == 0) && (T[s] == c1)) || (s < 0));
          *j = ~s;
        }
      }
    }
  }

  /* Construct the suffix array by using
     the sorted order of type B suffixes. */
  k = SA + BUCKET_A(c2 = T[n - 1]);
  *k++ = (T[n - 2] < c2) ? ~(n - 1) : (n - 1);
  /* Scan the suffix array from left to right. */
  for(i = SA, j = SA + n; i < j; ++i) {
    if(0 < (s = *i)) {
      assert(T[s - 1] >= T[s]);
      c0 = T[--s];
      if((s == 0) || (T[s - 1] < c0)) { s = ~s; }
      if(c0 != c2) {
        BUCKET_A(c2) = k - SA;
        k = SA + BUCKET_A(c2 = c0);
      }
      assert(i < k);
      *k++ = s;
    } else {
      assert(s < 0);
      *i = ~s;
    }
  }
}

/* Constructs the burrows-wheeler transformed string directly
   by using the sorted order of type B* suffixes. */
static
int
construct_BWT(const unsigned char *T, int *SA,
              int *bucket_A, int *bucket_B,
              int n, int m) {
  int *i, *j, *k, *orig;
  int s;
  int c0, c1, c2;

  if(0 < m) {
    /* Construct the sorted order of type B suffixes by using
       the sorted order of type B* suffixes. */
    for(c1 = ALPHABET_SIZE - 2; 0 <= c1; --c1) {
      /* Scan the suffix array from right to left. */
      for(i = SA + BUCKET_BSTAR(c1, c1 + 1),
          j = SA + BUCKET_A(c1 + 1) - 1, k = NULL, c2 = -1;
          i <= j;
          --j) {
        if(0 < (s = *j)) {
          assert(T[s] == c1);
          assert(((s + 1) < n) && (T[s] <= T[s + 1]));
          assert(T[s - 1] <= T[s]);
          c0 = T[--s];
          *j = ~((int)c0);
          if((0 < s) && (T[s - 1] > c0)) { s = ~s; }
          if(c0 != c2) {
            if(0 <= c2) { BUCKET_B(c2, c1) = k - SA; }
            k = SA + BUCKET_B(c2 = c0, c1);
          }
          assert(k < j);
          *k-- = s;
        } else if(s != 0) {
          *j = ~s;
#ifndef NDEBUG
        } else {
          assert(T[s] == c1);
#endif
        }
      }
    }
  }

  /* Construct the BWTed string by using
     the sorted order of type B suffixes. */
  k = SA + BUCKET_A(c2 = T[n - 1]);
  *k++ = (T[n - 2] < c2) ? ~((int)T[n - 2]) : (n - 1);
  /* Scan the suffix array from left to right. */
  for(i = SA, j = SA + n, orig = SA; i < j; ++i) {
    if(0 < (s = *i)) {
      assert(T[s - 1] >= T[s]);
      c0 = T[--s];
      *i = c0;
      if((0 < s) && (T[s - 1] < c0)) { s = ~((int)T[s - 1]); }
      if(c0 != c2) {
        BUCKET_A(c2) = k - SA;
        k = SA + BUCKET_A(c2 = c0);
      }
      assert(i < k);
      *k++ = s;
    } else if(s != 0) {
      *i = ~s;
    } else {
      orig = i;
    }
  }

  return orig - SA;
}


/*---------------------------------------------------------------------------*/

/*- Function -*/

int
divsufsort(const unsigned char *T, int *SA, int n) {
  int *bucket_A, *bucket_B;
  int m;
  int err = 0;

  /* Check arguments. */
  if((T == NULL) || (SA == NULL) || (n < 0)) { return -1; }
  else if(n == 0) { return 0; }
  else if(n == 1) { SA[0] = 0; return 0; }
  else if(n == 2) { m = (T[0] < T[1]); SA[m ^ 1] = 0, SA[m] = 1; return 0; }

  bucket_A = (int *)malloc(BUCKET_A_SIZE * sizeof(int));
  bucket_B = (int *)malloc(BUCKET_B_SIZE * sizeof(int));

  /* Suffixsort. */
  if((bucket_A != NULL) && (bucket_B != NULL)) {
    m = sort_typeBstar(T, SA, bucket_A, bucket_B, n);
    construct_SA(T, SA, bucket_A, bucket_B, n, m);
  } else {
    err = -2;
  }

  free(bucket_B);
  free(bucket_A);

  return err;
}

int
divbwt(const unsigned char *T, unsigned char *U, int *A, int n) {
  int *B;
  int *bucket_A, *bucket_B;
  int m, pidx, i;

  /* Check arguments. */
  if((T == NULL) || (U == NULL) || (n < 0)) { return -1; }
  else if(n <= 1) { if(n == 1) { U[0] = T[0]; } return n; }

  if((B = A) == NULL) { B = (int *)malloc((size_t)(n + 1) * sizeof(int)); }
  bucket_A = (int *)malloc(BUCKET_A_SIZE * sizeof(int));
  bucket_B = (int *)malloc(BUCKET_B_SIZE * sizeof(int));

  /* Burrows-Wheeler Transform. */
  if((B != NULL) && (bucket_A != NULL) && (bucket_B != NULL)) {
    m = sort_typeBstar(T, B, bucket_A, bucket_B, n);
    pidx = construct_BWT(T, B, bucket_A, bucket_B, n, m);

    /* Copy to output string. */
    U[0] = T[n - 1];
    for(i = 0; i < pidx; ++i) { U[i + 1] = (unsigned char)B[i]; }
    for(i += 1; i < n; ++i) { U[i] = (unsigned char)B[i]; }
    pidx += 1;
  } else {
    pidx = -2;
  }

  free(bucket_B);
  free(bucket_A);
  if(A == NULL) { free(B); }

  return pidx;
}

// End divsufsort.c

/////////////////////////////// add ///////////////////////////////////

// Convert non-negative decimal number x to string of at least n digits
std::string itos(int64_t x, int n=1) {
  assert(x>=0);
  assert(n>=0);
  std::string r;
  for (; x || n>0; x/=10, --n) r=std::string(1, '0'+x%10)+r;
  return r;
}

// E8E9 transform of buf[0..n-1] to improve compression of .exe and .dll.
// Patterns (E8|E9 xx xx xx 00|FF) at offset i replace the 3 middle
// bytes with x+i mod 2^24, LSB first, reading backward.
void e8e9(unsigned char* buf, int n) {
  for (int i=n-5; i>=0; --i) {
    if (((buf[i]&254)==0xe8) && ((buf[i+4]+1)&254)==0) {
      unsigned a=(buf[i+1]|buf[i+2]<<8|buf[i+3]<<16)+i;
      buf[i+1]=a;
      buf[i+2]=a>>8;
      buf[i+3]=a>>16;
    }
  }
}

// Encode inbuf to buf using LZ77. args are as follows:
// args[0] is log2 buffer size in MB.
// args[1] is level (1=var. length, 2=byte aligned lz77, 3=bwt) + 4 if E8E9.
// args[2] is the lz77 minimum match length and context order.
// args[3] is the lz77 higher context order to search first, or else 0.
// args[4] is the log2 hash bucket size (number of searches).
// args[5] is the log2 hash table size. If 21+args[0] then use a suffix array.
// args[6] is the secondary context look ahead
// sap is pointer to external suffix array of inbuf or 0. If supplied and
//   args[0]=5..7 then it is assumed that E8E9 was already applied to
//   both the input and sap and the input buffer is not modified.

class LZBuffer: public libzpaq::Reader {
  libzpaq::Array<unsigned> ht;// hash table, confirm in low bits, or SA+ISA
  const unsigned char* in;    // input pointer
  const int checkbits;        // hash confirmation size or lg(ISA size)
  const int level;            // 1=var length LZ77, 2=byte aligned LZ77, 3=BWT
  const unsigned htsize;      // size of hash table
  const unsigned n;           // input length
  unsigned i;                 // current location in in (0 <= i < n)
  const unsigned minMatch;    // minimum match length
  const unsigned minMatch2;   // second context order or 0 if not used
  const unsigned maxMatch;    // longest match length allowed
  const unsigned maxLiteral;  // longest literal length allowed
  const unsigned lookahead;   // second context look ahead
  unsigned h1, h2;            // low, high order context hashes of in[i..]
  const unsigned bucket;      // number of matches to search per hash - 1
  const unsigned shift1, shift2;  // how far to shift h1, h2 per hash
  const int minMatchBoth;     // max(minMatch, minMatch2)
  const unsigned rb;          // number of level 1 r bits in match code
  unsigned bits;              // pending output bits (level 1)
  unsigned nbits;             // number of bits in bits
  unsigned rpos, wpos;        // read, write pointers
  unsigned idx;               // BWT index
  const unsigned* sa;         // suffix array for BWT or LZ77-SA
  unsigned* isa;              // inverse suffix array for LZ77-SA
  enum {BUFSIZE=1<<14};       // output buffer size
  unsigned char buf[BUFSIZE]; // output buffer

  void write_literal(unsigned i, unsigned& lit);
  void write_match(unsigned len, unsigned off);
  void fill();  // encode to buf

  // write k bits of x
  void putb(unsigned x, int k) {
    x&=(1<<k)-1;
    bits|=x<<nbits;
    nbits+=k;
    while (nbits>7) {
      assert(wpos<BUFSIZE);
      buf[wpos++]=bits, bits>>=8, nbits-=8;
    }
  }

  // write last byte
  void flush() {
    assert(wpos<BUFSIZE);
    if (nbits>0) buf[wpos++]=bits;
    bits=nbits=0;
  }

  // write 1 byte
  void put(int c) {
    assert(wpos<BUFSIZE);
    buf[wpos++]=c;
  }

public:
  LZBuffer(StringBuffer& inbuf, int args[], const unsigned* sap=0);

  // return 1 byte of compressed output (overrides Reader)
  int get() {
    int c=-1;
    if (rpos==wpos) fill();
    if (rpos<wpos) c=buf[rpos++];
    if (rpos==wpos) rpos=wpos=0;
    return c;
  }

  // Read up to p[0..n-1] and return bytes read.
  int read(char* p, int n);
};

// LZ/BWT preprocessor for levels 1..3 compression and e8e9 filter.
// Level 1 uses variable length LZ77 codes like in the lazy compressor:
//
//   00,n,L[n] = n literal bytes
//   mm,mmm,n,ll,r,q (mm > 00) = match 4*n+ll at offset (q<<rb)+r-1
//
// where q is written in 8mm+mmm-8 (0..23) bits with an implied leading 1 bit
// and n is written using interleaved Elias Gamma coding, i.e. the leading
// 1 bit is implied, remaining bits are preceded by a 1 and terminated by
// a 0. e.g. abc is written 1,b,1,c,0. Codes are packed LSB first and
// padded with leading 0 bits in the last byte. r is a number with rb bits,
// where rb = log2(blocksize) - 24.
//
// Level 2 is byte oriented LZ77 with minimum match length m = $4 = args[3]
// with m in 1..64. Lengths and offsets are MSB first:
// 00xxxxxx   x+1 (1..64) literals follow
// yyxxxxxx   y+1 (2..4) offset bytes follow, match length x+m (m..m+63)
//
// Level 3 is BWT with the end of string byte coded as 255 and the
// last 4 bytes giving its position LSB first.

// floor(log2(x)) + 1 = number of bits excluding leading zeros (0..32)
int lg(unsigned x) {
  unsigned r=0;
  if (x>=65536) r=16, x>>=16;
  if (x>=256) r+=8, x>>=8;
  if (x>=16) r+=4, x>>=4;
  assert(x>=0 && x<16);
  return
    "\x00\x01\x02\x02\x03\x03\x03\x03\x04\x04\x04\x04\x04\x04\x04\x04"[x]+r;
}

// return number of 1 bits in x
int nbits(unsigned x) {
  int r;
  for (r=0; x; x>>=1) r+=x&1;
  return r;
}

// Read n bytes of compressed output into p and return number of
// bytes read in 0..n. 0 signals EOF (overrides Reader).
int LZBuffer::read(char* p, int n) {
  if (rpos==wpos) fill();
  int nr=n;
  if (nr>int(wpos-rpos)) nr=wpos-rpos;
  if (nr) memcpy(p, buf+rpos, nr);
  rpos+=nr;
  assert(rpos<=wpos);
  if (rpos==wpos) rpos=wpos=0;
  return nr;
}

LZBuffer::LZBuffer(StringBuffer& inbuf, int args[], const unsigned* sap):
    ht((args[1]&3)==3 ? (inbuf.size()+1)*!sap      // for BWT suffix array
        : args[5]-args[0]<21 ? 1u<<args[5]         // for LZ77 hash table
        : (inbuf.size()*!sap)+(1u<<17<<args[0])),  // for LZ77 SA and ISA
    in(inbuf.data()),
    checkbits(args[5]-args[0]<21 ? 12-args[0] : 17+args[0]),
    level(args[1]&3),
    htsize(ht.size()),
    n(inbuf.size()),
    i(0),
    minMatch(args[2]),
    minMatch2(args[3]),
    maxMatch(BUFSIZE*3),
    maxLiteral(BUFSIZE/4),
    lookahead(args[6]),
    h1(0), h2(0),
    bucket((1<<args[4])-1), 
    shift1(minMatch>0 ? (args[5]-1)/minMatch+1 : 1),
    shift2(minMatch2>0 ? (args[5]-1)/minMatch2+1 : 0),
    minMatchBoth(MAX(minMatch, minMatch2+lookahead)+4),
    rb(args[0]>4 ? args[0]-4 : 0),
    bits(0), nbits(0), rpos(0), wpos(0),
    idx(0), sa(0), isa(0) {
  assert(args[0]>=0);
  assert(n<=(1u<<20<<args[0]));
  assert(args[1]>=1 && args[1]<=7 && args[1]!=4);
  assert(level>=1 && level<=3);
  if ((minMatch<4 && level==1) || (minMatch<1 && level==2))
    error("match length $3 too small");

  // e8e9 transform
  if (args[1]>4 && !sap) e8e9(inbuf.data(), n);

  // build suffix array if not supplied
  if (args[5]-args[0]>=21 || level==3) {  // LZ77-SA or BWT
    if (sap)
      sa=sap;
    else {
      assert(ht.size()>=n);
      assert(ht.size()>0);
      sa=&ht[0];
      if (n>0) divsufsort((const unsigned char*)in, (int*)sa, n);
    }
    if (level<3) {
      assert(ht.size()>=(n*(sap==0))+(1u<<17<<args[0]));
      isa=&ht[n*(sap==0)];
    }
  }
}

// Encode from in to buf until end of input or buf is not empty
void LZBuffer::fill() {

  // BWT
  if (level==3) {
    assert(in || n==0);
    assert(sa);
    for (; wpos<BUFSIZE && i<n+5; ++i) {
      if (i==0) put(n>0 ? in[n-1] : 255);
      else if (i>n) put(idx&255), idx>>=8;
      else if (sa[i-1]==0) idx=i, put(255);
      else put(in[sa[i-1]-1]);
    }
    return;
  }

  // LZ77: scan the input
  unsigned lit=0;  // number of output literals pending
  const unsigned mask=(1<<checkbits)-1;
  while (i<n && wpos*2<BUFSIZE) {

    // Search for longest match, or pick closest in case of tie
    unsigned blen=minMatch-1;  // best match length
    unsigned bp=0;  // pointer to best match
    unsigned blit=0;  // literals before best match
    int bscore=0;  // best cost

    // Look up contexts in suffix array
    if (isa) {
      if (sa[isa[i&mask]]!=i) // rebuild ISA
        for (unsigned j=0; j<n; ++j)
          if ((sa[j]&~mask)==(i&~mask))
            isa[sa[j]&mask]=j;
      for (unsigned h=0; h<=lookahead; ++h) {
        unsigned q=isa[(h+i)&mask];  // location of h+i in SA
        assert(q<n);
        if (sa[q]!=h+i) continue;
        for (int j=-1; j<=1; j+=2) {  // search backward and forward
          for (unsigned k=1; k<=bucket; ++k) {
            unsigned p;  // match to be tested
            if (q+j*k<n && (p=sa[q+j*k]-h)<i) {
              assert(p<n);
              unsigned l, l1;  // length of match, leading literals
              for (l=h; i+l<n && l<maxMatch && in[p+l]==in[i+l]; ++l);
              for (l1=h; l1>0 && in[p+l1-1]==in[i+l1-1]; --l1);
              int score=int(l-l1)*8-lg(i-p)-4*(lit==0 && l1>0)-11;
              for (unsigned a=0; a<h; ++a) score=score*5/8;
              if (score>bscore) blen=l, bp=p, blit=l1, bscore=score;
              if (l<blen || l<minMatch || l>255) break;
            }
          }
        }
        if (bscore<=0 || blen<minMatch) break;
      }
    }

    // Look up contexts in a hash table.
    // Try the longest context orders first. If a match is found, then
    // skip the lower order as a speed optimization.
    else if (level==1 || minMatch<=64) {
      if (minMatch2>0) {
        for (unsigned k=0; k<=bucket; ++k) {
          unsigned p=ht[h2^k];
          if (p && (p&mask)==(in[i+3]&mask)) {
            p>>=checkbits;
            if (p<i && i+blen<=n && in[p+blen-1]==in[i+blen-1]) {
              unsigned l;  // match length from lookahead
              for (l=lookahead; i+l<n && l<maxMatch && in[p+l]==in[i+l]; ++l);
              if (l>=minMatch2+lookahead) {
                int l1;  // length back from lookahead
                for (l1=lookahead; l1>0 && in[p+l1-1]==in[i+l1-1]; --l1);
                assert(l1>=0 && l1<=int(lookahead));
                int score=int(l-l1)*8-lg(i-p)-8*(lit==0 && l1>0)-11;
                if (score>bscore) blen=l, bp=p, blit=l1, bscore=score;
              }
            }
          }
          if (blen>=128) break;
        }
      }

      // Search the lower order context
      if (!minMatch2 || blen<minMatch2) {
        for (unsigned k=0; k<=bucket; ++k) {
          unsigned p=ht[h1^k];
          if (p && i+3<n && (p&mask)==(in[i+3]&mask)) {
            p>>=checkbits;
            if (p<i && i+blen<=n && in[p+blen-1]==in[i+blen-1]) {
              unsigned l;
              for (l=0; i+l<n && l<maxMatch && in[p+l]==in[i+l]; ++l);
              int score=l*8-lg(i-p)-2*(lit>0)-11;
              if (score>bscore) blen=l, bp=p, blit=0, bscore=score;
            }
          }
          if (blen>=128) break;
        }
      }
    }

    // If match is long enough, then output any pending literals first,
    // and then the match. blen is the length of the match.
    assert(i>=bp);
    const unsigned off=i-bp;  // offset
    if (off>0 && bscore>0
        && blen-blit>=minMatch+(level==2)*((off>=(1<<16))+(off>=(1<<24)))) {
      lit+=blit;
      write_literal(i+blit, lit);
      write_match(blen-blit, off);
    }

    // Otherwise add to literal length
    else {
      blen=1;
      ++lit;
    }

    // Update index, advance blen bytes
    if (isa)
      i+=blen;
    else {
      while (blen--) {
        if (i+minMatchBoth<n) {
          unsigned ih=((i*1234547)>>19)&bucket;
          const unsigned p=(i<<checkbits)|(in[i+3]&mask);
          assert(ih<=bucket);
          if (minMatch2) {
            ht[h2^ih]=p;
            h2=(((h2*9)<<shift2)
                +(in[i+minMatch2+lookahead]+1)*23456789u)&(htsize-1);
          }
          ht[h1^ih]=p;
          h1=(((h1*5)<<shift1)+(in[i+minMatch]+1)*123456791u)&(htsize-1);
        }
        ++i;
      }
    }

    // Write long literals to keep buf from filling up
    if (lit>=maxLiteral)
      write_literal(i, lit);
  }

  // Write pending literals at end of input
  assert(i<=n);
  if (i==n) {
    write_literal(n, lit);
    flush();
  }
}

// Write literal sequence in[i-lit..i-1], set lit=0
void LZBuffer::write_literal(unsigned i, unsigned& lit) {
  assert(lit>=0);
  assert(i>=0 && i<=n);
  assert(i>=lit);
  if (level==1) {
    if (lit<1) return;
    int ll=lg(lit);
    assert(ll>=1 && ll<=24);
    putb(0, 2);
    --ll;
    while (--ll>=0) {
      putb(1, 1);
      putb((lit>>ll)&1, 1);
    }
    putb(0, 1);
    while (lit) putb(in[i-lit--], 8);
  }
  else {
    assert(level==2);
    while (lit>0) {
      unsigned lit1=lit;
      if (lit1>64) lit1=64;
      put(lit1-1);
      for (unsigned j=i-lit; j<i-lit+lit1; ++j) put(in[j]);
      lit-=lit1;
    }
  }
}

// Write match sequence of given length and offset
void LZBuffer::write_match(unsigned len, unsigned off) {

  // mm,mmm,n,ll,r,q[mmmmm-8] = match n*4+ll, offset ((q-1)<<rb)+r+1
  if (level==1) {
    assert(len>=minMatch && len<=maxMatch);
    assert(off>0);
    assert(len>=4);
    assert(rb>=0 && rb<=8);
    int ll=lg(len)-1;
    assert(ll>=2);
    off+=(1<<rb)-1;
    int lo=lg(off)-1-rb;
    assert(lo>=0 && lo<=23);
    putb((lo+8)>>3, 2);// mm
    putb(lo&7, 3);     // mmm
    while (--ll>=2) {  // n
      putb(1, 1);
      putb((len>>ll)&1, 1);
    }
    putb(0, 1);
    putb(len&3, 2);    // ll
    putb(off, rb);     // r
    putb(off>>rb, lo); // q
  }

  // x[2]:len[6] off[x-1] 
  else {
    assert(level==2);
    assert(minMatch>=1 && minMatch<=64);
    --off;
    while (len>0) {  // Split long matches to len1=minMatch..minMatch+63
      const unsigned len1=len>minMatch*2+63 ? minMatch+63 :
          len>minMatch+63 ? len-minMatch : len;
      assert(wpos<BUFSIZE-5);
      assert(len1>=minMatch && len1<minMatch+64);
      if (off<(1<<16)) {
        put(64+len1-minMatch);
        put(off>>8);
        put(off);
      }
      else if (off<(1<<24)) {
        put(128+len1-minMatch);
        put(off>>16);
        put(off>>8);
        put(off);
      }
      else {
        put(192+len1-minMatch);
        put(off>>24);
        put(off>>16);
        put(off>>8);
        put(off);
      }
      len-=len1;
    }
  }
}

// Generate a config file from the method argument with syntax:
// {0|x|s|i}[N1[,N2]...][{ciamtswf<cfg>}[N1[,N2]]...]...
std::string makeConfig(const char* method, int args[]) {
  assert(method);
  const char type=method[0];
  assert(type=='x' || type=='s' || type=='0' || type=='i');

  // Read "{x|s|i|0}N1,N2...N9" into args[0..8] ($1..$9)
  args[0]=0;  // log block size in MiB
  args[1]=0;  // 0=none, 1=var-LZ77, 2=byte-LZ77, 3=BWT, 4..7 adds E8E9
  args[2]=0;  // lz77 minimum match length
  args[3]=0;  // secondary context length
  args[4]=0;  // log searches
  args[5]=0;  // lz77 hash table size or SA if args[0]+21
  args[6]=0;  // secondary context look ahead
  args[7]=0;  // not used
  args[8]=0;  // not used
  if (isdigit(*++method)) args[0]=0;
  for (int i=0; i<9 && (isdigit(*method) || *method==',' || *method=='.');) {
    if (isdigit(*method))
      args[i]=args[i]*10+*method-'0';
    else if (++i<9)
      args[i]=0;
    ++method;
  }

  // "0..." = No compression
  if (type=='0')
    return "comp 0 0 0 0 0 hcomp end\n";

  // Generate the postprocessor
  std::string hdr, pcomp;
  const int level=args[1]&3;
  const bool doe8=args[1]>=4 && args[1]<=7;

  // LZ77+Huffman, with or without E8E9
  if (level==1) {
    const int rb=args[0]>4 ? args[0]-4 : 0;
    hdr="comp 9 16 0 $1+20 ";
    pcomp=
    "pcomp lazy2 3 ;\n"
    " (r1 = state\n"
    "  r2 = len - match or literal length\n"
    "  r3 = m - number of offset bits expected\n"
    "  r4 = ptr to buf\n"
    "  r5 = r - low bits of offset\n"
    "  c = bits - input buffer\n"
    "  d = n - number of bits in c)\n"
    "\n"
    "  a> 255 if\n";
    if (doe8)
      pcomp+=
      "    b=0 d=r 4 do (for b=0..d-1, d = end of buf)\n"
      "      a=b a==d ifnot\n"
      "        a+= 4 a<d if\n"
      "          a=*b a&= 254 a== 232 if (e8 or e9?)\n"
      "            c=b b++ b++ b++ b++ a=*b a++ a&= 254 a== 0 if (00 or ff)\n"
      "              b-- a=*b\n"
      "              b-- a<<= 8 a+=*b\n"
      "              b-- a<<= 8 a+=*b\n"
      "              a-=b a++\n"
      "              *b=a a>>= 8 b++\n"
      "              *b=a a>>= 8 b++\n"
      "              *b=a b++\n"
      "            endif\n"
      "            b=c\n"
      "          endif\n"
      "        endif\n"
      "        a=*b out b++\n"
      "      forever\n"
      "    endif\n"
      "\n";
    pcomp+=
    "    (reset state)\n"
    "    a=0 b=0 c=0 d=0 r=a 1 r=a 2 r=a 3 r=a 4\n"
    "    halt\n"
    "  endif\n"
    "\n"
    "  a<<=d a+=c c=a               (bits+=a<<n)\n"
    "  a= 8 a+=d d=a                (n+=8)\n"
    "\n"
    "  (if state==0 (expect new code))\n"
    "  a=r 1 a== 0 if (match code mm,mmm)\n"
    "    a= 1 r=a 2                 (len=1)\n"
    "    a=c a&= 3 a> 0 if          (if (bits&3))\n"
    "      a-- a<<= 3 r=a 3           (m=((bits&3)-1)*8)\n"
    "      a=c a>>= 2 c=a             (bits>>=2)\n"
    "      b=r 3 a&= 7 a+=b r=a 3     (m+=bits&7)\n"
    "      a=c a>>= 3 c=a             (bits>>=3)\n"
    "      a=d a-= 5 d=a              (n-=5)\n"
    "      a= 1 r=a 1                 (state=1)\n"
    "    else (literal, discard 00)\n"
    "      a=c a>>= 2 c=a             (bits>>=2)\n"
    "      d-- d--                    (n-=2)\n"
    "      a= 3 r=a 1                 (state=3)\n"
    "    endif\n"
    "  endif\n"
    "\n"
    "  (while state==1 && n>=3 (expect match length n*4+ll -> r2))\n"
    "  do a=r 1 a== 1 if a=d a> 2 if\n"
    "    a=c a&= 1 a== 1 if         (if bits&1)\n"
    "      a=c a>>= 1 c=a             (bits>>=1)\n"
    "      b=r 2 a=c a&= 1 a+=b a+=b r=a 2 (len+=len+(bits&1))\n"
    "      a=c a>>= 1 c=a             (bits>>=1)\n"
    "      d-- d--                    (n-=2)\n"
    "    else\n"
    "      a=c a>>= 1 c=a             (bits>>=1)\n"
    "      a=r 2 a<<= 2 b=a           (len<<=2)\n"
    "      a=c a&= 3 a+=b r=a 2       (len+=bits&3)\n"
    "      a=c a>>= 2 c=a             (bits>>=2)\n"
    "      d-- d-- d--                (n-=3)\n";
    if (rb)
      pcomp+="      a= 5 r=a 1                 (state=5)\n";
    else
      pcomp+="      a= 2 r=a 1                 (state=2)\n";
    pcomp+=
    "    endif\n"
    "  forever endif endif\n"
    "\n";
    if (rb) pcomp+=  // save r in r5
      "  (if state==5 && n>=8) (expect low bits of offset to put in r5)\n"
      "  a=r 1 a== 5 if a=d a> "+itos(rb-1)+" if\n"
      "    a=c a&= "+itos((1<<rb)-1)+" r=a 5            (save r in r5)\n"
      "    a=c a>>= "+itos(rb)+" c=a\n"
      "    a=d a-= "+itos(rb)+ " d=a\n"
      "    a= 2 r=a 1                   (go to state 2)\n"
      "  endif endif\n"
      "\n";
    pcomp+=
    "  (if state==2 && n>=m) (expect m offset bits)\n"
    "  a=r 1 a== 2 if a=r 3 a>d ifnot\n"
    "    a=c r=a 6 a=d r=a 7          (save c=bits, d=n in r6,r7)\n"
    "    b=r 3 a= 1 a<<=b d=a         (d=1<<m)\n"
    "    a-- a&=c a+=d                (d=offset=bits&((1<<m)-1)|(1<<m))\n";
    if (rb)
      pcomp+=  // insert r into low bits of d
      "    a<<= "+itos(rb)+" d=r 5 a+=d a-= "+itos((1<<rb)-1)+"\n";
    pcomp+=
    "    d=a b=r 4 a=b a-=d c=a       (c=p=(b=ptr)-offset)\n"
    "\n"
    "    (while len-- (copy and output match d bytes from *c to *b))\n"
    "    d=r 2 do a=d a> 0 if d--\n"
    "      a=*c *b=a c++ b++          (buf[ptr++]-buf[p++])\n";
    if (!doe8) pcomp+=" out\n";
    pcomp+=
    "    forever endif\n"
    "    a=b r=a 4\n"
    "\n"
    "    a=r 6 b=r 3 a>>=b c=a        (bits>>=m)\n"
    "    a=r 7 a-=b d=a               (n-=m)\n"
    "    a=0 r=a 1                    (state=0)\n"
    "  endif endif\n"
    "\n"
    "  (while state==3 && n>=2 (expect literal length))\n"
    "  do a=r 1 a== 3 if a=d a> 1 if\n"
    "    a=c a&= 1 a== 1 if         (if bits&1)\n"
    "      a=c a>>= 1 c=a              (bits>>=1)\n"
    "      b=r 2 a&= 1 a+=b a+=b r=a 2 (len+=len+(bits&1))\n"
    "      a=c a>>= 1 c=a              (bits>>=1)\n"
    "      d-- d--                     (n-=2)\n"
    "    else\n"
    "      a=c a>>= 1 c=a              (bits>>=1)\n"
    "      d--                         (--n)\n"
    "      a= 4 r=a 1                  (state=4)\n"
    "    endif\n"
    "  forever endif endif\n"
    "\n"
    "  (if state==4 && n>=8 (expect len literals))\n"
    "  a=r 1 a== 4 if a=d a> 7 if\n"
    "    b=r 4 a=c *b=a\n";
    if (!doe8) pcomp+=" out\n";
    pcomp+=
    "    b++ a=b r=a 4                 (buf[ptr++]=bits)\n"
    "    a=c a>>= 8 c=a                (bits>>=8)\n"
    "    a=d a-= 8 d=a                 (n-=8)\n"
    "    a=r 2 a-- r=a 2 a== 0 if      (if --len<1)\n"
    "      a=0 r=a 1                     (state=0)\n"
    "    endif\n"
    "  endif endif\n"
    "  halt\n"
    "end\n";
  }

  // Byte aligned LZ77, with or without E8E9
  else if (level==2) {
    hdr="comp 9 16 0 $1+20 ";
    pcomp=
    "pcomp lzpre c ;\n"
    "  (Decode LZ77: d=state, M=output buffer, b=size)\n"
    "  a> 255 if (at EOF decode e8e9 and output)\n";
    if (doe8)
      pcomp+=
      "    d=b b=0 do (for b=0..d-1, d = end of buf)\n"
      "      a=b a==d ifnot\n"
      "        a+= 4 a<d if\n"
      "          a=*b a&= 254 a== 232 if (e8 or e9?)\n"
      "            c=b b++ b++ b++ b++ a=*b a++ a&= 254 a== 0 if (00 or ff)\n"
      "              b-- a=*b\n"
      "              b-- a<<= 8 a+=*b\n"
      "              b-- a<<= 8 a+=*b\n"
      "              a-=b a++\n"
      "              *b=a a>>= 8 b++\n"
      "              *b=a a>>= 8 b++\n"
      "              *b=a b++\n"
      "            endif\n"
      "            b=c\n"
      "          endif\n"
      "        endif\n"
      "        a=*b out b++\n"
      "      forever\n"
      "    endif\n";
    pcomp+=
    "    b=0 c=0 d=0 a=0 r=a 1 r=a 2 (reset state)\n"
    "  halt\n"
    "  endif\n"
    "\n"
    "  (in state d==0, expect a new code)\n"
    "  (put length in r1 and inital part of offset in r2)\n"
    "  c=a a=d a== 0 if\n"
    "    a=c a>>= 6 a++ d=a\n"
    "    a== 1 if (literal?)\n"
    "      a+=c r=a 1 a=0 r=a 2\n"
    "    else (3 to 5 byte match)\n"
    "      d++ a=c a&= 63 a+= $3 r=a 1 a=0 r=a 2\n"
    "    endif\n"
    "  else\n"
    "    a== 1 if (writing literal)\n"
    "      a=c *b=a b++\n";
    if (!doe8) pcomp+=" out\n";
    pcomp+=
    "      a=r 1 a-- a== 0 if d=0 endif r=a 1 (if (--len==0) state=0)\n"
    "    else\n"
    "      a> 2 if (reading offset)\n"
    "        a=r 2 a<<= 8 a|=c r=a 2 d-- (off=off<<8|c, --state)\n"
    "      else (state==2, write match)\n"
    "        a=r 2 a<<= 8 a|=c c=a a=b a-=c a-- c=a (c=i-off-1)\n"
    "        d=r 1 (d=len)\n"
    "        do (copy and output d=len bytes)\n"
    "          a=*c *b=a c++ b++\n";
    if (!doe8) pcomp+=" out\n";
    pcomp+=
    "        d-- a=d a> 0 while\n"
    "        (d=state=0. off, len don\'t matter)\n"
    "      endif\n"
    "    endif\n"
    "  endif\n"
    "  halt\n"
    "end\n";
  }

  // BWT with or without E8E9
  else if (level==3) {  // IBWT
    hdr="comp 9 16 $1+20 $1+20 ";  // 2^$1 = block size in MB
    pcomp=
    "pcomp bwtrle c ;\n"
    "\n"
    "  (read BWT, index into M, size in b)\n"
    "  a> 255 ifnot\n"
    "    *b=a b++\n"
    "\n"
    "  (inverse BWT)\n"
    "  elsel\n"
    "\n"
    "    (index in last 4 bytes, put in c and R1)\n"
    "    b-- a=*b\n"
    "    b-- a<<= 8 a+=*b\n"
    "    b-- a<<= 8 a+=*b\n"
    "    b-- a<<= 8 a+=*b c=a r=a 1\n"
    "\n"
    "    (save size in R2)\n"
    "    a=b r=a 2\n"
    "\n"
    "    (count bytes in H[~1..~255, ~0])\n"
    "    do\n"
    "      a=b a> 0 if\n"
    "        b-- a=*b a++ a&= 255 d=a d! *d++\n"
    "      forever\n"
    "    endif\n"
    "\n"
    "    (cumulative counts: H[~i=0..255] = count of bytes before i)\n"
    "    d=0 d! *d= 1 a=0\n"
    "    do\n"
    "      a+=*d *d=a d--\n"
    "    d<>a a! a> 255 a! d<>a until\n"
    "\n"
    "    (build first part of linked list in H[0..idx-1])\n"
    "    b=0 do\n"
    "      a=c a>b if\n"
    "        d=*b d! *d++ d=*d d-- *d=b\n"
    "      b++ forever\n"
    "    endif\n"
    "\n"
    "    (rest of list in H[idx+1..n-1])\n"
    "    b=c b++ c=r 2 do\n"
    "      a=c a>b if\n"
    "        d=*b d! *d++ d=*d d-- *d=b\n"
    "      b++ forever\n"
    "    endif\n"
    "\n";
    if (args[0]<=4) {  // faster IBWT list traversal limited to 16 MB blocks
      pcomp+=
      "    (copy M to low 8 bits of H to reduce cache misses in next loop)\n"
      "    b=0 do\n"
      "      a=c a>b if\n"
      "        d=b a=*d a<<= 8 a+=*b *d=a\n"
      "      b++ forever\n"
      "    endif\n"
      "\n"
      "    (traverse list and output or copy to M)\n"
      "    d=r 1 b=0 do\n"
      "      a=d a== 0 ifnot\n"
      "        a=*d a>>= 8 d=a\n";
      if (doe8) pcomp+=" *b=*d b++\n";
      else      pcomp+=" a=*d out\n";
      pcomp+=
      "      forever\n"
      "    endif\n"
      "\n";
      if (doe8)  // IBWT+E8E9
        pcomp+=
        "    (e8e9 transform to out)\n"
        "    d=b b=0 do (for b=0..d-1, d = end of buf)\n"
        "      a=b a==d ifnot\n"
        "        a+= 4 a<d if\n"
        "          a=*b a&= 254 a== 232 if\n"
        "            c=b b++ b++ b++ b++ a=*b a++ a&= 254 a== 0 if\n"
        "              b-- a=*b\n"
        "              b-- a<<= 8 a+=*b\n"
        "              b-- a<<= 8 a+=*b\n"
        "              a-=b a++\n"
        "              *b=a a>>= 8 b++\n"
        "              *b=a a>>= 8 b++\n"
        "              *b=a b++\n"
        "            endif\n"
        "            b=c\n"
        "          endif\n"
        "        endif\n"
        "        a=*b out b++\n"
        "      forever\n"
        "    endif\n";
      pcomp+=
      "  endif\n"
      "  halt\n"
      "end\n";
    }
    else {  // slower IBWT list traversal for all sized blocks
      if (doe8) {  // E8E9 after IBWT
        pcomp+=
        "    (R2 = output size without EOS)\n"
        "    a=r 2 a-- r=a 2\n"
        "\n"
        "    (traverse list (d = IBWT pointer) and output inverse e8e9)\n"
        "    (C = offset = 0..R2-1)\n"
        "    (R4 = last 4 bytes shifted in from MSB end)\n"
        "    (R5 = temp pending output byte)\n"
        "    c=0 d=r 1 do\n"
        "      a=d a== 0 ifnot\n"
        "        d=*d\n"
        "\n"
        "        (store byte in R4 and shift out to R5)\n"
        "        b=d a=*b a<<= 24 b=a\n"
        "        a=r 4 r=a 5 a>>= 8 a|=b r=a 4\n"
        "\n"
        "        (if E8|E9 xx xx xx 00|FF in R4:R5 then subtract c from x)\n"
        "        a=c a> 3 if\n"
        "          a=r 5 a&= 254 a== 232 if\n"
        "            a=r 4 a>>= 24 b=a a++ a&= 254 a< 2 if\n"
        "              a=r 4 a-=c a+= 4 a<<= 8 a>>= 8 \n"
        "              b<>a a<<= 24 a+=b r=a 4\n"
        "            endif\n"
        "          endif\n"
        "        endif\n"
        "\n"
        "        (output buffered byte)\n"
        "        a=c a> 3 if a=r 5 out endif c++\n"
        "\n"
        "      forever\n"
        "    endif\n"
        "\n"
        "    (output up to 4 pending bytes in R4)\n"
        "    b=r 4\n"
        "    a=c a> 3 a=b if out endif a>>= 8 b=a\n"
        "    a=c a> 2 a=b if out endif a>>= 8 b=a\n"
        "    a=c a> 1 a=b if out endif a>>= 8 b=a\n"
        "    a=c a> 0 a=b if out endif\n"
        "\n"
        "  endif\n"
        "  halt\n"
        "end\n";
      }
      else {
        pcomp+=
        "    (traverse list and output)\n"
        "    d=r 1 do\n"
        "      a=d a== 0 ifnot\n"
        "        d=*d\n"
        "        b=d a=*b out\n"
        "      forever\n"
        "    endif\n"
        "  endif\n"
        "  halt\n"
        "end\n";
      }
    }
  }

  // E8E9 or no preprocessing
  else if (level==0) {
    hdr="comp 9 16 0 0 ";
    if (doe8) { // E8E9?
      pcomp=
      "pcomp e8e9 d ;\n"
      "  a> 255 if\n"
      "    a=c a> 4 if\n"
      "      c= 4\n"
      "    else\n"
      "      a! a+= 5 a<<= 3 d=a a=b a>>=d b=a\n"
      "    endif\n"
      "    do a=c a> 0 if\n"
      "      a=b out a>>= 8 b=a c--\n"
      "    forever endif\n"
      "  else\n"
      "    *b=b a<<= 24 d=a a=b a>>= 8 a+=d b=a c++\n"
      "    a=c a> 4 if\n"
      "      a=*b out\n"
      "      a&= 254 a== 232 if\n"
      "        a=b a>>= 24 a++ a&= 254 a== 0 if\n"
      "          a=b a>>= 24 a<<= 24 d=a\n"
      "          a=b a-=c a+= 5\n"
      "          a<<= 8 a>>= 8 a|=d b=a\n"
      "        endif\n"
      "      endif\n"
      "    endif\n"
      "  endif\n"
      "  halt\n"
      "end\n";
    }
    else
      pcomp="end\n";
  }
  else
    error("Unsupported method");
  
  // Build context model (comp, hcomp) assuming:
  // H[0..254] = contexts
  // H[255..511] = location of last byte i-255
  // M = last 64K bytes, filling backward
  // C = pointer to most recent byte
  // R1 = level 2 lz77 1+bytes expected until next code, 0=init
  // R2 = level 2 lz77 first byte of code
  int ncomp=0;  // number of components
  const int membits=args[0]+20;
  int sb=5;  // bits in last context
  std::string comp;
  std::string hcomp="hcomp\n"
    "c-- *c=a a+= 255 d=a *d=c\n";
  if (level==2) {  // put level 2 lz77 parse state in R1, R2
    hcomp+=
    "  (decode lz77 into M. Codes:\n"
    "  00xxxxxx = literal length xxxxxx+1\n"
    "  xx......, xx > 0 = match with xx offset bytes to follow)\n"
    "\n"
    "  a=r 1 a== 0 if (init)\n"
    "    a= "+itos(111+57*doe8)+" (skip post code)\n"
    "  else a== 1 if  (new code?)\n"
    "    a=*c r=a 2  (save code in R2)\n"
    "    a> 63 if a>>= 6 a++ a++  (match)\n"
    "    else a++ a++ endif  (literal)\n"
    "  else (read rest of code)\n"
    "    a--\n"
    "  endif endif\n"
    "  r=a 1  (R1 = 1+expected bytes to next code)\n";
  }

  // Generate the context model
  while (*method && ncomp<254) {

    // parse command C[N1[,N2]...] into v = {C, N1, N2...}
    std::vector<int> v;
    v.push_back(*method++);
    if (isdigit(*method)) {
      v.push_back(*method++-'0');
      while (isdigit(*method) || *method==',' || *method=='.') {
        if (isdigit(*method))
          v.back()=v.back()*10+*method++-'0';
        else {
          v.push_back(0);
          ++method;
        }
      }
    }

    // c: context model
    // N1%1000: 0=ICM 1..256=CM limit N1-1
    // N1/1000: number of times to halve memory
    // N2: 1..255=offset mod N2. 1000..1255=distance to N2-1000
    // N3...: 0..255=byte mask + 256=lz77 state. 1000+=run of N3-1000 zeros.
    if (v[0]=='c') {
      while (v.size()<3) v.push_back(0);
      comp+=itos(ncomp)+" ";
      sb=11;  // count context bits
      if (v[2]<256) sb+=lg(v[2]);
      else sb+=6;
      for (unsigned i=3; i<v.size(); ++i)
        if (v[i]<512) sb+=nbits(v[i])*3/4;
      if (sb>membits) sb=membits;
      if (v[1]%1000==0) comp+="icm "+itos(sb-6-v[1]/1000)+"\n";
      else comp+="cm "+itos(sb-2-v[1]/1000)+" "+itos(v[1]%1000-1)+"\n";

      // special contexts
      hcomp+="d= "+itos(ncomp)+" *d=0\n";
      if (v[2]>1 && v[2]<=255) {  // periodic context
        if (lg(v[2])!=lg(v[2]-1))
          hcomp+="a=c a&= "+itos(v[2]-1)+" hashd\n";
        else
          hcomp+="a=c a%= "+itos(v[2])+" hashd\n";
      }
      else if (v[2]>=1000 && v[2]<=1255)  // distance context
        hcomp+="a= 255 a+= "+itos(v[2]-1000)+
               " d=a a=*d a-=c a> 255 if a= 255 endif d= "+
               itos(ncomp)+" hashd\n";

      // Masked context
      for (unsigned i=3; i<v.size(); ++i) {
        if (i==3) hcomp+="b=c ";
        if (v[i]==255)
          hcomp+="a=*b hashd\n";  // ordinary byte
        else if (v[i]>0 && v[i]<255)
          hcomp+="a=*b a&= "+itos(v[i])+" hashd\n";  // masked byte
        else if (v[i]>=256 && v[i]<512) { // lz77 state or masked literal byte
          hcomp+=
          "a=r 1 a> 1 if\n"  // expect literal or offset
          "  a=r 2 a< 64 if\n"  // expect literal
          "    a=*b ";
          if (v[i]<511) hcomp+="a&= "+itos(v[i]-256);
          hcomp+=" hashd\n"
          "  else\n"  // expect match offset byte
          "    a>>= 6 hashd a=r 1 hashd\n"
          "  endif\n"
          "else\n"  // expect new code
          "  a= 255 hashd a=r 2 hashd\n"
          "endif\n";
        }
        else if (v[i]>=1256)  // skip v[i]-1000 bytes
          hcomp+="a= "+itos(((v[i]-1000)>>8)&255)+" a<<= 8 a+= "
               +itos((v[i]-1000)&255)+
          " a+=b b=a\n";
        else if (v[i]>1000)
          hcomp+="a= "+itos(v[i]-1000)+" a+=b b=a\n";
        if (v[i]<512 && i<v.size()-1)
          hcomp+="b++ ";
      }
      ++ncomp;
    }

    // m,8,24: MIX, size, rate
    // t,8,24: MIX2, size, rate
    // s,8,32,255: SSE, size, start, limit
    if (strchr("mts", v[0]) && ncomp>int(v[0]=='t')) {
      if (v.size()<=1) v.push_back(8);
      if (v.size()<=2) v.push_back(24+8*(v[0]=='s'));
      if (v[0]=='s' && v.size()<=3) v.push_back(255);
      comp+=itos(ncomp);
      sb=5+v[1]*3/4;
      if (v[0]=='m')
        comp+=" mix "+itos(v[1])+" 0 "+itos(ncomp)+" "+itos(v[2])+" 255\n";
      else if (v[0]=='t')
        comp+=" mix2 "+itos(v[1])+" "+itos(ncomp-1)+" "+itos(ncomp-2)
            +" "+itos(v[2])+" 255\n";
      else // s
        comp+=" sse "+itos(v[1])+" "+itos(ncomp-1)+" "+itos(v[2])+" "
            +itos(v[3])+"\n";
      if (v[1]>8) {
        hcomp+="d= "+itos(ncomp)+" *d=0 b=c a=0\n";
        for (; v[1]>=16; v[1]-=8) {
          hcomp+="a<<= 8 a+=*b";
          if (v[1]>16) hcomp+=" b++";
          hcomp+="\n";
        }
        if (v[1]>8)
          hcomp+="a<<= 8 a+=*b a>>= "+itos(16-v[1])+"\n";
        hcomp+="a<<= 8 *d=a\n";
      }
      ++ncomp;
    }

    // i: ISSE chain with order increasing by N1,N2...
    if (v[0]=='i' && ncomp>0) {
      assert(sb>=5);
      hcomp+="d= "+itos(ncomp-1)+" b=c a=*d d++\n";
      for (unsigned i=1; i<v.size() && ncomp<254; ++i) {
        for (int j=0; j<v[i]%10; ++j) {
          hcomp+="hash ";
          if (i<v.size()-1 || j<v[i]%10-1) hcomp+="b++ ";
          sb+=6;
        }
        hcomp+="*d=a";
        if (i<v.size()-1) hcomp+=" d++";
        hcomp+="\n";
        if (sb>membits) sb=membits;
        comp+=itos(ncomp)+" isse "+itos(sb-6-v[i]/10)+" "+itos(ncomp-1)+"\n";
        ++ncomp;
      }
    }

    // a24,0,0: MATCH. N1=hash multiplier. N2,N3=halve buf, table.
    if (v[0]=='a') {
      if (v.size()<=1) v.push_back(24);
      while (v.size()<4) v.push_back(0);
      comp+=itos(ncomp)+" match "+itos(membits-v[3]-2)+" "
          +itos(membits-v[2])+"\n";
      hcomp+="d= "+itos(ncomp)+" a=*d a*= "+itos(v[1])
           +" a+=*c a++ *d=a\n";
      sb=5+(membits-v[2])*3/4;
      ++ncomp;
    }

    // w1,65,26,223,20,0: ICM-ISSE chain of length N1 with word contexts,
    // where a word is a sequence of c such that c&N4 is in N2..N2+N3-1.
    // Word is hashed by: hash := hash*N5+c+1
    // Decrease memory by 2^-N6.
    if (v[0]=='w') {
      if (v.size()<=1) v.push_back(1);
      if (v.size()<=2) v.push_back(65);
      if (v.size()<=3) v.push_back(26);
      if (v.size()<=4) v.push_back(223);
      if (v.size()<=5) v.push_back(20);
      if (v.size()<=6) v.push_back(0);
      comp+=itos(ncomp)+" icm "+itos(membits-6-v[6])+"\n";
      for (int i=1; i<v[1]; ++i)
        comp+=itos(ncomp+i)+" isse "+itos(membits-6-v[6])+" "
            +itos(ncomp+i-1)+"\n";
      hcomp+="a=*c a&= "+itos(v[4])+" a-= "+itos(v[2])+" a&= 255 a< "
           +itos(v[3])+" if\n";
      for (int i=0; i<v[1]; ++i) {
        if (i==0) hcomp+="  d= "+itos(ncomp);
        else hcomp+="  d++";
        hcomp+=" a=*d a*= "+itos(v[5])+" a+=*c a++ *d=a\n";
      }
      hcomp+="else\n";
      for (int i=v[1]-1; i>0; --i)
        hcomp+="  d= "+itos(ncomp+i-1)+" a=*d d++ *d=a\n";
      hcomp+="  d= "+itos(ncomp)+" *d=0\n"
           "endif\n";
      ncomp+=v[1]-1;
      sb=membits-v[6];
      ++ncomp;
    }
  }
  return hdr+itos(ncomp)+"\n"+comp+hcomp+"halt\n"+pcomp;
}

// Compress from in to out in 1 segment in 1 block using the algorithm
// descried in method. If method begins with a digit then choose
// a method depending on type. Save filename and comment
// in the segment header. If comment is 0 then the default is the input size
// as a decimal string, plus " jDC\x01" for a journaling method (method[0]
// is not 's'). Write the generated method to methodOut if not 0.
void compressBlock(StringBuffer* in, Writer* out, const char* method_,
                   const char* filename, const char* comment, bool dosha1) {
  assert(in);
  assert(out);
  assert(method_);
  assert(method_[0]);
  std::string method=method_;
  const unsigned n=in->size();  // input size
  const int arg0=MAX(lg(n+4095)-20, 0);  // block size
  assert((1u<<(arg0+20))>=n+4096);

  // Get type from method "LB,R,t" where L is level 0..5, B is block
  // size 0..11, R is redundancy 0..255, t = 0..3 = binary, text, exe, both.
  unsigned type=0;
  if (isdigit(method[0])) {
    int commas=0, arg[4]={0};
    for (int i=1; i<int(method.size()) && commas<4; ++i) {
      if (method[i]==',' || method[i]=='.') ++commas;
      else if (isdigit(method[i])) arg[commas]=arg[commas]*10+method[i]-'0';
    }
    if (commas==0) type=512;
    else type=arg[1]*4+arg[2];
  }

  // Get hash of input
  libzpaq::SHA1 sha1;
  const char* sha1ptr=0;
#ifdef DEBUG
  if (true) {
#else
  if (dosha1) {
#endif
    sha1.write(in->c_str(), n);
    sha1ptr=sha1.result();
  }

  // Expand default methods
  if (isdigit(method[0])) {
    const int level=method[0]-'0';
    assert(level>=0 && level<=9);

    // build models
    const int doe8=(type&2)*2;
    method="x"+itos(arg0);
    std::string htsz=","+itos(19+arg0+(arg0<=6));  // lz77 hash table size
    std::string sasz=","+itos(21+arg0);            // lz77 suffix array size

    // store uncompressed
    if (level==0)
      method="0"+itos(arg0)+",0";

    // LZ77, no model. Store if hard to compress
    else if (level==1) {
      if (type<40) method+=",0";
      else {
        method+=","+itos(1+doe8)+",";
        if      (type<80)  method+="4,0,1,15";
        else if (type<128) method+="4,0,2,16";
        else if (type<256) method+="4,0,2"+htsz;
        else if (type<960) method+="5,0,3"+htsz;
        else               method+="6,0,3"+htsz;
      }
    }

    // LZ77 with longer search
    else if (level==2) {
      if (type<32) method+=",0";
      else {
        method+=","+itos(1+doe8)+",";
        if (type<64) method+="4,0,3"+htsz;
        else method+="4,0,7"+sasz+",1";
      }
    }

    // LZ77 with CM depending on redundancy
    else if (level==3) {
      if (type<20)  // store if not compressible
        method+=",0";
      else if (type<48)  // fast LZ77 if barely compressible
        method+=","+itos(1+doe8)+",4,0,3"+htsz;
      else if (type>=640 || (type&1))  // BWT if text or highly compressible
        method+=","+itos(3+doe8)+"ci1";
      else  // LZ77 with O0-1 compression of up to 12 literals
        method+=","+itos(2+doe8)+",12,0,7"+sasz+",1c0,0,511i2";
    }

    // LZ77+CM, fast CM, or BWT depending on type
    else if (level==4) {
      if (type<12)
        method+=",0";
      else if (type<24)
        method+=","+itos(1+doe8)+",4,0,3"+htsz;
      else if (type<48)
        method+=","+itos(2+doe8)+",5,0,7"+sasz+"1c0,0,511";
      else if (type<900) {
        method+=","+itos(doe8)+"ci1,1,1,1,2a";
        if (type&1) method+="w";
        method+="m";
      }
      else
        method+=","+itos(3+doe8)+"ci1";
    }

    // Slow CM with lots of models
    else {  // 5..9

      // Model text files
      method+=","+itos(doe8);
      if (type&1) method+="w2c0,1010,255i1";
      else method+="w1i1";
      method+="c256ci1,1,1,1,1,1,2a";

      // Analyze the data
      const int NR=1<<12;
      int pt[256]={0};  // position of last occurrence
      int r[NR]={0};    // count repetition gaps of length r
      const unsigned char* p=in->data();
      if (level>0) {
        for (unsigned i=0; i<n; ++i) {
          const int k=i-pt[p[i]];
          if (k>0 && k<NR) ++r[k];
          pt[p[i]]=i;
        }
      }

      // Add periodic models
      int n1=n-r[1]-r[2]-r[3];
      for (int i=0; i<2; ++i) {
        int period=0;
        double score=0;
        int t=0;
        for (int j=5; j<NR && t<n1; ++j) {
          const double s=r[j]/(256.0+n1-t);
          if (s>score) score=s, period=j;
          t+=r[j];
        }
        if (period>4 && score>0.1) {
          method+="c0,0,"+itos(999+period)+",255i1";
          if (period<=255)
            method+="c0,"+itos(period)+"i1";
          n1-=r[period];
          r[period]=0;
        }
        else
          break;
      }
      method+="c0,2,0,255i1c0,3,0,0,255i1c0,4,0,0,0,255i1mm16ts19t0";
    }
  }

  // Compress
  std::string config;
  int args[9]={0};
  config=makeConfig(method.c_str(), args);
  assert(n<=(0x100000u<<args[0])-4096);
  libzpaq::Compressor co;
  co.setOutput(out);
#ifdef DEBUG
  co.setVerify(true);
#endif
  StringBuffer pcomp_cmd;
  co.writeTag();
  co.startBlock(config.c_str(), args, &pcomp_cmd);
  std::string cs=itos(n);
  if (comment) cs=cs+" "+comment;
  co.startSegment(filename, cs.c_str());
  if (args[1]>=1 && args[1]<=7 && args[1]!=4) {  // LZ77 or BWT
    LZBuffer lz(*in, args);
    co.setInput(&lz);
    co.compress();
  }
  else {  // compress with e8e9 or no preprocessing
    if (args[1]>=4 && args[1]<=7)
      e8e9(in->data(), in->size());
    co.setInput(in);
    co.compress();
  }
#ifdef DEBUG  // verify pre-post processing are inverses
  int64_t outsize;
  const char* sha1result=co.endSegmentChecksum(&outsize, dosha1);
  assert(sha1result);
  assert(sha1ptr);
  if (memcmp(sha1result, sha1ptr, 20)!=0)
    error("Pre/post-processor test failed");
#else
  co.endSegment(sha1ptr);
#endif
  co.endBlock();
}

}  // end namespace libzpaq


/////// main source
using std::string;
using std::vector;
using std::map;
///using std::min;
///using std::max;
using libzpaq::StringBuffer;

int unz(const char * archive,const char * key); // paranoid unzpaq 2.06

typedef void (*voidhelpfunction)(bool i_usage,bool i_example); 
typedef map<string, voidhelpfunction> 	MAPPAHELP;
typedef map<int, 	string> 			MAPPACOMMENTI;
typedef map<string, string> 			MAPPAFILEHASH;
typedef map<string, string> 			MAPPASTRINGASTRINGA;
typedef map<int64_t,string> 			MAPPAINT64STRING;

struct	hash_check
{
	int		algotype;
	int		checkedok;
	int		checkedfailed;
	int		checkednotfound;
	int64_t checksize;
	hash_check(): algotype(0), checkedok(0),checkedfailed(0),checkednotfound(0),checksize(0) {};
};
typedef map<string, hash_check> MAPPACHECK;


enum ealgoritmi		{ ALGO_SHA1,ALGO_CRC32C,ALGO_CRC32,ALGO_XXH3,ALGO_SHA256,ALGO_WYHASH,ALGO_XXHASH64,ALGO_BLAKE3,ALGO_WHIRLPOOL,ALGO_MD5,ALGO_SHA3,ALGO_NILSIMSA,ALGO_ENTROPY,ALGO_LAST };
typedef std::map<int,std::string> algoritmi;
const algoritmi::value_type rawData[] = 
{
   ///algoritmi::value_type(ALGO_SIZE,"Size"),
   algoritmi::value_type(ALGO_SHA1,"sha1"),
   algoritmi::value_type(ALGO_CRC32,"crc32"),
   algoritmi::value_type(ALGO_CRC32C,"crc32c"),
   algoritmi::value_type(ALGO_XXH3,"xxh3"),
   algoritmi::value_type(ALGO_XXHASH64,"xxhash"),
   algoritmi::value_type(ALGO_SHA256,"sha256"),
   algoritmi::value_type(ALGO_WYHASH,"wyhash"),
   algoritmi::value_type(ALGO_BLAKE3,"blake3"),
   algoritmi::value_type(ALGO_WHIRLPOOL,"whirlpool"),
   algoritmi::value_type(ALGO_MD5,"md5"),
   algoritmi::value_type(ALGO_MD5,"sha3"),
   algoritmi::value_type(ALGO_NILSIMSA,"nilsimsa"),
   algoritmi::value_type(ALGO_ENTROPY,"entropy"),
};
const int numElems = sizeof rawData / sizeof rawData[0];
algoritmi myalgoritmi(rawData, rawData + numElems);


////// calculate CRC32 by blocks and not by file. Need to sort before combine
////// list of CRC32 for every file  
struct s_crc32block
{
	string	filename;
	uint64_t crc32start;
	uint64_t crc32size;
	uint32_t crc32;
	s_crc32block(): crc32start(0),crc32size(0),crc32(0) {}
};


struct s_error
{
	int				counter;
	string			text;
	vector<string>	filenames;
	vector<int32_t>	attrs;
	s_error(): counter(0) {text="";}
};


typedef map<int,s_error> 	MAPPAERRORS;


/// Global variables
/// not in  for pthread that does not like class and methods

pthread_mutex_t g_mylock = PTHREAD_MUTEX_INITIALIZER;
vector<s_crc32block> 	g_crc32;
vector<uint64_t> 		g_arraybytescanned;
vector<uint64_t> 		g_arrayfilescanned;
MAPPAERRORS g_errors;

char 	command;             			// command 'a', 'x', or 'l'
string 	g_vss_shadow="";
string 	g_copy;
string 	g_freeze;
string 	g_exec_error;
string  g_exec_warn;
string 	g_exec_ok;
string 	g_exec_text;
string 	g_exec;
int 	g_255;
string 	g_output;
string 	g_sfx;
string 	g_sfxto;
string 	g_sfxnot;
string 	g_sfxonly;
string 	g_sfxuntil;
bool 	g_sfxflagall;
bool  	g_sfxflagforce;
string 	g_archive; /// archive writted by add
FILE* 	g_output_handle;
int64_t g_robocopy_check_sorgente;
int64_t g_robocopy_check_destinazione;
int64_t g_start			=0;  	// set to mtime() at start of main()
int64_t g_dimensione	=0;
int64_t g_scritti		=0;// note: not thread safe, but who care?
int64_t g_zerotime		=0;
int64_t g_bytescanned	=0;
int64_t g_filescanned	=0;
int64_t g_worked		=0;
int64_t g_fwritten		=0;
int64_t g_fexpected		=0;
int64_t g_ramdisksize	=0;
int32_t g_rd			=0;
int32_t g_rd_expected	=0;
int64_t g_startrd		=0;
int 	g_rd_ultimotempo=0;


uint64_t minsize;
uint64_t maxsize;
bool 	flagdonotforcexls;
bool 	flagfilelist;
bool 	flag715;
bool 	flagzero;
bool 	flagforcezfs;
bool	flagspace;
bool 	flagdebug;
bool	flagutc;
bool 	flagnoeta;
bool 	flagpakka;
bool 	flagvss;
bool 	flagverbose;
bool 	flagverify;
bool 	flagkill;
bool 	flagchecksum;					// get checksum 
bool 	flagutf;
bool 	flagflat;
bool 	flagparanoid;
bool 	flagfix255;
bool	flagfixcase;
#ifdef _WIN32
bool	flaglongpath;
bool 	flagfixreserved;
#endif
bool 	flagfixeml;
bool 	flagbarraod;
bool 	flagbarraon;
bool 	flagbarraos;
bool 	flagcrc32c;
bool	flagentropy;
bool 	flagsha1;
bool 	flagxxh3;
bool 	flagcrc32;
bool 	flagsha256;
bool 	flagwyhash; // future
bool 	flagxxhash64;
bool 	flagblake3;
bool 	flagwhirlpool;
bool 	flagmd5;
bool	flagnilsimsa;
bool 	flagsha3;
bool 	flagmm;
bool 	flagappend;
bool 	flaghw;
bool	flagdesc;
bool	flagnodedup;
bool	flagtar;
bool	flagramdisk;
bool	flagssd;
bool 	flagtouch;
bool	flagstat;
bool	flagfrugal;


int 	g_franzotype; 
string 	g_optional;

string orderby;
vector<string> g_theorderby;
MAPPACHECK	g_mychecks;




/*
	Section: hashers
*/

string	binarytohex(const unsigned char* i_risultato,const int i_lunghezza)
{
	/// slow, and dirty
	string risultato="";
	char myhex[4];
	
	if (i_risultato!=NULL)
		if (i_lunghezza>0)
			for (int j=0;j<i_lunghezza;j++)
			{
				sprintf(myhex,"%02X", (unsigned char)i_risultato[j]);
				risultato.push_back(myhex[0]);
				risultato.push_back(myhex[1]);
			}
	return risultato;
}


string decodefranzoffset(int franzotype)
{
	if (franzotype==FRANZO_NONE)
		return "NOTHING (LIKE 7.15)";
	if (franzotype==FRANZO_CRC_32) /// store only CRC-32
		return "CRC-32";
	if (franzotype==FRANZO_XXHASH64)
		return "XXHASH64+CRC-32";
	if (franzotype==FRANZO_SHA_1)
		return "SHA-1+CRC-32";
	if (franzotype==FRANZO_SHA_256)
		return "SHA-256+CRC-32";
	if (franzotype==FRANZO_XXH3)
		return "XXH3+CRC-32";
	if (franzotype==FRANZO_BLAKE3)
		return "BLAKE3+CRC-32";
	if (franzotype==FRANZO_SHA3)
		return "SHA-3+CRC-32";
	if (franzotype==FRANZO_MD5)
		return "MD5+CRC-32";
/*
	string temp="16839: franzotype strange "+franzotype;
	perror(temp.c_str());
	*/
	return "BYPASSWARNING";
}

string mygetalgo()
{
	if (flagblake3)
		return "BLAKE3";
	else
	if (flagxxhash64)
		return "XXHASH64";
	else
	if (flagwyhash)
		return "WYHASH";
	else
	if (flagcrc32)
		return "CRC-32";
	else
	if (flagentropy)
		return "ENTROPY";
	else
	if (flagcrc32c)
		return "CRC-32C";
	else
	if (flagxxh3)
		return "XXH3";
	else
	if (flagsha256)
		return "SHA-256";
	else
	if (flagwhirlpool)
		return "WHIRLPOOL";
	else
	if (flagmd5)
		return "MD5";
	else
	if (flagnilsimsa)
		return "NILSIMSA";
	else
	if (flagsha3)
		return "SHA-3";
	else
		return "SHA-1";
}
int flag2algo()
{
	if (flagblake3)
		return ALGO_BLAKE3;
	else
	if (flagxxhash64)
		return ALGO_XXHASH64;
	else
	if (flagwyhash)
		return ALGO_WYHASH;
	else
	if (flagwhirlpool)
		return ALGO_WHIRLPOOL;
	else
	if (flagmd5)
		return ALGO_MD5;
	else
	if (flagnilsimsa)
		return ALGO_NILSIMSA;
	else
	if (flagsha3)
		return ALGO_SHA3;
	else
	if (flagcrc32)
		return ALGO_CRC32;
	else
	if (flagcrc32c)
		return ALGO_CRC32C;
	else
	if (flagxxh3)
		return ALGO_XXH3;
	else
	if (flagsha256)
		return ALGO_SHA256;
	else
		return ALGO_SHA1;
}

string emptyalgo(const string i_string)
{
	if (i_string=="BLAKE3")
		return "AF1349B9F5F9A1A6A0404DEA36DCC9499BCB25C9ADC112B7CC9A93CAE41F3262";
	else
	if (i_string=="XXHASH64")
		return "EF46DB3751D8E999";
	else
	if (i_string=="WYHASH")
		return "";
	else
	if (i_string=="CRC-32")
		return "00000000";
	else
	if (i_string=="ENTROPY")
		return "00000000";
	else
	if (i_string=="CRC-32C")
		return "00000000";
	else
	if (i_string=="XXH3")
		return "99AA06D3014798D86001C324468D497F";
	else
	if (i_string=="SHA-256")
		return "E3B0C44298FC1C149AFBF4C8996FB92427AE41E4649B934CA495991B7852B855";
	else
	if (i_string=="WHIRLPOOL")
		return "19FA61D75522A4669B44E39C1D2E1726C530232130D407F89AFEE0964997F7A73E83BE698B288FEBCF88E3E03C4F0757EA8964E59B63D93708B138CC42A66EB3";
	else
	if (i_string=="MD5")
		return "D41D8CD98F00B204E9800998ECF8427E";
	else
	if (i_string=="NILSIMSA")
		return "VUOTO";
	else
	if (i_string=="SHA-3")
		return "A7FFC6F8BF1ED76651C14756A061D662F580FF4DE43B49FA82D80A4B80F8434A";
	else
		return "DA39A3EE5E6B4B0D3255BFEF95601890AFD80709"; //sha1
}


int string2algo(string i_string)
{
	if (i_string=="BLAKE3")
		return ALGO_BLAKE3;
	else
	if (i_string=="XXHASH64")
		return ALGO_XXHASH64;
	else
	if (i_string=="WYHASH")
		return ALGO_WYHASH;
	else
	if (i_string=="CRC-32")
		return ALGO_CRC32;
	else
	if (i_string=="ENTROPY")
		return ALGO_ENTROPY;
	else
	if (i_string=="CRC-32C")
		return ALGO_CRC32C;
	else
	if (i_string=="XXH3")
		return ALGO_XXH3;
	else
	if (i_string=="SHA-256")
		return ALGO_SHA256;
	else
	if (i_string=="WHIRLPOOL")
		return ALGO_WHIRLPOOL;
	else
	if (i_string=="MD5")
		return ALGO_MD5;
	else
	if (i_string=="NILSIMSA")
		return ALGO_NILSIMSA;
	else
	if (i_string=="SHA-3")
		return ALGO_SHA3;
	else
		return ALGO_SHA1;
}



/*
	Experimental "antihash" function: sort "similar" files
*/



/*!
 * The MIT License (MIT)
 * =====================
 *
 * Copyright 2017 Sepehr Laal
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
*/


/*!
 * @fn nilsimsa_compute
 * @brief computes the Nilsimsa hash of the given data.
 * @arg data [IN] input data byte (char) array
 * @arg size [IN] input data size
 * @arg out [OUT] output hash string (must be allocated 
 * to hold exactly 64 characters + 1 null character. So
 * total of 65 characters e.g. char hash[65])
 */
void nilsimsa_compute(const char* data, int size, char* out);

/*!
 * @fn nilsimsa_compare
 * @brief compares two given Nilsimsa hashes
 * @returns A score between -127 and 128 where -127 means
 * completely uncorrelated data and 128 means same data.
 * @arg lhs [IN] left hand side hash
 * @arg rhs [IN] right hand side hash
 */
int nilsimsa_compare(const char* lhs, const char* rhs);

static int __score(int num);
static int __tran3(int a, int b, int c, int n);
static int __hexchar_to_int(char digit);
static const char* __int_to_hexchar(int num);

#define ACCUM_LENGTH 256
#define DIGEST_LENGTH 32
#define WINDOW_LENGTH 4 

void nilsimsa_compute(const char* data, int n, char* out)
{
    int accum[ACCUM_LENGTH] = { 0 };
    int digest[DIGEST_LENGTH] = { 0 };
    int window[WINDOW_LENGTH] = { -1, -1, -1, -1 };

    for (int i = 0; i < n; ++i)
    {
        int ch = data[i] & 0xFF;

        if (window[1] > -1)
        {
            accum[__tran3(ch, window[0], window[1], 0)] += 1;
        }

        if (window[2] > -1)
        {
            accum[__tran3(ch, window[0], window[2], 1)] += 1;
            accum[__tran3(ch, window[1], window[2], 2)] += 1;
        }

        if (window[3] > -1)
        {
            accum[__tran3(ch, window[0], window[3], 3)] += 1;
            accum[__tran3(ch, window[1], window[3], 4)] += 1;
            accum[__tran3(ch, window[2], window[3], 5)] += 1;
            accum[__tran3(window[3], window[0], ch, 6)] += 1;
            accum[__tran3(window[3], window[2], ch, 7)] += 1;
        }

        window[3] = window[2];
        window[2] = window[1];
        window[1] = window[0];
        window[0] = ch;
    }

    int total = 0;

    if (n == 3)
        total = 1;
    else if (n == 4)
        total = 4;
    else if (n > 4)
        total = 8 * n - 28;

    int threshold = total / ACCUM_LENGTH;

    for (int i = 0; i < ACCUM_LENGTH; i++)
        if (accum[i] > threshold)
            digest[i >> 3] += 1 << (i & 7);

    int rev_index = 0;

    for (int i = 0; i < DIGEST_LENGTH; ++i)
    {
        rev_index = DIGEST_LENGTH - i - 1;
        out[2*i  ] = __int_to_hexchar(digest[rev_index])[0];
        out[2*i+1] = __int_to_hexchar(digest[rev_index])[1];
    }

    out[2 * DIGEST_LENGTH] = '\0';
}

int nilsimsa_compare(const char* hash1, const char* hash2)
{
    int digest1[DIGEST_LENGTH] = { 0 };
    int digest2[DIGEST_LENGTH] = { 0 };

    for (int i = 0; i < DIGEST_LENGTH; ++i)
    {
        digest1[i] = (__hexchar_to_int(hash1[2 * i]) << 4) + __hexchar_to_int(hash1[2 * i + 1]);
        digest2[i] = (__hexchar_to_int(hash2[2 * i]) << 4) + __hexchar_to_int(hash2[2 * i + 1]);
    }

    int bits = 0;
    for (int i = 0; i < DIGEST_LENGTH; i++)
        bits += __score(255 & (digest1[i] ^ digest2[i]));
    return 128 - bits;
}

//////////////////////////////////////////////////////////////////////////
// implementation detail

// This is a precomputed constant for the standard Nilsimsa "53"-based transition table.
static const int __TRAN53[] =
{
    0x02, 0xD6, 0x9E, 0x6F, 0xF9, 0x1D, 0x04, 0xAB, 0xD0, 0x22, 0x16, 0x1F, 0xD8, 0x73, 0xA1, 0xAC,
    0x3B, 0x70, 0x62, 0x96, 0x1E, 0x6E, 0x8F, 0x39, 0x9D, 0x05, 0x14, 0x4A, 0xA6, 0xBE, 0xAE, 0x0E,
    0xCF, 0xB9, 0x9C, 0x9A, 0xC7, 0x68, 0x13, 0xE1, 0x2D, 0xA4, 0xEB, 0x51, 0x8D, 0x64, 0x6B, 0x50,
    0x23, 0x80, 0x03, 0x41, 0xEC, 0xBB, 0x71, 0xCC, 0x7A, 0x86, 0x7F, 0x98, 0xF2, 0x36, 0x5E, 0xEE,
    0x8E, 0xCE, 0x4F, 0xB8, 0x32, 0xB6, 0x5F, 0x59, 0xDC, 0x1B, 0x31, 0x4C, 0x7B, 0xF0, 0x63, 0x01,
    0x6C, 0xBA, 0x07, 0xE8, 0x12, 0x77, 0x49, 0x3C, 0xDA, 0x46, 0xFE, 0x2F, 0x79, 0x1C, 0x9B, 0x30,
    0xE3, 0x00, 0x06, 0x7E, 0x2E, 0x0F, 0x38, 0x33, 0x21, 0xAD, 0xA5, 0x54, 0xCA, 0xA7, 0x29, 0xFC,
    0x5A, 0x47, 0x69, 0x7D, 0xC5, 0x95, 0xB5, 0xF4, 0x0B, 0x90, 0xA3, 0x81, 0x6D, 0x25, 0x55, 0x35,
    0xF5, 0x75, 0x74, 0x0A, 0x26, 0xBF, 0x19, 0x5C, 0x1A, 0xC6, 0xFF, 0x99, 0x5D, 0x84, 0xAA, 0x66,
    0x3E, 0xAF, 0x78, 0xB3, 0x20, 0x43, 0xC1, 0xED, 0x24, 0xEA, 0xE6, 0x3F, 0x18, 0xF3, 0xA0, 0x42,
    0x57, 0x08, 0x53, 0x60, 0xC3, 0xC0, 0x83, 0x40, 0x82, 0xD7, 0x09, 0xBD, 0x44, 0x2A, 0x67, 0xA8,
    0x93, 0xE0, 0xC2, 0x56, 0x9F, 0xD9, 0xDD, 0x85, 0x15, 0xB4, 0x8A, 0x27, 0x28, 0x92, 0x76, 0xDE,
    0xEF, 0xF8, 0xB2, 0xB7, 0xC9, 0x3D, 0x45, 0x94, 0x4B, 0x11, 0x0D, 0x65, 0xD5, 0x34, 0x8B, 0x91,
    0x0C, 0xFA, 0x87, 0xE9, 0x7C, 0x5B, 0xB1, 0x4D, 0xE5, 0xD4, 0xCB, 0x10, 0xA2, 0x17, 0x89, 0xBC,
    0xDB, 0xB0, 0xE2, 0x97, 0x88, 0x52, 0xF7, 0x48, 0xD3, 0x61, 0x2C, 0x3A, 0x2B, 0xD1, 0x8C, 0xFB,
    0xF1, 0xCD, 0xE4, 0x6A, 0xE7, 0xA9, 0xFD, 0xC4, 0x37, 0xC8, 0xD2, 0xF6, 0xDF, 0x58, 0x72, 0x4E
};

/*
* This is an optimization table for doing bitwise vector comparisons. The
* population count of x, POPC[x], is the number of 1's in the binary
* representation of x. The bitwise XOR(a, b) applied within this table,
* POPC[a ^ b], is the Hamming distance between a and b. For more
* information, see http://en.wikipedia.org/wiki/Hamming_weight.
*/
static const int __POPC[] =
{
    0x00, 0x01, 0x01, 0x02, 0x01, 0x02, 0x02, 0x03, 0x01, 0x02, 0x02, 0x03, 0x02, 0x03, 0x03, 0x04,
    0x01, 0x02, 0x02, 0x03, 0x02, 0x03, 0x03, 0x04, 0x02, 0x03, 0x03, 0x04, 0x03, 0x04, 0x04, 0x05,
    0x01, 0x02, 0x02, 0x03, 0x02, 0x03, 0x03, 0x04, 0x02, 0x03, 0x03, 0x04, 0x03, 0x04, 0x04, 0x05,
    0x02, 0x03, 0x03, 0x04, 0x03, 0x04, 0x04, 0x05, 0x03, 0x04, 0x04, 0x05, 0x04, 0x05, 0x05, 0x06,
    0x01, 0x02, 0x02, 0x03, 0x02, 0x03, 0x03, 0x04, 0x02, 0x03, 0x03, 0x04, 0x03, 0x04, 0x04, 0x05,
    0x02, 0x03, 0x03, 0x04, 0x03, 0x04, 0x04, 0x05, 0x03, 0x04, 0x04, 0x05, 0x04, 0x05, 0x05, 0x06,
    0x02, 0x03, 0x03, 0x04, 0x03, 0x04, 0x04, 0x05, 0x03, 0x04, 0x04, 0x05, 0x04, 0x05, 0x05, 0x06,
    0x03, 0x04, 0x04, 0x05, 0x04, 0x05, 0x05, 0x06, 0x04, 0x05, 0x05, 0x06, 0x05, 0x06, 0x06, 0x07,
    0x01, 0x02, 0x02, 0x03, 0x02, 0x03, 0x03, 0x04, 0x02, 0x03, 0x03, 0x04, 0x03, 0x04, 0x04, 0x05,
    0x02, 0x03, 0x03, 0x04, 0x03, 0x04, 0x04, 0x05, 0x03, 0x04, 0x04, 0x05, 0x04, 0x05, 0x05, 0x06,
    0x02, 0x03, 0x03, 0x04, 0x03, 0x04, 0x04, 0x05, 0x03, 0x04, 0x04, 0x05, 0x04, 0x05, 0x05, 0x06,
    0x03, 0x04, 0x04, 0x05, 0x04, 0x05, 0x05, 0x06, 0x04, 0x05, 0x05, 0x06, 0x05, 0x06, 0x06, 0x07,
    0x02, 0x03, 0x03, 0x04, 0x03, 0x04, 0x04, 0x05, 0x03, 0x04, 0x04, 0x05, 0x04, 0x05, 0x05, 0x06,
    0x03, 0x04, 0x04, 0x05, 0x04, 0x05, 0x05, 0x06, 0x04, 0x05, 0x05, 0x06, 0x05, 0x06, 0x06, 0x07,
    0x03, 0x04, 0x04, 0x05, 0x04, 0x05, 0x05, 0x06, 0x04, 0x05, 0x05, 0x06, 0x05, 0x06, 0x06, 0x07,
    0x04, 0x05, 0x05, 0x06, 0x05, 0x06, 0x06, 0x07, 0x05, 0x06, 0x06, 0x07, 0x06, 0x07, 0x07, 0x08
};

/*
* Used to convert integers to 1-byte hex strings
* Integers in between the range of 0 and 256.
*/
static const char* __HEX_BYTE_DIGITS[] =
{
    "00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0A", "0B", "0C", "0D", "0E", "0F",
    "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1A", "1B", "1C", "1D", "1E", "1F",
    "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2A", "2B", "2C", "2D", "2E", "2F",
    "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3A", "3B", "3C", "3D", "3E", "3F",
    "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4A", "4B", "4C", "4D", "4E", "4F",
    "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5A", "5B", "5C", "5D", "5E", "5F",
    "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6A", "6B", "6C", "6D", "6E", "6F",
    "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7A", "7B", "7C", "7D", "7E", "7F",
    "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8A", "8B", "8C", "8D", "8E", "8F",
    "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9A", "9B", "9C", "9D", "9E", "9F",
    "A0", "A1", "A2", "A3", "A4", "A5", "A6", "A7", "A8", "A9", "AA", "AB", "AC", "AD", "AE", "AF",
    "B0", "B1", "B2", "B3", "B4", "B5", "B6", "B7", "B8", "B9", "BA", "BB", "BC", "BD", "BE", "BF",
    "C0", "C1", "C2", "C3", "C4", "C5", "C6", "C7", "C8", "C9", "CA", "CB", "CC", "CD", "CE", "CF",
    "D0", "D1", "D2", "D3", "D4", "D5", "D6", "D7", "D8", "D9", "DA", "DB", "DC", "DD", "DE", "DF",
    "E0", "E1", "E2", "E3", "E4", "E5", "E6", "E7", "E8", "E9", "EA", "EB", "EC", "ED", "EE", "EF",
    "F0", "F1", "F2", "F3", "F4", "F5", "F6", "F7", "F8", "F9", "FA", "FB", "FC", "FD", "FE", "FF"
};

static int __tran3(int a, int b, int c, int n)
{
    return (((__TRAN53[(a + n) & 255] ^ __TRAN53[b] * (n + n + 1)) + __TRAN53[c ^ __TRAN53[n]]) & 255);
}

static int __hexchar_to_int(char digit)
{
    return ((digit | 432) * 239217992 & 0xffffffff) >> 28;
}

static const char* __int_to_hexchar(int num)
{
    return __HEX_BYTE_DIGITS[num];
}

static int __score(int num)
{
    return __POPC[num];
}


/*
	This implementation is a minor reworked of
	https://github.com/System-Glitch/SHA256
	Writing style very similar to mine, so it's no surprise that I liked it.
	
	Speed test against libzpaq (on my PC) just about 2% faster
*/

/*macos*/
static uint32_t Kappa[] = {
		0x428a2f98,0x71374491,0xb5c0fbcf,0xe9b5dba5,
		0x3956c25b,0x59f111f1,0x923f82a4,0xab1c5ed5,
		0xd807aa98,0x12835b01,0x243185be,0x550c7dc3,
		0x72be5d74,0x80deb1fe,0x9bdc06a7,0xc19bf174,
		0xe49b69c1,0xefbe4786,0x0fc19dc6,0x240ca1cc,
		0x2de92c6f,0x4a7484aa,0x5cb0a9dc,0x76f988da,
		0x983e5152,0xa831c66d,0xb00327c8,0xbf597fc7,
		0xc6e00bf3,0xd5a79147,0x06ca6351,0x14292967,
		0x27b70a85,0x2e1b2138,0x4d2c6dfc,0x53380d13,
		0x650a7354,0x766a0abb,0x81c2c92e,0x92722c85,
		0xa2bfe8a1,0xa81a664b,0xc24b8b70,0xc76c51a3,
		0xd192e819,0xd6990624,0xf40e3585,0x106aa070,
		0x19a4c116,0x1e376c08,0x2748774c,0x34b0bcb5,
		0x391c0cb3,0x4ed8aa4a,0x5b9cca4f,0x682e6ff3,
		0x748f82ee,0x78a5636f,0x84c87814,0x8cc70208,
		0x90befffa,0xa4506ceb,0xbef9a3f7,0xc67178f2
	};

class franzSHA256 {

public:
	franzSHA256();
	void update(const uint8_t * data, size_t length);
	std::string gethex();

private:
	uint8_t  m_data[64];
	uint32_t m_blocklen;
	uint64_t m_bitlen;
	uint32_t m_state[8]; //A, B, C, D, E, F, G, H


	static uint32_t rotr(uint32_t x, uint32_t n);
	static uint32_t choose(uint32_t e, uint32_t f, uint32_t g);
	static uint32_t majority(uint32_t a, uint32_t b, uint32_t c);
	static uint32_t sig0(uint32_t x);
	static uint32_t sig1(uint32_t x);
	void transform();
	void pad();
	void revert(uint8_t * hash);
};

franzSHA256::franzSHA256(): m_blocklen(0), m_bitlen(0) {
	m_state[0] = 0x6a09e667;
	m_state[1] = 0xbb67ae85;
	m_state[2] = 0x3c6ef372;
	m_state[3] = 0xa54ff53a;
	m_state[4] = 0x510e527f;
	m_state[5] = 0x9b05688c;
	m_state[6] = 0x1f83d9ab;
	m_state[7] = 0x5be0cd19;
}

void franzSHA256::update(const uint8_t * data, size_t length) {
	for (size_t i = 0 ; i < length ; i++) {
		m_data[m_blocklen++] = data[i];
		if (m_blocklen == 64) {
			transform();

			// End of the block
			m_bitlen += 512;
			m_blocklen = 0;
		}
	}
}

uint32_t franzSHA256::rotr(uint32_t x, uint32_t n) {
	return (x >> n) | (x << (32 - n));
}

uint32_t franzSHA256::choose(uint32_t e, uint32_t f, uint32_t g) {
	return (e & f) ^ (~e & g);
}

uint32_t franzSHA256::majority(uint32_t a, uint32_t b, uint32_t c) {
	return (a & (b | c)) | (b & c);
}

uint32_t franzSHA256::sig0(uint32_t x) {
	return franzSHA256::rotr(x, 7) ^ franzSHA256::rotr(x, 18) ^ (x >> 3);
}

uint32_t franzSHA256::sig1(uint32_t x) {
	return franzSHA256::rotr(x, 17) ^ franzSHA256::rotr(x, 19) ^ (x >> 10);
}

void franzSHA256::transform() {
	uint32_t maj, xorA, ch, xorE, sum, newA, newE, m[64];
	uint32_t state[8];

	for (uint8_t i = 0, j = 0; i < 16; i++, j += 4) { // Split data in 32 bit blocks for the 16 first words
		m[i] = (m_data[j] << 24) | (m_data[j + 1] << 16) | (m_data[j + 2] << 8) | (m_data[j + 3]);
	}

	for (uint8_t k = 16 ; k < 64; k++) { // Remaining 48 blocks
		m[k] = franzSHA256::sig1(m[k - 2]) + m[k - 7] + franzSHA256::sig0(m[k - 15]) + m[k - 16];
	}

	for(uint8_t i = 0 ; i < 8 ; i++) {
		state[i] = m_state[i];
	}

	for (uint8_t i = 0; i < 64; i++) {
		maj   = franzSHA256::majority(state[0], state[1], state[2]);
		xorA  = franzSHA256::rotr(state[0], 2) ^ franzSHA256::rotr(state[0], 13) ^ franzSHA256::rotr(state[0], 22);

		ch = choose(state[4], state[5], state[6]);

		xorE  = franzSHA256::rotr(state[4], 6) ^ franzSHA256::rotr(state[4], 11) ^ franzSHA256::rotr(state[4], 25);

		sum  = m[i] + Kappa[i] + state[7] + ch + xorE;
		newA = xorA + maj + sum;
		newE = state[3] + sum;

		state[7] = state[6];
		state[6] = state[5];
		state[5] = state[4];
		state[4] = newE;
		state[3] = state[2];
		state[2] = state[1];
		state[1] = state[0];
		state[0] = newA;
	}

	for(uint8_t i = 0 ; i < 8 ; i++) {
		m_state[i] += state[i];
	}
}

void franzSHA256::pad() 
{

	uint64_t i = m_blocklen;
	uint8_t end = m_blocklen < 56 ? 56 : 64;

	m_data[i++] = 0x80; // Append a bit 1
	while (i < end) {
		m_data[i++] = 0x00; // Pad with zeros
	}

	if(m_blocklen >= 56) {
		transform();
		memset(m_data, 0, 56);
	}

	// Append to the padding the total message's length in bits and transform.
	m_bitlen += m_blocklen * 8;
	m_data[63] = m_bitlen;
	m_data[62] = m_bitlen >> 8;
	m_data[61] = m_bitlen >> 16;
	m_data[60] = m_bitlen >> 24;
	m_data[59] = m_bitlen >> 32;
	m_data[58] = m_bitlen >> 40;
	m_data[57] = m_bitlen >> 48;
	m_data[56] = m_bitlen >> 56;
	transform();
}

void franzSHA256::revert(uint8_t * hash) 
{
	// SHA uses big endian byte ordering
	// Revert all bytes
	for (uint8_t i = 0 ; i < 4 ; i++) {
		for(uint8_t j = 0 ; j < 8 ; j++) {
			hash[i + (j * 4)] = (m_state[j] >> (24 - i * 8)) & 0x000000ff;
		}
	}
}

std::string franzSHA256::gethex()
{
/// less include, smaller executable. Dirty, but quick and small
	uint8_t * hash = new uint8_t[32];
	pad();
	revert(hash);
	string risultato=binarytohex((const unsigned char*)hash,32);
	delete[] hash;
	return risultato;
}




// //////////////////////////////////////////////////////////
// sha3.h
// Copyright (c) 2014,2015 Stephan Brumme. All rights reserved.
// see http://create.stephan-brumme.com/disclaimer.html
//

class SHA3
{
public:
  enum Bits { Bits224 = 224, Bits256 = 256, Bits384 = 384, Bits512 = 512 };
  explicit SHA3(Bits bits = Bits256);
  void add(const void* data, size_t numBytes);
  std::string getHash();
  void reset();

private:
  void processBlock(const void* data);
  void processBuffer();

  /// 1600 bits, stored as 25x64 bit, BlockSize is no more than 1152 bits (Keccak224)
  enum { StateSize    = 1600 / (8 * 8),
         MaxBlockSize =  200 - 2 * (224 / 8) };

  /// hash
  uint64_t m_hash[StateSize];
  /// size of processed data in bytes
  uint64_t m_numBytes;
  /// block size (less or equal to MaxBlockSize)
  size_t   m_blockSize;
  /// valid bytes in m_buffer
  size_t   m_bufferSize;
  /// bytes not processed yet
  uint8_t  m_buffer[MaxBlockSize];
  /// variant
  Bits     m_bits;
};

SHA3::SHA3(Bits bits)
: m_blockSize(200 - 2 * (bits / 8)),
  m_bits(bits)
{
  reset();
}
void SHA3::reset()
{
  for (size_t i = 0; i < StateSize; i++)
    m_hash[i] = 0;

  m_numBytes   = 0;
  m_bufferSize = 0;
}

namespace
{
  const unsigned int Rounds = 24;
  const uint64_t XorMasks[Rounds] =
  {
    0x0000000000000001ULL, 0x0000000000008082ULL, 0x800000000000808aULL,
    0x8000000080008000ULL, 0x000000000000808bULL, 0x0000000080000001ULL,
    0x8000000080008081ULL, 0x8000000000008009ULL, 0x000000000000008aULL,
    0x0000000000000088ULL, 0x0000000080008009ULL, 0x000000008000000aULL,
    0x000000008000808bULL, 0x800000000000008bULL, 0x8000000000008089ULL,
    0x8000000000008003ULL, 0x8000000000008002ULL, 0x8000000000000080ULL,
    0x000000000000800aULL, 0x800000008000000aULL, 0x8000000080008081ULL,
    0x8000000000008080ULL, 0x0000000080000001ULL, 0x8000000080008008ULL
  };

  inline uint64_t rotateLeft(uint64_t x, uint8_t numBits)
  {
    return (x << numBits) | (x >> (64 - numBits));
  }

  /// convert litte vs big endian
  inline uint64_t swap(uint64_t x)
  {
#if defined(__GNUC__) || defined(__clang__)
    return __builtin_bswap64(x);
#endif
#ifdef _MSC_VER
    return _byteswap_uint64(x);
#endif

    return  (x >> 56) |
           ((x >> 40) & 0x000000000000FF00ULL) |
           ((x >> 24) & 0x0000000000FF0000ULL) |
           ((x >>  8) & 0x00000000FF000000ULL) |
           ((x <<  8) & 0x000000FF00000000ULL) |
           ((x << 24) & 0x0000FF0000000000ULL) |
           ((x << 40) & 0x00FF000000000000ULL) |
            (x << 56);
  }
  unsigned int mod5(unsigned int x)
  {
    if (x < 5)
      return x;

    return x - 5;
  }
}


void SHA3::processBlock(const void* data)
{
#if defined(__BYTE_ORDER) && (__BYTE_ORDER != 0) && (__BYTE_ORDER == __BIG_ENDIAN)
#define LITTLEENDIAN(x) swap(x)
#else
#define LITTLEENDIAN(x) (x)
#endif

  const uint64_t* data64 = (const uint64_t*) data;
  for (unsigned int i = 0; i < m_blockSize / 8; i++)
    m_hash[i] ^= LITTLEENDIAN(data64[i]);

  for (unsigned int round = 0; round < Rounds; round++)
  {
    uint64_t coefficients[5];
    for (unsigned int i = 0; i < 5; i++)
      coefficients[i] = m_hash[i] ^ m_hash[i + 5] ^ m_hash[i + 10] ^ m_hash[i + 15] ^ m_hash[i + 20];

    for (unsigned int i = 0; i < 5; i++)
    {
      uint64_t one = coefficients[mod5(i + 4)] ^ rotateLeft(coefficients[mod5(i + 1)], 1);
      m_hash[i     ] ^= one;
      m_hash[i +  5] ^= one;
      m_hash[i + 10] ^= one;
      m_hash[i + 15] ^= one;
      m_hash[i + 20] ^= one;
    }

    uint64_t one;

    uint64_t last = m_hash[1];
    one = m_hash[10]; m_hash[10] = rotateLeft(last,  1); last = one;
    one = m_hash[ 7]; m_hash[ 7] = rotateLeft(last,  3); last = one;
    one = m_hash[11]; m_hash[11] = rotateLeft(last,  6); last = one;
    one = m_hash[17]; m_hash[17] = rotateLeft(last, 10); last = one;
    one = m_hash[18]; m_hash[18] = rotateLeft(last, 15); last = one;
    one = m_hash[ 3]; m_hash[ 3] = rotateLeft(last, 21); last = one;
    one = m_hash[ 5]; m_hash[ 5] = rotateLeft(last, 28); last = one;
    one = m_hash[16]; m_hash[16] = rotateLeft(last, 36); last = one;
    one = m_hash[ 8]; m_hash[ 8] = rotateLeft(last, 45); last = one;
    one = m_hash[21]; m_hash[21] = rotateLeft(last, 55); last = one;
    one = m_hash[24]; m_hash[24] = rotateLeft(last,  2); last = one;
    one = m_hash[ 4]; m_hash[ 4] = rotateLeft(last, 14); last = one;
    one = m_hash[15]; m_hash[15] = rotateLeft(last, 27); last = one;
    one = m_hash[23]; m_hash[23] = rotateLeft(last, 41); last = one;
    one = m_hash[19]; m_hash[19] = rotateLeft(last, 56); last = one;
    one = m_hash[13]; m_hash[13] = rotateLeft(last,  8); last = one;
    one = m_hash[12]; m_hash[12] = rotateLeft(last, 25); last = one;
    one = m_hash[ 2]; m_hash[ 2] = rotateLeft(last, 43); last = one;
    one = m_hash[20]; m_hash[20] = rotateLeft(last, 62); last = one;
    one = m_hash[14]; m_hash[14] = rotateLeft(last, 18); last = one;
    one = m_hash[22]; m_hash[22] = rotateLeft(last, 39); last = one;
    one = m_hash[ 9]; m_hash[ 9] = rotateLeft(last, 61); last = one;
    one = m_hash[ 6]; m_hash[ 6] = rotateLeft(last, 20); last = one;
                      m_hash[ 1] = rotateLeft(last, 44);

    for (unsigned int j = 0; j < StateSize; j += 5)
    {
      uint64_t one = m_hash[j];
      uint64_t two = m_hash[j + 1];

      m_hash[j]     ^= m_hash[j + 2] & ~two;
      m_hash[j + 1] ^= m_hash[j + 3] & ~m_hash[j + 2];
      m_hash[j + 2] ^= m_hash[j + 4] & ~m_hash[j + 3];
      m_hash[j + 3] ^=      one      & ~m_hash[j + 4];
      m_hash[j + 4] ^=      two      & ~one;
    }

    m_hash[0] ^= XorMasks[round];
  }
}


void SHA3::add(const void* data, size_t numBytes)
{
  const uint8_t* current = (const uint8_t*) data;

  // copy data to buffer
  if (m_bufferSize > 0)
    while (numBytes > 0 && m_bufferSize < m_blockSize)
    {
      m_buffer[m_bufferSize++] = *current++;
      numBytes--;
    }

  // full buffer
  if (m_bufferSize == m_blockSize)
  {
    processBlock((void*)m_buffer);
    m_numBytes  += m_blockSize;
    m_bufferSize = 0;
  }

  // no more data ?
  if (numBytes == 0)
    return;

  // process full blocks
  while (numBytes >= m_blockSize)
  {
    processBlock(current);
    current    += m_blockSize;
    m_numBytes += m_blockSize;
    numBytes   -= m_blockSize;
  }

  // keep remaining bytes in buffer
  while (numBytes > 0)
  {
    m_buffer[m_bufferSize++] = *current++;
    numBytes--;
  }
}

void SHA3::processBuffer()
{
  // add padding
  size_t offset = m_bufferSize;
  // add a "1" byte
  m_buffer[offset++] = 0x06;
  // fill with zeros
  while (offset < m_blockSize)
    m_buffer[offset++] = 0;

  // and add a single set bit
  m_buffer[offset - 1] |= 0x80;

  processBlock(m_buffer);
}

std::string SHA3::getHash()
{
  // save hash state
  uint64_t oldHash[StateSize];
  for (unsigned int i = 0; i < StateSize; i++)
    oldHash[i] = m_hash[i];

  processBuffer();

  static const char dec2hex[16 + 1] = "0123456789ABCDEF";

  // number of significant elements in hash (uint64_t)
  unsigned int hashLength = m_bits / 64;

  std::string result;
  result.reserve(m_bits / 4);
  for (unsigned int i = 0; i < hashLength; i++)
    for (unsigned int j = 0; j < 8; j++) // 64 bits => 8 bytes
    {
      // convert a byte to hex
      unsigned char oneByte = (unsigned char) (m_hash[i] >> (8 * j));
      result += dec2hex[oneByte >> 4];
      result += dec2hex[oneByte & 15];
    }

  // SHA3-224's last entry in m_hash provides only 32 bits instead of 64 bits
  unsigned int remainder = m_bits - hashLength * 64;
  unsigned int processed = 0;
  while (processed < remainder)
  {
    // convert a byte to hex
    unsigned char oneByte = (unsigned char) (m_hash[hashLength] >> processed);
    result += dec2hex[oneByte >> 4];
    result += dec2hex[oneByte & 15];

    processed += 8;
  }

  // restore state
  for (unsigned int i = 0; i < StateSize; i++)
    m_hash[i] = oldHash[i];

  return result;
}





// //////////////////////////////////////////////////////////
// md5.h
// Copyright (c) 2014 Stephan Brumme. All rights reserved.
// see http://create.stephan-brumme.com/disclaimer.html
//



/** Usage:
    MD5 md5;
    while (more data available)
      md5.add(pointer to fresh data, number of new bytes);
    std::string myHash3 = md5.getHash();
  */
class MD5
{
public:
  /// split into 64 byte blocks (=> 512 bits), hash is 16 bytes long
  enum { BlockSize = 512 / 8, HashBytes = 16 };

  MD5();

  void add(const void* data, size_t numBytes);
  std::string getHash();
  void getHash(unsigned char buffer[HashBytes]);
  void reset();

private:
  void processBlock(const void* data);
  void processBuffer();
  /// size of processed data in bytes
  uint64_t m_numBytes;
  /// valid bytes in m_buffer
  size_t   m_bufferSize;
  /// bytes not processed yet
  uint8_t  m_buffer[BlockSize];

  enum { HashValues = HashBytes / 4 };
  /// hash, stored as integers
  uint32_t m_hash[HashValues];
};



/// same as reset()
MD5::MD5()
{
  reset();
}


/// restart
void MD5::reset()
{
  m_numBytes   = 0;
  m_bufferSize = 0;

  // according to RFC 1321
  m_hash[0] = 0x67452301;
  m_hash[1] = 0xefcdab89;
  m_hash[2] = 0x98badcfe;
  m_hash[3] = 0x10325476;
}


namespace
{
  // mix functions for processBlock()
  inline uint32_t f1(uint32_t b, uint32_t c, uint32_t d)
  {
    return d ^ (b & (c ^ d)); // original: f = (b & c) | ((~b) & d);
  }

  inline uint32_t f2(uint32_t b, uint32_t c, uint32_t d)
  {
    return c ^ (d & (b ^ c)); // original: f = (b & d) | (c & (~d));
  }

  inline uint32_t f3(uint32_t b, uint32_t c, uint32_t d)
  {
    return b ^ c ^ d;
  }

  inline uint32_t f4(uint32_t b, uint32_t c, uint32_t d)
  {
    return c ^ (b | ~d);
  }

  inline uint32_t rotate(uint32_t a, uint32_t c)
  {
    return (a << c) | (a >> (32 - c));
  }

#if defined(__BYTE_ORDER) && (__BYTE_ORDER != 0) && (__BYTE_ORDER == __BIG_ENDIAN)
  inline uint32_t swap(uint32_t x)
  {
#if defined(__GNUC__) || defined(__clang__)
    return __builtin_bswap32(x);
#endif
#ifdef MSC_VER
    return _byteswap_ulong(x);
#endif

    return (x >> 24) |
          ((x >>  8) & 0x0000FF00) |
          ((x <<  8) & 0x00FF0000) |
           (x << 24);
  }
#endif
}


/// process 64 bytes
void MD5::processBlock(const void* data)
{
  // get last hash
  uint32_t a = m_hash[0];
  uint32_t b = m_hash[1];
  uint32_t c = m_hash[2];
  uint32_t d = m_hash[3];

  // data represented as 16x 32-bit words
  const uint32_t* words = (uint32_t*) data;

  // computations are little endian, swap data if necessary
#if defined(__BYTE_ORDER) && (__BYTE_ORDER != 0) && (__BYTE_ORDER == __BIG_ENDIAN)
#define LITTLEENDIAN(x) swap(x)
#else
#define LITTLEENDIAN(x) (x)
#endif

  // first round
  uint32_t word0  = LITTLEENDIAN(words[ 0]);
  a = rotate(a + f1(b,c,d) + word0  + 0xd76aa478,  7) + b;
  uint32_t word1  = LITTLEENDIAN(words[ 1]);
  d = rotate(d + f1(a,b,c) + word1  + 0xe8c7b756, 12) + a;
  uint32_t word2  = LITTLEENDIAN(words[ 2]);
  c = rotate(c + f1(d,a,b) + word2  + 0x242070db, 17) + d;
  uint32_t word3  = LITTLEENDIAN(words[ 3]);
  b = rotate(b + f1(c,d,a) + word3  + 0xc1bdceee, 22) + c;

  uint32_t word4  = LITTLEENDIAN(words[ 4]);
  a = rotate(a + f1(b,c,d) + word4  + 0xf57c0faf,  7) + b;
  uint32_t word5  = LITTLEENDIAN(words[ 5]);
  d = rotate(d + f1(a,b,c) + word5  + 0x4787c62a, 12) + a;
  uint32_t word6  = LITTLEENDIAN(words[ 6]);
  c = rotate(c + f1(d,a,b) + word6  + 0xa8304613, 17) + d;
  uint32_t word7  = LITTLEENDIAN(words[ 7]);
  b = rotate(b + f1(c,d,a) + word7  + 0xfd469501, 22) + c;

  uint32_t word8  = LITTLEENDIAN(words[ 8]);
  a = rotate(a + f1(b,c,d) + word8  + 0x698098d8,  7) + b;
  uint32_t word9  = LITTLEENDIAN(words[ 9]);
  d = rotate(d + f1(a,b,c) + word9  + 0x8b44f7af, 12) + a;
  uint32_t word10 = LITTLEENDIAN(words[10]);
  c = rotate(c + f1(d,a,b) + word10 + 0xffff5bb1, 17) + d;
  uint32_t word11 = LITTLEENDIAN(words[11]);
  b = rotate(b + f1(c,d,a) + word11 + 0x895cd7be, 22) + c;

  uint32_t word12 = LITTLEENDIAN(words[12]);
  a = rotate(a + f1(b,c,d) + word12 + 0x6b901122,  7) + b;
  uint32_t word13 = LITTLEENDIAN(words[13]);
  d = rotate(d + f1(a,b,c) + word13 + 0xfd987193, 12) + a;
  uint32_t word14 = LITTLEENDIAN(words[14]);
  c = rotate(c + f1(d,a,b) + word14 + 0xa679438e, 17) + d;
  uint32_t word15 = LITTLEENDIAN(words[15]);
  b = rotate(b + f1(c,d,a) + word15 + 0x49b40821, 22) + c;

  // second round
  a = rotate(a + f2(b,c,d) + word1  + 0xf61e2562,  5) + b;
  d = rotate(d + f2(a,b,c) + word6  + 0xc040b340,  9) + a;
  c = rotate(c + f2(d,a,b) + word11 + 0x265e5a51, 14) + d;
  b = rotate(b + f2(c,d,a) + word0  + 0xe9b6c7aa, 20) + c;

  a = rotate(a + f2(b,c,d) + word5  + 0xd62f105d,  5) + b;
  d = rotate(d + f2(a,b,c) + word10 + 0x02441453,  9) + a;
  c = rotate(c + f2(d,a,b) + word15 + 0xd8a1e681, 14) + d;
  b = rotate(b + f2(c,d,a) + word4  + 0xe7d3fbc8, 20) + c;

  a = rotate(a + f2(b,c,d) + word9  + 0x21e1cde6,  5) + b;
  d = rotate(d + f2(a,b,c) + word14 + 0xc33707d6,  9) + a;
  c = rotate(c + f2(d,a,b) + word3  + 0xf4d50d87, 14) + d;
  b = rotate(b + f2(c,d,a) + word8  + 0x455a14ed, 20) + c;

  a = rotate(a + f2(b,c,d) + word13 + 0xa9e3e905,  5) + b;
  d = rotate(d + f2(a,b,c) + word2  + 0xfcefa3f8,  9) + a;
  c = rotate(c + f2(d,a,b) + word7  + 0x676f02d9, 14) + d;
  b = rotate(b + f2(c,d,a) + word12 + 0x8d2a4c8a, 20) + c;

  // third round
  a = rotate(a + f3(b,c,d) + word5  + 0xfffa3942,  4) + b;
  d = rotate(d + f3(a,b,c) + word8  + 0x8771f681, 11) + a;
  c = rotate(c + f3(d,a,b) + word11 + 0x6d9d6122, 16) + d;
  b = rotate(b + f3(c,d,a) + word14 + 0xfde5380c, 23) + c;

  a = rotate(a + f3(b,c,d) + word1  + 0xa4beea44,  4) + b;
  d = rotate(d + f3(a,b,c) + word4  + 0x4bdecfa9, 11) + a;
  c = rotate(c + f3(d,a,b) + word7  + 0xf6bb4b60, 16) + d;
  b = rotate(b + f3(c,d,a) + word10 + 0xbebfbc70, 23) + c;

  a = rotate(a + f3(b,c,d) + word13 + 0x289b7ec6,  4) + b;
  d = rotate(d + f3(a,b,c) + word0  + 0xeaa127fa, 11) + a;
  c = rotate(c + f3(d,a,b) + word3  + 0xd4ef3085, 16) + d;
  b = rotate(b + f3(c,d,a) + word6  + 0x04881d05, 23) + c;

  a = rotate(a + f3(b,c,d) + word9  + 0xd9d4d039,  4) + b;
  d = rotate(d + f3(a,b,c) + word12 + 0xe6db99e5, 11) + a;
  c = rotate(c + f3(d,a,b) + word15 + 0x1fa27cf8, 16) + d;
  b = rotate(b + f3(c,d,a) + word2  + 0xc4ac5665, 23) + c;

  // fourth round
  a = rotate(a + f4(b,c,d) + word0  + 0xf4292244,  6) + b;
  d = rotate(d + f4(a,b,c) + word7  + 0x432aff97, 10) + a;
  c = rotate(c + f4(d,a,b) + word14 + 0xab9423a7, 15) + d;
  b = rotate(b + f4(c,d,a) + word5  + 0xfc93a039, 21) + c;

  a = rotate(a + f4(b,c,d) + word12 + 0x655b59c3,  6) + b;
  d = rotate(d + f4(a,b,c) + word3  + 0x8f0ccc92, 10) + a;
  c = rotate(c + f4(d,a,b) + word10 + 0xffeff47d, 15) + d;
  b = rotate(b + f4(c,d,a) + word1  + 0x85845dd1, 21) + c;

  a = rotate(a + f4(b,c,d) + word8  + 0x6fa87e4f,  6) + b;
  d = rotate(d + f4(a,b,c) + word15 + 0xfe2ce6e0, 10) + a;
  c = rotate(c + f4(d,a,b) + word6  + 0xa3014314, 15) + d;
  b = rotate(b + f4(c,d,a) + word13 + 0x4e0811a1, 21) + c;

  a = rotate(a + f4(b,c,d) + word4  + 0xf7537e82,  6) + b;
  d = rotate(d + f4(a,b,c) + word11 + 0xbd3af235, 10) + a;
  c = rotate(c + f4(d,a,b) + word2  + 0x2ad7d2bb, 15) + d;
  b = rotate(b + f4(c,d,a) + word9  + 0xeb86d391, 21) + c;

  // update hash
  m_hash[0] += a;
  m_hash[1] += b;
  m_hash[2] += c;
  m_hash[3] += d;
}


/// add arbitrary number of bytes
void MD5::add(const void* data, size_t numBytes)
{
  const uint8_t* current = (const uint8_t*) data;

  if (m_bufferSize > 0)
  {
    while (numBytes > 0 && m_bufferSize < BlockSize)
    {
      m_buffer[m_bufferSize++] = *current++;
      numBytes--;
    }
  }

  // full buffer
  if (m_bufferSize == BlockSize)
  {
    processBlock(m_buffer);
    m_numBytes  += BlockSize;
    m_bufferSize = 0;
  }

  // no more data ?
  if (numBytes == 0)
    return;

  // process full blocks
  while (numBytes >= BlockSize)
  {
    processBlock(current);
    current    += BlockSize;
    m_numBytes += BlockSize;
    numBytes   -= BlockSize;
  }

  // keep remaining bytes in buffer
  while (numBytes > 0)
  {
    m_buffer[m_bufferSize++] = *current++;
    numBytes--;
  }
}


/// process final block, less than 64 bytes
void MD5::processBuffer()
{
  // the input bytes are considered as bits strings, where the first bit is the most significant bit of the byte

  // - append "1" bit to message
  // - append "0" bits until message length in bit mod 512 is 448
  // - append length as 64 bit integer

  // number of bits
  size_t paddedLength = m_bufferSize * 8;

  // plus one bit set to 1 (always appended)
  paddedLength++;

  // number of bits must be (numBits % 512) = 448
  size_t lower11Bits = paddedLength & 511;
  if (lower11Bits <= 448)
    paddedLength +=       448 - lower11Bits;
  else
    paddedLength += 512 + 448 - lower11Bits;
  // convert from bits to bytes
  paddedLength /= 8;

  // only needed if additional data flows over into a second block
  unsigned char extra[BlockSize];

  // append a "1" bit, 128 => binary 10000000
  if (m_bufferSize < BlockSize)
    m_buffer[m_bufferSize] = 128;
  else
    extra[0] = 128;

  size_t i;
  for (i = m_bufferSize + 1; i < BlockSize; i++)
    m_buffer[i] = 0;
  for (; i < paddedLength; i++)
    extra[i - BlockSize] = 0;

  // add message length in bits as 64 bit number
  uint64_t msgBits = 8 * (m_numBytes + m_bufferSize);
  // find right position
  unsigned char* addLength;
  if (paddedLength < BlockSize)
    addLength = m_buffer + paddedLength;
  else
    addLength = extra + paddedLength - BlockSize;

  // must be little endian
  *addLength++ = msgBits & 0xFF; msgBits >>= 8;
  *addLength++ = msgBits & 0xFF; msgBits >>= 8;
  *addLength++ = msgBits & 0xFF; msgBits >>= 8;
  *addLength++ = msgBits & 0xFF; msgBits >>= 8;
  *addLength++ = msgBits & 0xFF; msgBits >>= 8;
  *addLength++ = msgBits & 0xFF; msgBits >>= 8;
  *addLength++ = msgBits & 0xFF; msgBits >>= 8;
  *addLength++ = msgBits & 0xFF;

  // process blocks
  processBlock(m_buffer);
  // flowed over into a second block ?
  if (paddedLength > BlockSize)
    processBlock(extra);
}


/// return latest hash as 32 hex characters
std::string MD5::getHash()
{
  // compute hash (as raw bytes)
  unsigned char rawHash[HashBytes];
  getHash(rawHash);

  // convert to hex string
  std::string result;
  result.reserve(2 * HashBytes);
  for (int i = 0; i < HashBytes; i++)
  {
    static const char dec2hex[16+1] = "0123456789ABCDEF";
    result += dec2hex[(rawHash[i] >> 4) & 15];
    result += dec2hex[ rawHash[i]       & 15];
  }

  return result;
}


/// return latest hash as bytes
void MD5::getHash(unsigned char buffer[MD5::HashBytes])
{
  // save old hash if buffer is partially filled
  uint32_t oldHash[HashValues];
  for (int i = 0; i < HashValues; i++)
    oldHash[i] = m_hash[i];

  // process remaining bytes
  processBuffer();

  unsigned char* current = buffer;
  for (int i = 0; i < HashValues; i++)
  {
    *current++ =  m_hash[i]        & 0xFF;
    *current++ = (m_hash[i] >>  8) & 0xFF;
    *current++ = (m_hash[i] >> 16) & 0xFF;
    *current++ = (m_hash[i] >> 24) & 0xFF;

    // restore old hash
    m_hash[i] = oldHash[i];
  }
}



#if !defined(HWBLAKE3)
// Sligthly reworked to compile on C++ (and FreeBSD)


#define BLAKE3_VERSION_STRING "1.0.0"
#define BLAKE3_KEY_LEN 32
#define BLAKE3_OUT_LEN 32
#define BLAKE3_BLOCK_LEN 64
#define BLAKE3_CHUNK_LEN 1024
#define BLAKE3_MAX_DEPTH 54

// This struct is a private implementation detail. It has to be here because
// it's part of blake3_hasher below.
typedef struct {
  uint32_t cv[8];
  uint64_t chunk_counter;
  uint8_t buf[BLAKE3_BLOCK_LEN];
  uint8_t buf_len;
  uint8_t blocks_compressed;
  uint8_t flags;
} blake3_chunk_state;

typedef struct {
  uint32_t key[8];
  blake3_chunk_state chunk;
  uint8_t cv_stack_len;
  uint8_t cv_stack[(BLAKE3_MAX_DEPTH + 1) * BLAKE3_OUT_LEN];
} blake3_hasher;

const char *blake3_version(void);
void blake3_hasher_init(blake3_hasher *self);
void blake3_hasher_update(blake3_hasher *self, const void *input,
                          size_t input_len);
void blake3_hasher_finalize(const blake3_hasher *self, uint8_t *out,
                            size_t out_len);
void blake3_hasher_finalize_seek(const blake3_hasher *self, uint64_t seek,
                                 uint8_t *out, size_t out_len);

// internal flags
enum blake3_flags {
  CHUNK_START         = 1 << 0,
  CHUNK_END           = 1 << 1,
  PARENT              = 1 << 2,
  ROOT                = 1 << 3,
  KEYED_HASH          = 1 << 4,
  DERIVE_KEY_CONTEXT  = 1 << 5,
  DERIVE_KEY_MATERIAL = 1 << 6,
};


#define MAX_SIMD_DEGREE 1
// There are some places where we want a static size that's equal to the
// MAX_SIMD_DEGREE, but also at least 2.
#define MAX_SIMD_DEGREE_OR_2 (MAX_SIMD_DEGREE > 2 ? MAX_SIMD_DEGREE : 2)

static const uint32_t IV[8] = {0x6A09E667UL, 0xBB67AE85UL, 0x3C6EF372UL,
                               0xA54FF53AUL, 0x510E527FUL, 0x9B05688CUL,
                               0x1F83D9ABUL, 0x5BE0CD19UL};

static const uint8_t MSG_SCHEDULE[7][16] = {
    {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15},
    {2, 6, 3, 10, 7, 0, 4, 13, 1, 11, 12, 5, 9, 14, 15, 8},
    {3, 4, 10, 12, 13, 2, 7, 14, 6, 5, 9, 0, 11, 15, 8, 1},
    {10, 7, 12, 9, 14, 3, 13, 15, 4, 0, 11, 2, 5, 8, 1, 6},
    {12, 13, 9, 11, 15, 10, 14, 8, 7, 2, 5, 3, 0, 1, 6, 4},
    {9, 14, 11, 5, 8, 12, 15, 1, 13, 3, 0, 10, 2, 6, 4, 7},
    {11, 15, 5, 0, 1, 9, 8, 6, 14, 10, 2, 12, 3, 4, 7, 13},
};

/* Find index of the highest set bit */
/* x is assumed to be nonzero.       */
static unsigned int highest_one(uint64_t x) {
#if defined(__GNUC__) || defined(__clang__)
  return 63 ^ __builtin_clzll(x);
#elif defined(_MSC_VER) && defined(IS_X86_64)
  unsigned long index;
  _BitScanReverse64(&index, x);
  return index;
#elif defined(_MSC_VER) && defined(IS_X86_32)
  if(x >> 32) {
    unsigned long index;
    _BitScanReverse(&index, x >> 32);
    return 32 + index;
  } else {
    unsigned long index;
    _BitScanReverse(&index, x);
    return index;
  }
#else
  unsigned int c = 0;
  if(x & 0xffffffff00000000ULL) { x >>= 32; c += 32; }
  if(x & 0x00000000ffff0000ULL) { x >>= 16; c += 16; }
  if(x & 0x000000000000ff00ULL) { x >>=  8; c +=  8; }
  if(x & 0x00000000000000f0ULL) { x >>=  4; c +=  4; }
  if(x & 0x000000000000000cULL) { x >>=  2; c +=  2; }
  if(x & 0x0000000000000002ULL) {           c +=  1; }
  return c;
#endif
}

// Count the number of 1 bits.
INLINE_divsuf unsigned int popcnt(uint64_t x) {
#if defined(__GNUC__) || defined(__clang__)
  return __builtin_popcountll(x);
#else
  unsigned int count = 0;
  while (x != 0) {
    count += 1;
    x &= x - 1;
  }
  return count;
#endif
}

// Largest power of two less than or equal to x. As a special case, returns 1
// when x is 0. 
INLINE_divsuf uint64_t round_down_to_power_of_2(uint64_t x) {
  return 1ULL << highest_one(x | 1);
}

INLINE_divsuf uint32_t counter_low(uint64_t counter) { return (uint32_t)counter; }

INLINE_divsuf uint32_t counter_high(uint64_t counter) {
  return (uint32_t)(counter >> 32);
}

INLINE_divsuf uint32_t load32(const void *src) {
  const uint8_t *p = (const uint8_t *)src;
  return ((uint32_t)(p[0]) << 0) | ((uint32_t)(p[1]) << 8) |
         ((uint32_t)(p[2]) << 16) | ((uint32_t)(p[3]) << 24);
}

INLINE_divsuf void load_key_words(const uint8_t key[BLAKE3_KEY_LEN],
                           uint32_t key_words[8]) {
  key_words[0] = load32(&key[0 * 4]);
  key_words[1] = load32(&key[1 * 4]);
  key_words[2] = load32(&key[2 * 4]);
  key_words[3] = load32(&key[3 * 4]);
  key_words[4] = load32(&key[4 * 4]);
  key_words[5] = load32(&key[5 * 4]);
  key_words[6] = load32(&key[6 * 4]);
  key_words[7] = load32(&key[7 * 4]);
}

INLINE_divsuf void store32(void *dst, uint32_t w) {
  uint8_t *p = (uint8_t *)dst;
  p[0] = (uint8_t)(w >> 0);
  p[1] = (uint8_t)(w >> 8);
  p[2] = (uint8_t)(w >> 16);
  p[3] = (uint8_t)(w >> 24);
}

INLINE_divsuf void store_cv_words(uint8_t bytes_out[32], uint32_t cv_words[8]) {
  store32(&bytes_out[0 * 4], cv_words[0]);
  store32(&bytes_out[1 * 4], cv_words[1]);
  store32(&bytes_out[2 * 4], cv_words[2]);
  store32(&bytes_out[3 * 4], cv_words[3]);
  store32(&bytes_out[4 * 4], cv_words[4]);
  store32(&bytes_out[5 * 4], cv_words[5]);
  store32(&bytes_out[6 * 4], cv_words[6]);
  store32(&bytes_out[7 * 4], cv_words[7]);
}

void blake3_compress_in_place(uint32_t cv[8],
                              const uint8_t block[BLAKE3_BLOCK_LEN],
                              uint8_t block_len, uint64_t counter,
                              uint8_t flags);

void blake3_compress_xof(const uint32_t cv[8],
                         const uint8_t block[BLAKE3_BLOCK_LEN],
                         uint8_t block_len, uint64_t counter, uint8_t flags,
                         uint8_t out[64]);

void blake3_hash_many(const uint8_t *const *inputs, size_t num_inputs,
                      size_t blocks, const uint32_t key[8], uint64_t counter,
                      bool increment_counter, uint8_t flags,
                      uint8_t flags_start, uint8_t flags_end, uint8_t *out);

size_t blake3_simd_degree(void);


// Declarations for implementation-specific functions.
void blake3_compress_in_place_portable(uint32_t cv[8],
                                       const uint8_t block[BLAKE3_BLOCK_LEN],
                                       uint8_t block_len, uint64_t counter,
                                       uint8_t flags);

void blake3_compress_xof_portable(const uint32_t cv[8],
                                  const uint8_t block[BLAKE3_BLOCK_LEN],
                                  uint8_t block_len, uint64_t counter,
                                  uint8_t flags, uint8_t out[64]);

void blake3_hash_many_portable(const uint8_t *const *inputs, size_t num_inputs,
                               size_t blocks, const uint32_t key[8],
                               uint64_t counter, bool increment_counter,
                               uint8_t flags, uint8_t flags_start,
                               uint8_t flags_end, uint8_t *out);





const char *blake3_version(void) { return BLAKE3_VERSION_STRING; }

INLINE_divsuf void chunk_state_init(blake3_chunk_state *self, const uint32_t key[8],
                             uint8_t flags) {
  memcpy(self->cv, key, BLAKE3_KEY_LEN);
  self->chunk_counter = 0;
  memset(self->buf, 0, BLAKE3_BLOCK_LEN);
  self->buf_len = 0;
  self->blocks_compressed = 0;
  self->flags = flags;
}

INLINE_divsuf void chunk_state_reset(blake3_chunk_state *self, const uint32_t key[8],
                              uint64_t chunk_counter) {
  memcpy(self->cv, key, BLAKE3_KEY_LEN);
  self->chunk_counter = chunk_counter;
  self->blocks_compressed = 0;
  memset(self->buf, 0, BLAKE3_BLOCK_LEN);
  self->buf_len = 0;
}

INLINE_divsuf size_t chunk_state_len(const blake3_chunk_state *self) {
  return (BLAKE3_BLOCK_LEN * (size_t)self->blocks_compressed) +
         ((size_t)self->buf_len);
}

INLINE_divsuf size_t chunk_state_fill_buf(blake3_chunk_state *self,
                                   const uint8_t *input, size_t input_len) {
  size_t take = BLAKE3_BLOCK_LEN - ((size_t)self->buf_len);
  if (take > input_len) {
    take = input_len;
  }
  uint8_t *dest = self->buf + ((size_t)self->buf_len);
  memcpy(dest, input, take);
  self->buf_len += (uint8_t)take;
  return take;
}

INLINE_divsuf uint8_t chunk_state_maybe_start_flag(const blake3_chunk_state *self) {
  if (self->blocks_compressed == 0) {
    return CHUNK_START;
  } else {
    return 0;
  }
}

typedef struct {
  uint32_t input_cv[8];
  uint64_t counter;
  uint8_t block[BLAKE3_BLOCK_LEN];
  uint8_t block_len;
  uint8_t flags;
} output_t;

INLINE_divsuf output_t make_output(const uint32_t input_cv[8],
                            const uint8_t block[BLAKE3_BLOCK_LEN],
                            uint8_t block_len, uint64_t counter,
                            uint8_t flags) {
  output_t ret;
  memcpy(ret.input_cv, input_cv, 32);
  memcpy(ret.block, block, BLAKE3_BLOCK_LEN);
  ret.block_len = block_len;
  ret.counter = counter;
  ret.flags = flags;
  return ret;
}

// Chaining values within a given chunk (specifically the compress_in_place
// interface) are represented as words. This avoids unnecessary bytes<->words
// conversion overhead in the portable implementation. However, the hash_many
// interface handles both user input and parent node blocks, so it accepts
// bytes. For that reason, chaining values in the CV stack are represented as
// bytes.
INLINE_divsuf void output_chaining_value(const output_t *self, uint8_t cv[32]) {
  uint32_t cv_words[8];
  memcpy(cv_words, self->input_cv, 32);
  blake3_compress_in_place(cv_words, self->block, self->block_len,
                           self->counter, self->flags);
  store_cv_words(cv, cv_words);
}

INLINE_divsuf void output_root_bytes(const output_t *self, uint64_t seek, uint8_t *out,
                              size_t out_len) {
  uint64_t output_block_counter = seek / 64;
  size_t offset_within_block = seek % 64;
  uint8_t wide_buf[64];
  while (out_len > 0) {
    blake3_compress_xof(self->input_cv, self->block, self->block_len,
                        output_block_counter, self->flags | ROOT, wide_buf);
    size_t available_bytes = 64 - offset_within_block;
    size_t memcpy_len;
    if (out_len > available_bytes) {
      memcpy_len = available_bytes;
    } else {
      memcpy_len = out_len;
    }
    memcpy(out, wide_buf + offset_within_block, memcpy_len);
    out += memcpy_len;
    out_len -= memcpy_len;
    output_block_counter += 1;
    offset_within_block = 0;
  }
}

INLINE_divsuf void chunk_state_update(blake3_chunk_state *self, const uint8_t *input,
                               size_t input_len) {
  if (self->buf_len > 0) {
    size_t take = chunk_state_fill_buf(self, input, input_len);
    input += take;
    input_len -= take;
    if (input_len > 0) {
      blake3_compress_in_place(
          self->cv, self->buf, BLAKE3_BLOCK_LEN, self->chunk_counter,
          self->flags | chunk_state_maybe_start_flag(self));
      self->blocks_compressed += 1;
      self->buf_len = 0;
      memset(self->buf, 0, BLAKE3_BLOCK_LEN);
    }
  }

  while (input_len > BLAKE3_BLOCK_LEN) {
    blake3_compress_in_place(self->cv, input, BLAKE3_BLOCK_LEN,
                             self->chunk_counter,
                             self->flags | chunk_state_maybe_start_flag(self));
    self->blocks_compressed += 1;
    input += BLAKE3_BLOCK_LEN;
    input_len -= BLAKE3_BLOCK_LEN;
  }

  size_t take = chunk_state_fill_buf(self, input, input_len);
  input += take;
  input_len -= take;
}

INLINE_divsuf output_t chunk_state_output(const blake3_chunk_state *self) {
  uint8_t block_flags =
      self->flags | chunk_state_maybe_start_flag(self) | CHUNK_END;
  return make_output(self->cv, self->buf, self->buf_len, self->chunk_counter,
                     block_flags);
}

INLINE_divsuf output_t parent_output(const uint8_t block[BLAKE3_BLOCK_LEN],
                              const uint32_t key[8], uint8_t flags) {
  return make_output(key, block, BLAKE3_BLOCK_LEN, 0, flags | PARENT);
}

// Given some input larger than one chunk, return the number of bytes that
// should go in the left subtree. This is the largest power-of-2 number of
// chunks that leaves at least 1 byte for the right subtree.
INLINE_divsuf size_t left_len(size_t content_len) {
  // Subtract 1 to reserve at least one byte for the right side. content_len
  // should always be greater than BLAKE3_CHUNK_LEN.
  size_t full_chunks = (content_len - 1) / BLAKE3_CHUNK_LEN;
  return round_down_to_power_of_2(full_chunks) * BLAKE3_CHUNK_LEN;
}

// Use SIMD parallelism to hash up to MAX_SIMD_DEGREE chunks at the same time
// on a single thread. Write out the chunk chaining values and return the
// number of chunks hashed. These chunks are never the root and never empty;
// those cases use a different codepath.
INLINE_divsuf size_t compress_chunks_parallel(const uint8_t *input, size_t input_len,
                                       const uint32_t key[8],
                                       uint64_t chunk_counter, uint8_t flags,
                                       uint8_t *out) {
#if defined(BLAKE3_TESTING)
  assert(0 < input_len);
  assert(input_len <= MAX_SIMD_DEGREE * BLAKE3_CHUNK_LEN);
#endif

  const uint8_t *chunks_array[MAX_SIMD_DEGREE];
  size_t input_position = 0;
  size_t chunks_array_len = 0;
  while (input_len - input_position >= BLAKE3_CHUNK_LEN) {
    chunks_array[chunks_array_len] = &input[input_position];
    input_position += BLAKE3_CHUNK_LEN;
    chunks_array_len += 1;
  }

  blake3_hash_many(chunks_array, chunks_array_len,
                   BLAKE3_CHUNK_LEN / BLAKE3_BLOCK_LEN, key, chunk_counter,
                   true, flags, CHUNK_START, CHUNK_END, out);

  // Hash the remaining partial chunk, if there is one. Note that the empty
  // chunk (meaning the empty message) is a different codepath.
  if (input_len > input_position) {
    uint64_t counter = chunk_counter + (uint64_t)chunks_array_len;
    blake3_chunk_state chunk_state;
    chunk_state_init(&chunk_state, key, flags);
    chunk_state.chunk_counter = counter;
    chunk_state_update(&chunk_state, &input[input_position],
                       input_len - input_position);
    output_t output = chunk_state_output(&chunk_state);
    output_chaining_value(&output, &out[chunks_array_len * BLAKE3_OUT_LEN]);
    return chunks_array_len + 1;
  } else {
    return chunks_array_len;
  }
}

// Use SIMD parallelism to hash up to MAX_SIMD_DEGREE parents at the same time
// on a single thread. Write out the parent chaining values and return the
// number of parents hashed. (If there's an odd input chaining value left over,
// return it as an additional output.) These parents are never the root and
// never empty; those cases use a different codepath.
INLINE_divsuf size_t compress_parents_parallel(const uint8_t *child_chaining_values,
                                        size_t num_chaining_values,
                                        const uint32_t key[8], uint8_t flags,
                                        uint8_t *out) {
#if defined(BLAKE3_TESTING)
  assert(2 <= num_chaining_values);
  assert(num_chaining_values <= 2 * MAX_SIMD_DEGREE_OR_2);
#endif

  const uint8_t *parents_array[MAX_SIMD_DEGREE_OR_2];
  size_t parents_array_len = 0;
  while (num_chaining_values - (2 * parents_array_len) >= 2) {
    parents_array[parents_array_len] =
        &child_chaining_values[2 * parents_array_len * BLAKE3_OUT_LEN];
    parents_array_len += 1;
  }

  blake3_hash_many(parents_array, parents_array_len, 1, key,
                   0, // Parents always use counter 0.
                   false, flags | PARENT,
                   0, // Parents have no start flags.
                   0, // Parents have no end flags.
                   out);

  // If there's an odd child left over, it becomes an output.
  if (num_chaining_values > 2 * parents_array_len) {
	  /*
	  franzfix to avoid strange warning
	  */
	  
	  memcpy(&out+(parents_array_len * BLAKE3_OUT_LEN),
           &child_chaining_values+(2 * parents_array_len * BLAKE3_OUT_LEN),
           BLAKE3_OUT_LEN);
/*
    memcpy(&out[parents_array_len * BLAKE3_OUT_LEN],
           &child_chaining_values[2 * parents_array_len * BLAKE3_OUT_LEN],
           BLAKE3_OUT_LEN);
*/
    return parents_array_len + 1;
  } else {
    return parents_array_len;
  }
}

// The wide helper function returns (writes out) an array of chaining values
// and returns the length of that array. The number of chaining values returned
// is the dyanmically detected SIMD degree, at most MAX_SIMD_DEGREE. Or fewer,
// if the input is shorter than that many chunks. The reason for maintaining a
// wide array of chaining values going back up the tree, is to allow the
// implementation to hash as many parents in parallel as possible.
//
// As a special case when the SIMD degree is 1, this function will still return
// at least 2 outputs. This guarantees that this function doesn't perform the
// root compression. (If it did, it would use the wrong flags, and also we
// wouldn't be able to implement exendable ouput.) Note that this function is
// not used when the whole input is only 1 chunk long; that's a different
// codepath.
//
// Why not just have the caller split the input on the first update(), instead
// of implementing this special rule? Because we don't want to limit SIMD or
// multi-threading parallelism for that update().
static size_t blake3_compress_subtree_wide(const uint8_t *input,
                                           size_t input_len,
                                           const uint32_t key[8],
                                           uint64_t chunk_counter,
                                           uint8_t flags, uint8_t *out) {
  // Note that the single chunk case does *not* bump the SIMD degree up to 2
  // when it is 1. If this implementation adds multi-threading in the future,
  // this gives us the option of multi-threading even the 2-chunk case, which
  // can help performance on smaller platforms.
  if (input_len <= blake3_simd_degree() * BLAKE3_CHUNK_LEN) {
    return compress_chunks_parallel(input, input_len, key, chunk_counter, flags,
                                    out);
  }

  // With more than simd_degree chunks, we need to recurse. Start by dividing
  // the input into left and right subtrees. (Note that this is only optimal
  // as long as the SIMD degree is a power of 2. If we ever get a SIMD degree
  // of 3 or something, we'll need a more complicated strategy.)
  size_t left_input_len = left_len(input_len);
  size_t right_input_len = input_len - left_input_len;
  const uint8_t *right_input = &input[left_input_len];
  uint64_t right_chunk_counter =
      chunk_counter + (uint64_t)(left_input_len / BLAKE3_CHUNK_LEN);

  // Make space for the child outputs. Here we use MAX_SIMD_DEGREE_OR_2 to
  // account for the special case of returning 2 outputs when the SIMD degree
  // is 1.
  uint8_t cv_array[2 * MAX_SIMD_DEGREE_OR_2 * BLAKE3_OUT_LEN];
  size_t degree = blake3_simd_degree();
  if (left_input_len > BLAKE3_CHUNK_LEN && degree == 1) {
    // The special case: We always use a degree of at least two, to make
    // sure there are two outputs. Except, as noted above, at the chunk
    // level, where we allow degree=1. (Note that the 1-chunk-input case is
    // a different codepath.)
    degree = 2;
  }
  uint8_t *right_cvs = &cv_array[degree * BLAKE3_OUT_LEN];

  // Recurse! If this implementation adds multi-threading support in the
  // future, this is where it will go.
  size_t left_n = blake3_compress_subtree_wide(input, left_input_len, key,
                                               chunk_counter, flags, cv_array);
  size_t right_n = blake3_compress_subtree_wide(
      right_input, right_input_len, key, right_chunk_counter, flags, right_cvs);

  // The special case again. If simd_degree=1, then we'll have left_n=1 and
  // right_n=1. Rather than compressing them into a single output, return
  // them directly, to make sure we always have at least two outputs.
  if (left_n == 1) {
    memcpy(out, cv_array, 2 * BLAKE3_OUT_LEN);
    return 2;
  }

  // Otherwise, do one layer of parent node compression.
  size_t num_chaining_values = left_n + right_n;
  return compress_parents_parallel(cv_array, num_chaining_values, key, flags,
                                   out);
}

// Hash a subtree with compress_subtree_wide(), and then condense the resulting
// list of chaining values down to a single parent node. Don't compress that
// last parent node, however. Instead, return its message bytes (the
// concatenated chaining values of its children). This is necessary when the
// first call to update() supplies a complete subtree, because the topmost
// parent node of that subtree could end up being the root. It's also necessary
// for extended output in the general case.
//
// As with compress_subtree_wide(), this function is not used on inputs of 1
// chunk or less. That's a different codepath.
INLINE_divsuf void compress_subtree_to_parent_node(
    const uint8_t *input, size_t input_len, const uint32_t key[8],
    uint64_t chunk_counter, uint8_t flags, uint8_t out[2 * BLAKE3_OUT_LEN]) {
#if defined(BLAKE3_TESTING)
  assert(input_len > BLAKE3_CHUNK_LEN);
#endif

  uint8_t cv_array[MAX_SIMD_DEGREE_OR_2 * BLAKE3_OUT_LEN];
  size_t num_cvs = blake3_compress_subtree_wide(input, input_len, key,
                                                chunk_counter, flags, cv_array);

  // If MAX_SIMD_DEGREE is greater than 2 and there's enough input,
  // compress_subtree_wide() returns more than 2 chaining values. Condense
  // them into 2 by forming parent nodes repeatedly.
  uint8_t out_array[MAX_SIMD_DEGREE_OR_2 * BLAKE3_OUT_LEN /*franzfix / 2*/];
  while (num_cvs > 2) {
    num_cvs =
        compress_parents_parallel(cv_array, num_cvs, key, flags, out_array);
    memcpy(cv_array, out_array, num_cvs * BLAKE3_OUT_LEN);
  }
  memcpy(out, cv_array, 2 * BLAKE3_OUT_LEN);
}

INLINE_divsuf void hasher_init_base(blake3_hasher *self, const uint32_t key[8],
                             uint8_t flags) {
  memcpy(self->key, key, BLAKE3_KEY_LEN);
  chunk_state_init(&self->chunk, key, flags);
  self->cv_stack_len = 0;
}

void blake3_hasher_init(blake3_hasher *self) { hasher_init_base(self, IV, 0); }



// As described in hasher_push_cv() below, we do "lazy merging", delaying
// merges until right before the next CV is about to be added. This is
// different from the reference implementation. Another difference is that we
// aren't always merging 1 chunk at a time. Instead, each CV might represent
// any power-of-two number of chunks, as long as the smaller-above-larger stack
// order is maintained. Instead of the "count the trailing 0-bits" algorithm
// described in the spec, we use a "count the total number of 1-bits" variant
// that doesn't require us to retain the subtree size of the CV on top of the
// stack. The principle is the same: each CV that should remain in the stack is
// represented by a 1-bit in the total number of chunks (or bytes) so far.
INLINE_divsuf void hasher_merge_cv_stack(blake3_hasher *self, uint64_t total_len) {
  size_t post_merge_stack_len = (size_t)popcnt(total_len);
  while (self->cv_stack_len > post_merge_stack_len) {
    uint8_t *parent_node =
        &self->cv_stack[(self->cv_stack_len - 2) * BLAKE3_OUT_LEN];
    output_t output = parent_output(parent_node, self->key, self->chunk.flags);
    output_chaining_value(&output, parent_node);
    self->cv_stack_len -= 1;
  }
}

// In reference_impl.rs, we merge the new CV with existing CVs from the stack
// before pushing it. We can do that because we know more input is coming, so
// we know none of the merges are root.
//
// This setting is different. We want to feed as much input as possible to
// compress_subtree_wide(), without setting aside anything for the chunk_state.
// If the user gives us 64 KiB, we want to parallelize over all 64 KiB at once
// as a single subtree, if at all possible.
//
// This leads to two problems:
// 1) This 64 KiB input might be the only call that ever gets made to update.
//    In this case, the root node of the 64 KiB subtree would be the root node
//    of the whole tree, and it would need to be ROOT finalized. We can't
//    compress it until we know.
// 2) This 64 KiB input might complete a larger tree, whose root node is
//    similarly going to be the the root of the whole tree. For example, maybe
//    we have 196 KiB (that is, 128 + 64) hashed so far. We can't compress the
//    node at the root of the 256 KiB subtree until we know how to finalize it.
//
// The second problem is solved with "lazy merging". That is, when we're about
// to add a CV to the stack, we don't merge it with anything first, as the
// reference impl does. Instead we do merges using the *previous* CV that was
// added, which is sitting on top of the stack, and we put the new CV
// (unmerged) on top of the stack afterwards. This guarantees that we never
// merge the root node until finalize().
//
// Solving the first problem requires an additional tool,
// compress_subtree_to_parent_node(). That function always returns the top
// *two* chaining values of the subtree it's compressing. We then do lazy
// merging with each of them separately, so that the second CV will always
// remain unmerged. (That also helps us support extendable output when we're
// hashing an input all-at-once.)
INLINE_divsuf void hasher_push_cv(blake3_hasher *self, uint8_t new_cv[BLAKE3_OUT_LEN],
                           uint64_t chunk_counter) {
  hasher_merge_cv_stack(self, chunk_counter);
  memcpy(&self->cv_stack[self->cv_stack_len * BLAKE3_OUT_LEN], new_cv,
         BLAKE3_OUT_LEN);
  self->cv_stack_len += 1;
}

void blake3_hasher_update(blake3_hasher *self, const void *input,
                          size_t input_len) {
  // Explicitly checking for zero avoids causing UB by passing a null pointer
  // to memcpy. This comes up in practice with things like:
  //   std::vector<uint8_t> v;
  //   blake3_hasher_update(&hasher, v.data(), v.size());
  if (input_len == 0) {
    return;
  }

  const uint8_t *input_bytes = (const uint8_t *)input;

  // If we have some partial chunk bytes in the internal chunk_state, we need
  // to finish that chunk first.
  if (chunk_state_len(&self->chunk) > 0) {
    size_t take = BLAKE3_CHUNK_LEN - chunk_state_len(&self->chunk);
    if (take > input_len) {
      take = input_len;
    }
    chunk_state_update(&self->chunk, input_bytes, take);
    input_bytes += take;
    input_len -= take;
    // If we've filled the current chunk and there's more coming, finalize this
    // chunk and proceed. In this case we know it's not the root.
    if (input_len > 0) {
      output_t output = chunk_state_output(&self->chunk);
      uint8_t chunk_cv[32];
      output_chaining_value(&output, chunk_cv);
      hasher_push_cv(self, chunk_cv, self->chunk.chunk_counter);
      chunk_state_reset(&self->chunk, self->key, self->chunk.chunk_counter + 1);
    } else {
      return;
    }
  }

  // Now the chunk_state is clear, and we have more input. If there's more than
  // a single chunk (so, definitely not the root chunk), hash the largest whole
  // subtree we can, with the full benefits of SIMD (and maybe in the future,
  // multi-threading) parallelism. Two restrictions:
  // - The subtree has to be a power-of-2 number of chunks. Only subtrees along
  //   the right edge can be incomplete, and we don't know where the right edge
  //   is going to be until we get to finalize().
  // - The subtree must evenly divide the total number of chunks up until this
  //   point (if total is not 0). If the current incomplete subtree is only
  //   waiting for 1 more chunk, we can't hash a subtree of 4 chunks. We have
  //   to complete the current subtree first.
  // Because we might need to break up the input to form powers of 2, or to
  // evenly divide what we already have, this part runs in a loop.
  while (input_len > BLAKE3_CHUNK_LEN) {
    size_t subtree_len = round_down_to_power_of_2(input_len);
    uint64_t count_so_far = self->chunk.chunk_counter * BLAKE3_CHUNK_LEN;
    // Shrink the subtree_len until it evenly divides the count so far. We know
    // that subtree_len itself is a power of 2, so we can use a bitmasking
    // trick instead of an actual remainder operation. (Note that if the caller
    // consistently passes power-of-2 inputs of the same size, as is hopefully
    // typical, this loop condition will always fail, and subtree_len will
    // always be the full length of the input.)
    //
    // An aside: We don't have to shrink subtree_len quite this much. For
    // example, if count_so_far is 1, we could pass 2 chunks to
    // compress_subtree_to_parent_node. Since we'll get 2 CVs back, we'll still
    // get the right answer in the end, and we might get to use 2-way SIMD
    // parallelism. The problem with this optimization, is that it gets us
    // stuck always hashing 2 chunks. The total number of chunks will remain
    // odd, and we'll never graduate to higher degrees of parallelism. See
    // https://github.com/BLAKE3-team/BLAKE3/issues/69.
    while ((((uint64_t)(subtree_len - 1)) & count_so_far) != 0) {
      subtree_len /= 2;
    }
    // The shrunken subtree_len might now be 1 chunk long. If so, hash that one
    // chunk by itself. Otherwise, compress the subtree into a pair of CVs.
    uint64_t subtree_chunks = subtree_len / BLAKE3_CHUNK_LEN;
    if (subtree_len <= BLAKE3_CHUNK_LEN) {
      blake3_chunk_state chunk_state;
      chunk_state_init(&chunk_state, self->key, self->chunk.flags);
      chunk_state.chunk_counter = self->chunk.chunk_counter;
      chunk_state_update(&chunk_state, input_bytes, subtree_len);
      output_t output = chunk_state_output(&chunk_state);
      uint8_t cv[BLAKE3_OUT_LEN];
      output_chaining_value(&output, cv);
      hasher_push_cv(self, cv, chunk_state.chunk_counter);
    } else {
      // This is the high-performance happy path, though getting here depends
      // on the caller giving us a long enough input.
      uint8_t cv_pair[2 * BLAKE3_OUT_LEN];
      compress_subtree_to_parent_node(input_bytes, subtree_len, self->key,
                                      self->chunk.chunk_counter,
                                      self->chunk.flags, cv_pair);
      hasher_push_cv(self, cv_pair, self->chunk.chunk_counter);
      hasher_push_cv(self, &cv_pair[BLAKE3_OUT_LEN],
                     self->chunk.chunk_counter + (subtree_chunks / 2));
    }
    self->chunk.chunk_counter += subtree_chunks;
    input_bytes += subtree_len;
    input_len -= subtree_len;
  }

  // If there's any remaining input less than a full chunk, add it to the chunk
  // state. In that case, also do a final merge loop to make sure the subtree
  // stack doesn't contain any unmerged pairs. The remaining input means we
  // know these merges are non-root. This merge loop isn't strictly necessary
  // here, because hasher_push_chunk_cv already does its own merge loop, but it
  // simplifies blake3_hasher_finalize below.
  if (input_len > 0) {
    chunk_state_update(&self->chunk, input_bytes, input_len);
    hasher_merge_cv_stack(self, self->chunk.chunk_counter);
  }
}

void blake3_hasher_finalize(const blake3_hasher *self, uint8_t *out,
                            size_t out_len) {
  blake3_hasher_finalize_seek(self, 0, out, out_len);
}

void blake3_hasher_finalize_seek(const blake3_hasher *self, uint64_t seek,
                                 uint8_t *out, size_t out_len) {
  // Explicitly checking for zero avoids causing UB by passing a null pointer
  // to memcpy. This comes up in practice with things like:
  //   std::vector<uint8_t> v;
  //   blake3_hasher_finalize(&hasher, v.data(), v.size());
  if (out_len == 0) {
    return;
  }

  // If the subtree stack is empty, then the current chunk is the root.
  if (self->cv_stack_len == 0) {
    output_t output = chunk_state_output(&self->chunk);
    output_root_bytes(&output, seek, out, out_len);
    return;
  }
  // If there are any bytes in the chunk state, finalize that chunk and do a
  // roll-up merge between that chunk hash and every subtree in the stack. In
  // this case, the extra merge loop at the end of blake3_hasher_update
  // guarantees that none of the subtrees in the stack need to be merged with
  // each other first. Otherwise, if there are no bytes in the chunk state,
  // then the top of the stack is a chunk hash, and we start the merge from
  // that.
  output_t output;
  size_t cvs_remaining;
  if (chunk_state_len(&self->chunk) > 0) {
    cvs_remaining = self->cv_stack_len;
    output = chunk_state_output(&self->chunk);
  } else {
    // There are always at least 2 CVs in the stack in this case.
    cvs_remaining = self->cv_stack_len - 2;
    output = parent_output(&self->cv_stack[cvs_remaining * 32], self->key,
                           self->chunk.flags);
  }
  while (cvs_remaining > 0) {
    cvs_remaining -= 1;
    uint8_t parent_block[BLAKE3_BLOCK_LEN];
    memcpy(parent_block, &self->cv_stack[cvs_remaining * 32], 32);
    output_chaining_value(&output, &parent_block[32]);
    output = parent_output(parent_block, self->key, self->chunk.flags);
  }
  output_root_bytes(&output, seek, out, out_len);
}






#define MAYBE_UNUSED(x) (void)((x))

#if defined(IS_X86)
static uint64_t xgetbv() {
#if defined(_MSC_VER)
  return _xgetbv(0);
#else
  uint32_t eax = 0, edx = 0;
  __asm__ __volatile__("xgetbv\n" : "=a"(eax), "=d"(edx) : "c"(0));
  return ((uint64_t)edx << 32) | eax;
#endif
}

static void cpuid(uint32_t out[4], uint32_t id) {
#if defined(_MSC_VER)
  __cpuid((int *)out, id);
#elif defined(__i386__) || defined(_M_IX86)
  __asm__ __volatile__("movl %%ebx, %1\n"
                       "cpuid\n"
                       "xchgl %1, %%ebx\n"
                       : "=a"(out[0]), "=r"(out[1]), "=c"(out[2]), "=d"(out[3])
                       : "a"(id));
#else
  __asm__ __volatile__("cpuid\n"
                       : "=a"(out[0]), "=b"(out[1]), "=c"(out[2]), "=d"(out[3])
                       : "a"(id));
#endif
}

static void cpuidex(uint32_t out[4], uint32_t id, uint32_t sid) {
#if defined(_MSC_VER)
  __cpuidex((int *)out, id, sid);
#elif defined(__i386__) || defined(_M_IX86)
  __asm__ __volatile__("movl %%ebx, %1\n"
                       "cpuid\n"
                       "xchgl %1, %%ebx\n"
                       : "=a"(out[0]), "=r"(out[1]), "=c"(out[2]), "=d"(out[3])
                       : "a"(id), "c"(sid));
#else
  __asm__ __volatile__("cpuid\n"
                       : "=a"(out[0]), "=b"(out[1]), "=c"(out[2]), "=d"(out[3])
                       : "a"(id), "c"(sid));
#endif
}

#endif




void blake3_compress_in_place(uint32_t cv[8],
                              const uint8_t block[BLAKE3_BLOCK_LEN],
                              uint8_t block_len, uint64_t counter,
                              uint8_t flags) {

  blake3_compress_in_place_portable(cv, block, block_len, counter, flags);
}

void blake3_compress_xof(const uint32_t cv[8],
                         const uint8_t block[BLAKE3_BLOCK_LEN],
                         uint8_t block_len, uint64_t counter, uint8_t flags,
                         uint8_t out[64]) {
  blake3_compress_xof_portable(cv, block, block_len, counter, flags, out);
}

void blake3_hash_many(const uint8_t *const *inputs, size_t num_inputs,
                      size_t blocks, const uint32_t key[8], uint64_t counter,
                      bool increment_counter, uint8_t flags,
                      uint8_t flags_start, uint8_t flags_end, uint8_t *out) {

  blake3_hash_many_portable(inputs, num_inputs, blocks, key, counter,
                            increment_counter, flags, flags_start, flags_end,
                            out);
}

// No SIMD here, full-software implementation
size_t blake3_simd_degree(void) 
{
  return 1;
}


INLINE_divsuf uint32_t rotr32(uint32_t w, uint32_t c) {
  return (w >> c) | (w << (32 - c));
}

INLINE_divsuf void g(uint32_t *state, size_t a, size_t b, size_t c, size_t d,
              uint32_t x, uint32_t y) {
  state[a] = state[a] + state[b] + x;
  state[d] = rotr32(state[d] ^ state[a], 16);
  state[c] = state[c] + state[d];
  state[b] = rotr32(state[b] ^ state[c], 12);
  state[a] = state[a] + state[b] + y;
  state[d] = rotr32(state[d] ^ state[a], 8);
  state[c] = state[c] + state[d];
  state[b] = rotr32(state[b] ^ state[c], 7);
}

INLINE_divsuf void round_fn(uint32_t state[16], const uint32_t *msg, size_t round) {
  // Select the message schedule based on the round.
  const uint8_t *schedule = MSG_SCHEDULE[round];

  // Mix the columns.
  g(state, 0, 4, 8, 12, msg[schedule[0]], msg[schedule[1]]);
  g(state, 1, 5, 9, 13, msg[schedule[2]], msg[schedule[3]]);
  g(state, 2, 6, 10, 14, msg[schedule[4]], msg[schedule[5]]);
  g(state, 3, 7, 11, 15, msg[schedule[6]], msg[schedule[7]]);

  // Mix the rows.
  g(state, 0, 5, 10, 15, msg[schedule[8]], msg[schedule[9]]);
  g(state, 1, 6, 11, 12, msg[schedule[10]], msg[schedule[11]]);
  g(state, 2, 7, 8, 13, msg[schedule[12]], msg[schedule[13]]);
  g(state, 3, 4, 9, 14, msg[schedule[14]], msg[schedule[15]]);
}

INLINE_divsuf void compress_pre(uint32_t state[16], const uint32_t cv[8],
                         const uint8_t block[BLAKE3_BLOCK_LEN],
                         uint8_t block_len, uint64_t counter, uint8_t flags) {
  uint32_t block_words[16];
  block_words[0] = load32(block + 4 * 0);
  block_words[1] = load32(block + 4 * 1);
  block_words[2] = load32(block + 4 * 2);
  block_words[3] = load32(block + 4 * 3);
  block_words[4] = load32(block + 4 * 4);
  block_words[5] = load32(block + 4 * 5);
  block_words[6] = load32(block + 4 * 6);
  block_words[7] = load32(block + 4 * 7);
  block_words[8] = load32(block + 4 * 8);
  block_words[9] = load32(block + 4 * 9);
  block_words[10] = load32(block + 4 * 10);
  block_words[11] = load32(block + 4 * 11);
  block_words[12] = load32(block + 4 * 12);
  block_words[13] = load32(block + 4 * 13);
  block_words[14] = load32(block + 4 * 14);
  block_words[15] = load32(block + 4 * 15);

  state[0] = cv[0];
  state[1] = cv[1];
  state[2] = cv[2];
  state[3] = cv[3];
  state[4] = cv[4];
  state[5] = cv[5];
  state[6] = cv[6];
  state[7] = cv[7];
  state[8] = IV[0];
  state[9] = IV[1];
  state[10] = IV[2];
  state[11] = IV[3];
  state[12] = counter_low(counter);
  state[13] = counter_high(counter);
  state[14] = (uint32_t)block_len;
  state[15] = (uint32_t)flags;

  round_fn(state, &block_words[0], 0);
  round_fn(state, &block_words[0], 1);
  round_fn(state, &block_words[0], 2);
  round_fn(state, &block_words[0], 3);
  round_fn(state, &block_words[0], 4);
  round_fn(state, &block_words[0], 5);
  round_fn(state, &block_words[0], 6);
}

void blake3_compress_in_place_portable(uint32_t cv[8],
                                       const uint8_t block[BLAKE3_BLOCK_LEN],
                                       uint8_t block_len, uint64_t counter,
                                       uint8_t flags) {
  uint32_t state[16];
  compress_pre(state, cv, block, block_len, counter, flags);
  cv[0] = state[0] ^ state[8];
  cv[1] = state[1] ^ state[9];
  cv[2] = state[2] ^ state[10];
  cv[3] = state[3] ^ state[11];
  cv[4] = state[4] ^ state[12];
  cv[5] = state[5] ^ state[13];
  cv[6] = state[6] ^ state[14];
  cv[7] = state[7] ^ state[15];
}

void blake3_compress_xof_portable(const uint32_t cv[8],
                                  const uint8_t block[BLAKE3_BLOCK_LEN],
                                  uint8_t block_len, uint64_t counter,
                                  uint8_t flags, uint8_t out[64]) {
  uint32_t state[16];
  compress_pre(state, cv, block, block_len, counter, flags);

  store32(&out[0 * 4], state[0] ^ state[8]);
  store32(&out[1 * 4], state[1] ^ state[9]);
  store32(&out[2 * 4], state[2] ^ state[10]);
  store32(&out[3 * 4], state[3] ^ state[11]);
  store32(&out[4 * 4], state[4] ^ state[12]);
  store32(&out[5 * 4], state[5] ^ state[13]);
  store32(&out[6 * 4], state[6] ^ state[14]);
  store32(&out[7 * 4], state[7] ^ state[15]);
  store32(&out[8 * 4], state[8] ^ cv[0]);
  store32(&out[9 * 4], state[9] ^ cv[1]);
  store32(&out[10 * 4], state[10] ^ cv[2]);
  store32(&out[11 * 4], state[11] ^ cv[3]);
  store32(&out[12 * 4], state[12] ^ cv[4]);
  store32(&out[13 * 4], state[13] ^ cv[5]);
  store32(&out[14 * 4], state[14] ^ cv[6]);
  store32(&out[15 * 4], state[15] ^ cv[7]);
}

INLINE_divsuf void hash_one_portable(const uint8_t *input, size_t blocks,
                              const uint32_t key[8], uint64_t counter,
                              uint8_t flags, uint8_t flags_start,
                              uint8_t flags_end, uint8_t out[BLAKE3_OUT_LEN]) {
  uint32_t cv[8];
  memcpy(cv, key, BLAKE3_KEY_LEN);
  uint8_t block_flags = flags | flags_start;
  while (blocks > 0) {
    if (blocks == 1) {
      block_flags |= flags_end;
    }
    blake3_compress_in_place_portable(cv, input, BLAKE3_BLOCK_LEN, counter,
                                      block_flags);
    input = &input[BLAKE3_BLOCK_LEN];
    blocks -= 1;
    block_flags = flags;
  }
  store_cv_words(out, cv);
}

void blake3_hash_many_portable(const uint8_t *const *inputs, size_t num_inputs,
                               size_t blocks, const uint32_t key[8],
                               uint64_t counter, bool increment_counter,
                               uint8_t flags, uint8_t flags_start,
                               uint8_t flags_end, uint8_t *out) {
  while (num_inputs > 0) {
    hash_one_portable(inputs[0], blocks, key, counter, flags, flags_start,
                      flags_end, out);
    if (increment_counter) {
      counter += 1;
    }
    inputs += 1;
    num_inputs -= 1;
    out = &out[BLAKE3_OUT_LEN];
  }
}

#else  /// HWBLAKE3


///	This call the hardware-accelerated-Win64-asm zpaqfranz

#define BLAKE3_VERSION_STRING "1.0.0"
#define BLAKE3_KEY_LEN 32
#define BLAKE3_OUT_LEN 32
#define BLAKE3_BLOCK_LEN 64
#define BLAKE3_CHUNK_LEN 1024
#define BLAKE3_MAX_DEPTH 54

// This struct is a private implementation detail. It has to be here because
// it's part of blake3_hasher below.
typedef struct {
  uint32_t cv[8];
  uint64_t chunk_counter;
  uint8_t buf[BLAKE3_BLOCK_LEN];
  uint8_t buf_len;
  uint8_t blocks_compressed;
  uint8_t flags;
} blake3_chunk_state;

typedef struct {
  uint32_t key[8];
  blake3_chunk_state chunk;
  uint8_t cv_stack_len;
  // The stack size is MAX_DEPTH + 1 because we do lazy merging. For example,
  // with 7 chunks, we have 3 entries in the stack. Adding an 8th chunk
  // requires a 4th entry, rather than merging everything down to 1, because we
  // don't know whether more input is coming. This is different from how the
  // reference implementation does things.
  uint8_t cv_stack[(BLAKE3_MAX_DEPTH + 1) * BLAKE3_OUT_LEN];
} blake3_hasher;

const char *blake3_version(void);
void blake3_hasher_init(blake3_hasher *self);
void blake3_hasher_init_derive_key(blake3_hasher *self, const char *context);
void blake3_hasher_init_derive_key_raw(blake3_hasher *self, const void *context,
                                       size_t context_len);
void blake3_hasher_update(blake3_hasher *self, const void *input,
                          size_t input_len);
void blake3_hasher_finalize(const blake3_hasher *self, uint8_t *out,
                            size_t out_len);
void blake3_hasher_finalize_seek(const blake3_hasher *self, uint64_t seek,
                                 uint8_t *out, size_t out_len);

// internal flags
enum blake3_flags {
  CHUNK_START         = 1 << 0,
  CHUNK_END           = 1 << 1,
  PARENT              = 1 << 2,
  ROOT                = 1 << 3,
  KEYED_HASH          = 1 << 4,
  DERIVE_KEY_CONTEXT  = 1 << 5,
  DERIVE_KEY_MATERIAL = 1 << 6,
};

// This C implementation tries to support recent versions of GCC, Clang, and
// MSVC.
#if defined(_MSC_VER)
#define INLINE static __forceinline
#else
#define INLINE static inline __attribute__((always_inline))
#endif

#if defined(__x86_64__) || defined(_M_X64) 
#define IS_X86
#define IS_X86_64
#endif

#if defined(__i386__) || defined(_M_IX86)
#define IS_X86
#define IS_X86_32
#endif

#if defined(IS_X86)
#if defined(_MSC_VER)
#include <intrin.h>
#endif
#include <immintrin.h>
#endif

#if defined(IS_X86)
#define MAX_SIMD_DEGREE 16
#elif defined(BLAKE3_USE_NEON)
#define MAX_SIMD_DEGREE 4
#else
#define MAX_SIMD_DEGREE 1
#endif

// There are some places where we want a static size that's equal to the
// MAX_SIMD_DEGREE, but also at least 2.
#define MAX_SIMD_DEGREE_OR_2 (MAX_SIMD_DEGREE > 2 ? MAX_SIMD_DEGREE : 2)

static const uint32_t IV[8] = {0x6A09E667UL, 0xBB67AE85UL, 0x3C6EF372UL,
                               0xA54FF53AUL, 0x510E527FUL, 0x9B05688CUL,
                               0x1F83D9ABUL, 0x5BE0CD19UL};

static const uint8_t MSG_SCHEDULE[7][16] = {
    {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15},
    {2, 6, 3, 10, 7, 0, 4, 13, 1, 11, 12, 5, 9, 14, 15, 8},
    {3, 4, 10, 12, 13, 2, 7, 14, 6, 5, 9, 0, 11, 15, 8, 1},
    {10, 7, 12, 9, 14, 3, 13, 15, 4, 0, 11, 2, 5, 8, 1, 6},
    {12, 13, 9, 11, 15, 10, 14, 8, 7, 2, 5, 3, 0, 1, 6, 4},
    {9, 14, 11, 5, 8, 12, 15, 1, 13, 3, 0, 10, 2, 6, 4, 7},
    {11, 15, 5, 0, 1, 9, 8, 6, 14, 10, 2, 12, 3, 4, 7, 13},
};

/* Find index of the highest set bit */
/* x is assumed to be nonzero.       */
static unsigned int highest_one(uint64_t x) {
#if defined(__GNUC__) || defined(__clang__)
  return 63 ^ __builtin_clzll(x);
#elif defined(_MSC_VER) && defined(IS_X86_64)
  unsigned long index;
  _BitScanReverse64(&index, x);
  return index;
#elif defined(_MSC_VER) && defined(IS_X86_32)
  if(x >> 32) {
    unsigned long index;
    _BitScanReverse(&index, x >> 32);
    return 32 + index;
  } else {
    unsigned long index;
    _BitScanReverse(&index, x);
    return index;
  }
#else
  unsigned int c = 0;
  if(x & 0xffffffff00000000ULL) { x >>= 32; c += 32; }
  if(x & 0x00000000ffff0000ULL) { x >>= 16; c += 16; }
  if(x & 0x000000000000ff00ULL) { x >>=  8; c +=  8; }
  if(x & 0x00000000000000f0ULL) { x >>=  4; c +=  4; }
  if(x & 0x000000000000000cULL) { x >>=  2; c +=  2; }
  if(x & 0x0000000000000002ULL) {           c +=  1; }
  return c;
#endif
}

// Count the number of 1 bits.
INLINE unsigned int popcnt(uint64_t x) {
#if defined(__GNUC__) || defined(__clang__)
  return __builtin_popcountll(x);
#else
  unsigned int count = 0;
  while (x != 0) {
    count += 1;
    x &= x - 1;
  }
  return count;
#endif
}

// Largest power of two less than or equal to x. As a special case, returns 1
// when x is 0. 
INLINE uint64_t round_down_to_power_of_2(uint64_t x) {
  return 1ULL << highest_one(x | 1);
}

INLINE uint32_t counter_low(uint64_t counter) { return (uint32_t)counter; }

INLINE uint32_t counter_high(uint64_t counter) {
  return (uint32_t)(counter >> 32);
}

INLINE uint32_t load32(const void *src) {
  const uint8_t *p = (const uint8_t *)src;
  return ((uint32_t)(p[0]) << 0) | ((uint32_t)(p[1]) << 8) |
         ((uint32_t)(p[2]) << 16) | ((uint32_t)(p[3]) << 24);
}

INLINE void load_key_words(const uint8_t key[BLAKE3_KEY_LEN],
                           uint32_t key_words[8]) {
  key_words[0] = load32(&key[0 * 4]);
  key_words[1] = load32(&key[1 * 4]);
  key_words[2] = load32(&key[2 * 4]);
  key_words[3] = load32(&key[3 * 4]);
  key_words[4] = load32(&key[4 * 4]);
  key_words[5] = load32(&key[5 * 4]);
  key_words[6] = load32(&key[6 * 4]);
  key_words[7] = load32(&key[7 * 4]);
}

INLINE void store32(void *dst, uint32_t w) {
  uint8_t *p = (uint8_t *)dst;
  p[0] = (uint8_t)(w >> 0);
  p[1] = (uint8_t)(w >> 8);
  p[2] = (uint8_t)(w >> 16);
  p[3] = (uint8_t)(w >> 24);
}

INLINE void store_cv_words(uint8_t bytes_out[32], uint32_t cv_words[8]) {
  store32(&bytes_out[0 * 4], cv_words[0]);
  store32(&bytes_out[1 * 4], cv_words[1]);
  store32(&bytes_out[2 * 4], cv_words[2]);
  store32(&bytes_out[3 * 4], cv_words[3]);
  store32(&bytes_out[4 * 4], cv_words[4]);
  store32(&bytes_out[5 * 4], cv_words[5]);
  store32(&bytes_out[6 * 4], cv_words[6]);
  store32(&bytes_out[7 * 4], cv_words[7]);
}

void blake3_compress_in_place(uint32_t cv[8],
                              const uint8_t block[BLAKE3_BLOCK_LEN],
                              uint8_t block_len, uint64_t counter,
                              uint8_t flags);

void blake3_compress_xof(const uint32_t cv[8],
                         const uint8_t block[BLAKE3_BLOCK_LEN],
                         uint8_t block_len, uint64_t counter, uint8_t flags,
                         uint8_t out[64]);

void blake3_hash_many(const uint8_t *const *inputs, size_t num_inputs,
                      size_t blocks, const uint32_t key[8], uint64_t counter,
                      bool increment_counter, uint8_t flags,
                      uint8_t flags_start, uint8_t flags_end, uint8_t *out);

size_t blake3_simd_degree(void);


// Declarations for implementation-specific functions.
void blake3_compress_in_place_portable(uint32_t cv[8],
                                       const uint8_t block[BLAKE3_BLOCK_LEN],
                                       uint8_t block_len, uint64_t counter,
                                       uint8_t flags);

void blake3_compress_xof_portable(const uint32_t cv[8],
                                  const uint8_t block[BLAKE3_BLOCK_LEN],
                                  uint8_t block_len, uint64_t counter,
                                  uint8_t flags, uint8_t out[64]);

void blake3_hash_many_portable(const uint8_t *const *inputs, size_t num_inputs,
                               size_t blocks, const uint32_t key[8],
                               uint64_t counter, bool increment_counter,
                               uint8_t flags, uint8_t flags_start,
                               uint8_t flags_end, uint8_t *out);

#if defined(IS_X86)
#if !defined(BLAKE3_NO_SSE2)
extern "C" void blake3_compress_in_place_sse2(uint32_t cv[8],
                                   const uint8_t block[BLAKE3_BLOCK_LEN],
                                   uint8_t block_len, uint64_t counter,
                                   uint8_t flags);
extern "C" void blake3_compress_xof_sse2(const uint32_t cv[8],
                              const uint8_t block[BLAKE3_BLOCK_LEN],
                              uint8_t block_len, uint64_t counter,
                              uint8_t flags, uint8_t out[64]);
extern "C" void blake3_hash_many_sse2(const uint8_t *const *inputs, size_t num_inputs,
                           size_t blocks, const uint32_t key[8],
                           uint64_t counter, bool increment_counter,
                           uint8_t flags, uint8_t flags_start,
                           uint8_t flags_end, uint8_t *out);
#endif
#if !defined(BLAKE3_NO_SSE41)
extern "C" void blake3_compress_in_place_sse41(uint32_t cv[8],
                                    const uint8_t block[BLAKE3_BLOCK_LEN],
                                    uint8_t block_len, uint64_t counter,
                                    uint8_t flags);
extern "C" void blake3_compress_xof_sse41(const uint32_t cv[8],
                               const uint8_t block[BLAKE3_BLOCK_LEN],
                               uint8_t block_len, uint64_t counter,
                               uint8_t flags, uint8_t out[64]);
extern "C" void blake3_hash_many_sse41(const uint8_t *const *inputs, size_t num_inputs,
                            size_t blocks, const uint32_t key[8],
                            uint64_t counter, bool increment_counter,
                            uint8_t flags, uint8_t flags_start,
                            uint8_t flags_end, uint8_t *out);
#endif
#if !defined(BLAKE3_NO_AVX2)
extern "C" void blake3_hash_many_avx2(const uint8_t *const *inputs, size_t num_inputs,
                           size_t blocks, const uint32_t key[8],
                           uint64_t counter, bool increment_counter,
                           uint8_t flags, uint8_t flags_start,
                           uint8_t flags_end, uint8_t *out);
#endif
#if !defined(BLAKE3_NO_AVX512)
extern "C" void blake3_compress_in_place_avx512(uint32_t cv[8],
                                     const uint8_t block[BLAKE3_BLOCK_LEN],
                                     uint8_t block_len, uint64_t counter,
                                     uint8_t flags);

extern "C" void blake3_compress_xof_avx512(const uint32_t cv[8],
                                const uint8_t block[BLAKE3_BLOCK_LEN],
                                uint8_t block_len, uint64_t counter,
                                uint8_t flags, uint8_t out[64]);

extern "C" void blake3_hash_many_avx512(const uint8_t *const *inputs, size_t num_inputs,
                             size_t blocks, const uint32_t key[8],
                             uint64_t counter, bool increment_counter,
                             uint8_t flags, uint8_t flags_start,
                             uint8_t flags_end, uint8_t *out);
#endif
#endif

#if defined(BLAKE3_USE_NEON)
void blake3_hash_many_neon(const uint8_t *const *inputs, size_t num_inputs,
                           size_t blocks, const uint32_t key[8],
                           uint64_t counter, bool increment_counter,
                           uint8_t flags, uint8_t flags_start,
                           uint8_t flags_end, uint8_t *out);
#endif


#if defined(IS_X86)
#if defined(_MSC_VER)
#include <intrin.h>
#elif defined(__GNUC__)
#include <immintrin.h>
#else
#error "Unimplemented!"
#endif
#endif

#define MAYBE_UNUSED(x) (void)((x))

#if defined(IS_X86)
static uint64_t xgetbv() {
#if defined(_MSC_VER)
  return _xgetbv(0);
#else
  uint32_t eax = 0, edx = 0;
  __asm__ __volatile__("xgetbv\n" : "=a"(eax), "=d"(edx) : "c"(0));
  return ((uint64_t)edx << 32) | eax;
#endif
}

static void cpuid(uint32_t out[4], uint32_t id) {
#if defined(_MSC_VER)
  __cpuid((int *)out, id);
#elif defined(__i386__) || defined(_M_IX86)
  __asm__ __volatile__("movl %%ebx, %1\n"
                       "cpuid\n"
                       "xchgl %1, %%ebx\n"
                       : "=a"(out[0]), "=r"(out[1]), "=c"(out[2]), "=d"(out[3])
                       : "a"(id));
#else
  __asm__ __volatile__("cpuid\n"
                       : "=a"(out[0]), "=b"(out[1]), "=c"(out[2]), "=d"(out[3])
                       : "a"(id));
#endif
}

static void cpuidex(uint32_t out[4], uint32_t id, uint32_t sid) {
#if defined(_MSC_VER)
  __cpuidex((int *)out, id, sid);
#elif defined(__i386__) || defined(_M_IX86)
  __asm__ __volatile__("movl %%ebx, %1\n"
                       "cpuid\n"
                       "xchgl %1, %%ebx\n"
                       : "=a"(out[0]), "=r"(out[1]), "=c"(out[2]), "=d"(out[3])
                       : "a"(id), "c"(sid));
#else
  __asm__ __volatile__("cpuid\n"
                       : "=a"(out[0]), "=b"(out[1]), "=c"(out[2]), "=d"(out[3])
                       : "a"(id), "c"(sid));
#endif
}

#endif
#define FRANZFIX
#define SSE2  		1
#define SSSE3 		2
#define SSE41 		4
#define AVX 		8
#define AVX2 		16
#define AVX512F 	32
#define AVX512VL 	64
#define UNDEFINED 1<<30
  

#ifdef FRANZFIX
#else
enum cpu_feature {
  SSE2 = 1 << 0,
  SSSE3 = 1 << 1,
  SSE41 = 1 << 2,
  AVX = 1 << 3,
  AVX2 = 1 << 4,
  AVX512F = 1 << 5,
  AVX512VL = 1 << 6,
  /* ... */
  UNDEFINED = 1 << 30
};
#endif

#if !defined(BLAKE3_TESTING)
static /* Allow the variable to be controlled manually for testing */
#endif
#ifdef FRANZFIX
    uint32_t g_cpu_features = UNDEFINED;
#else
    enum cpu_feature g_cpu_features = UNDEFINED;
#endif


#if !defined(BLAKE3_TESTING)
static
#endif

///	This is C++ compatible fix
#ifdef FRANZFIX
	uint32_t
#else
    enum cpu_feature
#endif

    get_cpu_features() {

  if (g_cpu_features != UNDEFINED) {
    return g_cpu_features;
  } else {
#if defined(IS_X86)
    uint32_t regs[4] = {0};
    uint32_t *eax = &regs[0], *ebx = &regs[1], *ecx = &regs[2], *edx = &regs[3];
    (void)edx;
#ifdef FRANZFIX
    uint32_t features = 0;
#else
    enum cpu_feature features = 0;
#endif

    cpuid(regs, 0);
    const int max_id = *eax;
    cpuid(regs, 1);
#if defined(__amd64__) || defined(_M_X64)
    features |= SSE2;
#else
    if (*edx & (1UL << 26))
      features |= SSE2;
#endif
    if (*ecx & (1UL << 0))
      features |= SSSE3;
    if (*ecx & (1UL << 19))
      features |= SSE41;

    if (*ecx & (1UL << 27)) { // OSXSAVE
      const uint64_t mask = xgetbv();
      if ((mask & 6) == 6) { // SSE and AVX states
        if (*ecx & (1UL << 28))
          features |= AVX;
        if (max_id >= 7) {
          cpuidex(regs, 7, 0);
          if (*ebx & (1UL << 5))
            features |= AVX2;
          if ((mask & 224) == 224) { // Opmask, ZMM_Hi256, Hi16_Zmm
            if (*ebx & (1UL << 31))
              features |= AVX512VL;
            if (*ebx & (1UL << 16))
              features |= AVX512F;
          }
        }
      }
    }
	//features=8;
	g_cpu_features = features;
	if (flagdebug)
	printf("CPU feature %04X\n",features); // zeke
    return features;
#else
    /* How to detect NEON? */
    return 0;
#endif
  }
}

void blake3_compress_in_place(uint32_t cv[8],
                              const uint8_t block[BLAKE3_BLOCK_LEN],
                              uint8_t block_len, uint64_t counter,
                              uint8_t flags) {
#if defined(IS_X86)
#ifdef FRANZFIX
  uint32_t features = get_cpu_features();
#else
  const enum cpu_feature features = get_cpu_features();
#endif

  MAYBE_UNUSED(features);
#if !defined(BLAKE3_NO_AVX512)
  if (features & AVX512VL) {
    blake3_compress_in_place_avx512(cv, block, block_len, counter, flags);
    return;
  }
#endif
#if !defined(BLAKE3_NO_SSE41)
  if (features & SSE41) {
    blake3_compress_in_place_sse41(cv, block, block_len, counter, flags);
    return;
  }
#endif
#if !defined(BLAKE3_NO_SSE2)
  if (features & SSE2) {
    blake3_compress_in_place_sse2(cv, block, block_len, counter, flags);
    return;
  }
#endif
#endif
  blake3_compress_in_place_portable(cv, block, block_len, counter, flags);
}

void blake3_compress_xof(const uint32_t cv[8],
                         const uint8_t block[BLAKE3_BLOCK_LEN],
                         uint8_t block_len, uint64_t counter, uint8_t flags,
                         uint8_t out[64]) {
#if defined(IS_X86)
#ifdef FRANZFIX
  const uint32_t features = get_cpu_features();
#else
  const enum cpu_feature features = get_cpu_features();
#endif

  MAYBE_UNUSED(features);
#if !defined(BLAKE3_NO_AVX512)
  if (features & AVX512VL) {
    blake3_compress_xof_avx512(cv, block, block_len, counter, flags, out);
    return;
  }
#endif
#if !defined(BLAKE3_NO_SSE41)
  if (features & SSE41) {
    blake3_compress_xof_sse41(cv, block, block_len, counter, flags, out);
    return;
  }
#endif
#if !defined(BLAKE3_NO_SSE2)
  if (features & SSE2) {
    blake3_compress_xof_sse2(cv, block, block_len, counter, flags, out);
    return;
  }
#endif
#endif
  blake3_compress_xof_portable(cv, block, block_len, counter, flags, out);
}

void blake3_hash_many(const uint8_t *const *inputs, size_t num_inputs,
                      size_t blocks, const uint32_t key[8], uint64_t counter,
                      bool increment_counter, uint8_t flags,
                      uint8_t flags_start, uint8_t flags_end, uint8_t *out) {
#if defined(IS_X86)
#ifdef FRANZFIX
  const uint32_t features = get_cpu_features();
#else
  const enum cpu_feature features = get_cpu_features();
#endif
  MAYBE_UNUSED(features);
#if !defined(BLAKE3_NO_AVX512)
  if ((features & (AVX512F|AVX512VL)) == (AVX512F|AVX512VL)) {
    blake3_hash_many_avx512(inputs, num_inputs, blocks, key, counter,
                            increment_counter, flags, flags_start, flags_end,
                            out);
    return;
  }
#endif
#if !defined(BLAKE3_NO_AVX2)
  if (features & AVX2) {
    blake3_hash_many_avx2(inputs, num_inputs, blocks, key, counter,
                          increment_counter, flags, flags_start, flags_end,
                          out);
    return;
  }
#endif
#if !defined(BLAKE3_NO_SSE41)
  if (features & SSE41) {
    blake3_hash_many_sse41(inputs, num_inputs, blocks, key, counter,
                           increment_counter, flags, flags_start, flags_end,
                           out);
    return;
  }
#endif
#if !defined(BLAKE3_NO_SSE2)
  if (features & SSE2) {
    blake3_hash_many_sse2(inputs, num_inputs, blocks, key, counter,
                          increment_counter, flags, flags_start, flags_end,
                          out);
    return;
  }
#endif
#endif

#if defined(BLAKE3_USE_NEON)
  blake3_hash_many_neon(inputs, num_inputs, blocks, key, counter,
                        increment_counter, flags, flags_start, flags_end, out);
  return;
#endif

  blake3_hash_many_portable(inputs, num_inputs, blocks, key, counter,
                            increment_counter, flags, flags_start, flags_end,
                            out);
}

// The dynamically detected SIMD degree of the current platform.
size_t blake3_simd_degree(void) {
#if defined(IS_X86)
#ifdef FRANZFIX
  uint32_t features = get_cpu_features();
#else
  const enum cpu_feature features = get_cpu_features();
#endif
  MAYBE_UNUSED(features);
#if !defined(BLAKE3_NO_AVX512)
  if ((features & (AVX512F|AVX512VL)) == (AVX512F|AVX512VL)) {
    return 16;
  }
#endif
#if !defined(BLAKE3_NO_AVX2)
  if (features & AVX2) {
    return 8;
  }
#endif
#if !defined(BLAKE3_NO_SSE41)
  if (features & SSE41) {
    return 4;
  }
#endif
#if !defined(BLAKE3_NO_SSE2)
  if (features & SSE2) {
    return 4;
  }
#endif
#endif
#if defined(BLAKE3_USE_NEON)
  return 4;
#endif
  return 1;
}




INLINE uint32_t rotr32(uint32_t w, uint32_t c) {
  return (w >> c) | (w << (32 - c));
}

INLINE void g(uint32_t *state, size_t a, size_t b, size_t c, size_t d,
              uint32_t x, uint32_t y) {
  state[a] = state[a] + state[b] + x;
  state[d] = rotr32(state[d] ^ state[a], 16);
  state[c] = state[c] + state[d];
  state[b] = rotr32(state[b] ^ state[c], 12);
  state[a] = state[a] + state[b] + y;
  state[d] = rotr32(state[d] ^ state[a], 8);
  state[c] = state[c] + state[d];
  state[b] = rotr32(state[b] ^ state[c], 7);
}

INLINE void round_fn(uint32_t state[16], const uint32_t *msg, size_t round) {
  // Select the message schedule based on the round.
  const uint8_t *schedule = MSG_SCHEDULE[round];

  // Mix the columns.
  g(state, 0, 4, 8, 12, msg[schedule[0]], msg[schedule[1]]);
  g(state, 1, 5, 9, 13, msg[schedule[2]], msg[schedule[3]]);
  g(state, 2, 6, 10, 14, msg[schedule[4]], msg[schedule[5]]);
  g(state, 3, 7, 11, 15, msg[schedule[6]], msg[schedule[7]]);

  // Mix the rows.
  g(state, 0, 5, 10, 15, msg[schedule[8]], msg[schedule[9]]);
  g(state, 1, 6, 11, 12, msg[schedule[10]], msg[schedule[11]]);
  g(state, 2, 7, 8, 13, msg[schedule[12]], msg[schedule[13]]);
  g(state, 3, 4, 9, 14, msg[schedule[14]], msg[schedule[15]]);
}

INLINE void compress_pre(uint32_t state[16], const uint32_t cv[8],
                         const uint8_t block[BLAKE3_BLOCK_LEN],
                         uint8_t block_len, uint64_t counter, uint8_t flags) {
  uint32_t block_words[16];
  block_words[0] = load32(block + 4 * 0);
  block_words[1] = load32(block + 4 * 1);
  block_words[2] = load32(block + 4 * 2);
  block_words[3] = load32(block + 4 * 3);
  block_words[4] = load32(block + 4 * 4);
  block_words[5] = load32(block + 4 * 5);
  block_words[6] = load32(block + 4 * 6);
  block_words[7] = load32(block + 4 * 7);
  block_words[8] = load32(block + 4 * 8);
  block_words[9] = load32(block + 4 * 9);
  block_words[10] = load32(block + 4 * 10);
  block_words[11] = load32(block + 4 * 11);
  block_words[12] = load32(block + 4 * 12);
  block_words[13] = load32(block + 4 * 13);
  block_words[14] = load32(block + 4 * 14);
  block_words[15] = load32(block + 4 * 15);

  state[0] = cv[0];
  state[1] = cv[1];
  state[2] = cv[2];
  state[3] = cv[3];
  state[4] = cv[4];
  state[5] = cv[5];
  state[6] = cv[6];
  state[7] = cv[7];
  state[8] = IV[0];
  state[9] = IV[1];
  state[10] = IV[2];
  state[11] = IV[3];
  state[12] = counter_low(counter);
  state[13] = counter_high(counter);
  state[14] = (uint32_t)block_len;
  state[15] = (uint32_t)flags;

  round_fn(state, &block_words[0], 0);
  round_fn(state, &block_words[0], 1);
  round_fn(state, &block_words[0], 2);
  round_fn(state, &block_words[0], 3);
  round_fn(state, &block_words[0], 4);
  round_fn(state, &block_words[0], 5);
  round_fn(state, &block_words[0], 6);
}

void blake3_compress_in_place_portable(uint32_t cv[8],
                                       const uint8_t block[BLAKE3_BLOCK_LEN],
                                       uint8_t block_len, uint64_t counter,
                                       uint8_t flags) {
  uint32_t state[16];
  compress_pre(state, cv, block, block_len, counter, flags);
  cv[0] = state[0] ^ state[8];
  cv[1] = state[1] ^ state[9];
  cv[2] = state[2] ^ state[10];
  cv[3] = state[3] ^ state[11];
  cv[4] = state[4] ^ state[12];
  cv[5] = state[5] ^ state[13];
  cv[6] = state[6] ^ state[14];
  cv[7] = state[7] ^ state[15];
}

void blake3_compress_xof_portable(const uint32_t cv[8],
                                  const uint8_t block[BLAKE3_BLOCK_LEN],
                                  uint8_t block_len, uint64_t counter,
                                  uint8_t flags, uint8_t out[64]) {
  uint32_t state[16];
  compress_pre(state, cv, block, block_len, counter, flags);

  store32(&out[0 * 4], state[0] ^ state[8]);
  store32(&out[1 * 4], state[1] ^ state[9]);
  store32(&out[2 * 4], state[2] ^ state[10]);
  store32(&out[3 * 4], state[3] ^ state[11]);
  store32(&out[4 * 4], state[4] ^ state[12]);
  store32(&out[5 * 4], state[5] ^ state[13]);
  store32(&out[6 * 4], state[6] ^ state[14]);
  store32(&out[7 * 4], state[7] ^ state[15]);
  store32(&out[8 * 4], state[8] ^ cv[0]);
  store32(&out[9 * 4], state[9] ^ cv[1]);
  store32(&out[10 * 4], state[10] ^ cv[2]);
  store32(&out[11 * 4], state[11] ^ cv[3]);
  store32(&out[12 * 4], state[12] ^ cv[4]);
  store32(&out[13 * 4], state[13] ^ cv[5]);
  store32(&out[14 * 4], state[14] ^ cv[6]);
  store32(&out[15 * 4], state[15] ^ cv[7]);
}

INLINE void hash_one_portable(const uint8_t *input, size_t blocks,
                              const uint32_t key[8], uint64_t counter,
                              uint8_t flags, uint8_t flags_start,
                              uint8_t flags_end, uint8_t out[BLAKE3_OUT_LEN]) {
  uint32_t cv[8];
  memcpy(cv, key, BLAKE3_KEY_LEN);
  uint8_t block_flags = flags | flags_start;
  while (blocks > 0) {
    if (blocks == 1) {
      block_flags |= flags_end;
    }
    blake3_compress_in_place_portable(cv, input, BLAKE3_BLOCK_LEN, counter,
                                      block_flags);
    input = &input[BLAKE3_BLOCK_LEN];
    blocks -= 1;
    block_flags = flags;
  }
  store_cv_words(out, cv);
}

void blake3_hash_many_portable(const uint8_t *const *inputs, size_t num_inputs,
                               size_t blocks, const uint32_t key[8],
                               uint64_t counter, bool increment_counter,
                               uint8_t flags, uint8_t flags_start,
                               uint8_t flags_end, uint8_t *out) {
  while (num_inputs > 0) {
    hash_one_portable(inputs[0], blocks, key, counter, flags, flags_start,
                      flags_end, out);
    if (increment_counter) {
      counter += 1;
    }
    inputs += 1;
    num_inputs -= 1;
    out = &out[BLAKE3_OUT_LEN];
  }
}


const char *blake3_version(void) { return BLAKE3_VERSION_STRING; }

INLINE void chunk_state_init(blake3_chunk_state *self, const uint32_t key[8],
                             uint8_t flags) {
  memcpy(self->cv, key, BLAKE3_KEY_LEN);
  self->chunk_counter = 0;
  memset(self->buf, 0, BLAKE3_BLOCK_LEN);
  self->buf_len = 0;
  self->blocks_compressed = 0;
  self->flags = flags;
}

INLINE void chunk_state_reset(blake3_chunk_state *self, const uint32_t key[8],
                              uint64_t chunk_counter) {
  memcpy(self->cv, key, BLAKE3_KEY_LEN);
  self->chunk_counter = chunk_counter;
  self->blocks_compressed = 0;
  memset(self->buf, 0, BLAKE3_BLOCK_LEN);
  self->buf_len = 0;
}

INLINE size_t chunk_state_len(const blake3_chunk_state *self) {
  return (BLAKE3_BLOCK_LEN * (size_t)self->blocks_compressed) +
         ((size_t)self->buf_len);
}

INLINE size_t chunk_state_fill_buf(blake3_chunk_state *self,
                                   const uint8_t *input, size_t input_len) {
  size_t take = BLAKE3_BLOCK_LEN - ((size_t)self->buf_len);
  if (take > input_len) {
    take = input_len;
  }
  uint8_t *dest = self->buf + ((size_t)self->buf_len);
  memcpy(dest, input, take);
  self->buf_len += (uint8_t)take;
  return take;
}

INLINE uint8_t chunk_state_maybe_start_flag(const blake3_chunk_state *self) {
  if (self->blocks_compressed == 0) {
    return CHUNK_START;
  } else {
    return 0;
  }
}

typedef struct {
  uint32_t input_cv[8];
  uint64_t counter;
  uint8_t block[BLAKE3_BLOCK_LEN];
  uint8_t block_len;
  uint8_t flags;
} output_t;

INLINE output_t make_output(const uint32_t input_cv[8],
                            const uint8_t block[BLAKE3_BLOCK_LEN],
                            uint8_t block_len, uint64_t counter,
                            uint8_t flags) {
  output_t ret;
  memcpy(ret.input_cv, input_cv, 32);
  memcpy(ret.block, block, BLAKE3_BLOCK_LEN);
  ret.block_len = block_len;
  ret.counter = counter;
  ret.flags = flags;
  return ret;
}

// Chaining values within a given chunk (specifically the compress_in_place
// interface) are represented as words. This avoids unnecessary bytes<->words
// conversion overhead in the portable implementation. However, the hash_many
// interface handles both user input and parent node blocks, so it accepts
// bytes. For that reason, chaining values in the CV stack are represented as
// bytes.
INLINE void output_chaining_value(const output_t *self, uint8_t cv[32]) {
  uint32_t cv_words[8];
  memcpy(cv_words, self->input_cv, 32);
  blake3_compress_in_place(cv_words, self->block, self->block_len,
                           self->counter, self->flags);
  store_cv_words(cv, cv_words);
}

INLINE void output_root_bytes(const output_t *self, uint64_t seek, uint8_t *out,
                              size_t out_len) {
  uint64_t output_block_counter = seek / 64;
  size_t offset_within_block = seek % 64;
  uint8_t wide_buf[64];
  while (out_len > 0) {
    blake3_compress_xof(self->input_cv, self->block, self->block_len,
                        output_block_counter, self->flags | ROOT, wide_buf);
    size_t available_bytes = 64 - offset_within_block;
    size_t memcpy_len;
    if (out_len > available_bytes) {
      memcpy_len = available_bytes;
    } else {
      memcpy_len = out_len;
    }
    memcpy(out, wide_buf + offset_within_block, memcpy_len);
    out += memcpy_len;
    out_len -= memcpy_len;
    output_block_counter += 1;
    offset_within_block = 0;
  }
}

INLINE void chunk_state_update(blake3_chunk_state *self, const uint8_t *input,
                               size_t input_len) {
  if (self->buf_len > 0) {
    size_t take = chunk_state_fill_buf(self, input, input_len);
    input += take;
    input_len -= take;
    if (input_len > 0) {
      blake3_compress_in_place(
          self->cv, self->buf, BLAKE3_BLOCK_LEN, self->chunk_counter,
          self->flags | chunk_state_maybe_start_flag(self));
      self->blocks_compressed += 1;
      self->buf_len = 0;
      memset(self->buf, 0, BLAKE3_BLOCK_LEN);
    }
  }

  while (input_len > BLAKE3_BLOCK_LEN) {
    blake3_compress_in_place(self->cv, input, BLAKE3_BLOCK_LEN,
                             self->chunk_counter,
                             self->flags | chunk_state_maybe_start_flag(self));
    self->blocks_compressed += 1;
    input += BLAKE3_BLOCK_LEN;
    input_len -= BLAKE3_BLOCK_LEN;
  }

  size_t take = chunk_state_fill_buf(self, input, input_len);
  input += take;
  input_len -= take;
}

INLINE output_t chunk_state_output(const blake3_chunk_state *self) {
  uint8_t block_flags =
      self->flags | chunk_state_maybe_start_flag(self) | CHUNK_END;
  return make_output(self->cv, self->buf, self->buf_len, self->chunk_counter,
                     block_flags);
}

INLINE output_t parent_output(const uint8_t block[BLAKE3_BLOCK_LEN],
                              const uint32_t key[8], uint8_t flags) {
  return make_output(key, block, BLAKE3_BLOCK_LEN, 0, flags | PARENT);
}

// Given some input larger than one chunk, return the number of bytes that
// should go in the left subtree. This is the largest power-of-2 number of
// chunks that leaves at least 1 byte for the right subtree.
INLINE size_t left_len(size_t content_len) {
  // Subtract 1 to reserve at least one byte for the right side. content_len
  // should always be greater than BLAKE3_CHUNK_LEN.
  size_t full_chunks = (content_len - 1) / BLAKE3_CHUNK_LEN;
  return round_down_to_power_of_2(full_chunks) * BLAKE3_CHUNK_LEN;
}

// Use SIMD parallelism to hash up to MAX_SIMD_DEGREE chunks at the same time
// on a single thread. Write out the chunk chaining values and return the
// number of chunks hashed. These chunks are never the root and never empty;
// those cases use a different codepath.
INLINE size_t compress_chunks_parallel(const uint8_t *input, size_t input_len,
                                       const uint32_t key[8],
                                       uint64_t chunk_counter, uint8_t flags,
                                       uint8_t *out) {
#if defined(BLAKE3_TESTING)
  assert(0 < input_len);
  assert(input_len <= MAX_SIMD_DEGREE * BLAKE3_CHUNK_LEN);
#endif

  const uint8_t *chunks_array[MAX_SIMD_DEGREE];
  size_t input_position = 0;
  size_t chunks_array_len = 0;
  while (input_len - input_position >= BLAKE3_CHUNK_LEN) {
    chunks_array[chunks_array_len] = &input[input_position];
    input_position += BLAKE3_CHUNK_LEN;
    chunks_array_len += 1;
  }

  blake3_hash_many(chunks_array, chunks_array_len,
                   BLAKE3_CHUNK_LEN / BLAKE3_BLOCK_LEN, key, chunk_counter,
                   true, flags, CHUNK_START, CHUNK_END, out);

  // Hash the remaining partial chunk, if there is one. Note that the empty
  // chunk (meaning the empty message) is a different codepath.
  if (input_len > input_position) {
    uint64_t counter = chunk_counter + (uint64_t)chunks_array_len;
    blake3_chunk_state chunk_state;
    chunk_state_init(&chunk_state, key, flags);
    chunk_state.chunk_counter = counter;
    chunk_state_update(&chunk_state, &input[input_position],
                       input_len - input_position);
    output_t output = chunk_state_output(&chunk_state);
    output_chaining_value(&output, &out[chunks_array_len * BLAKE3_OUT_LEN]);
    return chunks_array_len + 1;
  } else {
    return chunks_array_len;
  }
}

// Use SIMD parallelism to hash up to MAX_SIMD_DEGREE parents at the same time
// on a single thread. Write out the parent chaining values and return the
// number of parents hashed. (If there's an odd input chaining value left over,
// return it as an additional output.) These parents are never the root and
// never empty; those cases use a different codepath.
INLINE size_t compress_parents_parallel(const uint8_t *child_chaining_values,
                                        size_t num_chaining_values,
                                        const uint32_t key[8], uint8_t flags,
                                        uint8_t *out) {
#if defined(BLAKE3_TESTING)
  assert(2 <= num_chaining_values);
  assert(num_chaining_values <= 2 * MAX_SIMD_DEGREE_OR_2);
#endif

  const uint8_t *parents_array[MAX_SIMD_DEGREE_OR_2];
  size_t parents_array_len = 0;
  while (num_chaining_values - (2 * parents_array_len) >= 2) {
    parents_array[parents_array_len] =
        &child_chaining_values[2 * parents_array_len * BLAKE3_OUT_LEN];
    parents_array_len += 1;
  }

  blake3_hash_many(parents_array, parents_array_len, 1, key,
                   0, // Parents always use counter 0.
                   false, flags | PARENT,
                   0, // Parents have no start flags.
                   0, // Parents have no end flags.
                   out);

  // If there's an odd child left over, it becomes an output.
  if (num_chaining_values > 2 * parents_array_len) {
    memcpy(&out[parents_array_len * BLAKE3_OUT_LEN],
           &child_chaining_values[2 * parents_array_len * BLAKE3_OUT_LEN],
           BLAKE3_OUT_LEN);
    return parents_array_len + 1;
  } else {
    return parents_array_len;
  }
}

static size_t blake3_compress_subtree_wide(const uint8_t *input,
                                           size_t input_len,
                                           const uint32_t key[8],
                                           uint64_t chunk_counter,
                                           uint8_t flags, uint8_t *out) {
  // Note that the single chunk case does *not* bump the SIMD degree up to 2
  // when it is 1. If this implementation adds multi-threading in the future,
  // this gives us the option of multi-threading even the 2-chunk case, which
  // can help performance on smaller platforms.
  if (input_len <= blake3_simd_degree() * BLAKE3_CHUNK_LEN) {
    return compress_chunks_parallel(input, input_len, key, chunk_counter, flags,
                                    out);
  }

  // With more than simd_degree chunks, we need to recurse. Start by dividing
  // the input into left and right subtrees. (Note that this is only optimal
  // as long as the SIMD degree is a power of 2. If we ever get a SIMD degree
  // of 3 or something, we'll need a more complicated strategy.)
  size_t left_input_len = left_len(input_len);
  size_t right_input_len = input_len - left_input_len;
  const uint8_t *right_input = &input[left_input_len];
  uint64_t right_chunk_counter =
      chunk_counter + (uint64_t)(left_input_len / BLAKE3_CHUNK_LEN);

  // Make space for the child outputs. Here we use MAX_SIMD_DEGREE_OR_2 to
  // account for the special case of returning 2 outputs when the SIMD degree
  // is 1.
  uint8_t cv_array[2 * MAX_SIMD_DEGREE_OR_2 * BLAKE3_OUT_LEN];
  size_t degree = blake3_simd_degree();
  if (left_input_len > BLAKE3_CHUNK_LEN && degree == 1) {
    // The special case: We always use a degree of at least two, to make
    // sure there are two outputs. Except, as noted above, at the chunk
    // level, where we allow degree=1. (Note that the 1-chunk-input case is
    // a different codepath.)
    degree = 2;
  }
  uint8_t *right_cvs = &cv_array[degree * BLAKE3_OUT_LEN];

  // Recurse! If this implementation adds multi-threading support in the
  // future, this is where it will go.
  size_t left_n = blake3_compress_subtree_wide(input, left_input_len, key,
                                               chunk_counter, flags, cv_array);
  size_t right_n = blake3_compress_subtree_wide(
      right_input, right_input_len, key, right_chunk_counter, flags, right_cvs);

  // The special case again. If simd_degree=1, then we'll have left_n=1 and
  // right_n=1. Rather than compressing them into a single output, return
  // them directly, to make sure we always have at least two outputs.
  if (left_n == 1) {
    memcpy(out, cv_array, 2 * BLAKE3_OUT_LEN);
    return 2;
  }

  // Otherwise, do one layer of parent node compression.
  size_t num_chaining_values = left_n + right_n;
  return compress_parents_parallel(cv_array, num_chaining_values, key, flags,
                                   out);
}

INLINE void compress_subtree_to_parent_node(
    const uint8_t *input, size_t input_len, const uint32_t key[8],
    uint64_t chunk_counter, uint8_t flags, uint8_t out[2 * BLAKE3_OUT_LEN]) {
#if defined(BLAKE3_TESTING)
  assert(input_len > BLAKE3_CHUNK_LEN);
#endif

  uint8_t cv_array[MAX_SIMD_DEGREE_OR_2 * BLAKE3_OUT_LEN];
  size_t num_cvs = blake3_compress_subtree_wide(input, input_len, key,
                                                chunk_counter, flags, cv_array);

  // If MAX_SIMD_DEGREE is greater than 2 and there's enough input,
  // compress_subtree_wide() returns more than 2 chaining values. Condense
  // them into 2 by forming parent nodes repeatedly.
  uint8_t out_array[MAX_SIMD_DEGREE_OR_2 * BLAKE3_OUT_LEN / 2];
  while (num_cvs > 2) {
    num_cvs =
        compress_parents_parallel(cv_array, num_cvs, key, flags, out_array);
    memcpy(cv_array, out_array, num_cvs * BLAKE3_OUT_LEN);
  }
  memcpy(out, cv_array, 2 * BLAKE3_OUT_LEN);
}

INLINE void hasher_init_base(blake3_hasher *self, const uint32_t key[8],
                             uint8_t flags) {
  memcpy(self->key, key, BLAKE3_KEY_LEN);
  chunk_state_init(&self->chunk, key, flags);
  self->cv_stack_len = 0;
}

void blake3_hasher_init(blake3_hasher *self) { hasher_init_base(self, IV, 0); }


void blake3_hasher_init_derive_key_raw(blake3_hasher *self, const void *context,
                                       size_t context_len) {
  blake3_hasher context_hasher;
  hasher_init_base(&context_hasher, IV, DERIVE_KEY_CONTEXT);
  blake3_hasher_update(&context_hasher, context, context_len);
  uint8_t context_key[BLAKE3_KEY_LEN];
  blake3_hasher_finalize(&context_hasher, context_key, BLAKE3_KEY_LEN);
  uint32_t context_key_words[8];
  load_key_words(context_key, context_key_words);
  hasher_init_base(self, context_key_words, DERIVE_KEY_MATERIAL);
}

void blake3_hasher_init_derive_key(blake3_hasher *self, const char *context) {
  blake3_hasher_init_derive_key_raw(self, context, strlen(context));
}

INLINE void hasher_merge_cv_stack(blake3_hasher *self, uint64_t total_len) {
  size_t post_merge_stack_len = (size_t)popcnt(total_len);
  while (self->cv_stack_len > post_merge_stack_len) {
    uint8_t *parent_node =
        &self->cv_stack[(self->cv_stack_len - 2) * BLAKE3_OUT_LEN];
    output_t output = parent_output(parent_node, self->key, self->chunk.flags);
    output_chaining_value(&output, parent_node);
    self->cv_stack_len -= 1;
  }
}

INLINE void hasher_push_cv(blake3_hasher *self, uint8_t new_cv[BLAKE3_OUT_LEN],
                           uint64_t chunk_counter) {
  hasher_merge_cv_stack(self, chunk_counter);
  memcpy(&self->cv_stack[self->cv_stack_len * BLAKE3_OUT_LEN], new_cv,
         BLAKE3_OUT_LEN);
  self->cv_stack_len += 1;
}

void blake3_hasher_update(blake3_hasher *self, const void *input,
                          size_t input_len) {
  // Explicitly checking for zero avoids causing UB by passing a null pointer
  // to memcpy. This comes up in practice with things like:
  //   std::vector<uint8_t> v;
  //   blake3_hasher_update(&hasher, v.data(), v.size());
  if (input_len == 0) {
    return;
  }

  const uint8_t *input_bytes = (const uint8_t *)input;

  // If we have some partial chunk bytes in the internal chunk_state, we need
  // to finish that chunk first.
  if (chunk_state_len(&self->chunk) > 0) {
    size_t take = BLAKE3_CHUNK_LEN - chunk_state_len(&self->chunk);
    if (take > input_len) {
      take = input_len;
    }
    chunk_state_update(&self->chunk, input_bytes, take);
    input_bytes += take;
    input_len -= take;
    // If we've filled the current chunk and there's more coming, finalize this
    // chunk and proceed. In this case we know it's not the root.
    if (input_len > 0) {
      output_t output = chunk_state_output(&self->chunk);
      uint8_t chunk_cv[32];
      output_chaining_value(&output, chunk_cv);
      hasher_push_cv(self, chunk_cv, self->chunk.chunk_counter);
      chunk_state_reset(&self->chunk, self->key, self->chunk.chunk_counter + 1);
    } else {
      return;
    }
  }

  while (input_len > BLAKE3_CHUNK_LEN) {
    size_t subtree_len = round_down_to_power_of_2(input_len);
    uint64_t count_so_far = self->chunk.chunk_counter * BLAKE3_CHUNK_LEN;
    while ((((uint64_t)(subtree_len - 1)) & count_so_far) != 0) {
      subtree_len /= 2;
    }
    // The shrunken subtree_len might now be 1 chunk long. If so, hash that one
    // chunk by itself. Otherwise, compress the subtree into a pair of CVs.
    uint64_t subtree_chunks = subtree_len / BLAKE3_CHUNK_LEN;
    if (subtree_len <= BLAKE3_CHUNK_LEN) {
      blake3_chunk_state chunk_state;
      chunk_state_init(&chunk_state, self->key, self->chunk.flags);
      chunk_state.chunk_counter = self->chunk.chunk_counter;
      chunk_state_update(&chunk_state, input_bytes, subtree_len);
      output_t output = chunk_state_output(&chunk_state);
      uint8_t cv[BLAKE3_OUT_LEN];
      output_chaining_value(&output, cv);
      hasher_push_cv(self, cv, chunk_state.chunk_counter);
    } else {
      // This is the high-performance happy path, though getting here depends
      // on the caller giving us a long enough input.
      uint8_t cv_pair[2 * BLAKE3_OUT_LEN];
      compress_subtree_to_parent_node(input_bytes, subtree_len, self->key,
                                      self->chunk.chunk_counter,
                                      self->chunk.flags, cv_pair);
      hasher_push_cv(self, cv_pair, self->chunk.chunk_counter);
      hasher_push_cv(self, &cv_pair[BLAKE3_OUT_LEN],
                     self->chunk.chunk_counter + (subtree_chunks / 2));
    }
    self->chunk.chunk_counter += subtree_chunks;
    input_bytes += subtree_len;
    input_len -= subtree_len;
  }

  // If there's any remaining input less than a full chunk, add it to the chunk
  // state. In that case, also do a final merge loop to make sure the subtree
  // stack doesn't contain any unmerged pairs. The remaining input means we
  // know these merges are non-root. This merge loop isn't strictly necessary
  // here, because hasher_push_chunk_cv already does its own merge loop, but it
  // simplifies blake3_hasher_finalize below.
  if (input_len > 0) {
    chunk_state_update(&self->chunk, input_bytes, input_len);
    hasher_merge_cv_stack(self, self->chunk.chunk_counter);
  }
}

void blake3_hasher_finalize(const blake3_hasher *self, uint8_t *out,
                            size_t out_len) {
  blake3_hasher_finalize_seek(self, 0, out, out_len);
}

void blake3_hasher_finalize_seek(const blake3_hasher *self, uint64_t seek,
                                 uint8_t *out, size_t out_len) {
  // Explicitly checking for zero avoids causing UB by passing a null pointer
  // to memcpy. This comes up in practice with things like:
  //   std::vector<uint8_t> v;
  //   blake3_hasher_finalize(&hasher, v.data(), v.size());
  if (out_len == 0) {
    return;
  }

  // If the subtree stack is empty, then the current chunk is the root.
  if (self->cv_stack_len == 0) {
    output_t output = chunk_state_output(&self->chunk);
    output_root_bytes(&output, seek, out, out_len);
    return;
  }
  // If there are any bytes in the chunk state, finalize that chunk and do a
  // roll-up merge between that chunk hash and every subtree in the stack. In
  // this case, the extra merge loop at the end of blake3_hasher_update
  // guarantees that none of the subtrees in the stack need to be merged with
  // each other first. Otherwise, if there are no bytes in the chunk state,
  // then the top of the stack is a chunk hash, and we start the merge from
  // that.
  output_t output;
  size_t cvs_remaining;
  if (chunk_state_len(&self->chunk) > 0) {
    cvs_remaining = self->cv_stack_len;
    output = chunk_state_output(&self->chunk);
  } else {
    // There are always at least 2 CVs in the stack in this case.
    cvs_remaining = self->cv_stack_len - 2;
    output = parent_output(&self->cv_stack[cvs_remaining * 32], self->key,
                           self->chunk.flags);
  }
  while (cvs_remaining > 0) {
    cvs_remaining -= 1;
    uint8_t parent_block[BLAKE3_BLOCK_LEN];
    memcpy(parent_block, &self->cv_stack[cvs_remaining * 32], 32);
    output_chaining_value(&output, &parent_block[32]);
    output = parent_output(parent_block, self->key, self->chunk.flags);
  }
  output_root_bytes(&output, seek, out, out_len);
}



#endif ///HWBLAKE3




/**
 * The Whirlpool hashing function.
 *
 * <P>
 * <b>References</b>
 *
 * <P>
 * The Whirlpool algorithm was developed by
 * <a href="mailto:pbarreto@scopus.com.br">Paulo S. L. M. Barreto</a> and
 * <a href="mailto:vincent.rijmen@cryptomathic.com">Vincent Rijmen</a>.
 */

typedef signed char s8;
typedef unsigned char u8;

#if UINT_MAX >= 4294967295UL

typedef signed short s16;
typedef signed int s32;
typedef unsigned short u16;
typedef unsigned int u32;

#define ONE32   0xffffffffU

#else

typedef signed int s16;
typedef signed long s32;
typedef unsigned int u16;
typedef unsigned long u32;

#define ONE32   0xffffffffUL

#endif

#define ONE8    0xffU
#define ONE16   0xffffU

#define T8(x)   ((x) & ONE8)
#define T16(x)  ((x) & ONE16)
#define T32(x)  ((x) & ONE32)

#ifdef _MSC_VER
typedef unsigned __int64 u64;
typedef signed __int64 s64;
#define LL(v)   (v##i64)
#define ONE64   LL(0xffffffffffffffff)
#else  /* !_MSC_VER */
typedef unsigned long long u64;
typedef signed long long s64;
#define LL(v)   (v##ULL)
#define ONE64   LL(0xffffffffffffffff)
#endif /* ?_MSC_VER */
#define T64(x)  ((x) & ONE64)
#define ROTR64(v, n)   (((v) >> (n)) | T64((v) << (64 - (n))))
/*
 * Note: the test is used to detect native 64-bit architectures;
 * if the unsigned long is strictly greater than 32-bit, it is
 * assumed to be at least 64-bit. This will not work correctly
 * on (old) 36-bit architectures (PDP-11 for instance).
 *
 * On non-64-bit architectures, "long long" is used.
 */

/*
 * U8TO32_BIG(c) returns the 32-bit value stored in big-endian convention
 * in the unsigned char array pointed to by c.
 */
#define U8TO32_BIG(c)  (((u32)T8(*(c)) << 24) | ((u32)T8(*((c) + 1)) << 16) | ((u32)T8(*((c) + 2)) << 8) | ((u32)T8(*((c) + 3))))
#define U8TO32_LITTLE(c)  (((u32)T8(*(c))) | ((u32)T8(*((c) + 1)) << 8) | (u32)T8(*((c) + 2)) << 16) | ((u32)T8(*((c) + 3)) << 24))
#define U32TO8_BIG(c, v)    do { u32 x = (v); u8 *d = (c); d[0] = T8(x >> 24); d[1] = T8(x >> 16); d[2] = T8(x >> 8); d[3] = T8(x); } while (0)
#define U32TO8_LITTLE(c, v)    do { u32 x = (v); u8 *d = (c); d[0] = T8(x); d[1] = T8(x >> 8); d[2] = T8(x >> 16); d[3] = T8(x >> 24); } while (0)
#define ROTL32(v, n)   (T32((v) << (n)) | ((v) >> (32 - (n))))

/*
 * Whirlpool-specific definitions.
 */

#define DIGESTBYTES 64
#define DIGESTBITS  (8*DIGESTBYTES) /* 512 */

#define WBLOCKBYTES 64
#define WBLOCKBITS  (8*WBLOCKBYTES) /* 512 */

#define LENGTHBYTES 32
#define LENGTHBITS  (8*LENGTHBYTES) /* 256 */

typedef struct NESSIEstruct {
	u8  bitLength[LENGTHBYTES]; /* global number of hashed bits (256-bit counter) */
	u8  buffer[WBLOCKBYTES];	/* buffer of data to hash */
	int bufferBits;		        /* current number of bits on the buffer */
	int bufferPos;		        /* current (possibly incomplete) byte slot on the buffer */
	u64 hash[DIGESTBYTES/8];    /* the hashing state */
} NESSIEstruct;



/*
 * The number of rounds of the internal dedicated block cipher.
 */
#define WHIRLPOOL_R 10


static const u64 C0[256] = {
    LL(0x18186018c07830d8), LL(0x23238c2305af4626), LL(0xc6c63fc67ef991b8), LL(0xe8e887e8136fcdfb),
    LL(0x878726874ca113cb), LL(0xb8b8dab8a9626d11), LL(0x0101040108050209), LL(0x4f4f214f426e9e0d),
    LL(0x3636d836adee6c9b), LL(0xa6a6a2a6590451ff), LL(0xd2d26fd2debdb90c), LL(0xf5f5f3f5fb06f70e),
    LL(0x7979f979ef80f296), LL(0x6f6fa16f5fcede30), LL(0x91917e91fcef3f6d), LL(0x52525552aa07a4f8),
    LL(0x60609d6027fdc047), LL(0xbcbccabc89766535), LL(0x9b9b569baccd2b37), LL(0x8e8e028e048c018a),
    LL(0xa3a3b6a371155bd2), LL(0x0c0c300c603c186c), LL(0x7b7bf17bff8af684), LL(0x3535d435b5e16a80),
    LL(0x1d1d741de8693af5), LL(0xe0e0a7e05347ddb3), LL(0xd7d77bd7f6acb321), LL(0xc2c22fc25eed999c),
    LL(0x2e2eb82e6d965c43), LL(0x4b4b314b627a9629), LL(0xfefedffea321e15d), LL(0x575741578216aed5),
    LL(0x15155415a8412abd), LL(0x7777c1779fb6eee8), LL(0x3737dc37a5eb6e92), LL(0xe5e5b3e57b56d79e),
    LL(0x9f9f469f8cd92313), LL(0xf0f0e7f0d317fd23), LL(0x4a4a354a6a7f9420), LL(0xdada4fda9e95a944),
    LL(0x58587d58fa25b0a2), LL(0xc9c903c906ca8fcf), LL(0x2929a429558d527c), LL(0x0a0a280a5022145a),
    LL(0xb1b1feb1e14f7f50), LL(0xa0a0baa0691a5dc9), LL(0x6b6bb16b7fdad614), LL(0x85852e855cab17d9),
    LL(0xbdbdcebd8173673c), LL(0x5d5d695dd234ba8f), LL(0x1010401080502090), LL(0xf4f4f7f4f303f507),
    LL(0xcbcb0bcb16c08bdd), LL(0x3e3ef83eedc67cd3), LL(0x0505140528110a2d), LL(0x676781671fe6ce78),
    LL(0xe4e4b7e47353d597), LL(0x27279c2725bb4e02), LL(0x4141194132588273), LL(0x8b8b168b2c9d0ba7),
    LL(0xa7a7a6a7510153f6), LL(0x7d7de97dcf94fab2), LL(0x95956e95dcfb3749), LL(0xd8d847d88e9fad56),
    LL(0xfbfbcbfb8b30eb70), LL(0xeeee9fee2371c1cd), LL(0x7c7ced7cc791f8bb), LL(0x6666856617e3cc71),
    LL(0xdddd53dda68ea77b), LL(0x17175c17b84b2eaf), LL(0x4747014702468e45), LL(0x9e9e429e84dc211a),
    LL(0xcaca0fca1ec589d4), LL(0x2d2db42d75995a58), LL(0xbfbfc6bf9179632e), LL(0x07071c07381b0e3f),
    LL(0xadad8ead012347ac), LL(0x5a5a755aea2fb4b0), LL(0x838336836cb51bef), LL(0x3333cc3385ff66b6),
    LL(0x636391633ff2c65c), LL(0x02020802100a0412), LL(0xaaaa92aa39384993), LL(0x7171d971afa8e2de),
    LL(0xc8c807c80ecf8dc6), LL(0x19196419c87d32d1), LL(0x494939497270923b), LL(0xd9d943d9869aaf5f),
    LL(0xf2f2eff2c31df931), LL(0xe3e3abe34b48dba8), LL(0x5b5b715be22ab6b9), LL(0x88881a8834920dbc),
    LL(0x9a9a529aa4c8293e), LL(0x262698262dbe4c0b), LL(0x3232c8328dfa64bf), LL(0xb0b0fab0e94a7d59),
    LL(0xe9e983e91b6acff2), LL(0x0f0f3c0f78331e77), LL(0xd5d573d5e6a6b733), LL(0x80803a8074ba1df4),
    LL(0xbebec2be997c6127), LL(0xcdcd13cd26de87eb), LL(0x3434d034bde46889), LL(0x48483d487a759032),
    LL(0xffffdbffab24e354), LL(0x7a7af57af78ff48d), LL(0x90907a90f4ea3d64), LL(0x5f5f615fc23ebe9d),
    LL(0x202080201da0403d), LL(0x6868bd6867d5d00f), LL(0x1a1a681ad07234ca), LL(0xaeae82ae192c41b7),
    LL(0xb4b4eab4c95e757d), LL(0x54544d549a19a8ce), LL(0x93937693ece53b7f), LL(0x222288220daa442f),
    LL(0x64648d6407e9c863), LL(0xf1f1e3f1db12ff2a), LL(0x7373d173bfa2e6cc), LL(0x12124812905a2482),
    LL(0x40401d403a5d807a), LL(0x0808200840281048), LL(0xc3c32bc356e89b95), LL(0xecec97ec337bc5df),
    LL(0xdbdb4bdb9690ab4d), LL(0xa1a1bea1611f5fc0), LL(0x8d8d0e8d1c830791), LL(0x3d3df43df5c97ac8),
    LL(0x97976697ccf1335b), LL(0x0000000000000000), LL(0xcfcf1bcf36d483f9), LL(0x2b2bac2b4587566e),
    LL(0x7676c57697b3ece1), LL(0x8282328264b019e6), LL(0xd6d67fd6fea9b128), LL(0x1b1b6c1bd87736c3),
    LL(0xb5b5eeb5c15b7774), LL(0xafaf86af112943be), LL(0x6a6ab56a77dfd41d), LL(0x50505d50ba0da0ea),
    LL(0x45450945124c8a57), LL(0xf3f3ebf3cb18fb38), LL(0x3030c0309df060ad), LL(0xefef9bef2b74c3c4),
    LL(0x3f3ffc3fe5c37eda), LL(0x55554955921caac7), LL(0xa2a2b2a2791059db), LL(0xeaea8fea0365c9e9),
    LL(0x656589650fecca6a), LL(0xbabad2bab9686903), LL(0x2f2fbc2f65935e4a), LL(0xc0c027c04ee79d8e),
    LL(0xdede5fdebe81a160), LL(0x1c1c701ce06c38fc), LL(0xfdfdd3fdbb2ee746), LL(0x4d4d294d52649a1f),
    LL(0x92927292e4e03976), LL(0x7575c9758fbceafa), LL(0x06061806301e0c36), LL(0x8a8a128a249809ae),
    LL(0xb2b2f2b2f940794b), LL(0xe6e6bfe66359d185), LL(0x0e0e380e70361c7e), LL(0x1f1f7c1ff8633ee7),
    LL(0x6262956237f7c455), LL(0xd4d477d4eea3b53a), LL(0xa8a89aa829324d81), LL(0x96966296c4f43152),
    LL(0xf9f9c3f99b3aef62), LL(0xc5c533c566f697a3), LL(0x2525942535b14a10), LL(0x59597959f220b2ab),
    LL(0x84842a8454ae15d0), LL(0x7272d572b7a7e4c5), LL(0x3939e439d5dd72ec), LL(0x4c4c2d4c5a619816),
    LL(0x5e5e655eca3bbc94), LL(0x7878fd78e785f09f), LL(0x3838e038ddd870e5), LL(0x8c8c0a8c14860598),
    LL(0xd1d163d1c6b2bf17), LL(0xa5a5aea5410b57e4), LL(0xe2e2afe2434dd9a1), LL(0x616199612ff8c24e),
    LL(0xb3b3f6b3f1457b42), LL(0x2121842115a54234), LL(0x9c9c4a9c94d62508), LL(0x1e1e781ef0663cee),
    LL(0x4343114322528661), LL(0xc7c73bc776fc93b1), LL(0xfcfcd7fcb32be54f), LL(0x0404100420140824),
    LL(0x51515951b208a2e3), LL(0x99995e99bcc72f25), LL(0x6d6da96d4fc4da22), LL(0x0d0d340d68391a65),
    LL(0xfafacffa8335e979), LL(0xdfdf5bdfb684a369), LL(0x7e7ee57ed79bfca9), LL(0x242490243db44819),
    LL(0x3b3bec3bc5d776fe), LL(0xabab96ab313d4b9a), LL(0xcece1fce3ed181f0), LL(0x1111441188552299),
    LL(0x8f8f068f0c890383), LL(0x4e4e254e4a6b9c04), LL(0xb7b7e6b7d1517366), LL(0xebeb8beb0b60cbe0),
    LL(0x3c3cf03cfdcc78c1), LL(0x81813e817cbf1ffd), LL(0x94946a94d4fe3540), LL(0xf7f7fbf7eb0cf31c),
    LL(0xb9b9deb9a1676f18), LL(0x13134c13985f268b), LL(0x2c2cb02c7d9c5851), LL(0xd3d36bd3d6b8bb05),
    LL(0xe7e7bbe76b5cd38c), LL(0x6e6ea56e57cbdc39), LL(0xc4c437c46ef395aa), LL(0x03030c03180f061b),
    LL(0x565645568a13acdc), LL(0x44440d441a49885e), LL(0x7f7fe17fdf9efea0), LL(0xa9a99ea921374f88),
    LL(0x2a2aa82a4d825467), LL(0xbbbbd6bbb16d6b0a), LL(0xc1c123c146e29f87), LL(0x53535153a202a6f1),
    LL(0xdcdc57dcae8ba572), LL(0x0b0b2c0b58271653), LL(0x9d9d4e9d9cd32701), LL(0x6c6cad6c47c1d82b),
    LL(0x3131c43195f562a4), LL(0x7474cd7487b9e8f3), LL(0xf6f6fff6e309f115), LL(0x464605460a438c4c),
    LL(0xacac8aac092645a5), LL(0x89891e893c970fb5), LL(0x14145014a04428b4), LL(0xe1e1a3e15b42dfba),
    LL(0x16165816b04e2ca6), LL(0x3a3ae83acdd274f7), LL(0x6969b9696fd0d206), LL(0x09092409482d1241),
    LL(0x7070dd70a7ade0d7), LL(0xb6b6e2b6d954716f), LL(0xd0d067d0ceb7bd1e), LL(0xeded93ed3b7ec7d6),
    LL(0xcccc17cc2edb85e2), LL(0x424215422a578468), LL(0x98985a98b4c22d2c), LL(0xa4a4aaa4490e55ed),
    LL(0x2828a0285d885075), LL(0x5c5c6d5cda31b886), LL(0xf8f8c7f8933fed6b), LL(0x8686228644a411c2),
};

static const u64 C1[256] = {
    LL(0xd818186018c07830), LL(0x2623238c2305af46), LL(0xb8c6c63fc67ef991), LL(0xfbe8e887e8136fcd),
    LL(0xcb878726874ca113), LL(0x11b8b8dab8a9626d), LL(0x0901010401080502), LL(0x0d4f4f214f426e9e),
    LL(0x9b3636d836adee6c), LL(0xffa6a6a2a6590451), LL(0x0cd2d26fd2debdb9), LL(0x0ef5f5f3f5fb06f7),
    LL(0x967979f979ef80f2), LL(0x306f6fa16f5fcede), LL(0x6d91917e91fcef3f), LL(0xf852525552aa07a4),
    LL(0x4760609d6027fdc0), LL(0x35bcbccabc897665), LL(0x379b9b569baccd2b), LL(0x8a8e8e028e048c01),
    LL(0xd2a3a3b6a371155b), LL(0x6c0c0c300c603c18), LL(0x847b7bf17bff8af6), LL(0x803535d435b5e16a),
    LL(0xf51d1d741de8693a), LL(0xb3e0e0a7e05347dd), LL(0x21d7d77bd7f6acb3), LL(0x9cc2c22fc25eed99),
    LL(0x432e2eb82e6d965c), LL(0x294b4b314b627a96), LL(0x5dfefedffea321e1), LL(0xd5575741578216ae),
    LL(0xbd15155415a8412a), LL(0xe87777c1779fb6ee), LL(0x923737dc37a5eb6e), LL(0x9ee5e5b3e57b56d7),
    LL(0x139f9f469f8cd923), LL(0x23f0f0e7f0d317fd), LL(0x204a4a354a6a7f94), LL(0x44dada4fda9e95a9),
    LL(0xa258587d58fa25b0), LL(0xcfc9c903c906ca8f), LL(0x7c2929a429558d52), LL(0x5a0a0a280a502214),
    LL(0x50b1b1feb1e14f7f), LL(0xc9a0a0baa0691a5d), LL(0x146b6bb16b7fdad6), LL(0xd985852e855cab17),
    LL(0x3cbdbdcebd817367), LL(0x8f5d5d695dd234ba), LL(0x9010104010805020), LL(0x07f4f4f7f4f303f5),
    LL(0xddcbcb0bcb16c08b), LL(0xd33e3ef83eedc67c), LL(0x2d0505140528110a), LL(0x78676781671fe6ce),
    LL(0x97e4e4b7e47353d5), LL(0x0227279c2725bb4e), LL(0x7341411941325882), LL(0xa78b8b168b2c9d0b),
    LL(0xf6a7a7a6a7510153), LL(0xb27d7de97dcf94fa), LL(0x4995956e95dcfb37), LL(0x56d8d847d88e9fad),
    LL(0x70fbfbcbfb8b30eb), LL(0xcdeeee9fee2371c1), LL(0xbb7c7ced7cc791f8), LL(0x716666856617e3cc),
    LL(0x7bdddd53dda68ea7), LL(0xaf17175c17b84b2e), LL(0x454747014702468e), LL(0x1a9e9e429e84dc21),
    LL(0xd4caca0fca1ec589), LL(0x582d2db42d75995a), LL(0x2ebfbfc6bf917963), LL(0x3f07071c07381b0e),
    LL(0xacadad8ead012347), LL(0xb05a5a755aea2fb4), LL(0xef838336836cb51b), LL(0xb63333cc3385ff66),
    LL(0x5c636391633ff2c6), LL(0x1202020802100a04), LL(0x93aaaa92aa393849), LL(0xde7171d971afa8e2),
    LL(0xc6c8c807c80ecf8d), LL(0xd119196419c87d32), LL(0x3b49493949727092), LL(0x5fd9d943d9869aaf),
    LL(0x31f2f2eff2c31df9), LL(0xa8e3e3abe34b48db), LL(0xb95b5b715be22ab6), LL(0xbc88881a8834920d),
    LL(0x3e9a9a529aa4c829), LL(0x0b262698262dbe4c), LL(0xbf3232c8328dfa64), LL(0x59b0b0fab0e94a7d),
    LL(0xf2e9e983e91b6acf), LL(0x770f0f3c0f78331e), LL(0x33d5d573d5e6a6b7), LL(0xf480803a8074ba1d),
    LL(0x27bebec2be997c61), LL(0xebcdcd13cd26de87), LL(0x893434d034bde468), LL(0x3248483d487a7590),
    LL(0x54ffffdbffab24e3), LL(0x8d7a7af57af78ff4), LL(0x6490907a90f4ea3d), LL(0x9d5f5f615fc23ebe),
    LL(0x3d202080201da040), LL(0x0f6868bd6867d5d0), LL(0xca1a1a681ad07234), LL(0xb7aeae82ae192c41),
    LL(0x7db4b4eab4c95e75), LL(0xce54544d549a19a8), LL(0x7f93937693ece53b), LL(0x2f222288220daa44),
    LL(0x6364648d6407e9c8), LL(0x2af1f1e3f1db12ff), LL(0xcc7373d173bfa2e6), LL(0x8212124812905a24),
    LL(0x7a40401d403a5d80), LL(0x4808082008402810), LL(0x95c3c32bc356e89b), LL(0xdfecec97ec337bc5),
    LL(0x4ddbdb4bdb9690ab), LL(0xc0a1a1bea1611f5f), LL(0x918d8d0e8d1c8307), LL(0xc83d3df43df5c97a),
    LL(0x5b97976697ccf133), LL(0x0000000000000000), LL(0xf9cfcf1bcf36d483), LL(0x6e2b2bac2b458756),
    LL(0xe17676c57697b3ec), LL(0xe68282328264b019), LL(0x28d6d67fd6fea9b1), LL(0xc31b1b6c1bd87736),
    LL(0x74b5b5eeb5c15b77), LL(0xbeafaf86af112943), LL(0x1d6a6ab56a77dfd4), LL(0xea50505d50ba0da0),
    LL(0x5745450945124c8a), LL(0x38f3f3ebf3cb18fb), LL(0xad3030c0309df060), LL(0xc4efef9bef2b74c3),
    LL(0xda3f3ffc3fe5c37e), LL(0xc755554955921caa), LL(0xdba2a2b2a2791059), LL(0xe9eaea8fea0365c9),
    LL(0x6a656589650fecca), LL(0x03babad2bab96869), LL(0x4a2f2fbc2f65935e), LL(0x8ec0c027c04ee79d),
    LL(0x60dede5fdebe81a1), LL(0xfc1c1c701ce06c38), LL(0x46fdfdd3fdbb2ee7), LL(0x1f4d4d294d52649a),
    LL(0x7692927292e4e039), LL(0xfa7575c9758fbcea), LL(0x3606061806301e0c), LL(0xae8a8a128a249809),
    LL(0x4bb2b2f2b2f94079), LL(0x85e6e6bfe66359d1), LL(0x7e0e0e380e70361c), LL(0xe71f1f7c1ff8633e),
    LL(0x556262956237f7c4), LL(0x3ad4d477d4eea3b5), LL(0x81a8a89aa829324d), LL(0x5296966296c4f431),
    LL(0x62f9f9c3f99b3aef), LL(0xa3c5c533c566f697), LL(0x102525942535b14a), LL(0xab59597959f220b2),
    LL(0xd084842a8454ae15), LL(0xc57272d572b7a7e4), LL(0xec3939e439d5dd72), LL(0x164c4c2d4c5a6198),
    LL(0x945e5e655eca3bbc), LL(0x9f7878fd78e785f0), LL(0xe53838e038ddd870), LL(0x988c8c0a8c148605),
    LL(0x17d1d163d1c6b2bf), LL(0xe4a5a5aea5410b57), LL(0xa1e2e2afe2434dd9), LL(0x4e616199612ff8c2),
    LL(0x42b3b3f6b3f1457b), LL(0x342121842115a542), LL(0x089c9c4a9c94d625), LL(0xee1e1e781ef0663c),
    LL(0x6143431143225286), LL(0xb1c7c73bc776fc93), LL(0x4ffcfcd7fcb32be5), LL(0x2404041004201408),
    LL(0xe351515951b208a2), LL(0x2599995e99bcc72f), LL(0x226d6da96d4fc4da), LL(0x650d0d340d68391a),
    LL(0x79fafacffa8335e9), LL(0x69dfdf5bdfb684a3), LL(0xa97e7ee57ed79bfc), LL(0x19242490243db448),
    LL(0xfe3b3bec3bc5d776), LL(0x9aabab96ab313d4b), LL(0xf0cece1fce3ed181), LL(0x9911114411885522),
    LL(0x838f8f068f0c8903), LL(0x044e4e254e4a6b9c), LL(0x66b7b7e6b7d15173), LL(0xe0ebeb8beb0b60cb),
    LL(0xc13c3cf03cfdcc78), LL(0xfd81813e817cbf1f), LL(0x4094946a94d4fe35), LL(0x1cf7f7fbf7eb0cf3),
    LL(0x18b9b9deb9a1676f), LL(0x8b13134c13985f26), LL(0x512c2cb02c7d9c58), LL(0x05d3d36bd3d6b8bb),
    LL(0x8ce7e7bbe76b5cd3), LL(0x396e6ea56e57cbdc), LL(0xaac4c437c46ef395), LL(0x1b03030c03180f06),
    LL(0xdc565645568a13ac), LL(0x5e44440d441a4988), LL(0xa07f7fe17fdf9efe), LL(0x88a9a99ea921374f),
    LL(0x672a2aa82a4d8254), LL(0x0abbbbd6bbb16d6b), LL(0x87c1c123c146e29f), LL(0xf153535153a202a6),
    LL(0x72dcdc57dcae8ba5), LL(0x530b0b2c0b582716), LL(0x019d9d4e9d9cd327), LL(0x2b6c6cad6c47c1d8),
    LL(0xa43131c43195f562), LL(0xf37474cd7487b9e8), LL(0x15f6f6fff6e309f1), LL(0x4c464605460a438c),
    LL(0xa5acac8aac092645), LL(0xb589891e893c970f), LL(0xb414145014a04428), LL(0xbae1e1a3e15b42df),
    LL(0xa616165816b04e2c), LL(0xf73a3ae83acdd274), LL(0x066969b9696fd0d2), LL(0x4109092409482d12),
    LL(0xd77070dd70a7ade0), LL(0x6fb6b6e2b6d95471), LL(0x1ed0d067d0ceb7bd), LL(0xd6eded93ed3b7ec7),
    LL(0xe2cccc17cc2edb85), LL(0x68424215422a5784), LL(0x2c98985a98b4c22d), LL(0xeda4a4aaa4490e55),
    LL(0x752828a0285d8850), LL(0x865c5c6d5cda31b8), LL(0x6bf8f8c7f8933fed), LL(0xc28686228644a411),
};

static const u64 C2[256] = {
    LL(0x30d818186018c078), LL(0x462623238c2305af), LL(0x91b8c6c63fc67ef9), LL(0xcdfbe8e887e8136f),
    LL(0x13cb878726874ca1), LL(0x6d11b8b8dab8a962), LL(0x0209010104010805), LL(0x9e0d4f4f214f426e),
    LL(0x6c9b3636d836adee), LL(0x51ffa6a6a2a65904), LL(0xb90cd2d26fd2debd), LL(0xf70ef5f5f3f5fb06),
    LL(0xf2967979f979ef80), LL(0xde306f6fa16f5fce), LL(0x3f6d91917e91fcef), LL(0xa4f852525552aa07),
    LL(0xc04760609d6027fd), LL(0x6535bcbccabc8976), LL(0x2b379b9b569baccd), LL(0x018a8e8e028e048c),
    LL(0x5bd2a3a3b6a37115), LL(0x186c0c0c300c603c), LL(0xf6847b7bf17bff8a), LL(0x6a803535d435b5e1),
    LL(0x3af51d1d741de869), LL(0xddb3e0e0a7e05347), LL(0xb321d7d77bd7f6ac), LL(0x999cc2c22fc25eed),
    LL(0x5c432e2eb82e6d96), LL(0x96294b4b314b627a), LL(0xe15dfefedffea321), LL(0xaed5575741578216),
    LL(0x2abd15155415a841), LL(0xeee87777c1779fb6), LL(0x6e923737dc37a5eb), LL(0xd79ee5e5b3e57b56),
    LL(0x23139f9f469f8cd9), LL(0xfd23f0f0e7f0d317), LL(0x94204a4a354a6a7f), LL(0xa944dada4fda9e95),
    LL(0xb0a258587d58fa25), LL(0x8fcfc9c903c906ca), LL(0x527c2929a429558d), LL(0x145a0a0a280a5022),
    LL(0x7f50b1b1feb1e14f), LL(0x5dc9a0a0baa0691a), LL(0xd6146b6bb16b7fda), LL(0x17d985852e855cab),
    LL(0x673cbdbdcebd8173), LL(0xba8f5d5d695dd234), LL(0x2090101040108050), LL(0xf507f4f4f7f4f303),
    LL(0x8bddcbcb0bcb16c0), LL(0x7cd33e3ef83eedc6), LL(0x0a2d050514052811), LL(0xce78676781671fe6),
    LL(0xd597e4e4b7e47353), LL(0x4e0227279c2725bb), LL(0x8273414119413258), LL(0x0ba78b8b168b2c9d),
    LL(0x53f6a7a7a6a75101), LL(0xfab27d7de97dcf94), LL(0x374995956e95dcfb), LL(0xad56d8d847d88e9f),
    LL(0xeb70fbfbcbfb8b30), LL(0xc1cdeeee9fee2371), LL(0xf8bb7c7ced7cc791), LL(0xcc716666856617e3),
    LL(0xa77bdddd53dda68e), LL(0x2eaf17175c17b84b), LL(0x8e45474701470246), LL(0x211a9e9e429e84dc),
    LL(0x89d4caca0fca1ec5), LL(0x5a582d2db42d7599), LL(0x632ebfbfc6bf9179), LL(0x0e3f07071c07381b),
    LL(0x47acadad8ead0123), LL(0xb4b05a5a755aea2f), LL(0x1bef838336836cb5), LL(0x66b63333cc3385ff),
    LL(0xc65c636391633ff2), LL(0x041202020802100a), LL(0x4993aaaa92aa3938), LL(0xe2de7171d971afa8),
    LL(0x8dc6c8c807c80ecf), LL(0x32d119196419c87d), LL(0x923b494939497270), LL(0xaf5fd9d943d9869a),
    LL(0xf931f2f2eff2c31d), LL(0xdba8e3e3abe34b48), LL(0xb6b95b5b715be22a), LL(0x0dbc88881a883492),
    LL(0x293e9a9a529aa4c8), LL(0x4c0b262698262dbe), LL(0x64bf3232c8328dfa), LL(0x7d59b0b0fab0e94a),
    LL(0xcff2e9e983e91b6a), LL(0x1e770f0f3c0f7833), LL(0xb733d5d573d5e6a6), LL(0x1df480803a8074ba),
    LL(0x6127bebec2be997c), LL(0x87ebcdcd13cd26de), LL(0x68893434d034bde4), LL(0x903248483d487a75),
    LL(0xe354ffffdbffab24), LL(0xf48d7a7af57af78f), LL(0x3d6490907a90f4ea), LL(0xbe9d5f5f615fc23e),
    LL(0x403d202080201da0), LL(0xd00f6868bd6867d5), LL(0x34ca1a1a681ad072), LL(0x41b7aeae82ae192c),
    LL(0x757db4b4eab4c95e), LL(0xa8ce54544d549a19), LL(0x3b7f93937693ece5), LL(0x442f222288220daa),
    LL(0xc86364648d6407e9), LL(0xff2af1f1e3f1db12), LL(0xe6cc7373d173bfa2), LL(0x248212124812905a),
    LL(0x807a40401d403a5d), LL(0x1048080820084028), LL(0x9b95c3c32bc356e8), LL(0xc5dfecec97ec337b),
    LL(0xab4ddbdb4bdb9690), LL(0x5fc0a1a1bea1611f), LL(0x07918d8d0e8d1c83), LL(0x7ac83d3df43df5c9),
    LL(0x335b97976697ccf1), LL(0x0000000000000000), LL(0x83f9cfcf1bcf36d4), LL(0x566e2b2bac2b4587),
    LL(0xece17676c57697b3), LL(0x19e68282328264b0), LL(0xb128d6d67fd6fea9), LL(0x36c31b1b6c1bd877),
    LL(0x7774b5b5eeb5c15b), LL(0x43beafaf86af1129), LL(0xd41d6a6ab56a77df), LL(0xa0ea50505d50ba0d),
    LL(0x8a5745450945124c), LL(0xfb38f3f3ebf3cb18), LL(0x60ad3030c0309df0), LL(0xc3c4efef9bef2b74),
    LL(0x7eda3f3ffc3fe5c3), LL(0xaac755554955921c), LL(0x59dba2a2b2a27910), LL(0xc9e9eaea8fea0365),
    LL(0xca6a656589650fec), LL(0x6903babad2bab968), LL(0x5e4a2f2fbc2f6593), LL(0x9d8ec0c027c04ee7),
    LL(0xa160dede5fdebe81), LL(0x38fc1c1c701ce06c), LL(0xe746fdfdd3fdbb2e), LL(0x9a1f4d4d294d5264),
    LL(0x397692927292e4e0), LL(0xeafa7575c9758fbc), LL(0x0c3606061806301e), LL(0x09ae8a8a128a2498),
    LL(0x794bb2b2f2b2f940), LL(0xd185e6e6bfe66359), LL(0x1c7e0e0e380e7036), LL(0x3ee71f1f7c1ff863),
    LL(0xc4556262956237f7), LL(0xb53ad4d477d4eea3), LL(0x4d81a8a89aa82932), LL(0x315296966296c4f4),
    LL(0xef62f9f9c3f99b3a), LL(0x97a3c5c533c566f6), LL(0x4a102525942535b1), LL(0xb2ab59597959f220),
    LL(0x15d084842a8454ae), LL(0xe4c57272d572b7a7), LL(0x72ec3939e439d5dd), LL(0x98164c4c2d4c5a61),
    LL(0xbc945e5e655eca3b), LL(0xf09f7878fd78e785), LL(0x70e53838e038ddd8), LL(0x05988c8c0a8c1486),
    LL(0xbf17d1d163d1c6b2), LL(0x57e4a5a5aea5410b), LL(0xd9a1e2e2afe2434d), LL(0xc24e616199612ff8),
    LL(0x7b42b3b3f6b3f145), LL(0x42342121842115a5), LL(0x25089c9c4a9c94d6), LL(0x3cee1e1e781ef066),
    LL(0x8661434311432252), LL(0x93b1c7c73bc776fc), LL(0xe54ffcfcd7fcb32b), LL(0x0824040410042014),
    LL(0xa2e351515951b208), LL(0x2f2599995e99bcc7), LL(0xda226d6da96d4fc4), LL(0x1a650d0d340d6839),
    LL(0xe979fafacffa8335), LL(0xa369dfdf5bdfb684), LL(0xfca97e7ee57ed79b), LL(0x4819242490243db4),
    LL(0x76fe3b3bec3bc5d7), LL(0x4b9aabab96ab313d), LL(0x81f0cece1fce3ed1), LL(0x2299111144118855),
    LL(0x03838f8f068f0c89), LL(0x9c044e4e254e4a6b), LL(0x7366b7b7e6b7d151), LL(0xcbe0ebeb8beb0b60),
    LL(0x78c13c3cf03cfdcc), LL(0x1ffd81813e817cbf), LL(0x354094946a94d4fe), LL(0xf31cf7f7fbf7eb0c),
    LL(0x6f18b9b9deb9a167), LL(0x268b13134c13985f), LL(0x58512c2cb02c7d9c), LL(0xbb05d3d36bd3d6b8),
    LL(0xd38ce7e7bbe76b5c), LL(0xdc396e6ea56e57cb), LL(0x95aac4c437c46ef3), LL(0x061b03030c03180f),
    LL(0xacdc565645568a13), LL(0x885e44440d441a49), LL(0xfea07f7fe17fdf9e), LL(0x4f88a9a99ea92137),
    LL(0x54672a2aa82a4d82), LL(0x6b0abbbbd6bbb16d), LL(0x9f87c1c123c146e2), LL(0xa6f153535153a202),
    LL(0xa572dcdc57dcae8b), LL(0x16530b0b2c0b5827), LL(0x27019d9d4e9d9cd3), LL(0xd82b6c6cad6c47c1),
    LL(0x62a43131c43195f5), LL(0xe8f37474cd7487b9), LL(0xf115f6f6fff6e309), LL(0x8c4c464605460a43),
    LL(0x45a5acac8aac0926), LL(0x0fb589891e893c97), LL(0x28b414145014a044), LL(0xdfbae1e1a3e15b42),
    LL(0x2ca616165816b04e), LL(0x74f73a3ae83acdd2), LL(0xd2066969b9696fd0), LL(0x124109092409482d),
    LL(0xe0d77070dd70a7ad), LL(0x716fb6b6e2b6d954), LL(0xbd1ed0d067d0ceb7), LL(0xc7d6eded93ed3b7e),
    LL(0x85e2cccc17cc2edb), LL(0x8468424215422a57), LL(0x2d2c98985a98b4c2), LL(0x55eda4a4aaa4490e),
    LL(0x50752828a0285d88), LL(0xb8865c5c6d5cda31), LL(0xed6bf8f8c7f8933f), LL(0x11c28686228644a4),
};

static const u64 C3[256] = {
    LL(0x7830d818186018c0), LL(0xaf462623238c2305), LL(0xf991b8c6c63fc67e), LL(0x6fcdfbe8e887e813),
    LL(0xa113cb878726874c), LL(0x626d11b8b8dab8a9), LL(0x0502090101040108), LL(0x6e9e0d4f4f214f42),
    LL(0xee6c9b3636d836ad), LL(0x0451ffa6a6a2a659), LL(0xbdb90cd2d26fd2de), LL(0x06f70ef5f5f3f5fb),
    LL(0x80f2967979f979ef), LL(0xcede306f6fa16f5f), LL(0xef3f6d91917e91fc), LL(0x07a4f852525552aa),
    LL(0xfdc04760609d6027), LL(0x766535bcbccabc89), LL(0xcd2b379b9b569bac), LL(0x8c018a8e8e028e04),
    LL(0x155bd2a3a3b6a371), LL(0x3c186c0c0c300c60), LL(0x8af6847b7bf17bff), LL(0xe16a803535d435b5),
    LL(0x693af51d1d741de8), LL(0x47ddb3e0e0a7e053), LL(0xacb321d7d77bd7f6), LL(0xed999cc2c22fc25e),
    LL(0x965c432e2eb82e6d), LL(0x7a96294b4b314b62), LL(0x21e15dfefedffea3), LL(0x16aed55757415782),
    LL(0x412abd15155415a8), LL(0xb6eee87777c1779f), LL(0xeb6e923737dc37a5), LL(0x56d79ee5e5b3e57b),
    LL(0xd923139f9f469f8c), LL(0x17fd23f0f0e7f0d3), LL(0x7f94204a4a354a6a), LL(0x95a944dada4fda9e),
    LL(0x25b0a258587d58fa), LL(0xca8fcfc9c903c906), LL(0x8d527c2929a42955), LL(0x22145a0a0a280a50),
    LL(0x4f7f50b1b1feb1e1), LL(0x1a5dc9a0a0baa069), LL(0xdad6146b6bb16b7f), LL(0xab17d985852e855c),
    LL(0x73673cbdbdcebd81), LL(0x34ba8f5d5d695dd2), LL(0x5020901010401080), LL(0x03f507f4f4f7f4f3),
    LL(0xc08bddcbcb0bcb16), LL(0xc67cd33e3ef83eed), LL(0x110a2d0505140528), LL(0xe6ce78676781671f),
    LL(0x53d597e4e4b7e473), LL(0xbb4e0227279c2725), LL(0x5882734141194132), LL(0x9d0ba78b8b168b2c),
    LL(0x0153f6a7a7a6a751), LL(0x94fab27d7de97dcf), LL(0xfb374995956e95dc), LL(0x9fad56d8d847d88e),
    LL(0x30eb70fbfbcbfb8b), LL(0x71c1cdeeee9fee23), LL(0x91f8bb7c7ced7cc7), LL(0xe3cc716666856617),
    LL(0x8ea77bdddd53dda6), LL(0x4b2eaf17175c17b8), LL(0x468e454747014702), LL(0xdc211a9e9e429e84),
    LL(0xc589d4caca0fca1e), LL(0x995a582d2db42d75), LL(0x79632ebfbfc6bf91), LL(0x1b0e3f07071c0738),
    LL(0x2347acadad8ead01), LL(0x2fb4b05a5a755aea), LL(0xb51bef838336836c), LL(0xff66b63333cc3385),
    LL(0xf2c65c636391633f), LL(0x0a04120202080210), LL(0x384993aaaa92aa39), LL(0xa8e2de7171d971af),
    LL(0xcf8dc6c8c807c80e), LL(0x7d32d119196419c8), LL(0x70923b4949394972), LL(0x9aaf5fd9d943d986),
    LL(0x1df931f2f2eff2c3), LL(0x48dba8e3e3abe34b), LL(0x2ab6b95b5b715be2), LL(0x920dbc88881a8834),
    LL(0xc8293e9a9a529aa4), LL(0xbe4c0b262698262d), LL(0xfa64bf3232c8328d), LL(0x4a7d59b0b0fab0e9),
    LL(0x6acff2e9e983e91b), LL(0x331e770f0f3c0f78), LL(0xa6b733d5d573d5e6), LL(0xba1df480803a8074),
    LL(0x7c6127bebec2be99), LL(0xde87ebcdcd13cd26), LL(0xe468893434d034bd), LL(0x75903248483d487a),
    LL(0x24e354ffffdbffab), LL(0x8ff48d7a7af57af7), LL(0xea3d6490907a90f4), LL(0x3ebe9d5f5f615fc2),
    LL(0xa0403d202080201d), LL(0xd5d00f6868bd6867), LL(0x7234ca1a1a681ad0), LL(0x2c41b7aeae82ae19),
    LL(0x5e757db4b4eab4c9), LL(0x19a8ce54544d549a), LL(0xe53b7f93937693ec), LL(0xaa442f222288220d),
    LL(0xe9c86364648d6407), LL(0x12ff2af1f1e3f1db), LL(0xa2e6cc7373d173bf), LL(0x5a24821212481290),
    LL(0x5d807a40401d403a), LL(0x2810480808200840), LL(0xe89b95c3c32bc356), LL(0x7bc5dfecec97ec33),
    LL(0x90ab4ddbdb4bdb96), LL(0x1f5fc0a1a1bea161), LL(0x8307918d8d0e8d1c), LL(0xc97ac83d3df43df5),
    LL(0xf1335b97976697cc), LL(0x0000000000000000), LL(0xd483f9cfcf1bcf36), LL(0x87566e2b2bac2b45),
    LL(0xb3ece17676c57697), LL(0xb019e68282328264), LL(0xa9b128d6d67fd6fe), LL(0x7736c31b1b6c1bd8),
    LL(0x5b7774b5b5eeb5c1), LL(0x2943beafaf86af11), LL(0xdfd41d6a6ab56a77), LL(0x0da0ea50505d50ba),
    LL(0x4c8a574545094512), LL(0x18fb38f3f3ebf3cb), LL(0xf060ad3030c0309d), LL(0x74c3c4efef9bef2b),
    LL(0xc37eda3f3ffc3fe5), LL(0x1caac75555495592), LL(0x1059dba2a2b2a279), LL(0x65c9e9eaea8fea03),
    LL(0xecca6a656589650f), LL(0x686903babad2bab9), LL(0x935e4a2f2fbc2f65), LL(0xe79d8ec0c027c04e),
    LL(0x81a160dede5fdebe), LL(0x6c38fc1c1c701ce0), LL(0x2ee746fdfdd3fdbb), LL(0x649a1f4d4d294d52),
    LL(0xe0397692927292e4), LL(0xbceafa7575c9758f), LL(0x1e0c360606180630), LL(0x9809ae8a8a128a24),
    LL(0x40794bb2b2f2b2f9), LL(0x59d185e6e6bfe663), LL(0x361c7e0e0e380e70), LL(0x633ee71f1f7c1ff8),
    LL(0xf7c4556262956237), LL(0xa3b53ad4d477d4ee), LL(0x324d81a8a89aa829), LL(0xf4315296966296c4),
    LL(0x3aef62f9f9c3f99b), LL(0xf697a3c5c533c566), LL(0xb14a102525942535), LL(0x20b2ab59597959f2),
    LL(0xae15d084842a8454), LL(0xa7e4c57272d572b7), LL(0xdd72ec3939e439d5), LL(0x6198164c4c2d4c5a),
    LL(0x3bbc945e5e655eca), LL(0x85f09f7878fd78e7), LL(0xd870e53838e038dd), LL(0x8605988c8c0a8c14),
    LL(0xb2bf17d1d163d1c6), LL(0x0b57e4a5a5aea541), LL(0x4dd9a1e2e2afe243), LL(0xf8c24e616199612f),
    LL(0x457b42b3b3f6b3f1), LL(0xa542342121842115), LL(0xd625089c9c4a9c94), LL(0x663cee1e1e781ef0),
    LL(0x5286614343114322), LL(0xfc93b1c7c73bc776), LL(0x2be54ffcfcd7fcb3), LL(0x1408240404100420),
    LL(0x08a2e351515951b2), LL(0xc72f2599995e99bc), LL(0xc4da226d6da96d4f), LL(0x391a650d0d340d68),
    LL(0x35e979fafacffa83), LL(0x84a369dfdf5bdfb6), LL(0x9bfca97e7ee57ed7), LL(0xb44819242490243d),
    LL(0xd776fe3b3bec3bc5), LL(0x3d4b9aabab96ab31), LL(0xd181f0cece1fce3e), LL(0x5522991111441188),
    LL(0x8903838f8f068f0c), LL(0x6b9c044e4e254e4a), LL(0x517366b7b7e6b7d1), LL(0x60cbe0ebeb8beb0b),
    LL(0xcc78c13c3cf03cfd), LL(0xbf1ffd81813e817c), LL(0xfe354094946a94d4), LL(0x0cf31cf7f7fbf7eb),
    LL(0x676f18b9b9deb9a1), LL(0x5f268b13134c1398), LL(0x9c58512c2cb02c7d), LL(0xb8bb05d3d36bd3d6),
    LL(0x5cd38ce7e7bbe76b), LL(0xcbdc396e6ea56e57), LL(0xf395aac4c437c46e), LL(0x0f061b03030c0318),
    LL(0x13acdc565645568a), LL(0x49885e44440d441a), LL(0x9efea07f7fe17fdf), LL(0x374f88a9a99ea921),
    LL(0x8254672a2aa82a4d), LL(0x6d6b0abbbbd6bbb1), LL(0xe29f87c1c123c146), LL(0x02a6f153535153a2),
    LL(0x8ba572dcdc57dcae), LL(0x2716530b0b2c0b58), LL(0xd327019d9d4e9d9c), LL(0xc1d82b6c6cad6c47),
    LL(0xf562a43131c43195), LL(0xb9e8f37474cd7487), LL(0x09f115f6f6fff6e3), LL(0x438c4c464605460a),
    LL(0x2645a5acac8aac09), LL(0x970fb589891e893c), LL(0x4428b414145014a0), LL(0x42dfbae1e1a3e15b),
    LL(0x4e2ca616165816b0), LL(0xd274f73a3ae83acd), LL(0xd0d2066969b9696f), LL(0x2d12410909240948),
    LL(0xade0d77070dd70a7), LL(0x54716fb6b6e2b6d9), LL(0xb7bd1ed0d067d0ce), LL(0x7ec7d6eded93ed3b),
    LL(0xdb85e2cccc17cc2e), LL(0x578468424215422a), LL(0xc22d2c98985a98b4), LL(0x0e55eda4a4aaa449),
    LL(0x8850752828a0285d), LL(0x31b8865c5c6d5cda), LL(0x3fed6bf8f8c7f893), LL(0xa411c28686228644),
};

static const u64 C4[256] = {
    LL(0xc07830d818186018), LL(0x05af462623238c23), LL(0x7ef991b8c6c63fc6), LL(0x136fcdfbe8e887e8),
    LL(0x4ca113cb87872687), LL(0xa9626d11b8b8dab8), LL(0x0805020901010401), LL(0x426e9e0d4f4f214f),
    LL(0xadee6c9b3636d836), LL(0x590451ffa6a6a2a6), LL(0xdebdb90cd2d26fd2), LL(0xfb06f70ef5f5f3f5),
    LL(0xef80f2967979f979), LL(0x5fcede306f6fa16f), LL(0xfcef3f6d91917e91), LL(0xaa07a4f852525552),
    LL(0x27fdc04760609d60), LL(0x89766535bcbccabc), LL(0xaccd2b379b9b569b), LL(0x048c018a8e8e028e),
    LL(0x71155bd2a3a3b6a3), LL(0x603c186c0c0c300c), LL(0xff8af6847b7bf17b), LL(0xb5e16a803535d435),
    LL(0xe8693af51d1d741d), LL(0x5347ddb3e0e0a7e0), LL(0xf6acb321d7d77bd7), LL(0x5eed999cc2c22fc2),
    LL(0x6d965c432e2eb82e), LL(0x627a96294b4b314b), LL(0xa321e15dfefedffe), LL(0x8216aed557574157),
    LL(0xa8412abd15155415), LL(0x9fb6eee87777c177), LL(0xa5eb6e923737dc37), LL(0x7b56d79ee5e5b3e5),
    LL(0x8cd923139f9f469f), LL(0xd317fd23f0f0e7f0), LL(0x6a7f94204a4a354a), LL(0x9e95a944dada4fda),
    LL(0xfa25b0a258587d58), LL(0x06ca8fcfc9c903c9), LL(0x558d527c2929a429), LL(0x5022145a0a0a280a),
    LL(0xe14f7f50b1b1feb1), LL(0x691a5dc9a0a0baa0), LL(0x7fdad6146b6bb16b), LL(0x5cab17d985852e85),
    LL(0x8173673cbdbdcebd), LL(0xd234ba8f5d5d695d), LL(0x8050209010104010), LL(0xf303f507f4f4f7f4),
    LL(0x16c08bddcbcb0bcb), LL(0xedc67cd33e3ef83e), LL(0x28110a2d05051405), LL(0x1fe6ce7867678167),
    LL(0x7353d597e4e4b7e4), LL(0x25bb4e0227279c27), LL(0x3258827341411941), LL(0x2c9d0ba78b8b168b),
    LL(0x510153f6a7a7a6a7), LL(0xcf94fab27d7de97d), LL(0xdcfb374995956e95), LL(0x8e9fad56d8d847d8),
    LL(0x8b30eb70fbfbcbfb), LL(0x2371c1cdeeee9fee), LL(0xc791f8bb7c7ced7c), LL(0x17e3cc7166668566),
    LL(0xa68ea77bdddd53dd), LL(0xb84b2eaf17175c17), LL(0x02468e4547470147), LL(0x84dc211a9e9e429e),
    LL(0x1ec589d4caca0fca), LL(0x75995a582d2db42d), LL(0x9179632ebfbfc6bf), LL(0x381b0e3f07071c07),
    LL(0x012347acadad8ead), LL(0xea2fb4b05a5a755a), LL(0x6cb51bef83833683), LL(0x85ff66b63333cc33),
    LL(0x3ff2c65c63639163), LL(0x100a041202020802), LL(0x39384993aaaa92aa), LL(0xafa8e2de7171d971),
    LL(0x0ecf8dc6c8c807c8), LL(0xc87d32d119196419), LL(0x7270923b49493949), LL(0x869aaf5fd9d943d9),
    LL(0xc31df931f2f2eff2), LL(0x4b48dba8e3e3abe3), LL(0xe22ab6b95b5b715b), LL(0x34920dbc88881a88),
    LL(0xa4c8293e9a9a529a), LL(0x2dbe4c0b26269826), LL(0x8dfa64bf3232c832), LL(0xe94a7d59b0b0fab0),
    LL(0x1b6acff2e9e983e9), LL(0x78331e770f0f3c0f), LL(0xe6a6b733d5d573d5), LL(0x74ba1df480803a80),
    LL(0x997c6127bebec2be), LL(0x26de87ebcdcd13cd), LL(0xbde468893434d034), LL(0x7a75903248483d48),
    LL(0xab24e354ffffdbff), LL(0xf78ff48d7a7af57a), LL(0xf4ea3d6490907a90), LL(0xc23ebe9d5f5f615f),
    LL(0x1da0403d20208020), LL(0x67d5d00f6868bd68), LL(0xd07234ca1a1a681a), LL(0x192c41b7aeae82ae),
    LL(0xc95e757db4b4eab4), LL(0x9a19a8ce54544d54), LL(0xece53b7f93937693), LL(0x0daa442f22228822),
    LL(0x07e9c86364648d64), LL(0xdb12ff2af1f1e3f1), LL(0xbfa2e6cc7373d173), LL(0x905a248212124812),
    LL(0x3a5d807a40401d40), LL(0x4028104808082008), LL(0x56e89b95c3c32bc3), LL(0x337bc5dfecec97ec),
    LL(0x9690ab4ddbdb4bdb), LL(0x611f5fc0a1a1bea1), LL(0x1c8307918d8d0e8d), LL(0xf5c97ac83d3df43d),
    LL(0xccf1335b97976697), LL(0x0000000000000000), LL(0x36d483f9cfcf1bcf), LL(0x4587566e2b2bac2b),
    LL(0x97b3ece17676c576), LL(0x64b019e682823282), LL(0xfea9b128d6d67fd6), LL(0xd87736c31b1b6c1b),
    LL(0xc15b7774b5b5eeb5), LL(0x112943beafaf86af), LL(0x77dfd41d6a6ab56a), LL(0xba0da0ea50505d50),
    LL(0x124c8a5745450945), LL(0xcb18fb38f3f3ebf3), LL(0x9df060ad3030c030), LL(0x2b74c3c4efef9bef),
    LL(0xe5c37eda3f3ffc3f), LL(0x921caac755554955), LL(0x791059dba2a2b2a2), LL(0x0365c9e9eaea8fea),
    LL(0x0fecca6a65658965), LL(0xb9686903babad2ba), LL(0x65935e4a2f2fbc2f), LL(0x4ee79d8ec0c027c0),
    LL(0xbe81a160dede5fde), LL(0xe06c38fc1c1c701c), LL(0xbb2ee746fdfdd3fd), LL(0x52649a1f4d4d294d),
    LL(0xe4e0397692927292), LL(0x8fbceafa7575c975), LL(0x301e0c3606061806), LL(0x249809ae8a8a128a),
    LL(0xf940794bb2b2f2b2), LL(0x6359d185e6e6bfe6), LL(0x70361c7e0e0e380e), LL(0xf8633ee71f1f7c1f),
    LL(0x37f7c45562629562), LL(0xeea3b53ad4d477d4), LL(0x29324d81a8a89aa8), LL(0xc4f4315296966296),
    LL(0x9b3aef62f9f9c3f9), LL(0x66f697a3c5c533c5), LL(0x35b14a1025259425), LL(0xf220b2ab59597959),
    LL(0x54ae15d084842a84), LL(0xb7a7e4c57272d572), LL(0xd5dd72ec3939e439), LL(0x5a6198164c4c2d4c),
    LL(0xca3bbc945e5e655e), LL(0xe785f09f7878fd78), LL(0xddd870e53838e038), LL(0x148605988c8c0a8c),
    LL(0xc6b2bf17d1d163d1), LL(0x410b57e4a5a5aea5), LL(0x434dd9a1e2e2afe2), LL(0x2ff8c24e61619961),
    LL(0xf1457b42b3b3f6b3), LL(0x15a5423421218421), LL(0x94d625089c9c4a9c), LL(0xf0663cee1e1e781e),
    LL(0x2252866143431143), LL(0x76fc93b1c7c73bc7), LL(0xb32be54ffcfcd7fc), LL(0x2014082404041004),
    LL(0xb208a2e351515951), LL(0xbcc72f2599995e99), LL(0x4fc4da226d6da96d), LL(0x68391a650d0d340d),
    LL(0x8335e979fafacffa), LL(0xb684a369dfdf5bdf), LL(0xd79bfca97e7ee57e), LL(0x3db4481924249024),
    LL(0xc5d776fe3b3bec3b), LL(0x313d4b9aabab96ab), LL(0x3ed181f0cece1fce), LL(0x8855229911114411),
    LL(0x0c8903838f8f068f), LL(0x4a6b9c044e4e254e), LL(0xd1517366b7b7e6b7), LL(0x0b60cbe0ebeb8beb),
    LL(0xfdcc78c13c3cf03c), LL(0x7cbf1ffd81813e81), LL(0xd4fe354094946a94), LL(0xeb0cf31cf7f7fbf7),
    LL(0xa1676f18b9b9deb9), LL(0x985f268b13134c13), LL(0x7d9c58512c2cb02c), LL(0xd6b8bb05d3d36bd3),
    LL(0x6b5cd38ce7e7bbe7), LL(0x57cbdc396e6ea56e), LL(0x6ef395aac4c437c4), LL(0x180f061b03030c03),
    LL(0x8a13acdc56564556), LL(0x1a49885e44440d44), LL(0xdf9efea07f7fe17f), LL(0x21374f88a9a99ea9),
    LL(0x4d8254672a2aa82a), LL(0xb16d6b0abbbbd6bb), LL(0x46e29f87c1c123c1), LL(0xa202a6f153535153),
    LL(0xae8ba572dcdc57dc), LL(0x582716530b0b2c0b), LL(0x9cd327019d9d4e9d), LL(0x47c1d82b6c6cad6c),
    LL(0x95f562a43131c431), LL(0x87b9e8f37474cd74), LL(0xe309f115f6f6fff6), LL(0x0a438c4c46460546),
    LL(0x092645a5acac8aac), LL(0x3c970fb589891e89), LL(0xa04428b414145014), LL(0x5b42dfbae1e1a3e1),
    LL(0xb04e2ca616165816), LL(0xcdd274f73a3ae83a), LL(0x6fd0d2066969b969), LL(0x482d124109092409),
    LL(0xa7ade0d77070dd70), LL(0xd954716fb6b6e2b6), LL(0xceb7bd1ed0d067d0), LL(0x3b7ec7d6eded93ed),
    LL(0x2edb85e2cccc17cc), LL(0x2a57846842421542), LL(0xb4c22d2c98985a98), LL(0x490e55eda4a4aaa4),
    LL(0x5d8850752828a028), LL(0xda31b8865c5c6d5c), LL(0x933fed6bf8f8c7f8), LL(0x44a411c286862286),
};

static const u64 C5[256] = {
    LL(0x18c07830d8181860), LL(0x2305af462623238c), LL(0xc67ef991b8c6c63f), LL(0xe8136fcdfbe8e887),
    LL(0x874ca113cb878726), LL(0xb8a9626d11b8b8da), LL(0x0108050209010104), LL(0x4f426e9e0d4f4f21),
    LL(0x36adee6c9b3636d8), LL(0xa6590451ffa6a6a2), LL(0xd2debdb90cd2d26f), LL(0xf5fb06f70ef5f5f3),
    LL(0x79ef80f2967979f9), LL(0x6f5fcede306f6fa1), LL(0x91fcef3f6d91917e), LL(0x52aa07a4f8525255),
    LL(0x6027fdc04760609d), LL(0xbc89766535bcbcca), LL(0x9baccd2b379b9b56), LL(0x8e048c018a8e8e02),
    LL(0xa371155bd2a3a3b6), LL(0x0c603c186c0c0c30), LL(0x7bff8af6847b7bf1), LL(0x35b5e16a803535d4),
    LL(0x1de8693af51d1d74), LL(0xe05347ddb3e0e0a7), LL(0xd7f6acb321d7d77b), LL(0xc25eed999cc2c22f),
    LL(0x2e6d965c432e2eb8), LL(0x4b627a96294b4b31), LL(0xfea321e15dfefedf), LL(0x578216aed5575741),
    LL(0x15a8412abd151554), LL(0x779fb6eee87777c1), LL(0x37a5eb6e923737dc), LL(0xe57b56d79ee5e5b3),
    LL(0x9f8cd923139f9f46), LL(0xf0d317fd23f0f0e7), LL(0x4a6a7f94204a4a35), LL(0xda9e95a944dada4f),
    LL(0x58fa25b0a258587d), LL(0xc906ca8fcfc9c903), LL(0x29558d527c2929a4), LL(0x0a5022145a0a0a28),
    LL(0xb1e14f7f50b1b1fe), LL(0xa0691a5dc9a0a0ba), LL(0x6b7fdad6146b6bb1), LL(0x855cab17d985852e),
    LL(0xbd8173673cbdbdce), LL(0x5dd234ba8f5d5d69), LL(0x1080502090101040), LL(0xf4f303f507f4f4f7),
    LL(0xcb16c08bddcbcb0b), LL(0x3eedc67cd33e3ef8), LL(0x0528110a2d050514), LL(0x671fe6ce78676781),
    LL(0xe47353d597e4e4b7), LL(0x2725bb4e0227279c), LL(0x4132588273414119), LL(0x8b2c9d0ba78b8b16),
    LL(0xa7510153f6a7a7a6), LL(0x7dcf94fab27d7de9), LL(0x95dcfb374995956e), LL(0xd88e9fad56d8d847),
    LL(0xfb8b30eb70fbfbcb), LL(0xee2371c1cdeeee9f), LL(0x7cc791f8bb7c7ced), LL(0x6617e3cc71666685),
    LL(0xdda68ea77bdddd53), LL(0x17b84b2eaf17175c), LL(0x4702468e45474701), LL(0x9e84dc211a9e9e42),
    LL(0xca1ec589d4caca0f), LL(0x2d75995a582d2db4), LL(0xbf9179632ebfbfc6), LL(0x07381b0e3f07071c),
    LL(0xad012347acadad8e), LL(0x5aea2fb4b05a5a75), LL(0x836cb51bef838336), LL(0x3385ff66b63333cc),
    LL(0x633ff2c65c636391), LL(0x02100a0412020208), LL(0xaa39384993aaaa92), LL(0x71afa8e2de7171d9),
    LL(0xc80ecf8dc6c8c807), LL(0x19c87d32d1191964), LL(0x497270923b494939), LL(0xd9869aaf5fd9d943),
    LL(0xf2c31df931f2f2ef), LL(0xe34b48dba8e3e3ab), LL(0x5be22ab6b95b5b71), LL(0x8834920dbc88881a),
    LL(0x9aa4c8293e9a9a52), LL(0x262dbe4c0b262698), LL(0x328dfa64bf3232c8), LL(0xb0e94a7d59b0b0fa),
    LL(0xe91b6acff2e9e983), LL(0x0f78331e770f0f3c), LL(0xd5e6a6b733d5d573), LL(0x8074ba1df480803a),
    LL(0xbe997c6127bebec2), LL(0xcd26de87ebcdcd13), LL(0x34bde468893434d0), LL(0x487a75903248483d),
    LL(0xffab24e354ffffdb), LL(0x7af78ff48d7a7af5), LL(0x90f4ea3d6490907a), LL(0x5fc23ebe9d5f5f61),
    LL(0x201da0403d202080), LL(0x6867d5d00f6868bd), LL(0x1ad07234ca1a1a68), LL(0xae192c41b7aeae82),
    LL(0xb4c95e757db4b4ea), LL(0x549a19a8ce54544d), LL(0x93ece53b7f939376), LL(0x220daa442f222288),
    LL(0x6407e9c86364648d), LL(0xf1db12ff2af1f1e3), LL(0x73bfa2e6cc7373d1), LL(0x12905a2482121248),
    LL(0x403a5d807a40401d), LL(0x0840281048080820), LL(0xc356e89b95c3c32b), LL(0xec337bc5dfecec97),
    LL(0xdb9690ab4ddbdb4b), LL(0xa1611f5fc0a1a1be), LL(0x8d1c8307918d8d0e), LL(0x3df5c97ac83d3df4),
    LL(0x97ccf1335b979766), LL(0x0000000000000000), LL(0xcf36d483f9cfcf1b), LL(0x2b4587566e2b2bac),
    LL(0x7697b3ece17676c5), LL(0x8264b019e6828232), LL(0xd6fea9b128d6d67f), LL(0x1bd87736c31b1b6c),
    LL(0xb5c15b7774b5b5ee), LL(0xaf112943beafaf86), LL(0x6a77dfd41d6a6ab5), LL(0x50ba0da0ea50505d),
    LL(0x45124c8a57454509), LL(0xf3cb18fb38f3f3eb), LL(0x309df060ad3030c0), LL(0xef2b74c3c4efef9b),
    LL(0x3fe5c37eda3f3ffc), LL(0x55921caac7555549), LL(0xa2791059dba2a2b2), LL(0xea0365c9e9eaea8f),
    LL(0x650fecca6a656589), LL(0xbab9686903babad2), LL(0x2f65935e4a2f2fbc), LL(0xc04ee79d8ec0c027),
    LL(0xdebe81a160dede5f), LL(0x1ce06c38fc1c1c70), LL(0xfdbb2ee746fdfdd3), LL(0x4d52649a1f4d4d29),
    LL(0x92e4e03976929272), LL(0x758fbceafa7575c9), LL(0x06301e0c36060618), LL(0x8a249809ae8a8a12),
    LL(0xb2f940794bb2b2f2), LL(0xe66359d185e6e6bf), LL(0x0e70361c7e0e0e38), LL(0x1ff8633ee71f1f7c),
    LL(0x6237f7c455626295), LL(0xd4eea3b53ad4d477), LL(0xa829324d81a8a89a), LL(0x96c4f43152969662),
    LL(0xf99b3aef62f9f9c3), LL(0xc566f697a3c5c533), LL(0x2535b14a10252594), LL(0x59f220b2ab595979),
    LL(0x8454ae15d084842a), LL(0x72b7a7e4c57272d5), LL(0x39d5dd72ec3939e4), LL(0x4c5a6198164c4c2d),
    LL(0x5eca3bbc945e5e65), LL(0x78e785f09f7878fd), LL(0x38ddd870e53838e0), LL(0x8c148605988c8c0a),
    LL(0xd1c6b2bf17d1d163), LL(0xa5410b57e4a5a5ae), LL(0xe2434dd9a1e2e2af), LL(0x612ff8c24e616199),
    LL(0xb3f1457b42b3b3f6), LL(0x2115a54234212184), LL(0x9c94d625089c9c4a), LL(0x1ef0663cee1e1e78),
    LL(0x4322528661434311), LL(0xc776fc93b1c7c73b), LL(0xfcb32be54ffcfcd7), LL(0x0420140824040410),
    LL(0x51b208a2e3515159), LL(0x99bcc72f2599995e), LL(0x6d4fc4da226d6da9), LL(0x0d68391a650d0d34),
    LL(0xfa8335e979fafacf), LL(0xdfb684a369dfdf5b), LL(0x7ed79bfca97e7ee5), LL(0x243db44819242490),
    LL(0x3bc5d776fe3b3bec), LL(0xab313d4b9aabab96), LL(0xce3ed181f0cece1f), LL(0x1188552299111144),
    LL(0x8f0c8903838f8f06), LL(0x4e4a6b9c044e4e25), LL(0xb7d1517366b7b7e6), LL(0xeb0b60cbe0ebeb8b),
    LL(0x3cfdcc78c13c3cf0), LL(0x817cbf1ffd81813e), LL(0x94d4fe354094946a), LL(0xf7eb0cf31cf7f7fb),
    LL(0xb9a1676f18b9b9de), LL(0x13985f268b13134c), LL(0x2c7d9c58512c2cb0), LL(0xd3d6b8bb05d3d36b),
    LL(0xe76b5cd38ce7e7bb), LL(0x6e57cbdc396e6ea5), LL(0xc46ef395aac4c437), LL(0x03180f061b03030c),
    LL(0x568a13acdc565645), LL(0x441a49885e44440d), LL(0x7fdf9efea07f7fe1), LL(0xa921374f88a9a99e),
    LL(0x2a4d8254672a2aa8), LL(0xbbb16d6b0abbbbd6), LL(0xc146e29f87c1c123), LL(0x53a202a6f1535351),
    LL(0xdcae8ba572dcdc57), LL(0x0b582716530b0b2c), LL(0x9d9cd327019d9d4e), LL(0x6c47c1d82b6c6cad),
    LL(0x3195f562a43131c4), LL(0x7487b9e8f37474cd), LL(0xf6e309f115f6f6ff), LL(0x460a438c4c464605),
    LL(0xac092645a5acac8a), LL(0x893c970fb589891e), LL(0x14a04428b4141450), LL(0xe15b42dfbae1e1a3),
    LL(0x16b04e2ca6161658), LL(0x3acdd274f73a3ae8), LL(0x696fd0d2066969b9), LL(0x09482d1241090924),
    LL(0x70a7ade0d77070dd), LL(0xb6d954716fb6b6e2), LL(0xd0ceb7bd1ed0d067), LL(0xed3b7ec7d6eded93),
    LL(0xcc2edb85e2cccc17), LL(0x422a578468424215), LL(0x98b4c22d2c98985a), LL(0xa4490e55eda4a4aa),
    LL(0x285d8850752828a0), LL(0x5cda31b8865c5c6d), LL(0xf8933fed6bf8f8c7), LL(0x8644a411c2868622),
};

static const u64 C6[256] = {
    LL(0x6018c07830d81818), LL(0x8c2305af46262323), LL(0x3fc67ef991b8c6c6), LL(0x87e8136fcdfbe8e8),
    LL(0x26874ca113cb8787), LL(0xdab8a9626d11b8b8), LL(0x0401080502090101), LL(0x214f426e9e0d4f4f),
    LL(0xd836adee6c9b3636), LL(0xa2a6590451ffa6a6), LL(0x6fd2debdb90cd2d2), LL(0xf3f5fb06f70ef5f5),
    LL(0xf979ef80f2967979), LL(0xa16f5fcede306f6f), LL(0x7e91fcef3f6d9191), LL(0x5552aa07a4f85252),
    LL(0x9d6027fdc0476060), LL(0xcabc89766535bcbc), LL(0x569baccd2b379b9b), LL(0x028e048c018a8e8e),
    LL(0xb6a371155bd2a3a3), LL(0x300c603c186c0c0c), LL(0xf17bff8af6847b7b), LL(0xd435b5e16a803535),
    LL(0x741de8693af51d1d), LL(0xa7e05347ddb3e0e0), LL(0x7bd7f6acb321d7d7), LL(0x2fc25eed999cc2c2),
    LL(0xb82e6d965c432e2e), LL(0x314b627a96294b4b), LL(0xdffea321e15dfefe), LL(0x41578216aed55757),
    LL(0x5415a8412abd1515), LL(0xc1779fb6eee87777), LL(0xdc37a5eb6e923737), LL(0xb3e57b56d79ee5e5),
    LL(0x469f8cd923139f9f), LL(0xe7f0d317fd23f0f0), LL(0x354a6a7f94204a4a), LL(0x4fda9e95a944dada),
    LL(0x7d58fa25b0a25858), LL(0x03c906ca8fcfc9c9), LL(0xa429558d527c2929), LL(0x280a5022145a0a0a),
    LL(0xfeb1e14f7f50b1b1), LL(0xbaa0691a5dc9a0a0), LL(0xb16b7fdad6146b6b), LL(0x2e855cab17d98585),
    LL(0xcebd8173673cbdbd), LL(0x695dd234ba8f5d5d), LL(0x4010805020901010), LL(0xf7f4f303f507f4f4),
    LL(0x0bcb16c08bddcbcb), LL(0xf83eedc67cd33e3e), LL(0x140528110a2d0505), LL(0x81671fe6ce786767),
    LL(0xb7e47353d597e4e4), LL(0x9c2725bb4e022727), LL(0x1941325882734141), LL(0x168b2c9d0ba78b8b),
    LL(0xa6a7510153f6a7a7), LL(0xe97dcf94fab27d7d), LL(0x6e95dcfb37499595), LL(0x47d88e9fad56d8d8),
    LL(0xcbfb8b30eb70fbfb), LL(0x9fee2371c1cdeeee), LL(0xed7cc791f8bb7c7c), LL(0x856617e3cc716666),
    LL(0x53dda68ea77bdddd), LL(0x5c17b84b2eaf1717), LL(0x014702468e454747), LL(0x429e84dc211a9e9e),
    LL(0x0fca1ec589d4caca), LL(0xb42d75995a582d2d), LL(0xc6bf9179632ebfbf), LL(0x1c07381b0e3f0707),
    LL(0x8ead012347acadad), LL(0x755aea2fb4b05a5a), LL(0x36836cb51bef8383), LL(0xcc3385ff66b63333),
    LL(0x91633ff2c65c6363), LL(0x0802100a04120202), LL(0x92aa39384993aaaa), LL(0xd971afa8e2de7171),
    LL(0x07c80ecf8dc6c8c8), LL(0x6419c87d32d11919), LL(0x39497270923b4949), LL(0x43d9869aaf5fd9d9),
    LL(0xeff2c31df931f2f2), LL(0xabe34b48dba8e3e3), LL(0x715be22ab6b95b5b), LL(0x1a8834920dbc8888),
    LL(0x529aa4c8293e9a9a), LL(0x98262dbe4c0b2626), LL(0xc8328dfa64bf3232), LL(0xfab0e94a7d59b0b0),
    LL(0x83e91b6acff2e9e9), LL(0x3c0f78331e770f0f), LL(0x73d5e6a6b733d5d5), LL(0x3a8074ba1df48080),
    LL(0xc2be997c6127bebe), LL(0x13cd26de87ebcdcd), LL(0xd034bde468893434), LL(0x3d487a7590324848),
    LL(0xdbffab24e354ffff), LL(0xf57af78ff48d7a7a), LL(0x7a90f4ea3d649090), LL(0x615fc23ebe9d5f5f),
    LL(0x80201da0403d2020), LL(0xbd6867d5d00f6868), LL(0x681ad07234ca1a1a), LL(0x82ae192c41b7aeae),
    LL(0xeab4c95e757db4b4), LL(0x4d549a19a8ce5454), LL(0x7693ece53b7f9393), LL(0x88220daa442f2222),
    LL(0x8d6407e9c8636464), LL(0xe3f1db12ff2af1f1), LL(0xd173bfa2e6cc7373), LL(0x4812905a24821212),
    LL(0x1d403a5d807a4040), LL(0x2008402810480808), LL(0x2bc356e89b95c3c3), LL(0x97ec337bc5dfecec),
    LL(0x4bdb9690ab4ddbdb), LL(0xbea1611f5fc0a1a1), LL(0x0e8d1c8307918d8d), LL(0xf43df5c97ac83d3d),
    LL(0x6697ccf1335b9797), LL(0x0000000000000000), LL(0x1bcf36d483f9cfcf), LL(0xac2b4587566e2b2b),
    LL(0xc57697b3ece17676), LL(0x328264b019e68282), LL(0x7fd6fea9b128d6d6), LL(0x6c1bd87736c31b1b),
    LL(0xeeb5c15b7774b5b5), LL(0x86af112943beafaf), LL(0xb56a77dfd41d6a6a), LL(0x5d50ba0da0ea5050),
    LL(0x0945124c8a574545), LL(0xebf3cb18fb38f3f3), LL(0xc0309df060ad3030), LL(0x9bef2b74c3c4efef),
    LL(0xfc3fe5c37eda3f3f), LL(0x4955921caac75555), LL(0xb2a2791059dba2a2), LL(0x8fea0365c9e9eaea),
    LL(0x89650fecca6a6565), LL(0xd2bab9686903baba), LL(0xbc2f65935e4a2f2f), LL(0x27c04ee79d8ec0c0),
    LL(0x5fdebe81a160dede), LL(0x701ce06c38fc1c1c), LL(0xd3fdbb2ee746fdfd), LL(0x294d52649a1f4d4d),
    LL(0x7292e4e039769292), LL(0xc9758fbceafa7575), LL(0x1806301e0c360606), LL(0x128a249809ae8a8a),
    LL(0xf2b2f940794bb2b2), LL(0xbfe66359d185e6e6), LL(0x380e70361c7e0e0e), LL(0x7c1ff8633ee71f1f),
    LL(0x956237f7c4556262), LL(0x77d4eea3b53ad4d4), LL(0x9aa829324d81a8a8), LL(0x6296c4f431529696),
    LL(0xc3f99b3aef62f9f9), LL(0x33c566f697a3c5c5), LL(0x942535b14a102525), LL(0x7959f220b2ab5959),
    LL(0x2a8454ae15d08484), LL(0xd572b7a7e4c57272), LL(0xe439d5dd72ec3939), LL(0x2d4c5a6198164c4c),
    LL(0x655eca3bbc945e5e), LL(0xfd78e785f09f7878), LL(0xe038ddd870e53838), LL(0x0a8c148605988c8c),
    LL(0x63d1c6b2bf17d1d1), LL(0xaea5410b57e4a5a5), LL(0xafe2434dd9a1e2e2), LL(0x99612ff8c24e6161),
    LL(0xf6b3f1457b42b3b3), LL(0x842115a542342121), LL(0x4a9c94d625089c9c), LL(0x781ef0663cee1e1e),
    LL(0x1143225286614343), LL(0x3bc776fc93b1c7c7), LL(0xd7fcb32be54ffcfc), LL(0x1004201408240404),
    LL(0x5951b208a2e35151), LL(0x5e99bcc72f259999), LL(0xa96d4fc4da226d6d), LL(0x340d68391a650d0d),
    LL(0xcffa8335e979fafa), LL(0x5bdfb684a369dfdf), LL(0xe57ed79bfca97e7e), LL(0x90243db448192424),
    LL(0xec3bc5d776fe3b3b), LL(0x96ab313d4b9aabab), LL(0x1fce3ed181f0cece), LL(0x4411885522991111),
    LL(0x068f0c8903838f8f), LL(0x254e4a6b9c044e4e), LL(0xe6b7d1517366b7b7), LL(0x8beb0b60cbe0ebeb),
    LL(0xf03cfdcc78c13c3c), LL(0x3e817cbf1ffd8181), LL(0x6a94d4fe35409494), LL(0xfbf7eb0cf31cf7f7),
    LL(0xdeb9a1676f18b9b9), LL(0x4c13985f268b1313), LL(0xb02c7d9c58512c2c), LL(0x6bd3d6b8bb05d3d3),
    LL(0xbbe76b5cd38ce7e7), LL(0xa56e57cbdc396e6e), LL(0x37c46ef395aac4c4), LL(0x0c03180f061b0303),
    LL(0x45568a13acdc5656), LL(0x0d441a49885e4444), LL(0xe17fdf9efea07f7f), LL(0x9ea921374f88a9a9),
    LL(0xa82a4d8254672a2a), LL(0xd6bbb16d6b0abbbb), LL(0x23c146e29f87c1c1), LL(0x5153a202a6f15353),
    LL(0x57dcae8ba572dcdc), LL(0x2c0b582716530b0b), LL(0x4e9d9cd327019d9d), LL(0xad6c47c1d82b6c6c),
    LL(0xc43195f562a43131), LL(0xcd7487b9e8f37474), LL(0xfff6e309f115f6f6), LL(0x05460a438c4c4646),
    LL(0x8aac092645a5acac), LL(0x1e893c970fb58989), LL(0x5014a04428b41414), LL(0xa3e15b42dfbae1e1),
    LL(0x5816b04e2ca61616), LL(0xe83acdd274f73a3a), LL(0xb9696fd0d2066969), LL(0x2409482d12410909),
    LL(0xdd70a7ade0d77070), LL(0xe2b6d954716fb6b6), LL(0x67d0ceb7bd1ed0d0), LL(0x93ed3b7ec7d6eded),
    LL(0x17cc2edb85e2cccc), LL(0x15422a5784684242), LL(0x5a98b4c22d2c9898), LL(0xaaa4490e55eda4a4),
    LL(0xa0285d8850752828), LL(0x6d5cda31b8865c5c), LL(0xc7f8933fed6bf8f8), LL(0x228644a411c28686),
};

static const u64 C7[256] = {
    LL(0x186018c07830d818), LL(0x238c2305af462623), LL(0xc63fc67ef991b8c6), LL(0xe887e8136fcdfbe8),
    LL(0x8726874ca113cb87), LL(0xb8dab8a9626d11b8), LL(0x0104010805020901), LL(0x4f214f426e9e0d4f),
    LL(0x36d836adee6c9b36), LL(0xa6a2a6590451ffa6), LL(0xd26fd2debdb90cd2), LL(0xf5f3f5fb06f70ef5),
    LL(0x79f979ef80f29679), LL(0x6fa16f5fcede306f), LL(0x917e91fcef3f6d91), LL(0x525552aa07a4f852),
    LL(0x609d6027fdc04760), LL(0xbccabc89766535bc), LL(0x9b569baccd2b379b), LL(0x8e028e048c018a8e),
    LL(0xa3b6a371155bd2a3), LL(0x0c300c603c186c0c), LL(0x7bf17bff8af6847b), LL(0x35d435b5e16a8035),
    LL(0x1d741de8693af51d), LL(0xe0a7e05347ddb3e0), LL(0xd77bd7f6acb321d7), LL(0xc22fc25eed999cc2),
    LL(0x2eb82e6d965c432e), LL(0x4b314b627a96294b), LL(0xfedffea321e15dfe), LL(0x5741578216aed557),
    LL(0x155415a8412abd15), LL(0x77c1779fb6eee877), LL(0x37dc37a5eb6e9237), LL(0xe5b3e57b56d79ee5),
    LL(0x9f469f8cd923139f), LL(0xf0e7f0d317fd23f0), LL(0x4a354a6a7f94204a), LL(0xda4fda9e95a944da),
    LL(0x587d58fa25b0a258), LL(0xc903c906ca8fcfc9), LL(0x29a429558d527c29), LL(0x0a280a5022145a0a),
    LL(0xb1feb1e14f7f50b1), LL(0xa0baa0691a5dc9a0), LL(0x6bb16b7fdad6146b), LL(0x852e855cab17d985),
    LL(0xbdcebd8173673cbd), LL(0x5d695dd234ba8f5d), LL(0x1040108050209010), LL(0xf4f7f4f303f507f4),
    LL(0xcb0bcb16c08bddcb), LL(0x3ef83eedc67cd33e), LL(0x05140528110a2d05), LL(0x6781671fe6ce7867),
    LL(0xe4b7e47353d597e4), LL(0x279c2725bb4e0227), LL(0x4119413258827341), LL(0x8b168b2c9d0ba78b),
    LL(0xa7a6a7510153f6a7), LL(0x7de97dcf94fab27d), LL(0x956e95dcfb374995), LL(0xd847d88e9fad56d8),
    LL(0xfbcbfb8b30eb70fb), LL(0xee9fee2371c1cdee), LL(0x7ced7cc791f8bb7c), LL(0x66856617e3cc7166),
    LL(0xdd53dda68ea77bdd), LL(0x175c17b84b2eaf17), LL(0x47014702468e4547), LL(0x9e429e84dc211a9e),
    LL(0xca0fca1ec589d4ca), LL(0x2db42d75995a582d), LL(0xbfc6bf9179632ebf), LL(0x071c07381b0e3f07),
    LL(0xad8ead012347acad), LL(0x5a755aea2fb4b05a), LL(0x8336836cb51bef83), LL(0x33cc3385ff66b633),
    LL(0x6391633ff2c65c63), LL(0x020802100a041202), LL(0xaa92aa39384993aa), LL(0x71d971afa8e2de71),
    LL(0xc807c80ecf8dc6c8), LL(0x196419c87d32d119), LL(0x4939497270923b49), LL(0xd943d9869aaf5fd9),
    LL(0xf2eff2c31df931f2), LL(0xe3abe34b48dba8e3), LL(0x5b715be22ab6b95b), LL(0x881a8834920dbc88),
    LL(0x9a529aa4c8293e9a), LL(0x2698262dbe4c0b26), LL(0x32c8328dfa64bf32), LL(0xb0fab0e94a7d59b0),
    LL(0xe983e91b6acff2e9), LL(0x0f3c0f78331e770f), LL(0xd573d5e6a6b733d5), LL(0x803a8074ba1df480),
    LL(0xbec2be997c6127be), LL(0xcd13cd26de87ebcd), LL(0x34d034bde4688934), LL(0x483d487a75903248),
    LL(0xffdbffab24e354ff), LL(0x7af57af78ff48d7a), LL(0x907a90f4ea3d6490), LL(0x5f615fc23ebe9d5f),
    LL(0x2080201da0403d20), LL(0x68bd6867d5d00f68), LL(0x1a681ad07234ca1a), LL(0xae82ae192c41b7ae),
    LL(0xb4eab4c95e757db4), LL(0x544d549a19a8ce54), LL(0x937693ece53b7f93), LL(0x2288220daa442f22),
    LL(0x648d6407e9c86364), LL(0xf1e3f1db12ff2af1), LL(0x73d173bfa2e6cc73), LL(0x124812905a248212),
    LL(0x401d403a5d807a40), LL(0x0820084028104808), LL(0xc32bc356e89b95c3), LL(0xec97ec337bc5dfec),
    LL(0xdb4bdb9690ab4ddb), LL(0xa1bea1611f5fc0a1), LL(0x8d0e8d1c8307918d), LL(0x3df43df5c97ac83d),
    LL(0x976697ccf1335b97), LL(0x0000000000000000), LL(0xcf1bcf36d483f9cf), LL(0x2bac2b4587566e2b),
    LL(0x76c57697b3ece176), LL(0x82328264b019e682), LL(0xd67fd6fea9b128d6), LL(0x1b6c1bd87736c31b),
    LL(0xb5eeb5c15b7774b5), LL(0xaf86af112943beaf), LL(0x6ab56a77dfd41d6a), LL(0x505d50ba0da0ea50),
    LL(0x450945124c8a5745), LL(0xf3ebf3cb18fb38f3), LL(0x30c0309df060ad30), LL(0xef9bef2b74c3c4ef),
    LL(0x3ffc3fe5c37eda3f), LL(0x554955921caac755), LL(0xa2b2a2791059dba2), LL(0xea8fea0365c9e9ea),
    LL(0x6589650fecca6a65), LL(0xbad2bab9686903ba), LL(0x2fbc2f65935e4a2f), LL(0xc027c04ee79d8ec0),
    LL(0xde5fdebe81a160de), LL(0x1c701ce06c38fc1c), LL(0xfdd3fdbb2ee746fd), LL(0x4d294d52649a1f4d),
    LL(0x927292e4e0397692), LL(0x75c9758fbceafa75), LL(0x061806301e0c3606), LL(0x8a128a249809ae8a),
    LL(0xb2f2b2f940794bb2), LL(0xe6bfe66359d185e6), LL(0x0e380e70361c7e0e), LL(0x1f7c1ff8633ee71f),
    LL(0x62956237f7c45562), LL(0xd477d4eea3b53ad4), LL(0xa89aa829324d81a8), LL(0x966296c4f4315296),
    LL(0xf9c3f99b3aef62f9), LL(0xc533c566f697a3c5), LL(0x25942535b14a1025), LL(0x597959f220b2ab59),
    LL(0x842a8454ae15d084), LL(0x72d572b7a7e4c572), LL(0x39e439d5dd72ec39), LL(0x4c2d4c5a6198164c),
    LL(0x5e655eca3bbc945e), LL(0x78fd78e785f09f78), LL(0x38e038ddd870e538), LL(0x8c0a8c148605988c),
    LL(0xd163d1c6b2bf17d1), LL(0xa5aea5410b57e4a5), LL(0xe2afe2434dd9a1e2), LL(0x6199612ff8c24e61),
    LL(0xb3f6b3f1457b42b3), LL(0x21842115a5423421), LL(0x9c4a9c94d625089c), LL(0x1e781ef0663cee1e),
    LL(0x4311432252866143), LL(0xc73bc776fc93b1c7), LL(0xfcd7fcb32be54ffc), LL(0x0410042014082404),
    LL(0x515951b208a2e351), LL(0x995e99bcc72f2599), LL(0x6da96d4fc4da226d), LL(0x0d340d68391a650d),
    LL(0xfacffa8335e979fa), LL(0xdf5bdfb684a369df), LL(0x7ee57ed79bfca97e), LL(0x2490243db4481924),
    LL(0x3bec3bc5d776fe3b), LL(0xab96ab313d4b9aab), LL(0xce1fce3ed181f0ce), LL(0x1144118855229911),
    LL(0x8f068f0c8903838f), LL(0x4e254e4a6b9c044e), LL(0xb7e6b7d1517366b7), LL(0xeb8beb0b60cbe0eb),
    LL(0x3cf03cfdcc78c13c), LL(0x813e817cbf1ffd81), LL(0x946a94d4fe354094), LL(0xf7fbf7eb0cf31cf7),
    LL(0xb9deb9a1676f18b9), LL(0x134c13985f268b13), LL(0x2cb02c7d9c58512c), LL(0xd36bd3d6b8bb05d3),
    LL(0xe7bbe76b5cd38ce7), LL(0x6ea56e57cbdc396e), LL(0xc437c46ef395aac4), LL(0x030c03180f061b03),
    LL(0x5645568a13acdc56), LL(0x440d441a49885e44), LL(0x7fe17fdf9efea07f), LL(0xa99ea921374f88a9),
    LL(0x2aa82a4d8254672a), LL(0xbbd6bbb16d6b0abb), LL(0xc123c146e29f87c1), LL(0x535153a202a6f153),
    LL(0xdc57dcae8ba572dc), LL(0x0b2c0b582716530b), LL(0x9d4e9d9cd327019d), LL(0x6cad6c47c1d82b6c),
    LL(0x31c43195f562a431), LL(0x74cd7487b9e8f374), LL(0xf6fff6e309f115f6), LL(0x4605460a438c4c46),
    LL(0xac8aac092645a5ac), LL(0x891e893c970fb589), LL(0x145014a04428b414), LL(0xe1a3e15b42dfbae1),
    LL(0x165816b04e2ca616), LL(0x3ae83acdd274f73a), LL(0x69b9696fd0d20669), LL(0x092409482d124109),
    LL(0x70dd70a7ade0d770), LL(0xb6e2b6d954716fb6), LL(0xd067d0ceb7bd1ed0), LL(0xed93ed3b7ec7d6ed),
    LL(0xcc17cc2edb85e2cc), LL(0x4215422a57846842), LL(0x985a98b4c22d2c98), LL(0xa4aaa4490e55eda4),
    LL(0x28a0285d88507528), LL(0x5c6d5cda31b8865c), LL(0xf8c7f8933fed6bf8), LL(0x86228644a411c286),
};


static const u64 rc[WHIRLPOOL_R + 1] = {
    LL(0x0000000000000000),
    LL(0x1823c6e887b8014f),
    LL(0x36a6d2f5796f9152),
    LL(0x60bc9b8ea30c7b35),
    LL(0x1de0d7c22e4bfe57),
    LL(0x157737e59ff04ada),
    LL(0x58c9290ab1a06b85),
    LL(0xbd5d10f4cb3e0567),
    LL(0xe427418ba77d95d8),
    LL(0xfbee7c66dd17479e),
    LL(0xca2dbf07ad5a8333),
};

/**
 * The core Whirlpool transform.
 */
static void processBuffer(struct NESSIEstruct * const structpointer) {
    int i, r;
    u64 K[8];        /* the round key */
    u64 block[8];    /* mu(buffer) */
    u64 state[8];    /* the cipher state */
    u64 L[8];
    u8 *buffer = structpointer->buffer;
    for (i = 0; i < 8; i++, buffer += 8) {
        block[i] =
            (((u64)buffer[0]        ) << 56) ^
            (((u64)buffer[1] & 0xffL) << 48) ^
            (((u64)buffer[2] & 0xffL) << 40) ^
            (((u64)buffer[3] & 0xffL) << 32) ^
            (((u64)buffer[4] & 0xffL) << 24) ^
            (((u64)buffer[5] & 0xffL) << 16) ^
            (((u64)buffer[6] & 0xffL) <<  8) ^
            (((u64)buffer[7] & 0xffL)      );
    }
    /*
     * compute and apply K^0 to the cipher state:
     */
    state[0] = block[0] ^ (K[0] = structpointer->hash[0]);
    state[1] = block[1] ^ (K[1] = structpointer->hash[1]);
    state[2] = block[2] ^ (K[2] = structpointer->hash[2]);
    state[3] = block[3] ^ (K[3] = structpointer->hash[3]);
    state[4] = block[4] ^ (K[4] = structpointer->hash[4]);
    state[5] = block[5] ^ (K[5] = structpointer->hash[5]);
    state[6] = block[6] ^ (K[6] = structpointer->hash[6]);
    state[7] = block[7] ^ (K[7] = structpointer->hash[7]);
    /*
     * iterate over all rounds:
     */
    for (r = 1; r <= WHIRLPOOL_R; r++) {
    ///for (r = 1; r <= 5; r++) {
        /*
         * compute K^r from K^{r-1}:
         */
        L[0] =
            C0[(int)(K[0] >> 56)       ] ^
            C1[(int)(K[7] >> 48) & 0xff] ^
            C2[(int)(K[6] >> 40) & 0xff] ^
            C3[(int)(K[5] >> 32) & 0xff] ^
            C4[(int)(K[4] >> 24) & 0xff] ^
            C5[(int)(K[3] >> 16) & 0xff] ^
            C6[(int)(K[2] >>  8) & 0xff] ^
            C7[(int)(K[1]      ) & 0xff] ^
            rc[r];
        L[1] =
            C0[(int)(K[1] >> 56)       ] ^
            C1[(int)(K[0] >> 48) & 0xff] ^
            C2[(int)(K[7] >> 40) & 0xff] ^
            C3[(int)(K[6] >> 32) & 0xff] ^
            C4[(int)(K[5] >> 24) & 0xff] ^
            C5[(int)(K[4] >> 16) & 0xff] ^
            C6[(int)(K[3] >>  8) & 0xff] ^
            C7[(int)(K[2]      ) & 0xff];
        L[2] =
            C0[(int)(K[2] >> 56)       ] ^
            C1[(int)(K[1] >> 48) & 0xff] ^
            C2[(int)(K[0] >> 40) & 0xff] ^
            C3[(int)(K[7] >> 32) & 0xff] ^
            C4[(int)(K[6] >> 24) & 0xff] ^
            C5[(int)(K[5] >> 16) & 0xff] ^
            C6[(int)(K[4] >>  8) & 0xff] ^
            C7[(int)(K[3]      ) & 0xff];
        L[3] =
            C0[(int)(K[3] >> 56)       ] ^
            C1[(int)(K[2] >> 48) & 0xff] ^
            C2[(int)(K[1] >> 40) & 0xff] ^
            C3[(int)(K[0] >> 32) & 0xff] ^
            C4[(int)(K[7] >> 24) & 0xff] ^
            C5[(int)(K[6] >> 16) & 0xff] ^
            C6[(int)(K[5] >>  8) & 0xff] ^
            C7[(int)(K[4]      ) & 0xff];
        L[4] =
            C0[(int)(K[4] >> 56)       ] ^
            C1[(int)(K[3] >> 48) & 0xff] ^
            C2[(int)(K[2] >> 40) & 0xff] ^
            C3[(int)(K[1] >> 32) & 0xff] ^
            C4[(int)(K[0] >> 24) & 0xff] ^
            C5[(int)(K[7] >> 16) & 0xff] ^
            C6[(int)(K[6] >>  8) & 0xff] ^
            C7[(int)(K[5]      ) & 0xff];
        L[5] =
            C0[(int)(K[5] >> 56)       ] ^
            C1[(int)(K[4] >> 48) & 0xff] ^
            C2[(int)(K[3] >> 40) & 0xff] ^
            C3[(int)(K[2] >> 32) & 0xff] ^
            C4[(int)(K[1] >> 24) & 0xff] ^
            C5[(int)(K[0] >> 16) & 0xff] ^
            C6[(int)(K[7] >>  8) & 0xff] ^
            C7[(int)(K[6]      ) & 0xff];
        L[6] =
            C0[(int)(K[6] >> 56)       ] ^
            C1[(int)(K[5] >> 48) & 0xff] ^
            C2[(int)(K[4] >> 40) & 0xff] ^
            C3[(int)(K[3] >> 32) & 0xff] ^
            C4[(int)(K[2] >> 24) & 0xff] ^
            C5[(int)(K[1] >> 16) & 0xff] ^
            C6[(int)(K[0] >>  8) & 0xff] ^
            C7[(int)(K[7]      ) & 0xff];
        L[7] =
            C0[(int)(K[7] >> 56)       ] ^
            C1[(int)(K[6] >> 48) & 0xff] ^
            C2[(int)(K[5] >> 40) & 0xff] ^
            C3[(int)(K[4] >> 32) & 0xff] ^
            C4[(int)(K[3] >> 24) & 0xff] ^
            C5[(int)(K[2] >> 16) & 0xff] ^
            C6[(int)(K[1] >>  8) & 0xff] ^
            C7[(int)(K[0]      ) & 0xff];
        K[0] = L[0];
        K[1] = L[1];
        K[2] = L[2];
        K[3] = L[3];
        K[4] = L[4];
        K[5] = L[5];
        K[6] = L[6];
        K[7] = L[7];
        /*
         * apply the r-th round transformation:
         */
        L[0] =
            C0[(int)(state[0] >> 56)       ] ^
            C1[(int)(state[7] >> 48) & 0xff] ^
            C2[(int)(state[6] >> 40) & 0xff] ^
            C3[(int)(state[5] >> 32) & 0xff] ^
            C4[(int)(state[4] >> 24) & 0xff] ^
            C5[(int)(state[3] >> 16) & 0xff] ^
            C6[(int)(state[2] >>  8) & 0xff] ^
            C7[(int)(state[1]      ) & 0xff] ^
            K[0];
        L[1] =
            C0[(int)(state[1] >> 56)       ] ^
            C1[(int)(state[0] >> 48) & 0xff] ^
            C2[(int)(state[7] >> 40) & 0xff] ^
            C3[(int)(state[6] >> 32) & 0xff] ^
            C4[(int)(state[5] >> 24) & 0xff] ^
            C5[(int)(state[4] >> 16) & 0xff] ^
            C6[(int)(state[3] >>  8) & 0xff] ^
            C7[(int)(state[2]      ) & 0xff] ^
            K[1];
        L[2] =
            C0[(int)(state[2] >> 56)       ] ^
            C1[(int)(state[1] >> 48) & 0xff] ^
            C2[(int)(state[0] >> 40) & 0xff] ^
            C3[(int)(state[7] >> 32) & 0xff] ^
            C4[(int)(state[6] >> 24) & 0xff] ^
            C5[(int)(state[5] >> 16) & 0xff] ^
            C6[(int)(state[4] >>  8) & 0xff] ^
            C7[(int)(state[3]      ) & 0xff] ^
            K[2];
        L[3] =
            C0[(int)(state[3] >> 56)       ] ^
            C1[(int)(state[2] >> 48) & 0xff] ^
            C2[(int)(state[1] >> 40) & 0xff] ^
            C3[(int)(state[0] >> 32) & 0xff] ^
            C4[(int)(state[7] >> 24) & 0xff] ^
            C5[(int)(state[6] >> 16) & 0xff] ^
            C6[(int)(state[5] >>  8) & 0xff] ^
            C7[(int)(state[4]      ) & 0xff] ^
            K[3];
        L[4] =
            C0[(int)(state[4] >> 56)       ] ^
            C1[(int)(state[3] >> 48) & 0xff] ^
            C2[(int)(state[2] >> 40) & 0xff] ^
            C3[(int)(state[1] >> 32) & 0xff] ^
            C4[(int)(state[0] >> 24) & 0xff] ^
            C5[(int)(state[7] >> 16) & 0xff] ^
            C6[(int)(state[6] >>  8) & 0xff] ^
            C7[(int)(state[5]      ) & 0xff] ^
            K[4];
        L[5] =
            C0[(int)(state[5] >> 56)       ] ^
            C1[(int)(state[4] >> 48) & 0xff] ^
            C2[(int)(state[3] >> 40) & 0xff] ^
            C3[(int)(state[2] >> 32) & 0xff] ^
            C4[(int)(state[1] >> 24) & 0xff] ^
            C5[(int)(state[0] >> 16) & 0xff] ^
            C6[(int)(state[7] >>  8) & 0xff] ^
            C7[(int)(state[6]      ) & 0xff] ^
            K[5];
        L[6] =
            C0[(int)(state[6] >> 56)       ] ^
            C1[(int)(state[5] >> 48) & 0xff] ^
            C2[(int)(state[4] >> 40) & 0xff] ^
            C3[(int)(state[3] >> 32) & 0xff] ^
            C4[(int)(state[2] >> 24) & 0xff] ^
            C5[(int)(state[1] >> 16) & 0xff] ^
            C6[(int)(state[0] >>  8) & 0xff] ^
            C7[(int)(state[7]      ) & 0xff] ^
            K[6];
        L[7] =
            C0[(int)(state[7] >> 56)       ] ^
            C1[(int)(state[6] >> 48) & 0xff] ^
            C2[(int)(state[5] >> 40) & 0xff] ^
            C3[(int)(state[4] >> 32) & 0xff] ^
            C4[(int)(state[3] >> 24) & 0xff] ^
            C5[(int)(state[2] >> 16) & 0xff] ^
            C6[(int)(state[1] >>  8) & 0xff] ^
            C7[(int)(state[0]      ) & 0xff] ^
            K[7];
        state[0] = L[0];
        state[1] = L[1];
        state[2] = L[2];
        state[3] = L[3];
        state[4] = L[4];
        state[5] = L[5];
        state[6] = L[6];
        state[7] = L[7];
    }
    /*
     * apply the Miyaguchi-Preneel compression function:
     */
    structpointer->hash[0] ^= state[0] ^ block[0];
    structpointer->hash[1] ^= state[1] ^ block[1];
    structpointer->hash[2] ^= state[2] ^ block[2];
    structpointer->hash[3] ^= state[3] ^ block[3];
    structpointer->hash[4] ^= state[4] ^ block[4];
    structpointer->hash[5] ^= state[5] ^ block[5];
    structpointer->hash[6] ^= state[6] ^ block[6];
    structpointer->hash[7] ^= state[7] ^ block[7];
}

/**
 * Initialize the hashing state.
 */
void NESSIEinit(struct NESSIEstruct * const structpointer) {
    int i;

    memset(structpointer->bitLength, 0, 32);
    structpointer->bufferBits = structpointer->bufferPos = 0;
    structpointer->buffer[0] = 0; /* it's only necessary to cleanup buffer[bufferPos] */
    for (i = 0; i < 8; i++) {
        structpointer->hash[i] = 0L; /* initial value */
    }
}

/**
 * Delivers input data to the hashing algorithm.
 *
 * @param    source        plaintext data to hash.
 * @param    sourceBits    how many bits of plaintext to process.
 *
 * This method maintains the invariant: bufferBits < DIGESTBITS
 */
void NESSIEadd(const unsigned char * const source,
			   unsigned long sourceBits,
               struct NESSIEstruct * const structpointer) {
    /*
                       sourcePos
                       |
                       +-------+-------+-------
                          ||||||||||||||||||||| source
                       +-------+-------+-------
    +-------+-------+-------+-------+-------+-------
    ||||||||||||||||||||||                           buffer
    +-------+-------+-------+-------+-------+-------
                    |
                    bufferPos
    */
    int sourcePos    = 0; /* index of leftmost source u8 containing data (1 to 8 bits). */
    int sourceGap    = (8 - ((int)sourceBits & 7)) & 7; /* space on source[sourcePos]. */
    int bufferRem    = structpointer->bufferBits & 7; /* occupied bits on buffer[bufferPos]. */
    int i;
    u32 b, carry;
    u8 *buffer       = structpointer->buffer;
    u8 *bitLength    = structpointer->bitLength;
    int bufferBits   = structpointer->bufferBits;
    int bufferPos    = structpointer->bufferPos;

    /*
     * tally the length of the added data:
     */
    u64 value = sourceBits;
    for (i = 31, carry = 0; i >= 0 && (carry != 0 || value != LL(0)); i--) {
        carry += bitLength[i] + ((u32)value & 0xff);
        bitLength[i] = (u8)carry;
        carry >>= 8;
        value >>= 8;
    }
    /*
     * process data in chunks of 8 bits (a more efficient approach would be to take whole-word chunks):
     */
    while (sourceBits > 8) {
        /* N.B. at least source[sourcePos] and source[sourcePos+1] contain data. */
        /*
         * take a byte from the source:
         */
        b = ((source[sourcePos] << sourceGap) & 0xff) |
            ((source[sourcePos + 1] & 0xff) >> (8 - sourceGap));
        /*
         * process this byte:
         */
        buffer[bufferPos++] |= (u8)(b >> bufferRem);
        bufferBits += 8 - bufferRem; /* bufferBits = 8*bufferPos; */
        if (bufferBits == DIGESTBITS) {
            /*
             * process data block:
             */
            processBuffer(structpointer);
            /*
             * reset buffer:
             */
            bufferBits = bufferPos = 0;
        }
        buffer[bufferPos] = b << (8 - bufferRem);
        bufferBits += bufferRem;
        /*
         * proceed to remaining data:
         */
        sourceBits -= 8;
        sourcePos++;
    }
    /* now 0 <= sourceBits <= 8;
     * furthermore, all data (if any is left) is in source[sourcePos].
     */
    if (sourceBits > 0) {
        b = (source[sourcePos] << sourceGap) & 0xff; /* bits are left-justified on b. */
        /*
         * process the remaining bits:
         */
        buffer[bufferPos] |= b >> bufferRem;
    } else {
        b = 0;
    }
    if (bufferRem + sourceBits < 8) {
        /*
         * all remaining data fits on buffer[bufferPos],
         * and there still remains some space.
         */
        bufferBits += sourceBits;
    } else {
        /*
         * buffer[bufferPos] is full:
         */
        bufferPos++;
        bufferBits += 8 - bufferRem; /* bufferBits = 8*bufferPos; */
        sourceBits -= 8 - bufferRem;
        /* now 0 <= sourceBits < 8;
         * furthermore, all data (if any is left) is in source[sourcePos].
         */
        if (bufferBits == DIGESTBITS) {
            /*
             * process data block:
             */
            processBuffer(structpointer);
            /*
             * reset buffer:
             */
            bufferBits = bufferPos = 0;
        }
        buffer[bufferPos] = b << (8 - bufferRem);
        bufferBits += (int)sourceBits;
    }
    structpointer->bufferBits   = bufferBits;
    structpointer->bufferPos    = bufferPos;
}
void NESSIEadd64(const unsigned char * const source,
			   uint64_t sourceBits,
               struct NESSIEstruct * const structpointer) {
    /*
                       sourcePos
                       |
                       +-------+-------+-------
                          ||||||||||||||||||||| source
                       +-------+-------+-------
    +-------+-------+-------+-------+-------+-------
    ||||||||||||||||||||||                           buffer
    +-------+-------+-------+-------+-------+-------
                    |
                    bufferPos
    */
    int sourcePos    = 0; /* index of leftmost source u8 containing data (1 to 8 bits). */
    int sourceGap    = (8 - ((int)sourceBits & 7)) & 7; /* space on source[sourcePos]. */
    int bufferRem    = structpointer->bufferBits & 7; /* occupied bits on buffer[bufferPos]. */
    int i;
    u32 b, carry;
    u8 *buffer       = structpointer->buffer;
    u8 *bitLength    = structpointer->bitLength;
    int bufferBits   = structpointer->bufferBits;
    int bufferPos    = structpointer->bufferPos;

    /*
     * tally the length of the added data:
     */
    u64 value = sourceBits;
    for (i = 31, carry = 0; i >= 0 && (carry != 0 || value != LL(0)); i--) {
        carry += bitLength[i] + ((u32)value & 0xff);
        bitLength[i] = (u8)carry;
        carry >>= 8;
        value >>= 8;
    }
    /*
     * process data in chunks of 8 bits (a more efficient approach would be to take whole-word chunks):
     */
    while (sourceBits > 8) {
        /* N.B. at least source[sourcePos] and source[sourcePos+1] contain data. */
        /*
         * take a byte from the source:
         */
        b = ((source[sourcePos] << sourceGap) & 0xff) |
            ((source[sourcePos + 1] & 0xff) >> (8 - sourceGap));
        /*
         * process this byte:
         */
        buffer[bufferPos++] |= (u8)(b >> bufferRem);
        bufferBits += 8 - bufferRem; /* bufferBits = 8*bufferPos; */
        if (bufferBits == DIGESTBITS) {
            /*
             * process data block:
             */
            processBuffer(structpointer);
            /*
             * reset buffer:
             */
            bufferBits = bufferPos = 0;
        }
        buffer[bufferPos] = b << (8 - bufferRem);
        bufferBits += bufferRem;
        /*
         * proceed to remaining data:
         */
        sourceBits -= 8;
        sourcePos++;
    }
    /* now 0 <= sourceBits <= 8;
     * furthermore, all data (if any is left) is in source[sourcePos].
     */
    if (sourceBits > 0) {
        b = (source[sourcePos] << sourceGap) & 0xff; /* bits are left-justified on b. */
        /*
         * process the remaining bits:
         */
        buffer[bufferPos] |= b >> bufferRem;
    } else {
        b = 0;
    }
    if (bufferRem + sourceBits < 8) {
        /*
         * all remaining data fits on buffer[bufferPos],
         * and there still remains some space.
         */
        bufferBits += sourceBits;
    } else {
        /*
         * buffer[bufferPos] is full:
         */
        bufferPos++;
        bufferBits += 8 - bufferRem; /* bufferBits = 8*bufferPos; */
        sourceBits -= 8 - bufferRem;
        /* now 0 <= sourceBits < 8;
         * furthermore, all data (if any is left) is in source[sourcePos].
         */
        if (bufferBits == DIGESTBITS) {
            /*
             * process data block:
             */
            processBuffer(structpointer);
            /*
             * reset buffer:
             */
            bufferBits = bufferPos = 0;
        }
        buffer[bufferPos] = b << (8 - bufferRem);
        bufferBits += (int)sourceBits;
    }
    structpointer->bufferBits   = bufferBits;
    structpointer->bufferPos    = bufferPos;
}

/**
 * Get the hash value from the hashing state.
 * 
 * This method uses the invariant: bufferBits < DIGESTBITS
 */
void NESSIEfinalize(struct NESSIEstruct * const structpointer,
                    unsigned char * const result) {
    int i;
    u8 *buffer      = structpointer->buffer;
    u8 *bitLength   = structpointer->bitLength;
    int bufferBits  = structpointer->bufferBits;
    int bufferPos   = structpointer->bufferPos;
    u8 *digest      = result;

    /*
     * append a '1'-bit:
     */
    buffer[bufferPos] |= 0x80U >> (bufferBits & 7);
    bufferPos++; /* all remaining bits on the current u8 are set to zero. */
    /*
     * pad with zero bits to complete (N*WBLOCKBITS - LENGTHBITS) bits:
     */
    if (bufferPos > WBLOCKBYTES - LENGTHBYTES) {
        if (bufferPos < WBLOCKBYTES) {
            memset(&buffer[bufferPos], 0, WBLOCKBYTES - bufferPos);
        }
        /*
         * process data block:
         */
        processBuffer(structpointer);
        /*
         * reset buffer:
         */
        bufferPos = 0;
    }
    if (bufferPos < WBLOCKBYTES - LENGTHBYTES) {
        memset(&buffer[bufferPos], 0, (WBLOCKBYTES - LENGTHBYTES) - bufferPos);
    }
    bufferPos = WBLOCKBYTES - LENGTHBYTES;
    /*
     * append bit length of hashed data:
     */
    memcpy(&buffer[WBLOCKBYTES - LENGTHBYTES], bitLength, LENGTHBYTES);
    /*
     * process data block:
     */
    processBuffer(structpointer);
    /*
     * return the completed message digest:
     */
    for (i = 0; i < DIGESTBYTES/8; i++) {
        digest[0] = (u8)(structpointer->hash[i] >> 56);
        digest[1] = (u8)(structpointer->hash[i] >> 48);
        digest[2] = (u8)(structpointer->hash[i] >> 40);
        digest[3] = (u8)(structpointer->hash[i] >> 32);
        digest[4] = (u8)(structpointer->hash[i] >> 24);
        digest[5] = (u8)(structpointer->hash[i] >> 16);
        digest[6] = (u8)(structpointer->hash[i] >>  8);
        digest[7] = (u8)(structpointer->hash[i]      );
        digest += 8;
    }
    structpointer->bufferBits   = bufferBits;
    structpointer->bufferPos    = bufferPos;
}





// This is free and unencumbered software released into the public domain under The Unlicense (http://unlicense.org/)
// main repo: https://github.com/wangyi-fudan/wyhash
// author:  Wang Yi <godspeed_china@yeah.net>
// contributors: Reini Urban, Dietrich Epp, Joshua Haberman, Tommy Ettinger, Daniel Lemire, Otmar Ertl, cocowalla, leo-yuriev, Diego Barrios Romero, paulie-g, dumblob, Yann Collet, ivte-ms, hyb, James Z.M. Gao, easyaspi314 (Devin), TheOneric

/* quick example:
   string s="fjsakfdsjkf";
   uint64_t hash=wyhash(s.c_str(), s.size(), 0, _wyp);
*/

#define wyhash_final_version_3

#ifndef WYHASH_CONDOM
//protections that produce different results:
//1: normal valid behavior
//2: extra protection against entropy loss (probability=2^-63), aka. "blind multiplication"
#define WYHASH_CONDOM 1
#endif

#ifndef WYHASH_32BIT_MUM
//0: normal version, slow on 32 bit systems
//1: faster on 32 bit systems but produces different results, incompatible with wy2u0k function
#define WYHASH_32BIT_MUM 0  
#endif

//includes
#include <stdint.h>
#include <string.h>
#if defined(_MSC_VER) && defined(_M_X64)
  #include <intrin.h>
  #pragma intrinsic(_umul128)
#endif

//likely and unlikely macros
#if defined(__GNUC__) || defined(__INTEL_COMPILER) || defined(__clang__)
  #define _likely_(x)  __builtin_expect(x,1)
  #define _unlikely_(x)  __builtin_expect(x,0)
#else
  #define _likely_(x) (x)
  #define _unlikely_(x) (x)
#endif

//128bit multiply function
static inline uint64_t _wyrot(uint64_t x) { return (x>>32)|(x<<32); }
static inline void _wymum(uint64_t *A, uint64_t *B){
#if(WYHASH_32BIT_MUM)
  uint64_t hh=(*A>>32)*(*B>>32), hl=(*A>>32)*(uint32_t)*B, lh=(uint32_t)*A*(*B>>32), ll=(uint64_t)(uint32_t)*A*(uint32_t)*B;
  #if(WYHASH_CONDOM>1)
  *A^=_wyrot(hl)^hh; *B^=_wyrot(lh)^ll;
  #else
  *A=_wyrot(hl)^hh; *B=_wyrot(lh)^ll;
  #endif
#elif defined(__SIZEOF_INT128__)
  __uint128_t r=*A; r*=*B; 
  #if(WYHASH_CONDOM>1)
  *A^=(uint64_t)r; *B^=(uint64_t)(r>>64);
  #else
  *A=(uint64_t)r; *B=(uint64_t)(r>>64);
  #endif
#elif defined(_MSC_VER) && defined(_M_X64)
  #if(WYHASH_CONDOM>1)
  uint64_t  a,  b;
  a=_umul128(*A,*B,&b);
  *A^=a;  *B^=b;
  #else
  *A=_umul128(*A,*B,B);
  #endif
#else
  uint64_t ha=*A>>32, hb=*B>>32, la=(uint32_t)*A, lb=(uint32_t)*B, hi, lo;
  uint64_t rh=ha*hb, rm0=ha*lb, rm1=hb*la, rl=la*lb, t=rl+(rm0<<32), c=t<rl;
  lo=t+(rm1<<32); c+=lo<t; hi=rh+(rm0>>32)+(rm1>>32)+c;
  #if(WYHASH_CONDOM>1)
  *A^=lo;  *B^=hi;
  #else
  *A=lo;  *B=hi;
  #endif
#endif
}

//multiply and xor mix function, aka MUM
static inline uint64_t _wymix(uint64_t A, uint64_t B){ _wymum(&A,&B); return A^B; }

//endian macros
#ifndef WYHASH_LITTLE_ENDIAN
  #if defined(_WIN32) || defined(__LITTLE_ENDIAN__) || (defined(__BYTE_ORDER__) && __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__)
    #define WYHASH_LITTLE_ENDIAN 1
  #elif defined(__BIG_ENDIAN__) || (defined(__BYTE_ORDER__) && __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__)
    #define WYHASH_LITTLE_ENDIAN 0
  #else
    #warning could not determine endianness! Falling back to little endian.
    #define WYHASH_LITTLE_ENDIAN 1
  #endif
#endif

//read functions
#if (WYHASH_LITTLE_ENDIAN)
static inline uint64_t _wyr8(const uint8_t *p) { uint64_t v; memcpy(&v, p, 8); return v;}
static inline uint64_t _wyr4(const uint8_t *p) { uint32_t v; memcpy(&v, p, 4); return v;}
#elif defined(__GNUC__) || defined(__INTEL_COMPILER) || defined(__clang__)
static inline uint64_t _wyr8(const uint8_t *p) { uint64_t v; memcpy(&v, p, 8); return __builtin_bswap64(v);}
static inline uint64_t _wyr4(const uint8_t *p) { uint32_t v; memcpy(&v, p, 4); return __builtin_bswap32(v);}
#elif defined(_MSC_VER)
static inline uint64_t _wyr8(const uint8_t *p) { uint64_t v; memcpy(&v, p, 8); return _byteswap_uint64(v);}
static inline uint64_t _wyr4(const uint8_t *p) { uint32_t v; memcpy(&v, p, 4); return _byteswap_ulong(v);}
#else
static inline uint64_t _wyr8(const uint8_t *p) {
  uint64_t v; memcpy(&v, p, 8);
  return (((v >> 56) & 0xff)| ((v >> 40) & 0xff00)| ((v >> 24) & 0xff0000)| ((v >>  8) & 0xff000000)| ((v <<  8) & 0xff00000000)| ((v << 24) & 0xff0000000000)| ((v << 40) & 0xff000000000000)| ((v << 56) & 0xff00000000000000));
}
static inline uint64_t _wyr4(const uint8_t *p) {
  uint32_t v; memcpy(&v, p, 4);
  return (((v >> 24) & 0xff)| ((v >>  8) & 0xff00)| ((v <<  8) & 0xff0000)| ((v << 24) & 0xff000000));
}
#endif
static inline uint64_t _wyr3(const uint8_t *p, size_t k) { return (((uint64_t)p[0])<<16)|(((uint64_t)p[k>>1])<<8)|p[k-1];}
//wyhash main function
static inline uint64_t wyhash(const void *key, size_t len, uint64_t seed, const uint64_t *secret){
  const uint8_t *p=(const uint8_t *)key; seed^=*secret;	uint64_t	a,	b;
  if(_likely_(len<=16)){
    if(_likely_(len>=4)){ a=(_wyr4(p)<<32)|_wyr4(p+((len>>3)<<2)); b=(_wyr4(p+len-4)<<32)|_wyr4(p+len-4-((len>>3)<<2)); }
    else if(_likely_(len>0)){ a=_wyr3(p,len); b=0;}
    else a=b=0;
  }
  else{
    size_t i=len; 
    if(_unlikely_(i>48)){
      uint64_t see1=seed, see2=seed;
      do{
        seed=_wymix(_wyr8(p)^secret[1],_wyr8(p+8)^seed);
        see1=_wymix(_wyr8(p+16)^secret[2],_wyr8(p+24)^see1);
        see2=_wymix(_wyr8(p+32)^secret[3],_wyr8(p+40)^see2);
        p+=48; i-=48;
      }while(_likely_(i>48));
      seed^=see1^see2;
    }
    while(_unlikely_(i>16)){  seed=_wymix(_wyr8(p)^secret[1],_wyr8(p+8)^seed);  i-=16; p+=16;  }
    a=_wyr8(p+i-16);  b=_wyr8(p+i-8);
  }
  return _wymix(secret[1]^len,_wymix(a^secret[1],b^seed));
}

//the default secret parameters
static const uint64_t _wyp[4] = {0xa0761d6478bd642full, 0xe7037ed1a0b428dbull, 0x8ebc6af09c88c6e3ull, 0x589965cc75374cc3ull};

//a useful 64bit-64bit mix function to produce deterministic pseudo random numbers that can pass BigCrush and PractRand
static inline uint64_t wyhash64(uint64_t A, uint64_t B){ A^=0xa0761d6478bd642full; B^=0xe7037ed1a0b428dbull; _wymum(&A,&B); return _wymix(A^0xa0761d6478bd642full,B^0xe7037ed1a0b428dbull);}

//The wyrand PRNG that pass BigCrush and PractRand
static inline uint64_t wyrand(uint64_t *seed){ *seed+=0xa0761d6478bd642full; return _wymix(*seed,*seed^0xe7037ed1a0b428dbull);}

//convert any 64 bit pseudo random numbers to uniform distribution [0,1). It can be combined with wyrand, wyhash64 or wyhash.
static inline double wy2u01(uint64_t r){ const double _wynorm=1.0/(1ull<<52); return (r>>12)*_wynorm;}

//convert any 64 bit pseudo random numbers to APPROXIMATE Gaussian distribution. It can be combined with wyrand, wyhash64 or wyhash.
static inline double wy2gau(uint64_t r){ const double _wynorm=1.0/(1ull<<20); return ((r&0x1fffff)+((r>>21)&0x1fffff)+((r>>42)&0x1fffff))*_wynorm-3.0;}

#if(!WYHASH_32BIT_MUM)
//fast range integer random number generation on [0,k) credit to Daniel Lemire. May not work when WYHASH_32BIT_MUM=1. It can be combined with wyrand, wyhash64 or wyhash.
static inline uint64_t wy2u0k(uint64_t r, uint64_t k){ _wymum(&r,&k); return k; }
#endif

//make your own secret
static inline void make_secret(uint64_t seed, uint64_t *secret){
  uint8_t c[] = {15, 23, 27, 29, 30, 39, 43, 45, 46, 51, 53, 54, 57, 58, 60, 71, 75, 77, 78, 83, 85, 86, 89, 90, 92, 99, 101, 102, 105, 106, 108, 113, 114, 116, 120, 135, 139, 141, 142, 147, 149, 150, 153, 154, 156, 163, 165, 166, 169, 170, 172, 177, 178, 180, 184, 195, 197, 198, 201, 202, 204, 209, 210, 212, 216, 225, 226, 228, 232, 240 };
  for(size_t i=0;i<4;i++){
    uint8_t ok;
    do{
      ok=1; secret[i]=0;
      for(size_t j=0;j<64;j+=8) secret[i]|=((uint64_t)c[wyrand(&seed)%sizeof(c)])<<j;
      if(secret[i]%2==0){ ok=0; continue; }
      for(size_t j=0;j<i;j++) {
#if defined(__GNUC__) || defined(__INTEL_COMPILER) || defined(__clang__)
        if(__builtin_popcountll(secret[j]^secret[i])!=32){ ok=0; break; }
#elif defined(_MSC_VER) && defined(_M_X64)
        if(_mm_popcnt_u64(secret[j]^secret[i])!=32){ ok=0; break; }
#else
        //manual popcount
        uint64_t x = secret[j]^secret[i];
        x -= (x >> 1) & 0x5555555555555555;
        x = (x & 0x3333333333333333) + ((x >> 2) & 0x3333333333333333);
        x = (x + (x >> 4)) & 0x0f0f0f0f0f0f0f0f;
        x = (x * 0x0101010101010101) >> 56;
        if(x!=32){ ok=0; break; }
#endif
      }
    }while(!ok);
  }
}





// //////////////////////////////////////////////////////////
// xxhash64.h
// Copyright (c) 2016 Stephan Brumme. All rights reserved.
// see http://create.stephan-brumme.com/disclaimer.html
//

/// XXHash (64 bit), based on Yann Collet's descriptions, see http://cyan4973.github.io/xxHash/
/** How to use:
    uint64_t myseed = 0;
    XXHash64 myhash(myseed);
    myhash.add(pointerToSomeBytes,     numberOfBytes);
    myhash.add(pointerToSomeMoreBytes, numberOfMoreBytes); // call add as often as you like to ...
    // and compute hash:
    uint64_t result = myhash.hash();
    Note: my code is NOT endian-aware !
**/
class XXHash64
{
public:
  /// create new XXHash (64 bit)
  /** @param seed your seed value, even zero is a valid seed **/
  explicit XXHash64(uint64_t seed)
  {
    state[0] = seed + Prime1 + Prime2;
    state[1] = seed + Prime2;
    state[2] = seed;
    state[3] = seed - Prime1;
    bufferSize  = 0;
    totalLength = 0;
  }

  bool add(const void* input, uint64_t length)
  {
    // no data ?
    if (!input || length == 0)
      return false;

    totalLength += length;
    // byte-wise access
    const unsigned char* data = (const unsigned char*)input;

    // unprocessed old data plus new data still fit in temporary buffer ?
    if (bufferSize + length < MaxBufferSize)
    {
      // just add new data
      while (length-- > 0)
        buffer[bufferSize++] = *data++;
      return true;
    }

    // point beyond last byte
    const unsigned char* stop      = data + length;
    const unsigned char* stopBlock = stop - MaxBufferSize;

    // some data left from previous update ?
    if (bufferSize > 0)
    {
      // make sure temporary buffer is full (16 bytes)
      while (bufferSize < MaxBufferSize)
        buffer[bufferSize++] = *data++;

      // process these 32 bytes (4x8)
      process(buffer, state[0], state[1], state[2], state[3]);
    }

    // copying state to local variables helps optimizer A LOT
    uint64_t s0 = state[0], s1 = state[1], s2 = state[2], s3 = state[3];
    // 32 bytes at once
    while (data <= stopBlock)
    {
      // local variables s0..s3 instead of state[0]..state[3] are much faster
      process(data, s0, s1, s2, s3);
      data += 32;
    }
    // copy back
    state[0] = s0; state[1] = s1; state[2] = s2; state[3] = s3;

    // copy remainder to temporary buffer
    bufferSize = stop - data;
    for (unsigned int i = 0; i < bufferSize; i++)
      buffer[i] = data[i];

    // done
    return true;
  }

  uint64_t hash() const
  {
    // fold 256 bit state into one single 64 bit value
    uint64_t result;
    if (totalLength >= MaxBufferSize)
    {
      result = rotateLeft(state[0],  1) +
               rotateLeft(state[1],  7) +
               rotateLeft(state[2], 12) +
               rotateLeft(state[3], 18);
      result = (result ^ processSingle(0, state[0])) * Prime1 + Prime4;
      result = (result ^ processSingle(0, state[1])) * Prime1 + Prime4;
      result = (result ^ processSingle(0, state[2])) * Prime1 + Prime4;
      result = (result ^ processSingle(0, state[3])) * Prime1 + Prime4;
    }
    else
    {
      // internal state wasn't set in add, therefore original seed is still stored in state2
      result = state[2] + Prime5;
    }

    result += totalLength;

    // process remaining bytes in temporary buffer
    const unsigned char* data = buffer;
    // point beyond last byte
    const unsigned char* stop = data + bufferSize;

    // at least 8 bytes left ? => eat 8 bytes per step
    for (; data + 8 <= stop; data += 8)
      result = rotateLeft(result ^ processSingle(0, *(uint64_t*)data), 27) * Prime1 + Prime4;

    // 4 bytes left ? => eat those
    if (data + 4 <= stop)
    {
      result = rotateLeft(result ^ (*(uint32_t*)data) * Prime1,   23) * Prime2 + Prime3;
      data  += 4;
    }

    // take care of remaining 0..3 bytes, eat 1 byte per step
    while (data != stop)
      result = rotateLeft(result ^ (*data++) * Prime5,            11) * Prime1;

    // mix bits
    result ^= result >> 33;
    result *= Prime2;
    result ^= result >> 29;
    result *= Prime3;
    result ^= result >> 32;
    return result;
  }



private:
  /// magic constants :-)
  static const uint64_t Prime1 = 11400714785074694791ULL;
  static const uint64_t Prime2 = 14029467366897019727ULL;
  static const uint64_t Prime3 =  1609587929392839161ULL;
  static const uint64_t Prime4 =  9650029242287828579ULL;
  static const uint64_t Prime5 =  2870177450012600261ULL;

  /// temporarily store up to 31 bytes between multiple add calls
  static const uint64_t MaxBufferSize = 31+1;

  uint64_t      state[4];
  unsigned char buffer[MaxBufferSize];
  unsigned int  bufferSize;
  uint64_t      totalLength;

  /// rotate bits, should compile to a single CPU instruction (ROL)
  static inline uint64_t rotateLeft(uint64_t x, unsigned char bits)
  {
    return (x << bits) | (x >> (64 - bits));
  }

  /// process a single 64 bit value
  static inline uint64_t processSingle(uint64_t previous, uint64_t input)
  {
    return rotateLeft(previous + input * Prime2, 31) * Prime1;
  }

  /// process a block of 4x4 bytes, this is the main part of the XXHash32 algorithm
  static inline void process(const void* data, uint64_t& state0, uint64_t& state1, uint64_t& state2, uint64_t& state3)
  {
    const uint64_t* block = (const uint64_t*) data;
    state0 = processSingle(state0, block[0]);
    state1 = processSingle(state1, block[1]);
    state2 = processSingle(state2, block[2]);
    state3 = processSingle(state3, block[3]);
  }
};

/*
 * xxHash - Extremely Fast Hash algorithm
 * Header File
 * Copyright (C) 2012-2020 Yann Collet
 *
 * BSD 2-Clause License (https://www.opensource.org/licenses/bsd-license.php)
 */
#define XXH_IMPLEMENTATION   /* access definitions */
#define XXH_STATIC_LINKING_ONLY   /* *_state_t */



#if (defined(XXH_INLINE_ALL) || defined(XXH_PRIVATE_API)) \
    && !defined(XXH_INLINE_ALL_31684351384)
   /* this section should be traversed only once */
#  define XXH_INLINE_ALL_31684351384
   /* give access to the advanced API, required to compile implementations */
#  undef XXH_STATIC_LINKING_ONLY   /* avoid macro redef */
#  define XXH_STATIC_LINKING_ONLY
   /* make all functions private */
#  undef XXH_PUBLIC_API
#  if defined(__GNUC__)
#    define XXH_PUBLIC_API static __inline __attribute__((unused))
#  elif defined (__cplusplus) || (defined (__STDC_VERSION__) && (__STDC_VERSION__ >= 199901L) /* C99 */)
#    define XXH_PUBLIC_API static inline
#  elif defined(_MSC_VER)
#    define XXH_PUBLIC_API static __inline
#  else
     /* note: this version may generate warnings for unused static functions */
#    define XXH_PUBLIC_API static
#  endif

#  ifdef XXH_NAMESPACE
#    error "XXH_INLINE_ALL with XXH_NAMESPACE is not supported"
     /*
      * Note: Alternative: #undef all symbols (it's a pretty large list).
      * Without #error: it compiles, but functions are actually not inlined.
      */
#  endif
#  define XXH_NAMESPACE XXH_INLINE_
#  define XXH_IPREF(Id)   XXH_INLINE_ ## Id
#  define XXH_OK XXH_IPREF(XXH_OK)
#  define XXH_ERROR XXH_IPREF(XXH_ERROR)
#  define XXH_errorcode XXH_IPREF(XXH_errorcode)
#  define XXH32_canonical_t  XXH_IPREF(XXH32_canonical_t)
#  define XXH64_canonical_t  XXH_IPREF(XXH64_canonical_t)
#  define XXH128_canonical_t XXH_IPREF(XXH128_canonical_t)
#  define XXH32_state_s XXH_IPREF(XXH32_state_s)
#  define XXH32_state_t XXH_IPREF(XXH32_state_t)
#  define XXH64_state_s XXH_IPREF(XXH64_state_s)
#  define XXH64_state_t XXH_IPREF(XXH64_state_t)
#  define XXH3_state_s  XXH_IPREF(XXH3_state_s)
#  define XXH3_state_t  XXH_IPREF(XXH3_state_t)
#  define XXH128_hash_t XXH_IPREF(XXH128_hash_t)
   /* Ensure the header is parsed again, even if it was previously included */
#  undef XXHASH_H_5627135585666179
#  undef XXHASH_H_STATIC_13879238742
#endif /* XXH_INLINE_ALL || XXH_PRIVATE_API */



/* ****************************************************************
 *  Stable API
 *****************************************************************/
#ifndef XXHASH_H_5627135585666179
#define XXHASH_H_5627135585666179 1

/* specific declaration modes for Windows */
#if !defined(XXH_INLINE_ALL) && !defined(XXH_PRIVATE_API)
#  if defined(WIN32) && defined(_MSC_VER) && (defined(XXH_IMPORT) || defined(XXH_EXPORT))
#    ifdef XXH_EXPORT
#      define XXH_PUBLIC_API __declspec(dllexport)
#    elif XXH_IMPORT
#      define XXH_PUBLIC_API __declspec(dllimport)
#    endif
#  else
#    define XXH_PUBLIC_API   /* do nothing */
#  endif
#endif

#ifdef XXH_NAMESPACE
#  define XXH_CAT(A,B) A##B
#  define XXH_NAME2(A,B) XXH_CAT(A,B)
#  define XXH_versionNumber XXH_NAME2(XXH_NAMESPACE, XXH_versionNumber)
/* XXH32 */
#  define XXH32 XXH_NAME2(XXH_NAMESPACE, XXH32)
#  define XXH32_createState XXH_NAME2(XXH_NAMESPACE, XXH32_createState)
#  define XXH32_freeState XXH_NAME2(XXH_NAMESPACE, XXH32_freeState)
#  define XXH32_reset XXH_NAME2(XXH_NAMESPACE, XXH32_reset)
#  define XXH32_update XXH_NAME2(XXH_NAMESPACE, XXH32_update)
#  define XXH32_digest XXH_NAME2(XXH_NAMESPACE, XXH32_digest)
#  define XXH32_copyState XXH_NAME2(XXH_NAMESPACE, XXH32_copyState)
#  define XXH32_canonicalFromHash XXH_NAME2(XXH_NAMESPACE, XXH32_canonicalFromHash)
#  define XXH32_hashFromCanonical XXH_NAME2(XXH_NAMESPACE, XXH32_hashFromCanonical)
/* XXH64 */
#  define XXH64 XXH_NAME2(XXH_NAMESPACE, XXH64)
#  define XXH64_createState XXH_NAME2(XXH_NAMESPACE, XXH64_createState)
#  define XXH64_freeState XXH_NAME2(XXH_NAMESPACE, XXH64_freeState)
#  define XXH64_reset XXH_NAME2(XXH_NAMESPACE, XXH64_reset)
#  define XXH64_update XXH_NAME2(XXH_NAMESPACE, XXH64_update)
#  define XXH64_digest XXH_NAME2(XXH_NAMESPACE, XXH64_digest)
#  define XXH64_copyState XXH_NAME2(XXH_NAMESPACE, XXH64_copyState)
#  define XXH64_canonicalFromHash XXH_NAME2(XXH_NAMESPACE, XXH64_canonicalFromHash)
#  define XXH64_hashFromCanonical XXH_NAME2(XXH_NAMESPACE, XXH64_hashFromCanonical)
/* XXH3_64bits */
#  define XXH3_64bits XXH_NAME2(XXH_NAMESPACE, XXH3_64bits)
#  define XXH3_64bits_withSecret XXH_NAME2(XXH_NAMESPACE, XXH3_64bits_withSecret)
#  define XXH3_64bits_withSeed XXH_NAME2(XXH_NAMESPACE, XXH3_64bits_withSeed)
#  define XXH3_createState XXH_NAME2(XXH_NAMESPACE, XXH3_createState)
#  define XXH3_freeState XXH_NAME2(XXH_NAMESPACE, XXH3_freeState)
#  define XXH3_copyState XXH_NAME2(XXH_NAMESPACE, XXH3_copyState)
#  define XXH3_64bits_reset XXH_NAME2(XXH_NAMESPACE, XXH3_64bits_reset)
#  define XXH3_64bits_reset_withSeed XXH_NAME2(XXH_NAMESPACE, XXH3_64bits_reset_withSeed)
#  define XXH3_64bits_reset_withSecret XXH_NAME2(XXH_NAMESPACE, XXH3_64bits_reset_withSecret)
#  define XXH3_64bits_update XXH_NAME2(XXH_NAMESPACE, XXH3_64bits_update)
#  define XXH3_64bits_digest XXH_NAME2(XXH_NAMESPACE, XXH3_64bits_digest)
#  define XXH3_generateSecret XXH_NAME2(XXH_NAMESPACE, XXH3_generateSecret)
/* XXH3_128bits */
#  define XXH128 XXH_NAME2(XXH_NAMESPACE, XXH128)
#  define XXH3_128bits XXH_NAME2(XXH_NAMESPACE, XXH3_128bits)
#  define XXH3_128bits_withSeed XXH_NAME2(XXH_NAMESPACE, XXH3_128bits_withSeed)
#  define XXH3_128bits_withSecret XXH_NAME2(XXH_NAMESPACE, XXH3_128bits_withSecret)
#  define XXH3_128bits_reset XXH_NAME2(XXH_NAMESPACE, XXH3_128bits_reset)
#  define XXH3_128bits_reset_withSeed XXH_NAME2(XXH_NAMESPACE, XXH3_128bits_reset_withSeed)
#  define XXH3_128bits_reset_withSecret XXH_NAME2(XXH_NAMESPACE, XXH3_128bits_reset_withSecret)
#  define XXH3_128bits_update XXH_NAME2(XXH_NAMESPACE, XXH3_128bits_update)
#  define XXH3_128bits_digest XXH_NAME2(XXH_NAMESPACE, XXH3_128bits_digest)
#  define XXH128_isEqual XXH_NAME2(XXH_NAMESPACE, XXH128_isEqual)
#  define XXH128_cmp     XXH_NAME2(XXH_NAMESPACE, XXH128_cmp)
#  define XXH128_canonicalFromHash XXH_NAME2(XXH_NAMESPACE, XXH128_canonicalFromHash)
#  define XXH128_hashFromCanonical XXH_NAME2(XXH_NAMESPACE, XXH128_hashFromCanonical)
#endif


/* *************************************
*  Version
***************************************/
#define XXH_VERSION_MAJOR    0
#define XXH_VERSION_MINOR    8
#define XXH_VERSION_RELEASE  0
#define XXH_VERSION_NUMBER  (XXH_VERSION_MAJOR *100*100 + XXH_VERSION_MINOR *100 + XXH_VERSION_RELEASE)
XXH_PUBLIC_API unsigned XXH_versionNumber (void);


/* ****************************
*  Definitions
******************************/
typedef enum { XXH_OK=0, XXH_ERROR } XXH_errorcode;


/*-**********************************************************************
*  32-bit hash
************************************************************************/
#if !defined (__VMS) \
  && (defined (__cplusplus) \
  || (defined (__STDC_VERSION__) && (__STDC_VERSION__ >= 199901L) /* C99 */) )
#   include <stdint.h>
    typedef uint32_t XXH32_hash_t;
#else
#   include <limits.h>
#   if UINT_MAX == 0xFFFFFFFFUL
      typedef unsigned int XXH32_hash_t;
#   else
#     if ULONG_MAX == 0xFFFFFFFFUL
        typedef unsigned long XXH32_hash_t;
#     else
#       error "unsupported platform: need a 32-bit type"
#     endif
#   endif
#endif

XXH_PUBLIC_API XXH32_hash_t XXH32 (const void* input, size_t length, XXH32_hash_t seed);


typedef struct XXH32_state_s XXH32_state_t;   /* incomplete type */
XXH_PUBLIC_API XXH32_state_t* XXH32_createState(void);
XXH_PUBLIC_API XXH_errorcode  XXH32_freeState(XXH32_state_t* statePtr);
XXH_PUBLIC_API void XXH32_copyState(XXH32_state_t* dst_state, const XXH32_state_t* src_state);

XXH_PUBLIC_API XXH_errorcode XXH32_reset  (XXH32_state_t* statePtr, XXH32_hash_t seed);
XXH_PUBLIC_API XXH_errorcode XXH32_update (XXH32_state_t* statePtr, const void* input, size_t length);
XXH_PUBLIC_API XXH32_hash_t  XXH32_digest (const XXH32_state_t* statePtr);


typedef struct { unsigned char digest[4]; } XXH32_canonical_t;
XXH_PUBLIC_API void XXH32_canonicalFromHash(XXH32_canonical_t* dst, XXH32_hash_t hash);
XXH_PUBLIC_API XXH32_hash_t XXH32_hashFromCanonical(const XXH32_canonical_t* src);


#ifndef XXH_NO_LONG_LONG
/*-**********************************************************************
*  64-bit hash
************************************************************************/
#if !defined (__VMS) \
  && (defined (__cplusplus) \
  || (defined (__STDC_VERSION__) && (__STDC_VERSION__ >= 199901L) /* C99 */) )
#   include <stdint.h>
    typedef uint64_t XXH64_hash_t;
#else
    /* the following type must have a width of 64-bit */
    typedef unsigned long long XXH64_hash_t;
#endif

XXH_PUBLIC_API XXH64_hash_t XXH64 (const void* input, size_t length, XXH64_hash_t seed);

/*******   Streaming   *******/
typedef struct XXH64_state_s XXH64_state_t;   /* incomplete type */
XXH_PUBLIC_API XXH64_state_t* XXH64_createState(void);
XXH_PUBLIC_API XXH_errorcode  XXH64_freeState(XXH64_state_t* statePtr);
XXH_PUBLIC_API void XXH64_copyState(XXH64_state_t* dst_state, const XXH64_state_t* src_state);

XXH_PUBLIC_API XXH_errorcode XXH64_reset  (XXH64_state_t* statePtr, XXH64_hash_t seed);
XXH_PUBLIC_API XXH_errorcode XXH64_update (XXH64_state_t* statePtr, const void* input, size_t length);
XXH_PUBLIC_API XXH64_hash_t  XXH64_digest (const XXH64_state_t* statePtr);

/*******   Canonical representation   *******/
typedef struct { unsigned char digest[sizeof(XXH64_hash_t)]; } XXH64_canonical_t;
XXH_PUBLIC_API void XXH64_canonicalFromHash(XXH64_canonical_t* dst, XXH64_hash_t hash);
XXH_PUBLIC_API XXH64_hash_t XXH64_hashFromCanonical(const XXH64_canonical_t* src);



/* XXH3_64bits():
 * default 64-bit variant, using default secret and default seed of 0.
 * It's the fastest variant. */
XXH_PUBLIC_API XXH64_hash_t XXH3_64bits(const void* data, size_t len);

XXH_PUBLIC_API XXH64_hash_t XXH3_64bits_withSeed(const void* data, size_t len, XXH64_hash_t seed);

#define XXH3_SECRET_SIZE_MIN 136
XXH_PUBLIC_API XXH64_hash_t XXH3_64bits_withSecret(const void* data, size_t len, const void* secret, size_t secretSize);


typedef struct XXH3_state_s XXH3_state_t;
XXH_PUBLIC_API XXH3_state_t* XXH3_createState(void);
XXH_PUBLIC_API XXH_errorcode XXH3_freeState(XXH3_state_t* statePtr);
XXH_PUBLIC_API void XXH3_copyState(XXH3_state_t* dst_state, const XXH3_state_t* src_state);

/*
 * XXH3_64bits_reset():
 * Initialize with default parameters.
 * digest will be equivalent to `XXH3_64bits()`.
 */
XXH_PUBLIC_API XXH_errorcode XXH3_64bits_reset(XXH3_state_t* statePtr);
/*
 * XXH3_64bits_reset_withSeed():
 * Generate a custom secret from `seed`, and store it into `statePtr`.
 * digest will be equivalent to `XXH3_64bits_withSeed()`.
 */
XXH_PUBLIC_API XXH_errorcode XXH3_64bits_reset_withSeed(XXH3_state_t* statePtr, XXH64_hash_t seed);
/*
 * XXH3_64bits_reset_withSecret():
 * `secret` is referenced, it _must outlive_ the hash streaming session.
 * Similar to one-shot API, `secretSize` must be >= `XXH3_SECRET_SIZE_MIN`,
 * and the quality of produced hash values depends on secret's entropy
 * (secret's content should look like a bunch of random bytes).
 * When in doubt about the randomness of a candidate `secret`,
 * consider employing `XXH3_generateSecret()` instead (see below).
 */
XXH_PUBLIC_API XXH_errorcode XXH3_64bits_reset_withSecret(XXH3_state_t* statePtr, const void* secret, size_t secretSize);

XXH_PUBLIC_API XXH_errorcode XXH3_64bits_update (XXH3_state_t* statePtr, const void* input, size_t length);
XXH_PUBLIC_API XXH64_hash_t  XXH3_64bits_digest (const XXH3_state_t* statePtr);

/* note : canonical representation of XXH3 is the same as XXH64
 * since they both produce XXH64_hash_t values */


/*-**********************************************************************
*  XXH3 128-bit variant
************************************************************************/

typedef struct {
 XXH64_hash_t low64;
 XXH64_hash_t high64;
} XXH128_hash_t;

XXH_PUBLIC_API XXH128_hash_t XXH3_128bits(const void* data, size_t len);
XXH_PUBLIC_API XXH128_hash_t XXH3_128bits_withSeed(const void* data, size_t len, XXH64_hash_t seed);
XXH_PUBLIC_API XXH128_hash_t XXH3_128bits_withSecret(const void* data, size_t len, const void* secret, size_t secretSize);

/*******   Streaming   *******/
/*
 * Streaming requires state maintenance.
 * This operation costs memory and CPU.
 * As a consequence, streaming is slower than one-shot hashing.
 * For better performance, prefer one-shot functions whenever applicable.
 *
 * XXH3_128bits uses the same XXH3_state_t as XXH3_64bits().
 * Use already declared XXH3_createState() and XXH3_freeState().
 *
 * All reset and streaming functions have same meaning as their 64-bit counterpart.
 */

XXH_PUBLIC_API XXH_errorcode XXH3_128bits_reset(XXH3_state_t* statePtr);
XXH_PUBLIC_API XXH_errorcode XXH3_128bits_reset_withSeed(XXH3_state_t* statePtr, XXH64_hash_t seed);
XXH_PUBLIC_API XXH_errorcode XXH3_128bits_reset_withSecret(XXH3_state_t* statePtr, const void* secret, size_t secretSize);

XXH_PUBLIC_API XXH_errorcode XXH3_128bits_update (XXH3_state_t* statePtr, const void* input, size_t length);
XXH_PUBLIC_API XXH128_hash_t XXH3_128bits_digest (const XXH3_state_t* statePtr);
XXH_PUBLIC_API int XXH128_isEqual(XXH128_hash_t h1, XXH128_hash_t h2);

XXH_PUBLIC_API int XXH128_cmp(const void* h128_1, const void* h128_2);


/*******   Canonical representation   *******/
typedef struct { unsigned char digest[sizeof(XXH128_hash_t)]; } XXH128_canonical_t;
XXH_PUBLIC_API void XXH128_canonicalFromHash(XXH128_canonical_t* dst, XXH128_hash_t hash);
XXH_PUBLIC_API XXH128_hash_t XXH128_hashFromCanonical(const XXH128_canonical_t* src);


#endif  /* XXH_NO_LONG_LONG */

#endif /* XXHASH_H_5627135585666179 */



#if defined(XXH_STATIC_LINKING_ONLY) && !defined(XXHASH_H_STATIC_13879238742)
#define XXHASH_H_STATIC_13879238742

struct XXH32_state_s {
   XXH32_hash_t total_len_32;
   XXH32_hash_t large_len;
   XXH32_hash_t v1;
   XXH32_hash_t v2;
   XXH32_hash_t v3;
   XXH32_hash_t v4;
   XXH32_hash_t mem32[4];
   XXH32_hash_t memsize;
   XXH32_hash_t reserved;   /* never read nor write, might be removed in a future version */
};   /* typedef'd to XXH32_state_t */


#ifndef XXH_NO_LONG_LONG  /* defined when there is no 64-bit support */

struct XXH64_state_s {
   XXH64_hash_t total_len;
   XXH64_hash_t v1;
   XXH64_hash_t v2;
   XXH64_hash_t v3;
   XXH64_hash_t v4;
   XXH64_hash_t mem64[4];
   XXH32_hash_t memsize;
   XXH32_hash_t reserved32;  /* required for padding anyway */
   XXH64_hash_t reserved64;  /* never read nor write, might be removed in a future version */
};   /* typedef'd to XXH64_state_t */

#if defined (__STDC_VERSION__) && (__STDC_VERSION__ >= 201112L)   /* C11+ */
#  include <stdalign.h>
#  define XXH_ALIGN(n)      alignas(n)
#elif defined(__GNUC__)
#  define XXH_ALIGN(n)      __attribute__ ((aligned(n)))
#elif defined(_MSC_VER)
#  define XXH_ALIGN(n)      __declspec(align(n))
#else
#  define XXH_ALIGN(n)   /* disabled */
#endif

/* Old GCC versions only accept the attribute after the type in structures. */
#if !(defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 201112L))   /* C11+ */ \
    && defined(__GNUC__)
#   define XXH_ALIGN_MEMBER(align, type) type XXH_ALIGN(align)
#else
#   define XXH_ALIGN_MEMBER(align, type) XXH_ALIGN(align) type
#endif

#define XXH3_INTERNALBUFFER_SIZE 256
#define XXH3_SECRET_DEFAULT_SIZE 192
struct XXH3_state_s {
   XXH_ALIGN_MEMBER(64, XXH64_hash_t acc[8]);
   /* used to store a custom secret generated from a seed */
   XXH_ALIGN_MEMBER(64, unsigned char customSecret[XXH3_SECRET_DEFAULT_SIZE]);
   XXH_ALIGN_MEMBER(64, unsigned char buffer[XXH3_INTERNALBUFFER_SIZE]);
   XXH32_hash_t bufferedSize;
   XXH32_hash_t reserved32;
   size_t nbStripesSoFar;
   XXH64_hash_t totalLen;
   size_t nbStripesPerBlock;
   size_t secretLimit;
   XXH64_hash_t seed;
   XXH64_hash_t reserved64;
   const unsigned char* extSecret;  /* reference to external secret;
                                     * if == NULL, use .customSecret instead */
   /* note: there may be some padding at the end due to alignment on 64 bytes */
}; /* typedef'd to XXH3_state_t */

#undef XXH_ALIGN_MEMBER

/* When the XXH3_state_t structure is merely emplaced on stack,
 * it should be initialized with XXH3_INITSTATE() or a memset()
 * in case its first reset uses XXH3_NNbits_reset_withSeed().
 * This init can be omitted if the first reset uses default or _withSecret mode.
 * This operation isn't necessary when the state is created with XXH3_createState().
 * Note that this doesn't prepare the state for a streaming operation,
 * it's still necessary to use XXH3_NNbits_reset*() afterwards.
 */
#define XXH3_INITSTATE(XXH3_state_ptr)   { (XXH3_state_ptr)->seed = 0; }


XXH_PUBLIC_API void XXH3_generateSecret(void* secretBuffer, const void* customSeed, size_t customSeedSize);


/* simple short-cut to pre-selected XXH3_128bits variant */
XXH_PUBLIC_API XXH128_hash_t XXH128(const void* data, size_t len, XXH64_hash_t seed);


#endif  /* XXH_NO_LONG_LONG */


#if defined(XXH_INLINE_ALL) || defined(XXH_PRIVATE_API)
#  define XXH_IMPLEMENTATION
#endif

#endif  /* defined(XXH_STATIC_LINKING_ONLY) && !defined(XXHASH_H_STATIC_13879238742) */



#if ( defined(XXH_INLINE_ALL) || defined(XXH_PRIVATE_API) \
   || defined(XXH_IMPLEMENTATION) ) && !defined(XXH_IMPLEM_13a8737387)
#  define XXH_IMPLEM_13a8737387

#ifndef XXH_FORCE_MEMORY_ACCESS   /* can be defined externally, on command line for example */
#  if !defined(__clang__) && defined(__GNUC__) && defined(__ARM_FEATURE_UNALIGNED) && defined(__ARM_ARCH) && (__ARM_ARCH == 6)
#    define XXH_FORCE_MEMORY_ACCESS 2
#  elif !defined(__clang__) && ((defined(__INTEL_COMPILER) && !defined(_WIN32)) || \
  (defined(__GNUC__) && (defined(__ARM_ARCH) && __ARM_ARCH >= 7)))
#    define XXH_FORCE_MEMORY_ACCESS 1
#  endif
#endif

#ifndef XXH_ACCEPT_NULL_INPUT_POINTER   /* can be defined externally */
#  define XXH_ACCEPT_NULL_INPUT_POINTER 0
#endif

#ifndef XXH_FORCE_ALIGN_CHECK  /* can be defined externally */
#  if defined(__i386)  || defined(__x86_64__) || defined(__aarch64__) \
   || defined(_M_IX86) || defined(_M_X64)     || defined(_M_ARM64) /* visual */
#    define XXH_FORCE_ALIGN_CHECK 0
#  else
#    define XXH_FORCE_ALIGN_CHECK 1
#  endif
#endif

#ifndef XXH_NO_INLINE_HINTS
#  if defined(__OPTIMIZE_SIZE__) /* -Os, -Oz */ \
   || defined(__NO_INLINE__)     /* -O0, -fno-inline */
#    define XXH_NO_INLINE_HINTS 1
#  else
#    define XXH_NO_INLINE_HINTS 0
#  endif
#endif

#ifndef XXH_REROLL
#  if defined(__OPTIMIZE_SIZE__)
#    define XXH_REROLL 1
#  else
#    define XXH_REROLL 0
#  endif
#endif


/* *************************************
*  Includes & Memory related functions
***************************************/
/*!
 * Modify the local functions below should you wish to use
 * different memory routines for malloc() and free()
 */


static void* XXH_malloc(size_t s) { return malloc(s); }
static void XXH_free(void* p) { free(p); }

/*! and for memcpy() */
static void* XXH_memcpy(void* dest, const void* src, size_t size)
{
    return memcpy(dest,src,size);
}



/* *************************************
*  Compiler Specific Options
***************************************/
#ifdef _MSC_VER /* Visual Studio warning fix */
#  pragma warning(disable : 4127) /* disable: C4127: conditional expression is constant */
#endif

#if XXH_NO_INLINE_HINTS  /* disable inlining hints */
#  if defined(__GNUC__)
#    define XXH_FORCE_INLINE static __attribute__((unused))
#  else
#    define XXH_FORCE_INLINE static
#  endif
#  define XXH_NO_INLINE static
/* enable inlining hints */
#elif defined(_MSC_VER)  /* Visual Studio */
#  define XXH_FORCE_INLINE static __forceinline
#  define XXH_NO_INLINE static __declspec(noinline)
#elif defined(__GNUC__)
#  define XXH_FORCE_INLINE static __inline__ __attribute__((always_inline, unused))
#  define XXH_NO_INLINE static __attribute__((noinline))
#elif defined (__cplusplus) \
  || (defined (__STDC_VERSION__) && (__STDC_VERSION__ >= 199901L))   /* C99 */
#  define XXH_FORCE_INLINE static inline
#  define XXH_NO_INLINE static
#else
#  define XXH_FORCE_INLINE static
#  define XXH_NO_INLINE static
#endif



#ifndef XXH_DEBUGLEVEL
#  ifdef DEBUGLEVEL /* backwards compat */
#    define XXH_DEBUGLEVEL DEBUGLEVEL
#  else
#    define XXH_DEBUGLEVEL 0
#  endif
#endif

#if (XXH_DEBUGLEVEL>=1)
#  include <assert.h>   /* note: can still be disabled with NDEBUG */
#  define XXH_ASSERT(c)   assert(c)
#else
#  define XXH_ASSERT(c)   ((void)0)
#endif

/* note: use after variable declarations */
#define XXH_STATIC_ASSERT(c)  do { enum { XXH_sa = 1/(int)(!!(c)) }; } while (0)


/* *************************************
*  Basic Types
***************************************/
#if !defined (__VMS) \
 && (defined (__cplusplus) \
 || (defined (__STDC_VERSION__) && (__STDC_VERSION__ >= 199901L) /* C99 */) )
# include <stdint.h>
  typedef uint8_t xxh_u8;
#else
  typedef unsigned char xxh_u8;
#endif
typedef XXH32_hash_t xxh_u32;

#ifdef XXH_OLD_NAMES
#  define BYTE xxh_u8
#  define U8   xxh_u8
#  define U32  xxh_u32
#endif

/* ***   Memory access   *** */

#if (defined(XXH_FORCE_MEMORY_ACCESS) && (XXH_FORCE_MEMORY_ACCESS==3))
/*
 * Manual byteshift. Best for old compilers which don't inline memcpy.
 * We actually directly use XXH_readLE32 and XXH_readBE32.
 */
#elif (defined(XXH_FORCE_MEMORY_ACCESS) && (XXH_FORCE_MEMORY_ACCESS==2))

/*
 * Force direct memory access. Only works on CPU which support unaligned memory
 * access in hardware.
 */
static xxh_u32 XXH_read32(const void* memPtr) { return *(const xxh_u32*) memPtr; }

#elif (defined(XXH_FORCE_MEMORY_ACCESS) && (XXH_FORCE_MEMORY_ACCESS==1))

/*
 * __pack instructions are safer but compiler specific, hence potentially
 * problematic for some compilers.
 *
 * Currently only defined for GCC and ICC.
 */
#ifdef XXH_OLD_NAMES
typedef union { xxh_u32 u32; } __attribute__((packed)) unalign;
#endif
static xxh_u32 XXH_read32(const void* ptr)
{
    typedef union { xxh_u32 u32; } __attribute__((packed)) xxh_unalign;
    return ((const xxh_unalign*)ptr)->u32;
}

#else

/*
 * Portable and safe solution. Generally efficient.
 * see: https://stackoverflow.com/a/32095106/646947
 */
static xxh_u32 XXH_read32(const void* memPtr)
{
    xxh_u32 val;
    memcpy(&val, memPtr, sizeof(val));
    return val;
}

#endif   /* XXH_FORCE_DIRECT_MEMORY_ACCESS */


/* ***   Endianess   *** */
typedef enum { XXH_bigEndian=0, XXH_littleEndian=1 } XXH_endianess;

/*!
 * XXH_CPU_LITTLE_ENDIAN:
 * Defined to 1 if the target is little endian, or 0 if it is big endian.
 * It can be defined externally, for example on the compiler command line.
 *
 * If it is not defined, a runtime check (which is usually constant folded)
 * is used instead.
 */
#ifndef XXH_CPU_LITTLE_ENDIAN
/*
 * Try to detect endianness automatically, to avoid the nonstandard behavior
 * in `XXH_isLittleEndian()`
 */
#  if defined(_WIN32) /* Windows is always little endian */ \
     || defined(__LITTLE_ENDIAN__) \
     || (defined(__BYTE_ORDER__) && __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__)
#    define XXH_CPU_LITTLE_ENDIAN 1
#  elif defined(__BIG_ENDIAN__) \
     || (defined(__BYTE_ORDER__) && __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__)
#    define XXH_CPU_LITTLE_ENDIAN 0
#  else
/*
 * runtime test, presumed to simplify to a constant by compiler
 */
static int XXH_isLittleEndian(void)
{
    /*
     * Portable and well-defined behavior.
     * Don't use static: it is detrimental to performance.
     */
    const union { xxh_u32 u; xxh_u8 c[4]; } one = { 1 };
    return one.c[0];
}
#   define XXH_CPU_LITTLE_ENDIAN   XXH_isLittleEndian()
#  endif
#endif




/* ****************************************
*  Compiler-specific Functions and Macros
******************************************/
#define XXH_GCC_VERSION (__GNUC__ * 100 + __GNUC_MINOR__)

#ifdef __has_builtin
#  define XXH_HAS_BUILTIN(x) __has_builtin(x)
#else
#  define XXH_HAS_BUILTIN(x) 0
#endif

#if !defined(NO_CLANG_BUILTIN) && XXH_HAS_BUILTIN(__builtin_rotateleft32) \
                               && XXH_HAS_BUILTIN(__builtin_rotateleft64)
#  define XXH_rotl32 __builtin_rotateleft32
#  define XXH_rotl64 __builtin_rotateleft64
/* Note: although _rotl exists for minGW (GCC under windows), performance seems poor */
#elif defined(_MSC_VER)
#  define XXH_rotl32(x,r) _rotl(x,r)
#  define XXH_rotl64(x,r) _rotl64(x,r)
#else
#  define XXH_rotl32(x,r) (((x) << (r)) | ((x) >> (32 - (r))))
#  define XXH_rotl64(x,r) (((x) << (r)) | ((x) >> (64 - (r))))
#endif

#if defined(_MSC_VER)     /* Visual Studio */
#  define XXH_swap32 _byteswap_ulong
#elif XXH_GCC_VERSION >= 403
#  define XXH_swap32 __builtin_bswap32
#else
static xxh_u32 XXH_swap32 (xxh_u32 x)
{
    return  ((x << 24) & 0xff000000 ) |
            ((x <<  8) & 0x00ff0000 ) |
            ((x >>  8) & 0x0000ff00 ) |
            ((x >> 24) & 0x000000ff );
}
#endif


/* ***************************
*  Memory reads
*****************************/
typedef enum { XXH_aligned, XXH_unaligned } XXH_alignment;

/*
 * XXH_FORCE_MEMORY_ACCESS==3 is an endian-independent byteshift load.
 *
 * This is ideal for older compilers which don't inline memcpy.
 */
#if (defined(XXH_FORCE_MEMORY_ACCESS) && (XXH_FORCE_MEMORY_ACCESS==3))

XXH_FORCE_INLINE xxh_u32 XXH_readLE32(const void* memPtr)
{
    const xxh_u8* bytePtr = (const xxh_u8 *)memPtr;
    return bytePtr[0]
         | ((xxh_u32)bytePtr[1] << 8)
         | ((xxh_u32)bytePtr[2] << 16)
         | ((xxh_u32)bytePtr[3] << 24);
}

XXH_FORCE_INLINE xxh_u32 XXH_readBE32(const void* memPtr)
{
    const xxh_u8* bytePtr = (const xxh_u8 *)memPtr;
    return bytePtr[3]
         | ((xxh_u32)bytePtr[2] << 8)
         | ((xxh_u32)bytePtr[1] << 16)
         | ((xxh_u32)bytePtr[0] << 24);
}

#else
XXH_FORCE_INLINE xxh_u32 XXH_readLE32(const void* ptr)
{
    return XXH_CPU_LITTLE_ENDIAN ? XXH_read32(ptr) : XXH_swap32(XXH_read32(ptr));
}

static xxh_u32 XXH_readBE32(const void* ptr)
{
    return XXH_CPU_LITTLE_ENDIAN ? XXH_swap32(XXH_read32(ptr)) : XXH_read32(ptr);
}
#endif

XXH_FORCE_INLINE xxh_u32
XXH_readLE32_align(const void* ptr, XXH_alignment align)
{
    if (align==XXH_unaligned) {
        return XXH_readLE32(ptr);
    } else {
        return XXH_CPU_LITTLE_ENDIAN ? *(const xxh_u32*)ptr : XXH_swap32(*(const xxh_u32*)ptr);
    }
}


/* *************************************
*  Misc
***************************************/
XXH_PUBLIC_API unsigned XXH_versionNumber (void) { return XXH_VERSION_NUMBER; }


/* *******************************************************************
*  32-bit hash functions
*********************************************************************/
static const xxh_u32 XXH_PRIME32_1 = 0x9E3779B1U;   /* 0b10011110001101110111100110110001 */
static const xxh_u32 XXH_PRIME32_2 = 0x85EBCA77U;   /* 0b10000101111010111100101001110111 */
static const xxh_u32 XXH_PRIME32_3 = 0xC2B2AE3DU;   /* 0b11000010101100101010111000111101 */
static const xxh_u32 XXH_PRIME32_4 = 0x27D4EB2FU;   /* 0b00100111110101001110101100101111 */
static const xxh_u32 XXH_PRIME32_5 = 0x165667B1U;   /* 0b00010110010101100110011110110001 */

#ifdef XXH_OLD_NAMES
#  define PRIME32_1 XXH_PRIME32_1
#  define PRIME32_2 XXH_PRIME32_2
#  define PRIME32_3 XXH_PRIME32_3
#  define PRIME32_4 XXH_PRIME32_4
#  define PRIME32_5 XXH_PRIME32_5
#endif

static xxh_u32 XXH32_round(xxh_u32 acc, xxh_u32 input)
{
    acc += input * XXH_PRIME32_2;
    acc  = XXH_rotl32(acc, 13);
    acc *= XXH_PRIME32_1;
#if defined(__GNUC__) && defined(__SSE4_1__) && !defined(XXH_ENABLE_AUTOVECTORIZE)
    __asm__("" : "+r" (acc));
#endif
    return acc;
}

/* mix all bits */
static xxh_u32 XXH32_avalanche(xxh_u32 h32)
{
    h32 ^= h32 >> 15;
    h32 *= XXH_PRIME32_2;
    h32 ^= h32 >> 13;
    h32 *= XXH_PRIME32_3;
    h32 ^= h32 >> 16;
    return(h32);
}

#define XXH_get32bits(p) XXH_readLE32_align(p, align)

static xxh_u32
XXH32_finalize(xxh_u32 h32, const xxh_u8* ptr, size_t len, XXH_alignment align)
{
#define XXH_PROCESS1 do {                           \
    h32 += (*ptr++) * XXH_PRIME32_5;                \
    h32 = XXH_rotl32(h32, 11) * XXH_PRIME32_1;      \
} while (0)

#define XXH_PROCESS4 do {                           \
    h32 += XXH_get32bits(ptr) * XXH_PRIME32_3;      \
    ptr += 4;                                   \
    h32  = XXH_rotl32(h32, 17) * XXH_PRIME32_4;     \
} while (0)

    /* Compact rerolled version */
    if (XXH_REROLL) {
        len &= 15;
        while (len >= 4) {
            XXH_PROCESS4;
            len -= 4;
        }
        while (len > 0) {
            XXH_PROCESS1;
            --len;
        }
        return XXH32_avalanche(h32);
    } else {
         switch(len&15) /* or switch(bEnd - p) */ {
           case 12:      XXH_PROCESS4;
                         /* fallthrough */
           case 8:       XXH_PROCESS4;
                         /* fallthrough */
           case 4:       XXH_PROCESS4;
                         return XXH32_avalanche(h32);

           case 13:      XXH_PROCESS4;
                         /* fallthrough */
           case 9:       XXH_PROCESS4;
                         /* fallthrough */
           case 5:       XXH_PROCESS4;
                         XXH_PROCESS1;
                         return XXH32_avalanche(h32);

           case 14:      XXH_PROCESS4;
                         /* fallthrough */
           case 10:      XXH_PROCESS4;
                         /* fallthrough */
           case 6:       XXH_PROCESS4;
                         XXH_PROCESS1;
                         XXH_PROCESS1;
                         return XXH32_avalanche(h32);

           case 15:      XXH_PROCESS4;
                         /* fallthrough */
           case 11:      XXH_PROCESS4;
                         /* fallthrough */
           case 7:       XXH_PROCESS4;
                         /* fallthrough */
           case 3:       XXH_PROCESS1;
                         /* fallthrough */
           case 2:       XXH_PROCESS1;
                         /* fallthrough */
           case 1:       XXH_PROCESS1;
                         /* fallthrough */
           case 0:       return XXH32_avalanche(h32);
        }
        XXH_ASSERT(0);
        return h32;   /* reaching this point is deemed impossible */
    }
}

#ifdef XXH_OLD_NAMES
#  define PROCESS1 XXH_PROCESS1
#  define PROCESS4 XXH_PROCESS4
#else
#  undef XXH_PROCESS1
#  undef XXH_PROCESS4
#endif

XXH_FORCE_INLINE xxh_u32
XXH32_endian_align(const xxh_u8* input, size_t len, xxh_u32 seed, XXH_alignment align)
{
    const xxh_u8* bEnd = input + len;
    xxh_u32 h32;

#if defined(XXH_ACCEPT_NULL_INPUT_POINTER) && (XXH_ACCEPT_NULL_INPUT_POINTER>=1)
    if (input==NULL) {
        len=0;
        bEnd=input=(const xxh_u8*)(size_t)16;
    }
#endif

    if (len>=16) {
        const xxh_u8* const limit = bEnd - 15;
        xxh_u32 v1 = seed + XXH_PRIME32_1 + XXH_PRIME32_2;
        xxh_u32 v2 = seed + XXH_PRIME32_2;
        xxh_u32 v3 = seed + 0;
        xxh_u32 v4 = seed - XXH_PRIME32_1;

        do {
            v1 = XXH32_round(v1, XXH_get32bits(input)); input += 4;
            v2 = XXH32_round(v2, XXH_get32bits(input)); input += 4;
            v3 = XXH32_round(v3, XXH_get32bits(input)); input += 4;
            v4 = XXH32_round(v4, XXH_get32bits(input)); input += 4;
        } while (input < limit);

        h32 = XXH_rotl32(v1, 1)  + XXH_rotl32(v2, 7)
            + XXH_rotl32(v3, 12) + XXH_rotl32(v4, 18);
    } else {
        h32  = seed + XXH_PRIME32_5;
    }

    h32 += (xxh_u32)len;

    return XXH32_finalize(h32, input, len&15, align);
}


XXH_PUBLIC_API XXH32_hash_t XXH32 (const void* input, size_t len, XXH32_hash_t seed)
{
#if 0
    /* Simple version, good for code maintenance, but unfortunately slow for small inputs */
    XXH32_state_t state;
    XXH32_reset(&state, seed);
    XXH32_update(&state, (const xxh_u8*)input, len);
    return XXH32_digest(&state);

#else

    if (XXH_FORCE_ALIGN_CHECK) {
        if ((((size_t)input) & 3) == 0) {   /* Input is 4-bytes aligned, leverage the speed benefit */
            return XXH32_endian_align((const xxh_u8*)input, len, seed, XXH_aligned);
    }   }

    return XXH32_endian_align((const xxh_u8*)input, len, seed, XXH_unaligned);
#endif
}



/*******   Hash streaming   *******/

XXH_PUBLIC_API XXH32_state_t* XXH32_createState(void)
{
    return (XXH32_state_t*)XXH_malloc(sizeof(XXH32_state_t));
}
XXH_PUBLIC_API XXH_errorcode XXH32_freeState(XXH32_state_t* statePtr)
{
    XXH_free(statePtr);
    return XXH_OK;
}

XXH_PUBLIC_API void XXH32_copyState(XXH32_state_t* dstState, const XXH32_state_t* srcState)
{
    memcpy(dstState, srcState, sizeof(*dstState));
}

XXH_PUBLIC_API XXH_errorcode XXH32_reset(XXH32_state_t* statePtr, XXH32_hash_t seed)
{
    XXH32_state_t state;   /* using a local state to memcpy() in order to avoid strict-aliasing warnings */
    memset(&state, 0, sizeof(state));
    state.v1 = seed + XXH_PRIME32_1 + XXH_PRIME32_2;
    state.v2 = seed + XXH_PRIME32_2;
    state.v3 = seed + 0;
    state.v4 = seed - XXH_PRIME32_1;
    /* do not write into reserved, planned to be removed in a future version */
    memcpy(statePtr, &state, sizeof(state) - sizeof(state.reserved));
    return XXH_OK;
}


XXH_PUBLIC_API XXH_errorcode
XXH32_update(XXH32_state_t* state, const void* input, size_t len)
{
    if (input==NULL)
#if defined(XXH_ACCEPT_NULL_INPUT_POINTER) && (XXH_ACCEPT_NULL_INPUT_POINTER>=1)
        return XXH_OK;
#else
        return XXH_ERROR;
#endif

    {   const xxh_u8* p = (const xxh_u8*)input;
        const xxh_u8* const bEnd = p + len;

        state->total_len_32 += (XXH32_hash_t)len;
        state->large_len |= (XXH32_hash_t)((len>=16) | (state->total_len_32>=16));

        if (state->memsize + len < 16)  {   /* fill in tmp buffer */
            XXH_memcpy((xxh_u8*)(state->mem32) + state->memsize, input, len);
            state->memsize += (XXH32_hash_t)len;
            return XXH_OK;
        }

        if (state->memsize) {   /* some data left from previous update */
            XXH_memcpy((xxh_u8*)(state->mem32) + state->memsize, input, 16-state->memsize);
            {   const xxh_u32* p32 = state->mem32;
                state->v1 = XXH32_round(state->v1, XXH_readLE32(p32)); p32++;
                state->v2 = XXH32_round(state->v2, XXH_readLE32(p32)); p32++;
                state->v3 = XXH32_round(state->v3, XXH_readLE32(p32)); p32++;
                state->v4 = XXH32_round(state->v4, XXH_readLE32(p32));
            }
            p += 16-state->memsize;
            state->memsize = 0;
        }

        if (p <= bEnd-16) {
            const xxh_u8* const limit = bEnd - 16;
            xxh_u32 v1 = state->v1;
            xxh_u32 v2 = state->v2;
            xxh_u32 v3 = state->v3;
            xxh_u32 v4 = state->v4;

            do {
                v1 = XXH32_round(v1, XXH_readLE32(p)); p+=4;
                v2 = XXH32_round(v2, XXH_readLE32(p)); p+=4;
                v3 = XXH32_round(v3, XXH_readLE32(p)); p+=4;
                v4 = XXH32_round(v4, XXH_readLE32(p)); p+=4;
            } while (p<=limit);

            state->v1 = v1;
            state->v2 = v2;
            state->v3 = v3;
            state->v4 = v4;
        }

        if (p < bEnd) {
            XXH_memcpy(state->mem32, p, (size_t)(bEnd-p));
            state->memsize = (unsigned)(bEnd-p);
        }
    }

    return XXH_OK;
}


XXH_PUBLIC_API XXH32_hash_t XXH32_digest (const XXH32_state_t* state)
{
    xxh_u32 h32;

    if (state->large_len) {
        h32 = XXH_rotl32(state->v1, 1)
            + XXH_rotl32(state->v2, 7)
            + XXH_rotl32(state->v3, 12)
            + XXH_rotl32(state->v4, 18);
    } else {
        h32 = state->v3 /* == seed */ + XXH_PRIME32_5;
    }

    h32 += state->total_len_32;

    return XXH32_finalize(h32, (const xxh_u8*)state->mem32, state->memsize, XXH_aligned);
}


XXH_PUBLIC_API void XXH32_canonicalFromHash(XXH32_canonical_t* dst, XXH32_hash_t hash)
{
    XXH_STATIC_ASSERT(sizeof(XXH32_canonical_t) == sizeof(XXH32_hash_t));
    if (XXH_CPU_LITTLE_ENDIAN) hash = XXH_swap32(hash);
    memcpy(dst, &hash, sizeof(*dst));
}

XXH_PUBLIC_API XXH32_hash_t XXH32_hashFromCanonical(const XXH32_canonical_t* src)
{
    return XXH_readBE32(src);
}


#ifndef XXH_NO_LONG_LONG

/* *******************************************************************
*  64-bit hash functions
*********************************************************************/

/*******   Memory access   *******/

typedef XXH64_hash_t xxh_u64;

#ifdef XXH_OLD_NAMES
#  define U64 xxh_u64
#endif

#ifndef XXH_REROLL_XXH64
#  if (defined(__ILP32__) || defined(_ILP32)) /* ILP32 is often defined on 32-bit GCC family */ \
   || !(defined(__x86_64__) || defined(_M_X64) || defined(_M_AMD64) /* x86-64 */ \
     || defined(_M_ARM64) || defined(__aarch64__) || defined(__arm64__) /* aarch64 */ \
     || defined(__PPC64__) || defined(__PPC64LE__) || defined(__ppc64__) || defined(__powerpc64__) /* ppc64 */ \
     || defined(__mips64__) || defined(__mips64)) /* mips64 */ \
   || (!defined(SIZE_MAX) || SIZE_MAX < ULLONG_MAX) /* check limits */
#    define XXH_REROLL_XXH64 1
#  else
#    define XXH_REROLL_XXH64 0
#  endif
#endif /* !defined(XXH_REROLL_XXH64) */

#if (defined(XXH_FORCE_MEMORY_ACCESS) && (XXH_FORCE_MEMORY_ACCESS==3))
/*
 * Manual byteshift. Best for old compilers which don't inline memcpy.
 * We actually directly use XXH_readLE64 and XXH_readBE64.
 */
#elif (defined(XXH_FORCE_MEMORY_ACCESS) && (XXH_FORCE_MEMORY_ACCESS==2))

/* Force direct memory access. Only works on CPU which support unaligned memory access in hardware */
static xxh_u64 XXH_read64(const void* memPtr) { return *(const xxh_u64*) memPtr; }

#elif (defined(XXH_FORCE_MEMORY_ACCESS) && (XXH_FORCE_MEMORY_ACCESS==1))

/*
 * __pack instructions are safer, but compiler specific, hence potentially
 * problematic for some compilers.
 *
 * Currently only defined for GCC and ICC.
 */
#ifdef XXH_OLD_NAMES
typedef union { xxh_u32 u32; xxh_u64 u64; } __attribute__((packed)) unalign64;
#endif
static xxh_u64 XXH_read64(const void* ptr)
{
    typedef union { xxh_u32 u32; xxh_u64 u64; } __attribute__((packed)) xxh_unalign64;
    return ((const xxh_unalign64*)ptr)->u64;
}

#else

/*
 * Portable and safe solution. Generally efficient.
 * see: https://stackoverflow.com/a/32095106/646947
 */
static xxh_u64 XXH_read64(const void* memPtr)
{
    xxh_u64 val;
    memcpy(&val, memPtr, sizeof(val));
    return val;
}

#endif   /* XXH_FORCE_DIRECT_MEMORY_ACCESS */

#if defined(_MSC_VER)     /* Visual Studio */
#  define XXH_swap64 _byteswap_uint64
#elif XXH_GCC_VERSION >= 403
#  define XXH_swap64 __builtin_bswap64
#else
static xxh_u64 XXH_swap64 (xxh_u64 x)
{
    return  ((x << 56) & 0xff00000000000000ULL) |
            ((x << 40) & 0x00ff000000000000ULL) |
            ((x << 24) & 0x0000ff0000000000ULL) |
            ((x << 8)  & 0x000000ff00000000ULL) |
            ((x >> 8)  & 0x00000000ff000000ULL) |
            ((x >> 24) & 0x0000000000ff0000ULL) |
            ((x >> 40) & 0x000000000000ff00ULL) |
            ((x >> 56) & 0x00000000000000ffULL);
}
#endif


/* XXH_FORCE_MEMORY_ACCESS==3 is an endian-independent byteshift load. */
#if (defined(XXH_FORCE_MEMORY_ACCESS) && (XXH_FORCE_MEMORY_ACCESS==3))

XXH_FORCE_INLINE xxh_u64 XXH_readLE64(const void* memPtr)
{
    const xxh_u8* bytePtr = (const xxh_u8 *)memPtr;
    return bytePtr[0]
         | ((xxh_u64)bytePtr[1] << 8)
         | ((xxh_u64)bytePtr[2] << 16)
         | ((xxh_u64)bytePtr[3] << 24)
         | ((xxh_u64)bytePtr[4] << 32)
         | ((xxh_u64)bytePtr[5] << 40)
         | ((xxh_u64)bytePtr[6] << 48)
         | ((xxh_u64)bytePtr[7] << 56);
}

XXH_FORCE_INLINE xxh_u64 XXH_readBE64(const void* memPtr)
{
    const xxh_u8* bytePtr = (const xxh_u8 *)memPtr;
    return bytePtr[7]
         | ((xxh_u64)bytePtr[6] << 8)
         | ((xxh_u64)bytePtr[5] << 16)
         | ((xxh_u64)bytePtr[4] << 24)
         | ((xxh_u64)bytePtr[3] << 32)
         | ((xxh_u64)bytePtr[2] << 40)
         | ((xxh_u64)bytePtr[1] << 48)
         | ((xxh_u64)bytePtr[0] << 56);
}

#else
XXH_FORCE_INLINE xxh_u64 XXH_readLE64(const void* ptr)
{
    return XXH_CPU_LITTLE_ENDIAN ? XXH_read64(ptr) : XXH_swap64(XXH_read64(ptr));
}

static xxh_u64 XXH_readBE64(const void* ptr)
{
    return XXH_CPU_LITTLE_ENDIAN ? XXH_swap64(XXH_read64(ptr)) : XXH_read64(ptr);
}
#endif

XXH_FORCE_INLINE xxh_u64
XXH_readLE64_align(const void* ptr, XXH_alignment align)
{
    if (align==XXH_unaligned)
        return XXH_readLE64(ptr);
    else
        return XXH_CPU_LITTLE_ENDIAN ? *(const xxh_u64*)ptr : XXH_swap64(*(const xxh_u64*)ptr);
}


/*******   xxh64   *******/

static const xxh_u64 XXH_PRIME64_1 = 0x9E3779B185EBCA87ULL;   /* 0b1001111000110111011110011011000110000101111010111100101010000111 */
static const xxh_u64 XXH_PRIME64_2 = 0xC2B2AE3D27D4EB4FULL;   /* 0b1100001010110010101011100011110100100111110101001110101101001111 */
static const xxh_u64 XXH_PRIME64_3 = 0x165667B19E3779F9ULL;   /* 0b0001011001010110011001111011000110011110001101110111100111111001 */
static const xxh_u64 XXH_PRIME64_4 = 0x85EBCA77C2B2AE63ULL;   /* 0b1000010111101011110010100111011111000010101100101010111001100011 */
static const xxh_u64 XXH_PRIME64_5 = 0x27D4EB2F165667C5ULL;   /* 0b0010011111010100111010110010111100010110010101100110011111000101 */

#ifdef XXH_OLD_NAMES
#  define PRIME64_1 XXH_PRIME64_1
#  define PRIME64_2 XXH_PRIME64_2
#  define PRIME64_3 XXH_PRIME64_3
#  define PRIME64_4 XXH_PRIME64_4
#  define PRIME64_5 XXH_PRIME64_5
#endif

static xxh_u64 XXH64_round(xxh_u64 acc, xxh_u64 input)
{
    acc += input * XXH_PRIME64_2;
    acc  = XXH_rotl64(acc, 31);
    acc *= XXH_PRIME64_1;
    return acc;
}

static xxh_u64 XXH64_mergeRound(xxh_u64 acc, xxh_u64 val)
{
    val  = XXH64_round(0, val);
    acc ^= val;
    acc  = acc * XXH_PRIME64_1 + XXH_PRIME64_4;
    return acc;
}

static xxh_u64 XXH64_avalanche(xxh_u64 h64)
{
    h64 ^= h64 >> 33;
    h64 *= XXH_PRIME64_2;
    h64 ^= h64 >> 29;
    h64 *= XXH_PRIME64_3;
    h64 ^= h64 >> 32;
    return h64;
}


#define XXH_get64bits(p) XXH_readLE64_align(p, align)

static xxh_u64
XXH64_finalize(xxh_u64 h64, const xxh_u8* ptr, size_t len, XXH_alignment align)
{
#define XXH_PROCESS1_64 do {                                   \
    h64 ^= (*ptr++) * XXH_PRIME64_5;                           \
    h64 = XXH_rotl64(h64, 11) * XXH_PRIME64_1;                 \
} while (0)

#define XXH_PROCESS4_64 do {                                   \
    h64 ^= (xxh_u64)(XXH_get32bits(ptr)) * XXH_PRIME64_1;      \
    ptr += 4;                                              \
    h64 = XXH_rotl64(h64, 23) * XXH_PRIME64_2 + XXH_PRIME64_3;     \
} while (0)

#define XXH_PROCESS8_64 do {                                   \
    xxh_u64 const k1 = XXH64_round(0, XXH_get64bits(ptr)); \
    ptr += 8;                                              \
    h64 ^= k1;                                             \
    h64  = XXH_rotl64(h64,27) * XXH_PRIME64_1 + XXH_PRIME64_4;     \
} while (0)

    /* Rerolled version for 32-bit targets is faster and much smaller. */
    if (XXH_REROLL || XXH_REROLL_XXH64) {
        len &= 31;
        while (len >= 8) {
            XXH_PROCESS8_64;
            len -= 8;
        }
        if (len >= 4) {
            XXH_PROCESS4_64;
            len -= 4;
        }
        while (len > 0) {
            XXH_PROCESS1_64;
            --len;
        }
         return  XXH64_avalanche(h64);
    } else {
        switch(len & 31) {
           case 24: XXH_PROCESS8_64;
                         /* fallthrough */
           case 16: XXH_PROCESS8_64;
                         /* fallthrough */
           case  8: XXH_PROCESS8_64;
                    return XXH64_avalanche(h64);

           case 28: XXH_PROCESS8_64;
                         /* fallthrough */
           case 20: XXH_PROCESS8_64;
                         /* fallthrough */
           case 12: XXH_PROCESS8_64;
                         /* fallthrough */
           case  4: XXH_PROCESS4_64;
                    return XXH64_avalanche(h64);

           case 25: XXH_PROCESS8_64;
                         /* fallthrough */
           case 17: XXH_PROCESS8_64;
                         /* fallthrough */
           case  9: XXH_PROCESS8_64;
                    XXH_PROCESS1_64;
                    return XXH64_avalanche(h64);

           case 29: XXH_PROCESS8_64;
                         /* fallthrough */
           case 21: XXH_PROCESS8_64;
                         /* fallthrough */
           case 13: XXH_PROCESS8_64;
                         /* fallthrough */
           case  5: XXH_PROCESS4_64;
                    XXH_PROCESS1_64;
                    return XXH64_avalanche(h64);

           case 26: XXH_PROCESS8_64;
                         /* fallthrough */
           case 18: XXH_PROCESS8_64;
                         /* fallthrough */
           case 10: XXH_PROCESS8_64;
                    XXH_PROCESS1_64;
                    XXH_PROCESS1_64;
                    return XXH64_avalanche(h64);

           case 30: XXH_PROCESS8_64;
                         /* fallthrough */
           case 22: XXH_PROCESS8_64;
                         /* fallthrough */
           case 14: XXH_PROCESS8_64;
                         /* fallthrough */
           case  6: XXH_PROCESS4_64;
                    XXH_PROCESS1_64;
                    XXH_PROCESS1_64;
                    return XXH64_avalanche(h64);

           case 27: XXH_PROCESS8_64;
                         /* fallthrough */
           case 19: XXH_PROCESS8_64;
                         /* fallthrough */
           case 11: XXH_PROCESS8_64;
                    XXH_PROCESS1_64;
                    XXH_PROCESS1_64;
                    XXH_PROCESS1_64;
                    return XXH64_avalanche(h64);

           case 31: XXH_PROCESS8_64;
                         /* fallthrough */
           case 23: XXH_PROCESS8_64;
                         /* fallthrough */
           case 15: XXH_PROCESS8_64;
                         /* fallthrough */
           case  7: XXH_PROCESS4_64;
                         /* fallthrough */
           case  3: XXH_PROCESS1_64;
                         /* fallthrough */
           case  2: XXH_PROCESS1_64;
                         /* fallthrough */
           case  1: XXH_PROCESS1_64;
                         /* fallthrough */
           case  0: return XXH64_avalanche(h64);
        }
    }
    /* impossible to reach */
    XXH_ASSERT(0);
    return 0;  /* unreachable, but some compilers complain without it */
}

#ifdef XXH_OLD_NAMES
#  define PROCESS1_64 XXH_PROCESS1_64
#  define PROCESS4_64 XXH_PROCESS4_64
#  define PROCESS8_64 XXH_PROCESS8_64
#else
#  undef XXH_PROCESS1_64
#  undef XXH_PROCESS4_64
#  undef XXH_PROCESS8_64
#endif

XXH_FORCE_INLINE xxh_u64
XXH64_endian_align(const xxh_u8* input, size_t len, xxh_u64 seed, XXH_alignment align)
{
    const xxh_u8* bEnd = input + len;
    xxh_u64 h64;

#if defined(XXH_ACCEPT_NULL_INPUT_POINTER) && (XXH_ACCEPT_NULL_INPUT_POINTER>=1)
    if (input==NULL) {
        len=0;
        bEnd=input=(const xxh_u8*)(size_t)32;
    }
#endif

    if (len>=32) {
        const xxh_u8* const limit = bEnd - 32;
        xxh_u64 v1 = seed + XXH_PRIME64_1 + XXH_PRIME64_2;
        xxh_u64 v2 = seed + XXH_PRIME64_2;
        xxh_u64 v3 = seed + 0;
        xxh_u64 v4 = seed - XXH_PRIME64_1;

        do {
            v1 = XXH64_round(v1, XXH_get64bits(input)); input+=8;
            v2 = XXH64_round(v2, XXH_get64bits(input)); input+=8;
            v3 = XXH64_round(v3, XXH_get64bits(input)); input+=8;
            v4 = XXH64_round(v4, XXH_get64bits(input)); input+=8;
        } while (input<=limit);

        h64 = XXH_rotl64(v1, 1) + XXH_rotl64(v2, 7) + XXH_rotl64(v3, 12) + XXH_rotl64(v4, 18);
        h64 = XXH64_mergeRound(h64, v1);
        h64 = XXH64_mergeRound(h64, v2);
        h64 = XXH64_mergeRound(h64, v3);
        h64 = XXH64_mergeRound(h64, v4);

    } else {
        h64  = seed + XXH_PRIME64_5;
    }

    h64 += (xxh_u64) len;

    return XXH64_finalize(h64, input, len, align);
}


XXH_PUBLIC_API XXH64_hash_t XXH64 (const void* input, size_t len, XXH64_hash_t seed)
{
#if 0
    /* Simple version, good for code maintenance, but unfortunately slow for small inputs */
    XXH64_state_t state;
    XXH64_reset(&state, seed);
    XXH64_update(&state, (const xxh_u8*)input, len);
    return XXH64_digest(&state);

#else

    if (XXH_FORCE_ALIGN_CHECK) {
        if ((((size_t)input) & 7)==0) {  /* Input is aligned, let's leverage the speed advantage */
            return XXH64_endian_align((const xxh_u8*)input, len, seed, XXH_aligned);
    }   }

    return XXH64_endian_align((const xxh_u8*)input, len, seed, XXH_unaligned);

#endif
}

/*******   Hash Streaming   *******/

XXH_PUBLIC_API XXH64_state_t* XXH64_createState(void)
{
    return (XXH64_state_t*)XXH_malloc(sizeof(XXH64_state_t));
}
XXH_PUBLIC_API XXH_errorcode XXH64_freeState(XXH64_state_t* statePtr)
{
    XXH_free(statePtr);
    return XXH_OK;
}

XXH_PUBLIC_API void XXH64_copyState(XXH64_state_t* dstState, const XXH64_state_t* srcState)
{
    memcpy(dstState, srcState, sizeof(*dstState));
}

XXH_PUBLIC_API XXH_errorcode XXH64_reset(XXH64_state_t* statePtr, XXH64_hash_t seed)
{
    XXH64_state_t state;   /* use a local state to memcpy() in order to avoid strict-aliasing warnings */
    memset(&state, 0, sizeof(state));
    state.v1 = seed + XXH_PRIME64_1 + XXH_PRIME64_2;
    state.v2 = seed + XXH_PRIME64_2;
    state.v3 = seed + 0;
    state.v4 = seed - XXH_PRIME64_1;
     /* do not write into reserved64, might be removed in a future version */
    memcpy(statePtr, &state, sizeof(state) - sizeof(state.reserved64));
    return XXH_OK;
}

XXH_PUBLIC_API XXH_errorcode
XXH64_update (XXH64_state_t* state, const void* input, size_t len)
{
    if (input==NULL)
#if defined(XXH_ACCEPT_NULL_INPUT_POINTER) && (XXH_ACCEPT_NULL_INPUT_POINTER>=1)
        return XXH_OK;
#else
        return XXH_ERROR;
#endif

    {   const xxh_u8* p = (const xxh_u8*)input;
        const xxh_u8* const bEnd = p + len;

        state->total_len += len;

        if (state->memsize + len < 32) {  /* fill in tmp buffer */
            XXH_memcpy(((xxh_u8*)state->mem64) + state->memsize, input, len);
            state->memsize += (xxh_u32)len;
            return XXH_OK;
        }

        if (state->memsize) {   /* tmp buffer is full */
            XXH_memcpy(((xxh_u8*)state->mem64) + state->memsize, input, 32-state->memsize);
            state->v1 = XXH64_round(state->v1, XXH_readLE64(state->mem64+0));
            state->v2 = XXH64_round(state->v2, XXH_readLE64(state->mem64+1));
            state->v3 = XXH64_round(state->v3, XXH_readLE64(state->mem64+2));
            state->v4 = XXH64_round(state->v4, XXH_readLE64(state->mem64+3));
            p += 32-state->memsize;
            state->memsize = 0;
        }

        if (p+32 <= bEnd) {
            const xxh_u8* const limit = bEnd - 32;
            xxh_u64 v1 = state->v1;
            xxh_u64 v2 = state->v2;
            xxh_u64 v3 = state->v3;
            xxh_u64 v4 = state->v4;

            do {
                v1 = XXH64_round(v1, XXH_readLE64(p)); p+=8;
                v2 = XXH64_round(v2, XXH_readLE64(p)); p+=8;
                v3 = XXH64_round(v3, XXH_readLE64(p)); p+=8;
                v4 = XXH64_round(v4, XXH_readLE64(p)); p+=8;
            } while (p<=limit);

            state->v1 = v1;
            state->v2 = v2;
            state->v3 = v3;
            state->v4 = v4;
        }

        if (p < bEnd) {
            XXH_memcpy(state->mem64, p, (size_t)(bEnd-p));
            state->memsize = (unsigned)(bEnd-p);
        }
    }

    return XXH_OK;
}


XXH_PUBLIC_API XXH64_hash_t XXH64_digest (const XXH64_state_t* state)
{
    xxh_u64 h64;

    if (state->total_len >= 32) {
        xxh_u64 const v1 = state->v1;
        xxh_u64 const v2 = state->v2;
        xxh_u64 const v3 = state->v3;
        xxh_u64 const v4 = state->v4;

        h64 = XXH_rotl64(v1, 1) + XXH_rotl64(v2, 7) + XXH_rotl64(v3, 12) + XXH_rotl64(v4, 18);
        h64 = XXH64_mergeRound(h64, v1);
        h64 = XXH64_mergeRound(h64, v2);
        h64 = XXH64_mergeRound(h64, v3);
        h64 = XXH64_mergeRound(h64, v4);
    } else {
        h64  = state->v3 /*seed*/ + XXH_PRIME64_5;
    }

    h64 += (xxh_u64) state->total_len;

    return XXH64_finalize(h64, (const xxh_u8*)state->mem64, (size_t)state->total_len, XXH_aligned);
}


/******* Canonical representation   *******/

XXH_PUBLIC_API void XXH64_canonicalFromHash(XXH64_canonical_t* dst, XXH64_hash_t hash)
{
    XXH_STATIC_ASSERT(sizeof(XXH64_canonical_t) == sizeof(XXH64_hash_t));
    if (XXH_CPU_LITTLE_ENDIAN) hash = XXH_swap64(hash);
    memcpy(dst, &hash, sizeof(*dst));
}

XXH_PUBLIC_API XXH64_hash_t XXH64_hashFromCanonical(const XXH64_canonical_t* src)
{
    return XXH_readBE64(src);
}



/* *********************************************************************
*  XXH3
*  New generation hash designed for speed on small keys and vectorization
************************************************************************ */

/* ===   Compiler specifics   === */

#if defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L  && (!defined(SOLARIS))  /* franzfix >= C99 */
#  define XXH_RESTRICT   restrict
#else
/* Note: it might be useful to define __restrict or __restrict__ for some C++ compilers */
#  define XXH_RESTRICT   /* disable */
#endif

#if (defined(__GNUC__) && (__GNUC__ >= 3))  \
  || (defined(__INTEL_COMPILER) && (__INTEL_COMPILER >= 800)) \
  || defined(__clang__)
#    define XXH_likely(x) __builtin_expect(x, 1)
#    define XXH_unlikely(x) __builtin_expect(x, 0)
#else
#    define XXH_likely(x) (x)
#    define XXH_unlikely(x) (x)
#endif

#if defined(__GNUC__)
#  if defined(__AVX2__)
#    include <immintrin.h>
#  elif defined(__SSE2__)
#    include <emmintrin.h>
#  elif defined(__ARM_NEON__) || defined(__ARM_NEON)
#    define inline __inline__  /* circumvent a clang bug */
#    include <arm_neon.h>
#    undef inline
#  endif
#elif defined(_MSC_VER)
#  include <intrin.h>
#endif

#if defined(__thumb__) && !defined(__thumb2__) && defined(__ARM_ARCH_ISA_ARM)
#   warning "XXH3 is highly inefficient without ARM or Thumb-2."
#endif

/* ==========================================
 * Vectorization detection
 * ========================================== */
#define XXH_SCALAR 0  /* Portable scalar version */
#define XXH_SSE2   1  /* SSE2 for Pentium 4 and all x86_64 */
#define XXH_AVX2   2  /* AVX2 for Haswell and Bulldozer */
#define XXH_AVX512 3  /* AVX512 for Skylake and Icelake */
#define XXH_NEON   4  /* NEON for most ARMv7-A and all AArch64 */
#define XXH_VSX    5  /* VSX and ZVector for POWER8/z13 */

#ifndef XXH_VECTOR    /* can be defined on command line */
#  if defined(__AVX512F__)
#    define XXH_VECTOR XXH_AVX512
#  elif defined(__AVX2__)
#    define XXH_VECTOR XXH_AVX2
#  elif defined(__SSE2__) || defined(_M_AMD64) || defined(_M_X64) || (defined(_M_IX86_FP) && (_M_IX86_FP == 2))
#    define XXH_VECTOR XXH_SSE2
#  elif defined(__GNUC__) /* msvc support maybe later */ \
  && (defined(__ARM_NEON__) || defined(__ARM_NEON)) \
  && (defined(__LITTLE_ENDIAN__) /* We only support little endian NEON */ \
    || (defined(__BYTE_ORDER__) && __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__))
#    define XXH_VECTOR XXH_NEON
#  elif (defined(__PPC64__) && defined(__POWER8_VECTOR__)) \
     || (defined(__s390x__) && defined(__VEC__)) \
     && defined(__GNUC__) /* TODO: IBM XL */
#    define XXH_VECTOR XXH_VSX
#  else
#    define XXH_VECTOR XXH_SCALAR
#  endif
#endif

/*
 * Controls the alignment of the accumulator,
 * for compatibility with aligned vector loads, which are usually faster.
 */
#ifndef XXH_ACC_ALIGN
#  if defined(XXH_X86DISPATCH)
#     define XXH_ACC_ALIGN 64  /* for compatibility with avx512 */
#  elif XXH_VECTOR == XXH_SCALAR  /* scalar */
#     define XXH_ACC_ALIGN 8
#  elif XXH_VECTOR == XXH_SSE2  /* sse2 */
#     define XXH_ACC_ALIGN 16
#  elif XXH_VECTOR == XXH_AVX2  /* avx2 */
#     define XXH_ACC_ALIGN 32
#  elif XXH_VECTOR == XXH_NEON  /* neon */
#     define XXH_ACC_ALIGN 16
#  elif XXH_VECTOR == XXH_VSX   /* vsx */
#     define XXH_ACC_ALIGN 16
#  elif XXH_VECTOR == XXH_AVX512  /* avx512 */
#     define XXH_ACC_ALIGN 64
#  endif
#endif

#if defined(XXH_X86DISPATCH) || XXH_VECTOR == XXH_SSE2 \
    || XXH_VECTOR == XXH_AVX2 || XXH_VECTOR == XXH_AVX512
#  define XXH_SEC_ALIGN XXH_ACC_ALIGN
#else
#  define XXH_SEC_ALIGN 8
#endif

#if XXH_VECTOR == XXH_AVX2 /* AVX2 */ \
  && defined(__GNUC__) && !defined(__clang__) /* GCC, not Clang */ \
  && defined(__OPTIMIZE__) && !defined(__OPTIMIZE_SIZE__) /* respect -O0 and -Os */
#  pragma GCC push_options
#  pragma GCC optimize("-O2")
#endif


#if XXH_VECTOR == XXH_NEON
# if !defined(XXH_NO_VZIP_HACK) /* define to disable */ \
   && defined(__GNUC__) \
   && !defined(__aarch64__) && !defined(__arm64__)
#  define XXH_SPLIT_IN_PLACE(in, outLo, outHi)                                              \
    do {                                                                                    \
      /* Undocumented GCC/Clang operand modifier: %e0 = lower D half, %f0 = upper D half */ \
      /* https://github.com/gcc-mirror/gcc/blob/38cf91e5/gcc/config/arm/arm.c#L22486 */     \
      /* https://github.com/llvm-mirror/llvm/blob/2c4ca683/lib/Target/ARM/ARMAsmPrinter.cpp#L399 */ \
      __asm__("vzip.32  %e0, %f0" : "+w" (in));                                             \
      (outLo) = vget_low_u32 (vreinterpretq_u32_u64(in));                                   \
      (outHi) = vget_high_u32(vreinterpretq_u32_u64(in));                                   \
   } while (0)
# else
#  define XXH_SPLIT_IN_PLACE(in, outLo, outHi)                                            \
    do {                                                                                  \
      (outLo) = vmovn_u64    (in);                                                        \
      (outHi) = vshrn_n_u64  ((in), 32);                                                  \
    } while (0)
# endif
#endif  /* XXH_VECTOR == XXH_NEON */

/*
 * VSX and Z Vector helpers.
 *
 * This is very messy, and any pull requests to clean this up are welcome.
 *
 * There are a lot of problems with supporting VSX and s390x, due to
 * inconsistent intrinsics, spotty coverage, and multiple endiannesses.
 */
#if XXH_VECTOR == XXH_VSX
#  if defined(__s390x__)
#    include <s390intrin.h>
#  else
/* gcc's altivec.h can have the unwanted consequence to unconditionally
 * #define bool, vector, and pixel keywords,
 * with bad consequences for programs already using these keywords for other purposes.
 * The paragraph defining these macros is skipped when __APPLE_ALTIVEC__ is defined.
 * __APPLE_ALTIVEC__ is _generally_ defined automatically by the compiler,
 * but it seems that, in some cases, it isn't.
 * Force the build macro to be defined, so that keywords are not altered.
 */
#    if defined(__GNUC__) && !defined(__APPLE_ALTIVEC__)
#      define __APPLE_ALTIVEC__
#    endif
#    include <altivec.h>
#  endif

typedef __vector unsigned long long xxh_u64x2;
typedef __vector unsigned char xxh_u8x16;
typedef __vector unsigned xxh_u32x4;

# ifndef XXH_VSX_BE
#  if defined(__BIG_ENDIAN__) \
  || (defined(__BYTE_ORDER__) && __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__)
#    define XXH_VSX_BE 1
#  elif defined(__VEC_ELEMENT_REG_ORDER__) && __VEC_ELEMENT_REG_ORDER__ == __ORDER_BIG_ENDIAN__
#    warning "-maltivec=be is not recommended. Please use native endianness."
#    define XXH_VSX_BE 1
#  else
#    define XXH_VSX_BE 0
#  endif
# endif /* !defined(XXH_VSX_BE) */

# if XXH_VSX_BE
/* A wrapper for POWER9's vec_revb. */
#  if defined(__POWER9_VECTOR__) || (defined(__clang__) && defined(__s390x__))
#    define XXH_vec_revb vec_revb
#  else
XXH_FORCE_INLINE xxh_u64x2 XXH_vec_revb(xxh_u64x2 val)
{
    xxh_u8x16 const vByteSwap = { 0x07, 0x06, 0x05, 0x04, 0x03, 0x02, 0x01, 0x00,
                                  0x0F, 0x0E, 0x0D, 0x0C, 0x0B, 0x0A, 0x09, 0x08 };
    return vec_perm(val, val, vByteSwap);
}
#  endif
# endif /* XXH_VSX_BE */

/*
 * Performs an unaligned load and byte swaps it on big endian.
 */
XXH_FORCE_INLINE xxh_u64x2 XXH_vec_loadu(const void *ptr)
{
    xxh_u64x2 ret;
    memcpy(&ret, ptr, sizeof(xxh_u64x2));
# if XXH_VSX_BE
    ret = XXH_vec_revb(ret);
# endif
    return ret;
}

/*
 * vec_mulo and vec_mule are very problematic intrinsics on PowerPC
 *
 * These intrinsics weren't added until GCC 8, despite existing for a while,
 * and they are endian dependent. Also, their meaning swap depending on version.
 * */
# if defined(__s390x__)
 /* s390x is always big endian, no issue on this platform */
#  define XXH_vec_mulo vec_mulo
#  define XXH_vec_mule vec_mule
# elif defined(__clang__) && XXH_HAS_BUILTIN(__builtin_altivec_vmuleuw)
/* Clang has a better way to control this, we can just use the builtin which doesn't swap. */
#  define XXH_vec_mulo __builtin_altivec_vmulouw
#  define XXH_vec_mule __builtin_altivec_vmuleuw
# else
/* gcc needs inline assembly */
/* Adapted from https://github.com/google/highwayhash/blob/master/highwayhash/hh_vsx.h. */
XXH_FORCE_INLINE xxh_u64x2 XXH_vec_mulo(xxh_u32x4 a, xxh_u32x4 b)
{
    xxh_u64x2 result;
    __asm__("vmulouw %0, %1, %2" : "=v" (result) : "v" (a), "v" (b));
    return result;
}
XXH_FORCE_INLINE xxh_u64x2 XXH_vec_mule(xxh_u32x4 a, xxh_u32x4 b)
{
    xxh_u64x2 result;
    __asm__("vmuleuw %0, %1, %2" : "=v" (result) : "v" (a), "v" (b));
    return result;
}
# endif /* XXH_vec_mulo, XXH_vec_mule */
#endif /* XXH_VECTOR == XXH_VSX */


/* prefetch
 * can be disabled, by declaring XXH_NO_PREFETCH build macro */
#if defined(XXH_NO_PREFETCH)
#  define XXH_PREFETCH(ptr)  (void)(ptr)  /* disabled */
#else
#  if defined(_MSC_VER) && (defined(_M_X64) || defined(_M_I86))  /* _mm_prefetch() is not defined outside of x86/x64 */
#    include <mmintrin.h>   /* https://msdn.microsoft.com/fr-fr/library/84szxsww(v=vs.90).aspx */
#    define XXH_PREFETCH(ptr)  _mm_prefetch((const char*)(ptr), _MM_HINT_T0)
#  elif defined(__GNUC__) && ( (__GNUC__ >= 4) || ( (__GNUC__ == 3) && (__GNUC_MINOR__ >= 1) ) )
#    define XXH_PREFETCH(ptr)  __builtin_prefetch((ptr), 0 /* rw==read */, 3 /* locality */)
#  else
#    define XXH_PREFETCH(ptr) (void)(ptr)  /* disabled */
#  endif
#endif  /* XXH_NO_PREFETCH */


/* ==========================================
 * XXH3 default settings
 * ========================================== */

#define XXH_SECRET_DEFAULT_SIZE 192   /* minimum XXH3_SECRET_SIZE_MIN */

#if (XXH_SECRET_DEFAULT_SIZE < XXH3_SECRET_SIZE_MIN)
#  error "default keyset is not large enough"
#endif

/* Pseudorandom secret taken directly from FARSH */
XXH_ALIGN(64) static const xxh_u8 XXH3_kSecret[XXH_SECRET_DEFAULT_SIZE] = {
    0xb8, 0xfe, 0x6c, 0x39, 0x23, 0xa4, 0x4b, 0xbe, 0x7c, 0x01, 0x81, 0x2c, 0xf7, 0x21, 0xad, 0x1c,
    0xde, 0xd4, 0x6d, 0xe9, 0x83, 0x90, 0x97, 0xdb, 0x72, 0x40, 0xa4, 0xa4, 0xb7, 0xb3, 0x67, 0x1f,
    0xcb, 0x79, 0xe6, 0x4e, 0xcc, 0xc0, 0xe5, 0x78, 0x82, 0x5a, 0xd0, 0x7d, 0xcc, 0xff, 0x72, 0x21,
    0xb8, 0x08, 0x46, 0x74, 0xf7, 0x43, 0x24, 0x8e, 0xe0, 0x35, 0x90, 0xe6, 0x81, 0x3a, 0x26, 0x4c,
    0x3c, 0x28, 0x52, 0xbb, 0x91, 0xc3, 0x00, 0xcb, 0x88, 0xd0, 0x65, 0x8b, 0x1b, 0x53, 0x2e, 0xa3,
    0x71, 0x64, 0x48, 0x97, 0xa2, 0x0d, 0xf9, 0x4e, 0x38, 0x19, 0xef, 0x46, 0xa9, 0xde, 0xac, 0xd8,
    0xa8, 0xfa, 0x76, 0x3f, 0xe3, 0x9c, 0x34, 0x3f, 0xf9, 0xdc, 0xbb, 0xc7, 0xc7, 0x0b, 0x4f, 0x1d,
    0x8a, 0x51, 0xe0, 0x4b, 0xcd, 0xb4, 0x59, 0x31, 0xc8, 0x9f, 0x7e, 0xc9, 0xd9, 0x78, 0x73, 0x64,
    0xea, 0xc5, 0xac, 0x83, 0x34, 0xd3, 0xeb, 0xc3, 0xc5, 0x81, 0xa0, 0xff, 0xfa, 0x13, 0x63, 0xeb,
    0x17, 0x0d, 0xdd, 0x51, 0xb7, 0xf0, 0xda, 0x49, 0xd3, 0x16, 0x55, 0x26, 0x29, 0xd4, 0x68, 0x9e,
    0x2b, 0x16, 0xbe, 0x58, 0x7d, 0x47, 0xa1, 0xfc, 0x8f, 0xf8, 0xb8, 0xd1, 0x7a, 0xd0, 0x31, 0xce,
    0x45, 0xcb, 0x3a, 0x8f, 0x95, 0x16, 0x04, 0x28, 0xaf, 0xd7, 0xfb, 0xca, 0xbb, 0x4b, 0x40, 0x7e,
};


#ifdef XXH_OLD_NAMES
#  define kSecret XXH3_kSecret
#endif

#if defined(_MSC_VER) && defined(_M_IX86)
#    include <intrin.h>
#    define XXH_mult32to64(x, y) __emulu((unsigned)(x), (unsigned)(y))
#else
/*
 * Downcast + upcast is usually better than masking on older compilers like
 * GCC 4.2 (especially 32-bit ones), all without affecting newer compilers.
 *
 * The other method, (x & 0xFFFFFFFF) * (y & 0xFFFFFFFF), will AND both operands
 * and perform a full 64x64 multiply -- entirely redundant on 32-bit.
 */
#    define XXH_mult32to64(x, y) ((xxh_u64)(xxh_u32)(x) * (xxh_u64)(xxh_u32)(y))
#endif

/*
 * Calculates a 64->128-bit long multiply.
 *
 * Uses __uint128_t and _umul128 if available, otherwise uses a scalar version.
 */
static XXH128_hash_t
XXH_mult64to128(xxh_u64 lhs, xxh_u64 rhs)
{
#if defined(__GNUC__) && !defined(__wasm__) \
    && defined(__SIZEOF_INT128__) \
    || (defined(_INTEGRAL_MAX_BITS) && _INTEGRAL_MAX_BITS >= 128)

    __uint128_t const product = (__uint128_t)lhs * (__uint128_t)rhs;
    XXH128_hash_t r128;
    r128.low64  = (xxh_u64)(product);
    r128.high64 = (xxh_u64)(product >> 64);
    return r128;

    /*
     * MSVC for x64's _umul128 method.
     *
     * xxh_u64 _umul128(xxh_u64 Multiplier, xxh_u64 Multiplicand, xxh_u64 *HighProduct);
     *
     * This compiles to single operand MUL on x64.
     */
#elif defined(_M_X64) || defined(_M_IA64)

#ifndef _MSC_VER
#   pragma intrinsic(_umul128)
#endif
    xxh_u64 product_high;
    xxh_u64 const product_low = _umul128(lhs, rhs, &product_high);
    XXH128_hash_t r128;
    r128.low64  = product_low;
    r128.high64 = product_high;
    return r128;

#else

    /* First calculate all of the cross products. */
    xxh_u64 const lo_lo = XXH_mult32to64(lhs & 0xFFFFFFFF, rhs & 0xFFFFFFFF);
    xxh_u64 const hi_lo = XXH_mult32to64(lhs >> 32,        rhs & 0xFFFFFFFF);
    xxh_u64 const lo_hi = XXH_mult32to64(lhs & 0xFFFFFFFF, rhs >> 32);
    xxh_u64 const hi_hi = XXH_mult32to64(lhs >> 32,        rhs >> 32);

    /* Now add the products together. These will never overflow. */
    xxh_u64 const cross = (lo_lo >> 32) + (hi_lo & 0xFFFFFFFF) + lo_hi;
    xxh_u64 const upper = (hi_lo >> 32) + (cross >> 32)        + hi_hi;
    xxh_u64 const lower = (cross << 32) | (lo_lo & 0xFFFFFFFF);

    XXH128_hash_t r128;
    r128.low64  = lower;
    r128.high64 = upper;
    return r128;
#endif
}

static xxh_u64
XXH3_mul128_fold64(xxh_u64 lhs, xxh_u64 rhs)
{
    XXH128_hash_t product = XXH_mult64to128(lhs, rhs);
    return product.low64 ^ product.high64;
}

/* Seems to produce slightly better code on GCC for some reason. */
XXH_FORCE_INLINE xxh_u64 XXH_xorshift64(xxh_u64 v64, int shift)
{
    XXH_ASSERT(0 <= shift && shift < 64);
    return v64 ^ (v64 >> shift);
}

/*
 * This is a fast avalanche stage,
 * suitable when input bits are already partially mixed
 */
static XXH64_hash_t XXH3_avalanche(xxh_u64 h64)
{
    h64 = XXH_xorshift64(h64, 37);
    h64 *= 0x165667919E3779F9ULL;
    h64 = XXH_xorshift64(h64, 32);
    return h64;
}

/*
 * This is a stronger avalanche,
 * inspired by Pelle Evensen's rrmxmx
 * preferable when input has not been previously mixed
 */
static XXH64_hash_t XXH3_rrmxmx(xxh_u64 h64, xxh_u64 len)
{
    /* this mix is inspired by Pelle Evensen's rrmxmx */
    h64 ^= XXH_rotl64(h64, 49) ^ XXH_rotl64(h64, 24);
    h64 *= 0x9FB21C651E98DF25ULL;
    h64 ^= (h64 >> 35) + len ;
    h64 *= 0x9FB21C651E98DF25ULL;
    return XXH_xorshift64(h64, 28);
}


XXH_FORCE_INLINE XXH64_hash_t
XXH3_len_1to3_64b(const xxh_u8* input, size_t len, const xxh_u8* secret, XXH64_hash_t seed)
{
    XXH_ASSERT(input != NULL);
    XXH_ASSERT(1 <= len && len <= 3);
    XXH_ASSERT(secret != NULL);
    /*
     * len = 1: combined = { input[0], 0x01, input[0], input[0] }
     * len = 2: combined = { input[1], 0x02, input[0], input[1] }
     * len = 3: combined = { input[2], 0x03, input[0], input[1] }
     */
    {   xxh_u8  const c1 = input[0];
        xxh_u8  const c2 = input[len >> 1];
        xxh_u8  const c3 = input[len - 1];
        xxh_u32 const combined = ((xxh_u32)c1 << 16) | ((xxh_u32)c2  << 24)
                               | ((xxh_u32)c3 <<  0) | ((xxh_u32)len << 8);
        xxh_u64 const bitflip = (XXH_readLE32(secret) ^ XXH_readLE32(secret+4)) + seed;
        xxh_u64 const keyed = (xxh_u64)combined ^ bitflip;
        return XXH64_avalanche(keyed);
    }
}

XXH_FORCE_INLINE XXH64_hash_t
XXH3_len_4to8_64b(const xxh_u8* input, size_t len, const xxh_u8* secret, XXH64_hash_t seed)
{
    XXH_ASSERT(input != NULL);
    XXH_ASSERT(secret != NULL);
    XXH_ASSERT(4 <= len && len < 8);
    seed ^= (xxh_u64)XXH_swap32((xxh_u32)seed) << 32;
    {   xxh_u32 const input1 = XXH_readLE32(input);
        xxh_u32 const input2 = XXH_readLE32(input + len - 4);
        xxh_u64 const bitflip = (XXH_readLE64(secret+8) ^ XXH_readLE64(secret+16)) - seed;
        xxh_u64 const input64 = input2 + (((xxh_u64)input1) << 32);
        xxh_u64 const keyed = input64 ^ bitflip;
        return XXH3_rrmxmx(keyed, len);
    }
}

XXH_FORCE_INLINE XXH64_hash_t
XXH3_len_9to16_64b(const xxh_u8* input, size_t len, const xxh_u8* secret, XXH64_hash_t seed)
{
    XXH_ASSERT(input != NULL);
    XXH_ASSERT(secret != NULL);
    XXH_ASSERT(8 <= len && len <= 16);
    {   xxh_u64 const bitflip1 = (XXH_readLE64(secret+24) ^ XXH_readLE64(secret+32)) + seed;
        xxh_u64 const bitflip2 = (XXH_readLE64(secret+40) ^ XXH_readLE64(secret+48)) - seed;
        xxh_u64 const input_lo = XXH_readLE64(input)           ^ bitflip1;
        xxh_u64 const input_hi = XXH_readLE64(input + len - 8) ^ bitflip2;
        xxh_u64 const acc = len
                          + XXH_swap64(input_lo) + input_hi
                          + XXH3_mul128_fold64(input_lo, input_hi);
        return XXH3_avalanche(acc);
    }
}

XXH_FORCE_INLINE XXH64_hash_t
XXH3_len_0to16_64b(const xxh_u8* input, size_t len, const xxh_u8* secret, XXH64_hash_t seed)
{
    XXH_ASSERT(len <= 16);
    {   if (XXH_likely(len >  8)) return XXH3_len_9to16_64b(input, len, secret, seed);
        if (XXH_likely(len >= 4)) return XXH3_len_4to8_64b(input, len, secret, seed);
        if (len) return XXH3_len_1to3_64b(input, len, secret, seed);
        return XXH64_avalanche(seed ^ (XXH_readLE64(secret+56) ^ XXH_readLE64(secret+64)));
    }
}

XXH_FORCE_INLINE xxh_u64 XXH3_mix16B(const xxh_u8* XXH_RESTRICT input,
                                     const xxh_u8* XXH_RESTRICT secret, xxh_u64 seed64)
{
#if defined(__GNUC__) && !defined(__clang__) /* GCC, not Clang */ \
  && defined(__i386__) && defined(__SSE2__)  /* x86 + SSE2 */ \
  && !defined(XXH_ENABLE_AUTOVECTORIZE)      /* Define to disable like XXH32 hack */
    __asm__ ("" : "+r" (seed64));
#endif
    {   xxh_u64 const input_lo = XXH_readLE64(input);
        xxh_u64 const input_hi = XXH_readLE64(input+8);
        return XXH3_mul128_fold64(
            input_lo ^ (XXH_readLE64(secret)   + seed64),
            input_hi ^ (XXH_readLE64(secret+8) - seed64)
        );
    }
}

/* For mid range keys, XXH3 uses a Mum-hash variant. */
XXH_FORCE_INLINE XXH64_hash_t
XXH3_len_17to128_64b(const xxh_u8* XXH_RESTRICT input, size_t len,
                     const xxh_u8* XXH_RESTRICT secret, size_t secretSize,
                     XXH64_hash_t seed)
{
    XXH_ASSERT(secretSize >= XXH3_SECRET_SIZE_MIN); (void)secretSize;
    XXH_ASSERT(16 < len && len <= 128);

    {   xxh_u64 acc = len * XXH_PRIME64_1;
        if (len > 32) {
            if (len > 64) {
                if (len > 96) {
                    acc += XXH3_mix16B(input+48, secret+96, seed);
                    acc += XXH3_mix16B(input+len-64, secret+112, seed);
                }
                acc += XXH3_mix16B(input+32, secret+64, seed);
                acc += XXH3_mix16B(input+len-48, secret+80, seed);
            }
            acc += XXH3_mix16B(input+16, secret+32, seed);
            acc += XXH3_mix16B(input+len-32, secret+48, seed);
        }
        acc += XXH3_mix16B(input+0, secret+0, seed);
        acc += XXH3_mix16B(input+len-16, secret+16, seed);

        return XXH3_avalanche(acc);
    }
}

#define XXH3_MIDSIZE_MAX 240

XXH_NO_INLINE XXH64_hash_t
XXH3_len_129to240_64b(const xxh_u8* XXH_RESTRICT input, size_t len,
                      const xxh_u8* XXH_RESTRICT secret, size_t secretSize,
                      XXH64_hash_t seed)
{
    XXH_ASSERT(secretSize >= XXH3_SECRET_SIZE_MIN); (void)secretSize;
    XXH_ASSERT(128 < len && len <= XXH3_MIDSIZE_MAX);

    #define XXH3_MIDSIZE_STARTOFFSET 3
    #define XXH3_MIDSIZE_LASTOFFSET  17

    {   xxh_u64 acc = len * XXH_PRIME64_1;
        int const nbRounds = (int)len / 16;
        int i;
        for (i=0; i<8; i++) {
            acc += XXH3_mix16B(input+(16*i), secret+(16*i), seed);
        }
        acc = XXH3_avalanche(acc);
        XXH_ASSERT(nbRounds >= 8);
#if defined(__clang__)                                /* Clang */ \
    && (defined(__ARM_NEON) || defined(__ARM_NEON__)) /* NEON */ \
    && !defined(XXH_ENABLE_AUTOVECTORIZE)             /* Define to disable */
        #pragma clang loop vectorize(disable)
#endif
        for (i=8 ; i < nbRounds; i++) {
            acc += XXH3_mix16B(input+(16*i), secret+(16*(i-8)) + XXH3_MIDSIZE_STARTOFFSET, seed);
        }
        /* last bytes */
        acc += XXH3_mix16B(input + len - 16, secret + XXH3_SECRET_SIZE_MIN - XXH3_MIDSIZE_LASTOFFSET, seed);
        return XXH3_avalanche(acc);
    }
}


/* =======     Long Keys     ======= */

#define XXH_STRIPE_LEN 64
#define XXH_SECRET_CONSUME_RATE 8   /* nb of secret bytes consumed at each accumulation */
#define XXH_ACC_NB (XXH_STRIPE_LEN / sizeof(xxh_u64))

#ifdef XXH_OLD_NAMES
#  define STRIPE_LEN XXH_STRIPE_LEN
#  define ACC_NB XXH_ACC_NB
#endif

XXH_FORCE_INLINE void XXH_writeLE64(void* dst, xxh_u64 v64)
{
    if (!XXH_CPU_LITTLE_ENDIAN) v64 = XXH_swap64(v64);
    memcpy(dst, &v64, sizeof(v64));
}

/* Several intrinsic functions below are supposed to accept __int64 as argument,
 * as documented in https://software.intel.com/sites/landingpage/IntrinsicsGuide/ .
 * However, several environments do not define __int64 type,
 * requiring a workaround.
 */
#if !defined (__VMS) \
  && (defined (__cplusplus) \
  || (defined (__STDC_VERSION__) && (__STDC_VERSION__ >= 199901L) /* C99 */) )
    typedef int64_t xxh_i64;
#else
    /* the following type must have a width of 64-bit */
    typedef long long xxh_i64;
#endif


#if (XXH_VECTOR == XXH_AVX512) || defined(XXH_X86DISPATCH)

#ifndef XXH_TARGET_AVX512
# define XXH_TARGET_AVX512  /* disable attribute target */
#endif

XXH_FORCE_INLINE XXH_TARGET_AVX512 void
XXH3_accumulate_512_avx512(void* XXH_RESTRICT acc,
                     const void* XXH_RESTRICT input,
                     const void* XXH_RESTRICT secret)
{
    XXH_ALIGN(64) __m512i* const xacc = (__m512i *) acc;
    XXH_ASSERT((((size_t)acc) & 63) == 0);
    XXH_STATIC_ASSERT(XXH_STRIPE_LEN == sizeof(__m512i));

    {
        /* data_vec    = input[0]; */
        __m512i const data_vec    = _mm512_loadu_si512   (input);
        /* key_vec     = secret[0]; */
        __m512i const key_vec     = _mm512_loadu_si512   (secret);
        /* data_key    = data_vec ^ key_vec; */
        __m512i const data_key    = _mm512_xor_si512     (data_vec, key_vec);
        /* data_key_lo = data_key >> 32; */
        __m512i const data_key_lo = _mm512_shuffle_epi32 (data_key, (_MM_PERM_ENUM)_MM_SHUFFLE(0, 3, 0, 1));
        /* product     = (data_key & 0xffffffff) * (data_key_lo & 0xffffffff); */
        __m512i const product     = _mm512_mul_epu32     (data_key, data_key_lo);
        /* xacc[0] += swap(data_vec); */
        __m512i const data_swap = _mm512_shuffle_epi32(data_vec, (_MM_PERM_ENUM)_MM_SHUFFLE(1, 0, 3, 2));
        __m512i const sum       = _mm512_add_epi64(*xacc, data_swap);
        /* xacc[0] += product; */
        *xacc = _mm512_add_epi64(product, sum);
    }
}


XXH_FORCE_INLINE XXH_TARGET_AVX512 void
XXH3_scrambleAcc_avx512(void* XXH_RESTRICT acc, const void* XXH_RESTRICT secret)
{
    XXH_ASSERT((((size_t)acc) & 63) == 0);
    XXH_STATIC_ASSERT(XXH_STRIPE_LEN == sizeof(__m512i));
    {   XXH_ALIGN(64) __m512i* const xacc = (__m512i*) acc;
        const __m512i prime32 = _mm512_set1_epi32((int)XXH_PRIME32_1);

        /* xacc[0] ^= (xacc[0] >> 47) */
        __m512i const acc_vec     = *xacc;
        __m512i const shifted     = _mm512_srli_epi64    (acc_vec, 47);
        __m512i const data_vec    = _mm512_xor_si512     (acc_vec, shifted);
        /* xacc[0] ^= secret; */
        __m512i const key_vec     = _mm512_loadu_si512   (secret);
        __m512i const data_key    = _mm512_xor_si512     (data_vec, key_vec);

        /* xacc[0] *= XXH_PRIME32_1; */
        __m512i const data_key_hi = _mm512_shuffle_epi32 (data_key, (_MM_PERM_ENUM)_MM_SHUFFLE(0, 3, 0, 1));
        __m512i const prod_lo     = _mm512_mul_epu32     (data_key, prime32);
        __m512i const prod_hi     = _mm512_mul_epu32     (data_key_hi, prime32);
        *xacc = _mm512_add_epi64(prod_lo, _mm512_slli_epi64(prod_hi, 32));
    }
}

XXH_FORCE_INLINE XXH_TARGET_AVX512 void
XXH3_initCustomSecret_avx512(void* XXH_RESTRICT customSecret, xxh_u64 seed64)
{
    XXH_STATIC_ASSERT((XXH_SECRET_DEFAULT_SIZE & 63) == 0);
    XXH_STATIC_ASSERT(XXH_SEC_ALIGN == 64);
    XXH_ASSERT(((size_t)customSecret & 63) == 0);
    (void)(&XXH_writeLE64);
    {   int const nbRounds = XXH_SECRET_DEFAULT_SIZE / sizeof(__m512i);
        __m512i const seed = _mm512_mask_set1_epi64(_mm512_set1_epi64((xxh_i64)seed64), 0xAA, -(xxh_i64)seed64);

        XXH_ALIGN(64) const __m512i* const src  = (const __m512i*) XXH3_kSecret;
        XXH_ALIGN(64)       __m512i* const dest = (      __m512i*) customSecret;
        int i;
        for (i=0; i < nbRounds; ++i) {
            /* GCC has a bug, _mm512_stream_load_si512 accepts 'void*', not 'void const*',
             * this will warn "discards ?const? qualifier". */
            union {
                XXH_ALIGN(64) const __m512i* cp;
                XXH_ALIGN(64) void* p;
            } remote_const_void;
            remote_const_void.cp = src + i;
            dest[i] = _mm512_add_epi64(_mm512_stream_load_si512(remote_const_void.p), seed);
    }   }
}

#endif

#if (XXH_VECTOR == XXH_AVX2) || defined(XXH_X86DISPATCH)

#ifndef XXH_TARGET_AVX2
# define XXH_TARGET_AVX2  /* disable attribute target */
#endif

XXH_FORCE_INLINE XXH_TARGET_AVX2 void
XXH3_accumulate_512_avx2( void* XXH_RESTRICT acc,
                    const void* XXH_RESTRICT input,
                    const void* XXH_RESTRICT secret)
{
    XXH_ASSERT((((size_t)acc) & 31) == 0);
    {   XXH_ALIGN(32) __m256i* const xacc    =       (__m256i *) acc;
        /* Unaligned. This is mainly for pointer arithmetic, and because
         * _mm256_loadu_si256 requires  a const __m256i * pointer for some reason. */
        const         __m256i* const xinput  = (const __m256i *) input;
        /* Unaligned. This is mainly for pointer arithmetic, and because
         * _mm256_loadu_si256 requires a const __m256i * pointer for some reason. */
        const         __m256i* const xsecret = (const __m256i *) secret;

        size_t i;
        for (i=0; i < XXH_STRIPE_LEN/sizeof(__m256i); i++) {
            /* data_vec    = xinput[i]; */
            __m256i const data_vec    = _mm256_loadu_si256    (xinput+i);
            /* key_vec     = xsecret[i]; */
            __m256i const key_vec     = _mm256_loadu_si256   (xsecret+i);
            /* data_key    = data_vec ^ key_vec; */
            __m256i const data_key    = _mm256_xor_si256     (data_vec, key_vec);
            /* data_key_lo = data_key >> 32; */
            __m256i const data_key_lo = _mm256_shuffle_epi32 (data_key, _MM_SHUFFLE(0, 3, 0, 1));
            /* product     = (data_key & 0xffffffff) * (data_key_lo & 0xffffffff); */
            __m256i const product     = _mm256_mul_epu32     (data_key, data_key_lo);
            /* xacc[i] += swap(data_vec); */
            __m256i const data_swap = _mm256_shuffle_epi32(data_vec, _MM_SHUFFLE(1, 0, 3, 2));
            __m256i const sum       = _mm256_add_epi64(xacc[i], data_swap);
            /* xacc[i] += product; */
            xacc[i] = _mm256_add_epi64(product, sum);
    }   }
}

XXH_FORCE_INLINE XXH_TARGET_AVX2 void
XXH3_scrambleAcc_avx2(void* XXH_RESTRICT acc, const void* XXH_RESTRICT secret)
{
    XXH_ASSERT((((size_t)acc) & 31) == 0);
    {   XXH_ALIGN(32) __m256i* const xacc = (__m256i*) acc;
        /* Unaligned. This is mainly for pointer arithmetic, and because
         * _mm256_loadu_si256 requires a const __m256i * pointer for some reason. */
        const         __m256i* const xsecret = (const __m256i *) secret;
        const __m256i prime32 = _mm256_set1_epi32((int)XXH_PRIME32_1);

        size_t i;
        for (i=0; i < XXH_STRIPE_LEN/sizeof(__m256i); i++) {
            /* xacc[i] ^= (xacc[i] >> 47) */
            __m256i const acc_vec     = xacc[i];
            __m256i const shifted     = _mm256_srli_epi64    (acc_vec, 47);
            __m256i const data_vec    = _mm256_xor_si256     (acc_vec, shifted);
            /* xacc[i] ^= xsecret; */
            __m256i const key_vec     = _mm256_loadu_si256   (xsecret+i);
            __m256i const data_key    = _mm256_xor_si256     (data_vec, key_vec);

            /* xacc[i] *= XXH_PRIME32_1; */
            __m256i const data_key_hi = _mm256_shuffle_epi32 (data_key, _MM_SHUFFLE(0, 3, 0, 1));
            __m256i const prod_lo     = _mm256_mul_epu32     (data_key, prime32);
            __m256i const prod_hi     = _mm256_mul_epu32     (data_key_hi, prime32);
            xacc[i] = _mm256_add_epi64(prod_lo, _mm256_slli_epi64(prod_hi, 32));
        }
    }
}

XXH_FORCE_INLINE XXH_TARGET_AVX2 void XXH3_initCustomSecret_avx2(void* XXH_RESTRICT customSecret, xxh_u64 seed64)
{
    XXH_STATIC_ASSERT((XXH_SECRET_DEFAULT_SIZE & 31) == 0);
    XXH_STATIC_ASSERT((XXH_SECRET_DEFAULT_SIZE / sizeof(__m256i)) == 6);
    XXH_STATIC_ASSERT(XXH_SEC_ALIGN <= 64);
    (void)(&XXH_writeLE64);
    XXH_PREFETCH(customSecret);
    {   __m256i const seed = _mm256_set_epi64x(-(xxh_i64)seed64, (xxh_i64)seed64, -(xxh_i64)seed64, (xxh_i64)seed64);

        XXH_ALIGN(64) const __m256i* const src  = (const __m256i*) XXH3_kSecret;
        XXH_ALIGN(64)       __m256i*       dest = (      __m256i*) customSecret;

#       if defined(__GNUC__) || defined(__clang__)
        /*
         * On GCC & Clang, marking 'dest' as modified will cause the compiler:
         *   - do not extract the secret from sse registers in the internal loop
         *   - use less common registers, and avoid pushing these reg into stack
         * The asm hack causes Clang to assume that XXH3_kSecretPtr aliases with
         * customSecret, and on aarch64, this prevented LDP from merging two
         * loads together for free. Putting the loads together before the stores
         * properly generates LDP.
         */
        __asm__("" : "+r" (dest));
#       endif

        /* GCC -O2 need unroll loop manually */
        dest[0] = _mm256_add_epi64(_mm256_stream_load_si256(src+0), seed);
        dest[1] = _mm256_add_epi64(_mm256_stream_load_si256(src+1), seed);
        dest[2] = _mm256_add_epi64(_mm256_stream_load_si256(src+2), seed);
        dest[3] = _mm256_add_epi64(_mm256_stream_load_si256(src+3), seed);
        dest[4] = _mm256_add_epi64(_mm256_stream_load_si256(src+4), seed);
        dest[5] = _mm256_add_epi64(_mm256_stream_load_si256(src+5), seed);
    }
}

#endif

#if (XXH_VECTOR == XXH_SSE2) || defined(XXH_X86DISPATCH)

#ifndef XXH_TARGET_SSE2
# define XXH_TARGET_SSE2  /* disable attribute target */
#endif

XXH_FORCE_INLINE XXH_TARGET_SSE2 void
XXH3_accumulate_512_sse2( void* XXH_RESTRICT acc,
                    const void* XXH_RESTRICT input,
                    const void* XXH_RESTRICT secret)
{
    /* SSE2 is just a half-scale version of the AVX2 version. */
    XXH_ASSERT((((size_t)acc) & 15) == 0);
    {   XXH_ALIGN(16) __m128i* const xacc    =       (__m128i *) acc;
        /* Unaligned. This is mainly for pointer arithmetic, and because
         * _mm_loadu_si128 requires a const __m128i * pointer for some reason. */
        const         __m128i* const xinput  = (const __m128i *) input;
        /* Unaligned. This is mainly for pointer arithmetic, and because
         * _mm_loadu_si128 requires a const __m128i * pointer for some reason. */
        const         __m128i* const xsecret = (const __m128i *) secret;

        size_t i;
        for (i=0; i < XXH_STRIPE_LEN/sizeof(__m128i); i++) {
            /* data_vec    = xinput[i]; */
            __m128i const data_vec    = _mm_loadu_si128   (xinput+i);
            /* key_vec     = xsecret[i]; */
            __m128i const key_vec     = _mm_loadu_si128   (xsecret+i);
            /* data_key    = data_vec ^ key_vec; */
            __m128i const data_key    = _mm_xor_si128     (data_vec, key_vec);
            /* data_key_lo = data_key >> 32; */
            __m128i const data_key_lo = _mm_shuffle_epi32 (data_key, _MM_SHUFFLE(0, 3, 0, 1));
            /* product     = (data_key & 0xffffffff) * (data_key_lo & 0xffffffff); */
            __m128i const product     = _mm_mul_epu32     (data_key, data_key_lo);
            /* xacc[i] += swap(data_vec); */
            __m128i const data_swap = _mm_shuffle_epi32(data_vec, _MM_SHUFFLE(1,0,3,2));
            __m128i const sum       = _mm_add_epi64(xacc[i], data_swap);
            /* xacc[i] += product; */
            xacc[i] = _mm_add_epi64(product, sum);
    }   }
}

XXH_FORCE_INLINE XXH_TARGET_SSE2 void
XXH3_scrambleAcc_sse2(void* XXH_RESTRICT acc, const void* XXH_RESTRICT secret)
{
    XXH_ASSERT((((size_t)acc) & 15) == 0);
    {   XXH_ALIGN(16) __m128i* const xacc = (__m128i*) acc;
        /* Unaligned. This is mainly for pointer arithmetic, and because
         * _mm_loadu_si128 requires a const __m128i * pointer for some reason. */
        const         __m128i* const xsecret = (const __m128i *) secret;
        const __m128i prime32 = _mm_set1_epi32((int)XXH_PRIME32_1);

        size_t i;
        for (i=0; i < XXH_STRIPE_LEN/sizeof(__m128i); i++) {
            /* xacc[i] ^= (xacc[i] >> 47) */
            __m128i const acc_vec     = xacc[i];
            __m128i const shifted     = _mm_srli_epi64    (acc_vec, 47);
            __m128i const data_vec    = _mm_xor_si128     (acc_vec, shifted);
            /* xacc[i] ^= xsecret[i]; */
            __m128i const key_vec     = _mm_loadu_si128   (xsecret+i);
            __m128i const data_key    = _mm_xor_si128     (data_vec, key_vec);

            /* xacc[i] *= XXH_PRIME32_1; */
            __m128i const data_key_hi = _mm_shuffle_epi32 (data_key, _MM_SHUFFLE(0, 3, 0, 1));
            __m128i const prod_lo     = _mm_mul_epu32     (data_key, prime32);
            __m128i const prod_hi     = _mm_mul_epu32     (data_key_hi, prime32);
            xacc[i] = _mm_add_epi64(prod_lo, _mm_slli_epi64(prod_hi, 32));
        }
    }
}

XXH_FORCE_INLINE XXH_TARGET_SSE2 void XXH3_initCustomSecret_sse2(void* XXH_RESTRICT customSecret, xxh_u64 seed64)
{
    XXH_STATIC_ASSERT((XXH_SECRET_DEFAULT_SIZE & 15) == 0);
    (void)(&XXH_writeLE64);
    {   int const nbRounds = XXH_SECRET_DEFAULT_SIZE / sizeof(__m128i);

#       if defined(_MSC_VER) && defined(_M_IX86) && _MSC_VER < 1900
        // MSVC 32bit mode does not support _mm_set_epi64x before 2015
        XXH_ALIGN(16) const xxh_i64 seed64x2[2] = { (xxh_i64)seed64, -(xxh_i64)seed64 };
        __m128i const seed = _mm_load_si128((__m128i const*)seed64x2);
#       else
        __m128i const seed = _mm_set_epi64x(-(xxh_i64)seed64, (xxh_i64)seed64);
#       endif
        int i;

        XXH_ALIGN(64)        const float* const src  = (float const*) XXH3_kSecret;
        XXH_ALIGN(XXH_SEC_ALIGN) __m128i*       dest = (__m128i*) customSecret;
#       if defined(__GNUC__) || defined(__clang__)
        /*
         * On GCC & Clang, marking 'dest' as modified will cause the compiler:
         *   - do not extract the secret from sse registers in the internal loop
         *   - use less common registers, and avoid pushing these reg into stack
         */
        __asm__("" : "+r" (dest));
#       endif

        for (i=0; i < nbRounds; ++i) {
            dest[i] = _mm_add_epi64(_mm_castps_si128(_mm_load_ps(src+i*4)), seed);
    }   }
}

#endif

#if (XXH_VECTOR == XXH_NEON)

XXH_FORCE_INLINE void
XXH3_accumulate_512_neon( void* XXH_RESTRICT acc,
                    const void* XXH_RESTRICT input,
                    const void* XXH_RESTRICT secret)
{
    XXH_ASSERT((((size_t)acc) & 15) == 0);
    {
        XXH_ALIGN(16) uint64x2_t* const xacc = (uint64x2_t *) acc;
        /* We don't use a uint32x4_t pointer because it causes bus errors on ARMv7. */
        uint8_t const* const xinput = (const uint8_t *) input;
        uint8_t const* const xsecret  = (const uint8_t *) secret;

        size_t i;
        for (i=0; i < XXH_STRIPE_LEN / sizeof(uint64x2_t); i++) {
            /* data_vec = xinput[i]; */
            uint8x16_t data_vec    = vld1q_u8(xinput  + (i * 16));
            /* key_vec  = xsecret[i];  */
            uint8x16_t key_vec     = vld1q_u8(xsecret + (i * 16));
            uint64x2_t data_key;
            uint32x2_t data_key_lo, data_key_hi;
            /* xacc[i] += swap(data_vec); */
            uint64x2_t const data64  = vreinterpretq_u64_u8(data_vec);
            uint64x2_t const swapped = vextq_u64(data64, data64, 1);
            xacc[i] = vaddq_u64 (xacc[i], swapped);
            /* data_key = data_vec ^ key_vec; */
            data_key = vreinterpretq_u64_u8(veorq_u8(data_vec, key_vec));
            /* data_key_lo = (uint32x2_t) (data_key & 0xFFFFFFFF);
             * data_key_hi = (uint32x2_t) (data_key >> 32);
             * data_key = UNDEFINED; */
            XXH_SPLIT_IN_PLACE(data_key, data_key_lo, data_key_hi);
            /* xacc[i] += (uint64x2_t) data_key_lo * (uint64x2_t) data_key_hi; */
            xacc[i] = vmlal_u32 (xacc[i], data_key_lo, data_key_hi);

        }
    }
}

XXH_FORCE_INLINE void
XXH3_scrambleAcc_neon(void* XXH_RESTRICT acc, const void* XXH_RESTRICT secret)
{
    XXH_ASSERT((((size_t)acc) & 15) == 0);

    {   uint64x2_t* xacc       = (uint64x2_t*) acc;
        uint8_t const* xsecret = (uint8_t const*) secret;
        uint32x2_t prime       = vdup_n_u32 (XXH_PRIME32_1);

        size_t i;
        for (i=0; i < XXH_STRIPE_LEN/sizeof(uint64x2_t); i++) {
            /* xacc[i] ^= (xacc[i] >> 47); */
            uint64x2_t acc_vec  = xacc[i];
            uint64x2_t shifted  = vshrq_n_u64 (acc_vec, 47);
            uint64x2_t data_vec = veorq_u64   (acc_vec, shifted);

            /* xacc[i] ^= xsecret[i]; */
            uint8x16_t key_vec  = vld1q_u8(xsecret + (i * 16));
            uint64x2_t data_key = veorq_u64(data_vec, vreinterpretq_u64_u8(key_vec));

            /* xacc[i] *= XXH_PRIME32_1 */
            uint32x2_t data_key_lo, data_key_hi;
            /* data_key_lo = (uint32x2_t) (xacc[i] & 0xFFFFFFFF);
             * data_key_hi = (uint32x2_t) (xacc[i] >> 32);
             * xacc[i] = UNDEFINED; */
            XXH_SPLIT_IN_PLACE(data_key, data_key_lo, data_key_hi);
            {   /*
                 * prod_hi = (data_key >> 32) * XXH_PRIME32_1;
                 *
                 * Avoid vmul_u32 + vshll_n_u32 since Clang 6 and 7 will
                 * incorrectly "optimize" this:
                 *   tmp     = vmul_u32(vmovn_u64(a), vmovn_u64(b));
                 *   shifted = vshll_n_u32(tmp, 32);
                 * to this:
                 *   tmp     = "vmulq_u64"(a, b); // no such thing!
                 *   shifted = vshlq_n_u64(tmp, 32);
                 *
                 * However, unlike SSE, Clang lacks a 64-bit multiply routine
                 * for NEON, and it scalarizes two 64-bit multiplies instead.
                 *
                 * vmull_u32 has the same timing as vmul_u32, and it avoids
                 * this bug completely.
                 * See https://bugs.llvm.org/show_bug.cgi?id=39967
                 */
                uint64x2_t prod_hi = vmull_u32 (data_key_hi, prime);
                /* xacc[i] = prod_hi << 32; */
                xacc[i] = vshlq_n_u64(prod_hi, 32);
                /* xacc[i] += (prod_hi & 0xFFFFFFFF) * XXH_PRIME32_1; */
                xacc[i] = vmlal_u32(xacc[i], data_key_lo, prime);
            }
    }   }
}

#endif

#if (XXH_VECTOR == XXH_VSX)

XXH_FORCE_INLINE void
XXH3_accumulate_512_vsx(  void* XXH_RESTRICT acc,
                    const void* XXH_RESTRICT input,
                    const void* XXH_RESTRICT secret)
{
          xxh_u64x2* const xacc     =       (xxh_u64x2*) acc;    /* presumed aligned */
    xxh_u64x2 const* const xinput   = (xxh_u64x2 const*) input;   /* no alignment restriction */
    xxh_u64x2 const* const xsecret  = (xxh_u64x2 const*) secret;    /* no alignment restriction */
    xxh_u64x2 const v32 = { 32, 32 };
    size_t i;
    for (i = 0; i < XXH_STRIPE_LEN / sizeof(xxh_u64x2); i++) {
        /* data_vec = xinput[i]; */
        xxh_u64x2 const data_vec = XXH_vec_loadu(xinput + i);
        /* key_vec = xsecret[i]; */
        xxh_u64x2 const key_vec  = XXH_vec_loadu(xsecret + i);
        xxh_u64x2 const data_key = data_vec ^ key_vec;
        /* shuffled = (data_key << 32) | (data_key >> 32); */
        xxh_u32x4 const shuffled = (xxh_u32x4)vec_rl(data_key, v32);
        /* product = ((xxh_u64x2)data_key & 0xFFFFFFFF) * ((xxh_u64x2)shuffled & 0xFFFFFFFF); */
        xxh_u64x2 const product  = XXH_vec_mulo((xxh_u32x4)data_key, shuffled);
        xacc[i] += product;

        /* swap high and low halves */
#ifdef __s390x__
        xacc[i] += vec_permi(data_vec, data_vec, 2);
#else
        xacc[i] += vec_xxpermdi(data_vec, data_vec, 2);
#endif
    }
}

XXH_FORCE_INLINE void
XXH3_scrambleAcc_vsx(void* XXH_RESTRICT acc, const void* XXH_RESTRICT secret)
{
    XXH_ASSERT((((size_t)acc) & 15) == 0);

    {         xxh_u64x2* const xacc    =       (xxh_u64x2*) acc;
        const xxh_u64x2* const xsecret = (const xxh_u64x2*) secret;
        /* constants */
        xxh_u64x2 const v32  = { 32, 32 };
        xxh_u64x2 const v47 = { 47, 47 };
        xxh_u32x4 const prime = { XXH_PRIME32_1, XXH_PRIME32_1, XXH_PRIME32_1, XXH_PRIME32_1 };
        size_t i;
        for (i = 0; i < XXH_STRIPE_LEN / sizeof(xxh_u64x2); i++) {
            /* xacc[i] ^= (xacc[i] >> 47); */
            xxh_u64x2 const acc_vec  = xacc[i];
            xxh_u64x2 const data_vec = acc_vec ^ (acc_vec >> v47);

            /* xacc[i] ^= xsecret[i]; */
            xxh_u64x2 const key_vec  = XXH_vec_loadu(xsecret + i);
            xxh_u64x2 const data_key = data_vec ^ key_vec;

            /* xacc[i] *= XXH_PRIME32_1 */
            /* prod_lo = ((xxh_u64x2)data_key & 0xFFFFFFFF) * ((xxh_u64x2)prime & 0xFFFFFFFF);  */
            xxh_u64x2 const prod_even  = XXH_vec_mule((xxh_u32x4)data_key, prime);
            /* prod_hi = ((xxh_u64x2)data_key >> 32) * ((xxh_u64x2)prime >> 32);  */
            xxh_u64x2 const prod_odd  = XXH_vec_mulo((xxh_u32x4)data_key, prime);
            xacc[i] = prod_odd + (prod_even << v32);
    }   }
}

#endif

/* scalar variants - universal */

XXH_FORCE_INLINE void
XXH3_accumulate_512_scalar(void* XXH_RESTRICT acc,
                     const void* XXH_RESTRICT input,
                     const void* XXH_RESTRICT secret)
{
    XXH_ALIGN(XXH_ACC_ALIGN) xxh_u64* const xacc = (xxh_u64*) acc; /* presumed aligned */
    const xxh_u8* const xinput  = (const xxh_u8*) input;  /* no alignment restriction */
    const xxh_u8* const xsecret = (const xxh_u8*) secret;   /* no alignment restriction */
    size_t i;
    XXH_ASSERT(((size_t)acc & (XXH_ACC_ALIGN-1)) == 0);
    for (i=0; i < XXH_ACC_NB; i++) {
        xxh_u64 const data_val = XXH_readLE64(xinput + 8*i);
        xxh_u64 const data_key = data_val ^ XXH_readLE64(xsecret + i*8);
        xacc[i ^ 1] += data_val; /* swap adjacent lanes */
        xacc[i] += XXH_mult32to64(data_key & 0xFFFFFFFF, data_key >> 32);
    }
}

XXH_FORCE_INLINE void
XXH3_scrambleAcc_scalar(void* XXH_RESTRICT acc, const void* XXH_RESTRICT secret)
{
    XXH_ALIGN(XXH_ACC_ALIGN) xxh_u64* const xacc = (xxh_u64*) acc;   /* presumed aligned */
    const xxh_u8* const xsecret = (const xxh_u8*) secret;   /* no alignment restriction */
    size_t i;
    XXH_ASSERT((((size_t)acc) & (XXH_ACC_ALIGN-1)) == 0);
    for (i=0; i < XXH_ACC_NB; i++) {
        xxh_u64 const key64 = XXH_readLE64(xsecret + 8*i);
        xxh_u64 acc64 = xacc[i];
        acc64 = XXH_xorshift64(acc64, 47);
        acc64 ^= key64;
        acc64 *= XXH_PRIME32_1;
        xacc[i] = acc64;
    }
}

XXH_FORCE_INLINE void
XXH3_initCustomSecret_scalar(void* XXH_RESTRICT customSecret, xxh_u64 seed64)
{
    /*
     * We need a separate pointer for the hack below,
     * which requires a non-const pointer.
     * Any decent compiler will optimize this out otherwise.
     */
    const xxh_u8* kSecretPtr = XXH3_kSecret;
    XXH_STATIC_ASSERT((XXH_SECRET_DEFAULT_SIZE & 15) == 0);

#if defined(__clang__) && defined(__aarch64__)
    __asm__("" : "+r" (kSecretPtr));
#endif
    /*
     * Note: in debug mode, this overrides the asm optimization
     * and Clang will emit MOVK chains again.
     */
    XXH_ASSERT(kSecretPtr == XXH3_kSecret);

    {   int const nbRounds = XXH_SECRET_DEFAULT_SIZE / 16;
        int i;
        for (i=0; i < nbRounds; i++) {
            /*
             * The asm hack causes Clang to assume that kSecretPtr aliases with
             * customSecret, and on aarch64, this prevented LDP from merging two
             * loads together for free. Putting the loads together before the stores
             * properly generates LDP.
             */
            xxh_u64 lo = XXH_readLE64(kSecretPtr + 16*i)     + seed64;
            xxh_u64 hi = XXH_readLE64(kSecretPtr + 16*i + 8) - seed64;
            XXH_writeLE64((xxh_u8*)customSecret + 16*i,     lo);
            XXH_writeLE64((xxh_u8*)customSecret + 16*i + 8, hi);
    }   }
}


typedef void (*XXH3_f_accumulate_512)(void* XXH_RESTRICT, const void*, const void*);
typedef void (*XXH3_f_scrambleAcc)(void* XXH_RESTRICT, const void*);
typedef void (*XXH3_f_initCustomSecret)(void* XXH_RESTRICT, xxh_u64);


#if (XXH_VECTOR == XXH_AVX512)

#define XXH3_accumulate_512 XXH3_accumulate_512_avx512
#define XXH3_scrambleAcc    XXH3_scrambleAcc_avx512
#define XXH3_initCustomSecret XXH3_initCustomSecret_avx512

#elif (XXH_VECTOR == XXH_AVX2)

#define XXH3_accumulate_512 XXH3_accumulate_512_avx2
#define XXH3_scrambleAcc    XXH3_scrambleAcc_avx2
#define XXH3_initCustomSecret XXH3_initCustomSecret_avx2

#elif (XXH_VECTOR == XXH_SSE2)

#define XXH3_accumulate_512 XXH3_accumulate_512_sse2
#define XXH3_scrambleAcc    XXH3_scrambleAcc_sse2
#define XXH3_initCustomSecret XXH3_initCustomSecret_sse2

#elif (XXH_VECTOR == XXH_NEON)

#define XXH3_accumulate_512 XXH3_accumulate_512_neon
#define XXH3_scrambleAcc    XXH3_scrambleAcc_neon
#define XXH3_initCustomSecret XXH3_initCustomSecret_scalar

#elif (XXH_VECTOR == XXH_VSX)

#define XXH3_accumulate_512 XXH3_accumulate_512_vsx
#define XXH3_scrambleAcc    XXH3_scrambleAcc_vsx
#define XXH3_initCustomSecret XXH3_initCustomSecret_scalar

#else /* scalar */

#define XXH3_accumulate_512 XXH3_accumulate_512_scalar
#define XXH3_scrambleAcc    XXH3_scrambleAcc_scalar
#define XXH3_initCustomSecret XXH3_initCustomSecret_scalar

#endif



#ifndef XXH_PREFETCH_DIST
#  ifdef __clang__
#    define XXH_PREFETCH_DIST 320
#  else
#    if (XXH_VECTOR == XXH_AVX512)
#      define XXH_PREFETCH_DIST 512
#    else
#      define XXH_PREFETCH_DIST 384
#    endif
#  endif  /* __clang__ */
#endif  /* XXH_PREFETCH_DIST */

/*
 * XXH3_accumulate()
 * Loops over XXH3_accumulate_512().
 * Assumption: nbStripes will not overflow the secret size
 */
XXH_FORCE_INLINE void
XXH3_accumulate(     xxh_u64* XXH_RESTRICT acc,
                const xxh_u8* XXH_RESTRICT input,
                const xxh_u8* XXH_RESTRICT secret,
                      size_t nbStripes,
                      XXH3_f_accumulate_512 f_acc512)
{
    size_t n;
    for (n = 0; n < nbStripes; n++ ) {
        const xxh_u8* const in = input + n*XXH_STRIPE_LEN;
        XXH_PREFETCH(in + XXH_PREFETCH_DIST);
        f_acc512(acc,
                 in,
                 secret + n*XXH_SECRET_CONSUME_RATE);
    }
}

XXH_FORCE_INLINE void
XXH3_hashLong_internal_loop(xxh_u64* XXH_RESTRICT acc,
                      const xxh_u8* XXH_RESTRICT input, size_t len,
                      const xxh_u8* XXH_RESTRICT secret, size_t secretSize,
                            XXH3_f_accumulate_512 f_acc512,
                            XXH3_f_scrambleAcc f_scramble)
{
    size_t const nbStripesPerBlock = (secretSize - XXH_STRIPE_LEN) / XXH_SECRET_CONSUME_RATE;
    size_t const block_len = XXH_STRIPE_LEN * nbStripesPerBlock;
    size_t const nb_blocks = (len - 1) / block_len;

    size_t n;

    XXH_ASSERT(secretSize >= XXH3_SECRET_SIZE_MIN);

    for (n = 0; n < nb_blocks; n++) {
        XXH3_accumulate(acc, input + n*block_len, secret, nbStripesPerBlock, f_acc512);
        f_scramble(acc, secret + secretSize - XXH_STRIPE_LEN);
    }

    /* last partial block */
    XXH_ASSERT(len > XXH_STRIPE_LEN);
    {   size_t const nbStripes = ((len - 1) - (block_len * nb_blocks)) / XXH_STRIPE_LEN;
        XXH_ASSERT(nbStripes <= (secretSize / XXH_SECRET_CONSUME_RATE));
        XXH3_accumulate(acc, input + nb_blocks*block_len, secret, nbStripes, f_acc512);

        /* last stripe */
        {   const xxh_u8* const p = input + len - XXH_STRIPE_LEN;
#define XXH_SECRET_LASTACC_START 7  /* not aligned on 8, last secret is different from acc & scrambler */
            f_acc512(acc, p, secret + secretSize - XXH_STRIPE_LEN - XXH_SECRET_LASTACC_START);
    }   }
}

XXH_FORCE_INLINE xxh_u64
XXH3_mix2Accs(const xxh_u64* XXH_RESTRICT acc, const xxh_u8* XXH_RESTRICT secret)
{
    return XXH3_mul128_fold64(
               acc[0] ^ XXH_readLE64(secret),
               acc[1] ^ XXH_readLE64(secret+8) );
}

static XXH64_hash_t
XXH3_mergeAccs(const xxh_u64* XXH_RESTRICT acc, const xxh_u8* XXH_RESTRICT secret, xxh_u64 start)
{
    xxh_u64 result64 = start;
    size_t i = 0;

    for (i = 0; i < 4; i++) {
        result64 += XXH3_mix2Accs(acc+2*i, secret + 16*i);
#if defined(__clang__)                                /* Clang */ \
    && (defined(__arm__) || defined(__thumb__))       /* ARMv7 */ \
    && (defined(__ARM_NEON) || defined(__ARM_NEON__)) /* NEON */  \
    && !defined(XXH_ENABLE_AUTOVECTORIZE)             /* Define to disable */
        /*
         * UGLY HACK:
         * Prevent autovectorization on Clang ARMv7-a. Exact same problem as
         * the one in XXH3_len_129to240_64b. Speeds up shorter keys > 240b.
         * XXH3_64bits, len == 256, Snapdragon 835:
         *   without hack: 2063.7 MB/s
         *   with hack:    2560.7 MB/s
         */
        __asm__("" : "+r" (result64));
#endif
    }

    return XXH3_avalanche(result64);
}

#define XXH3_INIT_ACC { XXH_PRIME32_3, XXH_PRIME64_1, XXH_PRIME64_2, XXH_PRIME64_3, \
                        XXH_PRIME64_4, XXH_PRIME32_2, XXH_PRIME64_5, XXH_PRIME32_1 }

XXH_FORCE_INLINE XXH64_hash_t
XXH3_hashLong_64b_internal(const void* XXH_RESTRICT input, size_t len,
                           const void* XXH_RESTRICT secret, size_t secretSize,
                           XXH3_f_accumulate_512 f_acc512,
                           XXH3_f_scrambleAcc f_scramble)
{
    XXH_ALIGN(XXH_ACC_ALIGN) xxh_u64 acc[XXH_ACC_NB] = XXH3_INIT_ACC;

    XXH3_hashLong_internal_loop(acc, (const xxh_u8*)input, len, (const xxh_u8*)secret, secretSize, f_acc512, f_scramble);

    /* converge into final hash */
    XXH_STATIC_ASSERT(sizeof(acc) == 64);
    /* do not align on 8, so that the secret is different from the accumulator */
#define XXH_SECRET_MERGEACCS_START 11
    XXH_ASSERT(secretSize >= sizeof(acc) + XXH_SECRET_MERGEACCS_START);
    return XXH3_mergeAccs(acc, (const xxh_u8*)secret + XXH_SECRET_MERGEACCS_START, (xxh_u64)len * XXH_PRIME64_1);
}

/*
 * It's important for performance that XXH3_hashLong is not inlined.
 */
XXH_NO_INLINE XXH64_hash_t
XXH3_hashLong_64b_withSecret(const void* XXH_RESTRICT input, size_t len,
                             XXH64_hash_t seed64, const xxh_u8* XXH_RESTRICT secret, size_t secretLen)
{
    (void)seed64;
    return XXH3_hashLong_64b_internal(input, len, secret, secretLen, XXH3_accumulate_512, XXH3_scrambleAcc);
}

/*
 * It's important for performance that XXH3_hashLong is not inlined.
 * Since the function is not inlined, the compiler may not be able to understand that,
 * in some scenarios, its `secret` argument is actually a compile time constant.
 * This variant enforces that the compiler can detect that,
 * and uses this opportunity to streamline the generated code for better performance.
 */
XXH_NO_INLINE XXH64_hash_t
XXH3_hashLong_64b_default(const void* XXH_RESTRICT input, size_t len,
                          XXH64_hash_t seed64, const xxh_u8* XXH_RESTRICT secret, size_t secretLen)
{
    (void)seed64; (void)secret; (void)secretLen;
    return XXH3_hashLong_64b_internal(input, len, XXH3_kSecret, sizeof(XXH3_kSecret), XXH3_accumulate_512, XXH3_scrambleAcc);
}

XXH_FORCE_INLINE XXH64_hash_t
XXH3_hashLong_64b_withSeed_internal(const void* input, size_t len,
                                    XXH64_hash_t seed,
                                    XXH3_f_accumulate_512 f_acc512,
                                    XXH3_f_scrambleAcc f_scramble,
                                    XXH3_f_initCustomSecret f_initSec)
{
    if (seed == 0)
        return XXH3_hashLong_64b_internal(input, len,
                                          XXH3_kSecret, sizeof(XXH3_kSecret),
                                          f_acc512, f_scramble);
    {   XXH_ALIGN(XXH_SEC_ALIGN) xxh_u8 secret[XXH_SECRET_DEFAULT_SIZE];
        f_initSec(secret, seed);
        return XXH3_hashLong_64b_internal(input, len, secret, sizeof(secret),
                                          f_acc512, f_scramble);
    }
}

/*
 * It's important for performance that XXH3_hashLong is not inlined.
 */
XXH_NO_INLINE XXH64_hash_t
XXH3_hashLong_64b_withSeed(const void* input, size_t len,
                           XXH64_hash_t seed, const xxh_u8* secret, size_t secretLen)
{
    (void)secret; (void)secretLen;
    return XXH3_hashLong_64b_withSeed_internal(input, len, seed,
                XXH3_accumulate_512, XXH3_scrambleAcc, XXH3_initCustomSecret);
}


typedef XXH64_hash_t (*XXH3_hashLong64_f)(const void* XXH_RESTRICT, size_t,
                                          XXH64_hash_t, const xxh_u8* XXH_RESTRICT, size_t);

XXH_FORCE_INLINE XXH64_hash_t
XXH3_64bits_internal(const void* XXH_RESTRICT input, size_t len,
                     XXH64_hash_t seed64, const void* XXH_RESTRICT secret, size_t secretLen,
                     XXH3_hashLong64_f f_hashLong)
{
    XXH_ASSERT(secretLen >= XXH3_SECRET_SIZE_MIN);
    /*
     * If an action is to be taken if `secretLen` condition is not respected,
     * it should be done here.
     * For now, it's a contract pre-condition.
     * Adding a check and a branch here would cost performance at every hash.
     * Also, note that function signature doesn't offer room to return an error.
     */
    if (len <= 16)
        return XXH3_len_0to16_64b((const xxh_u8*)input, len, (const xxh_u8*)secret, seed64);
    if (len <= 128)
        return XXH3_len_17to128_64b((const xxh_u8*)input, len, (const xxh_u8*)secret, secretLen, seed64);
    if (len <= XXH3_MIDSIZE_MAX)
        return XXH3_len_129to240_64b((const xxh_u8*)input, len, (const xxh_u8*)secret, secretLen, seed64);
    return f_hashLong(input, len, seed64, (const xxh_u8*)secret, secretLen);
}


/* ===   Public entry point   === */

XXH_PUBLIC_API XXH64_hash_t XXH3_64bits(const void* input, size_t len)
{
    return XXH3_64bits_internal(input, len, 0, XXH3_kSecret, sizeof(XXH3_kSecret), XXH3_hashLong_64b_default);
}

XXH_PUBLIC_API XXH64_hash_t
XXH3_64bits_withSecret(const void* input, size_t len, const void* secret, size_t secretSize)
{
    return XXH3_64bits_internal(input, len, 0, secret, secretSize, XXH3_hashLong_64b_withSecret);
}

XXH_PUBLIC_API XXH64_hash_t
XXH3_64bits_withSeed(const void* input, size_t len, XXH64_hash_t seed)
{
    return XXH3_64bits_internal(input, len, seed, XXH3_kSecret, sizeof(XXH3_kSecret), XXH3_hashLong_64b_withSeed);
}

static void* XXH_alignedMalloc(size_t s, size_t align)
{
    XXH_ASSERT(align <= 128 && align >= 8); /* range check */
    XXH_ASSERT((align & (align-1)) == 0);   /* power of 2 */
    XXH_ASSERT(s != 0 && s < (s + align));  /* empty/overflow */
    {   /* Overallocate to make room for manual realignment and an offset byte */
        xxh_u8* base = (xxh_u8*)XXH_malloc(s + align);
        if (base != NULL) {
            /*
             * Get the offset needed to align this pointer.
             *
             * Even if the returned pointer is aligned, there will always be
             * at least one byte to store the offset to the original pointer.
             */
            size_t offset = align - ((size_t)base & (align - 1)); /* base % align */
            /* Add the offset for the now-aligned pointer */
            xxh_u8* ptr = base + offset;

            XXH_ASSERT((size_t)ptr % align == 0);

            /* Store the offset immediately before the returned pointer. */
            ptr[-1] = (xxh_u8)offset;
            return ptr;
        }
        return NULL;
    }
}
/*
 * Frees an aligned pointer allocated by XXH_alignedMalloc(). Don't pass
 * normal malloc'd pointers, XXH_alignedMalloc has a specific data layout.
 */
static void XXH_alignedFree(void* p)
{
    if (p != NULL) {
        xxh_u8* ptr = (xxh_u8*)p;
        /* Get the offset byte we added in XXH_malloc. */
        xxh_u8 offset = ptr[-1];
        /* Free the original malloc'd pointer */
        xxh_u8* base = ptr - offset;
        XXH_free(base);
    }
}
XXH_PUBLIC_API XXH3_state_t* XXH3_createState(void)
{
    XXH3_state_t* const state = (XXH3_state_t*)XXH_alignedMalloc(sizeof(XXH3_state_t), 64);
    if (state==NULL) return NULL;
    XXH3_INITSTATE(state);
    return state;
}

XXH_PUBLIC_API XXH_errorcode XXH3_freeState(XXH3_state_t* statePtr)
{
    XXH_alignedFree(statePtr);
    return XXH_OK;
}

XXH_PUBLIC_API void
XXH3_copyState(XXH3_state_t* dst_state, const XXH3_state_t* src_state)
{
    memcpy(dst_state, src_state, sizeof(*dst_state));
}

static void
XXH3_64bits_reset_internal(XXH3_state_t* statePtr,
                           XXH64_hash_t seed,
                           const void* secret, size_t secretSize)
{
    size_t const initStart = offsetof(XXH3_state_t, bufferedSize);
    size_t const initLength = offsetof(XXH3_state_t, nbStripesPerBlock) - initStart;
    XXH_ASSERT(offsetof(XXH3_state_t, nbStripesPerBlock) > initStart);
    XXH_ASSERT(statePtr != NULL);
    /* set members from bufferedSize to nbStripesPerBlock (excluded) to 0 */
    memset((char*)statePtr + initStart, 0, initLength);
    statePtr->acc[0] = XXH_PRIME32_3;
    statePtr->acc[1] = XXH_PRIME64_1;
    statePtr->acc[2] = XXH_PRIME64_2;
    statePtr->acc[3] = XXH_PRIME64_3;
    statePtr->acc[4] = XXH_PRIME64_4;
    statePtr->acc[5] = XXH_PRIME32_2;
    statePtr->acc[6] = XXH_PRIME64_5;
    statePtr->acc[7] = XXH_PRIME32_1;
    statePtr->seed = seed;
    statePtr->extSecret = (const unsigned char*)secret;
    XXH_ASSERT(secretSize >= XXH3_SECRET_SIZE_MIN);
    statePtr->secretLimit = secretSize - XXH_STRIPE_LEN;
    statePtr->nbStripesPerBlock = statePtr->secretLimit / XXH_SECRET_CONSUME_RATE;
}

XXH_PUBLIC_API XXH_errorcode
XXH3_64bits_reset(XXH3_state_t* statePtr)
{
    if (statePtr == NULL) return XXH_ERROR;
    XXH3_64bits_reset_internal(statePtr, 0, XXH3_kSecret, XXH_SECRET_DEFAULT_SIZE);
    return XXH_OK;
}

XXH_PUBLIC_API XXH_errorcode
XXH3_64bits_reset_withSecret(XXH3_state_t* statePtr, const void* secret, size_t secretSize)
{
    if (statePtr == NULL) return XXH_ERROR;
    XXH3_64bits_reset_internal(statePtr, 0, secret, secretSize);
    if (secret == NULL) return XXH_ERROR;
    if (secretSize < XXH3_SECRET_SIZE_MIN) return XXH_ERROR;
    return XXH_OK;
}

XXH_PUBLIC_API XXH_errorcode
XXH3_64bits_reset_withSeed(XXH3_state_t* statePtr, XXH64_hash_t seed)
{
    if (statePtr == NULL) return XXH_ERROR;
    if (seed==0) return XXH3_64bits_reset(statePtr);
    if (seed != statePtr->seed) XXH3_initCustomSecret(statePtr->customSecret, seed);
    XXH3_64bits_reset_internal(statePtr, seed, NULL, XXH_SECRET_DEFAULT_SIZE);
    return XXH_OK;
}

/* Note : when XXH3_consumeStripes() is invoked,
 * there must be a guarantee that at least one more byte must be consumed from input
 * so that the function can blindly consume all stripes using the "normal" secret segment */
XXH_FORCE_INLINE void
XXH3_consumeStripes(xxh_u64* XXH_RESTRICT acc,
                    size_t* XXH_RESTRICT nbStripesSoFarPtr, size_t nbStripesPerBlock,
                    const xxh_u8* XXH_RESTRICT input, size_t nbStripes,
                    const xxh_u8* XXH_RESTRICT secret, size_t secretLimit,
                    XXH3_f_accumulate_512 f_acc512,
                    XXH3_f_scrambleAcc f_scramble)
{
    XXH_ASSERT(nbStripes <= nbStripesPerBlock);  /* can handle max 1 scramble per invocation */
    XXH_ASSERT(*nbStripesSoFarPtr < nbStripesPerBlock);
    if (nbStripesPerBlock - *nbStripesSoFarPtr <= nbStripes) {
        /* need a scrambling operation */
        size_t const nbStripesToEndofBlock = nbStripesPerBlock - *nbStripesSoFarPtr;
        size_t const nbStripesAfterBlock = nbStripes - nbStripesToEndofBlock;
        XXH3_accumulate(acc, input, secret + nbStripesSoFarPtr[0] * XXH_SECRET_CONSUME_RATE, nbStripesToEndofBlock, f_acc512);
        f_scramble(acc, secret + secretLimit);
        XXH3_accumulate(acc, input + nbStripesToEndofBlock * XXH_STRIPE_LEN, secret, nbStripesAfterBlock, f_acc512);
        *nbStripesSoFarPtr = nbStripesAfterBlock;
    } else {
        XXH3_accumulate(acc, input, secret + nbStripesSoFarPtr[0] * XXH_SECRET_CONSUME_RATE, nbStripes, f_acc512);
        *nbStripesSoFarPtr += nbStripes;
    }
}

/*
 * Both XXH3_64bits_update and XXH3_128bits_update use this routine.
 */
XXH_FORCE_INLINE XXH_errorcode
XXH3_update(XXH3_state_t* state,
            const xxh_u8* input, size_t len,
            XXH3_f_accumulate_512 f_acc512,
            XXH3_f_scrambleAcc f_scramble)
{
    if (input==NULL)
#if defined(XXH_ACCEPT_NULL_INPUT_POINTER) && (XXH_ACCEPT_NULL_INPUT_POINTER>=1)
        return XXH_OK;
#else
        return XXH_ERROR;
#endif

    {   const xxh_u8* const bEnd = input + len;
        const unsigned char* const secret = (state->extSecret == NULL) ? state->customSecret : state->extSecret;

        state->totalLen += len;

        if (state->bufferedSize + len <= XXH3_INTERNALBUFFER_SIZE) {  /* fill in tmp buffer */
            XXH_memcpy(state->buffer + state->bufferedSize, input, len);
            state->bufferedSize += (XXH32_hash_t)len;
            return XXH_OK;
        }
        /* total input is now > XXH3_INTERNALBUFFER_SIZE */

        #define XXH3_INTERNALBUFFER_STRIPES (XXH3_INTERNALBUFFER_SIZE / XXH_STRIPE_LEN)
        XXH_STATIC_ASSERT(XXH3_INTERNALBUFFER_SIZE % XXH_STRIPE_LEN == 0);   /* clean multiple */

        /*
         * Internal buffer is partially filled (always, except at beginning)
         * Complete it, then consume it.
         */
        if (state->bufferedSize) {
            size_t const loadSize = XXH3_INTERNALBUFFER_SIZE - state->bufferedSize;
            XXH_memcpy(state->buffer + state->bufferedSize, input, loadSize);
            input += loadSize;
            XXH3_consumeStripes(state->acc,
                               &state->nbStripesSoFar, state->nbStripesPerBlock,
                                state->buffer, XXH3_INTERNALBUFFER_STRIPES,
                                secret, state->secretLimit,
                                f_acc512, f_scramble);
            state->bufferedSize = 0;
        }
        XXH_ASSERT(input < bEnd);

        /* Consume input by a multiple of internal buffer size */
        if (input+XXH3_INTERNALBUFFER_SIZE < bEnd) {
            const xxh_u8* const limit = bEnd - XXH3_INTERNALBUFFER_SIZE;
            do {
                XXH3_consumeStripes(state->acc,
                                   &state->nbStripesSoFar, state->nbStripesPerBlock,
                                    input, XXH3_INTERNALBUFFER_STRIPES,
                                    secret, state->secretLimit,
                                    f_acc512, f_scramble);
                input += XXH3_INTERNALBUFFER_SIZE;
            } while (input<limit);
            /* for last partial stripe */
            memcpy(state->buffer + sizeof(state->buffer) - XXH_STRIPE_LEN, input - XXH_STRIPE_LEN, XXH_STRIPE_LEN);
        }
        XXH_ASSERT(input < bEnd);

        /* Some remaining input (always) : buffer it */
        XXH_memcpy(state->buffer, input, (size_t)(bEnd-input));
        state->bufferedSize = (XXH32_hash_t)(bEnd-input);
    }

    return XXH_OK;
}

XXH_PUBLIC_API XXH_errorcode
XXH3_64bits_update(XXH3_state_t* state, const void* input, size_t len)
{
    return XXH3_update(state, (const xxh_u8*)input, len,
                       XXH3_accumulate_512, XXH3_scrambleAcc);
}


XXH_FORCE_INLINE void
XXH3_digest_long (XXH64_hash_t* acc,
                  const XXH3_state_t* state,
                  const unsigned char* secret)
{
    /*
     * Digest on a local copy. This way, the state remains unaltered, and it can
     * continue ingesting more input afterwards.
     */
    memcpy(acc, state->acc, sizeof(state->acc));
    if (state->bufferedSize >= XXH_STRIPE_LEN) {
        size_t const nbStripes = (state->bufferedSize - 1) / XXH_STRIPE_LEN;
        size_t nbStripesSoFar = state->nbStripesSoFar;
        XXH3_consumeStripes(acc,
                           &nbStripesSoFar, state->nbStripesPerBlock,
                            state->buffer, nbStripes,
                            secret, state->secretLimit,
                            XXH3_accumulate_512, XXH3_scrambleAcc);
        /* last stripe */
        XXH3_accumulate_512(acc,
                            state->buffer + state->bufferedSize - XXH_STRIPE_LEN,
                            secret + state->secretLimit - XXH_SECRET_LASTACC_START);
    } else {  /* bufferedSize < XXH_STRIPE_LEN */
        xxh_u8 lastStripe[XXH_STRIPE_LEN];
        size_t const catchupSize = XXH_STRIPE_LEN - state->bufferedSize;
        XXH_ASSERT(state->bufferedSize > 0);  /* there is always some input buffered */
        memcpy(lastStripe, state->buffer + sizeof(state->buffer) - catchupSize, catchupSize);
        memcpy(lastStripe + catchupSize, state->buffer, state->bufferedSize);
        XXH3_accumulate_512(acc,
                            lastStripe,
                            secret + state->secretLimit - XXH_SECRET_LASTACC_START);
    }
}

XXH_PUBLIC_API XXH64_hash_t XXH3_64bits_digest (const XXH3_state_t* state)
{
    const unsigned char* const secret = (state->extSecret == NULL) ? state->customSecret : state->extSecret;
    if (state->totalLen > XXH3_MIDSIZE_MAX) {
        XXH_ALIGN(XXH_ACC_ALIGN) XXH64_hash_t acc[XXH_ACC_NB];
        XXH3_digest_long(acc, state, secret);
        return XXH3_mergeAccs(acc,
                              secret + XXH_SECRET_MERGEACCS_START,
                              (xxh_u64)state->totalLen * XXH_PRIME64_1);
    }
    /* totalLen <= XXH3_MIDSIZE_MAX: digesting a short input */
    if (state->seed)
        return XXH3_64bits_withSeed(state->buffer, (size_t)state->totalLen, state->seed);
    return XXH3_64bits_withSecret(state->buffer, (size_t)(state->totalLen),
                                  secret, state->secretLimit + XXH_STRIPE_LEN);
}


#define XXH_MIN(x, y) (((x) > (y)) ? (y) : (x))

XXH_PUBLIC_API void
XXH3_generateSecret(void* secretBuffer, const void* customSeed, size_t customSeedSize)
{
    XXH_ASSERT(secretBuffer != NULL);
    if (customSeedSize == 0) {
        memcpy(secretBuffer, XXH3_kSecret, XXH_SECRET_DEFAULT_SIZE);
        return;
    }
    XXH_ASSERT(customSeed != NULL);

    {   size_t const segmentSize = sizeof(XXH128_hash_t);
        size_t const nbSegments = XXH_SECRET_DEFAULT_SIZE / segmentSize;
        XXH128_canonical_t scrambler;
        XXH64_hash_t seeds[12];
        size_t segnb;
        XXH_ASSERT(nbSegments == 12);
        XXH_ASSERT(segmentSize * nbSegments == XXH_SECRET_DEFAULT_SIZE); /* exact multiple */
        XXH128_canonicalFromHash(&scrambler, XXH128(customSeed, customSeedSize, 0));

        /*
        * Copy customSeed to seeds[], truncating or repeating as necessary.
        */
        {   size_t toFill = XXH_MIN(customSeedSize, sizeof(seeds));
            size_t filled = toFill;
            memcpy(seeds, customSeed, toFill);
            while (filled < sizeof(seeds)) {
                toFill = XXH_MIN(filled, sizeof(seeds) - filled);
                memcpy((char*)seeds + filled, seeds, toFill);
                filled += toFill;
        }   }

        /* generate secret */
        memcpy(secretBuffer, &scrambler, sizeof(scrambler));
        for (segnb=1; segnb < nbSegments; segnb++) {
            size_t const segmentStart = segnb * segmentSize;
            XXH128_canonical_t segment;
            XXH128_canonicalFromHash(&segment,
                XXH128(&scrambler, sizeof(scrambler), XXH_readLE64(seeds + segnb) + segnb) );
            memcpy((char*)secretBuffer + segmentStart, &segment, sizeof(segment));
    }   }
}



XXH_FORCE_INLINE XXH128_hash_t
XXH3_len_1to3_128b(const xxh_u8* input, size_t len, const xxh_u8* secret, XXH64_hash_t seed)
{
    /* A doubled version of 1to3_64b with different constants. */
    XXH_ASSERT(input != NULL);
    XXH_ASSERT(1 <= len && len <= 3);
    XXH_ASSERT(secret != NULL);
    /*
     * len = 1: combinedl = { input[0], 0x01, input[0], input[0] }
     * len = 2: combinedl = { input[1], 0x02, input[0], input[1] }
     * len = 3: combinedl = { input[2], 0x03, input[0], input[1] }
     */
    {   xxh_u8 const c1 = input[0];
        xxh_u8 const c2 = input[len >> 1];
        xxh_u8 const c3 = input[len - 1];
        xxh_u32 const combinedl = ((xxh_u32)c1 <<16) | ((xxh_u32)c2 << 24)
                                | ((xxh_u32)c3 << 0) | ((xxh_u32)len << 8);
        xxh_u32 const combinedh = XXH_rotl32(XXH_swap32(combinedl), 13);
        xxh_u64 const bitflipl = (XXH_readLE32(secret) ^ XXH_readLE32(secret+4)) + seed;
        xxh_u64 const bitfliph = (XXH_readLE32(secret+8) ^ XXH_readLE32(secret+12)) - seed;
        xxh_u64 const keyed_lo = (xxh_u64)combinedl ^ bitflipl;
        xxh_u64 const keyed_hi = (xxh_u64)combinedh ^ bitfliph;
        XXH128_hash_t h128;
        h128.low64  = XXH64_avalanche(keyed_lo);
        h128.high64 = XXH64_avalanche(keyed_hi);
        return h128;
    }
}

XXH_FORCE_INLINE XXH128_hash_t
XXH3_len_4to8_128b(const xxh_u8* input, size_t len, const xxh_u8* secret, XXH64_hash_t seed)
{
    XXH_ASSERT(input != NULL);
    XXH_ASSERT(secret != NULL);
    XXH_ASSERT(4 <= len && len <= 8);
    seed ^= (xxh_u64)XXH_swap32((xxh_u32)seed) << 32;
    {   xxh_u32 const input_lo = XXH_readLE32(input);
        xxh_u32 const input_hi = XXH_readLE32(input + len - 4);
        xxh_u64 const input_64 = input_lo + ((xxh_u64)input_hi << 32);
        xxh_u64 const bitflip = (XXH_readLE64(secret+16) ^ XXH_readLE64(secret+24)) + seed;
        xxh_u64 const keyed = input_64 ^ bitflip;

        /* Shift len to the left to ensure it is even, this avoids even multiplies. */
        XXH128_hash_t m128 = XXH_mult64to128(keyed, XXH_PRIME64_1 + (len << 2));

        m128.high64 += (m128.low64 << 1);
        m128.low64  ^= (m128.high64 >> 3);

        m128.low64   = XXH_xorshift64(m128.low64, 35);
        m128.low64  *= 0x9FB21C651E98DF25ULL;
        m128.low64   = XXH_xorshift64(m128.low64, 28);
        m128.high64  = XXH3_avalanche(m128.high64);
        return m128;
    }
}

XXH_FORCE_INLINE XXH128_hash_t
XXH3_len_9to16_128b(const xxh_u8* input, size_t len, const xxh_u8* secret, XXH64_hash_t seed)
{
    XXH_ASSERT(input != NULL);
    XXH_ASSERT(secret != NULL);
    XXH_ASSERT(9 <= len && len <= 16);
    {   xxh_u64 const bitflipl = (XXH_readLE64(secret+32) ^ XXH_readLE64(secret+40)) - seed;
        xxh_u64 const bitfliph = (XXH_readLE64(secret+48) ^ XXH_readLE64(secret+56)) + seed;
        xxh_u64 const input_lo = XXH_readLE64(input);
        xxh_u64       input_hi = XXH_readLE64(input + len - 8);
        XXH128_hash_t m128 = XXH_mult64to128(input_lo ^ input_hi ^ bitflipl, XXH_PRIME64_1);
        /*
         * Put len in the middle of m128 to ensure that the length gets mixed to
         * both the low and high bits in the 128x64 multiply below.
         */
        m128.low64 += (xxh_u64)(len - 1) << 54;
        input_hi   ^= bitfliph;
        /*
         * Add the high 32 bits of input_hi to the high 32 bits of m128, then
         * add the long product of the low 32 bits of input_hi and XXH_PRIME32_2 to
         * the high 64 bits of m128.
         *
         * The best approach to this operation is different on 32-bit and 64-bit.
         */
        if (sizeof(void *) < sizeof(xxh_u64)) { /* 32-bit */
            /*
             * 32-bit optimized version, which is more readable.
             *
             * On 32-bit, it removes an ADC and delays a dependency between the two
             * halves of m128.high64, but it generates an extra mask on 64-bit.
             */
            m128.high64 += (input_hi & 0xFFFFFFFF00000000ULL) + XXH_mult32to64((xxh_u32)input_hi, XXH_PRIME32_2);
        } else {
            m128.high64 += input_hi + XXH_mult32to64((xxh_u32)input_hi, XXH_PRIME32_2 - 1);
        }
        /* m128 ^= XXH_swap64(m128 >> 64); */
        m128.low64  ^= XXH_swap64(m128.high64);

        {   /* 128x64 multiply: h128 = m128 * XXH_PRIME64_2; */
            XXH128_hash_t h128 = XXH_mult64to128(m128.low64, XXH_PRIME64_2);
            h128.high64 += m128.high64 * XXH_PRIME64_2;

            h128.low64   = XXH3_avalanche(h128.low64);
            h128.high64  = XXH3_avalanche(h128.high64);
            return h128;
    }   }
}

/*
 * Assumption: `secret` size is >= XXH3_SECRET_SIZE_MIN
 */
XXH_FORCE_INLINE XXH128_hash_t
XXH3_len_0to16_128b(const xxh_u8* input, size_t len, const xxh_u8* secret, XXH64_hash_t seed)
{
    XXH_ASSERT(len <= 16);
    {   if (len > 8) return XXH3_len_9to16_128b(input, len, secret, seed);
        if (len >= 4) return XXH3_len_4to8_128b(input, len, secret, seed);
        if (len) return XXH3_len_1to3_128b(input, len, secret, seed);
        {   XXH128_hash_t h128;
            xxh_u64 const bitflipl = XXH_readLE64(secret+64) ^ XXH_readLE64(secret+72);
            xxh_u64 const bitfliph = XXH_readLE64(secret+80) ^ XXH_readLE64(secret+88);
            h128.low64 = XXH64_avalanche(seed ^ bitflipl);
            h128.high64 = XXH64_avalanche( seed ^ bitfliph);
            return h128;
    }   }
}

/*
 * A bit slower than XXH3_mix16B, but handles multiply by zero better.
 */
XXH_FORCE_INLINE XXH128_hash_t
XXH128_mix32B(XXH128_hash_t acc, const xxh_u8* input_1, const xxh_u8* input_2,
              const xxh_u8* secret, XXH64_hash_t seed)
{
    acc.low64  += XXH3_mix16B (input_1, secret+0, seed);
    acc.low64  ^= XXH_readLE64(input_2) + XXH_readLE64(input_2 + 8);
    acc.high64 += XXH3_mix16B (input_2, secret+16, seed);
    acc.high64 ^= XXH_readLE64(input_1) + XXH_readLE64(input_1 + 8);
    return acc;
}


XXH_FORCE_INLINE XXH128_hash_t
XXH3_len_17to128_128b(const xxh_u8* XXH_RESTRICT input, size_t len,
                      const xxh_u8* XXH_RESTRICT secret, size_t secretSize,
                      XXH64_hash_t seed)
{
    XXH_ASSERT(secretSize >= XXH3_SECRET_SIZE_MIN); (void)secretSize;
    XXH_ASSERT(16 < len && len <= 128);

    {   XXH128_hash_t acc;
        acc.low64 = len * XXH_PRIME64_1;
        acc.high64 = 0;
        if (len > 32) {
            if (len > 64) {
                if (len > 96) {
                    acc = XXH128_mix32B(acc, input+48, input+len-64, secret+96, seed);
                }
                acc = XXH128_mix32B(acc, input+32, input+len-48, secret+64, seed);
            }
            acc = XXH128_mix32B(acc, input+16, input+len-32, secret+32, seed);
        }
        acc = XXH128_mix32B(acc, input, input+len-16, secret, seed);
        {   XXH128_hash_t h128;
            h128.low64  = acc.low64 + acc.high64;
            h128.high64 = (acc.low64    * XXH_PRIME64_1)
                        + (acc.high64   * XXH_PRIME64_4)
                        + ((len - seed) * XXH_PRIME64_2);
            h128.low64  = XXH3_avalanche(h128.low64);
            h128.high64 = (XXH64_hash_t)0 - XXH3_avalanche(h128.high64);
            return h128;
        }
    }
}

XXH_NO_INLINE XXH128_hash_t
XXH3_len_129to240_128b(const xxh_u8* XXH_RESTRICT input, size_t len,
                       const xxh_u8* XXH_RESTRICT secret, size_t secretSize,
                       XXH64_hash_t seed)
{
    XXH_ASSERT(secretSize >= XXH3_SECRET_SIZE_MIN); (void)secretSize;
    XXH_ASSERT(128 < len && len <= XXH3_MIDSIZE_MAX);

    {   XXH128_hash_t acc;
        int const nbRounds = (int)len / 32;
        int i;
        acc.low64 = len * XXH_PRIME64_1;
        acc.high64 = 0;
        for (i=0; i<4; i++) {
            acc = XXH128_mix32B(acc,
                                input  + (32 * i),
                                input  + (32 * i) + 16,
                                secret + (32 * i),
                                seed);
        }
        acc.low64 = XXH3_avalanche(acc.low64);
        acc.high64 = XXH3_avalanche(acc.high64);
        XXH_ASSERT(nbRounds >= 4);
        for (i=4 ; i < nbRounds; i++) {
            acc = XXH128_mix32B(acc,
                                input + (32 * i),
                                input + (32 * i) + 16,
                                secret + XXH3_MIDSIZE_STARTOFFSET + (32 * (i - 4)),
                                seed);
        }
        /* last bytes */
        acc = XXH128_mix32B(acc,
                            input + len - 16,
                            input + len - 32,
                            secret + XXH3_SECRET_SIZE_MIN - XXH3_MIDSIZE_LASTOFFSET - 16,
                            0ULL - seed);

        {   XXH128_hash_t h128;
            h128.low64  = acc.low64 + acc.high64;
            h128.high64 = (acc.low64    * XXH_PRIME64_1)
                        + (acc.high64   * XXH_PRIME64_4)
                        + ((len - seed) * XXH_PRIME64_2);
            h128.low64  = XXH3_avalanche(h128.low64);
            h128.high64 = (XXH64_hash_t)0 - XXH3_avalanche(h128.high64);
            return h128;
        }
    }
}

XXH_FORCE_INLINE XXH128_hash_t
XXH3_hashLong_128b_internal(const void* XXH_RESTRICT input, size_t len,
                            const xxh_u8* XXH_RESTRICT secret, size_t secretSize,
                            XXH3_f_accumulate_512 f_acc512,
                            XXH3_f_scrambleAcc f_scramble)
{
    XXH_ALIGN(XXH_ACC_ALIGN) xxh_u64 acc[XXH_ACC_NB] = XXH3_INIT_ACC;

    XXH3_hashLong_internal_loop(acc, (const xxh_u8*)input, len, secret, secretSize, f_acc512, f_scramble);

    /* converge into final hash */
    XXH_STATIC_ASSERT(sizeof(acc) == 64);
    XXH_ASSERT(secretSize >= sizeof(acc) + XXH_SECRET_MERGEACCS_START);
    {   XXH128_hash_t h128;
        h128.low64  = XXH3_mergeAccs(acc,
                                     secret + XXH_SECRET_MERGEACCS_START,
                                     (xxh_u64)len * XXH_PRIME64_1);
        h128.high64 = XXH3_mergeAccs(acc,
                                     secret + secretSize
                                            - sizeof(acc) - XXH_SECRET_MERGEACCS_START,
                                     ~((xxh_u64)len * XXH_PRIME64_2));
        return h128;
    }
}

/*
 * It's important for performance that XXH3_hashLong is not inlined.
 */
XXH_NO_INLINE XXH128_hash_t
XXH3_hashLong_128b_default(const void* XXH_RESTRICT input, size_t len,
                           XXH64_hash_t seed64,
                           const void* XXH_RESTRICT secret, size_t secretLen)
{
    (void)seed64; (void)secret; (void)secretLen;
    return XXH3_hashLong_128b_internal(input, len, XXH3_kSecret, sizeof(XXH3_kSecret),
                                       XXH3_accumulate_512, XXH3_scrambleAcc);
}

/*
 * It's important for performance that XXH3_hashLong is not inlined.
 */
XXH_NO_INLINE XXH128_hash_t
XXH3_hashLong_128b_withSecret(const void* XXH_RESTRICT input, size_t len,
                              XXH64_hash_t seed64,
                              const void* XXH_RESTRICT secret, size_t secretLen)
{
    (void)seed64;
    return XXH3_hashLong_128b_internal(input, len, (const xxh_u8*)secret, secretLen,
                                       XXH3_accumulate_512, XXH3_scrambleAcc);
}

XXH_FORCE_INLINE XXH128_hash_t
XXH3_hashLong_128b_withSeed_internal(const void* XXH_RESTRICT input, size_t len,
                                XXH64_hash_t seed64,
                                XXH3_f_accumulate_512 f_acc512,
                                XXH3_f_scrambleAcc f_scramble,
                                XXH3_f_initCustomSecret f_initSec)
{
    if (seed64 == 0)
        return XXH3_hashLong_128b_internal(input, len,
                                           XXH3_kSecret, sizeof(XXH3_kSecret),
                                           f_acc512, f_scramble);
    {   XXH_ALIGN(XXH_SEC_ALIGN) xxh_u8 secret[XXH_SECRET_DEFAULT_SIZE];
        f_initSec(secret, seed64);
        return XXH3_hashLong_128b_internal(input, len, (const xxh_u8*)secret, sizeof(secret),
                                           f_acc512, f_scramble);
    }
}

/*
 * It's important for performance that XXH3_hashLong is not inlined.
 */
XXH_NO_INLINE XXH128_hash_t
XXH3_hashLong_128b_withSeed(const void* input, size_t len,
                            XXH64_hash_t seed64, const void* XXH_RESTRICT secret, size_t secretLen)
{
    (void)secret; (void)secretLen;
    return XXH3_hashLong_128b_withSeed_internal(input, len, seed64,
                XXH3_accumulate_512, XXH3_scrambleAcc, XXH3_initCustomSecret);
}

typedef XXH128_hash_t (*XXH3_hashLong128_f)(const void* XXH_RESTRICT, size_t,
                                            XXH64_hash_t, const void* XXH_RESTRICT, size_t);

XXH_FORCE_INLINE XXH128_hash_t
XXH3_128bits_internal(const void* input, size_t len,
                      XXH64_hash_t seed64, const void* XXH_RESTRICT secret, size_t secretLen,
                      XXH3_hashLong128_f f_hl128)
{
    XXH_ASSERT(secretLen >= XXH3_SECRET_SIZE_MIN);
    /*
     * If an action is to be taken if `secret` conditions are not respected,
     * it should be done here.
     * For now, it's a contract pre-condition.
     * Adding a check and a branch here would cost performance at every hash.
     */
    if (len <= 16)
        return XXH3_len_0to16_128b((const xxh_u8*)input, len, (const xxh_u8*)secret, seed64);
    if (len <= 128)
        return XXH3_len_17to128_128b((const xxh_u8*)input, len, (const xxh_u8*)secret, secretLen, seed64);
    if (len <= XXH3_MIDSIZE_MAX)
        return XXH3_len_129to240_128b((const xxh_u8*)input, len, (const xxh_u8*)secret, secretLen, seed64);
    return f_hl128(input, len, seed64, secret, secretLen);
}


/* ===   Public XXH128 API   === */

XXH_PUBLIC_API XXH128_hash_t XXH3_128bits(const void* input, size_t len)
{
    return XXH3_128bits_internal(input, len, 0,
                                 XXH3_kSecret, sizeof(XXH3_kSecret),
                                 XXH3_hashLong_128b_default);
}

XXH_PUBLIC_API XXH128_hash_t
XXH3_128bits_withSecret(const void* input, size_t len, const void* secret, size_t secretSize)
{
    return XXH3_128bits_internal(input, len, 0,
                                 (const xxh_u8*)secret, secretSize,
                                 XXH3_hashLong_128b_withSecret);
}

XXH_PUBLIC_API XXH128_hash_t
XXH3_128bits_withSeed(const void* input, size_t len, XXH64_hash_t seed)
{
    return XXH3_128bits_internal(input, len, seed,
                                 XXH3_kSecret, sizeof(XXH3_kSecret),
                                 XXH3_hashLong_128b_withSeed);
}

XXH_PUBLIC_API XXH128_hash_t
XXH128(const void* input, size_t len, XXH64_hash_t seed)
{
    return XXH3_128bits_withSeed(input, len, seed);
}


/* ===   XXH3 128-bit streaming   === */

/*
 * All the functions are actually the same as for 64-bit streaming variant.
 * The only difference is the finalizatiom routine.
 */

static void
XXH3_128bits_reset_internal(XXH3_state_t* statePtr,
                            XXH64_hash_t seed,
                            const void* secret, size_t secretSize)
{
    XXH3_64bits_reset_internal(statePtr, seed, secret, secretSize);
}

XXH_PUBLIC_API XXH_errorcode
XXH3_128bits_reset(XXH3_state_t* statePtr)
{
    if (statePtr == NULL) return XXH_ERROR;
    XXH3_128bits_reset_internal(statePtr, 0, XXH3_kSecret, XXH_SECRET_DEFAULT_SIZE);
    return XXH_OK;
}

XXH_PUBLIC_API XXH_errorcode
XXH3_128bits_reset_withSecret(XXH3_state_t* statePtr, const void* secret, size_t secretSize)
{
    if (statePtr == NULL) return XXH_ERROR;
    XXH3_128bits_reset_internal(statePtr, 0, secret, secretSize);
    if (secret == NULL) return XXH_ERROR;
    if (secretSize < XXH3_SECRET_SIZE_MIN) return XXH_ERROR;
    return XXH_OK;
}

XXH_PUBLIC_API XXH_errorcode
XXH3_128bits_reset_withSeed(XXH3_state_t* statePtr, XXH64_hash_t seed)
{
    if (statePtr == NULL) return XXH_ERROR;
    if (seed==0) return XXH3_128bits_reset(statePtr);
    if (seed != statePtr->seed) XXH3_initCustomSecret(statePtr->customSecret, seed);
    XXH3_128bits_reset_internal(statePtr, seed, NULL, XXH_SECRET_DEFAULT_SIZE);
    return XXH_OK;
}

XXH_PUBLIC_API XXH_errorcode
XXH3_128bits_update(XXH3_state_t* state, const void* input, size_t len)
{
    return XXH3_update(state, (const xxh_u8*)input, len,
                       XXH3_accumulate_512, XXH3_scrambleAcc);
}

XXH_PUBLIC_API XXH128_hash_t XXH3_128bits_digest (const XXH3_state_t* state)
{
    const unsigned char* const secret = (state->extSecret == NULL) ? state->customSecret : state->extSecret;
    if (state->totalLen > XXH3_MIDSIZE_MAX) {
        XXH_ALIGN(XXH_ACC_ALIGN) XXH64_hash_t acc[XXH_ACC_NB];
        XXH3_digest_long(acc, state, secret);
        XXH_ASSERT(state->secretLimit + XXH_STRIPE_LEN >= sizeof(acc) + XXH_SECRET_MERGEACCS_START);
        {   XXH128_hash_t h128;
            h128.low64  = XXH3_mergeAccs(acc,
                                         secret + XXH_SECRET_MERGEACCS_START,
                                         (xxh_u64)state->totalLen * XXH_PRIME64_1);
            h128.high64 = XXH3_mergeAccs(acc,
                                         secret + state->secretLimit + XXH_STRIPE_LEN
                                                - sizeof(acc) - XXH_SECRET_MERGEACCS_START,
                                         ~((xxh_u64)state->totalLen * XXH_PRIME64_2));
            return h128;
        }
    }
    /* len <= XXH3_MIDSIZE_MAX : short code */
    if (state->seed)
        return XXH3_128bits_withSeed(state->buffer, (size_t)state->totalLen, state->seed);
    return XXH3_128bits_withSecret(state->buffer, (size_t)(state->totalLen),
                                   secret, state->secretLimit + XXH_STRIPE_LEN);
}

/* 128-bit utility functions */


/* return : 1 is equal, 0 if different */
XXH_PUBLIC_API int XXH128_isEqual(XXH128_hash_t h1, XXH128_hash_t h2)
{
    /* note : XXH128_hash_t is compact, it has no padding byte */
    return !(memcmp(&h1, &h2, sizeof(h1)));
}

/* This prototype is compatible with stdlib's qsort().
 * return : >0 if *h128_1  > *h128_2
 *          <0 if *h128_1  < *h128_2
 *          =0 if *h128_1 == *h128_2  */
XXH_PUBLIC_API int XXH128_cmp(const void* h128_1, const void* h128_2)
{
    XXH128_hash_t const h1 = *(const XXH128_hash_t*)h128_1;
    XXH128_hash_t const h2 = *(const XXH128_hash_t*)h128_2;
    int const hcmp = (h1.high64 > h2.high64) - (h2.high64 > h1.high64);
    /* note : bets that, in most cases, hash values are different */
    if (hcmp) return hcmp;
    return (h1.low64 > h2.low64) - (h2.low64 > h1.low64);
}


/*======   Canonical representation   ======*/
XXH_PUBLIC_API void
XXH128_canonicalFromHash(XXH128_canonical_t* dst, XXH128_hash_t hash)
{
    XXH_STATIC_ASSERT(sizeof(XXH128_canonical_t) == sizeof(XXH128_hash_t));
    if (XXH_CPU_LITTLE_ENDIAN) {
        hash.high64 = XXH_swap64(hash.high64);
        hash.low64  = XXH_swap64(hash.low64);
    }
    memcpy(dst, &hash.high64, sizeof(hash.high64));
    memcpy((char*)dst + sizeof(hash.high64), &hash.low64, sizeof(hash.low64));
}

XXH_PUBLIC_API XXH128_hash_t
XXH128_hashFromCanonical(const XXH128_canonical_t* src)
{
    XXH128_hash_t h;
    h.high64 = XXH_readBE64(src);
    h.low64  = XXH_readBE64(src->digest + 8);
    return h;
}

/* Pop our optimization override from above */
#if XXH_VECTOR == XXH_AVX2 /* AVX2 */ \
  && defined(__GNUC__) && !defined(__clang__) /* GCC, not Clang */ \
  && defined(__OPTIMIZE__) && !defined(__OPTIMIZE_SIZE__) /* respect -O0 and -Os */
#  pragma GCC pop_options
#endif

#endif  /* XXH_NO_LONG_LONG */


#endif  /* XXH_IMPLEMENTATION */













// Handle errors in libzpaq and elsewhere
void libzpaq::error(const char* msg) {
	g_exec_text=msg;
  if (strstr(msg, "ut of memory")) throw std::bad_alloc();
  throw std::runtime_error(msg);
}
using libzpaq::error;

// Portable thread types and functions for Windows and Linux. Use like this:
//
// // Create mutex for locking thread-unsafe code
// Mutex mutex;            // shared by all threads
// init_mutex(mutex);      // initialize in unlocked state
// Semaphore sem(n);       // n >= 0 is initial state
//
// // Declare a thread function
// ThreadReturn thread(void *arg) {  // arg points to in/out parameters
//   lock(mutex);          // wait if another thread has it first
//   release(mutex);       // allow another waiting thread to continue
//   sem.wait();           // wait until n>0, then --n
//   sem.signal();         // ++n to allow waiting threads to continue
//   return 0;             // must return 0 to exit thread
// }
//
// // Start a thread
// ThreadID tid;
// run(tid, thread, &arg); // runs in parallel
// join(tid);              // wait for thread to return
// destroy_mutex(mutex);   // deallocate resources used by mutex
// sem.destroy();          // deallocate resources used by semaphore

#ifdef PTHREAD
typedef void* ThreadReturn;                                // job return type
typedef pthread_t ThreadID;                                // job ID type
void run(ThreadID& tid, ThreadReturn(*f)(void*), void* arg)// start job
  {pthread_create(&tid, NULL, f, arg);}
void join(ThreadID tid) {pthread_join(tid, NULL);}         // wait for job
typedef pthread_mutex_t Mutex;                             // mutex type
void init_mutex(Mutex& m) {pthread_mutex_init(&m, 0);}     // init mutex
void lock(Mutex& m) {pthread_mutex_lock(&m);}              // wait for mutex
void release(Mutex& m) {pthread_mutex_unlock(&m);}         // release mutex
void destroy_mutex(Mutex& m) {pthread_mutex_destroy(&m);}  // destroy mutex

class Semaphore {
public:
  Semaphore() {sem=-1;}
  void init(int n) {
    assert(n>=0);
    assert(sem==-1);
    pthread_cond_init(&cv, 0);
    pthread_mutex_init(&mutex, 0);
    sem=n;
  }
  void destroy() {
    assert(sem>=0);
    pthread_mutex_destroy(&mutex);
    pthread_cond_destroy(&cv);
  }
  int wait() {
    assert(sem>=0);
    pthread_mutex_lock(&mutex);
    int r=0;
    if (sem==0) r=pthread_cond_wait(&cv, &mutex);
    assert(sem>0);
    --sem;
    pthread_mutex_unlock(&mutex);
    return r;
  }
  void signal() {
    assert(sem>=0);
    pthread_mutex_lock(&mutex);
    ++sem;
    pthread_cond_signal(&cv);
    pthread_mutex_unlock(&mutex);
  }
private:
  pthread_cond_t cv;  // to signal FINISHED
  pthread_mutex_t mutex; // protects cv
  int sem;  // semaphore count
};

#else  // Windows
typedef DWORD ThreadReturn;
typedef HANDLE ThreadID;
void run(ThreadID& tid, ThreadReturn(*f)(void*), void* arg) {
  tid=CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)f, arg, 0, NULL);
  if (tid==NULL) error("CreateThread failed");
}
void join(ThreadID& tid) {WaitForSingleObject(tid, INFINITE);}
typedef HANDLE Mutex;
void init_mutex(Mutex& m) {m=CreateMutex(NULL, FALSE, NULL);}
void lock(Mutex& m) {WaitForSingleObject(m, INFINITE);}
void release(Mutex& m) {ReleaseMutex(m);}
void destroy_mutex(Mutex& m) {CloseHandle(m);}

class Semaphore {
public:
  enum {MAXCOUNT=2000000000};
  Semaphore(): h(NULL) {}
  void init(int n) {assert(!h); h=CreateSemaphore(NULL, n, MAXCOUNT, NULL);}
  void destroy() {assert(h); CloseHandle(h);}
  int wait() {assert(h); return WaitForSingleObject(h, INFINITE);}
  void signal() {assert(h); ReleaseSemaphore(h, 1, NULL);}
private:
  HANDLE h;  // Windows semaphore
};

#endif






#ifdef _WIN32
	#ifndef ENABLE_VIRTUAL_TERMINAL_PROCESSING
		#define ENABLE_VIRTUAL_TERMINAL_PROCESSING  0x0004
	#endif

static HANDLE stdoutHandle;
static DWORD outModeInit;
 
void setupConsole(void) 
{
	DWORD outMode 	= 0;
	stdoutHandle 	= GetStdHandle(STD_OUTPUT_HANDLE);
 
	if(stdoutHandle == INVALID_HANDLE_VALUE)
		exit(GetLastError());
	
	if(!GetConsoleMode(stdoutHandle, &outMode))
		exit(GetLastError());
	outModeInit = outMode;
	
	 // Enable ANSI escape codes
	outMode |= ENABLE_VIRTUAL_TERMINAL_PROCESSING;
 
	if(!SetConsoleMode(stdoutHandle, outMode)) 
		exit(GetLastError());
}
 
void restoreConsole(void) 
{
	// Reset colors
	printf("\x1b[0m");	
	
	// Reset console mode
	if(!SetConsoleMode(stdoutHandle, outModeInit)) 
		exit(GetLastError());
}
#else // Houston, we have Unix
void setupConsole(void) 
{
}

void restoreConsole(void) 
{
	//colors
	printf("\x1b[0m");
}
#endif






int terminalwidth() 
{
#if defined(_WIN32)
    CONSOLE_SCREEN_BUFFER_INFO csbi;
    GetConsoleScreenBufferInfo(GetStdHandle(STD_OUTPUT_HANDLE), &csbi);
    return (int) csbi.srWindow.Right - csbi.srWindow.Left + 1;
   /// return (int)(csbi.dwSize.X);
#else
    struct winsize w;
    ioctl(fileno(stdout), TIOCGWINSZ, &w);
    return (int)(w.ws_col);
#endif 
}
int terminalheight()
{
#if defined(_WIN32)
    CONSOLE_SCREEN_BUFFER_INFO csbi;
    GetConsoleScreenBufferInfo(GetStdHandle(STD_OUTPUT_HANDLE), &csbi);
//    return (int)(csbi.dwSize.Y);
	return (int)csbi.srWindow.Bottom - csbi.srWindow.Top + 1;
#else
    struct winsize w;
    ioctl(fileno(stdout), TIOCGWINSZ, &w);
    return (int)(w.ws_row);
#endif 
}

int mygetch(bool i_flagmore)
{
	int mychar=0;
#if defined(_WIN32)
	mychar=getch();
#endif


#ifdef unix
/// BSD Unix
	struct termios oldt, newt;
	tcgetattr ( STDIN_FILENO, &oldt );
	newt = oldt;
	newt.c_lflag &= ~( ICANON | ECHO );
	tcsetattr ( STDIN_FILENO, TCSANOW, &newt );
	mychar = getchar();
	tcsetattr ( STDIN_FILENO, TCSANOW, &oldt );
#endif

	if (!i_flagmore)
		return mychar;

	if ((mychar==113) || (mychar==81) || (mychar==3))  /// q, Q, control-C
	{
#ifdef unix
		printf("\n\n");
#endif
		exit(0);
	}
	return mychar;

}


void printbar(char i_carattere,bool i_printbarraenne=true)
{
	int twidth=terminalwidth();
	if (twidth<10)
		twidth=100;
		
	for (int i=0;i<twidth-4;i++)
		printf("%c",i_carattere);
	if (i_printbarraenne)
		printf("\n");
}

///	print text just like |more
void moreprint(const char* i_stringa)
{
	/// warn: if redirected or piped widths can become <0
	
	int larghezzaconsole=terminalwidth()-2;
	int altezzaconsole=terminalheight();
	static int righestampate=0;
	
	if (!i_stringa)
		return;
		
	if ((larghezzaconsole<0) || (altezzaconsole<0))
	{
		printf("%s\n",i_stringa);
		return;
	}

	if (!strcmp(i_stringa,"\n"))
	{
		printf("\n");
		righestampate++;
		if (righestampate>(altezzaconsole-2))
		{
			printf("-- More (q, Q or control C to exit) --\r");
			mygetch(true);
			for (int i=0;i<altezzaconsole;i++)
				printf("\n");
			righestampate=0;
		}
		return;
	}
	int lunghezzastringa=strlen(i_stringa);
	
	if (!larghezzaconsole)
		return;

	int righe	=(lunghezzastringa/larghezzaconsole)+1;
	int massimo	=lunghezzastringa-(larghezzaconsole*(righe-1));
	
	for (int riga=1; riga<=righe;riga++)
	{
		int currentmax=larghezzaconsole;
		
		if (riga==righe)
			currentmax=massimo;

		int startcarattere=(riga-1)*larghezzaconsole;
		
		for (int i=startcarattere;i<startcarattere+currentmax;i++)
			printf("%c",i_stringa[i]);
		printf("\n");
		
		righestampate++;
		if (righestampate>(altezzaconsole-2))
		{
			printf("-- More (q, Q or control C to exit) --\r");
			mygetch(true);
			for (int i=0;i<altezzaconsole;i++)
				printf("\n");
			righestampate=0;
		}
	}
}
void morebar(const char i_carattere)
{
	int twidth=terminalwidth();
	if (twidth<10)
		twidth=100; // redirect
	if (twidth>100)
		twidth=100;
	
	char barbuffer[100+10];
	for (int i=0;i<twidth-4;i++)
		sprintf(barbuffer+i,"%c",i_carattere);
	moreprint(barbuffer);
}











////////// support functions

void myprintf(const char *fmt, ...)
{
	/// printf() on g_output_handle too
	char buffer[4096];
	va_list args;
    va_start(args, fmt);
    vsnprintf(buffer,sizeof(buffer),fmt,args);	
    printf("%s",buffer);
	if (g_output_handle!=0)
		fprintf(g_output_handle,"%s",buffer);
   va_end(args);
}

bool getcaptcha(const string i_captcha,const string i_reason)
{
	if (i_captcha=="")
		return false;
	if (i_reason=="")
		return false;
	printf("\nTo confirm a dangerous command\n");
	printf(">>> %s\n",i_reason.c_str());
	printf("enter EXACTLY the capcha, then press CR (return)\n");
	printf("Entering anything else will quit.\n");
	printf("\nCaptcha to continue:     %s\n",i_captcha.c_str());
	char myline[81];
    int dummy=scanf("%80s", myline);
	if (dummy==888888)	// compiler be quiet!
		printf("no-warning-please\n");
	if (myline!=i_captcha)
	{
		printf("Wrong captcha\n");
		return false;
	}
	printf("Captcha OK\n");
	return true;
}

  
// In Windows, convert 16-bit wide string to UTF-8 and \ to /
#ifdef _WIN32
bool windows7_or_above=false; //windows version (for using FindFirstFileExW)

string wtou(const wchar_t* s) {
  assert(sizeof(wchar_t)==2);  // Not true in Linux
  assert((wchar_t)(-1)==65535);
  string r;
  if (!s) return r;
  for (; *s; ++s) {
    if (*s=='\\') r+='/';
    else if (*s<128) r+=*s;
    else if (*s<2048) r+=192+*s/64, r+=128+*s%64;
    else r+=224+*s/4096, r+=128+*s/64%64, r+=128+*s%64;
  }
  return r;
}

// In Windows, convert UTF-8 string to wide string ignoring
// invalid UTF-8 or >64K. Convert "/" to slash (default "\").
std::wstring utow(const char* ss, char slash='\\') {
  assert(sizeof(wchar_t)==2);
  assert((wchar_t)(-1)==65535);
  std::wstring r;
  if (!ss) return r;
  const unsigned char* s=(const unsigned char*)ss;
  for (; s && *s; ++s) {
    if (s[0]=='/') r+=slash;
    else if (s[0]<128) r+=s[0];
    else if (s[0]>=192 && s[0]<224 && s[1]>=128 && s[1]<192)
      r+=(s[0]-192)*64+s[1]-128, ++s;
    else if (s[0]>=224 && s[0]<240 && s[1]>=128 && s[1]<192
             && s[2]>=128 && s[2]<192)
      r+=(s[0]-224)*4096+(s[1]-128)*64+s[2]-128, s+=2;
  }
  return r;
}
#endif



/////////////	case insensitive compare

char* stristr(const char* str1,const char* str2)
{
    const char* p1 = str1;
    const char* p2 = str2;
    const char* r = *p2 == 0 ? str1 : 0 ;

    while((*p1!=0) && (*p2!=0))
    {
        if( tolower((unsigned char)*p1)==tolower((unsigned char)*p2))
        {
            if(r==0)
                r=p1;
            p2++;
        }
        else
        {
            p2=str2;
            if(r!=0)
                p1=r+1;

            if(tolower((unsigned char)*p1)==tolower((unsigned char)*p2))
            {
                r=p1;
                p2++;
            }
            else
                r=0;
        }
        p1++;
    }

    return *p2 == 0 ? (char*)r : 0 ;
}
bool isdirectory(string i_filename)
{
	if (i_filename.length()==0)
		return false;
	else
	return
		i_filename[i_filename.size()-1]=='/';
}
bool havedoublequote(string i_filename)
{
	if (i_filename.length()==0)
		return false;
	else
	return
		i_filename[i_filename.size()-1]=='"';
}
string cutdoublequote(const string& i_string)
{
#ifdef ESX
	return "";
#else
	string temp=i_string;
	if (havedoublequote(i_string))
		temp.pop_back();
	return temp;
#endif
}

bool isextension(const char* i_filename,const char* i_ext)
{
	if (!i_filename)
		return false;
	if (!i_ext)
		return false;
	if (isdirectory(i_filename))
		return false;

	char * posizione=stristr(i_filename, i_ext);
	if (!posizione)
		return false;
	/*
	printf("Strlen filename %d\n",strlen(i_filename));
	printf("Strlen i_ext    %d\n",strlen(i_ext));
	printf("Delta  %d\n",posizione-i_filename);
	*/
	return (posizione-i_filename)+strlen(i_ext)==strlen(i_filename);
}
bool iszpaq(string i_filename)
{
	return isextension(i_filename.c_str(), ".zpaq");
}
bool isxls(string i_filename)
{
	return (isextension(i_filename.c_str(), ".xls") || isextension(i_filename.c_str(), ".ppt") || isextension(i_filename.c_str(), ".pps"));
}
bool isads(string i_filename)
{
	if (i_filename.length()==0)
		return false;
	else
		return strstr(i_filename.c_str(), ":$DATA")!=0;  
}
bool iszfs(string i_filename)
{
	if (i_filename.length()==0)
		return false;
	else
		return strstr(i_filename.c_str(), ".zfs")!=0;  
}


bool replace(std::string& str, const std::string& from, const std::string& to) {
    size_t start_pos = str.find(from);
    if(start_pos == std::string::npos)
        return false;
    str.replace(start_pos, from.length(), to);
    return true;
}

/*
string myreplacealli(string s,string a,string b)
{
   std::string lower_s;
   std::transform(s.begin(), s.end(), lower_s.begin(), ::tolower);
   std::transform(a.begin(), a.end(), a.begin(), ::tolower);
   auto position=lower_s.find(a);
   while(position!=std::string::npos){
        s.replace(position, a.size(), b);
        position=lower_s.find(a);
   }
   return s;
}
*/
void myreplaceall(std::string& str, const std::string& from, const std::string& to) {
    if(from.empty())
        return;
    size_t start_pos = 0;
    while((start_pos = str.find(from, start_pos)) != std::string::npos) {
        str.replace(start_pos, from.length(), to);
        start_pos += to.length(); // In case 'to' contains 'from', like replacing 'x' with 'yx'
    }
}

string format_datetime(string i_formato,tm* t=NULL)
{
	char	temp[10];
	if (t==NULL)
	{
		time_t now=time(NULL);
		t=localtime(&now);
	}
	sprintf(temp,"%02d",t->tm_hour);
	string hour=temp;
	
	sprintf(temp,"%02d",t->tm_min);
	string min=temp;
	
	sprintf(temp,"%02d",t->tm_sec);
	string sec=temp;
	
	sprintf(temp,"%d",t->tm_wday);
	string weekday=temp;
	
	sprintf(temp,"%04d",t->tm_year+1900);
	string	year=temp;
	
	sprintf(temp,"%02d",t->tm_mon+1);
	string month=temp;
	
	sprintf(temp,"%02d",t->tm_mday);
	string day=temp;
	
	sprintf(temp,"%02d",(t->tm_yday-t->tm_wday+7)/7);
	string	week=temp;
	
	string date=year+'-'+month+'-'+day;
	string time=hour+'-'+min+'-'+sec;
	string datetime=date+'_'+time;
	
	
	myreplaceall(i_formato,"$hour",hour);
	myreplaceall(i_formato,"$min",min);
	myreplaceall(i_formato,"$sec",sec);
	myreplaceall(i_formato,"$weekday",weekday);
	myreplaceall(i_formato,"$year",year);
	myreplaceall(i_formato,"$month",month);
	myreplaceall(i_formato,"$day",day);
	myreplaceall(i_formato,"$week",week);
	myreplaceall(i_formato,"$date",date);
	myreplaceall(i_formato,"$time",time);
	myreplaceall(i_formato,"$datetime",datetime);
	return i_formato;
}

bool myreplace(string& i_str, const string& i_from, const string& i_to) 
{
    size_t start_pos = i_str.find(i_from);
    if(start_pos == std::string::npos)
        return false;
    i_str.replace(start_pos, i_from.length(), i_to);
    return true;
}
int mypos(const string& i_substring,const string& i_string) 
{
    size_t start_pos = i_string.find(i_substring);
    if	(start_pos==std::string::npos)
        return -1;
	else
		return start_pos;
}




std::string myright(std::string const& source, size_t const length) 
{
  if (length >= source.size()) 
 	return source;

  return source.substr(source.size() - length);
} 
std::string myleft(std::string const& source, size_t const length) 
{
  if (length >= source.size()) 
 	return source;

  return source.substr(0,length);
} 

string mytrim(const string& i_str)
{
	size_t first = i_str.find_first_not_of(' ');
	if (string::npos == first)
		return i_str;
	size_t last = i_str.find_last_not_of(' ');
	return i_str.substr(first, (last - first + 1));
}

void explode(string i_string,char i_delimiter,vector<string>& array)
{
	unsigned int i=0;
	while(i<i_string.size())
	{
		string temp="";
		while ((i_string[i]!=i_delimiter) && (i<i_string.size()))
        {
			temp+=i_string[i];
			i++;
		}
		array.push_back(temp);
		i++;
		if (i>=i_string.size())
			break;
    }
}

struct s_fileandsize
{
	string	filename;
	uint64_t size;
	int64_t attr;
	int64_t date;
	int64_t data;          	// sort key or frags written. -1 = do not write
	
	bool 	isdir;
	string 	hashhex;
	string 	hashtype;
	bool 	flaghashstored;
	string	writtenfilename;
	bool	hashok;
	bool	filenotfound;
	s_fileandsize(): size(0),attr(0),date(0),data(-1),isdir(false),flaghashstored(false),hashok(false),filenotfound(false) {filename="";hashhex="";hashtype="";writtenfilename="";}
};


//// cut a too long filename 
string mymaxfile(string i_filename,const unsigned int i_lunghezza)
{
	if (i_filename=="")
		return "";
	if (i_lunghezza==0)
		return "";
	if (i_filename.length()<=i_lunghezza)
		return i_filename;
	
	if (i_lunghezza>10)
	{
		if (i_filename.length()>10)
		{
			unsigned int intestazione=i_lunghezza-10;
			return i_filename.substr(0,intestazione)+"(...)"+i_filename.substr(i_filename.length()-5,5);
		}
		else
		return i_filename.substr(0,i_lunghezza);
			
	}
	else
		return i_filename.substr(0,i_lunghezza);
}

/// OK we need a fix for 64-byte-align problem on some Linux compiler

/*
https://github.com/embeddedartistry/embedded-resources/blob/master/examples/c/malloc_aligned.c
*/

#ifndef align_up
#define align_up(num, align) \
	(((num) + ((align) - 1)) & ~((align) - 1))
#endif

//Convenience macro for memalign, the linux API
#define memalign(align, size) aligned_malloc(align, size)

//Number of bytes we're using for storing the aligned pointer offset
typedef uint16_t myoffset_t;
#define PTR_OFFSET_SZ sizeof(myoffset_t)

/**
* aligned_malloc takes in the requested alignment and size
*	We will call malloc with extra bytes for our header and the offset
*	required to guarantee the desired alignment.
*/
void * aligned_malloc(size_t align, size_t size)
{
	void * ptr = NULL;

	//We want it to be a power of two since align_up operates on powers of two
	assert((align & (align - 1)) == 0);

	if(align && size)
	{
		/*
		 * We know we have to fit an offset value
		 * We also allocate extra bytes to ensure we can meet the alignment
		 */
		uint32_t hdr_size = PTR_OFFSET_SZ + (align - 1);
		void * p = malloc(size + hdr_size);

		if(p)
		{
			/*
			 * Add the offset size to malloc's pointer (we will always store that)
			 * Then align the resulting value to the arget alignment
			 */
			ptr = (void *) align_up(((uintptr_t)p + PTR_OFFSET_SZ), align);

			//Calculate the offset and store it behind our aligned pointer
			*((myoffset_t *)ptr - 1) = (myoffset_t)((uintptr_t)ptr - (uintptr_t)p);

		} // else NULL, could not malloc
	} //else NULL, invalid arguments

	return ptr;
}

/**
* aligned_free works like free(), but we work backwards from the returned
* pointer to find the correct offset and pointer location to return to free()
* Note that it is VERY BAD to call free() on an aligned_malloc() pointer.
*/
void aligned_free(void * ptr)
{
	assert(ptr);

	/*
	* Walk backwards from the passed-in pointer to get the pointer offset
	* We convert to an offset_t pointer and rely on pointer math to get the data
	*/
	myoffset_t offset = *((myoffset_t *)ptr - 1);

	/*
	* Once we have the offset, we can get our original pointer and call free
	*/
	void * p = (void *)((uint8_t *)ptr - offset);
	free(p);
}







//////// Some functions to deal with UTF-8 on Windows
#ifdef _WIN32
	uint32_t convert_unicode_to_ansi_string(std::string& ansi,const wchar_t* unicode,const size_t unicode_size) 
	{
		uint32_t error = 0;
		do 
		{
			if ((nullptr == unicode) || (0 == unicode_size)) 
			{
				error = ERROR_INVALID_PARAMETER;
				break;
			}
			ansi.clear();
			int required_cch=::WideCharToMultiByte(
									CP_ACP,
									0,
									unicode, static_cast<int>(unicode_size),
									nullptr, 0,
									nullptr, nullptr
									);

			if (required_cch==0) 
			{
				error=::GetLastError();
				break;
			}
			ansi.resize(required_cch);
			if (0 == ::WideCharToMultiByte(
						CP_ACP,
						0,
						unicode, static_cast<int>(unicode_size),
						const_cast<char*>(ansi.c_str()), static_cast<int>(ansi.size()),
						nullptr, nullptr
						)) 
			{
				error =::GetLastError();
				break;
			}
		} 
		while (false);

		return error;
	}

	uint32_t convert_utf8_to_unicode_string(std::wstring& unicode,const char* utf8,const size_t utf8_size)
	{
		uint32_t error = 0;
		do 
		{
			if ((nullptr == utf8) || (0 == utf8_size)) 
			{
				error = ERROR_INVALID_PARAMETER;
				break;
			}
			unicode.clear();
			int required_cch = ::MultiByteToWideChar(
				CP_UTF8,
				MB_ERR_INVALID_CHARS,
				utf8, static_cast<int>(utf8_size),
				nullptr, 0
			);
			if (required_cch==0) 
			{
				error = ::GetLastError();
				break;
			}
			unicode.resize(required_cch);
			if (0 == ::MultiByteToWideChar(
						CP_UTF8,
						MB_ERR_INVALID_CHARS,
						utf8, static_cast<int>(utf8_size),
						const_cast<wchar_t*>(unicode.c_str()), static_cast<int>(unicode.size())
						)) 
			{
				error=::GetLastError();
				break;
			}
		} 
		while (false);

		return error;
	}
// Windows: double converison
	std::string utf8toansi(const std::string & utf8)
	{
		std::wstring unicode = L"";
		convert_utf8_to_unicode_string(unicode, utf8.c_str(), utf8.size());
		std::string ansi = "";
		convert_unicode_to_ansi_string(ansi, unicode.c_str(), unicode.size());
		return ansi;
	}

#else

/// Unix & Linux

	std::string utf8toansi(const std::string & utf8)
	{
		return utf8;
	}

#endif


//// trim left, right, and left-right
const std::string WHITESPACE = " \n\r\t\f\v";
 
std::string myltrim(const std::string &s)
{
    size_t start = s.find_first_not_of(WHITESPACE);
    return (start == std::string::npos) ? "" : s.substr(start);
}
 
std::string myrtrim(const std::string &s)
{
    size_t end = s.find_last_not_of(WHITESPACE);
    return (end == std::string::npos) ? "" : s.substr(0, end + 1);
}
 
std::string mytrim2(const std::string &s) 
{
    return myrtrim(myltrim(s));
}

//// functions "a-la-Delphi"
string extractfilename(const string& i_string) 
{
	size_t i = i_string.rfind('/', i_string.length());
	if (i != string::npos) 
		return(i_string.substr(i+1, i_string.length() - i));
	return(i_string);
}
string prendiestensione(const string& s) 
{
	if (isdirectory(s))
		return ("");
	string nomefile=extractfilename(s);
	size_t i = nomefile.rfind('.', nomefile.length());
	if (i != string::npos) 
	{
		int lunghezzaestensione=nomefile.length() - i;
/// sometimes it is hard to get the extension: pippo.plutopaperino
		if (lunghezzaestensione>20)
			return("");
		return(nomefile.substr(i+1, lunghezzaestensione));
	}
   return("");
}

string extractfilepath(const string& i_string) 
{
	size_t i = i_string.rfind('/', i_string.length());
	if (i != string::npos) 
		return(i_string.substr(0, i+1));
	return("");
}
string prendinomefileebasta(const string& s) 
{
	string nomefile=extractfilename(s);
	size_t i = nomefile.rfind('.', nomefile.length());
	if (i != string::npos) 
		return(nomefile.substr(0,i));
	return(nomefile);
}


// Return the part of fn up to the last slash
string path(const string& fn) 
{
	int n=0;
	for (int i=0; fn[i]; ++i)
	if (fn[i]=='/' || fn[i]=='\\') 
		n=i+1;
	return fn.substr(0, n);
}

/// iterative find of filename

string padleft(std::string str, const size_t num, const char paddingChar = ' ')
{
    if(num > str.size())
	{
        string tmpstring=str;
		tmpstring.insert(0, num - tmpstring.size(), paddingChar);
		return tmpstring;
	}
	else
		return("");
}

//// sanitixe filenames
string purgeansi(string i_string,bool i_keeppath=false)
{
	if (i_string=="")
		return ("");

	string purged;
	for (unsigned int i=0;i<i_string.length();i++)
	{
		if (i_keeppath)
		{
			if ((i_string[i]==':') || (i_string[i]=='/') || (i_string[i]=='\\'))
			{
				purged+=i_string[i];
				continue;
			}
		}
		if (isalnum(i_string[i]))
			purged+=i_string[i];
		else
		{
			switch (i_string[i]) 
			{
/*
very forbiden
< (less than)
> (greater than)
: (colon)
" (double quote)
/ (forward slash)
\ (backslash)
| (vertical bar or pipe)
? (question mark)
* (asterisk)
*/


				case ' ':
				case '-':
				case '#':
				case '~':
				case '%':
				case '^':
				case '_':
				case '.':
				case '+':
				case '=':
				purged+=i_string[i];
				break;

				case '&':
				purged+="_and_";
				break;

				case ',':
				case '`':
//				case '!':
				case '@':
				case '$':
				case '*':
	///			case '\\':
				case '|':
				case ':':
				case ';':
				case '"':
				case '\'':
				case '<':
				case '>':
	///			case '/':
				case '\n':
				case '\r':
				case '\t':
				purged+='_';
				break;

				case '(':
	///			case '[':
				case '{':
				purged+='(';
				break;

				case ')':
		///		case ']':
				case '}':
				purged+=')';
				break;
			}
		}
	}

	return purged;
}
/// heuristic strange-charset to latin
string forcelatinansi(string i_string)
{
	if (i_string=="")
		return ("");

	for (unsigned int j=0;j<i_string.length();j++)
	{
		if (i_string[j]<0)
		{
			if (i_string[j]==-1) // 
			i_string[j]='u';
				else
				if (i_string[j]==-2) // 
					i_string[j]='u';
				else
				if (i_string[j]==-3) // 
					i_string[j]='u';
				else
				if (i_string[j]==-4) // 
					i_string[j]='u';
				else
				if (i_string[j]==-5) // 
					i_string[j]='u';
				else
				if (i_string[j]==-6) // 
					i_string[j]='u';
				else
				if (i_string[j]==-7) // 
					i_string[j]='u';
				else
				if (i_string[j]==-8) // 
					i_string[j]='o';
				else
				if (i_string[j]==-9) // 
					i_string[j]='o';
				else
				if (i_string[j]==-10) //
					i_string[j]='o';
				else
				if (i_string[j]==-11) //
					i_string[j]='o';
				else
				if (i_string[j]==-12) //
					i_string[j]='o';
				else
				if (i_string[j]==-13) //
					i_string[j]='o';
				else
				if (i_string[j]==-14) //
					i_string[j]='o';
				else
				if (i_string[j]==-15) //
					i_string[j]='o';
				else
				if (i_string[j]==-17) //
					i_string[j]='i';
				else
				if (i_string[j]==-18) //
					i_string[j]='i';
				else
				if (i_string[j]==-19) //
					i_string[j]='i';
				else
				if (i_string[j]==-20) //
					i_string[j]='i';
				else
				if (i_string[j]==-21) //
					i_string[j]='e';
				else
				if (i_string[j]==-22) //
					i_string[j]='e';
				else
				if (i_string[j]==-23) //
					i_string[j]='e';
				else
				if (i_string[j]==-24) //
					i_string[j]='e';
				else
				if (i_string[j]==-25) //
					i_string[j]='a';
				else
				if (i_string[j]==-26) //
					i_string[j]='a';
				else
				if (i_string[j]==-27) //a
					i_string[j]='a';
				else
				if (i_string[j]==-28) //a
					i_string[j]='a';
				else
				if (i_string[j]==-29) //a
					i_string[j]='a';
				else
				if (i_string[j]==-30) //a
					i_string[j]='e';
				else
				if (i_string[j]==-31) //a
					i_string[j]='a';
				else
				if (i_string[j]==-32) //a
					i_string[j]='a';
				else
				if (i_string[j]==-33) //a
					i_string[j]='u';
				else
				if (i_string[j]==-34) //a
					i_string[j]='u';
				else
				if (i_string[j]==-35) //a
					i_string[j]='u';
				else
				if (i_string[j]==-36) //a
					i_string[j]='u';
				else
				if (i_string[j]==-37) //a
					i_string[j]='u';
				else
				if (i_string[j]==-38) //a
					i_string[j]='u';
				else
				if (i_string[j]==-39) //a
					i_string[j]='U';
				else
				if (i_string[j]==-40) //a
					i_string[j]='O';
				else
				if (i_string[j]==-41) //a
					i_string[j]='x';
				else
				if (i_string[j]==-42) //
					i_string[j]='O';
				else
				if (i_string[j]==-45) //
					i_string[j]='O';
				else
				if (i_string[j]==-46) //
					i_string[j]='O';
				else
				if (i_string[j]==-47) //
					i_string[j]='N';
				else
				if (i_string[j]==-49) //
					i_string[j]='I';
				else
				if (i_string[j]==-50) //
					i_string[j]='I';
				else
				if (i_string[j]==-51) //
					i_string[j]='I';
				else
				if (i_string[j]==-52) //
					i_string[j]='I';
				else
				if (i_string[j]==-53) //
					i_string[j]='E';
				else
				if (i_string[j]==-54) //
					i_string[j]='E';
				else
				if (i_string[j]==-55) //
					i_string[j]='E';
				else
				if (i_string[j]==-56) //
					i_string[j]='E';
				else
				if (i_string[j]==-57) //
					i_string[j]='E';
				else		
				if (i_string[j]==-60) //
					i_string[j]='A';
				else
				if (i_string[j]==-61) //
					i_string[j]='A';
				else
				if (i_string[j]==-62) //
					i_string[j]='A';
				else
				if (i_string[j]==-63) //
					i_string[j]='A';
				else
				if (i_string[j]==-64) //
					i_string[j]='A';
				else
				if (i_string[j]==-66) //
					i_string[j]='3';
				else
				if (i_string[j]==-68) //
					i_string[j]='3';
				else
				if (i_string[j]==-69) //
					i_string[j]='>';
				else
				if (i_string[j]==-70) //
					i_string[j]='o';
				else
				if (i_string[j]==-72) //
					i_string[j]='.';
				else
				if (i_string[j]==-74) //
					i_string[j]=' ';
				else
				if (i_string[j]==-75) //
					i_string[j]=' ';
				else
				if (i_string[j]==-76) //
					i_string[j]=' ';
				else
				if (i_string[j]==-78) //
					i_string[j]='2';
				else
				if (i_string[j]==-80) // 
					i_string[j]='o';
				else
				if (i_string[j]==-81) // 
					i_string[j]='-';
				else
				if (i_string[j]==-82) // 
					i_string[j]='-';
				else
				if (i_string[j]==-83) // 
					i_string[j]='-';
				else
				if (i_string[j]==-84) // 
					i_string[j]='-';
				else
				if (i_string[j]==-85) // 
					i_string[j]='<';
				else
				if (i_string[j]==-89) // 
					i_string[j]='S';
				else
				if (i_string[j]==-90) // 
					i_string[j]=' ';
				else
				if (i_string[j]==-93) // 
					i_string[j]=' ';
				else
				if (i_string[j]==-94) // 
					i_string[j]=' ';
				else
				if (i_string[j]==-95) // 
					i_string[j]=' ';
				else
				if (i_string[j]==-96) // 
					i_string[j]=' ';
				else
				if (i_string[j]==-98) // 
					i_string[j]=' ';
				else
				if (i_string[j]==-102) //-
					i_string[j]='s';
				else
				if (i_string[j]==-103) //-
					i_string[j]='a';
				else
				if (i_string[j]==-106) //-
					i_string[j]='-';
				else
				if (i_string[j]==-107) //-
					i_string[j]='.';
				else
				if (i_string[j]==-108) //-
					i_string[j]='"';
				else
				if (i_string[j]==-109) //-
					i_string[j]='"';
				else
				if (i_string[j]==-110) //-
					i_string[j]=' ';
				else
				if (i_string[j]==-111) //-
					i_string[j]=' ';
				else
				if (i_string[j]==-112) //-
					i_string[j]=' ';
				else
				if (i_string[j]==-112) //-
					i_string[j]=' ';
				else
				if (i_string[j]==-113) //-
					i_string[j]=' ';
				else
				if (i_string[j]==-114) //-
					i_string[j]=' ';
				else
				if (i_string[j]==-115)//-
					i_string[j]=' ';
				else
				if (i_string[j]==-116) //-
					i_string[j]=' ';
				else
				if (i_string[j]==-118) //-
					i_string[j]='S';
				else
				if (i_string[j]==-123) //-
					i_string[j]='d';
				else
				if (i_string[j]==-128) //-
					i_string[j]='E';
				else
					i_string[j]=' ';
			
			
		}
	}
		
	return i_string;
}

string purgedouble(const string& i_string,const string& i_from,const string& i_to)
{
	if (i_string=="")
		return("");
	if (i_from=="")
		return("");
	if (i_to=="")
		return("");
	string purged=i_string;
	myreplaceall(purged,i_from,i_to);
	return purged;
}
///	"dedup-compress" long .eml filenames (ex. thunderbird .eml)
string compressemlfilename(const string& i_string)
{
	if (i_string=="")
		return("");
	string uniqfilename=extractfilename(i_string);
	string percorso=extractfilepath(i_string);
		
	for (int k=0;k<10;k++)
		uniqfilename=purgedouble(uniqfilename,"  "," ");

	for (int k=0;k<10;k++)
		uniqfilename=purgedouble(uniqfilename,"..",".");

	for (int k=0;k<10;k++)
		uniqfilename=purgedouble(uniqfilename,"Fw ","Fwd ");
	
	for (int k=0;k<10;k++)
		uniqfilename=purgedouble(uniqfilename,"Fwd Fwd ","Fwd ");

	for (int k=0;k<10;k++)
		uniqfilename=purgedouble(uniqfilename," R "," Re ");

	for (int k=0;k<10;k++)
		uniqfilename=purgedouble(uniqfilename,"R Fwd ","Re Fwd");
	
	for (int k=0;k<10;k++)
		uniqfilename=purgedouble(uniqfilename," RE "," Re ");
	
	for (int k=0;k<10;k++)
		uniqfilename=purgedouble(uniqfilename,"Re Re ","Re ");

	for (int k=0;k<10;k++)
		uniqfilename=purgedouble(uniqfilename,"Fwd Re Fwd Re ","Fwd Re ");

	for (int k=0;k<10;k++)
		uniqfilename=purgedouble(uniqfilename,"Re Fwd Re Fwd ","Re Fwd ");

	for (int k=0;k<10;k++)
		uniqfilename=purgedouble(uniqfilename," SV SV "," SV ");

	for (int k=0;k<10;k++)
		uniqfilename=purgedouble(uniqfilename,"Fwd FW ","Fwd ");

	for (int k=0;k<10;k++)
		uniqfilename=purgedouble(uniqfilename,"Fwd I ","Fwd ");
	
	for (int k=0;k<10;k++)
		uniqfilename=purgedouble(uniqfilename,"I Fwd ","Fwd ");

	for (int k=0;k<10;k++)
			uniqfilename=purgedouble(uniqfilename,"R Re ","Re ");

	for (int k=0;k<10;k++)
		uniqfilename=purgedouble(uniqfilename,"__","_");

	for (int k=0;k<10;k++)
	uniqfilename=purgedouble(uniqfilename," _ ","_");

	for (int k=0;k<10;k++)
		uniqfilename=purgedouble(uniqfilename,"  "," ");
#ifndef ESX
	for (int k=uniqfilename.length()-1;k>0;k--)
	{
		if ((uniqfilename[k]=='-') || (uniqfilename[k]=='.') || (uniqfilename[k]==' '))
		{
			uniqfilename.pop_back();
		}
		else
		{
			break;
		}
	}
#endif
	uniqfilename=mytrim2(uniqfilename);
	
	uniqfilename=percorso+uniqfilename;
	
	return uniqfilename;
}

void print_datetime(void)
{
	int hours, minutes, seconds, day, month, year;

	time_t now;
	time(&now);
	struct tm *local = localtime(&now);

	hours = local->tm_hour;			// get hours since midnight	(0-23)
	minutes = local->tm_min;		// get minutes passed after the hour (0-59)
	seconds = local->tm_sec;		// get seconds passed after the minute (0-59)

	day = local->tm_mday;			// get day of month (1 to 31)
	month = local->tm_mon + 1;		// get month of year (0 to 11)
	year = local->tm_year + 1900;	// get year since 1900

	printf("%02d/%02d/%d %02d:%02d:%02d ", day, month, year, hours,minutes,seconds);
}


// Print a UTF-8 string to f (stdout, stderr) so it displays properly
void printUTF8(const char* s, FILE* f=stdout) 
{
	assert(f);
	assert(s);

	/// output on g_output_handle too (-output somefile)
	if (g_output_handle!=0)
		fprintf(g_output_handle,"%s",s);

#ifdef unix
  fprintf(f, "%s", s);
#else
  const HANDLE h=(HANDLE)_get_osfhandle(_fileno(f));
  DWORD ft=GetFileType(h);
  if (ft==FILE_TYPE_CHAR) {
    fflush(f);
    std::wstring w=utow(s, '/');  // Windows console: convert to UTF-16
    DWORD n=0;
    WriteConsole(h, w.c_str(), w.size(), &n, 0);
  }
  else  // stdout redirected to file
    fprintf(f, "%s", s);
#endif
}

/// We want to read the damn UTF8 files. 
/// In the case of Windows using the function for UTF16, after conversion

FILE* freadopen(const char* i_filename)
{
#ifdef _WIN32
	wstring widename=utow(i_filename);
	FILE* myfp=_wfopen(widename.c_str(), L"rb" );
#else
	FILE* myfp=fopen(i_filename, "rb" );
#endif
	if (myfp==NULL)
	{
		if (flagdebug)
		{
			printf( "\nfreadopen cannot open:");
			printUTF8(i_filename);
			printf("\n");
		}
		return 0;
	}
	return myfp;
}

int64_t prendidimensionehandle(FILE* i_handle)
{
	if (i_handle==0)
		return 0;
	fseeko(i_handle, 0, SEEK_END);
	int64_t dimensione=ftello(i_handle);
	fseeko(i_handle, 0, SEEK_SET);
	return dimensione;	
}

int64_t prendidimensionefile(const char* i_filename)
{
	if (!i_filename)
		return 0;
	FILE* myfile = freadopen(i_filename);
	if (myfile)
    {
		fseeko(myfile, 0, SEEK_END);
		int64_t dimensione=ftello(myfile);
		fclose(myfile);
		return dimensione;
	}
	else
	return 0;
}


bool islonguncpath(string i_filename)
{
	if (i_filename.size()<8)
		return false;
	if (i_filename[0]=='/')
	if (i_filename[1]=='/')
	if (i_filename[2]=='?')
	if (i_filename[3]=='/')
	if (toupper(i_filename[4])=='U')
	if (toupper(i_filename[5])=='N')
	if (toupper(i_filename[6])=='C')
	if (i_filename[7]=='/')
		return true;
	
	return false;
}
bool islongpath(string i_filename)
{
	if (i_filename.size()<8)
		return false;
	if (i_filename[0]=='/')
	if (i_filename[1]=='/')
	if (i_filename[2]=='?')
	if (i_filename[3]=='/')
	if (isalpha(i_filename[4]))
	if (i_filename[5]==':')
	if (i_filename[6]=='/')
		return true;
	
	return false;
}


//// some support functions to string compare case insensitive
bool comparechar(char c1, char c2)
{
    if (c1 == c2)
        return true;
    else if (std::toupper(c1) == std::toupper(c2))
        return true;
    return false;
}


string stringtolower(string i_stringa)
{
#ifndef ESX
	/*macos*/
	std::for_each(i_stringa.begin(), i_stringa.end(), [](char & c)
	{
		c = ::tolower(c);	
	});
#endif
	return i_stringa;

}			
string stringtoupper(string i_stringa)
{
	/*macos */
#ifndef ESX	
std::for_each(i_stringa.begin(), i_stringa.end(), [](char & c)
	{
		c = ::toupper(c);	
	});
#endif
	return i_stringa;

	
}			

int myposi(string i_substring,string i_string) 
{
	// not very quick...
	i_substring=stringtolower(i_substring);
	i_string=stringtolower(i_string);
	
    size_t start_pos = i_string.find(i_substring);
    if	(start_pos==std::string::npos)
        return -1;
	else
		return start_pos;
}


/*
bool isxls(string i_stringa)
{
	return (stringtolower(prendiestensione(i_filename))=="xls");
}
	*/							
bool stringcomparei(std::string str1, std::string str2)
{
    return ( (str1.size() == str2.size() ) &&
             std::equal(str1.begin(), str1.end(), str2.begin(), &comparechar) );
}

/// very quick and very dirty output
inline char *  migliaia(uint64_t n)
{
	static char retbuf[30];
	char *p = &retbuf[sizeof(retbuf)-1];
	unsigned int i = 0;
	*p = '\0';
	do 
	{
		if(i%3 == 0 && i != 0)
			*--p = '.';
		*--p = '0' + n % 10;
		n /= 10;
		i++;
		} while(n != 0);
	return p;
}
inline char *  migliaia2(uint64_t n)
{
	static char retbuf[30];
	char *p = &retbuf[sizeof(retbuf)-1];
	unsigned int i = 0;
	*p = '\0';
	do 
	{
		if(i%3 == 0 && i != 0)
			*--p = '.';
		*--p = '0' + n % 10;
		n /= 10;
		i++;
		} while(n != 0);
	return p;
}
inline char *  migliaia3(uint64_t n)
{
	static char retbuf[30];
	char *p = &retbuf[sizeof(retbuf)-1];
	unsigned int i = 0;
	*p = '\0';
	do 
	{
		if(i%3 == 0 && i != 0)
			*--p = '.';
		*--p = '0' + n % 10;
		n /= 10;
		i++;
		} while(n != 0);
	return p;
}
inline char *  migliaia4(uint64_t n)
{
	static char retbuf[30];
	char *p = &retbuf[sizeof(retbuf)-1];
	unsigned int i = 0;
	*p = '\0';
	do 
	{
		if(i%3 == 0 && i != 0)
			*--p = '.';
		*--p = '0' + n % 10;
		n /= 10;
		i++;
		} while(n != 0);
	return p;
}
inline char *  migliaia5(uint64_t n)
{
	static char retbuf[30];
	char *p = &retbuf[sizeof(retbuf)-1];
	unsigned int i = 0;
	*p = '\0';
	do 
	{
		if(i%3 == 0 && i != 0)
			*--p = '.';
		*--p = '0' + n % 10;
		n /= 10;
		i++;
		} while(n != 0);
	return p;
}

string timetohuman(int32_t i_seconds)
{
	if (i_seconds<=0)
		return "00:00:00";
	int h=(i_seconds/3600); 
	int m=(i_seconds -(3600*h))/60;
	int s=(i_seconds -(3600*h)-(m*60));
	char	temporaneo[20];
	sprintf(temporaneo,"%03d:%02d:%02d",h,m,s);
	return temporaneo;
}

/// quick and ugly
inline char* tohuman(uint64_t i_bytes)
{
	static char io_buf[30];
	
	char const *myappend[] = {"B","KB","MB","GB","TB","PB"};
	char length = sizeof(myappend)/sizeof(myappend[0]);
	double mybytes=i_bytes;
	int i=0;
	if (i_bytes > 1024) 
		for (i=0;(i_bytes / 1024) > 0 && i<length-1; i++, i_bytes /= 1024)
			mybytes = i_bytes / 1024.0;
	sprintf(io_buf, "%.02lf %s",mybytes,myappend[i]);
	return io_buf;
}
inline char* tohuman2(uint64_t i_bytes)
{
	static char io_buf[30];
	
	char const *myappend[] = {"B","KB","MB","GB","TB","PB"};
	char length = sizeof(myappend)/sizeof(myappend[0]);
	double mybytes=i_bytes;
	int i=0;
	if (i_bytes > 1024) 
		for (i=0;(i_bytes / 1024) > 0 && i<length-1; i++, i_bytes /= 1024)
			mybytes = i_bytes / 1024.0;
	sprintf(io_buf, "%.02lf %s",mybytes,myappend[i]);
	return io_buf;
}
inline char* tohuman3(uint64_t i_bytes)
{
	static char io_buf[30];
	
	char const *myappend[] = {"B","KB","MB","GB","TB","PB"};
	char length = sizeof(myappend)/sizeof(myappend[0]);
	double mybytes=i_bytes;
	int i=0;
	if (i_bytes > 1024) 
		for (i=0;(i_bytes / 1024) > 0 && i<length-1; i++, i_bytes /= 1024)
			mybytes = i_bytes / 1024.0;
	sprintf(io_buf, "%.02lf %s",mybytes,myappend[i]);
	return io_buf;
}
inline char* tohuman4(uint64_t i_bytes)
{
	static char io_buf[30];
	
	char const *myappend[] = {"B","KB","MB","GB","TB","PB"};
	char length = sizeof(myappend)/sizeof(myappend[0]);
	double mybytes=i_bytes;
	int i=0;
	if (i_bytes > 1024) 
		for (i=0;(i_bytes / 1024) > 0 && i<length-1; i++, i_bytes /= 1024)
			mybytes = i_bytes / 1024.0;
	sprintf(io_buf, "%.02lf %s",mybytes,myappend[i]);
	return io_buf;
}


//// rather robust 14 digits to strings (ignore non digits)
int64_t encodestringdate(string i_date)
{
#ifdef ESX

	return 0;
#else

	string purged;
	for (unsigned int i=0;i<i_date.length();i++)
		if (isdigit(i_date[i]))
			purged+=i_date[i];
	
	if (purged.length()!=14)
	{
		printf("106: datelength !=14\n");
		return -1;
	}
	for (int i=0;i<=13;i++)
		if (!isdigit(purged[i]))
		{
			printf("107: date[%d] not idigit\n",i);
			return -1;
		}
		
	int year=std::stoi(purged.substr(0,4));
	int month=std::stoi(purged.substr(4,2));
	int day=std::stoi(purged.substr(6,2));
	
	int hour=std::stoi(purged.substr(8,2));
	int minute=std::stoi(purged.substr(10,2));
	int second=std::stoi(purged.substr(12,2));
	if (flagdebug)
		printf("14669: date   %04d-%02d-%02d %02d:%02d:%02d\n",year,month,day,hour,minute,second);
	if ((year<1970) || (year>2070))
	{
		printf("108: year not from 1970 to 2070\n");
		return -1;
	}
	if ((month<1) || (month>12))
	{
		printf("136: month not in 1 to 12\n");
		return -1;
	}
	if ((day<1) || (day>31))
	{
		printf("141: day not in 1 to 31\n");
		return -1;
	}
	
	if (hour>24)
	{
		printf("147: hour >24\n");
		return -1;
	}
	if (minute>60)
	{
		printf("152: minute >60\n");
		return -1;
	}	
	if (second>60)
	{
		printf("157: second >60\n");
		return -1;
	}	
		
	bool isleap= (((year % 4 == 0) &&
         (year % 100 != 0)) ||
         (year % 400 == 0));
		

    if (month == 2)
    {
        if (isleap)
		{
			if (!(day <=29))
			{
				printf("180: leap year, feb must be <=29\n");
				return -1;
			}
		}
        else
			if (!(day <=28))
			{
				printf("187: NO leap year, feb must be <=28\n");
				return -1;
			}
    }
 
    if ((month==4) || (month==6) || (month==9) || (month==11))
		if (!(day <= 30))
		{
			printf("195: month cannot have more than 30 days\n");
			return -1;
		}
	return year*10000000000LL
		+month*100000000LL //mese
		+day*1000000				// giorno
	  
		+hour*10000 // ore
		+minute*100	// minuti
		+second;		// secondi
#endif
}




// Convert non-negative decimal number x to string of at least n digits
string itos(int64_t x, int n=1) {
  assert(x>=0);
  assert(n>=0);
  string r;
  for (; x || n>0; x/=10, --n) r=string(1, '0'+x%10)+r;
  return r;
}

// Replace * and ? in fn with part or digits of part
string subpart(string fn, int part) {
  for (int j=fn.size()-1; j>=0; --j) {
    if (fn[j]=='?')
      fn[j]='0'+part%10, part/=10;
    else if (fn[j]=='*')
      fn=fn.substr(0, j)+itos(part)+fn.substr(j+1), part=0;
  }
  return fn;
}




// Return relative time in milliseconds
int64_t mtime() 
{
#ifdef unix
  timeval tv;
  gettimeofday(&tv, 0);
  return tv.tv_sec*1000LL+tv.tv_usec/1000;
#else
  int64_t t=GetTickCount();
  if (t<g_start) t+=0x100000000LL;
  return t;
#endif
}

#ifdef unix
#include <sys/times.h>
#include <time.h>
#endif

/// Slow, working on string instead of char *. But who cares?
string ConvertUtcToLocalTime(const string i_date)
{
	if (flagdebug)
		printf("\n20006: converting to localtime %s\n",i_date.c_str());
#ifdef _WIN32
	struct tm t;
	memset(&t,0,sizeof(t));
	t.tm_year 	= atoi(i_date.c_str())-1900;
	t.tm_mon 	= atoi(i_date.c_str()+5)-1;
	t.tm_mday 	= atoi(i_date.c_str()+8);
	t.tm_hour 	= atoi(i_date.c_str()+11);
	t.tm_min 	= atoi(i_date.c_str()+14);
	t.tm_sec 	= atoi(i_date.c_str()+17);
#ifdef _WIN64
	time_t tt = _mkgmtime64(&t);
#else
	time_t tt = _mkgmtime32(&t);
#endif
	if(tt != -1)
	{
		struct tm* t2=NULL;
		t2 = &t; 
		*t2 = *localtime(&tt);
		char ds[24];
		memset(ds, 0, 24);
		sprintf(ds, "%.4d-%.2d-%.2d %.2d:%.2d:%.2d", t2->tm_year + 1900,
		  t2->tm_mon + 1, t2->tm_mday, t2->tm_hour, t2->tm_min,
		  t2->tm_sec);
		if (flagdebug)
			printf("20028: localtime is %s\n",ds);
		return ds;
	}
#else
	return i_date;

#endif

	return "";
}


// Convert 64 bit decimal YYYYMMDDHHMMSS to "YYYY-MM-DD HH:MM:SS"
// where -1 = unknown date, 0 = deleted.
string dateToString(int64_t date,bool i_mylocal=false) 
{
  if (date<=0) return "                   ";
  string s="0000-00-00 00:00:00";
  static const int t[]={18,17,15,14,12,11,9,8,6,5,3,2,1,0};
  for (int i=0; i<14; ++i) s[t[i]]+=int(date%10), date/=10;
  
  if (!flagutc)
		s=ConvertUtcToLocalTime(s);

  if (i_mylocal)
  {
	///string "0000-00-00 00:00:00";
		///	0123 56 89 12345
	char mylocal[30];
	mylocal[ 0]=s.at(8);
	mylocal[ 1]=s.at( 9);
	mylocal[ 2]='/';
	mylocal[ 3]=s.at( 5);
	mylocal[ 4]=s.at( 6);
	mylocal[ 5]='/';
	mylocal[ 6]=s.at( 0);
	mylocal[ 7]=s.at( 1);
	mylocal[ 8]=s.at( 2);
	mylocal[ 9]=s.at( 3);
	mylocal[10]=' ';
	mylocal[11]=' ';
	mylocal[12]=s.at(11);
	mylocal[13]=s.at(12);
	mylocal[14]=s.at(13);
	mylocal[15]=s.at(14);
	mylocal[16]=s.at(15);
	mylocal[17]=0;
	s=mylocal;
	
  }
  return s;
	
}

// Convert attributes to a readable format
string attrToString(int64_t attrib) {
  string r="     ";
  if ((attrib&255)=='u') {
    r[0]="0pc3d5b7 9lBsDEF"[(attrib>>20)&15];
    for (int i=0; i<4; ++i)
      r[4-i]=(attrib>>(8+3*i))%8+'0';
  }
  else if ((attrib&255)=='w') {
    for (int i=0, j=0; i<32; ++i) {
      if ((attrib>>(i+8))&1) {
        char c="RHS DAdFTprCoIEivs89012345678901"[i];
        if (j<5) r[j]=c;
        else r+=c;
        ++j;
      }
    }
  }
  return r;
}

// Convert seconds since 0000 1/1/1970 to 64 bit decimal YYYYMMDDHHMMSS
// Valid from 1970 to 2099.
int64_t decimal_time(time_t tt) {
  if (tt==-1) tt=0;
  int64_t t=(sizeof(tt)==4) ? unsigned(tt) : tt;
  const int second=t%60;
  const int minute=t/60%60;
  const int hour=t/3600%24;
  t/=86400;  // days since Jan 1 1970
  const int term=t/1461;  // 4 year terms since 1970
  t%=1461;
  t+=(t>=59);  // insert Feb 29 on non leap years
  t+=(t>=425);
  t+=(t>=1157);
  const int year=term*4+t/366+1970;  // actual year
  t%=366;
  t+=(t>=60)*2;  // make Feb. 31 days
  t+=(t>=123);   // insert Apr 31
  t+=(t>=185);   // insert June 31
  t+=(t>=278);   // insert Sept 31
  t+=(t>=340);   // insert Nov 31
  const int month=t/31+1;
  const int day=t%31+1;
  return year*10000000000LL+month*100000000+day*1000000
         +hour*10000+minute*100+second;
}

// Convert decimal date to time_t - inverse of decimal_time()
time_t unix_time(int64_t date) {
  if (date<=0) return -1;
  static const int days[12]={0,31,59,90,120,151,181,212,243,273,304,334};
  const int year=date/10000000000LL%10000;
  const int month=(date/100000000%100-1)%12;
  const int day=date/1000000%100;
  const int hour=date/10000%100;
  const int min=date/100%100;
  const int sec=date%100;
  return (day-1+days[month]+(year%4==0 && month>1)+((year-1970)*1461+1)/4)
    *86400+hour*3600+min*60+sec;
}


/*
	error section
*/
long long fsbtoblk(int64_t num, uint64_t fsbs, u_long bs)
{
	return (num * (intmax_t) fsbs / (int64_t) bs);
}


bool iswindowspath(const string& i_filename)
{
	if (i_filename.size()>3)
	{
		if (isalpha(i_filename[0]))
			if (i_filename[1]==':')
				if ((i_filename[2]=='\\') || (i_filename[2]=='/')) 
					return true;
	}
	return false;
}


bool iswindowsunc(const string& i_filename)
{
	if (i_filename=="")
			return false;
///	printf("31887: test of %s\n",i_filename.c_str());
	if (i_filename[0]!='/')
			return false;
	if (i_filename[1]!='/')
			return false;
		
	bool	foundslash=false;
	for (unsigned int i=3;i<i_filename.size();i++)
	{
		if (i_filename[i]=='/')
		{
			foundslash=true;
			break;
		}
	}
	/*
	if (foundslash)
		printf("Found slash %s\n",i_filename.c_str());
	else
		printf("NO Windows UNC %s\n",i_filename.c_str());
	*/
	return foundslash;
}

string getfirstwindowsuncdir(const string& i_filename)
{
	if (i_filename=="")
			return "";
	if (i_filename[0]!='/')
			return "";
	if (i_filename[1]!='/')
			return "";
	string	theserver="";
	string 	theshare="";
	string 	firstshare="";
	for (unsigned int i=3;i<i_filename.size();i++)
		if (i_filename[i]=='/')
		{
			theserver=i_filename.substr(0,i+1);
			theshare=i_filename.substr(i+1,i_filename.size());
			break;
		}
	for (unsigned int i=0;i<theshare.size();i++)
		if (theshare[i]=='/')
		{
			firstshare=theshare.substr(0,i);
			break;
		}
	return theserver+firstshare;
}


bool direxists(string i_directory) 
{
#ifdef unix
	struct stat sb;
    return ((stat(i_directory.c_str(), &sb) == 0) && S_ISDIR(sb.st_mode)); 	
#endif

#ifdef _WIN32
	HANDLE	myhandle;
	WIN32_FIND_DATA findfiledata;
	if (!isdirectory(i_directory))
		i_directory+="/";
	std::string pattern=i_directory+"*.*";
	std::wstring wpattern=utow(pattern.c_str());
	myhandle=FindFirstFile(wpattern.c_str(),&findfiledata);
	if (myhandle!=INVALID_HANDLE_VALUE)
	{
		FindClose(myhandle);
		return true;
	}
	return false;
#endif

	return false;
}
string	trimbarra(string i_path)
{
	if (isdirectory(i_path))
		return i_path.substr(0, i_path.size()-1);
	return i_path;
}
///		some windows' functions does not work with longpath
string	makeshortpath(string i_path)
{
	if (islongpath(i_path))
		return myright(i_path,i_path.size()-4);
	return i_path;
}	
string makelongpath(string i_path)
{
#ifdef _WIN32
	if (flaglongpath)
		if (iswindowspath(i_path))
			if (!islongpath(i_path))
				return "//?/"+i_path;
#endif
	return i_path;
}
/// it is not easy, at all, to take *nix free filesystem space
int64_t getfreespace(string i_path)
{
#ifdef BSD
	struct statfs stat;
 
	if (statfs(i_path.c_str(), &stat) != 0) 
	{
		// error happens, just quits here
		return 0;
	}
///	long long used = stat.f_blocks - stat.f_bfree;
///	long long availblks = stat.f_bavail + used;

	static long blocksize = 0;
	int dummy;

	if (blocksize == 0)
		getbsize(&dummy, &blocksize);
	return  fsbtoblk(stat.f_bavail,
	stat.f_bsize, blocksize)*1024;
#else
#ifdef unix //this sould be Linux
	return 0;
#else
	uint64_t spazio=0;
	
	i_path=makeshortpath(i_path);
	
	if (iswindowsunc(i_path))
	{
		string mydir=getfirstwindowsuncdir(i_path);
		i_path=mydir;
	}
	
	BOOL  fResult;
	unsigned __int64 i64FreeBytesToCaller,i64TotalBytes,i64FreeBytes;
	WCHAR  *pszDrive  = NULL, szDrive[4];

	const size_t WCHARBUF = 512;
	wchar_t  wszDest[WCHARBUF];
	MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, i_path.c_str(), -1, wszDest, WCHARBUF);

	pszDrive = wszDest;
	
	if (i_path[1] == ':')
	{
		szDrive[0] = pszDrive[0];
		szDrive[1] = ':';
        szDrive[2] = '\\';
        szDrive[3] = '\0';
		pszDrive = szDrive;
	}
	
	fResult = GetDiskFreeSpaceEx ((LPCTSTR)pszDrive,
                                 (PULARGE_INTEGER)&i64FreeBytesToCaller,
                                 (PULARGE_INTEGER)&i64TotalBytes,
                                 (PULARGE_INTEGER)&i64FreeBytes);
	if (fResult)
		spazio=i64FreeBytes;
	return spazio; // Windows
#endif

#endif
}



#ifdef unix
// Print last error message
void printerr(const char* i_where,const char* filename,int32_t i_fileattr) 
{
	string lasterror=i_where;
	string lasterror2=filename;
	string risultato=lasterror+":"+lasterror2;
	perror(risultato.c_str());
}

#else


string decodewinattribute(int32_t i_attribute)
{
	string risultato="";
	if (i_attribute & FILE_ATTRIBUTE_ARCHIVE)
		risultato+="ARCHIVE;";
		
	if (i_attribute & FILE_ATTRIBUTE_COMPRESSED)
		risultato+="COMPRESSED;";
	
	if (i_attribute & FILE_ATTRIBUTE_DEVICE)
		risultato+="DEVICE;";

	if (i_attribute & FILE_ATTRIBUTE_DIRECTORY)
		risultato+="DIRECTORY;";
	
	if (i_attribute & FILE_ATTRIBUTE_ENCRYPTED)
		risultato+="ENCRYPTED;";

	if (i_attribute & FILE_ATTRIBUTE_HIDDEN)
		risultato+="HIDDEN;";
		
	if (i_attribute & 32768)
		risultato+="INTEGRITY_STREAM;";

	if (i_attribute & FILE_ATTRIBUTE_NORMAL)
		risultato+="NORMAL;";
	
	if (i_attribute & FILE_ATTRIBUTE_NOT_CONTENT_INDEXED)
		risultato+="NOT_CONTENT_INDEXED;";

	if (i_attribute & 131072)
		risultato+="NO_SCRUB_DATA;";

	if (i_attribute & FILE_ATTRIBUTE_OFFLINE)
		risultato+="OFFLINE;";

	if (i_attribute & FILE_ATTRIBUTE_READONLY)
		risultato+="READONY;";

	if (i_attribute & 4194304 )
		risultato+="RECALL_ON_DATA_ACCESS;";
	
	if (i_attribute & 262144 )
		risultato+="RECALL_ON_OPEN;";

	if (i_attribute & FILE_ATTRIBUTE_REPARSE_POINT)
		risultato+="REPARSE_POINT;";

	if (i_attribute & FILE_ATTRIBUTE_SPARSE_FILE)
		risultato+="SPARSE_FILE;";
	
	if (i_attribute & FILE_ATTRIBUTE_SYSTEM)
		risultato+="SYSTEM;";
		
	if (i_attribute & FILE_ATTRIBUTE_TEMPORARY)
		risultato+="TEMPORARY;";
	
	if (i_attribute & FILE_ATTRIBUTE_VIRTUAL)
		risultato+="VIRTUAL;";
	return risultato;
	
}

string	decodewinerror(int	i_error,const char* i_filename)
{
	string risultato="";
	
	char buffer[100];
	
	if (i_error==ERROR_PATH_NOT_FOUND)
	{
		risultato="path not found";
		if (i_filename)
			if (strlen(i_filename)>255)
			{
				sprintf(buffer,"%08d",(int)strlen(i_filename));
				string lunghezza=buffer;
				risultato+=" : maybe length "+lunghezza+" >255?";
				g_255++;
			}
	}
	else if (i_error==ERROR_FILE_NOT_FOUND)
		risultato="file not found";
	else if (i_error==ERROR_ACCESS_DENIED)
		risultato="access denied";
	else if (i_error==ERROR_SHARING_VIOLATION)
		risultato="sharing violation";
	else if (i_error==ERROR_BAD_PATHNAME)
		risultato="bad pathname";
	else if (i_error==ERROR_INVALID_NAME)
		risultato="invalid name";
	else if (i_error==ERROR_NETNAME_DELETED)
		risultato="network name KO";
	else if (i_error==ERROR_ALREADY_EXISTS)
		risultato="file already exists";
	else if (i_error==1920)
		risultato="ERROR_CANT_ACCESS_FILE";
	else
	{
		sprintf(buffer,"Windows error # %d\n",i_error);
		risultato=buffer;
	}
	if (risultato!="")
		while (risultato.size()<25)
				risultato+=" ";
	return risultato;
	
}

void	enumerateerrors()
{
	if (g_errors.size()==0)
	{
		printf("20650: no file errors tracked\n");
		return;
	}
	printf("\nFile errors report\n");
	for (MAPPAERRORS::iterator p=g_errors.begin(); p!=g_errors.end(); p++)
	{
		printf("Error %08d # %8s |%s| \n",p->first,migliaia(p->second.counter),decodewinerror(p->first,NULL).c_str());
		if (flagdebug)
		{
			for (unsigned int i=0;i<p->second.filenames.size();i++)
			{
				printUTF8(p->second.filenames[i].c_str());
				printf(">>\n");
				printf("%08X %s\n",p->second.attrs[i],decodewinattribute(p->second.attrs[i]).c_str());
			}
			printbar('-');
		}
	}
}
// Print last error message
void printerr(const char* i_where,const char* filename,int32_t i_fileattr) 
{
	int err=GetLastError();
							
	MAPPAERRORS::iterator a=g_errors.find(err);
	if (a!=g_errors.end())
	{
		a->second.counter++;
		if (filename)
		{
			a->second.filenames.push_back(filename);
			a->second.attrs.push_back(i_fileattr);
		}
	}
	else
	{
		s_error myblock;
		myblock.counter=1;
		if (filename)
		{
			myblock.filenames.push_back(filename);
			myblock.attrs.push_back(i_fileattr);
		}
		g_errors.insert(std::pair<int,s_error>(err,myblock));
	}

	
	string swhere=i_where;
	
	g_exec_text=swhere+": "+decodewinerror(err,filename);
	printf("\n%s ",g_exec_text.c_str());
	printUTF8(filename);
	printf("\n");
	
	g_exec_text=g_exec_text+" "+filename;
	
	if (filename)
	{
		uint64_t spazio=getfreespace(filename);
		if (spazio<16384)
		{
			string mypath=filename;
			if (direxists(mypath))
				printf("\n\nMAYBE OUT OF FREE SPACE? %s\n",i_where);
			else
				printf("\n\nMAYBE OUT OF FREE SPACE OR INVALID PATH? %s\n",i_where);
		}
	}
}

#endif

// Print file open error and throw exception
void ioerr(const char* msg) 
{
  printerr("11896",msg,0);
  throw std::runtime_error(msg);
}



/*

	File-funtions section
*/


// Windows/Linux compatible file type
#ifdef unix
typedef FILE* FP;
const FP FPNULL=NULL;
const char* const RB="rb";
const char* const WB="wb";
const char* const RBPLUS="rb+";
#else // Windows
typedef HANDLE FP;
const FP FPNULL=INVALID_HANDLE_VALUE;
typedef enum {RB, WB, RBPLUS, WBPLUS} MODE;  // fopen modes


	

// Open file. Only modes "rb", "wb", "rb+" and "wb+" are supported.
FP fopen(const char* filename, MODE mode) 
{
  assert(filename);
  DWORD access=0;
  if (mode!=WB) access=GENERIC_READ;
  if (mode!=RB) access|=GENERIC_WRITE;
  DWORD disp=OPEN_ALWAYS;  // wb or wb+
  if (mode==RB || mode==RBPLUS) disp=OPEN_EXISTING;
  DWORD share=FILE_SHARE_READ;
  if (mode==RB) share|=FILE_SHARE_WRITE|FILE_SHARE_DELETE;

///	kludge: we are doing a "C:" backup, bypass ACLS
    
	if (command=='q')
		return CreateFile(utow(filename).c_str(), access, share,
                    NULL, disp, FILE_FLAG_BACKUP_SEMANTICS, NULL);
	
  return CreateFile(utow(filename).c_str(), access, share,
                    NULL, disp, FILE_ATTRIBUTE_NORMAL, NULL);
}

// Close file
int fclose(FP fp) 
{
  return CloseHandle(fp) ? 0 : EOF;
}

// Read nobj objects of size size into ptr. Return number of objects read.
size_t fread(void* ptr, size_t size, size_t nobj, FP fp) {
  DWORD r=0;
  ReadFile(fp, ptr, size*nobj, &r, NULL);
  if (size>1) r/=size;
  return r;
}

// Write nobj objects of size size from ptr to fp. Return number written.
size_t fwrite(const void* ptr, size_t size, size_t nobj, FP fp) {
  DWORD r=0;
  WriteFile(fp, ptr, size*nobj, &r, NULL);
  ///printf("UOOOOO %s\n",migliaia(r));	  
  /// quick-and-dirty check (media full)
  g_fexpected+=(size*nobj);
  g_fwritten+=r;
  if (flagdebug)
		if ((size*nobj)!=r)
			printf("20277: expected bytes != written (media full?)  %s vs  %s\n",migliaia(size*nobj),migliaia2(r));
  if (size>1) r/=size;
  return r;
}

// Move file pointer by offset. origin is SEEK_SET (from start), SEEK_CUR,
// (from current position), or SEEK_END (from end).
int fseeko(FP fp, int64_t offset, int origin) {
  if (origin==SEEK_SET) origin=FILE_BEGIN;
  else if (origin==SEEK_CUR) origin=FILE_CURRENT;
  else if (origin==SEEK_END) origin=FILE_END;
  LONG h=uint64_t(offset)>>32;
  SetFilePointer(fp, offset&0xffffffffull, &h, origin);
  return GetLastError()!=NO_ERROR;
}

// Get file position
int64_t ftello(FP fp) {
  LONG h=0;
  DWORD r=SetFilePointer(fp, 0, &h, FILE_CURRENT);
  return r+(uint64_t(h)<<32);
}

#endif



bool fileexists(const string& i_filename) 
{
#ifdef unix
// true even for dirs no S_ISDIR
  struct stat buffer;   
  return (stat(i_filename.c_str(),&buffer)==0); 
#endif

#ifdef _WIN32
	HANDLE	myhandle;
	WIN32_FIND_DATA findfiledata;
	std::wstring wpattern=utow(i_filename.c_str());
	myhandle=FindFirstFile(wpattern.c_str(),&findfiledata);
	if (myhandle!=INVALID_HANDLE_VALUE)
	{
		FindClose(myhandle);
		return true;
	}
	return false;
#endif

	return false;
}

// a bit different: check only for "real" files
bool realfileexists(const string& i_filename) 
{
#ifdef unix
  struct stat buffer;   
  
  if (stat(i_filename.c_str(),&buffer)==0)
	if (!S_ISDIR(buffer.st_mode))
		return true;
#endif

#ifdef _WIN32
	HANDLE	myhandle;
	WIN32_FIND_DATA findfiledata;
	std::wstring wpattern=utow(i_filename.c_str());
	myhandle=FindFirstFile(wpattern.c_str(),&findfiledata);
	if (myhandle!=INVALID_HANDLE_VALUE)
	{
		FindClose(myhandle);
		if (findfiledata.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
			return false;
		else
			return true;
	}
#endif

	return false;
}

/// return size, date and attr
bool getfileinfo(string i_filename,int64_t& o_size,int64_t& o_date,int64_t& o_attr)
{
	o_size=0;
	o_date=0;
	o_attr=0;
#ifdef unix
	while (i_filename.size()>1 && i_filename[i_filename.size()-1]=='/')
		i_filename=i_filename.substr(0, i_filename.size()-1);  
	struct stat sb;
	if (!lstat(i_filename.c_str(), &sb)) 
	{
		if (S_ISREG(sb.st_mode))
		{
			
			o_date=decimal_time(sb.st_mtime);
			o_size=sb.st_size;
			o_attr='u'+(sb.st_mode<<8);
			return true;
		}
	}
#endif
	
#ifdef _WIN32
	WIN32_FIND_DATA ffd;
	string t=i_filename;
	if (t.size()>0 && t[t.size()-1]=='/') 
		t+="*";
  
	HANDLE h=FindFirstFile(utow(t.c_str()).c_str(), &ffd);
	if (h==INVALID_HANDLE_VALUE && GetLastError()!=ERROR_FILE_NOT_FOUND && GetLastError()!=ERROR_PATH_NOT_FOUND)
		printerr("29617",t.c_str(),0);
	
	if (h!=INVALID_HANDLE_VALUE) 
	{
		SYSTEMTIME st;
		if (FileTimeToSystemTime(&ffd.ftLastWriteTime, &st))
			o_date=st.wYear*10000000000LL+st.wMonth*100000000LL+st.wDay*1000000
				+st.wHour*10000+st.wMinute*100+st.wSecond;
		o_size=ffd.nFileSizeLow+(int64_t(ffd.nFileSizeHigh)<<32);
		o_attr=ffd.dwFileAttributes;
		FindClose(h);
		return true;
    }
	FindClose(h);
#endif
	return false;
}

// Delete a file, return true if successful
bool delete_file(const char* filename) {
#ifdef unix
	return remove(filename)==0;
#else

	if (!fileexists(filename))
		return true;
	SetFileAttributes(utow(filename).c_str(),FILE_ATTRIBUTE_NORMAL);
	return DeleteFile(utow(filename).c_str());
#endif
}

bool delete_dir(const char* i_directory) {
#ifdef unix
  return remove(i_directory)==0;
#else
	SetFileAttributesW(utow(i_directory).c_str(),FILE_ATTRIBUTE_NORMAL);
  return RemoveDirectoryW(utow(i_directory).c_str());
#endif
}


/// risky command to make a rd folder /s (or rm -r)
#ifdef unix
int erredbarras(const std::string &i_path)
{
		bool 	risultato=false;

		DIR *d=opendir(i_path.c_str());

		if (d) 
		{
			struct dirent *p;
			risultato=true;
			while (risultato && (p=readdir(d))) 
			{
				if (!strcmp(p->d_name, ".") || !strcmp(p->d_name, ".."))
					continue;
				bool risultato2=false;
				struct stat statbuf;
				
				std::string temp;
				if (isdirectory(i_path))
					temp=i_path+p->d_name;
				else
					temp=i_path+"/"+p->d_name;

				if (!stat(temp.c_str(), &statbuf)) 
				{
					if (S_ISDIR(statbuf.st_mode))
						risultato2=erredbarras(temp);
					else
					{
						if (flagdebug)
							printf("20733: delete file %s\n",temp.c_str());
						risultato2=delete_file(temp.c_str());
					}
				}
				risultato=risultato2;
			}
			closedir(d);
		}

		if (risultato)
		{
			if (flagdebug)
				printf("20745: delete dir  %s\n\n",i_path.c_str());
			delete_dir(i_path.c_str());
		}
	   return risultato;
}
#endif

	
#ifdef _WIN32

int erredbarras(const std::wstring &wi_path)
{
	std::wstring wpattern = wi_path+L"\\*.*";
	const std::string s_pattern(wpattern.begin(),wpattern.end());

	if (flagdebug)
		printf("20762: get handle FOR %s\n",s_pattern.c_str());
	
	int secondi=(mtime()-g_startrd)/1000;
	if (secondi!=g_rd_ultimotempo)
	{
		g_rd_ultimotempo=secondi;
		if (g_rd_expected)
			printf("Deleted objects %12s of (~) %12s @ %s/s\r",migliaia(g_rd),migliaia2(g_rd_expected),migliaia3(g_rd/secondi));
		else
			printf("Deleted objects %12s\r",migliaia(g_rd));
	}
	

	WIN32_FIND_DATAW findfiledata;
	HANDLE myhandle=FindFirstFileW(wpattern.c_str(),&findfiledata);
	
	if (myhandle==INVALID_HANDLE_VALUE)
	{
		if (flagdebug)
			printf("20767: Invalid handle %s\n",s_pattern.c_str());
		return 0;
	}
	

	do
	{
		std::string t=wtou(findfiledata.cFileName);
		
		if ((t!=".") && (t!=".."))
		{
			std::wstring wfilepath=wi_path+L"\\"+findfiledata.cFileName;
			const std::string s_wfilepath(wfilepath.begin(),wfilepath.end());
			if (flagdebug)
				printf("20780: Working on %s\n",s_wfilepath.c_str());
			
			if (findfiledata.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
			{
				if (flagdebug)
					printf("\n20784: recurse on %s\n",s_wfilepath.c_str());
				int myresult=erredbarras(wfilepath);
				if (myresult)
					return myresult;
			}
			else
			{
				if (flagdebug)
					printf("20792: set attribute on file %s\n",s_wfilepath.c_str());

				if (SetFileAttributesW(wfilepath.c_str(),FILE_ATTRIBUTE_NORMAL) == FALSE)
				{
					if (flagdebug)
						printf("31019: ERROR cannot change attr of %s\n",s_wfilepath.c_str());
					return GetLastError();
				}
				
				if (flagdebug)
					printf("20802: try to delete file %s\n",s_wfilepath.c_str());

				if (DeleteFileW(wfilepath.c_str())==FALSE)
				{
					if (flagdebug)
						printf("31025: ERROR highlander file %s\n",s_wfilepath.c_str());
					return GetLastError();
				}
				else
					g_rd++;
			}
		}
	} while(FindNextFile(myhandle,&findfiledata)==TRUE);

	if (myhandle)
		FindClose(myhandle);

	
	DWORD myerror=GetLastError();
	if (myerror==ERROR_NO_MORE_FILES)
	{
		const std::string s_wipath(wi_path.begin(), wi_path.end());
		
		if (flagdebug)
			printf("20824: Change folder attr  %s\n",s_wipath.c_str());
					
		if (SetFileAttributesW(wi_path.c_str(),FILE_ATTRIBUTE_NORMAL)==FALSE)
		{
			if (flagdebug)
				printf("30135: ERROR cannot change folder attr %s\n",s_wipath.c_str());
			return GetLastError();
		}
		
		if (flagdebug)
			printf("20834: RemoveDirectory  %s\n",s_wipath.c_str());
						
		if (RemoveDirectoryW(wi_path.c_str())==FALSE)
		{
			if (flagdebug)
				printf("31047: ERROR highlander dir %s\n",s_wipath.c_str());
			return GetLastError();
		}
		else
		g_rd++;
	
	}
	else
		return myerror;
	return 0;
}
#endif



bool stermina(string i_path,int32_t i_expectedfile=0)
{
	
	if (i_path=="")
		return false;

	if (flagdebug)
		printf("20870 : PRE  ------------------ %s ----------\n",i_path.c_str());

#ifdef _WIN32
	if (flaglongpath)
		if (iswindowspath(i_path))
			if (!islongpath(i_path))
				i_path="//?/"+i_path;
#endif
	
	if (isdirectory(i_path))
		i_path=i_path.substr(0, i_path.size()-1);

	if (flagdebug)
		printf("20880 : POST ------------------ %s ----------\n",i_path.c_str());

	g_rd=0; // global file counter for huge dirs on slow media
	g_rd_expected=i_expectedfile;
	g_startrd=mtime();
	g_rd_ultimotempo=0;
#ifdef _WIN32
		erredbarras(utow(i_path.c_str()));
#else
	erredbarras(i_path);
#endif
	///printf("\n");
	return (!direxists(i_path));
	
}


string nomefileseesistegia(string i_nomefile)
{
	if (!fileexists(i_nomefile))
		return i_nomefile;
	string percorso=extractfilepath(i_nomefile);
	string estensione=prendiestensione(i_nomefile);
	string nomefile=prendinomefileebasta(i_nomefile);
	char	numero[10];
	for (int i=1;i<99999;i++)
	{
		sprintf(numero,"%05d",i);
		string snumero=numero;
		string candidato=percorso+nomefile+"_"+snumero+"."+estensione;
		if (!fileexists(candidato))
			return candidato;
	}
	return ("");
}



string forbiddenstring[] = {"CON","PRN","AUX","NUL","COM1","COM2","COM3","COM4","COM5","COM6","COM7","COM8","COM9","LPT1","LPT2","LPT3","LPT4","LPT5","LPT6","LPT7","LPT8","LPT9"};
size_t forbiddenstringsize = sizeof(forbiddenstring)/sizeof(forbiddenstring[0]);

char forbiddenchar[] = {'<','>','"','|','?','*'};
size_t forbiddencharsize = sizeof(forbiddenchar)/sizeof(forbiddenchar[0]);

bool isreserved(const string& i_filename,string& o_fixed)
{
	o_fixed=i_filename;
	bool risultato=false;
#ifdef _WIN32

		bool isfolder=isdirectory(i_filename);

		vector<string> pezzi;
		explode(i_filename,'/',pezzi);
		
		for (unsigned int i=0;i<pezzi.size();i++)
		{
			string porzione=stringtoupper(pezzi[i]);
			for (unsigned int j=0;j<forbiddenstringsize;j++)
				if ((porzione==forbiddenstring[j]) || (mypos(forbiddenstring[j]+".",porzione)==0))
				{
					pezzi[i]="_"+pezzi[i];
					risultato=true;
				}
		}
		
		if (risultato)
		{
			o_fixed="";
			for (unsigned int i=0;i<pezzi.size();i++)
				o_fixed=o_fixed+pezzi[i]+'/';
			
			if (!isfolder)
				o_fixed=myleft(o_fixed,o_fixed.length()-1);
		}

		for (unsigned int i=0;i<o_fixed.size();i++)
			for (unsigned int j=0;j<forbiddencharsize;j++)
				if ((o_fixed[i]==forbiddenchar[j]))
				{
					o_fixed[i]='_';
					risultato=true;
				}

		if (risultato)
			o_fixed=nomefileseesistegia(o_fixed);
		
	return risultato;
#else
	return false;
#endif
}

void xcommand(string i_command,string i_parameter)
{
	if (flagdebug)
	{
		printf("Entering xcommand()\n");
		printf("i_command   |%s|\n",i_command.c_str());
		printf("i_parameter |%s|\n",i_parameter.c_str());
	}

	if (i_command=="")
	{
		if (flagdebug)
				printf("Exit because empty i_command\n");
		return;
	}
	if (!fileexists(i_command))
	{
		if (flagdebug)
				printf("Exit because not fileexists  |%s|\n",i_command.c_str());
		return;
	}
	int dummy;
	

#if defined (_WIN32)
	if (flagdebug)
			printf("WIN32: Replacing before |%s|\n",i_command.c_str());
	myreplaceall(i_command,"/","\\");
	if (flagdebug)
			printf("WIN32: After            |%s|\n",i_command.c_str());
	
#endif

	string mycommand="";
	if (i_parameter=="")
	{
		if (flagdebug)
				printf("20273: i_parameter is empty\n");
			
#if defined (_WIN32)
		if (flagdebug)
			printf("20274: On Windows insert double-double quote for cmd /c\n");
		mycommand="\"\""+i_command+"\""+"\"";
#else
		if (flagdebug)
			printf("20278: On *unix insert single double quote\n");
		mycommand="\""+i_command+"\"";
#endif
	}
	else
	{
		if (flagdebug)
				printf("20291: i_parameter is NOT empty\n");
		
#if defined (_WIN32)
		if (flagdebug)
			printf("20280: On Windows insert double-double quote\n");
		mycommand="\"\""+i_command+"\""+" \""+i_parameter+"\"\"";
#else
		if (flagdebug)
			printf("20284: On *unix insert single double quote for cmd /c\n");
		mycommand="\""+i_command+"\""+" \""+i_parameter+"\"";
#endif

	}
	if (flagdebug)
		printf("20265: Do system on mycommand |%s|\n",mycommand.c_str());
	dummy=system(mycommand.c_str());

	if (dummy==888888)
		printf("no-warning-please\n");
}

string g_gettempdirectory()
{
#if defined(_WIN32) || defined(_WIN64)
	string temppath="";
	wchar_t charpath[MAX_PATH];
	if (GetTempPathW(MAX_PATH, charpath))
	{
		wstring ws(charpath);
		string str(ws.begin(), ws.end());	
		return str;
	}
	return temppath;
#else
	return "/tmp/";
#endif
}




#if defined(_WIN32)
/// something to get VSS done via batch file

void waitexecute(string i_filename,string i_parameters,int i_show)
{
	///SHELLEXECUTEINFOA ShExecInfo = {0};
	SHELLEXECUTEINFOA ShExecInfo =SHELLEXECUTEINFOA();
			 
	ShExecInfo.cbSize = sizeof(SHELLEXECUTEINFOA);
	ShExecInfo.fMask = SEE_MASK_NOCLOSEPROCESS;
	ShExecInfo.hwnd = NULL;
	ShExecInfo.lpVerb = NULL;
	ShExecInfo.lpFile = i_filename.c_str();
	ShExecInfo.lpParameters = i_parameters.c_str();   
	ShExecInfo.lpDirectory = NULL;
	ShExecInfo.nShow = i_show;
	ShExecInfo.hInstApp = NULL; 
	ShellExecuteExA(&ShExecInfo);
	WaitForSingleObject(ShExecInfo.hProcess, INFINITE);
	CloseHandle(ShExecInfo.hProcess);
}

bool isadmin()
{
	BOOL fIsElevated = FALSE;
	HANDLE hToken = NULL;
	TOKEN_ELEVATION elevation;
	DWORD dwSize;

	if (!OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &hToken))
	{
		printf("\n Failed to get Process Token\n");
		goto Cleanup;  // if Failed, we treat as False
	}


	if (!GetTokenInformation(hToken, TokenElevation, &elevation, sizeof(elevation), &dwSize))
	{	
		printf("\nFailed to get Token Information\n");
		goto Cleanup;// if Failed, we treat as False
	}

	fIsElevated = elevation.TokenIsElevated;

Cleanup:
	if (hToken)
	{
		CloseHandle(hToken);
		hToken = NULL;
	}
	return fIsElevated; 
}

//// VSS on Windows by... batchfile
//// delete all kind of shadows copies (if any)
void vss_deleteshadows(string i_cartella)
{
	if (flagvss)
	{
		string	filebatch	=g_gettempdirectory()+"vsz.bat";
		filebatch=nomefileseesistegia(filebatch);
		print_datetime();
		printf("VSS: starting release\n");
    		
		if (fileexists(filebatch))
			if (remove(filebatch.c_str())!=0)
			{
				printf("21204: Highlander batch  %s\n", filebatch.c_str());
				return;
			}
		
		FILE* batch=fopen(filebatch.c_str(), "wb");
		fprintf(batch,"@echo OFF\n");
		
		if (i_cartella!="")
		{
			///fprintf(batch,"subst %s: /d\n",i_lettera.c_str());
			fprintf(batch,"rmdir %s\n",i_cartella.c_str());
		}
		fprintf(batch,"@wmic shadowcopy delete /nointeractive\n");
		fclose(batch);
	
		waitexecute(filebatch,"",SW_HIDE);
	
		print_datetime();
		printf("VSS: end releasing\n");
	}

}
#endif


// Return true if a file or directory (UTF-8 without trailing /) exists.
bool exists(string filename) {
  int len=filename.size();
  if (len<1) return false;
  if (filename[len-1]=='/') filename=filename.substr(0, len-1);
#ifdef unix
  struct stat sb;
  return !lstat(filename.c_str(), &sb);
#else
  return GetFileAttributes(utow(filename.c_str()).c_str())
         !=INVALID_FILE_ATTRIBUTES;
#endif
}



// Close fp if open. Set date and attributes unless 0
bool close(const char* filename, int64_t date, int64_t attr, FP fp=FPNULL) {
  assert(filename);
#ifdef unix
  if (fp!=FPNULL) fclose(fp);
  if (date>0) {
    struct utimbuf ub;
    ub.actime=time(NULL);
    ub.modtime=unix_time(date);
    utime(filename, &ub);
  }
  if ((attr&255)=='u')
    chmod(filename, attr>>8);
	return true;
#else
	const bool ads=strstr(filename, ":$DATA")!=0;  // alternate data stream?
	bool allok=true;
	
	if (date>0 && !ads) 
	{
		if (fp==FPNULL)		// Windows require HANDLE
			fp=CreateFile(utow(filename).c_str(),
                    FILE_WRITE_ATTRIBUTES,
                    FILE_SHARE_READ|FILE_SHARE_WRITE|FILE_SHARE_DELETE,
                    NULL, OPEN_EXISTING, FILE_FLAG_BACKUP_SEMANTICS, NULL);
					
		if (fp!=FPNULL) 
		{
			SYSTEMTIME st;
			st.wYear=date/10000000000LL%10000;
			st.wMonth=date/100000000%100;
			st.wDayOfWeek=0;  // ignored
			st.wDay=date/1000000%100;
			st.wHour=date/10000%100;
			st.wMinute=date/100%100;
			st.wSecond=date%100;
			st.wMilliseconds=0;
			FILETIME ft;
			SystemTimeToFileTime(&st, &ft);
			
///			printf("%d-%d-%d   %d %d %d\n",st.wYear,st.wMonth,st.wDay,st.wHour,st.wMinute,st.wSecond);

			if (!SetFileTime(fp, NULL, NULL, &ft))
			{
				printf("21273: WARN cannot set filetime (error %s) on ",migliaia(GetLastError()));
				printUTF8(filename);
				printf("\n");
				allok=false;
			}
		}
	}
	if (fp!=FPNULL) 
		CloseHandle(fp);
	if ((attr&255)=='w' && !ads)
		if (!SetFileAttributes(utow(filename).c_str(), attr>>8))
		{
			printf("21290: WARN cannot set attributes on ");
			printUTF8(filename);
			printf("\n");
			allok=false;
		}
	return allok;
#endif
}
// Create directories as needed. For example if path="/tmp/foo/bar"
// then create directories /, /tmp, and /tmp/foo unless they exist.
// Set date and attributes if not 0.
void makepath(string path, int64_t date=0, int64_t attr=0) {
  for (unsigned i=0; i<path.size(); ++i) {
    if (path[i]=='\\' || path[i]=='/') {
      path[i]=0;
#ifdef unix
      mkdir(path.c_str(), 0777);
#else
      CreateDirectory(utow(path.c_str()).c_str(), 0);
#endif
      path[i]='/';
    }
  }

  // Set date and attributes
  string filename=path;
  if (filename!="" && filename[filename.size()-1]=='/')
    filename=filename.substr(0, filename.size()-1);  // remove trailing slash
  close(filename.c_str(), date, attr);
}

#ifndef unix

// Truncate filename to length. Return -1 if error, else 0.
int truncate(const char* filename, int64_t length) {
  std::wstring w=utow(filename);
  HANDLE out=CreateFile(w.c_str(), GENERIC_READ | GENERIC_WRITE,
                        0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
  if (out!=INVALID_HANDLE_VALUE) {
    //// LONG
	long hi=length>>32;
    if (SetFilePointer(out, length, &hi, FILE_BEGIN)
             !=INVALID_SET_FILE_POINTER
        && SetEndOfFile(out)
        && CloseHandle(out))
      return 0;
  }
  return -1;
}
#endif


bool saggiascrivibilitacartella(string i_cartella)
{
	if (i_cartella=="")
	{
		if (flagdebug)
				printf("20574: empty folder to be checked\n");
		return false;
	}
	if (flagdebug)		
		printf("20857: i_cartella %s\n",i_cartella.c_str());
	i_cartella=extractfilepath(i_cartella);
	
	if (flagdebug)		
		printf("20859: i_cartella %s\n",i_cartella.c_str());
	
	if (!isdirectory(i_cartella))
			i_cartella+="/";
		
	if (flagdebug)		
		printf("20580: Folder %s\n",i_cartella.c_str());
	string	percorso=extractfilepath(i_cartella);
	if (flagdebug)
		printf("20583: Percorso %s\n",percorso.c_str());
	if  (percorso=="")
	{
		if (flagdebug)
				printf("20587: percorso empty\n");
		return false;
	}
	makepath(percorso);
	
	string	testfile;
	testfile=percorso+"test$$$.txt.me";
	if (flagdebug)
		printf("20593: TEST FILE PRE  <<%s>>\n",testfile.c_str());
	testfile=nomefileseesistegia(testfile);
	if (flagdebug)
	printf("20595: TEST FILE POST <<%s>>\n",testfile.c_str());

	if (flagdebug)
		printf("20599: A1\n");
	
	FILE* testbyte=fopen(testfile.c_str(), "wb");
	if (testbyte!=NULL)
	{
		if (flagdebug)
			printf("20605\n");
		fprintf(testbyte,"this-file-can-be-deleted");
		if (flagdebug)
			printf("20608\n");
		fclose(testbyte);
	}
	if (flagdebug)
			printf("20611\n");
		
		
	bool risultato=fileexists(testfile.c_str());
	if (flagdebug)
			printf("20617\n");
	delete_file(testfile.c_str());
	if (flagdebug)
			printf("20620\n");
	
	return risultato;
}



/*
	some zpaq functions
*/



// Guess number of cores. In 32 bit mode, max is 2.
int numberOfProcessors() {
  int rc=0;  // result
#ifdef unix
#ifdef BSD  // BSD or Mac OS/X
  size_t rclen=sizeof(rc);
  int mib[2]={CTL_HW, HW_NCPU};
  if (sysctl(mib, 2, &rc, &rclen, 0, 0)!=0)
    perror("sysctl");

#else  // Linux
  // Count lines of the form "processor\t: %d\n" in /proc/cpuinfo
  // where %d is 0, 1, 2,..., rc-1
  FILE *in=fopen("/proc/cpuinfo", "r");
  if (!in) return 1;
  std::string s;
  int c;
  while ((c=getc(in))!=EOF) {
    if (c>='A' && c<='Z') c+='a'-'A';  // convert to lowercase
    if (c>' ') s+=c;  // remove white space
    if (c=='\n') {  // end of line?
      if (s.size()>10 && s.substr(0, 10)=="processor:") {
        c=atoi(s.c_str()+10);
        if (c==rc) ++rc;
      }
      s="";
    }
  }
  fclose(in);
#endif
#else

  // In Windows return %NUMBER_OF_PROCESSORS%
  //const char* p=getenv("NUMBER_OF_PROCESSORS");
  //if (p) rc=atoi(p);
  ///SYSTEM_INFO si={0};
  SYSTEM_INFO si= SYSTEM_INFO();
  
  GetSystemInfo(&si);
  rc=si.dwNumberOfProcessors;
#endif
  if (rc<1) rc=1; /// numero massimo core 32bit
  if (sizeof(char*)==4 && rc>2) rc=2;
  return rc;
}


// In Windows convert upper case to lower case.
inline int tolowerW(int c) {
#ifndef unix
  if (c>='A' && c<='Z') return c-'A'+'a';
#endif
  return c;
}

// Return true if strings a == b or a+"/" is a prefix of b
// or a ends in "/" and is a prefix of b.
// Match ? in a to any char in b.
// Match * in a to any string in b.
// In Windows, not case sensitive.
bool ispath(const char* a, const char* b) {
  
  /*
  printf("ZEKEa %s\n",a);
  printf("ZEKEb %s\n",b);
  */
  for (; *a; ++a, ++b) {
    const int ca=tolowerW(*a);
    const int cb=tolowerW(*b);
    if (ca=='*') {
      while (true) {
        if (ispath(a+1, b)) return true;
        if (!*b) return false;
        ++b;
      }
    }
    else if (ca=='?') {
      if (*b==0) return false;
    }
    else if (ca==cb && ca=='/' && a[1]==0)
      return true;
    else if (ca!=cb)
      return false;
  }
  return *b==0 || *b=='/';
}

// Read 4 byte little-endian int and advance s
unsigned btoi(const char* &s) {
  s+=4;
  return (s[-4]&255)|((s[-3]&255)<<8)|((s[-2]&255)<<16)|((s[-1]&255)<<24);
}

// Read 8 byte little-endian int and advance s
int64_t btol(const char* &s) {
  uint64_t r=btoi(s);
  return r+(uint64_t(btoi(s))<<32);
}


// return a/b such that there is exactly one "/" in between, and
// in Windows, any drive letter in b the : is removed and there
// is a "/" after.
string append_path(string a, string b) {
  int na=a.size();
  int nb=b.size();
#ifndef unix
  if (nb>1 && b[1]==':') {  // remove : from drive letter
    if (nb>2 && b[2]!='/') b[1]='/';
    else b=b[0]+b.substr(2), --nb;
  }
#endif
  if (nb>0 && b[0]=='/') b=b.substr(1);
  if (na>0 && a[na-1]=='/') a=a.substr(0, na-1);
  return a+"/"+b;
}


bool	iswildcards(const string& i_string)
{
	bool 	stars=strstr(i_string.c_str(), "*")!=0;			// for debug reason no "collapse"
	bool 	questionmark=strstr(i_string.c_str(), "?")!=0;
	return 	stars+questionmark;
}						
						

bool check_if_password(string i_filename)
{
	if (flagdebug)
		printf("21026: check_if_password of %s\n",i_filename.c_str());
	if (iswildcards(i_filename))
	{
		if (flagdebug)
			printf("21075: wildcard detected, no password check\n");
		return	false;
	}	
	if (!fileexists(i_filename))
		return false;
		
	FILE* inFile = freadopen(i_filename.c_str());
	if (inFile==NULL) 
	{
#ifdef _WIN32
		int err=GetLastError();
#else
		int err=1;
#endif
		printf("\n19802: ERR <%s> kind %d\n",i_filename.c_str(),err); 
		exit(0);
	}
    char s[4]={0};
    const int nr=fread(s,1,4,inFile);
///	for (int i=0;i<4;i++)
///		printf("%d  %c  %d\n",i,s[i],s[i]);
	fclose(inFile);
    if (nr>0 && memcmp(s, "7kSt", 4) && (memcmp(s, "zPQ", 3) || s[3]<1))
		return true;
	return false;
}

/*

	Sort section
*/

///// sort by offset, then by filename
///// use sprintf for debug, not very fast.
bool comparecrc32block(s_crc32block a, s_crc32block b)
{
	char a_start[40];
	char b_start[40];
	sprintf(a_start,"%014lld",(long long)a.crc32start);
	sprintf(b_start,"%014lld",(long long)b.crc32start);
	return a.filename+a_start<b.filename+b_start;
}

bool comparecrc32(s_fileandsize a, s_fileandsize b)
{
	return a.hashhex>b.hashhex;
}
bool comparesizehash(s_fileandsize a, s_fileandsize b)
{
	return (a.size < b.size) ||
           ((a.size == b.size) && (a.hashhex > b.hashhex)) || 
           ((a.size == b.size) && (a.hashhex == b.hashhex) &&
              (a.filename<b.filename));
			  ///(strcmp(a.filename.c_str(), b.filename.c_str()) <0));
			  
}
bool comparefilenamesize(s_fileandsize a, s_fileandsize b)
{
	char a_size[40];
	char b_size[40];
	sprintf(a_size,"%014lld",(long long)a.size);
	sprintf(b_size,"%014lld",(long long)b.size);
	return a_size+a.filename<b_size+b.filename;
}
bool comparefilenamedate(s_fileandsize a, s_fileandsize b)
{
	char a_size[40];
	char b_size[40];
	sprintf(a_size,"%014lld",(long long)a.date);
	sprintf(b_size,"%014lld",(long long)b.date);
	return a_size+a.filename<b_size+b.filename;
}
bool sortbyval(const std::pair<string, string> &a, 
               const std::pair<string, string> &b) 
{ 
///	slower, but useful sorting filenames
///	printf("First   %s     second   %s\n",a.first.c_str(),a.second.c_str());
	if (a.second==b.second)
		return (a.first < b.first);
	return (a.second < b.second); 
} 

bool sortbysize(const std::pair<uint64_t, string> &a, 
               const std::pair<uint64_t, string> &b) 
{ 
    return (a.first < b.first); 
} 

/// possible problems with unsigned to calculate the differences. We do NOT want to link abs()
int64_t myabs(int64_t i_first,int64_t i_second)
{
	if (i_first>i_second)
		return i_first-i_second;
	else
		return i_second-i_first;
}


/*
	random section
*/

struct xorshift128plus_key_s 
{
    uint64_t part1;
    uint64_t part2;
};

typedef struct xorshift128plus_key_s xorshift128plus_key_t;

static inline void xorshift128plus_init(uint64_t key1, uint64_t key2, xorshift128plus_key_t *key) 
{
  key->part1 = key1;
  key->part2 = key2;
}

uint64_t xorshift128plus(xorshift128plus_key_t * key) 
{
    uint64_t s1 = key->part1;
    const uint64_t s0 = key->part2;
    key->part1 = s0;
    s1 ^= s1 << 23; // a
    key->part2 = s1 ^ s0 ^ (s1 >> 18) ^ (s0 >> 5); // b, c
    return key->part2 + s0;
}

void populateRandom_xorshift128plus(uint32_t *answer, uint32_t size,uint64_t i_key1, uint64_t i_key2) 
{
	xorshift128plus_key_t mykey; /// nowarning
	mykey.part1 = i_key1;
	mykey.part2 = i_key2;
  xorshift128plus_init(i_key1, i_key2, &mykey);
  uint32_t i = size;
  while (i > 2) {
    *(uint64_t *)(answer + size - i) = xorshift128plus(&mykey);
    i -= 2;
  }
  if (i != 0)
    answer[size - i] = (uint32_t)xorshift128plus(&mykey);
}


/*
	checksum section
*/


/////////////////// calculate CRC32 

// //////////////////////////////////////////////////////////
// Crc32.h
// Copyright (c) 2011-2019 Stephan Brumme. All rights reserved.
// Slicing-by-16 contributed by Bulat Ziganshin
// Tableless bytewise CRC contributed by Hagai Gold
// see http://create.stephan-brumme.com/disclaimer.html
//

#define CRC32_USE_LOOKUP_TABLE_SLICING_BY_16

// uint8_t, uint32_t, int32_t


uint32_t crc32_combine (uint32_t crcA, uint32_t crcB, size_t lengthB);
uint32_t crc32_16bytes (const void* data, size_t length, uint32_t previousCrc32 = 0);


#ifndef __LITTLE_ENDIAN
  #define __LITTLE_ENDIAN 1234
#endif
#ifndef __BIG_ENDIAN
  #define __BIG_ENDIAN    4321
#endif

// define endianess and some integer data types
#if defined(_MSC_VER) || defined(__MINGW32__)
  // Windows always little endian
  #define __BYTE_ORDER __LITTLE_ENDIAN

  // intrinsics / prefetching
  #include <xmmintrin.h>
  #ifdef __MINGW32__
    #define PREFETCH(location) __builtin_prefetch(location)
  #else
    #define PREFETCH(location) _mm_prefetch(location, _MM_HINT_T0)
  #endif
#else
  // defines __BYTE_ORDER as __LITTLE_ENDIAN or __BIG_ENDIAN
  #include <sys/param.h>

  // intrinsics / prefetching
  #ifdef __GNUC__
    #define PREFETCH(location) __builtin_prefetch(location)
  #else
    // no prefetching
    #define PREFETCH(location) ;
  #endif
#endif


#define __BYTE_ORDER __LITTLE_ENDIAN

namespace
{
  /// zlib's CRC32 polynomial
  const uint32_t Polynomial = 0xEDB88320;
//esx
  /// swap endianess
  static inline uint32_t swap(uint32_t x)
  {
  
#ifndef ESX
#if defined(__GNUC__) || defined(__clang__) && !defined(ESX)
    return __builtin_bswap32(x);
  #else
    return (x >> 24) |
          ((x >>  8) & 0x0000FF00) |
          ((x <<  8) & 0x00FF0000) |
           (x << 24);
  #endif

#else //ESX

 return (x >> 24) |
          ((x >>  8) & 0x0000FF00) |
          ((x <<  8) & 0x00FF0000) |
           (x << 24);


#endif



  }

  /// Slicing-By-16
  const size_t MaxSlice = 16;
  
} // anonymous namespace

/// forward declaration, table is at the end of this file
extern const uint32_t Crc32Lookup[MaxSlice][256]; // extern is needed to keep compiler happy

uint32_t crc32_16bytes(const void* data, size_t length, uint32_t previousCrc32)
{
  uint32_t crc = ~previousCrc32; // same as previousCrc32 ^ 0xFFFFFFFF
  const uint32_t* current = (const uint32_t*) data;

  // enabling optimization (at least -O2) automatically unrolls the inner for-loop
  const size_t Unroll = 4;
  const size_t BytesAtOnce = 16 * Unroll;

  while (length >= BytesAtOnce)
  {
    for (size_t unrolling = 0; unrolling < Unroll; unrolling++)
    {
#if __BYTE_ORDER == __BIG_ENDIAN
    uint32_t one   = *current++ ^ swap(crc);
    uint32_t two   = *current++;
    uint32_t three = *current++;
    uint32_t four  = *current++;
    crc  = Crc32Lookup[ 0][ four         & 0xFF] ^
           Crc32Lookup[ 1][(four  >>  8) & 0xFF] ^
           Crc32Lookup[ 2][(four  >> 16) & 0xFF] ^
           Crc32Lookup[ 3][(four  >> 24) & 0xFF] ^
           Crc32Lookup[ 4][ three        & 0xFF] ^
           Crc32Lookup[ 5][(three >>  8) & 0xFF] ^
           Crc32Lookup[ 6][(three >> 16) & 0xFF] ^
           Crc32Lookup[ 7][(three >> 24) & 0xFF] ^
           Crc32Lookup[ 8][ two          & 0xFF] ^
           Crc32Lookup[ 9][(two   >>  8) & 0xFF] ^
           Crc32Lookup[10][(two   >> 16) & 0xFF] ^
           Crc32Lookup[11][(two   >> 24) & 0xFF] ^
           Crc32Lookup[12][ one          & 0xFF] ^
           Crc32Lookup[13][(one   >>  8) & 0xFF] ^
           Crc32Lookup[14][(one   >> 16) & 0xFF] ^
           Crc32Lookup[15][(one   >> 24) & 0xFF];
#else
    uint32_t one   = *current++ ^ crc;
    uint32_t two   = *current++;
    uint32_t three = *current++;
    uint32_t four  = *current++;
    crc  = Crc32Lookup[ 0][(four  >> 24) & 0xFF] ^
           Crc32Lookup[ 1][(four  >> 16) & 0xFF] ^
           Crc32Lookup[ 2][(four  >>  8) & 0xFF] ^
           Crc32Lookup[ 3][ four         & 0xFF] ^
           Crc32Lookup[ 4][(three >> 24) & 0xFF] ^
           Crc32Lookup[ 5][(three >> 16) & 0xFF] ^
           Crc32Lookup[ 6][(three >>  8) & 0xFF] ^
           Crc32Lookup[ 7][ three        & 0xFF] ^
           Crc32Lookup[ 8][(two   >> 24) & 0xFF] ^
           Crc32Lookup[ 9][(two   >> 16) & 0xFF] ^
           Crc32Lookup[10][(two   >>  8) & 0xFF] ^
           Crc32Lookup[11][ two          & 0xFF] ^
           Crc32Lookup[12][(one   >> 24) & 0xFF] ^
           Crc32Lookup[13][(one   >> 16) & 0xFF] ^
           Crc32Lookup[14][(one   >>  8) & 0xFF] ^
           Crc32Lookup[15][ one          & 0xFF];
#endif
    }

    length -= BytesAtOnce;
  }

  const uint8_t* currentChar = (const uint8_t*) current;
  // remaining 1 to 63 bytes (standard algorithm)
  while (length-- != 0)
    crc = (crc >> 8) ^ Crc32Lookup[0][(crc & 0xFF) ^ *currentChar++];

  return ~crc; // same as crc ^ 0xFFFFFFFF
}


/// merge two CRC32 such that result = crc32(dataB, lengthB, crc32(dataA, lengthA))
uint32_t crc32_combine(uint32_t crcA, uint32_t crcB, size_t lengthB)
{

  // degenerated case
  if (lengthB == 0)
    return crcA;

  /// CRC32 => 32 bits
  const uint32_t CrcBits = 32;

  uint32_t odd [CrcBits]; // odd-power-of-two  zeros operator
  uint32_t even[CrcBits]; // even-power-of-two zeros operator

  // put operator for one zero bit in odd
  odd[0] = Polynomial;    // CRC-32 polynomial
  for (unsigned int i = 1; i < CrcBits; i++)
    odd[i] = 1 << (i - 1);

  // put operator for two zero bits in even
  // same as gf2_matrix_square(even, odd);
  for (unsigned int i = 0; i < CrcBits; i++)
  {
    uint32_t vec = odd[i];
    even[i] = 0;
    for (int j = 0; vec != 0; j++, vec >>= 1)
      if (vec & 1)
        even[i] ^= odd[j];
  }
  // put operator for four zero bits in odd
  // same as gf2_matrix_square(odd, even);
  for (unsigned int i = 0; i < CrcBits; i++)
  {
    uint32_t vec = even[i];
    odd[i] = 0;
    for (int j = 0; vec != 0; j++, vec >>= 1)
      if (vec & 1)
        odd[i] ^= even[j];
  }

  // the following loop becomes much shorter if I keep swapping even and odd
  uint32_t* a = even;
  uint32_t* b = odd;
  // apply secondLength zeros to firstCrc32
  for (; lengthB > 0; lengthB >>= 1)
  {
    // same as gf2_matrix_square(a, b);
    for (unsigned int i = 0; i < CrcBits; i++)
    {
      uint32_t vec = b[i];
      a[i] = 0;
      for (int j = 0; vec != 0; j++, vec >>= 1)
        if (vec & 1)
          a[i] ^= b[j];
    }

    // apply zeros operator for this bit
    if (lengthB & 1)
    {
      // same as firstCrc32 = gf2_matrix_times(a, firstCrc32);
      uint32_t sum = 0;
      for (int i = 0; crcA != 0; i++, crcA >>= 1)
        if (crcA & 1)
          sum ^= a[i];
      crcA = sum;
    }

    // switch even and odd
    uint32_t* t = a; a = b; b = t;
  }

  // return combined crc
  return crcA ^ crcB;
}


// //////////////////////////////////////////////////////////
// constants


#ifndef NO_LUT
/// look-up table, already declared above
const uint32_t Crc32Lookup[MaxSlice][256] =
{
  {
    // note: the first number of every second row corresponds to the half-byte look-up table !
    0x00000000,0x77073096,0xEE0E612C,0x990951BA,0x076DC419,0x706AF48F,0xE963A535,0x9E6495A3,
    0x0EDB8832,0x79DCB8A4,0xE0D5E91E,0x97D2D988,0x09B64C2B,0x7EB17CBD,0xE7B82D07,0x90BF1D91,
    0x1DB71064,0x6AB020F2,0xF3B97148,0x84BE41DE,0x1ADAD47D,0x6DDDE4EB,0xF4D4B551,0x83D385C7,
    0x136C9856,0x646BA8C0,0xFD62F97A,0x8A65C9EC,0x14015C4F,0x63066CD9,0xFA0F3D63,0x8D080DF5,
    0x3B6E20C8,0x4C69105E,0xD56041E4,0xA2677172,0x3C03E4D1,0x4B04D447,0xD20D85FD,0xA50AB56B,
    0x35B5A8FA,0x42B2986C,0xDBBBC9D6,0xACBCF940,0x32D86CE3,0x45DF5C75,0xDCD60DCF,0xABD13D59,
    0x26D930AC,0x51DE003A,0xC8D75180,0xBFD06116,0x21B4F4B5,0x56B3C423,0xCFBA9599,0xB8BDA50F,
    0x2802B89E,0x5F058808,0xC60CD9B2,0xB10BE924,0x2F6F7C87,0x58684C11,0xC1611DAB,0xB6662D3D,
    0x76DC4190,0x01DB7106,0x98D220BC,0xEFD5102A,0x71B18589,0x06B6B51F,0x9FBFE4A5,0xE8B8D433,
    0x7807C9A2,0x0F00F934,0x9609A88E,0xE10E9818,0x7F6A0DBB,0x086D3D2D,0x91646C97,0xE6635C01,
    0x6B6B51F4,0x1C6C6162,0x856530D8,0xF262004E,0x6C0695ED,0x1B01A57B,0x8208F4C1,0xF50FC457,
    0x65B0D9C6,0x12B7E950,0x8BBEB8EA,0xFCB9887C,0x62DD1DDF,0x15DA2D49,0x8CD37CF3,0xFBD44C65,
    0x4DB26158,0x3AB551CE,0xA3BC0074,0xD4BB30E2,0x4ADFA541,0x3DD895D7,0xA4D1C46D,0xD3D6F4FB,
    0x4369E96A,0x346ED9FC,0xAD678846,0xDA60B8D0,0x44042D73,0x33031DE5,0xAA0A4C5F,0xDD0D7CC9,
    0x5005713C,0x270241AA,0xBE0B1010,0xC90C2086,0x5768B525,0x206F85B3,0xB966D409,0xCE61E49F,
    0x5EDEF90E,0x29D9C998,0xB0D09822,0xC7D7A8B4,0x59B33D17,0x2EB40D81,0xB7BD5C3B,0xC0BA6CAD,
    0xEDB88320,0x9ABFB3B6,0x03B6E20C,0x74B1D29A,0xEAD54739,0x9DD277AF,0x04DB2615,0x73DC1683,
    0xE3630B12,0x94643B84,0x0D6D6A3E,0x7A6A5AA8,0xE40ECF0B,0x9309FF9D,0x0A00AE27,0x7D079EB1,
    0xF00F9344,0x8708A3D2,0x1E01F268,0x6906C2FE,0xF762575D,0x806567CB,0x196C3671,0x6E6B06E7,
    0xFED41B76,0x89D32BE0,0x10DA7A5A,0x67DD4ACC,0xF9B9DF6F,0x8EBEEFF9,0x17B7BE43,0x60B08ED5,
    0xD6D6A3E8,0xA1D1937E,0x38D8C2C4,0x4FDFF252,0xD1BB67F1,0xA6BC5767,0x3FB506DD,0x48B2364B,
    0xD80D2BDA,0xAF0A1B4C,0x36034AF6,0x41047A60,0xDF60EFC3,0xA867DF55,0x316E8EEF,0x4669BE79,
    0xCB61B38C,0xBC66831A,0x256FD2A0,0x5268E236,0xCC0C7795,0xBB0B4703,0x220216B9,0x5505262F,
    0xC5BA3BBE,0xB2BD0B28,0x2BB45A92,0x5CB36A04,0xC2D7FFA7,0xB5D0CF31,0x2CD99E8B,0x5BDEAE1D,
    0x9B64C2B0,0xEC63F226,0x756AA39C,0x026D930A,0x9C0906A9,0xEB0E363F,0x72076785,0x05005713,
    0x95BF4A82,0xE2B87A14,0x7BB12BAE,0x0CB61B38,0x92D28E9B,0xE5D5BE0D,0x7CDCEFB7,0x0BDBDF21,
    0x86D3D2D4,0xF1D4E242,0x68DDB3F8,0x1FDA836E,0x81BE16CD,0xF6B9265B,0x6FB077E1,0x18B74777,
    0x88085AE6,0xFF0F6A70,0x66063BCA,0x11010B5C,0x8F659EFF,0xF862AE69,0x616BFFD3,0x166CCF45,
    0xA00AE278,0xD70DD2EE,0x4E048354,0x3903B3C2,0xA7672661,0xD06016F7,0x4969474D,0x3E6E77DB,
    0xAED16A4A,0xD9D65ADC,0x40DF0B66,0x37D83BF0,0xA9BCAE53,0xDEBB9EC5,0x47B2CF7F,0x30B5FFE9,
    0xBDBDF21C,0xCABAC28A,0x53B39330,0x24B4A3A6,0xBAD03605,0xCDD70693,0x54DE5729,0x23D967BF,
    0xB3667A2E,0xC4614AB8,0x5D681B02,0x2A6F2B94,0xB40BBE37,0xC30C8EA1,0x5A05DF1B,0x2D02EF8D,
  }

#if defined(CRC32_USE_LOOKUP_TABLE_SLICING_BY_4) || defined(CRC32_USE_LOOKUP_TABLE_SLICING_BY_8) || defined(CRC32_USE_LOOKUP_TABLE_SLICING_BY_16)
  // beyond this point only relevant for Slicing-by-4, Slicing-by-8 and Slicing-by-16
  ,{
    0x00000000,0x191B3141,0x32366282,0x2B2D53C3,0x646CC504,0x7D77F445,0x565AA786,0x4F4196C7,
    0xC8D98A08,0xD1C2BB49,0xFAEFE88A,0xE3F4D9CB,0xACB54F0C,0xB5AE7E4D,0x9E832D8E,0x87981CCF,
    0x4AC21251,0x53D92310,0x78F470D3,0x61EF4192,0x2EAED755,0x37B5E614,0x1C98B5D7,0x05838496,
    0x821B9859,0x9B00A918,0xB02DFADB,0xA936CB9A,0xE6775D5D,0xFF6C6C1C,0xD4413FDF,0xCD5A0E9E,
    0x958424A2,0x8C9F15E3,0xA7B24620,0xBEA97761,0xF1E8E1A6,0xE8F3D0E7,0xC3DE8324,0xDAC5B265,
    0x5D5DAEAA,0x44469FEB,0x6F6BCC28,0x7670FD69,0x39316BAE,0x202A5AEF,0x0B07092C,0x121C386D,
    0xDF4636F3,0xC65D07B2,0xED705471,0xF46B6530,0xBB2AF3F7,0xA231C2B6,0x891C9175,0x9007A034,
    0x179FBCFB,0x0E848DBA,0x25A9DE79,0x3CB2EF38,0x73F379FF,0x6AE848BE,0x41C51B7D,0x58DE2A3C,
    0xF0794F05,0xE9627E44,0xC24F2D87,0xDB541CC6,0x94158A01,0x8D0EBB40,0xA623E883,0xBF38D9C2,
    0x38A0C50D,0x21BBF44C,0x0A96A78F,0x138D96CE,0x5CCC0009,0x45D73148,0x6EFA628B,0x77E153CA,
    0xBABB5D54,0xA3A06C15,0x888D3FD6,0x91960E97,0xDED79850,0xC7CCA911,0xECE1FAD2,0xF5FACB93,
    0x7262D75C,0x6B79E61D,0x4054B5DE,0x594F849F,0x160E1258,0x0F152319,0x243870DA,0x3D23419B,
    0x65FD6BA7,0x7CE65AE6,0x57CB0925,0x4ED03864,0x0191AEA3,0x188A9FE2,0x33A7CC21,0x2ABCFD60,
    0xAD24E1AF,0xB43FD0EE,0x9F12832D,0x8609B26C,0xC94824AB,0xD05315EA,0xFB7E4629,0xE2657768,
    0x2F3F79F6,0x362448B7,0x1D091B74,0x04122A35,0x4B53BCF2,0x52488DB3,0x7965DE70,0x607EEF31,
    0xE7E6F3FE,0xFEFDC2BF,0xD5D0917C,0xCCCBA03D,0x838A36FA,0x9A9107BB,0xB1BC5478,0xA8A76539,
    0x3B83984B,0x2298A90A,0x09B5FAC9,0x10AECB88,0x5FEF5D4F,0x46F46C0E,0x6DD93FCD,0x74C20E8C,
    0xF35A1243,0xEA412302,0xC16C70C1,0xD8774180,0x9736D747,0x8E2DE606,0xA500B5C5,0xBC1B8484,
    0x71418A1A,0x685ABB5B,0x4377E898,0x5A6CD9D9,0x152D4F1E,0x0C367E5F,0x271B2D9C,0x3E001CDD,
    0xB9980012,0xA0833153,0x8BAE6290,0x92B553D1,0xDDF4C516,0xC4EFF457,0xEFC2A794,0xF6D996D5,
    0xAE07BCE9,0xB71C8DA8,0x9C31DE6B,0x852AEF2A,0xCA6B79ED,0xD37048AC,0xF85D1B6F,0xE1462A2E,
    0x66DE36E1,0x7FC507A0,0x54E85463,0x4DF36522,0x02B2F3E5,0x1BA9C2A4,0x30849167,0x299FA026,
    0xE4C5AEB8,0xFDDE9FF9,0xD6F3CC3A,0xCFE8FD7B,0x80A96BBC,0x99B25AFD,0xB29F093E,0xAB84387F,
    0x2C1C24B0,0x350715F1,0x1E2A4632,0x07317773,0x4870E1B4,0x516BD0F5,0x7A468336,0x635DB277,
    0xCBFAD74E,0xD2E1E60F,0xF9CCB5CC,0xE0D7848D,0xAF96124A,0xB68D230B,0x9DA070C8,0x84BB4189,
    0x03235D46,0x1A386C07,0x31153FC4,0x280E0E85,0x674F9842,0x7E54A903,0x5579FAC0,0x4C62CB81,
    0x8138C51F,0x9823F45E,0xB30EA79D,0xAA1596DC,0xE554001B,0xFC4F315A,0xD7626299,0xCE7953D8,
    0x49E14F17,0x50FA7E56,0x7BD72D95,0x62CC1CD4,0x2D8D8A13,0x3496BB52,0x1FBBE891,0x06A0D9D0,
    0x5E7EF3EC,0x4765C2AD,0x6C48916E,0x7553A02F,0x3A1236E8,0x230907A9,0x0824546A,0x113F652B,
    0x96A779E4,0x8FBC48A5,0xA4911B66,0xBD8A2A27,0xF2CBBCE0,0xEBD08DA1,0xC0FDDE62,0xD9E6EF23,
    0x14BCE1BD,0x0DA7D0FC,0x268A833F,0x3F91B27E,0x70D024B9,0x69CB15F8,0x42E6463B,0x5BFD777A,
    0xDC656BB5,0xC57E5AF4,0xEE530937,0xF7483876,0xB809AEB1,0xA1129FF0,0x8A3FCC33,0x9324FD72,
  },

  {
    0x00000000,0x01C26A37,0x0384D46E,0x0246BE59,0x0709A8DC,0x06CBC2EB,0x048D7CB2,0x054F1685,
    0x0E1351B8,0x0FD13B8F,0x0D9785D6,0x0C55EFE1,0x091AF964,0x08D89353,0x0A9E2D0A,0x0B5C473D,
    0x1C26A370,0x1DE4C947,0x1FA2771E,0x1E601D29,0x1B2F0BAC,0x1AED619B,0x18ABDFC2,0x1969B5F5,
    0x1235F2C8,0x13F798FF,0x11B126A6,0x10734C91,0x153C5A14,0x14FE3023,0x16B88E7A,0x177AE44D,
    0x384D46E0,0x398F2CD7,0x3BC9928E,0x3A0BF8B9,0x3F44EE3C,0x3E86840B,0x3CC03A52,0x3D025065,
    0x365E1758,0x379C7D6F,0x35DAC336,0x3418A901,0x3157BF84,0x3095D5B3,0x32D36BEA,0x331101DD,
    0x246BE590,0x25A98FA7,0x27EF31FE,0x262D5BC9,0x23624D4C,0x22A0277B,0x20E69922,0x2124F315,
    0x2A78B428,0x2BBADE1F,0x29FC6046,0x283E0A71,0x2D711CF4,0x2CB376C3,0x2EF5C89A,0x2F37A2AD,
    0x709A8DC0,0x7158E7F7,0x731E59AE,0x72DC3399,0x7793251C,0x76514F2B,0x7417F172,0x75D59B45,
    0x7E89DC78,0x7F4BB64F,0x7D0D0816,0x7CCF6221,0x798074A4,0x78421E93,0x7A04A0CA,0x7BC6CAFD,
    0x6CBC2EB0,0x6D7E4487,0x6F38FADE,0x6EFA90E9,0x6BB5866C,0x6A77EC5B,0x68315202,0x69F33835,
    0x62AF7F08,0x636D153F,0x612BAB66,0x60E9C151,0x65A6D7D4,0x6464BDE3,0x662203BA,0x67E0698D,
    0x48D7CB20,0x4915A117,0x4B531F4E,0x4A917579,0x4FDE63FC,0x4E1C09CB,0x4C5AB792,0x4D98DDA5,
    0x46C49A98,0x4706F0AF,0x45404EF6,0x448224C1,0x41CD3244,0x400F5873,0x4249E62A,0x438B8C1D,
    0x54F16850,0x55330267,0x5775BC3E,0x56B7D609,0x53F8C08C,0x523AAABB,0x507C14E2,0x51BE7ED5,
    0x5AE239E8,0x5B2053DF,0x5966ED86,0x58A487B1,0x5DEB9134,0x5C29FB03,0x5E6F455A,0x5FAD2F6D,
    0xE1351B80,0xE0F771B7,0xE2B1CFEE,0xE373A5D9,0xE63CB35C,0xE7FED96B,0xE5B86732,0xE47A0D05,
    0xEF264A38,0xEEE4200F,0xECA29E56,0xED60F461,0xE82FE2E4,0xE9ED88D3,0xEBAB368A,0xEA695CBD,
    0xFD13B8F0,0xFCD1D2C7,0xFE976C9E,0xFF5506A9,0xFA1A102C,0xFBD87A1B,0xF99EC442,0xF85CAE75,
    0xF300E948,0xF2C2837F,0xF0843D26,0xF1465711,0xF4094194,0xF5CB2BA3,0xF78D95FA,0xF64FFFCD,
    0xD9785D60,0xD8BA3757,0xDAFC890E,0xDB3EE339,0xDE71F5BC,0xDFB39F8B,0xDDF521D2,0xDC374BE5,
    0xD76B0CD8,0xD6A966EF,0xD4EFD8B6,0xD52DB281,0xD062A404,0xD1A0CE33,0xD3E6706A,0xD2241A5D,
    0xC55EFE10,0xC49C9427,0xC6DA2A7E,0xC7184049,0xC25756CC,0xC3953CFB,0xC1D382A2,0xC011E895,
    0xCB4DAFA8,0xCA8FC59F,0xC8C97BC6,0xC90B11F1,0xCC440774,0xCD866D43,0xCFC0D31A,0xCE02B92D,
    0x91AF9640,0x906DFC77,0x922B422E,0x93E92819,0x96A63E9C,0x976454AB,0x9522EAF2,0x94E080C5,
    0x9FBCC7F8,0x9E7EADCF,0x9C381396,0x9DFA79A1,0x98B56F24,0x99770513,0x9B31BB4A,0x9AF3D17D,
    0x8D893530,0x8C4B5F07,0x8E0DE15E,0x8FCF8B69,0x8A809DEC,0x8B42F7DB,0x89044982,0x88C623B5,
    0x839A6488,0x82580EBF,0x801EB0E6,0x81DCDAD1,0x8493CC54,0x8551A663,0x8717183A,0x86D5720D,
    0xA9E2D0A0,0xA820BA97,0xAA6604CE,0xABA46EF9,0xAEEB787C,0xAF29124B,0xAD6FAC12,0xACADC625,
    0xA7F18118,0xA633EB2F,0xA4755576,0xA5B73F41,0xA0F829C4,0xA13A43F3,0xA37CFDAA,0xA2BE979D,
    0xB5C473D0,0xB40619E7,0xB640A7BE,0xB782CD89,0xB2CDDB0C,0xB30FB13B,0xB1490F62,0xB08B6555,
    0xBBD72268,0xBA15485F,0xB853F606,0xB9919C31,0xBCDE8AB4,0xBD1CE083,0xBF5A5EDA,0xBE9834ED,
  },

  {
    0x00000000,0xB8BC6765,0xAA09C88B,0x12B5AFEE,0x8F629757,0x37DEF032,0x256B5FDC,0x9DD738B9,
    0xC5B428EF,0x7D084F8A,0x6FBDE064,0xD7018701,0x4AD6BFB8,0xF26AD8DD,0xE0DF7733,0x58631056,
    0x5019579F,0xE8A530FA,0xFA109F14,0x42ACF871,0xDF7BC0C8,0x67C7A7AD,0x75720843,0xCDCE6F26,
    0x95AD7F70,0x2D111815,0x3FA4B7FB,0x8718D09E,0x1ACFE827,0xA2738F42,0xB0C620AC,0x087A47C9,
    0xA032AF3E,0x188EC85B,0x0A3B67B5,0xB28700D0,0x2F503869,0x97EC5F0C,0x8559F0E2,0x3DE59787,
    0x658687D1,0xDD3AE0B4,0xCF8F4F5A,0x7733283F,0xEAE41086,0x525877E3,0x40EDD80D,0xF851BF68,
    0xF02BF8A1,0x48979FC4,0x5A22302A,0xE29E574F,0x7F496FF6,0xC7F50893,0xD540A77D,0x6DFCC018,
    0x359FD04E,0x8D23B72B,0x9F9618C5,0x272A7FA0,0xBAFD4719,0x0241207C,0x10F48F92,0xA848E8F7,
    0x9B14583D,0x23A83F58,0x311D90B6,0x89A1F7D3,0x1476CF6A,0xACCAA80F,0xBE7F07E1,0x06C36084,
    0x5EA070D2,0xE61C17B7,0xF4A9B859,0x4C15DF3C,0xD1C2E785,0x697E80E0,0x7BCB2F0E,0xC377486B,
    0xCB0D0FA2,0x73B168C7,0x6104C729,0xD9B8A04C,0x446F98F5,0xFCD3FF90,0xEE66507E,0x56DA371B,
    0x0EB9274D,0xB6054028,0xA4B0EFC6,0x1C0C88A3,0x81DBB01A,0x3967D77F,0x2BD27891,0x936E1FF4,
    0x3B26F703,0x839A9066,0x912F3F88,0x299358ED,0xB4446054,0x0CF80731,0x1E4DA8DF,0xA6F1CFBA,
    0xFE92DFEC,0x462EB889,0x549B1767,0xEC277002,0x71F048BB,0xC94C2FDE,0xDBF98030,0x6345E755,
    0x6B3FA09C,0xD383C7F9,0xC1366817,0x798A0F72,0xE45D37CB,0x5CE150AE,0x4E54FF40,0xF6E89825,
    0xAE8B8873,0x1637EF16,0x048240F8,0xBC3E279D,0x21E91F24,0x99557841,0x8BE0D7AF,0x335CB0CA,
    0xED59B63B,0x55E5D15E,0x47507EB0,0xFFEC19D5,0x623B216C,0xDA874609,0xC832E9E7,0x708E8E82,
    0x28ED9ED4,0x9051F9B1,0x82E4565F,0x3A58313A,0xA78F0983,0x1F336EE6,0x0D86C108,0xB53AA66D,
    0xBD40E1A4,0x05FC86C1,0x1749292F,0xAFF54E4A,0x322276F3,0x8A9E1196,0x982BBE78,0x2097D91D,
    0x78F4C94B,0xC048AE2E,0xD2FD01C0,0x6A4166A5,0xF7965E1C,0x4F2A3979,0x5D9F9697,0xE523F1F2,
    0x4D6B1905,0xF5D77E60,0xE762D18E,0x5FDEB6EB,0xC2098E52,0x7AB5E937,0x680046D9,0xD0BC21BC,
    0x88DF31EA,0x3063568F,0x22D6F961,0x9A6A9E04,0x07BDA6BD,0xBF01C1D8,0xADB46E36,0x15080953,
    0x1D724E9A,0xA5CE29FF,0xB77B8611,0x0FC7E174,0x9210D9CD,0x2AACBEA8,0x38191146,0x80A57623,
    0xD8C66675,0x607A0110,0x72CFAEFE,0xCA73C99B,0x57A4F122,0xEF189647,0xFDAD39A9,0x45115ECC,
    0x764DEE06,0xCEF18963,0xDC44268D,0x64F841E8,0xF92F7951,0x41931E34,0x5326B1DA,0xEB9AD6BF,
    0xB3F9C6E9,0x0B45A18C,0x19F00E62,0xA14C6907,0x3C9B51BE,0x842736DB,0x96929935,0x2E2EFE50,
    0x2654B999,0x9EE8DEFC,0x8C5D7112,0x34E11677,0xA9362ECE,0x118A49AB,0x033FE645,0xBB838120,
    0xE3E09176,0x5B5CF613,0x49E959FD,0xF1553E98,0x6C820621,0xD43E6144,0xC68BCEAA,0x7E37A9CF,
    0xD67F4138,0x6EC3265D,0x7C7689B3,0xC4CAEED6,0x591DD66F,0xE1A1B10A,0xF3141EE4,0x4BA87981,
    0x13CB69D7,0xAB770EB2,0xB9C2A15C,0x017EC639,0x9CA9FE80,0x241599E5,0x36A0360B,0x8E1C516E,
    0x866616A7,0x3EDA71C2,0x2C6FDE2C,0x94D3B949,0x090481F0,0xB1B8E695,0xA30D497B,0x1BB12E1E,
    0x43D23E48,0xFB6E592D,0xE9DBF6C3,0x516791A6,0xCCB0A91F,0x740CCE7A,0x66B96194,0xDE0506F1,
  }
#endif // defined(CRC32_USE_LOOKUP_TABLE_SLICING_BY_4) || defined(CRC32_USE_LOOKUP_TABLE_SLICING_BY_8) || defined(CRC32_USE_LOOKUP_TABLE_SLICING_BY_16)
#if defined (CRC32_USE_LOOKUP_TABLE_SLICING_BY_8) || defined(CRC32_USE_LOOKUP_TABLE_SLICING_BY_16)
  // beyond this point only relevant for Slicing-by-8 and Slicing-by-16
  ,{
    0x00000000,0x3D6029B0,0x7AC05360,0x47A07AD0,0xF580A6C0,0xC8E08F70,0x8F40F5A0,0xB220DC10,
    0x30704BC1,0x0D106271,0x4AB018A1,0x77D03111,0xC5F0ED01,0xF890C4B1,0xBF30BE61,0x825097D1,
    0x60E09782,0x5D80BE32,0x1A20C4E2,0x2740ED52,0x95603142,0xA80018F2,0xEFA06222,0xD2C04B92,
    0x5090DC43,0x6DF0F5F3,0x2A508F23,0x1730A693,0xA5107A83,0x98705333,0xDFD029E3,0xE2B00053,
    0xC1C12F04,0xFCA106B4,0xBB017C64,0x866155D4,0x344189C4,0x0921A074,0x4E81DAA4,0x73E1F314,
    0xF1B164C5,0xCCD14D75,0x8B7137A5,0xB6111E15,0x0431C205,0x3951EBB5,0x7EF19165,0x4391B8D5,
    0xA121B886,0x9C419136,0xDBE1EBE6,0xE681C256,0x54A11E46,0x69C137F6,0x2E614D26,0x13016496,
    0x9151F347,0xAC31DAF7,0xEB91A027,0xD6F18997,0x64D15587,0x59B17C37,0x1E1106E7,0x23712F57,
    0x58F35849,0x659371F9,0x22330B29,0x1F532299,0xAD73FE89,0x9013D739,0xD7B3ADE9,0xEAD38459,
    0x68831388,0x55E33A38,0x124340E8,0x2F236958,0x9D03B548,0xA0639CF8,0xE7C3E628,0xDAA3CF98,
    0x3813CFCB,0x0573E67B,0x42D39CAB,0x7FB3B51B,0xCD93690B,0xF0F340BB,0xB7533A6B,0x8A3313DB,
    0x0863840A,0x3503ADBA,0x72A3D76A,0x4FC3FEDA,0xFDE322CA,0xC0830B7A,0x872371AA,0xBA43581A,
    0x9932774D,0xA4525EFD,0xE3F2242D,0xDE920D9D,0x6CB2D18D,0x51D2F83D,0x167282ED,0x2B12AB5D,
    0xA9423C8C,0x9422153C,0xD3826FEC,0xEEE2465C,0x5CC29A4C,0x61A2B3FC,0x2602C92C,0x1B62E09C,
    0xF9D2E0CF,0xC4B2C97F,0x8312B3AF,0xBE729A1F,0x0C52460F,0x31326FBF,0x7692156F,0x4BF23CDF,
    0xC9A2AB0E,0xF4C282BE,0xB362F86E,0x8E02D1DE,0x3C220DCE,0x0142247E,0x46E25EAE,0x7B82771E,
    0xB1E6B092,0x8C869922,0xCB26E3F2,0xF646CA42,0x44661652,0x79063FE2,0x3EA64532,0x03C66C82,
    0x8196FB53,0xBCF6D2E3,0xFB56A833,0xC6368183,0x74165D93,0x49767423,0x0ED60EF3,0x33B62743,
    0xD1062710,0xEC660EA0,0xABC67470,0x96A65DC0,0x248681D0,0x19E6A860,0x5E46D2B0,0x6326FB00,
    0xE1766CD1,0xDC164561,0x9BB63FB1,0xA6D61601,0x14F6CA11,0x2996E3A1,0x6E369971,0x5356B0C1,
    0x70279F96,0x4D47B626,0x0AE7CCF6,0x3787E546,0x85A73956,0xB8C710E6,0xFF676A36,0xC2074386,
    0x4057D457,0x7D37FDE7,0x3A978737,0x07F7AE87,0xB5D77297,0x88B75B27,0xCF1721F7,0xF2770847,
    0x10C70814,0x2DA721A4,0x6A075B74,0x576772C4,0xE547AED4,0xD8278764,0x9F87FDB4,0xA2E7D404,
    0x20B743D5,0x1DD76A65,0x5A7710B5,0x67173905,0xD537E515,0xE857CCA5,0xAFF7B675,0x92979FC5,
    0xE915E8DB,0xD475C16B,0x93D5BBBB,0xAEB5920B,0x1C954E1B,0x21F567AB,0x66551D7B,0x5B3534CB,
    0xD965A31A,0xE4058AAA,0xA3A5F07A,0x9EC5D9CA,0x2CE505DA,0x11852C6A,0x562556BA,0x6B457F0A,
    0x89F57F59,0xB49556E9,0xF3352C39,0xCE550589,0x7C75D999,0x4115F029,0x06B58AF9,0x3BD5A349,
    0xB9853498,0x84E51D28,0xC34567F8,0xFE254E48,0x4C059258,0x7165BBE8,0x36C5C138,0x0BA5E888,
    0x28D4C7DF,0x15B4EE6F,0x521494BF,0x6F74BD0F,0xDD54611F,0xE03448AF,0xA794327F,0x9AF41BCF,
    0x18A48C1E,0x25C4A5AE,0x6264DF7E,0x5F04F6CE,0xED242ADE,0xD044036E,0x97E479BE,0xAA84500E,
    0x4834505D,0x755479ED,0x32F4033D,0x0F942A8D,0xBDB4F69D,0x80D4DF2D,0xC774A5FD,0xFA148C4D,
    0x78441B9C,0x4524322C,0x028448FC,0x3FE4614C,0x8DC4BD5C,0xB0A494EC,0xF704EE3C,0xCA64C78C,
  },

  {
    0x00000000,0xCB5CD3A5,0x4DC8A10B,0x869472AE,0x9B914216,0x50CD91B3,0xD659E31D,0x1D0530B8,
    0xEC53826D,0x270F51C8,0xA19B2366,0x6AC7F0C3,0x77C2C07B,0xBC9E13DE,0x3A0A6170,0xF156B2D5,
    0x03D6029B,0xC88AD13E,0x4E1EA390,0x85427035,0x9847408D,0x531B9328,0xD58FE186,0x1ED33223,
    0xEF8580F6,0x24D95353,0xA24D21FD,0x6911F258,0x7414C2E0,0xBF481145,0x39DC63EB,0xF280B04E,
    0x07AC0536,0xCCF0D693,0x4A64A43D,0x81387798,0x9C3D4720,0x57619485,0xD1F5E62B,0x1AA9358E,
    0xEBFF875B,0x20A354FE,0xA6372650,0x6D6BF5F5,0x706EC54D,0xBB3216E8,0x3DA66446,0xF6FAB7E3,
    0x047A07AD,0xCF26D408,0x49B2A6A6,0x82EE7503,0x9FEB45BB,0x54B7961E,0xD223E4B0,0x197F3715,
    0xE82985C0,0x23755665,0xA5E124CB,0x6EBDF76E,0x73B8C7D6,0xB8E41473,0x3E7066DD,0xF52CB578,
    0x0F580A6C,0xC404D9C9,0x4290AB67,0x89CC78C2,0x94C9487A,0x5F959BDF,0xD901E971,0x125D3AD4,
    0xE30B8801,0x28575BA4,0xAEC3290A,0x659FFAAF,0x789ACA17,0xB3C619B2,0x35526B1C,0xFE0EB8B9,
    0x0C8E08F7,0xC7D2DB52,0x4146A9FC,0x8A1A7A59,0x971F4AE1,0x5C439944,0xDAD7EBEA,0x118B384F,
    0xE0DD8A9A,0x2B81593F,0xAD152B91,0x6649F834,0x7B4CC88C,0xB0101B29,0x36846987,0xFDD8BA22,
    0x08F40F5A,0xC3A8DCFF,0x453CAE51,0x8E607DF4,0x93654D4C,0x58399EE9,0xDEADEC47,0x15F13FE2,
    0xE4A78D37,0x2FFB5E92,0xA96F2C3C,0x6233FF99,0x7F36CF21,0xB46A1C84,0x32FE6E2A,0xF9A2BD8F,
    0x0B220DC1,0xC07EDE64,0x46EAACCA,0x8DB67F6F,0x90B34FD7,0x5BEF9C72,0xDD7BEEDC,0x16273D79,
    0xE7718FAC,0x2C2D5C09,0xAAB92EA7,0x61E5FD02,0x7CE0CDBA,0xB7BC1E1F,0x31286CB1,0xFA74BF14,
    0x1EB014D8,0xD5ECC77D,0x5378B5D3,0x98246676,0x852156CE,0x4E7D856B,0xC8E9F7C5,0x03B52460,
    0xF2E396B5,0x39BF4510,0xBF2B37BE,0x7477E41B,0x6972D4A3,0xA22E0706,0x24BA75A8,0xEFE6A60D,
    0x1D661643,0xD63AC5E6,0x50AEB748,0x9BF264ED,0x86F75455,0x4DAB87F0,0xCB3FF55E,0x006326FB,
    0xF135942E,0x3A69478B,0xBCFD3525,0x77A1E680,0x6AA4D638,0xA1F8059D,0x276C7733,0xEC30A496,
    0x191C11EE,0xD240C24B,0x54D4B0E5,0x9F886340,0x828D53F8,0x49D1805D,0xCF45F2F3,0x04192156,
    0xF54F9383,0x3E134026,0xB8873288,0x73DBE12D,0x6EDED195,0xA5820230,0x2316709E,0xE84AA33B,
    0x1ACA1375,0xD196C0D0,0x5702B27E,0x9C5E61DB,0x815B5163,0x4A0782C6,0xCC93F068,0x07CF23CD,
    0xF6999118,0x3DC542BD,0xBB513013,0x700DE3B6,0x6D08D30E,0xA65400AB,0x20C07205,0xEB9CA1A0,
    0x11E81EB4,0xDAB4CD11,0x5C20BFBF,0x977C6C1A,0x8A795CA2,0x41258F07,0xC7B1FDA9,0x0CED2E0C,
    0xFDBB9CD9,0x36E74F7C,0xB0733DD2,0x7B2FEE77,0x662ADECF,0xAD760D6A,0x2BE27FC4,0xE0BEAC61,
    0x123E1C2F,0xD962CF8A,0x5FF6BD24,0x94AA6E81,0x89AF5E39,0x42F38D9C,0xC467FF32,0x0F3B2C97,
    0xFE6D9E42,0x35314DE7,0xB3A53F49,0x78F9ECEC,0x65FCDC54,0xAEA00FF1,0x28347D5F,0xE368AEFA,
    0x16441B82,0xDD18C827,0x5B8CBA89,0x90D0692C,0x8DD55994,0x46898A31,0xC01DF89F,0x0B412B3A,
    0xFA1799EF,0x314B4A4A,0xB7DF38E4,0x7C83EB41,0x6186DBF9,0xAADA085C,0x2C4E7AF2,0xE712A957,
    0x15921919,0xDECECABC,0x585AB812,0x93066BB7,0x8E035B0F,0x455F88AA,0xC3CBFA04,0x089729A1,
    0xF9C19B74,0x329D48D1,0xB4093A7F,0x7F55E9DA,0x6250D962,0xA90C0AC7,0x2F987869,0xE4C4ABCC,
  },

  {
    0x00000000,0xA6770BB4,0x979F1129,0x31E81A9D,0xF44F2413,0x52382FA7,0x63D0353A,0xC5A73E8E,
    0x33EF4E67,0x959845D3,0xA4705F4E,0x020754FA,0xC7A06A74,0x61D761C0,0x503F7B5D,0xF64870E9,
    0x67DE9CCE,0xC1A9977A,0xF0418DE7,0x56368653,0x9391B8DD,0x35E6B369,0x040EA9F4,0xA279A240,
    0x5431D2A9,0xF246D91D,0xC3AEC380,0x65D9C834,0xA07EF6BA,0x0609FD0E,0x37E1E793,0x9196EC27,
    0xCFBD399C,0x69CA3228,0x582228B5,0xFE552301,0x3BF21D8F,0x9D85163B,0xAC6D0CA6,0x0A1A0712,
    0xFC5277FB,0x5A257C4F,0x6BCD66D2,0xCDBA6D66,0x081D53E8,0xAE6A585C,0x9F8242C1,0x39F54975,
    0xA863A552,0x0E14AEE6,0x3FFCB47B,0x998BBFCF,0x5C2C8141,0xFA5B8AF5,0xCBB39068,0x6DC49BDC,
    0x9B8CEB35,0x3DFBE081,0x0C13FA1C,0xAA64F1A8,0x6FC3CF26,0xC9B4C492,0xF85CDE0F,0x5E2BD5BB,
    0x440B7579,0xE27C7ECD,0xD3946450,0x75E36FE4,0xB044516A,0x16335ADE,0x27DB4043,0x81AC4BF7,
    0x77E43B1E,0xD19330AA,0xE07B2A37,0x460C2183,0x83AB1F0D,0x25DC14B9,0x14340E24,0xB2430590,
    0x23D5E9B7,0x85A2E203,0xB44AF89E,0x123DF32A,0xD79ACDA4,0x71EDC610,0x4005DC8D,0xE672D739,
    0x103AA7D0,0xB64DAC64,0x87A5B6F9,0x21D2BD4D,0xE47583C3,0x42028877,0x73EA92EA,0xD59D995E,
    0x8BB64CE5,0x2DC14751,0x1C295DCC,0xBA5E5678,0x7FF968F6,0xD98E6342,0xE86679DF,0x4E11726B,
    0xB8590282,0x1E2E0936,0x2FC613AB,0x89B1181F,0x4C162691,0xEA612D25,0xDB8937B8,0x7DFE3C0C,
    0xEC68D02B,0x4A1FDB9F,0x7BF7C102,0xDD80CAB6,0x1827F438,0xBE50FF8C,0x8FB8E511,0x29CFEEA5,
    0xDF879E4C,0x79F095F8,0x48188F65,0xEE6F84D1,0x2BC8BA5F,0x8DBFB1EB,0xBC57AB76,0x1A20A0C2,
    0x8816EAF2,0x2E61E146,0x1F89FBDB,0xB9FEF06F,0x7C59CEE1,0xDA2EC555,0xEBC6DFC8,0x4DB1D47C,
    0xBBF9A495,0x1D8EAF21,0x2C66B5BC,0x8A11BE08,0x4FB68086,0xE9C18B32,0xD82991AF,0x7E5E9A1B,
    0xEFC8763C,0x49BF7D88,0x78576715,0xDE206CA1,0x1B87522F,0xBDF0599B,0x8C184306,0x2A6F48B2,
    0xDC27385B,0x7A5033EF,0x4BB82972,0xEDCF22C6,0x28681C48,0x8E1F17FC,0xBFF70D61,0x198006D5,
    0x47ABD36E,0xE1DCD8DA,0xD034C247,0x7643C9F3,0xB3E4F77D,0x1593FCC9,0x247BE654,0x820CEDE0,
    0x74449D09,0xD23396BD,0xE3DB8C20,0x45AC8794,0x800BB91A,0x267CB2AE,0x1794A833,0xB1E3A387,
    0x20754FA0,0x86024414,0xB7EA5E89,0x119D553D,0xD43A6BB3,0x724D6007,0x43A57A9A,0xE5D2712E,
    0x139A01C7,0xB5ED0A73,0x840510EE,0x22721B5A,0xE7D525D4,0x41A22E60,0x704A34FD,0xD63D3F49,
    0xCC1D9F8B,0x6A6A943F,0x5B828EA2,0xFDF58516,0x3852BB98,0x9E25B02C,0xAFCDAAB1,0x09BAA105,
    0xFFF2D1EC,0x5985DA58,0x686DC0C5,0xCE1ACB71,0x0BBDF5FF,0xADCAFE4B,0x9C22E4D6,0x3A55EF62,
    0xABC30345,0x0DB408F1,0x3C5C126C,0x9A2B19D8,0x5F8C2756,0xF9FB2CE2,0xC813367F,0x6E643DCB,
    0x982C4D22,0x3E5B4696,0x0FB35C0B,0xA9C457BF,0x6C636931,0xCA146285,0xFBFC7818,0x5D8B73AC,
    0x03A0A617,0xA5D7ADA3,0x943FB73E,0x3248BC8A,0xF7EF8204,0x519889B0,0x6070932D,0xC6079899,
    0x304FE870,0x9638E3C4,0xA7D0F959,0x01A7F2ED,0xC400CC63,0x6277C7D7,0x539FDD4A,0xF5E8D6FE,
    0x647E3AD9,0xC209316D,0xF3E12BF0,0x55962044,0x90311ECA,0x3646157E,0x07AE0FE3,0xA1D90457,
    0x579174BE,0xF1E67F0A,0xC00E6597,0x66796E23,0xA3DE50AD,0x05A95B19,0x34414184,0x92364A30,
  },

  {
    0x00000000,0xCCAA009E,0x4225077D,0x8E8F07E3,0x844A0EFA,0x48E00E64,0xC66F0987,0x0AC50919,
    0xD3E51BB5,0x1F4F1B2B,0x91C01CC8,0x5D6A1C56,0x57AF154F,0x9B0515D1,0x158A1232,0xD92012AC,
    0x7CBB312B,0xB01131B5,0x3E9E3656,0xF23436C8,0xF8F13FD1,0x345B3F4F,0xBAD438AC,0x767E3832,
    0xAF5E2A9E,0x63F42A00,0xED7B2DE3,0x21D12D7D,0x2B142464,0xE7BE24FA,0x69312319,0xA59B2387,
    0xF9766256,0x35DC62C8,0xBB53652B,0x77F965B5,0x7D3C6CAC,0xB1966C32,0x3F196BD1,0xF3B36B4F,
    0x2A9379E3,0xE639797D,0x68B67E9E,0xA41C7E00,0xAED97719,0x62737787,0xECFC7064,0x205670FA,
    0x85CD537D,0x496753E3,0xC7E85400,0x0B42549E,0x01875D87,0xCD2D5D19,0x43A25AFA,0x8F085A64,
    0x562848C8,0x9A824856,0x140D4FB5,0xD8A74F2B,0xD2624632,0x1EC846AC,0x9047414F,0x5CED41D1,
    0x299DC2ED,0xE537C273,0x6BB8C590,0xA712C50E,0xADD7CC17,0x617DCC89,0xEFF2CB6A,0x2358CBF4,
    0xFA78D958,0x36D2D9C6,0xB85DDE25,0x74F7DEBB,0x7E32D7A2,0xB298D73C,0x3C17D0DF,0xF0BDD041,
    0x5526F3C6,0x998CF358,0x1703F4BB,0xDBA9F425,0xD16CFD3C,0x1DC6FDA2,0x9349FA41,0x5FE3FADF,
    0x86C3E873,0x4A69E8ED,0xC4E6EF0E,0x084CEF90,0x0289E689,0xCE23E617,0x40ACE1F4,0x8C06E16A,
    0xD0EBA0BB,0x1C41A025,0x92CEA7C6,0x5E64A758,0x54A1AE41,0x980BAEDF,0x1684A93C,0xDA2EA9A2,
    0x030EBB0E,0xCFA4BB90,0x412BBC73,0x8D81BCED,0x8744B5F4,0x4BEEB56A,0xC561B289,0x09CBB217,
    0xAC509190,0x60FA910E,0xEE7596ED,0x22DF9673,0x281A9F6A,0xE4B09FF4,0x6A3F9817,0xA6959889,
    0x7FB58A25,0xB31F8ABB,0x3D908D58,0xF13A8DC6,0xFBFF84DF,0x37558441,0xB9DA83A2,0x7570833C,
    0x533B85DA,0x9F918544,0x111E82A7,0xDDB48239,0xD7718B20,0x1BDB8BBE,0x95548C5D,0x59FE8CC3,
    0x80DE9E6F,0x4C749EF1,0xC2FB9912,0x0E51998C,0x04949095,0xC83E900B,0x46B197E8,0x8A1B9776,
    0x2F80B4F1,0xE32AB46F,0x6DA5B38C,0xA10FB312,0xABCABA0B,0x6760BA95,0xE9EFBD76,0x2545BDE8,
    0xFC65AF44,0x30CFAFDA,0xBE40A839,0x72EAA8A7,0x782FA1BE,0xB485A120,0x3A0AA6C3,0xF6A0A65D,
    0xAA4DE78C,0x66E7E712,0xE868E0F1,0x24C2E06F,0x2E07E976,0xE2ADE9E8,0x6C22EE0B,0xA088EE95,
    0x79A8FC39,0xB502FCA7,0x3B8DFB44,0xF727FBDA,0xFDE2F2C3,0x3148F25D,0xBFC7F5BE,0x736DF520,
    0xD6F6D6A7,0x1A5CD639,0x94D3D1DA,0x5879D144,0x52BCD85D,0x9E16D8C3,0x1099DF20,0xDC33DFBE,
    0x0513CD12,0xC9B9CD8C,0x4736CA6F,0x8B9CCAF1,0x8159C3E8,0x4DF3C376,0xC37CC495,0x0FD6C40B,
    0x7AA64737,0xB60C47A9,0x3883404A,0xF42940D4,0xFEEC49CD,0x32464953,0xBCC94EB0,0x70634E2E,
    0xA9435C82,0x65E95C1C,0xEB665BFF,0x27CC5B61,0x2D095278,0xE1A352E6,0x6F2C5505,0xA386559B,
    0x061D761C,0xCAB77682,0x44387161,0x889271FF,0x825778E6,0x4EFD7878,0xC0727F9B,0x0CD87F05,
    0xD5F86DA9,0x19526D37,0x97DD6AD4,0x5B776A4A,0x51B26353,0x9D1863CD,0x1397642E,0xDF3D64B0,
    0x83D02561,0x4F7A25FF,0xC1F5221C,0x0D5F2282,0x079A2B9B,0xCB302B05,0x45BF2CE6,0x89152C78,
    0x50353ED4,0x9C9F3E4A,0x121039A9,0xDEBA3937,0xD47F302E,0x18D530B0,0x965A3753,0x5AF037CD,
    0xFF6B144A,0x33C114D4,0xBD4E1337,0x71E413A9,0x7B211AB0,0xB78B1A2E,0x39041DCD,0xF5AE1D53,
    0x2C8E0FFF,0xE0240F61,0x6EAB0882,0xA201081C,0xA8C40105,0x646E019B,0xEAE10678,0x264B06E6,
  }
#endif // CRC32_USE_LOOKUP_TABLE_SLICING_BY_8 || CRC32_USE_LOOKUP_TABLE_SLICING_BY_16
#ifdef CRC32_USE_LOOKUP_TABLE_SLICING_BY_16
  // beyond this point only relevant for Slicing-by-16
  ,{
    0x00000000,0x177B1443,0x2EF62886,0x398D3CC5,0x5DEC510C,0x4A97454F,0x731A798A,0x64616DC9,
    0xBBD8A218,0xACA3B65B,0x952E8A9E,0x82559EDD,0xE634F314,0xF14FE757,0xC8C2DB92,0xDFB9CFD1,
    0xACC04271,0xBBBB5632,0x82366AF7,0x954D7EB4,0xF12C137D,0xE657073E,0xDFDA3BFB,0xC8A12FB8,
    0x1718E069,0x0063F42A,0x39EEC8EF,0x2E95DCAC,0x4AF4B165,0x5D8FA526,0x640299E3,0x73798DA0,
    0x82F182A3,0x958A96E0,0xAC07AA25,0xBB7CBE66,0xDF1DD3AF,0xC866C7EC,0xF1EBFB29,0xE690EF6A,
    0x392920BB,0x2E5234F8,0x17DF083D,0x00A41C7E,0x64C571B7,0x73BE65F4,0x4A335931,0x5D484D72,
    0x2E31C0D2,0x394AD491,0x00C7E854,0x17BCFC17,0x73DD91DE,0x64A6859D,0x5D2BB958,0x4A50AD1B,
    0x95E962CA,0x82927689,0xBB1F4A4C,0xAC645E0F,0xC80533C6,0xDF7E2785,0xE6F31B40,0xF1880F03,
    0xDE920307,0xC9E91744,0xF0642B81,0xE71F3FC2,0x837E520B,0x94054648,0xAD887A8D,0xBAF36ECE,
    0x654AA11F,0x7231B55C,0x4BBC8999,0x5CC79DDA,0x38A6F013,0x2FDDE450,0x1650D895,0x012BCCD6,
    0x72524176,0x65295535,0x5CA469F0,0x4BDF7DB3,0x2FBE107A,0x38C50439,0x014838FC,0x16332CBF,
    0xC98AE36E,0xDEF1F72D,0xE77CCBE8,0xF007DFAB,0x9466B262,0x831DA621,0xBA909AE4,0xADEB8EA7,
    0x5C6381A4,0x4B1895E7,0x7295A922,0x65EEBD61,0x018FD0A8,0x16F4C4EB,0x2F79F82E,0x3802EC6D,
    0xE7BB23BC,0xF0C037FF,0xC94D0B3A,0xDE361F79,0xBA5772B0,0xAD2C66F3,0x94A15A36,0x83DA4E75,
    0xF0A3C3D5,0xE7D8D796,0xDE55EB53,0xC92EFF10,0xAD4F92D9,0xBA34869A,0x83B9BA5F,0x94C2AE1C,
    0x4B7B61CD,0x5C00758E,0x658D494B,0x72F65D08,0x169730C1,0x01EC2482,0x38611847,0x2F1A0C04,
    0x6655004F,0x712E140C,0x48A328C9,0x5FD83C8A,0x3BB95143,0x2CC24500,0x154F79C5,0x02346D86,
    0xDD8DA257,0xCAF6B614,0xF37B8AD1,0xE4009E92,0x8061F35B,0x971AE718,0xAE97DBDD,0xB9ECCF9E,
    0xCA95423E,0xDDEE567D,0xE4636AB8,0xF3187EFB,0x97791332,0x80020771,0xB98F3BB4,0xAEF42FF7,
    0x714DE026,0x6636F465,0x5FBBC8A0,0x48C0DCE3,0x2CA1B12A,0x3BDAA569,0x025799AC,0x152C8DEF,
    0xE4A482EC,0xF3DF96AF,0xCA52AA6A,0xDD29BE29,0xB948D3E0,0xAE33C7A3,0x97BEFB66,0x80C5EF25,
    0x5F7C20F4,0x480734B7,0x718A0872,0x66F11C31,0x029071F8,0x15EB65BB,0x2C66597E,0x3B1D4D3D,
    0x4864C09D,0x5F1FD4DE,0x6692E81B,0x71E9FC58,0x15889191,0x02F385D2,0x3B7EB917,0x2C05AD54,
    0xF3BC6285,0xE4C776C6,0xDD4A4A03,0xCA315E40,0xAE503389,0xB92B27CA,0x80A61B0F,0x97DD0F4C,
    0xB8C70348,0xAFBC170B,0x96312BCE,0x814A3F8D,0xE52B5244,0xF2504607,0xCBDD7AC2,0xDCA66E81,
    0x031FA150,0x1464B513,0x2DE989D6,0x3A929D95,0x5EF3F05C,0x4988E41F,0x7005D8DA,0x677ECC99,
    0x14074139,0x037C557A,0x3AF169BF,0x2D8A7DFC,0x49EB1035,0x5E900476,0x671D38B3,0x70662CF0,
    0xAFDFE321,0xB8A4F762,0x8129CBA7,0x9652DFE4,0xF233B22D,0xE548A66E,0xDCC59AAB,0xCBBE8EE8,
    0x3A3681EB,0x2D4D95A8,0x14C0A96D,0x03BBBD2E,0x67DAD0E7,0x70A1C4A4,0x492CF861,0x5E57EC22,
    0x81EE23F3,0x969537B0,0xAF180B75,0xB8631F36,0xDC0272FF,0xCB7966BC,0xF2F45A79,0xE58F4E3A,
    0x96F6C39A,0x818DD7D9,0xB800EB1C,0xAF7BFF5F,0xCB1A9296,0xDC6186D5,0xE5ECBA10,0xF297AE53,
    0x2D2E6182,0x3A5575C1,0x03D84904,0x14A35D47,0x70C2308E,0x67B924CD,0x5E341808,0x494F0C4B,
  },

  {
    0x00000000,0xEFC26B3E,0x04F5D03D,0xEB37BB03,0x09EBA07A,0xE629CB44,0x0D1E7047,0xE2DC1B79,
    0x13D740F4,0xFC152BCA,0x172290C9,0xF8E0FBF7,0x1A3CE08E,0xF5FE8BB0,0x1EC930B3,0xF10B5B8D,
    0x27AE81E8,0xC86CEAD6,0x235B51D5,0xCC993AEB,0x2E452192,0xC1874AAC,0x2AB0F1AF,0xC5729A91,
    0x3479C11C,0xDBBBAA22,0x308C1121,0xDF4E7A1F,0x3D926166,0xD2500A58,0x3967B15B,0xD6A5DA65,
    0x4F5D03D0,0xA09F68EE,0x4BA8D3ED,0xA46AB8D3,0x46B6A3AA,0xA974C894,0x42437397,0xAD8118A9,
    0x5C8A4324,0xB348281A,0x587F9319,0xB7BDF827,0x5561E35E,0xBAA38860,0x51943363,0xBE56585D,
    0x68F38238,0x8731E906,0x6C065205,0x83C4393B,0x61182242,0x8EDA497C,0x65EDF27F,0x8A2F9941,
    0x7B24C2CC,0x94E6A9F2,0x7FD112F1,0x901379CF,0x72CF62B6,0x9D0D0988,0x763AB28B,0x99F8D9B5,
    0x9EBA07A0,0x71786C9E,0x9A4FD79D,0x758DBCA3,0x9751A7DA,0x7893CCE4,0x93A477E7,0x7C661CD9,
    0x8D6D4754,0x62AF2C6A,0x89989769,0x665AFC57,0x8486E72E,0x6B448C10,0x80733713,0x6FB15C2D,
    0xB9148648,0x56D6ED76,0xBDE15675,0x52233D4B,0xB0FF2632,0x5F3D4D0C,0xB40AF60F,0x5BC89D31,
    0xAAC3C6BC,0x4501AD82,0xAE361681,0x41F47DBF,0xA32866C6,0x4CEA0DF8,0xA7DDB6FB,0x481FDDC5,
    0xD1E70470,0x3E256F4E,0xD512D44D,0x3AD0BF73,0xD80CA40A,0x37CECF34,0xDCF97437,0x333B1F09,
    0xC2304484,0x2DF22FBA,0xC6C594B9,0x2907FF87,0xCBDBE4FE,0x24198FC0,0xCF2E34C3,0x20EC5FFD,
    0xF6498598,0x198BEEA6,0xF2BC55A5,0x1D7E3E9B,0xFFA225E2,0x10604EDC,0xFB57F5DF,0x14959EE1,
    0xE59EC56C,0x0A5CAE52,0xE16B1551,0x0EA97E6F,0xEC756516,0x03B70E28,0xE880B52B,0x0742DE15,
    0xE6050901,0x09C7623F,0xE2F0D93C,0x0D32B202,0xEFEEA97B,0x002CC245,0xEB1B7946,0x04D91278,
    0xF5D249F5,0x1A1022CB,0xF12799C8,0x1EE5F2F6,0xFC39E98F,0x13FB82B1,0xF8CC39B2,0x170E528C,
    0xC1AB88E9,0x2E69E3D7,0xC55E58D4,0x2A9C33EA,0xC8402893,0x278243AD,0xCCB5F8AE,0x23779390,
    0xD27CC81D,0x3DBEA323,0xD6891820,0x394B731E,0xDB976867,0x34550359,0xDF62B85A,0x30A0D364,
    0xA9580AD1,0x469A61EF,0xADADDAEC,0x426FB1D2,0xA0B3AAAB,0x4F71C195,0xA4467A96,0x4B8411A8,
    0xBA8F4A25,0x554D211B,0xBE7A9A18,0x51B8F126,0xB364EA5F,0x5CA68161,0xB7913A62,0x5853515C,
    0x8EF68B39,0x6134E007,0x8A035B04,0x65C1303A,0x871D2B43,0x68DF407D,0x83E8FB7E,0x6C2A9040,
    0x9D21CBCD,0x72E3A0F3,0x99D41BF0,0x761670CE,0x94CA6BB7,0x7B080089,0x903FBB8A,0x7FFDD0B4,
    0x78BF0EA1,0x977D659F,0x7C4ADE9C,0x9388B5A2,0x7154AEDB,0x9E96C5E5,0x75A17EE6,0x9A6315D8,
    0x6B684E55,0x84AA256B,0x6F9D9E68,0x805FF556,0x6283EE2F,0x8D418511,0x66763E12,0x89B4552C,
    0x5F118F49,0xB0D3E477,0x5BE45F74,0xB426344A,0x56FA2F33,0xB938440D,0x520FFF0E,0xBDCD9430,
    0x4CC6CFBD,0xA304A483,0x48331F80,0xA7F174BE,0x452D6FC7,0xAAEF04F9,0x41D8BFFA,0xAE1AD4C4,
    0x37E20D71,0xD820664F,0x3317DD4C,0xDCD5B672,0x3E09AD0B,0xD1CBC635,0x3AFC7D36,0xD53E1608,
    0x24354D85,0xCBF726BB,0x20C09DB8,0xCF02F686,0x2DDEEDFF,0xC21C86C1,0x292B3DC2,0xC6E956FC,
    0x104C8C99,0xFF8EE7A7,0x14B95CA4,0xFB7B379A,0x19A72CE3,0xF66547DD,0x1D52FCDE,0xF29097E0,
    0x039BCC6D,0xEC59A753,0x076E1C50,0xE8AC776E,0x0A706C17,0xE5B20729,0x0E85BC2A,0xE147D714,
  },

  {
    0x00000000,0xC18EDFC0,0x586CB9C1,0x99E26601,0xB0D97382,0x7157AC42,0xE8B5CA43,0x293B1583,
    0xBAC3E145,0x7B4D3E85,0xE2AF5884,0x23218744,0x0A1A92C7,0xCB944D07,0x52762B06,0x93F8F4C6,
    0xAEF6C4CB,0x6F781B0B,0xF69A7D0A,0x3714A2CA,0x1E2FB749,0xDFA16889,0x46430E88,0x87CDD148,
    0x1435258E,0xD5BBFA4E,0x4C599C4F,0x8DD7438F,0xA4EC560C,0x656289CC,0xFC80EFCD,0x3D0E300D,
    0x869C8FD7,0x47125017,0xDEF03616,0x1F7EE9D6,0x3645FC55,0xF7CB2395,0x6E294594,0xAFA79A54,
    0x3C5F6E92,0xFDD1B152,0x6433D753,0xA5BD0893,0x8C861D10,0x4D08C2D0,0xD4EAA4D1,0x15647B11,
    0x286A4B1C,0xE9E494DC,0x7006F2DD,0xB1882D1D,0x98B3389E,0x593DE75E,0xC0DF815F,0x01515E9F,
    0x92A9AA59,0x53277599,0xCAC51398,0x0B4BCC58,0x2270D9DB,0xE3FE061B,0x7A1C601A,0xBB92BFDA,
    0xD64819EF,0x17C6C62F,0x8E24A02E,0x4FAA7FEE,0x66916A6D,0xA71FB5AD,0x3EFDD3AC,0xFF730C6C,
    0x6C8BF8AA,0xAD05276A,0x34E7416B,0xF5699EAB,0xDC528B28,0x1DDC54E8,0x843E32E9,0x45B0ED29,
    0x78BEDD24,0xB93002E4,0x20D264E5,0xE15CBB25,0xC867AEA6,0x09E97166,0x900B1767,0x5185C8A7,
    0xC27D3C61,0x03F3E3A1,0x9A1185A0,0x5B9F5A60,0x72A44FE3,0xB32A9023,0x2AC8F622,0xEB4629E2,
    0x50D49638,0x915A49F8,0x08B82FF9,0xC936F039,0xE00DE5BA,0x21833A7A,0xB8615C7B,0x79EF83BB,
    0xEA17777D,0x2B99A8BD,0xB27BCEBC,0x73F5117C,0x5ACE04FF,0x9B40DB3F,0x02A2BD3E,0xC32C62FE,
    0xFE2252F3,0x3FAC8D33,0xA64EEB32,0x67C034F2,0x4EFB2171,0x8F75FEB1,0x169798B0,0xD7194770,
    0x44E1B3B6,0x856F6C76,0x1C8D0A77,0xDD03D5B7,0xF438C034,0x35B61FF4,0xAC5479F5,0x6DDAA635,
    0x77E1359F,0xB66FEA5F,0x2F8D8C5E,0xEE03539E,0xC738461D,0x06B699DD,0x9F54FFDC,0x5EDA201C,
    0xCD22D4DA,0x0CAC0B1A,0x954E6D1B,0x54C0B2DB,0x7DFBA758,0xBC757898,0x25971E99,0xE419C159,
    0xD917F154,0x18992E94,0x817B4895,0x40F59755,0x69CE82D6,0xA8405D16,0x31A23B17,0xF02CE4D7,
    0x63D41011,0xA25ACFD1,0x3BB8A9D0,0xFA367610,0xD30D6393,0x1283BC53,0x8B61DA52,0x4AEF0592,
    0xF17DBA48,0x30F36588,0xA9110389,0x689FDC49,0x41A4C9CA,0x802A160A,0x19C8700B,0xD846AFCB,
    0x4BBE5B0D,0x8A3084CD,0x13D2E2CC,0xD25C3D0C,0xFB67288F,0x3AE9F74F,0xA30B914E,0x62854E8E,
    0x5F8B7E83,0x9E05A143,0x07E7C742,0xC6691882,0xEF520D01,0x2EDCD2C1,0xB73EB4C0,0x76B06B00,
    0xE5489FC6,0x24C64006,0xBD242607,0x7CAAF9C7,0x5591EC44,0x941F3384,0x0DFD5585,0xCC738A45,
    0xA1A92C70,0x6027F3B0,0xF9C595B1,0x384B4A71,0x11705FF2,0xD0FE8032,0x491CE633,0x889239F3,
    0x1B6ACD35,0xDAE412F5,0x430674F4,0x8288AB34,0xABB3BEB7,0x6A3D6177,0xF3DF0776,0x3251D8B6,
    0x0F5FE8BB,0xCED1377B,0x5733517A,0x96BD8EBA,0xBF869B39,0x7E0844F9,0xE7EA22F8,0x2664FD38,
    0xB59C09FE,0x7412D63E,0xEDF0B03F,0x2C7E6FFF,0x05457A7C,0xC4CBA5BC,0x5D29C3BD,0x9CA71C7D,
    0x2735A3A7,0xE6BB7C67,0x7F591A66,0xBED7C5A6,0x97ECD025,0x56620FE5,0xCF8069E4,0x0E0EB624,
    0x9DF642E2,0x5C789D22,0xC59AFB23,0x041424E3,0x2D2F3160,0xECA1EEA0,0x754388A1,0xB4CD5761,
    0x89C3676C,0x484DB8AC,0xD1AFDEAD,0x1021016D,0x391A14EE,0xF894CB2E,0x6176AD2F,0xA0F872EF,
    0x33008629,0xF28E59E9,0x6B6C3FE8,0xAAE2E028,0x83D9F5AB,0x42572A6B,0xDBB54C6A,0x1A3B93AA,
  },

  {
    0x00000000,0x9BA54C6F,0xEC3B9E9F,0x779ED2F0,0x03063B7F,0x98A37710,0xEF3DA5E0,0x7498E98F,
    0x060C76FE,0x9DA93A91,0xEA37E861,0x7192A40E,0x050A4D81,0x9EAF01EE,0xE931D31E,0x72949F71,
    0x0C18EDFC,0x97BDA193,0xE0237363,0x7B863F0C,0x0F1ED683,0x94BB9AEC,0xE325481C,0x78800473,
    0x0A149B02,0x91B1D76D,0xE62F059D,0x7D8A49F2,0x0912A07D,0x92B7EC12,0xE5293EE2,0x7E8C728D,
    0x1831DBF8,0x83949797,0xF40A4567,0x6FAF0908,0x1B37E087,0x8092ACE8,0xF70C7E18,0x6CA93277,
    0x1E3DAD06,0x8598E169,0xF2063399,0x69A37FF6,0x1D3B9679,0x869EDA16,0xF10008E6,0x6AA54489,
    0x14293604,0x8F8C7A6B,0xF812A89B,0x63B7E4F4,0x172F0D7B,0x8C8A4114,0xFB1493E4,0x60B1DF8B,
    0x122540FA,0x89800C95,0xFE1EDE65,0x65BB920A,0x11237B85,0x8A8637EA,0xFD18E51A,0x66BDA975,
    0x3063B7F0,0xABC6FB9F,0xDC58296F,0x47FD6500,0x33658C8F,0xA8C0C0E0,0xDF5E1210,0x44FB5E7F,
    0x366FC10E,0xADCA8D61,0xDA545F91,0x41F113FE,0x3569FA71,0xAECCB61E,0xD95264EE,0x42F72881,
    0x3C7B5A0C,0xA7DE1663,0xD040C493,0x4BE588FC,0x3F7D6173,0xA4D82D1C,0xD346FFEC,0x48E3B383,
    0x3A772CF2,0xA1D2609D,0xD64CB26D,0x4DE9FE02,0x3971178D,0xA2D45BE2,0xD54A8912,0x4EEFC57D,
    0x28526C08,0xB3F72067,0xC469F297,0x5FCCBEF8,0x2B545777,0xB0F11B18,0xC76FC9E8,0x5CCA8587,
    0x2E5E1AF6,0xB5FB5699,0xC2658469,0x59C0C806,0x2D582189,0xB6FD6DE6,0xC163BF16,0x5AC6F379,
    0x244A81F4,0xBFEFCD9B,0xC8711F6B,0x53D45304,0x274CBA8B,0xBCE9F6E4,0xCB772414,0x50D2687B,
    0x2246F70A,0xB9E3BB65,0xCE7D6995,0x55D825FA,0x2140CC75,0xBAE5801A,0xCD7B52EA,0x56DE1E85,
    0x60C76FE0,0xFB62238F,0x8CFCF17F,0x1759BD10,0x63C1549F,0xF86418F0,0x8FFACA00,0x145F866F,
    0x66CB191E,0xFD6E5571,0x8AF08781,0x1155CBEE,0x65CD2261,0xFE686E0E,0x89F6BCFE,0x1253F091,
    0x6CDF821C,0xF77ACE73,0x80E41C83,0x1B4150EC,0x6FD9B963,0xF47CF50C,0x83E227FC,0x18476B93,
    0x6AD3F4E2,0xF176B88D,0x86E86A7D,0x1D4D2612,0x69D5CF9D,0xF27083F2,0x85EE5102,0x1E4B1D6D,
    0x78F6B418,0xE353F877,0x94CD2A87,0x0F6866E8,0x7BF08F67,0xE055C308,0x97CB11F8,0x0C6E5D97,
    0x7EFAC2E6,0xE55F8E89,0x92C15C79,0x09641016,0x7DFCF999,0xE659B5F6,0x91C76706,0x0A622B69,
    0x74EE59E4,0xEF4B158B,0x98D5C77B,0x03708B14,0x77E8629B,0xEC4D2EF4,0x9BD3FC04,0x0076B06B,
    0x72E22F1A,0xE9476375,0x9ED9B185,0x057CFDEA,0x71E41465,0xEA41580A,0x9DDF8AFA,0x067AC695,
    0x50A4D810,0xCB01947F,0xBC9F468F,0x273A0AE0,0x53A2E36F,0xC807AF00,0xBF997DF0,0x243C319F,
    0x56A8AEEE,0xCD0DE281,0xBA933071,0x21367C1E,0x55AE9591,0xCE0BD9FE,0xB9950B0E,0x22304761,
    0x5CBC35EC,0xC7197983,0xB087AB73,0x2B22E71C,0x5FBA0E93,0xC41F42FC,0xB381900C,0x2824DC63,
    0x5AB04312,0xC1150F7D,0xB68BDD8D,0x2D2E91E2,0x59B6786D,0xC2133402,0xB58DE6F2,0x2E28AA9D,
    0x489503E8,0xD3304F87,0xA4AE9D77,0x3F0BD118,0x4B933897,0xD03674F8,0xA7A8A608,0x3C0DEA67,
    0x4E997516,0xD53C3979,0xA2A2EB89,0x3907A7E6,0x4D9F4E69,0xD63A0206,0xA1A4D0F6,0x3A019C99,
    0x448DEE14,0xDF28A27B,0xA8B6708B,0x33133CE4,0x478BD56B,0xDC2E9904,0xABB04BF4,0x3015079B,
    0x428198EA,0xD924D485,0xAEBA0675,0x351F4A1A,0x4187A395,0xDA22EFFA,0xADBC3D0A,0x36197165,
  },

  {
    0x00000000,0xDD96D985,0x605CB54B,0xBDCA6CCE,0xC0B96A96,0x1D2FB313,0xA0E5DFDD,0x7D730658,
    0x5A03D36D,0x87950AE8,0x3A5F6626,0xE7C9BFA3,0x9ABAB9FB,0x472C607E,0xFAE60CB0,0x2770D535,
    0xB407A6DA,0x69917F5F,0xD45B1391,0x09CDCA14,0x74BECC4C,0xA92815C9,0x14E27907,0xC974A082,
    0xEE0475B7,0x3392AC32,0x8E58C0FC,0x53CE1979,0x2EBD1F21,0xF32BC6A4,0x4EE1AA6A,0x937773EF,
    0xB37E4BF5,0x6EE89270,0xD322FEBE,0x0EB4273B,0x73C72163,0xAE51F8E6,0x139B9428,0xCE0D4DAD,
    0xE97D9898,0x34EB411D,0x89212DD3,0x54B7F456,0x29C4F20E,0xF4522B8B,0x49984745,0x940E9EC0,
    0x0779ED2F,0xDAEF34AA,0x67255864,0xBAB381E1,0xC7C087B9,0x1A565E3C,0xA79C32F2,0x7A0AEB77,
    0x5D7A3E42,0x80ECE7C7,0x3D268B09,0xE0B0528C,0x9DC354D4,0x40558D51,0xFD9FE19F,0x2009381A,
    0xBD8D91AB,0x601B482E,0xDDD124E0,0x0047FD65,0x7D34FB3D,0xA0A222B8,0x1D684E76,0xC0FE97F3,
    0xE78E42C6,0x3A189B43,0x87D2F78D,0x5A442E08,0x27372850,0xFAA1F1D5,0x476B9D1B,0x9AFD449E,
    0x098A3771,0xD41CEEF4,0x69D6823A,0xB4405BBF,0xC9335DE7,0x14A58462,0xA96FE8AC,0x74F93129,
    0x5389E41C,0x8E1F3D99,0x33D55157,0xEE4388D2,0x93308E8A,0x4EA6570F,0xF36C3BC1,0x2EFAE244,
    0x0EF3DA5E,0xD36503DB,0x6EAF6F15,0xB339B690,0xCE4AB0C8,0x13DC694D,0xAE160583,0x7380DC06,
    0x54F00933,0x8966D0B6,0x34ACBC78,0xE93A65FD,0x944963A5,0x49DFBA20,0xF415D6EE,0x29830F6B,
    0xBAF47C84,0x6762A501,0xDAA8C9CF,0x073E104A,0x7A4D1612,0xA7DBCF97,0x1A11A359,0xC7877ADC,
    0xE0F7AFE9,0x3D61766C,0x80AB1AA2,0x5D3DC327,0x204EC57F,0xFDD81CFA,0x40127034,0x9D84A9B1,
    0xA06A2517,0x7DFCFC92,0xC036905C,0x1DA049D9,0x60D34F81,0xBD459604,0x008FFACA,0xDD19234F,
    0xFA69F67A,0x27FF2FFF,0x9A354331,0x47A39AB4,0x3AD09CEC,0xE7464569,0x5A8C29A7,0x871AF022,
    0x146D83CD,0xC9FB5A48,0x74313686,0xA9A7EF03,0xD4D4E95B,0x094230DE,0xB4885C10,0x691E8595,
    0x4E6E50A0,0x93F88925,0x2E32E5EB,0xF3A43C6E,0x8ED73A36,0x5341E3B3,0xEE8B8F7D,0x331D56F8,
    0x13146EE2,0xCE82B767,0x7348DBA9,0xAEDE022C,0xD3AD0474,0x0E3BDDF1,0xB3F1B13F,0x6E6768BA,
    0x4917BD8F,0x9481640A,0x294B08C4,0xF4DDD141,0x89AED719,0x54380E9C,0xE9F26252,0x3464BBD7,
    0xA713C838,0x7A8511BD,0xC74F7D73,0x1AD9A4F6,0x67AAA2AE,0xBA3C7B2B,0x07F617E5,0xDA60CE60,
    0xFD101B55,0x2086C2D0,0x9D4CAE1E,0x40DA779B,0x3DA971C3,0xE03FA846,0x5DF5C488,0x80631D0D,
    0x1DE7B4BC,0xC0716D39,0x7DBB01F7,0xA02DD872,0xDD5EDE2A,0x00C807AF,0xBD026B61,0x6094B2E4,
    0x47E467D1,0x9A72BE54,0x27B8D29A,0xFA2E0B1F,0x875D0D47,0x5ACBD4C2,0xE701B80C,0x3A976189,
    0xA9E01266,0x7476CBE3,0xC9BCA72D,0x142A7EA8,0x695978F0,0xB4CFA175,0x0905CDBB,0xD493143E,
    0xF3E3C10B,0x2E75188E,0x93BF7440,0x4E29ADC5,0x335AAB9D,0xEECC7218,0x53061ED6,0x8E90C753,
    0xAE99FF49,0x730F26CC,0xCEC54A02,0x13539387,0x6E2095DF,0xB3B64C5A,0x0E7C2094,0xD3EAF911,
    0xF49A2C24,0x290CF5A1,0x94C6996F,0x495040EA,0x342346B2,0xE9B59F37,0x547FF3F9,0x89E92A7C,
    0x1A9E5993,0xC7088016,0x7AC2ECD8,0xA754355D,0xDA273305,0x07B1EA80,0xBA7B864E,0x67ED5FCB,
    0x409D8AFE,0x9D0B537B,0x20C13FB5,0xFD57E630,0x8024E068,0x5DB239ED,0xE0785523,0x3DEE8CA6,
  },

  {
    0x00000000,0x9D0FE176,0xE16EC4AD,0x7C6125DB,0x19AC8F1B,0x84A36E6D,0xF8C24BB6,0x65CDAAC0,
    0x33591E36,0xAE56FF40,0xD237DA9B,0x4F383BED,0x2AF5912D,0xB7FA705B,0xCB9B5580,0x5694B4F6,
    0x66B23C6C,0xFBBDDD1A,0x87DCF8C1,0x1AD319B7,0x7F1EB377,0xE2115201,0x9E7077DA,0x037F96AC,
    0x55EB225A,0xC8E4C32C,0xB485E6F7,0x298A0781,0x4C47AD41,0xD1484C37,0xAD2969EC,0x3026889A,
    0xCD6478D8,0x506B99AE,0x2C0ABC75,0xB1055D03,0xD4C8F7C3,0x49C716B5,0x35A6336E,0xA8A9D218,
    0xFE3D66EE,0x63328798,0x1F53A243,0x825C4335,0xE791E9F5,0x7A9E0883,0x06FF2D58,0x9BF0CC2E,
    0xABD644B4,0x36D9A5C2,0x4AB88019,0xD7B7616F,0xB27ACBAF,0x2F752AD9,0x53140F02,0xCE1BEE74,
    0x988F5A82,0x0580BBF4,0x79E19E2F,0xE4EE7F59,0x8123D599,0x1C2C34EF,0x604D1134,0xFD42F042,
    0x41B9F7F1,0xDCB61687,0xA0D7335C,0x3DD8D22A,0x581578EA,0xC51A999C,0xB97BBC47,0x24745D31,
    0x72E0E9C7,0xEFEF08B1,0x938E2D6A,0x0E81CC1C,0x6B4C66DC,0xF64387AA,0x8A22A271,0x172D4307,
    0x270BCB9D,0xBA042AEB,0xC6650F30,0x5B6AEE46,0x3EA74486,0xA3A8A5F0,0xDFC9802B,0x42C6615D,
    0x1452D5AB,0x895D34DD,0xF53C1106,0x6833F070,0x0DFE5AB0,0x90F1BBC6,0xEC909E1D,0x719F7F6B,
    0x8CDD8F29,0x11D26E5F,0x6DB34B84,0xF0BCAAF2,0x95710032,0x087EE144,0x741FC49F,0xE91025E9,
    0xBF84911F,0x228B7069,0x5EEA55B2,0xC3E5B4C4,0xA6281E04,0x3B27FF72,0x4746DAA9,0xDA493BDF,
    0xEA6FB345,0x77605233,0x0B0177E8,0x960E969E,0xF3C33C5E,0x6ECCDD28,0x12ADF8F3,0x8FA21985,
    0xD936AD73,0x44394C05,0x385869DE,0xA55788A8,0xC09A2268,0x5D95C31E,0x21F4E6C5,0xBCFB07B3,
    0x8373EFE2,0x1E7C0E94,0x621D2B4F,0xFF12CA39,0x9ADF60F9,0x07D0818F,0x7BB1A454,0xE6BE4522,
    0xB02AF1D4,0x2D2510A2,0x51443579,0xCC4BD40F,0xA9867ECF,0x34899FB9,0x48E8BA62,0xD5E75B14,
    0xE5C1D38E,0x78CE32F8,0x04AF1723,0x99A0F655,0xFC6D5C95,0x6162BDE3,0x1D039838,0x800C794E,
    0xD698CDB8,0x4B972CCE,0x37F60915,0xAAF9E863,0xCF3442A3,0x523BA3D5,0x2E5A860E,0xB3556778,
    0x4E17973A,0xD318764C,0xAF795397,0x3276B2E1,0x57BB1821,0xCAB4F957,0xB6D5DC8C,0x2BDA3DFA,
    0x7D4E890C,0xE041687A,0x9C204DA1,0x012FACD7,0x64E20617,0xF9EDE761,0x858CC2BA,0x188323CC,
    0x28A5AB56,0xB5AA4A20,0xC9CB6FFB,0x54C48E8D,0x3109244D,0xAC06C53B,0xD067E0E0,0x4D680196,
    0x1BFCB560,0x86F35416,0xFA9271CD,0x679D90BB,0x02503A7B,0x9F5FDB0D,0xE33EFED6,0x7E311FA0,
    0xC2CA1813,0x5FC5F965,0x23A4DCBE,0xBEAB3DC8,0xDB669708,0x4669767E,0x3A0853A5,0xA707B2D3,
    0xF1930625,0x6C9CE753,0x10FDC288,0x8DF223FE,0xE83F893E,0x75306848,0x09514D93,0x945EACE5,
    0xA478247F,0x3977C509,0x4516E0D2,0xD81901A4,0xBDD4AB64,0x20DB4A12,0x5CBA6FC9,0xC1B58EBF,
    0x97213A49,0x0A2EDB3F,0x764FFEE4,0xEB401F92,0x8E8DB552,0x13825424,0x6FE371FF,0xF2EC9089,
    0x0FAE60CB,0x92A181BD,0xEEC0A466,0x73CF4510,0x1602EFD0,0x8B0D0EA6,0xF76C2B7D,0x6A63CA0B,
    0x3CF77EFD,0xA1F89F8B,0xDD99BA50,0x40965B26,0x255BF1E6,0xB8541090,0xC435354B,0x593AD43D,
    0x691C5CA7,0xF413BDD1,0x8872980A,0x157D797C,0x70B0D3BC,0xEDBF32CA,0x91DE1711,0x0CD1F667,
    0x5A454291,0xC74AA3E7,0xBB2B863C,0x2624674A,0x43E9CD8A,0xDEE62CFC,0xA2870927,0x3F88E851,
  },

  {
    0x00000000,0xB9FBDBE8,0xA886B191,0x117D6A79,0x8A7C6563,0x3387BE8B,0x22FAD4F2,0x9B010F1A,
    0xCF89CC87,0x7672176F,0x670F7D16,0xDEF4A6FE,0x45F5A9E4,0xFC0E720C,0xED731875,0x5488C39D,
    0x44629F4F,0xFD9944A7,0xECE42EDE,0x551FF536,0xCE1EFA2C,0x77E521C4,0x66984BBD,0xDF639055,
    0x8BEB53C8,0x32108820,0x236DE259,0x9A9639B1,0x019736AB,0xB86CED43,0xA911873A,0x10EA5CD2,
    0x88C53E9E,0x313EE576,0x20438F0F,0x99B854E7,0x02B95BFD,0xBB428015,0xAA3FEA6C,0x13C43184,
    0x474CF219,0xFEB729F1,0xEFCA4388,0x56319860,0xCD30977A,0x74CB4C92,0x65B626EB,0xDC4DFD03,
    0xCCA7A1D1,0x755C7A39,0x64211040,0xDDDACBA8,0x46DBC4B2,0xFF201F5A,0xEE5D7523,0x57A6AECB,
    0x032E6D56,0xBAD5B6BE,0xABA8DCC7,0x1253072F,0x89520835,0x30A9D3DD,0x21D4B9A4,0x982F624C,
    0xCAFB7B7D,0x7300A095,0x627DCAEC,0xDB861104,0x40871E1E,0xF97CC5F6,0xE801AF8F,0x51FA7467,
    0x0572B7FA,0xBC896C12,0xADF4066B,0x140FDD83,0x8F0ED299,0x36F50971,0x27886308,0x9E73B8E0,
    0x8E99E432,0x37623FDA,0x261F55A3,0x9FE48E4B,0x04E58151,0xBD1E5AB9,0xAC6330C0,0x1598EB28,
    0x411028B5,0xF8EBF35D,0xE9969924,0x506D42CC,0xCB6C4DD6,0x7297963E,0x63EAFC47,0xDA1127AF,
    0x423E45E3,0xFBC59E0B,0xEAB8F472,0x53432F9A,0xC8422080,0x71B9FB68,0x60C49111,0xD93F4AF9,
    0x8DB78964,0x344C528C,0x253138F5,0x9CCAE31D,0x07CBEC07,0xBE3037EF,0xAF4D5D96,0x16B6867E,
    0x065CDAAC,0xBFA70144,0xAEDA6B3D,0x1721B0D5,0x8C20BFCF,0x35DB6427,0x24A60E5E,0x9D5DD5B6,
    0xC9D5162B,0x702ECDC3,0x6153A7BA,0xD8A87C52,0x43A97348,0xFA52A8A0,0xEB2FC2D9,0x52D41931,
    0x4E87F0BB,0xF77C2B53,0xE601412A,0x5FFA9AC2,0xC4FB95D8,0x7D004E30,0x6C7D2449,0xD586FFA1,
    0x810E3C3C,0x38F5E7D4,0x29888DAD,0x90735645,0x0B72595F,0xB28982B7,0xA3F4E8CE,0x1A0F3326,
    0x0AE56FF4,0xB31EB41C,0xA263DE65,0x1B98058D,0x80990A97,0x3962D17F,0x281FBB06,0x91E460EE,
    0xC56CA373,0x7C97789B,0x6DEA12E2,0xD411C90A,0x4F10C610,0xF6EB1DF8,0xE7967781,0x5E6DAC69,
    0xC642CE25,0x7FB915CD,0x6EC47FB4,0xD73FA45C,0x4C3EAB46,0xF5C570AE,0xE4B81AD7,0x5D43C13F,
    0x09CB02A2,0xB030D94A,0xA14DB333,0x18B668DB,0x83B767C1,0x3A4CBC29,0x2B31D650,0x92CA0DB8,
    0x8220516A,0x3BDB8A82,0x2AA6E0FB,0x935D3B13,0x085C3409,0xB1A7EFE1,0xA0DA8598,0x19215E70,
    0x4DA99DED,0xF4524605,0xE52F2C7C,0x5CD4F794,0xC7D5F88E,0x7E2E2366,0x6F53491F,0xD6A892F7,
    0x847C8BC6,0x3D87502E,0x2CFA3A57,0x9501E1BF,0x0E00EEA5,0xB7FB354D,0xA6865F34,0x1F7D84DC,
    0x4BF54741,0xF20E9CA9,0xE373F6D0,0x5A882D38,0xC1892222,0x7872F9CA,0x690F93B3,0xD0F4485B,
    0xC01E1489,0x79E5CF61,0x6898A518,0xD1637EF0,0x4A6271EA,0xF399AA02,0xE2E4C07B,0x5B1F1B93,
    0x0F97D80E,0xB66C03E6,0xA711699F,0x1EEAB277,0x85EBBD6D,0x3C106685,0x2D6D0CFC,0x9496D714,
    0x0CB9B558,0xB5426EB0,0xA43F04C9,0x1DC4DF21,0x86C5D03B,0x3F3E0BD3,0x2E4361AA,0x97B8BA42,
    0xC33079DF,0x7ACBA237,0x6BB6C84E,0xD24D13A6,0x494C1CBC,0xF0B7C754,0xE1CAAD2D,0x583176C5,
    0x48DB2A17,0xF120F1FF,0xE05D9B86,0x59A6406E,0xC2A74F74,0x7B5C949C,0x6A21FEE5,0xD3DA250D,
    0x8752E690,0x3EA93D78,0x2FD45701,0x962F8CE9,0x0D2E83F3,0xB4D5581B,0xA5A83262,0x1C53E98A,
  },

  {
    0x00000000,0xAE689191,0x87A02563,0x29C8B4F2,0xD4314C87,0x7A59DD16,0x539169E4,0xFDF9F875,
    0x73139F4F,0xDD7B0EDE,0xF4B3BA2C,0x5ADB2BBD,0xA722D3C8,0x094A4259,0x2082F6AB,0x8EEA673A,
    0xE6273E9E,0x484FAF0F,0x61871BFD,0xCFEF8A6C,0x32167219,0x9C7EE388,0xB5B6577A,0x1BDEC6EB,
    0x9534A1D1,0x3B5C3040,0x129484B2,0xBCFC1523,0x4105ED56,0xEF6D7CC7,0xC6A5C835,0x68CD59A4,
    0x173F7B7D,0xB957EAEC,0x909F5E1E,0x3EF7CF8F,0xC30E37FA,0x6D66A66B,0x44AE1299,0xEAC68308,
    0x642CE432,0xCA4475A3,0xE38CC151,0x4DE450C0,0xB01DA8B5,0x1E753924,0x37BD8DD6,0x99D51C47,
    0xF11845E3,0x5F70D472,0x76B86080,0xD8D0F111,0x25290964,0x8B4198F5,0xA2892C07,0x0CE1BD96,
    0x820BDAAC,0x2C634B3D,0x05ABFFCF,0xABC36E5E,0x563A962B,0xF85207BA,0xD19AB348,0x7FF222D9,
    0x2E7EF6FA,0x8016676B,0xA9DED399,0x07B64208,0xFA4FBA7D,0x54272BEC,0x7DEF9F1E,0xD3870E8F,
    0x5D6D69B5,0xF305F824,0xDACD4CD6,0x74A5DD47,0x895C2532,0x2734B4A3,0x0EFC0051,0xA09491C0,
    0xC859C864,0x663159F5,0x4FF9ED07,0xE1917C96,0x1C6884E3,0xB2001572,0x9BC8A180,0x35A03011,
    0xBB4A572B,0x1522C6BA,0x3CEA7248,0x9282E3D9,0x6F7B1BAC,0xC1138A3D,0xE8DB3ECF,0x46B3AF5E,
    0x39418D87,0x97291C16,0xBEE1A8E4,0x10893975,0xED70C100,0x43185091,0x6AD0E463,0xC4B875F2,
    0x4A5212C8,0xE43A8359,0xCDF237AB,0x639AA63A,0x9E635E4F,0x300BCFDE,0x19C37B2C,0xB7ABEABD,
    0xDF66B319,0x710E2288,0x58C6967A,0xF6AE07EB,0x0B57FF9E,0xA53F6E0F,0x8CF7DAFD,0x229F4B6C,
    0xAC752C56,0x021DBDC7,0x2BD50935,0x85BD98A4,0x784460D1,0xD62CF140,0xFFE445B2,0x518CD423,
    0x5CFDEDF4,0xF2957C65,0xDB5DC897,0x75355906,0x88CCA173,0x26A430E2,0x0F6C8410,0xA1041581,
    0x2FEE72BB,0x8186E32A,0xA84E57D8,0x0626C649,0xFBDF3E3C,0x55B7AFAD,0x7C7F1B5F,0xD2178ACE,
    0xBADAD36A,0x14B242FB,0x3D7AF609,0x93126798,0x6EEB9FED,0xC0830E7C,0xE94BBA8E,0x47232B1F,
    0xC9C94C25,0x67A1DDB4,0x4E696946,0xE001F8D7,0x1DF800A2,0xB3909133,0x9A5825C1,0x3430B450,
    0x4BC29689,0xE5AA0718,0xCC62B3EA,0x620A227B,0x9FF3DA0E,0x319B4B9F,0x1853FF6D,0xB63B6EFC,
    0x38D109C6,0x96B99857,0xBF712CA5,0x1119BD34,0xECE04541,0x4288D4D0,0x6B406022,0xC528F1B3,
    0xADE5A817,0x038D3986,0x2A458D74,0x842D1CE5,0x79D4E490,0xD7BC7501,0xFE74C1F3,0x501C5062,
    0xDEF63758,0x709EA6C9,0x5956123B,0xF73E83AA,0x0AC77BDF,0xA4AFEA4E,0x8D675EBC,0x230FCF2D,
    0x72831B0E,0xDCEB8A9F,0xF5233E6D,0x5B4BAFFC,0xA6B25789,0x08DAC618,0x211272EA,0x8F7AE37B,
    0x01908441,0xAFF815D0,0x8630A122,0x285830B3,0xD5A1C8C6,0x7BC95957,0x5201EDA5,0xFC697C34,
    0x94A42590,0x3ACCB401,0x130400F3,0xBD6C9162,0x40956917,0xEEFDF886,0xC7354C74,0x695DDDE5,
    0xE7B7BADF,0x49DF2B4E,0x60179FBC,0xCE7F0E2D,0x3386F658,0x9DEE67C9,0xB426D33B,0x1A4E42AA,
    0x65BC6073,0xCBD4F1E2,0xE21C4510,0x4C74D481,0xB18D2CF4,0x1FE5BD65,0x362D0997,0x98459806,
    0x16AFFF3C,0xB8C76EAD,0x910FDA5F,0x3F674BCE,0xC29EB3BB,0x6CF6222A,0x453E96D8,0xEB560749,
    0x839B5EED,0x2DF3CF7C,0x043B7B8E,0xAA53EA1F,0x57AA126A,0xF9C283FB,0xD00A3709,0x7E62A698,
    0xF088C1A2,0x5EE05033,0x7728E4C1,0xD9407550,0x24B98D25,0x8AD11CB4,0xA319A846,0x0D7139D7,
  }
#endif // CRC32_USE_LOOKUP_TABLE_SLICING_BY_16
};
#endif // NO_LUT


/////////////// CRC-32C with hardware acceleration
/* crc32c.c -- compute CRC-32C using the Intel crc32 instruction
 * Copyright (C) 2013 Mark Adler
 * Version 1.1  1 Aug 2013  Mark Adler
 */
/* Table for a quadword-at-a-time software crc. */
static pthread_once_t crc32c_once_sw = PTHREAD_ONCE_INIT;
static uint32_t crc32c_table[8][256];
#define POLY 0x82f63b78

/* Construct table for software CRC-32C calculation. */
static void crc32c_init_sw(void)
{
    uint32_t n, crc, k;

    for (n = 0; n < 256; n++) {
        crc = n;
        crc = crc & 1 ? (crc >> 1) ^ POLY : crc >> 1;
        crc = crc & 1 ? (crc >> 1) ^ POLY : crc >> 1;
        crc = crc & 1 ? (crc >> 1) ^ POLY : crc >> 1;
        crc = crc & 1 ? (crc >> 1) ^ POLY : crc >> 1;
        crc = crc & 1 ? (crc >> 1) ^ POLY : crc >> 1;
        crc = crc & 1 ? (crc >> 1) ^ POLY : crc >> 1;
        crc = crc & 1 ? (crc >> 1) ^ POLY : crc >> 1;
        crc = crc & 1 ? (crc >> 1) ^ POLY : crc >> 1;
        crc32c_table[0][n] = crc;
    }
    for (n = 0; n < 256; n++) {
        crc = crc32c_table[0][n];
        for (k = 1; k < 8; k++) {
            crc = crc32c_table[0][crc & 0xff] ^ (crc >> 8);
            crc32c_table[k][n] = crc;
        }
    }
}

/* Table-driven software version as a fall-back.  This is about 15 times slower
   than using the hardware instructions.  This assumes little-endian integers,
   as is the case on Intel processors that the assembler code here is for. */
static uint32_t crc32c_sw(uint32_t crci, const unsigned char *buf, size_t len)
{
    const unsigned char *next = buf;
    uint64_t crc;

    pthread_once(&crc32c_once_sw, crc32c_init_sw);
    crc = crci ^ 0xffffffff;
    while (len && ((uintptr_t)next & 7) != 0) {
        crc = crc32c_table[0][(crc ^ *next++) & 0xff] ^ (crc >> 8);
        len--;
    }
    while (len >= 8) {
        crc ^= *(uint64_t *)next;
        crc = crc32c_table[7][crc & 0xff] ^
              crc32c_table[6][(crc >> 8) & 0xff] ^
              crc32c_table[5][(crc >> 16) & 0xff] ^
              crc32c_table[4][(crc >> 24) & 0xff] ^
              crc32c_table[3][(crc >> 32) & 0xff] ^
              crc32c_table[2][(crc >> 40) & 0xff] ^
              crc32c_table[1][(crc >> 48) & 0xff] ^
              crc32c_table[0][crc >> 56];
        next += 8;
        len -= 8;
    }
    while (len) {
        crc = crc32c_table[0][(crc ^ *next++) & 0xff] ^ (crc >> 8);
        len--;
    }
    return (uint32_t)crc ^ 0xffffffff;
}

/* Multiply a matrix times a vector over the Galois field of two elements,
   GF(2).  Each element is a bit in an unsigned integer.  mat must have at
   least as many entries as the power of two for most significant one bit in
   vec. */
static inline uint32_t gf2_matrix_times(uint32_t *mat, uint32_t vec)
{
    uint32_t sum;

    sum = 0;
    while (vec) {
        if (vec & 1)
            sum ^= *mat;
        vec >>= 1;
        mat++;
    }
    return sum;
}

/* Multiply a matrix by itself over GF(2).  Both mat and square must have 32
   rows. */
static inline void gf2_matrix_square(uint32_t *square, uint32_t *mat)
{
    int n;

    for (n = 0; n < 32; n++)
        square[n] = gf2_matrix_times(mat, mat[n]);
}

/* Construct an operator to apply len zeros to a crc.  len must be a power of
   two.  If len is not a power of two, then the result is the same as for the
   largest power of two less than len.  The result for len == 0 is the same as
   for len == 1.  A version of this routine could be easily written for any
   len, but that is not needed for this application. */
static void crc32c_zeros_op(uint32_t *even, size_t len)
{
    int n;
    uint32_t row;
    uint32_t odd[32];       /* odd-power-of-two zeros operator */

    /* put operator for one zero bit in odd */
    odd[0] = POLY;              /* CRC-32C polynomial */
    row = 1;
    for (n = 1; n < 32; n++) {
        odd[n] = row;
        row <<= 1;
    }

    /* put operator for two zero bits in even */
    gf2_matrix_square(even, odd);

    /* put operator for four zero bits in odd */
    gf2_matrix_square(odd, even);

    /* first square will put the operator for one zero byte (eight zero bits),
       in even -- next square puts operator for two zero bytes in odd, and so
       on, until len has been rotated down to zero */
    do {
        gf2_matrix_square(even, odd);
        len >>= 1;
        if (len == 0)
            return;
        gf2_matrix_square(odd, even);
        len >>= 1;
    } while (len);

    /* answer ended up in odd -- copy to even */
    for (n = 0; n < 32; n++)
        even[n] = odd[n];
}

/* Take a length and build four lookup tables for applying the zeros operator
   for that length, byte-by-byte on the operand. */
static void crc32c_zeros(uint32_t zeros[][256], size_t len)
{
    uint32_t n;
    uint32_t op[32];

    crc32c_zeros_op(op, len);
    for (n = 0; n < 256; n++) {
        zeros[0][n] = gf2_matrix_times(op, n);
        zeros[1][n] = gf2_matrix_times(op, n << 8);
        zeros[2][n] = gf2_matrix_times(op, n << 16);
        zeros[3][n] = gf2_matrix_times(op, n << 24);
    }
}

/* Apply the zeros operator table to crc. */
static inline uint32_t crc32c_shift(uint32_t zeros[][256], uint32_t crc)
{
    return zeros[0][crc & 0xff] ^ zeros[1][(crc >> 8) & 0xff] ^
           zeros[2][(crc >> 16) & 0xff] ^ zeros[3][crc >> 24];
}

/* Block sizes for three-way parallel crc computation.  LONG and SHORT must
   both be powers of two.  The associated string constants must be set
   accordingly, for use in constructing the assembler instructions. */
#define LONG 8192
#define LONGx1 "8192"
#define LONGx2 "16384"
#define SHORT 256
#define SHORTx1 "256"
#define SHORTx2 "512"

/* Tables for hardware crc that shift a crc by LONG and SHORT zeros. */
static pthread_once_t crc32c_once_hw = PTHREAD_ONCE_INIT;
static uint32_t crc32c_long[4][256];
static uint32_t crc32c_short[4][256];

/* Initialize tables for shifting crcs. */
static void crc32c_init_hw(void)
{
    crc32c_zeros(crc32c_long, LONG);
    crc32c_zeros(crc32c_short, SHORT);
}

#if defined(_WIN64)

/* Compute CRC-32C using the Intel hardware instruction. */
static uint32_t crc32c_hw(uint32_t crc, const unsigned char *buf, size_t len)
{
    const unsigned char *next = buf;
    const unsigned char *end;
    uint64_t crc0, crc1, crc2;      /* need to be 64 bits for crc32q */

    /* populate shift tables the first time through */
    pthread_once(&crc32c_once_hw, crc32c_init_hw);

    /* pre-process the crc */
    crc0 = crc ^ 0xffffffff;

    /* compute the crc for up to seven leading bytes to bring the data pointer
       to an eight-byte boundary */
    while (len && ((uintptr_t)next & 7) != 0) {
        __asm__("crc32b\t" "(%1), %0"
                : "=r"(crc0)
                : "r"(next), "0"(crc0));
        next++;
        len--;
    }

    /* compute the crc on sets of LONG*3 bytes, executing three independent crc
       instructions, each on LONG bytes -- this is optimized for the Nehalem,
       Westmere, Sandy Bridge, and Ivy Bridge architectures, which have a
       throughput of one crc per cycle, but a latency of three cycles */
    while (len >= LONG*3) {
        crc1 = 0;
        crc2 = 0;
        end = next + LONG;
        do {
            __asm__("crc32q\t" "(%3), %0\n\t"
                    "crc32q\t" LONGx1 "(%3), %1\n\t"
                    "crc32q\t" LONGx2 "(%3), %2"
                    : "=r"(crc0), "=r"(crc1), "=r"(crc2)
                    : "r"(next), "0"(crc0), "1"(crc1), "2"(crc2));
            next += 8;
        } while (next < end);
        crc0 = crc32c_shift(crc32c_long, crc0) ^ crc1;
        crc0 = crc32c_shift(crc32c_long, crc0) ^ crc2;
        next += LONG*2;
        len -= LONG*3;
    }

    /* do the same thing, but now on SHORT*3 blocks for the remaining data less
       than a LONG*3 block */
    while (len >= SHORT*3) {
        crc1 = 0;
        crc2 = 0;
        end = next + SHORT;
        do {
            __asm__("crc32q\t" "(%3), %0\n\t"
                    "crc32q\t" SHORTx1 "(%3), %1\n\t"
                    "crc32q\t" SHORTx2 "(%3), %2"
                    : "=r"(crc0), "=r"(crc1), "=r"(crc2)
                    : "r"(next), "0"(crc0), "1"(crc1), "2"(crc2));
            next += 8;
        } while (next < end);
        crc0 = crc32c_shift(crc32c_short, crc0) ^ crc1;
        crc0 = crc32c_shift(crc32c_short, crc0) ^ crc2;
        next += SHORT*2;
        len -= SHORT*3;
    }

    /* compute the crc on the remaining eight-byte units less than a SHORT*3
       block */
    end = next + (len - (len & 7));
    while (next < end) {
        __asm__("crc32q\t" "(%1), %0"
                : "=r"(crc0)
                : "r"(next), "0"(crc0));
        next += 8;
    }
    len &= 7;

    /* compute the crc for up to seven trailing bytes */
    while (len) {
        __asm__("crc32b\t" "(%1), %0"
                : "=r"(crc0)
                : "r"(next), "0"(crc0));
        next++;
        len--;
    }

    /* return a post-processed crc */
    return (uint32_t)crc0 ^ 0xffffffff;
}

/* Check for SSE 4.2.  SSE 4.2 was first supported in Nehalem processors
   introduced in November, 2008.  This does not check for the existence of the
   cpuid instruction itself, which was introduced on the 486SL in 1992, so this
   will fail on earlier x86 processors.  cpuid works on all Pentium and later
   processors. */
#define SSE42(have) \
    do { \
        uint32_t eax, ecx; \
        eax = 1; \
        __asm__("cpuid" \
                : "=c"(ecx) \
                : "a"(eax) \
                : "%ebx", "%edx"); \
        (have) = (ecx >> 20) & 1; \
    } while (0)

/* Compute a CRC-32C.  If the crc32 instruction is available, use the hardware
   version.  Otherwise, use the software version. */
#endif

uint32_t crc32c(uint32_t crc, const unsigned char *buf, size_t len)
{
#if  defined(_WIN64)
    int sse42;
    SSE42(sse42);
	//printf("SSE42 %d\n",sse42);
    return sse42 ? crc32c_hw(crc, buf, len) : crc32c_sw(crc, buf, len);
#else
    return crc32c_sw(crc, buf, len);
#endif

}





//////////////////// zpaq stuff

// Base of InputArchive and OutputArchive
class ArchiveBase {
protected:
  libzpaq::AES_CTR* aes;  // NULL if not encrypted
  FP fp;          // currently open file or FPNULL
public:
  ArchiveBase(): aes(0), fp(FPNULL) {}
  ~ArchiveBase() {
    if (aes) delete aes;
    if (fp!=FPNULL) fclose(fp);
  }  
  bool isopen() {return fp!=FPNULL;}
};

// An InputArchive supports encrypted reading
class InputArchive: public ArchiveBase, public libzpaq::Reader {
  vector<int64_t> sz;  // part sizes
  int64_t off;  // current offset
  string fn;  // filename, possibly multi-part with wildcards
public:

  // Open filename. If password then decrypt input.
  InputArchive(const char* filename, const char* password=0);

  // Read and return 1 byte or -1 (EOF)
  int get() {
    error("get() not implemented");
    return -1;
  }

  // Read up to len bytes into obuf at current offset. Return 0..len bytes
  // actually read. 0 indicates EOF.
  int read(char* obuf, int len) {
    int nr=fread(obuf, 1, len, fp);
    if (nr==0) {
      seek(0, SEEK_CUR);
      nr=fread(obuf, 1, len, fp);
    }
    if (nr==0) return 0;
    if (aes) aes->encrypt(obuf, nr, off);
    off+=nr;
	
///	printf("BLOKKO len %d\n",len);
	
    return nr;
  }

  // Like fseeko()
  void seek(int64_t p, int whence);

  // Like ftello()
  int64_t tell() {
    return off;
  }

	int64_t totalsize()
	{
		int64_t temp=0;
		for (unsigned i=0; i<sz.size(); ++i) 
			temp+=sz[i];
		return temp;
	}
};

// Like fseeko. If p is out of range then close file.
void InputArchive::seek(int64_t p, int whence) {
  if (!isopen()) return;

  // Compute new offset
  if (whence==SEEK_SET) off=p;
  else if (whence==SEEK_CUR) off+=p;
  else if (whence==SEEK_END) {
    off=p;
    for (unsigned i=0; i<sz.size(); ++i) off+=sz[i];
  }

  // Optimization for single file to avoid close and reopen
  if (sz.size()==1) {
    fseeko(fp, off, SEEK_SET);
    return;
  }

  // Seek across multiple files
  assert(sz.size()>1);
  int64_t sum=0;
  unsigned i;
  for (i=0;; ++i) {
    sum+=sz[i];
    if (sum>off || i+1>=sz.size()) break;
  }
  const string next=subpart(fn, i+1);
  fclose(fp);
  fp=fopen(next.c_str(), RB);
  if (fp==FPNULL) ioerr(next.c_str());
  fseeko(fp, off-sum, SEEK_END);
}

// Open for input. Decrypt with password and using the salt in the
// first 32 bytes. If filename has wildcards then assume multi-part
// and read their concatenation.

InputArchive::InputArchive(const char* filename, const char* password):
    /*off(0),*/ fn(filename) {
  assert(filename);
  off=0;
 

  // Get file sizes
  const string part0=subpart(filename, 0);
  for (unsigned i=1; ; ++i) {
    const string parti=subpart(filename, i);
    if (i>1 && parti==part0) break;
    fp=fopen(parti.c_str(), RB);
    if (fp==FPNULL) break;
    fseeko(fp, 0, SEEK_END);
    sz.push_back(ftello(fp));
    fclose(fp);
  }

  // Open first part
  const string part1=subpart(filename, 1);
  fp=fopen(part1.c_str(), RB);
  if (!isopen()) ioerr(part1.c_str());
  assert(fp!=FPNULL);

  // Get encryption salt
  if (password) {
    char salt[32], key[32];
    if (fread(salt, 1, 32, fp)!=32) error("cannot read salt");
    libzpaq::stretchKey(key, password, salt);
    aes=new libzpaq::AES_CTR(key, 32, salt);
    off=32;
  }
}

// An Archive is a file supporting encryption
class OutputArchive: public ArchiveBase, public libzpaq::Writer {
  int64_t off;    // preceding multi-part bytes
  unsigned ptr;   // write pointer in buf: 0 <= ptr <= BUFSIZE
  enum {BUFSIZE=1<<16};
  char buf[BUFSIZE];  // I/O buffer
public:

  // Open. If password then encrypt output.
  OutputArchive(const char* filename, const char* password=0,
                const char* salt_=0, int64_t off_=0);

  // Write pending output
  void flush() {
    assert(fp!=FPNULL);
    if (aes) aes->encrypt(buf, ptr, ftello(fp)+off);
    fwrite(buf, 1, ptr, fp);
    ptr=0;
  }

  // Position the next read or write offset to p.
  void seek(int64_t p, int whence) {
    if (fp!=FPNULL) {
      flush();
      fseeko(fp, p, whence);
    }
    else if (whence==SEEK_SET) off=p;
    else off+=p;  // assume at end
  }

  // Return current file offset.
  int64_t tell() const {
    if (fp!=FPNULL) return ftello(fp)+ptr;
    else return off;
  }

  // Write one byte
  void put(int c) {
    if (fp==FPNULL) ++off;
    else {
      if (ptr>=BUFSIZE) flush();
      buf[ptr++]=c;
    }
  }

  // Write buf[0..n-1]
  void write(const char* ibuf, int len) {
    if (fp==FPNULL) off+=len;
    else while (len-->0) put(*ibuf++);
  }

  // Flush output and close
  void close() {
    if (fp!=FPNULL) {
      flush();
      fclose(fp);
    }
    fp=FPNULL;
  }
};

// Create or update an existing archive or part. If filename is ""
// then keep track of position in off but do not write to disk. Otherwise
// open and encrypt with password if not 0. If the file exists then
// read the salt from the first 32 bytes and off_ must be 0. Otherwise
// encrypt assuming off_ previous bytes, of which the first 32 are salt_.
// If off_ is 0 then write salt_ to the first 32 bytes.

OutputArchive::OutputArchive(const char* filename, const char* password,
    const char* salt_, int64_t off_): /*off(off_), */ptr(0) {
  assert(filename);
  off=off_;
  if (!*filename) return;

  // Open existing file
  char salt[32]={0};
  fp=fopen(filename, RBPLUS);
  if (isopen()) {
    if (off!=0) error("file exists and off > 0");
    if (password) {
      if (fread(salt, 1, 32, fp)!=32) error("cannot read salt");
      if (salt_ && memcmp(salt, salt_, 32)) error("salt mismatch");
    }
    seek(0, SEEK_END);
  }

  // Create new file
  else {
    fp=fopen(filename, WB);
    if (!isopen()) ioerr(filename);
    if (password) {
      if (!salt_) error("salt not specified");
      memcpy(salt, salt_, 32);
      if (off==0 && fwrite(salt, 1, 32, fp)!=32) ioerr(filename);
    }
  }

  // Set up encryption
  if (password) {
    char key[32];
    libzpaq::stretchKey(key, password, salt);
    aes=new libzpaq::AES_CTR(key, 32, salt);
  }
}


////////////////////////////// misc ///////////////////////////////////
//zpaq
// For libzpaq output to a string less than 64K chars
struct StringWriter: public libzpaq::Writer {
  string s;
  void put(int c) {
    if (s.size()>=65535) error("string too long");
    s+=char(c);
  }
};





// enum for version

static const int64_t HT_BAD=   -0x7FFFFFFFFFFFFFFALL;  // no such frag
static const int64_t DEFAULT_VERSION=99999999999999LL; // unless -until


// fragment hash table entry
struct HT 
{
	uint32_t crc32;			// new: take the CRC-32 of the fragment
	uint32_t crc32size;

	unsigned char sha1[20]; // fragment hash
	int usize;      		// uncompressed size, -1 if unknown, -2 if not init
	int64_t csize;  		// if >=0 then block offset else -fragment number
  
	HT(const char* s=0, int u=-2) 
	{
		crc32=0;
		crc32size=0;
		csize=0;
		if (s) 
			memcpy(sha1, s, 20);
		else 
			memset(sha1, 0, 20);
		usize=u;
	}
};

struct DTV 
{
  int64_t date;          // decimal YYYYMMDDHHMMSS (UT) or 0 if deleted
  int64_t size;          // size or -1 if unknown
  int64_t attr;          // first 8 attribute bytes
  double csize;          // approximate compressed size
  vector<unsigned> ptr;  // list of fragment indexes to HT
  int version;           // which transaction was it added?
  
  DTV(): date(0), size(0), attr(0), csize(0), version(0) {}
};



/// a "fake" class to mimic normal filesystem write, reducing coding complexity
class franzfs
{
	private:
	public:
	char*		data;
	uint64_t	filesize;
	uint64_t 	position;
	
	/*
	int ramseek(int64_t i_offset)
	{
		position=i_offset;
	}
	*/

	size_t ramread(size_t i_size,char* o_ptr)
	{
		if (o_ptr==NULL)
			return 0;
		if (i_size==0)
			return 0;
		if (!data)
		{
			printf("22938: Guru data is null\n");
			return 0; 
		}
		if ((position+i_size)>filesize)
			i_size=filesize-position;
		memcpy(o_ptr,data+position,i_size);
		position+=i_size;
		return i_size;
	}
	
	size_t ramwrite(uint64_t i_offset,char* i_ptr, size_t i_size)
	{
		if (i_offset>filesize)
		{
			printf("22953: i_offset greater then filesize %s %s\n",migliaia(i_offset),migliaia2(filesize));
			return 0;
		}
		if (i_ptr==NULL)
			return 0;
		if (i_size==0)
			return 0;
		if (!data)
		{
			printf("35254: Guru data is null\n");
			return 0; 
		}
		position=i_offset;
		if (position+i_size>filesize)
		{
			printf("35248: cannot write beyond size %s %s %s\n",migliaia(position),migliaia2(i_size),migliaia3(filesize));
			return 0;
		}
		memcpy(data+position,i_ptr,i_size);
		position+=i_size;
		return i_size;
	}
	
	franzfs(){data=NULL;position=0;}
	
	bool init(int64_t i_size) 
	{
		data=(char*)malloc(i_size);
		if (data==NULL)
		{
			printf("35250: GURU on malloc\n");
			return false;
		}
		
		memset(data,0,i_size); // required by zpaq extraction method

		g_ramdisksize+=i_size;
		filesize=i_size;
		if (flagdebug)
			printf("23000: allocated %21s\n",migliaia(i_size));
		return true;
	}
	
	bool reset() 
	{
		if (data==NULL)
		{
			printf("23001: GURU on reset\n");
			return false;
		}
		if (filesize==0)
		{
			printf("23006: GURU on filesize\n");
			return false;
		}
		free(data);
		g_ramdisksize-=filesize;
		filesize=0;
		if (flagdebug)
			printf("Deallocati  %s\n",migliaia(filesize));
		return true;
	}
};

#define	FIX_TOOLONG 	1;
#define	FIX_ADS 		2;
#define	FIX_UTF8		4;
#define FIX_RESERVED 	8;
#define FIX_WINDOWSPATH	16;
#define	FIX_WINDOWSUNC	32;

// filename entry
struct DT   // if you get some warning here, update your compiler!
{
	int64_t date;          	// if you get some warning here, update your compiler!
	// decimal YYYYMMDDHHMMSS (UT) or 0 if deleted
	int64_t size;          	// size or -1 if unknown
	int64_t attr;          	// first 8 attribute bytes
	int64_t data;          	// sort key or frags written. -1 = do not write
	vector<unsigned> ptr;  	// fragment list
	vector<DTV> dtv;       	// list of versions
	int written;           	// 0..ptr.size() = fragments output. -1=ignore

	string outputname;		// written filename
	string hexhash;			// for new functions, not for add
	string hashtype;		// for paranoid()
	
/*
	new FRANZOFFSET
*/
	char 			franz_block[FRANZOFFSETSHA256];
	int				franz_block_size;
	uint32_t 		file_crc32;
	int64_t			hashedsize;
	int		chunk;
	uint32_t		filefix;	// something strange?
	int64_t			expectedsize;
/// now using pointer to shrink DT from more then 1K to 296 bytes
	XXH3_state_t	*pfile_xxh3;  // this is the problem: XXH3's 64-byte align not always work with too old-too new compilers
    XXHash64 		*pfile_xxhash64;
	libzpaq::SHA256 *pfile_sha256;
	libzpaq::SHA1 	*pfile_sha1;
	SHA3			*pfile_sha3;
	MD5				*pfile_md5;
	blake3_hasher 	*pfile_blake3;
	
	franzfs			*pramfile;
	
	DT(): date(0), size(0), attr(0), data(0),written(-1),franz_block_size(FRANZOFFSETSHA256),file_crc32(0),hashedsize(0),chunk(-1),filefix(0),expectedsize(0)
	{
		memset(franz_block,0,sizeof(franz_block));
		hexhash	="";
		hashtype="";
		outputname="";
		pfile_xxhash64=NULL;
		if (g_franzotype==FRANZO_XXHASH64)
			pfile_xxhash64=new XXHash64(0);

		pfile_md5=NULL;
		if (g_franzotype==FRANZO_MD5)
			pfile_md5=new MD5;
			
		pfile_sha1=NULL;
		if (g_franzotype==FRANZO_SHA_1)
			pfile_sha1=new libzpaq::SHA1;
			
		pfile_sha256=NULL;
		if (g_franzotype==FRANZO_SHA_256)
			pfile_sha256=new libzpaq::SHA256;
			
		pfile_sha3=NULL;
		if (g_franzotype==FRANZO_SHA3)
			pfile_sha3=new SHA3;
				
	/// beware of time and space, but now we are sure to maintain 64 byte alignment
		pfile_xxh3=NULL;
		if (g_franzotype==FRANZO_XXH3)
		{
			pfile_xxh3=(XXH3_state_t*)aligned_malloc(64, sizeof(XXH3_state_t));
			(void)XXH3_128bits_reset(pfile_xxh3);
		}
		
		pfile_blake3=NULL;
		if (g_franzotype==FRANZO_BLAKE3)
		{
			pfile_blake3=(blake3_hasher*)malloc(sizeof(blake3_hasher));
			blake3_hasher_init(pfile_blake3);
		}
		
		pramfile=NULL;
		
	
	}
};
typedef map<string, DT> DTMap;




// list of blocks to extract
struct Block 
{
  int64_t offset;       // location in archive
  int64_t usize;        // uncompressed size, -1 if unknown (streaming)
  int64_t bsize;        // compressed size
  vector<DTMap::iterator> files;  // list of files pointing here
  unsigned start;       // index in ht of first fragment
  unsigned size;        // number of fragments to decompress
  unsigned frags;       // number of fragments in block
  unsigned extracted;   // number of fragments decompressed OK
  enum {READY, WORKING, GOOD, BAD} state;
  Block(unsigned s, int64_t o): offset(o), usize(-1), bsize(0), start(s),
      size(0), frags(0), extracted(0), state(READY) {}
};

// Version info
struct VER 
{
  int64_t date;          // Date of C block, 0 if streaming
  int64_t lastdate;      // Latest date of any block
  int64_t offset;        // start of transaction C block
  int64_t data_offset;   // start of first D block
  int64_t csize;         // size of compressed data, -1 = no index
  int updates;           // file updates
  int deletes;           // file deletions
  unsigned firstFragment;// first fragment ID
  int64_t usize;         // uncompressed size of files
  
  VER() {memset(this, 0, sizeof(*this));}
};


// Windows API functions not in Windows XP to be dynamically loaded
#ifndef unix
typedef HANDLE (WINAPI* FindFirstStreamW_t)
                   (LPCWSTR, STREAM_INFO_LEVELS, LPVOID, DWORD);
FindFirstStreamW_t findFirstStreamW=0;
typedef BOOL (WINAPI* FindNextStreamW_t)(HANDLE, LPVOID);
FindNextStreamW_t findNextStreamW=0;

typedef BOOL (WINAPI* GetFinalPathNameByHandleW_t)(HANDLE, LPWSTR,DWORD,DWORD);
GetFinalPathNameByHandleW_t getFinalPathNameByHandleW=0;
#endif


class CompressJob;

// Do everything. 
// Very weird approach, this is about plain-old C, almost zero ++

class Jidac 
{
public:
	int 	doCommand(int argc, const char** argv);
	friend 	ThreadReturn decompressThread(void* arg);
	friend 	ThreadReturn decompressthreadramdisk(void* arg);
	friend 	struct ExtractJob;
	void usageall		(string i_command); // verbose help
	
private:

	string				fullcommandline;
	vector<string> 		results;     	// warning and errors
	
	string	zpaqfranzexename;
	
	MAPPAHELP help_map;					/// maps: string command, helpfunctions(bool,bool)
	MAPPAHELP switches_map;	
	string archive;           			// archive name
	vector<string> 		files;     		// filename args
	
	vector<int64_t> 	files_size;		// instead of a struct many vectors
	vector<uint64_t> 	files_count;	// why? a bit faster
	vector<uint64_t> 	files_time;
	vector<DTMap> 		files_edt;

	
	int all;                  			// -all option
	int fragment;             			// -fragment option
	int summary;              			// do summary if >0, else brief. OLD 7.15 summary option if > 0, detailed if -1
	int howmanythreads;              	// default is number of cores
	unsigned int menoenne;
	int64_t date;             			// now as decimal YYYYMMDDHHMMSS (UT)
	int64_t version;          			// version number or 14 digit date

	string method;            			// default "1"

	const char* index;        			// index option

	string	plainpassword;
	const char* password;     			// points to password_string or NULL
	char password_string[32]; 			// hash of -key argument
	char new_password_string[32]; 		// -repack hashed password
	const char* new_password; 			// points to new_password_string or NULL

	string nottype;           			// -not =...
	string sfxnottype;           		// -not =...
	vector<string> notfiles;  			// list of prefixes to exclude
	vector<string> sfxnotfiles;  		// list of prefixes to exclude
	vector<string> tofiles;   			// -to option
	vector<string> onlyfiles; 			// list of prefixes to include
	vector<string> chunkfiles; 			// list of prefixes to include
	vector<string> sfxonlyfiles; 		// list of prefixes to include
	vector<string> alwaysfiles; 		// list of prefixes to pack ALWAYS
	
	string repack;       				// -repack output file
	
	map<int, string> mappacommenti;
	string versioncomment;

	bool flagnoattributes;        		// -noattributes option
	bool flagforce;               		// -force option
	bool flagcomment;
	bool flagtest;
	bool flagskipzfs;
	bool flagnoqnap;					// exclude @Recently-Snapshot and @Recycle
	bool flagforcewindows;        		// force alterate data stream $DATA$, system volume information
	bool flagnopath;					// do not store path
	bool flagnosort;              		// do not sort files std::sort(vf.begin(), vf.end(), compareFilename);
	bool flagnochecksum;				// disable (franzotype 0)
	uint32_t filelength;
	uint32_t dirlength;
	string searchfrom;					// search something in path
	string replaceto;					// replace (something like awk)
	string searchhash;
	
	// Archive state
	int64_t dhsize;           			// total size of D blocks according to H blocks
	int64_t dcsize;           			// total size of D blocks according to C blocks
	vector<HT> ht;            			// list of fragments
	DTMap dt;                 			// set of files in archive
	DTMap edt;                			// set of external files to add or compare
	vector<Block> block;      			// list of data blocks to extract
	vector<VER> ver;          			// version info

	
  // Commands
	int add();                			// add, return 1 if error else 0
	int extract();            			// extract, return 1 if error else 0
	int setpassword();					// set or change password 
	int extractw();            			// chunked-extract, return 1 if error else 0
	int info();							// wrap for list
	int list();               			// list (one parameter) / check (more than one)
	int zpaqdirsize();               	// get size of a folder
	int testverify();					// check
	int kill();							// align to archive
	int utf();							// check-sanitize strange filename
	int test();           				// test, return 1 if error else 0
	int verify(bool i_readfile);        // verify onfilesystem, return 1 if error else 0
	int consolidate(string i_archive);	// concat files into one
	int summa();						// get hash / or sum
	int decimation();					// get only the newest file
	int deduplicate();					// get hash / or sum
	int paranoid();						// paranoid test by unz. Really slow & lot of RAM
	int fillami();						// media check
	int dir();							// Windows-like dir command
	int robocopy();						// Like robocopy, but with XLS
	int mycopy();						// Like copy, but with progress
	int zero();							// Delete empty directory
	int trim();							// Trim incomplete transaction
	int rd();							// Remove dir (rd /s or rm-f)
	int purgersync();					// Purge rsync temporary file
	int sfx();							// Write autoextract module
	int dircompare(bool i_flagonlysize,bool i_flagrobocopy);
	int benchmark();
	int	zfs(string command);
	int windowsc();						// Backup (kind of) drive C:
	int adminrun();						// Run windowsc()
	
	void load_help_map	();					// not in the constructor!
	void helphelp		();        			// help
	void usage			();        			// help
	void examples		(string i_command);	// some examples
	
	void join_split();
	
	
  // Support functions
	void	reset();
	void 	printsanitizeflags();
	
	string 	rename(string name);           // rename from -to
	int64_t read_archive(const char* arc, int *errors=0, int i_myappend=0,bool i_quiet=false);  // read arc
	bool 	isselected(const char* filename, bool rn,int64_t i_size);// files, -only, -not
	
	void 	scandir(bool i_checkifselected,DTMap& i_edt,string filename, bool i_recursive=true);        // scan dirs to dt
	void 	addfile(bool i_checkifselected,DTMap& i_edt,string filename, int64_t edate, int64_t esize,int64_t eattr);          // add external file to dt
	int64_t franzparallelscandir(bool i_flaghash,bool i_recursive,bool i_forcedir);
	
	bool 	equal(DTMap::const_iterator p, const char* filename, uint32_t &o_crc32,string i_myhashtype,string i_myhash,string& o_hash);// compare file contents with p
	
	void 	write715attr(libzpaq::StringBuffer& i_sb, uint64_t i_data, unsigned int i_quanti);
	void 	writefranzattr(libzpaq::StringBuffer& i_sb, uint64_t i_data, unsigned int i_quanti,string i_filename,uint32_t i_crc32fromfragments,uint32_t i_crc32,string i_thehash);

	
	int 	enumeratecomments();
	int 	searchcomments(string i_testo,vector<DTMap::iterator> &filelist);
	
	string 	zfs_get_snaplist(string i_header,string i_footer,vector<string>& o_array_primachiocciola,vector<string>& o_array_dopochiocciola);
	string 	sanitizzanomefile(string i_filename,int i_filelength,int& io_collisioni,MAPPAFILEHASH& io_mappacollisioni);

	void 	getpasswordifempty();
	string 	getpasswordblind();
	string 	getpassword();

	int		writesfxmodule(string i_filename);
	int 	decompress_sfx_to_file(FILE* i_outfile);

	int 	extractqueue2(int i_chunk,int i_chunksize);
	int 	multiverify(vector <s_fileandsize>& i_arrayfilename);
	bool 	removetempdirifempty(string i_folder,bool i_deleteifsizezero);
	void 	handleflaglongpath();
	bool 	getfoldersize(string i_folder,uint64_t& o_totalsize,uint32_t & o_totalfile,uint32_t& o_totalfolder);
	uint64_t hashastringa(string& i_string);
	uint32_t casekollision(DTMap& i_dtmap,vector<string>& o_collisions,bool i_fix);
	void 	changedtmapkey(string i_oldkey,string i_newkey);
	
	int 	removeemptydirs(string i_folder,bool i_kill);
	
	int 	writeresource(string i_filename,bool i_force,const char* i_mime64);
	int 	decompress_mime64_to_file(FILE* i_outfile,const char* i_mime64);


};

///	detecting case collision: xxhash64 is more than enough (fast and compact)
uint64_t Jidac::hashastringa(string& i_string)
{
	uint64_t myseed = 0;
	XXHash64 myhash(myseed);
	myhash.add(i_string.c_str(),i_string.size());
	return myhash.hash();
}

/// change the key of a map is not so easy (slow)
/// this is something like filesystem behavior: just add and mark as deleted 
/// note: this is find, not binary search. quite slow, but resilient
void Jidac::changedtmapkey(string i_oldkey,string i_newkey)
{
	DTMap::iterator myp=dt.find(i_oldkey);
	if (myp==dt.end())
		return;
	DT olddt=myp->second;
	dt[i_newkey]=olddt;
	myp->second.date=0;		///fake delete
}

uint32_t Jidac::casekollision(DTMap& i_dtmap,vector<string>& o_collisions,bool i_fix=false)
{
	int64_t	startkoll=mtime();
	if (flagverbose)
		printf("Case-collision checks on %s files ",migliaia(i_dtmap.size()));
	uint32_t fixed=0;
	o_collisions.clear();
	vector<uint64_t>	hashedstrings;
	for (DTMap::iterator p=i_dtmap.begin(); p!=i_dtmap.end(); p++) 
		if (all || p->second.date)
		{
			string		fn			=rename(p->first);
			string 		filename	=stringtolower(fn);
			
			uint64_t hashato=hashastringa(filename);
			
			if (binary_search(hashedstrings.begin(),hashedstrings.end(),hashato)==true)
			{
				if (i_fix)
				{
					char	buf[10];
					string 	percorso	=extractfilepath(fn);
					string	nomefile	=prendinomefileebasta(fn);
					string	estensione	=prendiestensione(fn);
					int		iterazione	=1;
					string	rifatto		="";
					
					do
					{
						sprintf(buf,"_%08d",iterazione++);
						if (percorso!="")
							rifatto=percorso;
						string pezzetto=buf;
						if (nomefile!="")
							rifatto+=nomefile+buf;
						if (estensione!="")
							rifatto+="."+estensione;
						
						hashato=hashastringa(rifatto);
						if (binary_search(hashedstrings.begin(),hashedstrings.end(),hashato)==false)
							break;
					}
					while (iterazione<1000);
			
					if (iterazione<1000)
					{
						changedtmapkey(p->first,rifatto);
						fixed++;
					}
					else
					{
						printf("23507: ERROR IMPOSSIBLE TO 'DECASE' ");
						printUTF8(filename.c_str());
						printf("\n");
					}
				}
				else
					o_collisions.push_back(fn);

			}
			else
			{
				auto it = std::upper_bound(hashedstrings.cbegin(),hashedstrings.cend(),hashato); 
				hashedstrings.insert(it,hashato);
			}
		}
	int64_t	endkoll=mtime();
	if (flagverbose)
		printf("done in %.2fs\n",(endkoll-startkoll)*0.001);
	
	return (fixed);
}


/// "smarter" joiner, to be implemented
void Jidac::join_split() 
{
/*
  // Read archive and names of files to join
  const int64_t csize=read_archive(archive.c_str());
  printf("sono qui\n");
  // Test that version dates are in order and that fragment IDs are contiguous
    // Get date, frag from archive
    unsigned hpos=ht.size();  // next fragment ID expected
    int64_t dpos=0;
    if (ver.size()>0) dpos=ver.back().date;  // latest version date
      printf(
          "   File size   Previous end date   Fragment   File name\n"
          "-------------- ------------------- ---------- ---------\n");
     {
      printf("%14.0f %s %10d ",
          csize+0.0, "                   ", 1);
      printUTF8(archive.c_str());
      printf("\n");
    }
	*/
/*
    // Get salt from encrypted archive and set up key
    libzpaq::AES_CTR* aes=0;
    int64_t eoff=0;
    if (password && csize>=32) {
      InputFile in;
      if (in.open(archive.c_str())) {
        char salt[32];
        if (in.read(salt, 32)==32) {
          char key[32];
          libzpaq::stretchKey(key, password, salt);
          aes=new libzpaq::AES_CTR(key, 32, salt);
          eoff=csize;
        }
        in.close();
      }
    }

    // Scan files
    for (DTMap::iterator p=dt.begin(); p!=dt.end(); ++p) {
      if (p->second.written!=0 || p->second.edate==0
          || p->first=="" || p->first[p->first.size()-1]=='/')
        continue;  // skip directories
      if (p->second.esize>=quiet) {
        fprintf(con, "%14.0f %s %10d ",
            p->second.esize+0.0, dateToString(dpos).c_str(), hpos);
          printUTF8(p->first.c_str(), con);
        fprintf(con, "\n");
      }

      // Get encryption salt from first file
      InputFile in;
      if (password && eoff<32 && !aes && in.open(p->first.c_str())) {
        char salt[32], key[32];
        in.read(salt, 32);
        libzpaq::stretchKey(key, password, salt);
        aes=new libzpaq::AES_CTR(key, 32, salt);
        in.close();
      }

      // Input files must be in ZPAQ journaling format.
      // Scan segment headers. Names must be of the form
      // "jDCYYYYMMDDHHMMSSxNNNNNNNNNN" in ascending order.
      // If x is h, then N must equal hpos and YYYYMMDDHHMMSS > dpos.
      // Then update dpos=YYYYMMSSHHMMSS and add hsize to hpos.
      // where hsize is from the uncompressed comment size (comment-4)/24

      if (!in.open(p->first.c_str(), 0, aes, eoff))
        error("cannot read file");
      if (aes && eoff<32) in.seek(32, SEEK_SET);
      ++dpos;
      libzpaq::Decompresser d;
      d.setInput(&in);
      bool found=false;
      while (d.findBlock()) {
        StringWriter filename, comment;
        while (d.findFilename(&filename)) {
          found=true;
          d.readComment(&comment);

          // Test for journaling format
          if (size(filename.s)!=28
              || filename.s.substr(0, 3)!="jDC"
              || size(comment.s)<5
              || comment.s.substr(comment.s.size()-5)!=" jDC\x01")
            error("not in ZPAQ journaling format");

          // Test for dates in order
          int64_t hdate=0;  // read date from filename
          for (int i=3; i<17; ++i) {
            if (!isdigit(filename.s[i])) error("non-digit in date");
            hdate=hdate*10+filename.s[i]-'0';
          }
          if (hdate<dpos) error("dates out of order");
          dpos=hdate;

          // Test for contiguous fragments
          if (filename.s[17]=='h') {
            unsigned hfrag=0;
            for (int i=18; i<28; ++i) {
              if (!isdigit(filename.s[i])) error("non-digit in frag ID");
              hfrag=hfrag*10+filename.s[i]-'0';
            }
            if (hfrag!=hpos) error("fragments out of order");
            hpos+=(atoi(comment.s.c_str())-4)/24;
          }

          filename.s="";
          comment.s="";
          d.readSegmentEnd();
        }
      }
      if (aes) eoff+=in.tell();
      in.close();
      if (!found) error("Not a ZPAQ file");
    }
    if (aes) delete aes;
  }

  // Concatenate
  if (archive=="") return;
  OutputFile out;
  if (!out.open(archive.c_str())) error("cannot append archive");
  out.truncate(csize);
  for (DTMap::iterator p=dt.begin(); p!=dt.end(); ++p) {
    if (p->second.written!=0 || p->second.edate==0
        || p->first=="" || p->first[p->first.size()-1]=='/')
      continue;  // skip directories
    InputFile in;
    if (!in.open(p->first.c_str())) error("cannot read file");
    int c;
    while ((c=in.get())!=EOF) out.put(c);
    in.close();
  }
  int64_t newsize=out.tell();
  out.close();
  if (newsize>=quiet) {
    printUTF8(archive.c_str(), con);
    fprintf(con, " %1.0f -> %1.0f\n", csize+0.0, newsize+0.0);
  }
  */
}

string Jidac::getpasswordblind()
{
	string myresult="";
	printf("\nEnter password :");
		/*macos*/
#if defined (__APPLE__)
	///printf(" APPLE ");
	int mychar=0;
	struct termios oldt, newt;
	tcgetattr ( STDIN_FILENO, &oldt );
	newt = oldt;
	newt.c_lflag &= ~( ICANON | ECHO );
	tcsetattr ( STDIN_FILENO, TCSANOW, &newt );
#endif
	char carattere;
	while (1)
	{
#if defined(unix)
		carattere=getchar();
		if (carattere==10)
			break;
#else	/// Windows
		carattere=getch();
		if(carattere=='\r')
			break;
		printf("*");
#endif	
		myresult+=carattere;
	}
#if defined (__APPLE__)
	tcsetattr ( STDIN_FILENO, TCSANOW, &oldt );
#endif

	printf("\n");
	return myresult;
}

void Jidac::getpasswordifempty()
{
	if (password==NULL)
		if (check_if_password(archive))
		{
			printf("Archive seems encrypted (or corrupted)");
			string spassword=getpasswordblind();
			if (spassword!="")
			{
				libzpaq::SHA256 sha256;
				for (unsigned int i=0;i<spassword.size();i++)
					sha256.put(spassword[i]);
				memcpy(password_string, sha256.result(), 32);
				password=password_string;
			}
		}
}	

void Jidac::reset()
{
	g_freeze="";
	files_size.clear();
	files_count.clear();
	files_time.clear();
	files_edt.clear();
	ver.clear();
	block.clear();
	dt.clear();
	ht.clear();
	edt.clear();
	ht.resize(1);  // element 0 not used
	ver.resize(1); // version 0
	dhsize=dcsize=0;
	tofiles.clear();
	files.clear();
}

int Jidac::paranoid() 
////////////////////////////////////////////////////////////////////////////
///////// This is a merge of unzpaq206.cpp, patched by me to become unz.cpp
///////// Now support FRANZOFFSET256 
{
#ifdef _WIN32
#ifndef _WIN64
	printf("WARNING: paranoid test use lots of RAM, not good for Win32, better Win64\n");
#endif
#endif
#ifdef ESX
	printf("GURU: sorry: ESXi does not like to give so much RAM\n");
	exit(0);
#endif

	unz(archive.c_str(), password);
	return 0;
}


// Callback for user defined ZPAQ error handling.
// It will be called on input error with an English language error message.
// This function should not return.
extern void unzerror(const char* msg);

// Virtual base classes for input and output
// get() and put() must be overridden to read or write 1 byte.
class unzReader {
public:
  virtual int get() = 0;  // should return 0..255, or -1 at EOF
  virtual ~unzReader() {}
};

class unzWriter {
public:
  virtual void put(int c) = 0;  // should output low 8 bits of c
  virtual ~unzWriter() {}
};

// An Array of T is cleared and aligned on a 64 byte address
//   with no constructors called. No copy or assignment.
// Array<T> a(n, ex=0);  - creates n<<ex elements of type T
// a[i] - index
// a(i) - index mod n, n must be a power of 2
// a.size() - gets n
template <typename T>
class Array {
  T *data;     // user location of [0] on a 64 byte boundary
  size_t n;    // user size
  int offset;  // distance back in bytes to start of actual allocation
  void operator=(const Array&);  // no assignment
  Array(const Array&);  // no copy
public:
  Array(size_t sz=0, int ex=0): data(0), n(0), offset(0) {
    resize(sz, ex);} // [0..sz-1] = 0
  void resize(size_t sz, int ex=0); // change size, erase content to zeros
  ~Array() {resize(0);}  // free memory
  size_t size() const {return n;}  // get size
  int isize() const {return int(n);}  // get size as an int
  T& operator[](size_t i) {assert(n>0 && i<n); return data[i];}
  T& operator()(size_t i) {assert(n>0 && (n&(n-1))==0); return data[i&(n-1)];}
};

// Change size to sz<<ex elements of 0
template<typename T>
void Array<T>::resize(size_t sz, int ex) {
  assert(size_t(-1)>0);  // unsigned type?
  while (ex>0) {
    if (sz>sz*2) unzerror("Array too big");
    sz*=2, --ex;
  }
  if (n>0) {
    assert(offset>=0 && offset<=64);
    assert((char*)data-offset);
    free((char*)data-offset);
  }
  n=0;
  if (sz==0) return;
  n=sz;
  const size_t nb=128+n*sizeof(T);  // test for overflow
  if (nb<=128 || (nb-128)/sizeof(T)!=n) unzerror("Array too big");
  data=(T*)calloc(nb, 1);
  if (!data) unzerror("out of memory");

  // Align array on a 64 byte address.
  // This optimization is NOT required by the ZPAQ standard.
  offset=64-(((char*)data-(char*)0)&63);
  assert(offset>0 && offset<=64);
  data=(T*)((char*)data+offset);
}

//////////////////////////// unzSHA1 ////////////////////////////

// For computing SHA-1 checksums
class unzSHA1 {
public:
  void put(int c) {  // hash 1 byte
    uint32_t& r=w[len0>>5&15];
    r=(r<<8)|(c&255);
    if (!(len0+=8)) ++len1;
    if ((len0&511)==0) process();
  }
  double size() const {return len0/8+len1*536870912.0;} // size in bytes
  const char* result();  // get hash and reset
  unzSHA1() {init();}
private:
  void init();      // reset, but don't clear hbuf
  uint32_t len0, len1;   // length in bits (low, high)
  uint32_t h[5];         // hash state
  uint32_t w[80];        // input buffer
  char hbuf[20];    // result
  void process();   // hash 1 block
};

// Start a new hash
void unzSHA1::init() {
  len0=len1=0;
  h[0]=0x67452301;
  h[1]=0xEFCDAB89;
  h[2]=0x98BADCFE;
  h[3]=0x10325476;
  h[4]=0xC3D2E1F0;
}

// Return old result and start a new hash
const char* unzSHA1::result() {

  // pad and append length
  const uint32_t s1=len1, s0=len0;
  put(0x80);
  while ((len0&511)!=448)
    put(0);
  put(s1>>24);
  put(s1>>16);
  put(s1>>8);
  put(s1);
  put(s0>>24);
  put(s0>>16);
  put(s0>>8);
  put(s0);

  // copy h to hbuf
  for (int i=0; i<5; ++i) {
    hbuf[4*i]=h[i]>>24;
    hbuf[4*i+1]=h[i]>>16;
    hbuf[4*i+2]=h[i]>>8;
    hbuf[4*i+3]=h[i];
  }

  // return hash prior to clearing state
  init();
  return hbuf;
}

// Hash 1 block of 64 bytes
void unzSHA1::process() {
  for (int i=16; i<80; ++i) {
    w[i]=w[i-3]^w[i-8]^w[i-14]^w[i-16];
    w[i]=w[i]<<1|w[i]>>31;
  }
  uint32_t a=h[0];
  uint32_t b=h[1];
  uint32_t c=h[2];
  uint32_t d=h[3];
  uint32_t e=h[4];
  const uint32_t k1=0x5A827999, k2=0x6ED9EBA1, k3=0x8F1BBCDC, k4=0xCA62C1D6;
#define f1(a,b,c,d,e,i) e+=(a<<5|a>>27)+((b&c)|(~b&d))+k1+w[i]; b=b<<30|b>>2;
#define f5(i) f1(a,b,c,d,e,i) f1(e,a,b,c,d,i+1) f1(d,e,a,b,c,i+2) \
              f1(c,d,e,a,b,i+3) f1(b,c,d,e,a,i+4)
  f5(0) f5(5) f5(10) f5(15)
#undef f1
#define f1(a,b,c,d,e,i) e+=(a<<5|a>>27)+(b^c^d)+k2+w[i]; b=b<<30|b>>2;
  f5(20) f5(25) f5(30) f5(35)
#undef f1
#define f1(a,b,c,d,e,i) e+=(a<<5|a>>27)+((b&c)|(b&d)|(c&d))+k3+w[i]; \
        b=b<<30|b>>2;
  f5(40) f5(45) f5(50) f5(55)
#undef f1
#define f1(a,b,c,d,e,i) e+=(a<<5|a>>27)+(b^c^d)+k4+w[i]; b=b<<30|b>>2;
  f5(60) f5(65) f5(70) f5(75)
#undef f1
#undef f5
  h[0]+=a;
  h[1]+=b;
  h[2]+=c;
  h[3]+=d;
  h[4]+=e;
}

//////////////////////////// unzSHA256 //////////////////////////

// For computing SHA-256 checksums
// http://en.wikipedia.org/wiki/SHA-2
class unzSHA256 {
public:
  void put(int c) {  // hash 1 byte
    unsigned& r=w[len0>>5&15];
    r=(r<<8)|(c&255);
    if (!(len0+=8)) ++len1;
    if ((len0&511)==0) process();
  }
  double size() const {return len0/8+len1*536870912.0;} // size in bytes
  uint64_t usize() const {return len0/8+(uint64_t(len1)<<29);} //size in bytes
  const char* result();  // get hash and reset
  unzSHA256() {init();}
private:
  void init();           // reset, but don't clear hbuf
  unsigned len0, len1;   // length in bits (low, high)
  unsigned s[8];         // hash state
  unsigned w[16];        // input buffer
  char hbuf[32];         // result
  void process();        // hash 1 block
};

void unzSHA256::init() {
  len0=len1=0;
  s[0]=0x6a09e667;
  s[1]=0xbb67ae85;
  s[2]=0x3c6ef372;
  s[3]=0xa54ff53a;
  s[4]=0x510e527f;
  s[5]=0x9b05688c;
  s[6]=0x1f83d9ab;
  s[7]=0x5be0cd19;
  memset(w, 0, sizeof(w));
}

void unzSHA256::process() {

  #define ror(a,b) ((a)>>(b)|(a<<(32-(b))))

  #define m(i) \
     w[(i)&15]+=w[(i-7)&15] \
       +(ror(w[(i-15)&15],7)^ror(w[(i-15)&15],18)^(w[(i-15)&15]>>3)) \
       +(ror(w[(i-2)&15],17)^ror(w[(i-2)&15],19)^(w[(i-2)&15]>>10))

  #define r(a,b,c,d,e,f,g,h,i) { \
    unsigned t1=ror(e,14)^e; \
    t1=ror(t1,5)^e; \
    h+=ror(t1,6)+((e&f)^(~e&g))+k[i]+w[(i)&15]; } \
    d+=h; \
    {unsigned t1=ror(a,9)^a; \
    t1=ror(t1,11)^a; \
    h+=ror(t1,2)+((a&b)^(c&(a^b))); }

  #define mr(a,b,c,d,e,f,g,h,i) m(i); r(a,b,c,d,e,f,g,h,i);

  #define r8(i) \
    r(a,b,c,d,e,f,g,h,i);   \
    r(h,a,b,c,d,e,f,g,i+1); \
    r(g,h,a,b,c,d,e,f,i+2); \
    r(f,g,h,a,b,c,d,e,i+3); \
    r(e,f,g,h,a,b,c,d,i+4); \
    r(d,e,f,g,h,a,b,c,i+5); \
    r(c,d,e,f,g,h,a,b,i+6); \
    r(b,c,d,e,f,g,h,a,i+7);

  #define mr8(i) \
    mr(a,b,c,d,e,f,g,h,i);   \
    mr(h,a,b,c,d,e,f,g,i+1); \
    mr(g,h,a,b,c,d,e,f,i+2); \
    mr(f,g,h,a,b,c,d,e,i+3); \
    mr(e,f,g,h,a,b,c,d,i+4); \
    mr(d,e,f,g,h,a,b,c,i+5); \
    mr(c,d,e,f,g,h,a,b,i+6); \
    mr(b,c,d,e,f,g,h,a,i+7);

  static const unsigned k[64]={
    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5,
    0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
    0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3,
    0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
    0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc,
    0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
    0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7,
    0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
    0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13,
    0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
    0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3,
    0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
    0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5,
    0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
    0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,
    0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2};

  unsigned a=s[0];
  unsigned b=s[1];
  unsigned c=s[2];
  unsigned d=s[3];
  unsigned e=s[4];
  unsigned f=s[5];
  unsigned g=s[6];
  unsigned h=s[7];

  r8(0);
  r8(8);
  mr8(16);
  mr8(24);
  mr8(32);
  mr8(40);
  mr8(48);
  mr8(56);

  s[0]+=a;
  s[1]+=b;
  s[2]+=c;
  s[3]+=d;
  s[4]+=e;
  s[5]+=f;
  s[6]+=g;
  s[7]+=h;

  #undef mr8
  #undef r8
  #undef mr
  #undef r
  #undef m
  #undef ror
}

// Return old result and start a new hash
const char* unzSHA256::result() {

  // pad and append length
  const unsigned s1=len1, s0=len0;
  put(0x80);
  while ((len0&511)!=448) put(0);
  put(s1>>24);
  put(s1>>16);
  put(s1>>8);
  put(s1);
  put(s0>>24);
  put(s0>>16);
  put(s0>>8);
  put(s0);

  // copy s to hbuf
  for (int i=0; i<8; ++i) {
    hbuf[4*i]=s[i]>>24;
    hbuf[4*i+1]=s[i]>>16;
    hbuf[4*i+2]=s[i]>>8;
    hbuf[4*i+3]=s[i];
  }

  // return hash prior to clearing state
  init();
  return hbuf;
}

//////////////////////////// AES /////////////////////////////

// For encrypting with AES in CTR mode.
// The i'th 16 byte block is encrypted by XOR with AES(i)
// (i is big endian or MSB first, starting with 0).
class unzAES_CTR {
  uint32_t Te0[256], Te1[256], Te2[256], Te3[256], Te4[256]; // encryption tables
  uint32_t ek[60];  // round key
  int Nr;  // number of rounds (10, 12, 14 for AES 128, 192, 256)
  uint32_t iv0, iv1;  // first 8 bytes in CTR mode
public:
  unzAES_CTR(const char* key, int keylen, const char* iv=0);
    // Schedule: keylen is 16, 24, or 32, iv is 8 bytes or NULL
  void encrypt(uint32_t s0, uint32_t s1, uint32_t s2, uint32_t s3, unsigned char* ct);
  void encrypt(char* unzBuf, int n, uint64_t offset);  // encrypt n bytes of unzBuf
};

// Some AES code is derived from libtomcrypt 1.17 (public domain).

#define Te4_0 0x000000FF & Te4
#define Te4_1 0x0000FF00 & Te4
#define Te4_2 0x00FF0000 & Te4
#define Te4_3 0xFF000000 & Te4

// Extract byte n of x
static inline unsigned unzbyte(unsigned x, unsigned n) {return (x>>(8*n))&255;}

// x = y[0..3] MSB first
static inline void LOAD32H(uint32_t& x, const char* y) {
  const unsigned char* u=(const unsigned char*)y;
  x=u[0]<<24|u[1]<<16|u[2]<<8|u[3];
}

// y[0..3] = x MSB first
static inline void STORE32H(uint32_t& x, unsigned char* y) {
  y[0]=x>>24;
  y[1]=x>>16;
  y[2]=x>>8;
  y[3]=x;
}

#define setup_mix(temp) \
  ((Te4_3[unzbyte(temp, 2)]) ^ (Te4_2[unzbyte(temp, 1)]) ^ \
   (Te4_1[unzbyte(temp, 0)]) ^ (Te4_0[unzbyte(temp, 3)]))

// Initialize encryption tables and round key. keylen is 16, 24, or 32.
unzAES_CTR::unzAES_CTR(const char* key, int keylen, const char* iv) {
  assert(key  != NULL);
  assert(keylen==16 || keylen==24 || keylen==32);

  // Initialize IV (default 0)
  iv0=iv1=0;
  if (iv) {
    LOAD32H(iv0, iv);
    LOAD32H(iv1, iv+4);
  }

  // Initialize encryption tables
  for (int i=0; i<256; ++i) {
    unsigned s1=
    "\x63\x7c\x77\x7b\xf2\x6b\x6f\xc5\x30\x01\x67\x2b\xfe\xd7\xab\x76"
    "\xca\x82\xc9\x7d\xfa\x59\x47\xf0\xad\xd4\xa2\xaf\x9c\xa4\x72\xc0"
    "\xb7\xfd\x93\x26\x36\x3f\xf7\xcc\x34\xa5\xe5\xf1\x71\xd8\x31\x15"
    "\x04\xc7\x23\xc3\x18\x96\x05\x9a\x07\x12\x80\xe2\xeb\x27\xb2\x75"
    "\x09\x83\x2c\x1a\x1b\x6e\x5a\xa0\x52\x3b\xd6\xb3\x29\xe3\x2f\x84"
    "\x53\xd1\x00\xed\x20\xfc\xb1\x5b\x6a\xcb\xbe\x39\x4a\x4c\x58\xcf"
    "\xd0\xef\xaa\xfb\x43\x4d\x33\x85\x45\xf9\x02\x7f\x50\x3c\x9f\xa8"
    "\x51\xa3\x40\x8f\x92\x9d\x38\xf5\xbc\xb6\xda\x21\x10\xff\xf3\xd2"
    "\xcd\x0c\x13\xec\x5f\x97\x44\x17\xc4\xa7\x7e\x3d\x64\x5d\x19\x73"
    "\x60\x81\x4f\xdc\x22\x2a\x90\x88\x46\xee\xb8\x14\xde\x5e\x0b\xdb"
    "\xe0\x32\x3a\x0a\x49\x06\x24\x5c\xc2\xd3\xac\x62\x91\x95\xe4\x79"
    "\xe7\xc8\x37\x6d\x8d\xd5\x4e\xa9\x6c\x56\xf4\xea\x65\x7a\xae\x08"
    "\xba\x78\x25\x2e\x1c\xa6\xb4\xc6\xe8\xdd\x74\x1f\x4b\xbd\x8b\x8a"
    "\x70\x3e\xb5\x66\x48\x03\xf6\x0e\x61\x35\x57\xb9\x86\xc1\x1d\x9e"
    "\xe1\xf8\x98\x11\x69\xd9\x8e\x94\x9b\x1e\x87\xe9\xce\x55\x28\xdf"
    "\x8c\xa1\x89\x0d\xbf\xe6\x42\x68\x41\x99\x2d\x0f\xb0\x54\xbb\x16"
    [i]&255;
    unsigned s2=s1<<1;
    if (s2>=0x100) s2^=0x11b;
    unsigned s3=s1^s2;
    Te0[i]=s2<<24|s1<<16|s1<<8|s3;
    Te1[i]=s3<<24|s2<<16|s1<<8|s1;
    Te2[i]=s1<<24|s3<<16|s2<<8|s1;
    Te3[i]=s1<<24|s1<<16|s3<<8|s2;
    Te4[i]=s1<<24|s1<<16|s1<<8|s1;
  }

  // setup the forward key
  Nr = 10 + ((keylen/8)-2)*2;  // 10, 12, or 14 rounds
  int i = 0;
  uint32_t* rk = &ek[0];
  uint32_t temp;
  static const uint32_t rcon[10] = {
    0x01000000UL, 0x02000000UL, 0x04000000UL, 0x08000000UL,
    0x10000000UL, 0x20000000UL, 0x40000000UL, 0x80000000UL,
    0x1B000000UL, 0x36000000UL};  // round constants

  LOAD32H(rk[0], key   );
  LOAD32H(rk[1], key +  4);
  LOAD32H(rk[2], key +  8);
  LOAD32H(rk[3], key + 12);
  if (keylen == 16) {
    for (;;) {
      temp  = rk[3];
      rk[4] = rk[0] ^ setup_mix(temp) ^ rcon[i];
      rk[5] = rk[1] ^ rk[4];
      rk[6] = rk[2] ^ rk[5];
      rk[7] = rk[3] ^ rk[6];
      if (++i == 10) {
         break;
      }
      rk += 4;
    }
  }
  else if (keylen == 24) {
    LOAD32H(rk[4], key + 16);
    LOAD32H(rk[5], key + 20);
    for (;;) {
      temp = rk[5];
      rk[ 6] = rk[ 0] ^ setup_mix(temp) ^ rcon[i];
      rk[ 7] = rk[ 1] ^ rk[ 6];
      rk[ 8] = rk[ 2] ^ rk[ 7];
      rk[ 9] = rk[ 3] ^ rk[ 8];
      if (++i == 8) {
        break;
      }
      rk[10] = rk[ 4] ^ rk[ 9];
      rk[11] = rk[ 5] ^ rk[10];
      rk += 6;
    }
  }
  else if (keylen == 32) {
    LOAD32H(rk[4], key + 16);
    LOAD32H(rk[5], key + 20);
    LOAD32H(rk[6], key + 24);
    LOAD32H(rk[7], key + 28);
    for (;;) {
      temp = rk[7];
      rk[ 8] = rk[ 0] ^ setup_mix(temp) ^ rcon[i];
      rk[ 9] = rk[ 1] ^ rk[ 8];
      rk[10] = rk[ 2] ^ rk[ 9];
      rk[11] = rk[ 3] ^ rk[10];
      if (++i == 7) {
        break;
      }
      temp = rk[11];
      rk[12] = rk[ 4] ^ setup_mix(temp<<24|temp>>8);
      rk[13] = rk[ 5] ^ rk[12];
      rk[14] = rk[ 6] ^ rk[13];
      rk[15] = rk[ 7] ^ rk[14];
      rk += 8;
    }
  }
}

// Encrypt to ct[16]
void unzAES_CTR::encrypt(uint32_t s0, uint32_t s1, uint32_t s2, uint32_t s3, unsigned char* ct) {
  int r = Nr >> 1;
  uint32_t *rk = &ek[0];
  uint32_t t0=0, t1=0, t2=0, t3=0;
  s0 ^= rk[0];
  s1 ^= rk[1];
  s2 ^= rk[2];
  s3 ^= rk[3];
  for (;;) {
    t0 =
      Te0[unzbyte(s0, 3)] ^
      Te1[unzbyte(s1, 2)] ^
      Te2[unzbyte(s2, 1)] ^
      Te3[unzbyte(s3, 0)] ^
      rk[4];
    t1 =
      Te0[unzbyte(s1, 3)] ^
      Te1[unzbyte(s2, 2)] ^
      Te2[unzbyte(s3, 1)] ^
      Te3[unzbyte(s0, 0)] ^
      rk[5];
    t2 =
      Te0[unzbyte(s2, 3)] ^
      Te1[unzbyte(s3, 2)] ^
      Te2[unzbyte(s0, 1)] ^
      Te3[unzbyte(s1, 0)] ^
      rk[6];
    t3 =
      Te0[unzbyte(s3, 3)] ^
      Te1[unzbyte(s0, 2)] ^
      Te2[unzbyte(s1, 1)] ^
      Te3[unzbyte(s2, 0)] ^
      rk[7];

    rk += 8;
    if (--r == 0) {
      break;
    }

    s0 =
      Te0[unzbyte(t0, 3)] ^
      Te1[unzbyte(t1, 2)] ^
      Te2[unzbyte(t2, 1)] ^
      Te3[unzbyte(t3, 0)] ^
      rk[0];
    s1 =
      Te0[unzbyte(t1, 3)] ^
      Te1[unzbyte(t2, 2)] ^
      Te2[unzbyte(t3, 1)] ^
      Te3[unzbyte(t0, 0)] ^
      rk[1];
    s2 =
      Te0[unzbyte(t2, 3)] ^
      Te1[unzbyte(t3, 2)] ^
      Te2[unzbyte(t0, 1)] ^
      Te3[unzbyte(t1, 0)] ^
      rk[2];
    s3 =
      Te0[unzbyte(t3, 3)] ^
      Te1[unzbyte(t0, 2)] ^
      Te2[unzbyte(t1, 1)] ^
      Te3[unzbyte(t2, 0)] ^
      rk[3];
  }

  // apply last round and map cipher state to byte array block:
  s0 =
    (Te4_3[unzbyte(t0, 3)]) ^
    (Te4_2[unzbyte(t1, 2)]) ^
    (Te4_1[unzbyte(t2, 1)]) ^
    (Te4_0[unzbyte(t3, 0)]) ^
    rk[0];
  STORE32H(s0, ct);
  s1 =
    (Te4_3[unzbyte(t1, 3)]) ^
    (Te4_2[unzbyte(t2, 2)]) ^
    (Te4_1[unzbyte(t3, 1)]) ^
    (Te4_0[unzbyte(t0, 0)]) ^
    rk[1];
  STORE32H(s1, ct+4);
  s2 =
    (Te4_3[unzbyte(t2, 3)]) ^
    (Te4_2[unzbyte(t3, 2)]) ^
    (Te4_1[unzbyte(t0, 1)]) ^
    (Te4_0[unzbyte(t1, 0)]) ^
    rk[2];
  STORE32H(s2, ct+8);
  s3 =
    (Te4_3[unzbyte(t3, 3)]) ^
    (Te4_2[unzbyte(t0, 2)]) ^
    (Te4_1[unzbyte(t1, 1)]) ^
    (Te4_0[unzbyte(t2, 0)]) ^ 
    rk[3];
  STORE32H(s3, ct+12);
}

// Encrypt or decrypt slice unzBuf[0..n-1] at offset by XOR with AES(i) where
// i is the 128 bit big-endian distance from the start in 16 byte blocks.
void unzAES_CTR::encrypt(char* unzBuf, int n, uint64_t offset) {
  for (uint64_t i=offset/16; i<=(offset+n)/16; ++i) {
    unsigned char ct[16];
    encrypt(iv0, iv1, i>>32, i, ct);
    for (int j=0; j<16; ++j) {
      const int k=i*16-offset+j;
      if (k>=0 && k<n)
        unzBuf[k]^=ct[j];
    }
  }
}

#undef setup_mix
#undef Te4_3
#undef Te4_2
#undef Te4_1
#undef Te4_0

//////////////////////////// stretchKey //////////////////////

// PBKDF2(pw[0..pwlen], salt[0..saltlen], c) to unzBuf[0..dkLen-1]
// using HMAC-unzSHA256, for the special case of c = 1 iterations
// output size dkLen a multiple of 32, and pwLen <= 64.
static void unzpbkdf2(const char* pw, int pwLen, const char* salt, int saltLen,
                    char* unzBuf, int dkLen) {

  assert(dkLen%32==0);
  assert(pwLen<=64);

  unzSHA256 sha256;
  char b[32];
  for (int i=1; i*32<=dkLen; ++i) {
    for (int j=0; j<pwLen; ++j) sha256.put(pw[j]^0x36);
    for (int j=pwLen; j<64; ++j) sha256.put(0x36);
    for (int j=0; j<saltLen; ++j) sha256.put(salt[j]);
    for (int j=24; j>=0; j-=8) sha256.put(i>>j);
    memcpy(b, sha256.result(), 32);
    for (int j=0; j<pwLen; ++j) sha256.put(pw[j]^0x5c);
    for (int j=pwLen; j<64; ++j) sha256.put(0x5c);
    for (int j=0; j<32; ++j) sha256.put(b[j]);
    memcpy(unzBuf+i*32-32, sha256.result(), 32);
  }
}

// Hash b[0..15] using 8 rounds of salsa20
// Modified from http://cr.yp.to/salsa20.html (public domain) to 8 rounds
static void salsa8(uint32_t* b) {
  unsigned x[16]={0};
  memcpy(x, b, 64);
  for (int i=0; i<4; ++i) {
    #define R(a,b) (((a)<<(b))+((a)>>(32-b)))
    x[ 4] ^= R(x[ 0]+x[12], 7);  x[ 8] ^= R(x[ 4]+x[ 0], 9);
    x[12] ^= R(x[ 8]+x[ 4],13);  x[ 0] ^= R(x[12]+x[ 8],18);
    x[ 9] ^= R(x[ 5]+x[ 1], 7);  x[13] ^= R(x[ 9]+x[ 5], 9);
    x[ 1] ^= R(x[13]+x[ 9],13);  x[ 5] ^= R(x[ 1]+x[13],18);
    x[14] ^= R(x[10]+x[ 6], 7);  x[ 2] ^= R(x[14]+x[10], 9);
    x[ 6] ^= R(x[ 2]+x[14],13);  x[10] ^= R(x[ 6]+x[ 2],18);
    x[ 3] ^= R(x[15]+x[11], 7);  x[ 7] ^= R(x[ 3]+x[15], 9);
    x[11] ^= R(x[ 7]+x[ 3],13);  x[15] ^= R(x[11]+x[ 7],18);
    x[ 1] ^= R(x[ 0]+x[ 3], 7);  x[ 2] ^= R(x[ 1]+x[ 0], 9);
    x[ 3] ^= R(x[ 2]+x[ 1],13);  x[ 0] ^= R(x[ 3]+x[ 2],18);
    x[ 6] ^= R(x[ 5]+x[ 4], 7);  x[ 7] ^= R(x[ 6]+x[ 5], 9);
    x[ 4] ^= R(x[ 7]+x[ 6],13);  x[ 5] ^= R(x[ 4]+x[ 7],18);
    x[11] ^= R(x[10]+x[ 9], 7);  x[ 8] ^= R(x[11]+x[10], 9);
    x[ 9] ^= R(x[ 8]+x[11],13);  x[10] ^= R(x[ 9]+x[ 8],18);
    x[12] ^= R(x[15]+x[14], 7);  x[13] ^= R(x[12]+x[15], 9);
    x[14] ^= R(x[13]+x[12],13);  x[15] ^= R(x[14]+x[13],18);
    #undef R
  }
  for (int i=0; i<16; ++i) b[i]+=x[i];
}

// BlockMix_{Salsa20/8, r} on b[0..128*r-1]
static void blockmix(uint32_t* b, int r) {
  assert(r<=8);
  uint32_t x[16];
  uint32_t y[256];
  memcpy(x, b+32*r-16, 64);
  for (int i=0; i<2*r; ++i) {
    for (int j=0; j<16; ++j) x[j]^=b[i*16+j];
    salsa8(x);
    memcpy(&y[i*16], x, 64);
  }
  for (int i=0; i<r; ++i) memcpy(b+i*16, &y[i*32], 64);
  for (int i=0; i<r; ++i) memcpy(b+(i+r)*16, &y[i*32+16], 64);
}

// Mix b[0..128*r-1]. Uses 128*r*n bytes of memory and O(r*n) time
static void smix(char* b, int r, int n) {
  Array<uint32_t> x(32*r), v(32*r*n);
  for (int i=0; i<r*128; ++i) x[i/4]+=(b[i]&255)<<i%4*8;
  for (int i=0; i<n; ++i) {
    memcpy(&v[i*r*32], &x[0], r*128);
    blockmix(&x[0], r);
  }
  for (int i=0; i<n; ++i) {
    uint32_t j=x[(2*r-1)*16]&(n-1);
    for (int k=0; k<r*32; ++k) x[k]^=v[j*r*32+k];
    blockmix(&x[0], r);
  }
  for (int i=0; i<r*128; ++i) b[i]=x[i/4]>>(i%4*8);
}

// Strengthen password pw[0..pwlen-1] and salt[0..saltlen-1]
// to produce key unzBuf[0..buflen-1]. Uses O(n*r*p) time and 128*r*n bytes
// of memory. n must be a power of 2 and r <= 8.
void unzscrypt(const char* pw, int pwlen,
            const char* salt, int saltlen,
            int n, int r, int p, char* unzBuf, int buflen) {
  assert(r<=8);
  assert(n>0 && (n&(n-1))==0);  // power of 2?
  Array<char> b(p*r*128);
  unzpbkdf2(pw, pwlen, salt, saltlen,  &b[0], p*r*128);
  for (int i=0; i<p; ++i) smix(&b[i*r*128], r, n);
  unzpbkdf2(pw, pwlen, &b[0], p*r*128,  unzBuf, buflen);
}

// Stretch key in[0..31], assumed to be unzSHA256(password), with
// NUL terminate salt to produce new key out[0..31]
void stretchKey(char* out, const char* in, const char* salt) {
  unzscrypt(in, 32, salt, 32, 1<<14, 8, 1, out, 32);
}

//////////////////////////// unzZPAQL ///////////////////////////

// Symbolic instructions and their sizes
typedef enum {NONE,CONS,CM,ICM,MATCH,AVG,MIX2,MIX,ISSE,SSE} CompType;
const int compsize[256]={0,2,3,2,3,4,6,6,3,5};

// A unzZPAQL virtual machine COMP+HCOMP or PCOMP.
class unzZPAQL {
public:
  unzZPAQL();
  void clear();           // Free memory, erase program, reset machine state
  void inith();           // Initialize as HCOMP to run
  void initp();           // Initialize as PCOMP to run
  void run(uint32_t input);    // Execute with input
  int read(unzReader* in2);  // Read header
  void outc(int c);       // output a byte

  unzWriter* output;         // Destination for OUT instruction, or 0 to suppress
  unzSHA1* sha1;             // Points to checksum computer
  uint32_t H(int i) {return h(i);}  // get element of h

  // unzZPAQL block header
  Array<uint8_t> header;   // hsize[2] hh hm ph pm n COMP (guard) HCOMP (guard)
  int cend;           // COMP in header[7...cend-1]
  int hbegin, hend;   // HCOMP/PCOMP in header[hbegin...hend-1]

private:
  // Machine state for executing HCOMP
  Array<uint8_t> m;        // memory array M for HCOMP
  Array<uint32_t> h;       // hash array H for HCOMP
  Array<uint32_t> r;       // 256 element register array
  uint32_t a, b, c, d;     // machine registers
  int f;              // condition flag
  int pc;             // program counter

  // Support code
  void init(int hbits, int mbits);  // initialize H and M sizes
  int execute();  // execute 1 instruction, return 0 after HALT, else 1
  void div(uint32_t x) {if (x) a/=x; else a=0;}
  void mod(uint32_t x) {if (x) a%=x; else a=0;}
  void swap(uint32_t& x) {a^=x; x^=a; a^=x;}
  void swap(uint8_t& x)  {a^=x; x^=a; a^=x;}
  void err();  // exit with run time error
};

// Read header from in2
int unzZPAQL::read(unzReader* in2) {

  // Get header size and allocate
  int hsize=in2->get();
  if (hsize<0) unzerror("end of header");
  hsize+=in2->get()*256;
  if (hsize<0) unzerror("end of header");
  header.resize(hsize+300);
  cend=hbegin=hend=0;
  header[cend++]=hsize&255;
  header[cend++]=hsize>>8;
  while (cend<7) header[cend++]=in2->get(); // hh hm ph pm n

  // Read COMP
  int n=header[cend-1];
  for (int i=0; i<n; ++i) {
    int type=in2->get();  // component type
    if (type==-1) unzerror("unexpected end of file");
    header[cend++]=type;  // component type
    int size=compsize[type];
    if (size<1) unzerror("Invalid component type");
    if (cend+size>hsize) unzerror("COMP overflows header");
    for (int j=1; j<size; ++j)
      header[cend++]=in2->get();
  }
  if ((header[cend++]=in2->get())!=0) unzerror("missing COMP END");

  // Insert a guard gap and read HCOMP
  hbegin=hend=cend+128;
  if (hend>hsize+129) unzerror("missing HCOMP");
  while (hend<hsize+129) {
    assert(hend<header.isize()-8);
    int op=in2->get();
    if (op<0) unzerror("unexpected end of file");
    header[hend++]=op;
  }
  if ((header[hend++]=in2->get())!=0) unzerror("missing HCOMP END");
  assert(cend>=7 && cend<header.isize());
  assert(hbegin==cend+128 && hbegin<header.isize());
  assert(hend>hbegin && hend<header.isize());
  assert(hsize==header[0]+256*header[1]);
  assert(hsize==cend-2+hend-hbegin);
  return cend+hend-hbegin;
}

// Free memory, but preserve output, sha1 pointers
void unzZPAQL::clear() {
  cend=hbegin=hend=0;  // COMP and HCOMP locations
  a=b=c=d=f=pc=0;      // machine state
  header.resize(0);
  h.resize(0);
  m.resize(0);
  r.resize(0);
}

// Constructor
unzZPAQL::unzZPAQL() {
  output=0;
  sha1=0;
  clear();
}

// Initialize machine state as HCOMP
void unzZPAQL::inith() {
  assert(header.isize()>6);
  assert(output==0);
  assert(sha1==0);
  init(header[2], header[3]); // hh, hm
}

// Initialize machine state as PCOMP
void unzZPAQL::initp() {
  assert(header.isize()>6);
  init(header[4], header[5]); // ph, pm
}

// Initialize machine state to run a program.
void unzZPAQL::init(int hbits, int mbits) {
  assert(header.isize()>0);
  assert(cend>=7);
  assert(hbegin>=cend+128);
  assert(hend>=hbegin);
  assert(hend<header.isize()-130);
  assert(header[0]+256*header[1]==cend-2+hend-hbegin);
  h.resize(1, hbits);
  m.resize(1, mbits);
  r.resize(256);
  a=b=c=d=pc=f=0;
}

// Run program on input by interpreting header
void unzZPAQL::run(uint32_t input) {
  assert(cend>6);
  assert(hbegin>=cend+128);
  assert(hend>=hbegin);
  assert(hend<header.isize()-130);
  assert(m.size()>0);
  assert(h.size()>0);
  assert(header[0]+256*header[1]==cend+hend-hbegin-2);
  pc=hbegin;
  a=input;
  while (execute()) ;
}

void unzZPAQL::outc(int c) {
  if (output) output->put(c);
  if (sha1) sha1->put(c);
}

// Execute one instruction, return 0 after HALT else 1
int unzZPAQL::execute() {
  switch(header[pc++]) {
    case 0: err(); break; // ERROR
    case 1: ++a; break; // A++
    case 2: --a; break; // A--
    case 3: a = ~a; break; // A!
    case 4: a = 0; break; // A=0
    case 7: a = r[header[pc++]]; break; // A=R N
    case 8: swap(b); break; // B<>A
    case 9: ++b; break; // B++
    case 10: --b; break; // B--
    case 11: b = ~b; break; // B!
    case 12: b = 0; break; // B=0
    case 15: b = r[header[pc++]]; break; // B=R N
    case 16: swap(c); break; // C<>A
    case 17: ++c; break; // C++
    case 18: --c; break; // C--
    case 19: c = ~c; break; // C!
    case 20: c = 0; break; // C=0
    case 23: c = r[header[pc++]]; break; // C=R N
    case 24: swap(d); break; // D<>A
    case 25: ++d; break; // D++
    case 26: --d; break; // D--
    case 27: d = ~d; break; // D!
    case 28: d = 0; break; // D=0
    case 31: d = r[header[pc++]]; break; // D=R N
    case 32: swap(m(b)); break; // *B<>A
    case 33: ++m(b); break; // *B++
    case 34: --m(b); break; // *B--
    case 35: m(b) = ~m(b); break; // *B!
    case 36: m(b) = 0; break; // *B=0
    case 39: if (f) pc+=((header[pc]+128)&255)-127; else ++pc; break; // JT N
    case 40: swap(m(c)); break; // *C<>A
    case 41: ++m(c); break; // *C++
    case 42: --m(c); break; // *C--
    case 43: m(c) = ~m(c); break; // *C!
    case 44: m(c) = 0; break; // *C=0
    case 47: if (!f) pc+=((header[pc]+128)&255)-127; else ++pc; break; // JF N
    case 48: swap(h(d)); break; // *D<>A
    case 49: ++h(d); break; // *D++
    case 50: --h(d); break; // *D--
    case 51: h(d) = ~h(d); break; // *D!
    case 52: h(d) = 0; break; // *D=0
    case 55: r[header[pc++]] = a; break; // R=A N
    case 56: return 0  ; // HALT
    case 57: outc(a&255); break; // OUT
    case 59: a = (a+m(b)+512)*773; break; // HASH
    case 60: h(d) = (h(d)+a+512)*773; break; // HASHD
    case 63: pc+=((header[pc]+128)&255)-127; break; // JMP N
    case 64: break; // A=A
    case 65: a = b; break; // A=B
    case 66: a = c; break; // A=C
    case 67: a = d; break; // A=D
    case 68: a = m(b); break; // A=*B
    case 69: a = m(c); break; // A=*C
    case 70: a = h(d); break; // A=*D
    case 71: a = header[pc++]; break; // A= N
    case 72: b = a; break; // B=A
    case 73: break; // B=B
    case 74: b = c; break; // B=C
    case 75: b = d; break; // B=D
    case 76: b = m(b); break; // B=*B
    case 77: b = m(c); break; // B=*C
    case 78: b = h(d); break; // B=*D
    case 79: b = header[pc++]; break; // B= N
    case 80: c = a; break; // C=A
    case 81: c = b; break; // C=B
    case 82: break; // C=C
    case 83: c = d; break; // C=D
    case 84: c = m(b); break; // C=*B
    case 85: c = m(c); break; // C=*C
    case 86: c = h(d); break; // C=*D
    case 87: c = header[pc++]; break; // C= N
    case 88: d = a; break; // D=A
    case 89: d = b; break; // D=B
    case 90: d = c; break; // D=C
    case 91: break; // D=D
    case 92: d = m(b); break; // D=*B
    case 93: d = m(c); break; // D=*C
    case 94: d = h(d); break; // D=*D
    case 95: d = header[pc++]; break; // D= N
    case 96: m(b) = a; break; // *B=A
    case 97: m(b) = b; break; // *B=B
    case 98: m(b) = c; break; // *B=C
    case 99: m(b) = d; break; // *B=D
    case 100: break; // *B=*B
    case 101: m(b) = m(c); break; // *B=*C
    case 102: m(b) = h(d); break; // *B=*D
    case 103: m(b) = header[pc++]; break; // *B= N
    case 104: m(c) = a; break; // *C=A
    case 105: m(c) = b; break; // *C=B
    case 106: m(c) = c; break; // *C=C
    case 107: m(c) = d; break; // *C=D
    case 108: m(c) = m(b); break; // *C=*B
    case 109: break; // *C=*C
    case 110: m(c) = h(d); break; // *C=*D
    case 111: m(c) = header[pc++]; break; // *C= N
    case 112: h(d) = a; break; // *D=A
    case 113: h(d) = b; break; // *D=B
    case 114: h(d) = c; break; // *D=C
    case 115: h(d) = d; break; // *D=D
    case 116: h(d) = m(b); break; // *D=*B
    case 117: h(d) = m(c); break; // *D=*C
    case 118: break; // *D=*D
    case 119: h(d) = header[pc++]; break; // *D= N
    case 128: a += a; break; // A+=A
    case 129: a += b; break; // A+=B
    case 130: a += c; break; // A+=C
    case 131: a += d; break; // A+=D
    case 132: a += m(b); break; // A+=*B
    case 133: a += m(c); break; // A+=*C
    case 134: a += h(d); break; // A+=*D
    case 135: a += header[pc++]; break; // A+= N
    case 136: a -= a; break; // A-=A
    case 137: a -= b; break; // A-=B
    case 138: a -= c; break; // A-=C
    case 139: a -= d; break; // A-=D
    case 140: a -= m(b); break; // A-=*B
    case 141: a -= m(c); break; // A-=*C
    case 142: a -= h(d); break; // A-=*D
    case 143: a -= header[pc++]; break; // A-= N
    case 144: a *= a; break; // A*=A
    case 145: a *= b; break; // A*=B
    case 146: a *= c; break; // A*=C
    case 147: a *= d; break; // A*=D
    case 148: a *= m(b); break; // A*=*B
    case 149: a *= m(c); break; // A*=*C
    case 150: a *= h(d); break; // A*=*D
    case 151: a *= header[pc++]; break; // A*= N
    case 152: div(a); break; // A/=A
    case 153: div(b); break; // A/=B
    case 154: div(c); break; // A/=C
    case 155: div(d); break; // A/=D
    case 156: div(m(b)); break; // A/=*B
    case 157: div(m(c)); break; // A/=*C
    case 158: div(h(d)); break; // A/=*D
    case 159: div(header[pc++]); break; // A/= N
    case 160: mod(a); break; // A%=A
    case 161: mod(b); break; // A%=B
    case 162: mod(c); break; // A%=C
    case 163: mod(d); break; // A%=D
    case 164: mod(m(b)); break; // A%=*B
    case 165: mod(m(c)); break; // A%=*C
    case 166: mod(h(d)); break; // A%=*D
    case 167: mod(header[pc++]); break; // A%= N
    case 168: a &= a; break; // A&=A
    case 169: a &= b; break; // A&=B
    case 170: a &= c; break; // A&=C
    case 171: a &= d; break; // A&=D
    case 172: a &= m(b); break; // A&=*B
    case 173: a &= m(c); break; // A&=*C
    case 174: a &= h(d); break; // A&=*D
    case 175: a &= header[pc++]; break; // A&= N
    case 176: a &= ~ a; break; // A&~A
    case 177: a &= ~ b; break; // A&~B
    case 178: a &= ~ c; break; // A&~C
    case 179: a &= ~ d; break; // A&~D
    case 180: a &= ~ m(b); break; // A&~*B
    case 181: a &= ~ m(c); break; // A&~*C
    case 182: a &= ~ h(d); break; // A&~*D
    case 183: a &= ~ header[pc++]; break; // A&~ N
    case 184: a |= a; break; // A|=A
    case 185: a |= b; break; // A|=B
    case 186: a |= c; break; // A|=C
    case 187: a |= d; break; // A|=D
    case 188: a |= m(b); break; // A|=*B
    case 189: a |= m(c); break; // A|=*C
    case 190: a |= h(d); break; // A|=*D
    case 191: a |= header[pc++]; break; // A|= N
    case 192: a ^= a; break; // A^=A
    case 193: a ^= b; break; // A^=B
    case 194: a ^= c; break; // A^=C
    case 195: a ^= d; break; // A^=D
    case 196: a ^= m(b); break; // A^=*B
    case 197: a ^= m(c); break; // A^=*C
    case 198: a ^= h(d); break; // A^=*D
    case 199: a ^= header[pc++]; break; // A^= N
    case 200: a <<= (a&31); break; // A<<=A
    case 201: a <<= (b&31); break; // A<<=B
    case 202: a <<= (c&31); break; // A<<=C
    case 203: a <<= (d&31); break; // A<<=D
    case 204: a <<= (m(b)&31); break; // A<<=*B
    case 205: a <<= (m(c)&31); break; // A<<=*C
    case 206: a <<= (h(d)&31); break; // A<<=*D
    case 207: a <<= (header[pc++]&31); break; // A<<= N
    case 208: a >>= (a&31); break; // A>>=A
    case 209: a >>= (b&31); break; // A>>=B
    case 210: a >>= (c&31); break; // A>>=C
    case 211: a >>= (d&31); break; // A>>=D
    case 212: a >>= (m(b)&31); break; // A>>=*B
    case 213: a >>= (m(c)&31); break; // A>>=*C
    case 214: a >>= (h(d)&31); break; // A>>=*D
    case 215: a >>= (header[pc++]&31); break; // A>>= N
    case 216: f = (true); break; // A==A f = (a == a)
    case 217: f = (a == b); break; // A==B
    case 218: f = (a == c); break; // A==C
    case 219: f = (a == d); break; // A==D
    case 220: f = (a == uint32_t(m(b))); break; // A==*B
    case 221: f = (a == uint32_t(m(c))); break; // A==*C
    case 222: f = (a == h(d)); break; // A==*D
    case 223: f = (a == uint32_t(header[pc++])); break; // A== N
    case 224: f = (false); break; // A<A f = (a < a)
    case 225: f = (a < b); break; // A<B
    case 226: f = (a < c); break; // A<C
    case 227: f = (a < d); break; // A<D
    case 228: f = (a < uint32_t(m(b))); break; // A<*B
    case 229: f = (a < uint32_t(m(c))); break; // A<*C
    case 230: f = (a < h(d)); break; // A<*D
    case 231: f = (a < uint32_t(header[pc++])); break; // A< N
    case 232: f = (false); break; // A>A f= (a > a)
    case 233: f = (a > b); break; // A>B
    case 234: f = (a > c); break; // A>C
    case 235: f = (a > d); break; // A>D
    case 236: f = (a > uint32_t(m(b))); break; // A>*B
    case 237: f = (a > uint32_t(m(c))); break; // A>*C
    case 238: f = (a > h(d)); break; // A>*D
    case 239: f = (a > uint32_t(header[pc++])); break; // A> N
    case 255: if((pc=hbegin+header[pc]+256*header[pc+1])>=hend)err();break;//LJ
    default: err();
  }
  return 1;
}

// Print illegal instruction error message and exit
void unzZPAQL::err() {
  unzerror("unzZPAQL execution error");
}

///////////////////////// Component //////////////////////////

// A Component is a context model, indirect context model, match model,
// fixed weight mixer, adaptive 2 input mixer without or with current
// partial byte as context, adaptive m input mixer (without or with),
// or SSE (without or with).

struct unzComponent {
  uint32_t limit;      // max count for cm
  uint32_t cxt;        // saved context
  uint32_t a, b, c;    // multi-purpose variables
  Array<uint32_t> cm;  // cm[cxt] -> p in bits 31..10, n in 9..0; MATCH index
  Array<uint8_t> ht;   // ICM/ISSE hash table[0..size1][0..15] and MATCH unzBuf
  Array<uint16_t> a16; // MIX weights
  void init();    // initialize to all 0
  unzComponent() {init();}
};

void unzComponent::init() {
  limit=cxt=a=b=c=0;
  cm.resize(0);
  ht.resize(0);
  a16.resize(0);
}

////////////////////////// StateTable ////////////////////////

// Next state table generator
class StateTable {
  enum {N=64}; // sizes of b, t
  int num_states(int n0, int n1);  // compute t[n0][n1][1]
  void discount(int& n0);  // set new value of n0 after 1 or n1 after 0
  void next_state(int& n0, int& n1, int y);  // new (n0,n1) after bit y
public:
  uint8_t ns[1024]; // state*4 -> next state if 0, if 1, n0, n1
  int next(int state, int y) {  // next state for bit y
    assert(state>=0 && state<256);
    assert(y>=0 && y<4);
    return ns[state*4+y];
  }
  int cminit(int state) {  // initial probability of 1 * 2^23
    assert(state>=0 && state<256);
    return ((ns[state*4+3]*2+1)<<22)/(ns[state*4+2]+ns[state*4+3]+1);
  }
  StateTable();
};

// How many states with count of n0 zeros, n1 ones (0...2)
int StateTable::num_states(int n0, int n1) {
  const int B=6;
  const int bound[B]={20,48,15,8,6,5}; // n0 -> max n1, n1 -> max n0
  if (n0<n1) return num_states(n1, n0);
  if (n0<0 || n1<0 || n1>=B || n0>bound[n1]) return 0;
  return 1+(n1>0 && n0+n1<=17);
}

// New value of count n0 if 1 is observed (and vice versa)
void StateTable::discount(int& n0) {
  n0=(n0>=1)+(n0>=2)+(n0>=3)+(n0>=4)+(n0>=5)+(n0>=7)+(n0>=8);
}

// compute next n0,n1 (0 to N) given input y (0 or 1)
void StateTable::next_state(int& n0, int& n1, int y) {
  if (n0<n1)
    next_state(n1, n0, 1-y);
  else {
    if (y) {
      ++n1;
      discount(n0);
    }
    else {
      ++n0;
      discount(n1);
    }
    // 20,0,0 -> 20,0
    // 48,1,0 -> 48,1
    // 15,2,0 -> 8,1
    //  8,3,0 -> 6,2
    //  8,3,1 -> 5,3
    //  6,4,0 -> 5,3
    //  5,5,0 -> 5,4
    //  5,5,1 -> 4,5
    while (!num_states(n0, n1)) {
      if (n1<2) --n0;
      else {
        n0=(n0*(n1-1)+(n1/2))/n1;
        --n1;
      }
    }
  }
}

// Initialize next state table ns[state*4] -> next if 0, next if 1, n0, n1
StateTable::StateTable() {

  // Assign states by increasing priority
  const int N=50;
  uint8_t t[N][N][2]={{{0}}}; // (n0,n1,y) -> state number
  int state=0;
  for (int i=0; i<N; ++i) {
    for (int n1=0; n1<=i; ++n1) {
      int n0=i-n1;
      int n=num_states(n0, n1);
      assert(n>=0 && n<=2);
      if (n) {
        t[n0][n1][0]=state;
        t[n0][n1][1]=state+n-1;
        state+=n;
      }
    }
  }
       
  // Generate next state table
  memset(ns, 0, sizeof(ns));
  for (int n0=0; n0<N; ++n0) {
    for (int n1=0; n1<N; ++n1) {
      for (int y=0; y<num_states(n0, n1); ++y) {
        int s=t[n0][n1][y];
        assert(s>=0 && s<256);
        int s0=n0, s1=n1;
        next_state(s0, s1, 0);
        assert(s0>=0 && s0<N && s1>=0 && s1<N);
        ns[s*4+0]=t[s0][s1][0];
        s0=n0, s1=n1;
        next_state(s0, s1, 1);
        assert(s0>=0 && s0<N && s1>=0 && s1<N);
        ns[s*4+1]=t[s0][s1][1];
        ns[s*4+2]=n0;
        ns[s*4+3]=n1;
      }
    }
  }
}

///////////////////////// Predictor //////////////////////////

// A predictor guesses the next bit
class unzPredictor {
public:
  unzPredictor(unzZPAQL&);
  void init();          // build model
  int predict();        // probability that next bit is a 1 (0..32767)
  void update(int y);   // train on bit y (0..1)
  bool isModeled() {    // n>0 components?
    assert(z.header.isize()>6);
    return z.header[6]!=0;
  }

private:

  // unzPredictor state
  int c8;               // last 0...7 bits.
  int hmap4;            // c8 split into nibbles
  int p[256];           // predictions
  uint32_t h[256];           // unrolled copy of z.h
  unzZPAQL& z;             // VM to compute context hashes, includes H, n
  unzComponent comp[256];  // the model, includes P

  // Modeling support functions
  int dt2k[256];        // division table for match: dt2k[i] = 2^12/i
  int dt[1024];         // division table for cm: dt[i] = 2^16/(i+1.5)
  uint16_t squasht[4096];    // squash() lookup table
  short stretcht[32768];// stretch() lookup table
  StateTable st;        // next, cminit functions

  // reduce prediction error in cr.cm
  void train(unzComponent& cr, int y) {
    assert(y==0 || y==1);
    uint32_t& pn=cr.cm(cr.cxt);
    uint32_t count=pn&0x3ff;
    int error=y*32767-(cr.cm(cr.cxt)>>17);
    pn+=(error*dt[count]&-1024)+(count<cr.limit);
  }

  // x -> floor(32768/(1+exp(-x/64)))
  int squash(int x) {
    assert(x>=-2048 && x<=2047);
    return squasht[x+2048];
  }

  // x -> round(64*log((x+0.5)/(32767.5-x))), approx inverse of squash
  int stretch(int x) {
    assert(x>=0 && x<=32767);
    return stretcht[x];
  }

  // bound x to a 12 bit signed int
  int clamp2k(int x) {
    if (x<-2048) return -2048;
    else if (x>2047) return 2047;
    else return x;
  }

  // bound x to a 20 bit signed int
  int clamp512k(int x) {
    if (x<-(1<<19)) return -(1<<19);
    else if (x>=(1<<19)) return (1<<19)-1;
    else return x;
  }

  // Get cxt in ht, creating a new row if needed
  size_t find(Array<uint8_t>& ht, int sizebits, uint32_t cxt);
};

// Initailize model-independent tables
unzPredictor::unzPredictor(unzZPAQL& zr):
    c8(1), hmap4(1), z(zr) {
  assert(sizeof(uint8_t)==1);
  assert(sizeof(uint16_t)==2);
  assert(sizeof(uint32_t)==4);
  assert(sizeof(uint64_t)==8);
  assert(sizeof(short)==2);
  assert(sizeof(int)==4);

  // Initialize tables
  dt2k[0]=0;
  for (int i=1; i<256; ++i)
    dt2k[i]=2048/i;
  for (int i=0; i<1024; ++i)
    dt[i]=(1<<17)/(i*2+3)*2;
  for (int i=0; i<32768; ++i)
    stretcht[i]=int(log((i+0.5)/(32767.5-i))*64+0.5+100000)-100000;
  for (int i=0; i<4096; ++i)
    squasht[i]=int(32768.0/(1+exp((i-2048)*(-1.0/64))));

  // Verify floating point math for squash() and stretch()
  uint32_t sqsum=0, stsum=0;
  for (int i=32767; i>=0; --i)
    stsum=stsum*3+stretch(i);
  for (int i=4095; i>=0; --i)
    sqsum=sqsum*3+squash(i-2048);
  assert(stsum==3887533746u);
  assert(sqsum==2278286169u);
}

// Initialize the predictor with a new model in z
void unzPredictor::init() {

  // Initialize context hash function
  z.inith();

  // Initialize predictions
  for (int i=0; i<256; ++i) h[i]=p[i]=0;

  // Initialize components
  for (int i=0; i<256; ++i)  // clear old model
    comp[i].init();
  int n=z.header[6]; // hsize[0..1] hh hm ph pm n (comp)[n] 0 0[128] (hcomp) 0
  const uint8_t* cp=&z.header[7];  // start of component list
  for (int i=0; i<n; ++i) {
    assert(cp<&z.header[z.cend]);
    assert(cp>&z.header[0] && cp<&z.header[z.header.isize()-8]);
    unzComponent& cr=comp[i];
    switch(cp[0]) {
      case CONS:  // c
        p[i]=(cp[1]-128)*4;
        break;
      case CM: // sizebits limit
        if (cp[1]>32) unzerror("max size for CM is 32");
        cr.cm.resize(1, cp[1]);  // packed CM (22 bits) + CMCOUNT (10 bits)
        cr.limit=cp[2]*4;
        for (size_t j=0; j<cr.cm.size(); ++j)
          cr.cm[j]=0x80000000;
        break;
      case ICM: // sizebits
        if (cp[1]>26) unzerror("max size for ICM is 26");
        cr.limit=1023;
        cr.cm.resize(256);
        cr.ht.resize(64, cp[1]);
        for (size_t j=0; j<cr.cm.size(); ++j)
          cr.cm[j]=st.cminit(j);
        break;
      case MATCH:  // sizebits
        if (cp[1]>32 || cp[2]>32) unzerror("max size for MATCH is 32 32");
        cr.cm.resize(1, cp[1]);  // index
        cr.ht.resize(1, cp[2]);  // unzBuf
        cr.ht(0)=1;
        break;
      case AVG: // j k wt
        if (cp[1]>=i) unzerror("AVG j >= i");
        if (cp[2]>=i) unzerror("AVG k >= i");
        break;
      case MIX2:  // sizebits j k rate mask
        if (cp[1]>32) unzerror("max size for MIX2 is 32");
        if (cp[3]>=i) unzerror("MIX2 k >= i");
        if (cp[2]>=i) unzerror("MIX2 j >= i");
        cr.c=(size_t(1)<<cp[1]); // size (number of contexts)
        cr.a16.resize(1, cp[1]);  // wt[size][m]
        for (size_t j=0; j<cr.a16.size(); ++j)
          cr.a16[j]=32768;
        break;
      case MIX: {  // sizebits j m rate mask
        if (cp[1]>32) unzerror("max size for MIX is 32");
        if (cp[2]>=i) unzerror("MIX j >= i");
        if (cp[3]<1 || cp[3]>i-cp[2]) unzerror("MIX m not in 1..i-j");
        int m=cp[3];  // number of inputs
        assert(m>=1);
        cr.c=(size_t(1)<<cp[1]); // size (number of contexts)
        cr.cm.resize(m, cp[1]);  // wt[size][m]
        for (size_t j=0; j<cr.cm.size(); ++j)
          cr.cm[j]=65536/m;
        break;
      }
      case ISSE:  // sizebits j
        if (cp[1]>32) unzerror("max size for ISSE is 32");
        if (cp[2]>=i) unzerror("ISSE j >= i");
        cr.ht.resize(64, cp[1]);
        cr.cm.resize(512);
        for (int j=0; j<256; ++j) {
          cr.cm[j*2]=1<<15;
          cr.cm[j*2+1]=clamp512k(stretch(st.cminit(j)>>8)*1024);
        }
        break;
      case SSE: // sizebits j start limit
        if (cp[1]>32) unzerror("max size for SSE is 32");
        if (cp[2]>=i) unzerror("SSE j >= i");
        if (cp[3]>cp[4]*4) unzerror("SSE start > limit*4");
        cr.cm.resize(32, cp[1]);
        cr.limit=cp[4]*4;
        for (size_t j=0; j<cr.cm.size(); ++j)
          cr.cm[j]=squash((j&31)*64-992)<<17|cp[3];
        break;
      default: unzerror("unknown component type");
    }
    assert(compsize[*cp]>0);
    cp+=compsize[*cp];
    assert(cp>=&z.header[7] && cp<&z.header[z.cend]);
  }
}

// Return next bit prediction using interpreted COMP code
int unzPredictor::predict() {
  assert(c8>=1 && c8<=255);

  // Predict next bit
  int n=z.header[6];
  assert(n>0 && n<=255);
  const uint8_t* cp=&z.header[7];
  assert(cp[-1]==n);
  for (int i=0; i<n; ++i) {
    assert(cp>&z.header[0] && cp<&z.header[z.header.isize()-8]);
    unzComponent& cr=comp[i];
    switch(cp[0]) {
      case CONS:  // c
        break;
      case CM:  // sizebits limit
        cr.cxt=h[i]^hmap4;
        p[i]=stretch(cr.cm(cr.cxt)>>17);
        break;
      case ICM: // sizebits
        assert((hmap4&15)>0);
        if (c8==1 || (c8&0xf0)==16) cr.c=find(cr.ht, cp[1]+2, h[i]+16*c8);
        cr.cxt=cr.ht[cr.c+(hmap4&15)];
        p[i]=stretch(cr.cm(cr.cxt)>>8);
        break;
      case MATCH: // sizebits bufbits: a=len, b=offset, c=bit, cxt=bitpos,
                  //                   ht=unzBuf, limit=pos
        assert(cr.cm.size()==(size_t(1)<<cp[1]));
        assert(cr.ht.size()==(size_t(1)<<cp[2]));
        assert(cr.a<=255);
        assert(cr.c==0 || cr.c==1);
        assert(cr.cxt<8);
        assert(cr.limit<cr.ht.size());
        if (cr.a==0) p[i]=0;
        else {
          cr.c=(cr.ht(cr.limit-cr.b)>>(7-cr.cxt))&1; // predicted bit
          p[i]=stretch(dt2k[cr.a]*(cr.c*-2+1)&32767);
        }
        break;
      case AVG: // j k wt
        p[i]=(p[cp[1]]*cp[3]+p[cp[2]]*(256-cp[3]))>>8;
        break;
      case MIX2: { // sizebits j k rate mask
                   // c=size cm=wt[size] cxt=input
        cr.cxt=((h[i]+(c8&cp[5]))&(cr.c-1));
        assert(cr.cxt<cr.a16.size());
        int w=cr.a16[cr.cxt];
        assert(w>=0 && w<65536);
        p[i]=(w*p[cp[2]]+(65536-w)*p[cp[3]])>>16;
        assert(p[i]>=-2048 && p[i]<2048);
      }
        break;
      case MIX: {  // sizebits j m rate mask
                   // c=size cm=wt[size][m] cxt=index of wt in cm
        int m=cp[3];
        assert(m>=1 && m<=i);
        cr.cxt=h[i]+(c8&cp[5]);
        cr.cxt=(cr.cxt&(cr.c-1))*m; // pointer to row of weights
        assert(cr.cxt<=cr.cm.size()-m);
        int* wt=(int*)&cr.cm[cr.cxt];
        p[i]=0;
        for (int j=0; j<m; ++j)
          p[i]+=(wt[j]>>8)*p[cp[2]+j];
        p[i]=clamp2k(p[i]>>8);
      }
        break;
      case ISSE: { // sizebits j -- c=hi, cxt=bh
        assert((hmap4&15)>0);
        if (c8==1 || (c8&0xf0)==16)
          cr.c=find(cr.ht, cp[1]+2, h[i]+16*c8);
        cr.cxt=cr.ht[cr.c+(hmap4&15)];  // bit history
        int *wt=(int*)&cr.cm[cr.cxt*2];
        p[i]=clamp2k((wt[0]*p[cp[2]]+wt[1]*64)>>16);
      }
        break;
      case SSE: { // sizebits j start limit
        cr.cxt=(h[i]+c8)*32;
        int pq=p[cp[2]]+992;
        if (pq<0) pq=0;
        if (pq>1983) pq=1983;
        int wt=pq&63;
        pq>>=6;
        assert(pq>=0 && pq<=30);
        cr.cxt+=pq;
        p[i]=stretch(((cr.cm(cr.cxt)>>10)*(64-wt)+(cr.cm(cr.cxt+1)>>10)*wt)
             >>13);
        cr.cxt+=wt>>5;
      }
        break;
      default:
        unzerror("component predict not implemented");
    }
    cp+=compsize[cp[0]];
    assert(cp<&z.header[z.cend]);
    assert(p[i]>=-2048 && p[i]<2048);
  }
  assert(cp[0]==NONE);
  return squash(p[n-1]);
}

// Update model with decoded bit y (0...1)
void unzPredictor::update(int y) {
  assert(y==0 || y==1);
  assert(c8>=1 && c8<=255);
  assert(hmap4>=1 && hmap4<=511);

  // Update components
  const uint8_t* cp=&z.header[7];
  int n=z.header[6];
  assert(n>=1 && n<=255);
  assert(cp[-1]==n);
  for (int i=0; i<n; ++i) {
    unzComponent& cr=comp[i];
    switch(cp[0]) {
      case CONS:  // c
        break;
      case CM:  // sizebits limit
        train(cr, y);
        break;
      case ICM: { // sizebits: cxt=ht[b]=bh, ht[c][0..15]=bh row, cxt=bh
        cr.ht[cr.c+(hmap4&15)]=st.next(cr.ht[cr.c+(hmap4&15)], y);
        uint32_t& pn=cr.cm(cr.cxt);
        pn+=int(y*32767-(pn>>8))>>2;
      }
        break;
      case MATCH: // sizebits bufbits:
                  //   a=len, b=offset, c=bit, cm=index, cxt=bitpos
                  //   ht=unzBuf, limit=pos
      {
        assert(cr.a<=255);
        assert(cr.c==0 || cr.c==1);
        assert(cr.cxt<8);
        assert(cr.cm.size()==(size_t(1)<<cp[1]));
        assert(cr.ht.size()==(size_t(1)<<cp[2]));
        assert(cr.limit<cr.ht.size());
        if (int(cr.c)!=y) cr.a=0;  // mismatch?
        cr.ht(cr.limit)+=cr.ht(cr.limit)+y;
        if (++cr.cxt==8) {
          cr.cxt=0;
          ++cr.limit;
          cr.limit&=(1<<cp[2])-1;
          if (cr.a==0) {  // look for a match
            cr.b=cr.limit-cr.cm(h[i]);
            if (cr.b&(cr.ht.size()-1))
              while (cr.a<255
                     && cr.ht(cr.limit-cr.a-1)==cr.ht(cr.limit-cr.a-cr.b-1))
                ++cr.a;
          }
          else cr.a+=cr.a<255;
          cr.cm(h[i])=cr.limit;
        }
      }
        break;
      case AVG:  // j k wt
        break;
      case MIX2: { // sizebits j k rate mask
                   // cm=wt[size], cxt=input
        assert(cr.a16.size()==cr.c);
        assert(cr.cxt<cr.a16.size());
        int err=(y*32767-squash(p[i]))*cp[4]>>5;
        int w=cr.a16[cr.cxt];
        w+=(err*(p[cp[2]]-p[cp[3]])+(1<<12))>>13;
        if (w<0) w=0;
        if (w>65535) w=65535;
        cr.a16[cr.cxt]=w;
      }
        break;
      case MIX: {   // sizebits j m rate mask
                    // cm=wt[size][m], cxt=input
        int m=cp[3];
        assert(m>0 && m<=i);
        assert(cr.cm.size()==m*cr.c);
        assert(cr.cxt+m<=cr.cm.size());
        int err=(y*32767-squash(p[i]))*cp[4]>>4;
        int* wt=(int*)&cr.cm[cr.cxt];
        for (int j=0; j<m; ++j)
          wt[j]=clamp512k(wt[j]+((err*p[cp[2]+j]+(1<<12))>>13));
      }
        break;
      case ISSE: { // sizebits j  -- c=hi, cxt=bh
        assert(cr.cxt==uint32_t(cr.ht[cr.c+(hmap4&15)]));
        int err=y*32767-squash(p[i]);
        int *wt=(int*)&cr.cm[cr.cxt*2];
        wt[0]=clamp512k(wt[0]+((err*p[cp[2]]+(1<<12))>>13));
        wt[1]=clamp512k(wt[1]+((err+16)>>5));
        cr.ht[cr.c+(hmap4&15)]=st.next(cr.cxt, y);
      }
        break;
      case SSE:  // sizebits j start limit
        train(cr, y);
        break;
      default:
        assert(0);
    }
    cp+=compsize[cp[0]];
    assert(cp>=&z.header[7] && cp<&z.header[z.cend] 
           && cp<&z.header[z.header.isize()-8]);
  }
  assert(cp[0]==NONE);

  // Save bit y in c8, hmap4
  c8+=c8+y;
  if (c8>=256) {
    z.run(c8-256);
    hmap4=1;
    c8=1;
    for (int i=0; i<n; ++i) h[i]=z.H(i);
  }
  else if (c8>=16 && c8<32)
    hmap4=(hmap4&0xf)<<5|y<<4|1;
  else
    hmap4=(hmap4&0x1f0)|(((hmap4&0xf)*2+y)&0xf);
}

// Find cxt row in hash table ht. ht has rows of 16 indexed by the
// low sizebits of cxt with element 0 having the next higher 8 bits for
// collision detection. If not found after 3 adjacent tries, replace the
// row with lowest element 1 as priority. Return index of row.
size_t unzPredictor::find(Array<uint8_t>& ht, int sizebits, uint32_t cxt) {
  assert(ht.size()==size_t(16)<<sizebits);
  int chk=cxt>>sizebits&255;
  size_t h0=(cxt*16)&(ht.size()-16);
  if (ht[h0]==chk) return h0;
  size_t h1=h0^16;
  if (ht[h1]==chk) return h1;
  size_t h2=h0^32;
  if (ht[h2]==chk) return h2;
  if (ht[h0+1]<=ht[h1+1] && ht[h0+1]<=ht[h2+1])
    return memset(&ht[h0], 0, 16), ht[h0]=chk, h0;
  else if (ht[h1+1]<ht[h2+1])
    return memset(&ht[h1], 0, 16), ht[h1]=chk, h1;
  else
    return memset(&ht[h2], 0, 16), ht[h2]=chk, h2;
}

//////////////////////////// unzDecoder /////////////////////////

// unzDecoder decompresses using an arithmetic code
class unzDecoder {
public:
  unzReader* in;        // destination
  unzDecoder(unzZPAQL& z);
  int decompress();  // return a byte or EOF
  void init();       // initialize at start of block
private:
  uint32_t low, high;     // range
  uint32_t curr;          // last 4 bytes of archive
  unzPredictor pr;      // to get p
  int decode(int p); // return decoded bit (0..1) with prob. p (0..65535)
};

unzDecoder::unzDecoder(unzZPAQL& z):
    in(0), low(1), high(0xFFFFFFFF), curr(0), pr(z) {
}

void unzDecoder::init() {
  pr.init();
  if (pr.isModeled()) low=1, high=0xFFFFFFFF, curr=0;
  else low=high=curr=0;
}

// Return next bit of decoded input, which has 16 bit probability p of being 1
int unzDecoder::decode(int p) {
  assert(p>=0 && p<65536);
  assert(high>low && low>0);
  if (curr<low || curr>high) unzerror("archive corrupted");
  assert(curr>=low && curr<=high);
  uint32_t mid=low+uint32_t(((high-low)*uint64_t(uint32_t(p)))>>16);  // split range
  assert(high>mid && mid>=low);
  int y=curr<=mid;
  if (y) high=mid; else low=mid+1; // pick half
  while ((high^low)<0x1000000) { // shift out identical leading bytes
    high=high<<8|255;
    low=low<<8;
    low+=(low==0);
    int c=in->get();
    if (c<0) unzerror("unexpected end of file");
    curr=curr<<8|c;
  }
  return y;
}

// Decompress 1 byte or -1 at end of input
int unzDecoder::decompress() {
  if (pr.isModeled()) {  // n>0 components?
    if (curr==0) {  // segment initialization
      for (int i=0; i<4; ++i)
        curr=curr<<8|in->get();
    }
    if (decode(0)) {
      if (curr!=0) unzerror("decoding end of input");
      return -1;
    }
    else {
      int c=1;
      while (c<256) {  // get 8 bits
        int p=pr.predict()*2+1;
        c+=c+decode(p);
        pr.update(c&1);
      }
      return c-256;
    }
  }
  else {
    if (curr==0) {  // segment initialization
      for (int i=0; i<4; ++i)
        curr=curr<<8|in->get();
      if (curr==0) return -1;
    }
    assert(curr>0);
    --curr;
    return in->get();
  }
}

/////////////////////////// unzPostProcessor ////////////////////

class unzPostProcessor {
  int state;   // input parse state: 0=INIT, 1=PASS, 2..4=loading, 5=POST
  int hsize;   // header size
  int ph, pm;  // sizes of H and M in z
public:
  unzZPAQL z;     // holds PCOMP
  unzPostProcessor(): state(0), hsize(0), ph(0), pm(0) {}
  void init(int h, int m);  // ph, pm sizes of H and M
  int write(int c);  // Input a byte, return state
  void setOutput(unzWriter* out) {z.output=out;}
  void setSHA1(unzSHA1* sha1ptr) {z.sha1=sha1ptr;}
  int getState() const {return state;}
};

// Copy ph, pm from block header
void unzPostProcessor::init(int h, int m) {
  state=hsize=0;
  ph=h;
  pm=m;
  z.clear();
}

// (PASS=0 | PROG=1 psize[0..1] pcomp[0..psize-1]) data... EOB=-1
// Return state: 1=PASS, 2..4=loading PROG, 5=PROG loaded
int unzPostProcessor::write(int c) {
  assert(c>=-1 && c<=255);
  switch (state) {
    case 0:  // initial state
      if (c<0) unzerror("Unexpected EOS");
      state=c+1;  // 1=PASS, 2=PROG
      if (state>2) unzerror("unknown post processing type");
      if (state==1) z.clear();
      break;
    case 1:  // PASS
      if (c>=0) z.outc(c);
      break;
    case 2: // PROG
      if (c<0) unzerror("Unexpected EOS");
      hsize=c;  // low byte of size
      state=3;
      break;
    case 3:  // PROG psize[0]
      if (c<0) unzerror("Unexpected EOS");
      hsize+=c*256;  // high byte of psize
      if (hsize<1) unzerror("Empty PCOMP");
      z.header.resize(hsize+300);
      z.cend=8;
      z.hbegin=z.hend=z.cend+128;
      z.header[4]=ph;
      z.header[5]=pm;
      state=4;
      break;
    case 4:  // PROG psize[0..1] pcomp[0...]
      if (c<0) unzerror("Unexpected EOS");
      assert(z.hend<z.header.isize());
      z.header[z.hend++]=c;  // one byte of pcomp
      if (z.hend-z.hbegin==hsize) {  // last byte of pcomp?
        hsize=z.cend-2+z.hend-z.hbegin;
        z.header[0]=hsize&255;  // header size with empty COMP
        z.header[1]=hsize>>8;
        z.initp();
        state=5;
      }
      break;
    case 5:  // PROG ... data
      z.run(c);
      break;
  }
  return state;
}

//////////////////////// unzDecompresser ////////////////////////

// For decompression and listing archive contents
class unzDecompresser {
public:
  unzDecompresser(): z(), dec(z), pp(), state(BLOCK), decode_state(FIRSTSEG) {}
  void setInput(unzReader* in) {dec.in=in;}
  bool findBlock();
  bool findFilename(unzWriter* = 0);
  void readComment(unzWriter* = 0);
  void setOutput(unzWriter* out) {pp.setOutput(out);}
  void setSHA1(unzSHA1* sha1ptr) {pp.setSHA1(sha1ptr);}
  void decompress();  // decompress segment
  void readSegmentEnd(char* sha1string = 0);
private:
  unzZPAQL z;
  unzDecoder dec;
  unzPostProcessor pp;
  enum {BLOCK, FILENAME, COMMENT, DATA, SEGEND} state;  // expected next
  enum {FIRSTSEG, SEG} decode_state;  // which segment in block?
};

// Find the start of a block and return true if found. Set memptr
// to memory used.
bool unzDecompresser::findBlock() {
  assert(state==BLOCK);

  // Find start of block
  uint32_t h1=0x3D49B113, h2=0x29EB7F93, h3=0x2614BE13, h4=0x3828EB13;
  // Rolling hashes initialized to hash of first 13 bytes
  int c;
  while ((c=dec.in->get())!=-1) {
    h1=h1*12+c;
    h2=h2*20+c;
    h3=h3*28+c;
    h4=h4*44+c;
    if (h1==0xB16B88F1 && h2==0xFF5376F1 && h3==0x72AC5BF1 && h4==0x2F909AF1)
      break;  // hash of 16 byte string
  }
  if (c==-1) return false;

  // Read header
  if ((c=dec.in->get())!=1 && c!=2) unzerror("unsupported ZPAQ level");
  if (dec.in->get()!=1) unzerror("unsupported unzZPAQL type");
  z.read(dec.in);
  if (c==1 && z.header.isize()>6 && z.header[6]==0)
    unzerror("ZPAQ level 1 requires at least 1 component");
  state=FILENAME;
  decode_state=FIRSTSEG;
  return true;
}

// Read the start of a segment (1) or end of block code (255).
// If a segment is found, write the filename and return true, else false.
bool unzDecompresser::findFilename(unzWriter* filename) {
  assert(state==FILENAME);
  int c=dec.in->get();
  if (c==1) {  // segment found
    while (true) {
      c=dec.in->get();
      if (c==-1) unzerror("unexpected EOF");
      if (c==0) {
        state=COMMENT;
        return true;
      }
      if (filename) filename->put(c);
    }
  }
  else if (c==255) {  // end of block found
    state=BLOCK;
    return false;
  }
  else
    unzerror("missing segment or end of block");
  return false;
}

// Read the comment from the segment header
void unzDecompresser::readComment(unzWriter* comment) {
  assert(state==COMMENT);
  state=DATA;
  while (true) {
    int c=dec.in->get();
    if (c==-1) unzerror("unexpected EOF");
    if (c==0) break;
    if (comment) comment->put(c);
  }
  if (dec.in->get()!=0) unzerror("missing reserved byte");
}

// Decompress n bytes, or all if n < 0. Return false if done
void unzDecompresser::decompress() {
  assert(state==DATA);

  // Initialize models to start decompressing block
  if (decode_state==FIRSTSEG) {
    dec.init();
    assert(z.header.size()>5);
    pp.init(z.header[4], z.header[5]);
    decode_state=SEG;
  }

  // Decompress and load PCOMP into postprocessor
  while ((pp.getState()&3)!=1)
    pp.write(dec.decompress());

  // Decompress n bytes, or all if n < 0
  while (true) {
    int c=dec.decompress();
    pp.write(c);
    if (c==-1) {
      state=SEGEND;
      return;
    }
  }
}

// Read end of block. If a unzSHA1 checksum is present, write 1 and the
// 20 byte checksum into sha1string, else write 0 in first byte.
// If sha1string is 0 then discard it.
void unzDecompresser::readSegmentEnd(char* sha1string) {
  assert(state==SEGEND);

  // Read checksum
  int c=dec.in->get();
  if (c==254) {
    if (sha1string) sha1string[0]=0;  // no checksum
  }
  else if (c==253) {
    if (sha1string) sha1string[0]=1;
    for (int i=1; i<=20; ++i) {
      c=dec.in->get();
      if (sha1string) sha1string[i]=c;
    }
  }
  else
    unzerror("missing end of segment marker");
  state=FILENAME;
}

///////////////////////// Driver program ////////////////////

uint64_t offset=0;  // number of bytes input prior to current block

// Handle errors
void unzerror(const char* msg) {
  printf("\nError at offset %1.0f: %s\n", double(offset), msg);
  exit(1);
}

// Input archive
class unzInputFile: public unzReader {
  FILE* f;  // input file
  enum {BUFSIZE=4096};
  uint64_t offset;  // number of bytes read
  unsigned p, end;  // start and end of unread bytes in unzBuf
  unzAES_CTR* aes;  // to decrypt
  char unzBuf[BUFSIZE];  // input buffer
  int64_t filesize;
public:
  unzInputFile(): f(0), offset(0), p(0), end(0), aes(0),filesize(-1) {}

  void open(const char* filename, const char* key);

  // Return one input byte or -1 for EOF
  int get() {
    if (f && p>=end) {
      p=0;
      end=fread(unzBuf, 1, BUFSIZE, f);
      if (aes) aes->encrypt(unzBuf, end, offset);
    }
    if (p>=end) return -1;
    ++offset;
    return unzBuf[p++]&255;
  }

  // Return number of bytes read
  uint64_t tell() {return offset;}
  int64_t getfilesize() {return filesize;}
};

	
// Open input. Decrypt with key.
void unzInputFile::open(const char* filename, const char* key) {
  f=fopen(filename, "rb");
  if (!f) {
    perror(filename);
    return ;
  }
	fseeko(f, 0, SEEK_END);
	filesize=ftello(f);
	fseeko(f, 0, SEEK_SET);
	
  if (key) {
    char salt[32], stretched_key[32];
    unzSHA256 sha256;
    for (int i=0; i<32; ++i) salt[i]=get();
    if (offset!=32) unzerror("no salt");
    while (*key) sha256.put(*key++);
    stretchKey(stretched_key, sha256.result(), salt);
    aes=new unzAES_CTR(stretched_key, 32, salt);
    if (!aes) unzerror("out of memory");
    aes->encrypt(unzBuf, end, 0);
  }
}

// File to extract
class unzOutputFile: public unzWriter {
  FILE* f;  // output file or NULL
  unsigned p;  // number of pending bytes to write
  enum {BUFSIZE=4096};
  char unzBuf[BUFSIZE];  // output buffer
public:
  unzOutputFile(): f(0), p(0) {}
  void open(const char* filename);
  void close();

  // write 1 byte
  void put(int c) {
    if (f) {
      unzBuf[p++]=c;
      if (p==BUFSIZE) fwrite(unzBuf, 1, p, f), p=0;
    }
  }

  virtual ~unzOutputFile() {close();}
};

// Open file unless it exists. Print error message if unsuccessful.
void unzOutputFile::open(const char* filename) {
  close();
  f=fopen(filename, "rb");
  if (f) {
    fclose(f);
    f=0;
    fprintf(stderr, "file exists: %s\n", filename);
  }
  f=fopen(filename, "wb");
  if (!f) perror(filename);
}

// Flush output and close file
void unzOutputFile::close() {
  if (f && p>0) fwrite(unzBuf, 1, p, f);
  if (f) fclose(f), f=0;
  p=0;
}


// Write to string
struct unzBuf: public unzWriter {
  size_t limit;  // maximum size
  std::string s;  // saved output
  unzBuf(size_t l): limit(l) {}

  // Save c in s
  void put(int c) {
    if (s.size()>=limit) unzerror("output overflow");
    s+=char(c);
  }
};

// Test if 14 digit date is valid YYYYMMDDHHMMSS format
void verify_date(uint64_t date) {
  int year=date/1000000/10000;
  int month=date/100000000%100;
  int day=date/1000000%100;
  int hour=date/10000%100;
  int min=date/100%100;
  int sec=date%100;
  if (year<1900 || year>2999 || month<1 || month>12 || day<1 || day>31
      || hour<0 || hour>59 || min<0 || min>59 || sec<0 || sec>59)
    unzerror("invalid date");
}

// Test if string is valid UTF8
void unzverify_utf8(const char* s) {
  while (true) {
    int c=uint8_t(*s);
    if (c==0) return;
    if ((c>=128 && c<194) || c>=245) unzerror("invalid UTF-8 first byte");
    int len=1+(c>=192)+(c>=224)+(c>=240);
    for (int i=1; i<len; ++i)
      if ((s[i]&192)!=128) unzerror("invalid UTF-8 extra byte");
    if (c==224 && uint8_t(s[1])<160) unzerror("UTF-8 3 byte long code");
    if (c==240 && uint8_t(s[1])<144) unzerror("UTF-8 4 byte long code");
    s+=len;
  }
}

// read 8 byte LSB number
uint64_t unzget8(const char* p) {
  uint64_t r=0;
  for (int i=0; i<8; ++i)
    r+=(p[i]&255ull)<<(i*8);
  return r;
}

// read 4 byte LSB number
uint32_t unzget4(const char* p) {
  uint32_t r=0;
  for (int i=0; i<4; ++i)
    r+=(p[i]&255u)<<(i*8);
  return r;
}

// file metadata
struct unzDT {		// if you get some warning here, update your compiler!
  uint64_t date;    // if you get some warning here, update your compiler!
  // unzdt YYYYMMDDHHMMSS or 0 if deleted
  uint64_t attr;  // first 8 bytes, LSB first
  std::vector<uint32_t> ptr;  // fragment IDs
  char sha1hex[FRANZOFFSETSHA256];		 // 1+32+32 (unzSHA256)+ zero
  char sha1decompressedhex[FRANZOFFSETSHA256];		 // 1+32+32 (unzSHA256)+ zero
  std::string sha1fromfile;		 // 1+32+32 (unzSHA256)+ zero

  unzDT(): date(0), attr(0) {sha1hex[0]=0x0;sha1decompressedhex[0]=0x0;sha1fromfile="";}
};

typedef std::map<std::string, unzDT> unzDTMap;

bool unzcomparesha1hex(unzDTMap::iterator i_primo, unzDTMap::iterator i_secondo) 
{
	return (strcmp(i_primo->second.sha1hex,i_secondo->second.sha1hex)<0);
}

bool unzcompareprimo(unzDTMap::iterator i_primo, unzDTMap::iterator i_secondo) 
{
	return (i_primo->first<i_secondo->first);
}
///////// end of patched unzpaq206.cpp



/*
	franzo section
*/
/// yes, I can do incomprensible code too :)
/// decode a franzoblock, discriminating on length of the block, to get crc32 and hash, and hashtype
int decode_franz_block(const bool i_isdirectory,const char* i_franz_block,string& o_hashtype,string& o_hashvalue,string& o_crc32value)
{
	int	risultato;

	if (i_franz_block==NULL)
	{
		o_hashtype="";
		o_hashvalue="";
		o_crc32value="";
		return -1;
	}
	
	if (i_franz_block[0]==0)
		if (i_franz_block[0+8]!=0)
		{
			if (i_franz_block[0+40]==0)
			o_hashtype="XXHASH64";
			o_hashvalue=i_franz_block+8;
			risultato=FRANZO_XXHASH64; //franzotype
		}
	
	if (i_franz_block[41]!=0)
		if (i_franz_block[41+8]==0)
		{
			if (i_isdirectory)
				o_crc32value="        ";
			else
				o_crc32value=i_franz_block+41;
		}

	if (i_franz_block[0]=='0')
		if (i_franz_block[1]=='8') // <<< 8, not 4!
			if (i_franz_block[0+66]==0)
			{
				risultato=FRANZO_SHA_1; //franzotype
				o_hashtype="SHA-1";
				o_hashvalue=i_franz_block+2;
				if (i_isdirectory)
					o_crc32value="        ";
				else
				{
					if (i_franz_block[67]!=0)
						if (i_franz_block[67+8]==0)
							o_crc32value=i_franz_block+67;
				}
			}
			
	if (i_franz_block[0]=='0')
		if (i_franz_block[1]=='9') // <<< 9, not 4!
			if (i_franz_block[0+66]==0)
			{
				risultato=FRANZO_XXH3; //franzotype
				o_hashtype="XXH3";
				o_hashvalue=i_franz_block+2;
				if (i_isdirectory)
					o_crc32value="        ";
				else
				{
					if (i_franz_block[67]!=0)
						if (i_franz_block[67+8]==0)
							o_crc32value=i_franz_block+67;
				}
			}


	/// zpaqfranz 52, sha 256. Note: '0' is not "0" !
			
	if (i_franz_block[0]=='0')
		if (i_franz_block[1]=='4')
			if (i_franz_block[0+66]==0)
			{
				risultato=FRANZO_SHA_256; //franzotype
				o_hashtype="SHA-256";
				o_hashvalue=i_franz_block+2;
				if (i_isdirectory)
					o_crc32value="        ";
				else
				{
					if (i_franz_block[67]!=0)
						if (i_franz_block[67+8]==0)
							o_crc32value=i_franz_block+67;
				}
			}
			
	if (i_franz_block[0]=='0')
		if (i_franz_block[1]=='3') // <<< 3, not 4!
			if (i_franz_block[0+66]==0)
			{
				risultato=FRANZO_BLAKE3; //franzotype
				o_hashtype="BLAKE3";
				o_hashvalue=i_franz_block+2;
				if (i_isdirectory)
					o_crc32value="        ";
				else
				{
					if (i_franz_block[67]!=0)
						if (i_franz_block[67+8]==0)
							o_crc32value=i_franz_block+67;
				}
			}

	if (i_franz_block[0]=='0')
		if (i_franz_block[1]=='2') // <<< 2, not 4!
			if (i_franz_block[0+66]==0)
			{
				risultato=FRANZO_SHA3; //franzotype
				o_hashtype="SHA-3";
				o_hashvalue=i_franz_block+2;
				if (i_isdirectory)
					o_crc32value="        ";
				else
				{
					if (i_franz_block[67]!=0)
						if (i_franz_block[67+8]==0)
							o_crc32value=i_franz_block+67;
				}
			}

	if (i_franz_block[0]=='0')
		if (i_franz_block[1]=='1') // <<< 1, not 4!
			if (i_franz_block[0+66]==0)
			{
				risultato=FRANZO_MD5; //franzotype
				o_hashtype="MD5";
				o_hashvalue=i_franz_block+2;
				if (i_isdirectory)
					o_crc32value="        ";
				else
				{
					if (i_franz_block[67]!=0)
						if (i_franz_block[67+8]==0)
							o_crc32value=i_franz_block+67;
				}
			}
	return risultato;
}				

///https://gist.github.com/0x3f00/90edbec0c04616d0b8c21586762bf1ac

static std::string base64encode(const std::string data) 
{
    static constexpr char sEncodingTable[] = {
      'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H',
      'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P',
      'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X',
      'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f',
      'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n',
      'o', 'p', 'q', 'r', 's', 't', 'u', 'v',
      'w', 'x', 'y', 'z', '0', '1', '2', '3',
      '4', '5', '6', '7', '8', '9', '+', '/'
    };

    size_t in_len = data.size();
    if (in_len == 0)
      return "";

    size_t out_len = 4 * ((in_len + 2) / 3);
    std::string ret(out_len, '\0');
    size_t i;
    char *p = const_cast<char*>(ret.c_str());

    if (in_len == 1) {
      ret[0] = sEncodingTable[(data[0] >> 2) & 0x3F];
      ret[1] = sEncodingTable[((data[0] & 0x3) << 4)];
      ret[2] = '=';
      ret[3] = '=';
      return ret;
    }

    if (in_len == 2) {
      ret[0] = sEncodingTable[(data[0] >> 2) & 0x3F];
      ret[1] = sEncodingTable[((data[0] & 0x3) << 4) | ((int)(data[1] & 0xF0) >> 4)];
      ret[2] = sEncodingTable[((data[1] & 0xF) << 2)];
      ret[3] = '=';
      return ret;
    }

    for (i = 0; i < in_len - 2; i += 3) {
      *p++ = sEncodingTable[(data[i] >> 2) & 0x3F];
      *p++ = sEncodingTable[((data[i] & 0x3) << 4) | ((int) (data[i + 1] & 0xF0) >> 4)];
      *p++ = sEncodingTable[((data[i + 1] & 0xF) << 2) | ((int) (data[i + 2] & 0xC0) >> 6)];
      *p++ = sEncodingTable[data[i + 2] & 0x3F];
    }
    if (i < in_len) {
      *p++ = sEncodingTable[(data[i] >> 2) & 0x3F];
      if (i == (in_len - 1)) {
        *p++ = sEncodingTable[((data[i] & 0x3) << 4)];
        *p++ = '=';
      }
      else {
        *p++ = sEncodingTable[((data[i] & 0x3) << 4) | ((int) (data[i + 1] & 0xF0) >> 4)];
        *p++ = sEncodingTable[((data[i + 1] & 0xF) << 2)];
      }
      *p++ = '=';
    }

    return ret;
}

string Jidac::sanitizzanomefile(string i_filename,int i_filelength,int& io_collisioni,MAPPAFILEHASH& io_mappacollisioni)
{
	if  (i_filename=="")
		return("");
		
	string percorso			=extractfilepath(i_filename);
	string nome				=prendinomefileebasta(i_filename);
				
	string estensione		=prendiestensione(i_filename);
	string senzaestensione	=percorso+nome;
	string newname;
		

	int lunghezza=FRANZMAXPATH;
	if (i_filelength>0)
		if (i_filelength<FRANZMAXPATH)
			lunghezza=i_filelength;
	lunghezza-=9; // antidupe
	if (lunghezza<10)
		lunghezza=10;
	char numero[60];
	
	if (flagparanoid) 
	{
		// make unique and short filename
		sprintf(numero,"%08d_",++io_collisioni);
		newname=numero;
		DTMap::iterator p=dt.find(i_filename);

		string myhashtype	="";
		string myhash		="";
		string mycrc32		="";
				
		if (p!=dt.end())
		{
			decode_franz_block(isdirectory(i_filename),p->second.franz_block,
			myhashtype,
			myhash,
			mycrc32);
			if (myhashtype!="")
				if (myhash!="")
				{
					p->second.hexhash=myhash;
					myhash=myhash.substr(0, 10);
					newname+="$"+myhashtype+"!"+myhash+"%";
					p->second.hashtype=myhashtype;
				}
		}
		else
			printf("24501: not found %s\n",i_filename.c_str());
		if (flagdebug)
			printf("24389: paranoid filename <<%s>>\n",newname.c_str());
		return newname;
	}
		
	if (flagflat) /// desperate extract without path and filenames
	{
///		Stay safe		
		string temp=purgeansi(nome.substr(0, 20));
		temp=base64encode(temp);
		
		sprintf(numero,"%08d_%05d_",++io_collisioni,(unsigned int)i_filename.length());
		newname=numero;
		
		newname.append(temp.c_str());
		
		/// retain extension, BUT purge Windows reserved words
		estensione=purgeansi(estensione);

		for (unsigned int j=0;j<forbiddenstringsize;j++)
			myreplaceall(estensione,stringtolower(forbiddenstring[j]),"_");
		
		/// and strip to 3
		if ((estensione.size())>3)
			estensione=myleft(estensione,3);
		
		if (estensione!="")
			newname+="."+estensione;
		
		if (flagdebug)
			printf("25396: flatted filename <<%s>>\n",newname.c_str());
				
		return newname;
	}
	
	if (flagutf)
	{
		string prenome=nome;

// this is name, throw everything (FALSE)
		nome=purgeansi(forcelatinansi(utf8toansi(nome)),false);		
		if (flagdebug)
			if (nome!=prenome)
			{
				printf("25410: flagutf pre  %s\n",prenome.c_str());
				printf("25410: utf8toansi   %s\n",utf8toansi(nome).c_str());
				printf("25410: force2ansi   %s\n",forcelatinansi(utf8toansi(nome)).c_str());
				printf("25411: purgeansi    %s\n",nome.c_str());
			}

		if (flagfixeml)
		{
			if (estensione=="eml")
			{
				prenome=compressemlfilename(nome);
				if (nome!=prenome)
				{
					if (flagdebug)
					{
						printf("18109: eml pre  %s\n",nome.c_str());
						printf("18110: eml post %s\n",prenome.c_str());
					}
									
					nome=prenome;
				}
			}
			else
			{
				for (int i=0;i<10;i++)
					myreplaceall(newname,"  "," ");
					
			}
		}

/// this is a path, so keep \ and / (TRUE)
		string prepercorso=percorso;
		percorso=purgeansi(forcelatinansi(utf8toansi(percorso)),true);		
		if (flagdebug)
			if (percorso!=prepercorso)
			{
				printf("25452: flagutf pre  perc %s\n",prepercorso.c_str());
				printf("25453: flagutf post perc %s\n",percorso.c_str());
			}
	}
					
	if (flagdebug)
	{
		printf("18041: First    %03d %s\n",(int)i_filename.length(),i_filename.c_str());
		printf("18042: Percorso %03d %s\n",(int)percorso.length(),percorso.c_str());
		printf("18043: nome     %03d %s\n",(int)nome.length(),nome.c_str());
		printf("18044: ext      %03d %s\n",(int)estensione.length(),estensione.c_str());
		printf("18045: Senza ex %03d %s\n",(int)senzaestensione.length(),senzaestensione.c_str());
	}

	if (flagfix255)
	{
		int	lunghezzalibera=lunghezza-percorso.length();//%08d_
		if (lunghezzalibera<10)
		{
			if (flagdebug)
			{
				printf("\n\n\n18046: Path too long: need shrink %08d %s\n",(int)percorso.length(),percorso.c_str());
				printf("lunghezzalibera %d\n",lunghezzalibera);
			}
			vector<string> esploso;
						
			string temppercorso=percorso;
			size_t barra;
						
			while (1==1)
			{
				if (flagdebug)
					printf("18031: temppercorso %s\n",temppercorso.c_str());
				barra=temppercorso.find('/');
				if (flagdebug)
					printf("18034: Barra %ld\n",(long int)barra);
				if (barra==string::npos)
					break;
				if (flagdebug)		
					printf("18038: Eureka!!\n");
				esploso.push_back(temppercorso.substr(0, barra));
				temppercorso=temppercorso.substr(barra+1,temppercorso.length());
			}
		
			int lunghezzamassima=0;
			int indicelunghezzamassima=-1;
			for (unsigned int i=0;i<esploso.size();i++)
			{
				if ((int)esploso[i].length()>lunghezzamassima)
				{
					indicelunghezzamassima=i;
					lunghezzamassima=esploso[i].length();
				}
				if (flagdebug)
					printf("18087: Esploso %d %03d %s\n",(int)i,(int)esploso[i].length(),esploso[i].c_str());
			}
						
			int lunghezzacheserve=lunghezza-10-(percorso.length()-lunghezzamassima);
						
			if (lunghezzacheserve<lunghezzamassima)
			{
				esploso[indicelunghezzamassima]=esploso[indicelunghezzamassima].substr(0,lunghezzacheserve);
				string imploso;
				for (unsigned 	int i=0;i<esploso.size();i++)
					imploso+=esploso[i]+'/';
				if (flagdebug)
					printf("18114: Imploso           %d %s\n",(int)imploso.length(),imploso.c_str());
				percorso=imploso;
				lunghezzalibera=lunghezza-percorso.length();
				makepath(percorso);
			}
			else
			{
				printf("18088: HOUSTON\n");
			}						
		}
	}
	newname=nome;
	int lunghezzalibera=lunghezza-percorso.length();
					
	if (flagdebug)
		printf("18098:lunghezze per %03d nome %03d tot %03d\n",(int)percorso.length(),lunghezzalibera,(int)(percorso.length()+lunghezzalibera));
					
	if (newname.length()>(unsigned int)lunghezzalibera)
	{
		newname=newname.substr(0,lunghezzalibera-9);
		if (flagdebug)
			printf("18143:Trimmone newname %d %s\n",(int)newname.length(),newname.c_str());
	}
	
	newname=percorso+newname;
	
	if (flagdebug)
		printf("%d: newname %s\n",__LINE__,newname.c_str());
					
	std::map<string,string>::iterator collisione;
	string candidato=newname;
	if (estensione!="")
		candidato=candidato+'.'+estensione;
	
	// to be reworked by much faster sorted array
	if (flagfix255)	/// we are on windows, take care of case
	{
		/*macos*/
#ifndef ESX		
std::for_each(candidato.begin(), candidato.end(), [](char & c)
		{
			c = ::tolower(c);	
		});
		
	}
	if (flagdebug)
	printf("25570: candidato %s\n",candidato.c_str());
	
	collisione=io_mappacollisioni.find(candidato); 
	if (collisione!=io_mappacollisioni.end()) 
	{
		if (flagdebug)
			printf("18255 found  1 %s\n",candidato.c_str());
		if (collisione->second!=candidato)
		{
			if (flagdebug)
			{
				printf("25582: Collisione %s\n",collisione->second.c_str());
				printf("25583: newname    %s\n",collisione->second.c_str());
			}
			sprintf(numero,"_%d",io_collisioni++);
			newname+=numero;
			if (flagdebug)
				printf("18267: postname   %s\n\n\n\n\n",newname.c_str());
		}
	}
	io_mappacollisioni.insert(std::pair<string, string>(candidato,i_filename));
	
	if (estensione!="")
		newname+="."+estensione;
	
	if (flagdebug)
		printf("18195: Finalized %d %s\n",(int)newname.length(),newname.c_str());
					
	if (newname.length()>255)
	{
		printf("18123: WARN pre  %08d   %s\n",(int)i_filename.length(),i_filename.c_str());
		printf("18124: WARN post %08d   %s\n",(int)newname.length(),newname.c_str());
		printf("\n");
	}
					
	return newname;
}


/*

	section: progress
*/
// Print percent done (td/ts) and estimated time remaining
// two modes: "normal" (old zpaqfranz) "pakka" (new)

// beware STATIC not good for M/T
void print_progress(int64_t ts, int64_t td,int64_t i_scritti,int i_percentuale) 
{
	static int ultimapercentuale=0;
	static int ultimaeta=0;
	
	if (flagnoeta==true)
		return;
		
	if (td>ts) 
		td=ts;
	
	if (td<1000000)
		return;
		
	double eta=0.001*(mtime()-g_start)*(ts-td)/(td+1.0);
	int secondi=(mtime()-g_start)/1000;
	if (secondi==0)
		secondi=1;
	
	int percentuale=int(td*100.0/(ts+0.5));

	if (flagpakka)
	{
		if (eta<350000)
		if (((percentuale%10)==0) ||(percentuale==1))
			if ((percentuale!=ultimapercentuale) || (percentuale==1))
			{
				ultimapercentuale=percentuale;
				printf("%03d%% %02d:%02d:%02d %20s of %20s %s/sec\r", percentuale,
					int(eta/3600), int(eta/60)%60, int(eta)%60, migliaia(td), migliaia2(ts),migliaia3(td/secondi));
			}
	}
	else 
	{
		if (int(eta)!=ultimaeta)
		if (eta<350000)
		{
			ultimaeta=int(eta);
			
			if (i_percentuale>0)
				printf("(%03d%%) %6.2f%% %02d:%02d:%02d (%10s) -> (%10s) of (%10s) %10s/sec\r", i_percentuale,td*100.0/(ts+0.5),int(eta/3600), int(eta/60)%60, int(eta)%60, tohuman(td),tohuman2(i_scritti),tohuman3(ts),tohuman4(td/secondi));
			else
			{
				if (i_scritti>0)
			printf("       %6.2f%% %02d:%02d:%02d (%10s) -> (%10s) of (%10s) %10s/sec\r", td*100.0/(ts+0.5),
			int(eta/3600), int(eta/60)%60, int(eta)%60, tohuman(td),tohuman2(i_scritti),tohuman3(ts),tohuman4(td/secondi));
			else
			printf("       %6.2f%% %02d:%02d:%02d (%10s) of (%10s) %10s/sec\r", td*100.0/(ts+0.5),
			int(eta/3600), int(eta/60)%60, int(eta)%60, tohuman(td),tohuman2(ts),tohuman3(td/secondi));
			}
		}
	}				
}


/// work with a batch job
void avanzamento(int64_t i_lavorati,int64_t i_totali,int64_t i_inizio)
{
	static int ultimapercentuale=0;
	
	if (flagnoeta==true)
		return;
	
	int percentuale=int(i_lavorati*100.0/(i_totali+0.5));
	
	if (percentuale>0)
		if (((percentuale%10)==0)  || (percentuale==1))
	//if ((((percentuale%10)==0) && (percentuale>0)) || (percentuale==1))
	if (percentuale!=ultimapercentuale)
	{
		ultimapercentuale=percentuale;
				
		double eta=0.001*(mtime()-i_inizio)*(i_totali-i_lavorati)/(i_lavorati+1.0);
		int secondi=(mtime()-i_inizio)/1000;
		if (secondi==0)
			secondi=1;
		if (eta<356000)
		printf("%03d%% %02d:%02d:%02d (%10s) of (%10s) %20s /sec\n", percentuale,
		int(eta/3600), int(eta/60)%60, int(eta)%60, tohuman(i_lavorati), tohuman2(i_totali),migliaia3(i_lavorati/secondi));
		fflush(stdout);
	}
}


bool myavanzamento(int64_t i_lavorati,int64_t i_totali,int64_t i_inizio,bool i_barran=true)
{
	bool	hostampato=false;
	static int ultimapercentuale=0;

	int percentuale=int(i_lavorati*100.0/(i_totali+0.5));
	if (percentuale>100)
		percentuale=100;
	if (((percentuale%5)==0) && (percentuale>0))
	if (percentuale!=ultimapercentuale)
	{
		ultimapercentuale=percentuale;
		double eta=0.001*(mtime()-i_inizio)*(i_totali-i_lavorati)/(i_lavorati+1.0);
		int secondi=(mtime()-i_inizio)/1000;
		if (secondi==0)
			secondi=1;
		if (eta<356000)
		{
			printf("%03d%% %02d:%02d:%02d (%10s) of (%10s) %20s/sEc", percentuale,
		int(eta/3600), int(eta/60)%60, int(eta)%60, tohuman(i_lavorati), tohuman2(i_totali),migliaia3(i_lavorati/secondi));
			if (i_barran)
				printf("\n");
			else
				printf("\r");
			hostampato=true;
		}
		fflush(stdout);
	}
	return hostampato;
}

bool myavanzamentoby1sec(int64_t i_lavorati,int64_t i_totali,int64_t i_inizio,bool i_barran=true)
{
	bool	hostampato=false;
	static int ultimotempo=0;

	int secondi=(mtime()-i_inizio)/1000;
	int percentuale=int(i_lavorati*100.0/(i_totali+0.5));
if (percentuale>100)
		percentuale=100;
	
	if (secondi!=ultimotempo)
	{
		ultimotempo=secondi;
		double eta=0.001*(mtime()-i_inizio)*(i_totali-i_lavorati)/(i_lavorati+1.0);
		if (secondi==0)
			secondi=1;
		
		if (eta<356000)
		{
			printf("%03d%% %02d:%02d:%02d (%10s) of (%10s) %20s/SeC", percentuale,
		int(eta/3600), int(eta/60)%60, int(eta)%60, tohuman(i_lavorati), tohuman2(i_totali),migliaia3(i_lavorati/secondi));
	
			if (i_barran)
				printf("\n");
			else
				printf("\r");
			
			hostampato=true;
		}
		fflush(stdout);
	}
	return hostampato;
}


/// sorting functions


// Return p<q for sorting files by decreasing size, then fragment ID list
bool compareFragmentList(DTMap::const_iterator p, DTMap::const_iterator q) {
  if (p->second.size!=q->second.size) return p->second.size>q->second.size;
  if (p->second.ptr<q->second.ptr) return true;
  if (q->second.ptr<p->second.ptr) return false;
  if (p->second.data!=q->second.data) return p->second.data<q->second.data;
  return p->first<q->first;
}

// Sort by sortkey, then by full path
bool compareFilename(DTMap::iterator ap, DTMap::iterator bp) 
{
  if (ap->second.data!=bp->second.data)
    return ap->second.data<bp->second.data;
  return ap->first<bp->first;
}
bool comparedatethenfilename(DTMap::iterator ap, DTMap::iterator bp) 
{
	if (ap->second.date!=bp->second.date)
		return ap->second.date<bp->second.date;
	return ap->first<bp->first;
}

bool comparehexhash0(DTMap::iterator ap, DTMap::iterator bp) {
  if (ap->second.data!=bp->second.data)
    return ap->second.data<bp->second.data;
  return ap->first<bp->first;
}

bool comparehexhash1(DTMap::iterator ap, DTMap::iterator bp) 
{
	if (ap->second.date!=bp->second.date)
		return ap->second.date<bp->second.date;
	return ap->second.hexhash<bp->second.hexhash;
}
bool comparehexhash2(DTMap::iterator ap, DTMap::iterator bp) 
{
  if (ap->second.data!=bp->second.data)
    return ap->second.data<bp->second.data;

	return ap->second.hexhash<bp->second.hexhash;
}
bool comparehexhash3(DTMap::iterator a, DTMap::iterator b) 
{
	char a_start[40];
	char b_start[40];
	sprintf(a_start,"%014lld",(long long)a->second.size);
	sprintf(b_start,"%014lld",(long long)b->second.size);
	
	string	sizea=a_start;
	string	sizeb=b_start;
	
	return a_start+a->second.hexhash<b_start+b->second.hexhash;
}
bool comparehexhash4(DTMap::iterator a, DTMap::iterator b) 
{
	char a_start[40];
	char b_start[40];
	sprintf(a_start,"%014lld",(long long)a->second.size);
	sprintf(b_start,"%014lld",(long long)b->second.size);
	
	string	sizea=a_start;
	string	sizeb=b_start;
	
	return a_start+a->second.hexhash>b_start+b->second.hexhash;
}

bool comparehexhash5(DTMap::iterator a, DTMap::iterator b) 
{
	char a_start[40];
	char b_start[40];
	sprintf(a_start,"%014lld",(long long)a->second.data);
	sprintf(b_start,"%014lld",(long long)b->second.data);
	
	string	sizea=a_start;
	string	sizeb=b_start;
	
	return a_start+a->second.hexhash<b_start+b->second.hexhash;
}

bool comparehexhash6(DTMap::iterator a, DTMap::iterator b) 
{
	char a_start[40];
	char b_start[40];
	sprintf(a_start,"%014lld",(long long)a->second.data);
	sprintf(b_start,"%014lld",(long long)b->second.data);
	
	string	sizea=a_start;
	string	sizeb=b_start;
	
	return a_start+a->second.hexhash>b_start+b->second.hexhash;
}
bool comparehexhash7(DTMap::iterator a, DTMap::iterator b) 
{
	string a_estensione=prendiestensione(a->first);
	string b_estensione=prendiestensione(b->first);
	
	char a_start[40];
	char b_start[40];
	sprintf(a_start,"%014lld",(long long)a->second.size);
	sprintf(b_start,"%014lld",(long long)b->second.size);
	
	string	sizea=a_start;
	string	sizeb=b_start;
	
	return a_estensione+a_start+a->second.hexhash<b_estensione+b_start+b->second.hexhash;
}

bool comparehexhash8(DTMap::iterator a, DTMap::iterator b) 
{
	string a_estensione=prendiestensione(a->first);
	string b_estensione=prendiestensione(b->first);
	string	a_nomefile=prendinomefileebasta(a->first);
	string	b_nomefile=prendinomefileebasta(b->first);
	
	char a_start[40];
	char b_start[40];
	sprintf(a_start,"%014lld",(long long)a->second.size);
	sprintf(b_start,"%014lld",(long long)b->second.size);
	
	string	sizea=a_start;
	string	sizeb=b_start;
	
///	return a_estensione+a_start+a->second.hexhash+a_nomefile>b_estensione+b_start+b->second.hexhash+b_nomefile;
	return a_nomefile+a->second.hexhash>b_nomefile+b->second.hexhash;
	return a_estensione+a_nomefile+a->second.hexhash>b_estensione+b_nomefile+b_start+b->second.hexhash;
}
////// ext;size;name;hash;date;data
		
bool compareorderby(DTMap::iterator a, DTMap::iterator b) 
{
	if (g_theorderby.size()==0)
		return false;

	string 	a_ext		=prendiestensione(a->first);
	string 	b_ext		=prendiestensione(b->first);
	
	string	a_name		=prendinomefileebasta(a->first);
	string	b_name		=prendinomefileebasta(b->first);
	
	string	a_hash		=a->second.hexhash;
	string	b_hash		=b->second.hexhash;
	
	
	string	a_nilsimsa	=a->second.hexhash;
	string	b_nilsimsa	=b->second.hexhash;
	
	string	a_date		=dateToString(a->second.date);
	string	b_date		=dateToString(b->second.date);
	
	char buffer[40];

	sprintf(buffer,"%014lld",(long long)a->second.size);
	string	a_size=buffer;

	sprintf(buffer,"%014lld",(long long)b->second.size);
	string	b_size=buffer;
		
	sprintf(buffer,"%08X",(unsigned int)a->second.data);
	string	a_data=buffer;
		
	sprintf(buffer,"%08X",(unsigned int)b->second.data);
	string	b_data=buffer;
	
///////// ext;size;name;hash;date;data
	string	a_compare=orderby;
	myreplaceall(a_compare,"ext;"		,a_ext);
	myreplaceall(a_compare,"size;"		,a_size);
	myreplaceall(a_compare,"name;"		,a_name);
	myreplaceall(a_compare,"hash;"		,a_hash);
	myreplaceall(a_compare,"date;"		,a_date);
	myreplaceall(a_compare,"data;"		,a_data);
	myreplaceall(a_compare,"nilsimsa;"	,a_nilsimsa);
	
	string	b_compare=orderby;
	myreplaceall(b_compare,"ext;"		,b_ext);
	myreplaceall(b_compare,"size;"		,b_size);
	myreplaceall(b_compare,"name;"		,b_name);
	myreplaceall(b_compare,"hash;"		,b_hash);
	myreplaceall(b_compare,"date;"		,b_date);
	myreplaceall(b_compare,"data;"		,b_data);
	myreplaceall(b_compare,"nilsimsa;"	,b_nilsimsa);
	
	if (flagdesc)
	{
		if (a_compare!=b_compare)
			return a_compare>b_compare;
	}
	else
	{
		if (a_compare!=b_compare)
			return a_compare<b_compare;
	}
	return a->first<b->first;

}
/*
	Section: help
*/
void help_printhash(bool i_flagadd)
{
	moreprint("+ : -crc32        Ancient but ubiquitous, superfast");
	moreprint("+ : -xxh3         One of the fastest (128 bit), strong");
	moreprint("+ : -xxhash       Very fast (64 bit), low CPU");
	moreprint("+ : -sha1         Fair speed, very reliable, some collisions known");
	moreprint("+ : -sha256       CPU intensive, one of the most reliable. Legal proof in EU");
	moreprint("+ : -sha3         Latest NIST standard, very, very strong");
	moreprint("+ : -blake3       Fast, CPU intensive (on Win64 HW acceleration), very reliable");
	moreprint("+ : -md5          Very common, widespread usage");
	if (!i_flagadd)
	{
		moreprint("+ : -crc32c       'Castagnoli', HW accelerated");
		moreprint("+ : -wyhash       Maybe the fastest, limited 'strength'");
		moreprint("+ : -whirlpool    Slow but very reliable");
		moreprint("+ : -nilsimsa     Look for similarities");
		moreprint("+ : -entropy      Quick-and-dirty entropy estimator");
	}
}
void help_printhashline(bool i_flagadd)
{
	moreprint("+ : -crc32  -xxhash -md5 -sha1 -xxh3 -blake3 -sha256 -sha3");
	if (!i_flagadd)
		moreprint("+ : -crc32c -wyhash -whirlpool -nilsimsa -entropy");
}

void help_b(bool i_usage,bool i_example)
{
	if (i_usage)
	{
		moreprint("CMD   b (benchmark and CPU stresser)");
		moreprint("<>:               Rough benchmarking of hash-checksum");
		moreprint("<>:               franzomips (fake index) showed if no switch selected");
		moreprint("<>:               By default test ALL for 5 seconds with 400.000 bytes");
		moreprint("<>:               NOTE: THIS IS THE MAXIMUM PERFORMANCES, not the real one!");
		moreprint("<>: -verbose      Verbose output");
		moreprint("<>: -n X          Set time limit to X s (<1000)");
		moreprint("<>: -minsize Y    Run on chunks of Y bytes (<2000000000)");

		help_printhash(false);
		moreprint("+ : -all          Multithread run (CPU cooker)");
		moreprint("+ : -tX           With -all limit to X threads");
	}
	if (i_usage && i_example) moreprint("    Examples:");
	
	if (i_example)
	{
		moreprint("Benchmark all:                       b");
		moreprint("Benchmark all on 1.86GB:             b -minsize 2000000000");
		moreprint("Benchmark all on 1MB:                b -minsize 1048576");
		moreprint("Benchmark SHA256 and BLAKE3:         b -sha256 -blake 3 -minsize 1048576");
		moreprint("Benchmark for 10 second each:        b -n 10 -sha256 -blake3 -minsize 1048576");
		moreprint("Cook the CPU (all cores):            b -all -n 20 -blake3");
		moreprint("Cook the CPU (8 cores):              b -all -t8 -n 20 -blake3");
	}
}
void help_setpassword(bool i_usage,bool i_example)
{
	if (i_usage)
	{
		moreprint("CMD   password    Change/remove password of single archive (no multipart)");
		moreprint("<>:               By default DRY RUN (only test)");
		moreprint("<>: -force        Overwrite output if exists");
		moreprint("<>: -space        Do not check for free space");
		moreprint("<>: -key2 X       Use X as new password");
	}
	if (i_usage && i_example) moreprint("    Examples:");
	
	if (i_example)
	{
		moreprint("Change pass from X to Y:             password z:\\x.zpaq z:\\y.zpaq -key X -key2 Y");
		moreprint("Add password X to NON encrypted:     password z:\\nocrypt.zpaq z:\\yescrypt.zpaq -key2 X");
		moreprint("Remove password X from encrypted:    password z:\\crypt.zpaq z:\\nocrypt.zpaq -key X");
	}
}
void help_trim(bool i_usage,bool i_example)
{
	if (i_usage)
	{
		moreprint("CMD   trim        Trim incomplete .zpaq file");
		moreprint("<>:               By default DRY RUN (only test)");
		moreprint("<>: -kill         Do a 'wet' (effective) in-place run");
		moreprint("<>: -to tiny.zpaq Trim on tiny.zpaq");
		moreprint("<>: -verify       Check the copy before trim");
	}
	if (i_usage && i_example) moreprint("    Examples:");
	
	if (i_example)
	{
		moreprint("Trim file (dry run):                 trim z:\\1.zpaq");
		moreprint("Trim file IN PLACE (wet run):        trim z:\\1.zpaq -kill");
		moreprint("Trim file on other (safer):          trim z:\\1.zpaq -to d:\\small.zpaq");
		moreprint("Trim file w/verify:                  trim z:\\1.zpaq -to d:\\small.zpaq -verify");
		
	}
}

void help_a(bool i_usage,bool i_example)
{
	if (i_usage)
	{
		moreprint("CMD   a (add)");
		moreprint("<>:               zpaqfranz store CRC-32/XXH of each file, detecting SHA-1 collisions,");
		moreprint("                  while zpaq cannot by design. Can be disabled by -crc32 or -715,");
		moreprint("                  on modern CPU slow down ~10%.");
		moreprint("                  In archive and files substitute $hour $min $sec $weekday $year $month $day");
		moreprint("                  $week $date $time $datetime");
		moreprint("<>:               By default do NOT store ADSs on Windows (essentially useless).");
		moreprint("<>:               By default every .XLS file is forcibily added (old Excel change metafiles).");
		moreprint("+ : -verbose      Verbose output");
		moreprint("+ : -debug        Show LOTS of infos");
		moreprint("+ : -summary      Be brief");
		moreprint("+ : -noeta        Do not show ETA (redirect output to log file)");
		moreprint("+ : -pakka        New-style output (by chunks)");
		moreprint("<>: -forcewindows Store ADS stuff                (default: NO)");
		moreprint("<>: -xls          Do NOT force adding of XLS/PPT (default: NO)");
		moreprint("<>: -forcezfs     Do NOT ignore .zfs             (default: YES)");
		moreprint("<>: -715          Runs just about like 7.15");
		moreprint("+ : -debug -zero       Add files but zero-filled (debugging)");
		moreprint("+ : -debug -zero -kill Add 0-byte long file (debugging)");
		moreprint("+ : -nochecksum   Disable zpaqfranz additional checks (faster, less sure)");
		moreprint("+ : -nodedup      Turn off deduplicator");
		moreprint("+ : -tar          Tar mode: no deduplication, no compression");
		moreprint("+ : -touch        Force 'touch' on date (converting 7.15 to zpaqfranz)");
		help_printhash(true);
		moreprint("+ : -test         Do a post-add test (doveryay, no proveryay).");
		moreprint("+ : -verify       Verify hashes against filesystem");
		moreprint("+ : -verify -ssd  Verify hashes against filesystem MULTITHREAD (do NOT use on spinning drives)");
		moreprint("+ : -vss          Volume Shadow Copies (Win with admin rights) to backup files from %users%.");
		moreprint("+ : -timestamp X  Setting version datetime @X, ex 2021-12-30_01:03:04 to freeze zfs snapshots");
		moreprint("                  Must be monotonic. increasing (v[i+1].date>v[i]+date)");
		moreprint("+ : -comment foo  Add a version with ASCII text 'foo'");
		moreprint("+ : -filelist     Add the list of file to be added in a VFILE");
		moreprint("+ : -copy z:\\two  Make a 2nd copy of the written data into another folder");
		moreprint("+ : -exec_ok p.sh After successful run launch p.sh with archive name as parameter");
		moreprint("+ : -freeze kajo  If current archive size > maxsize, move to kajo folder");
		moreprint("+ : -orderby x    Sort files by (one or more of) ext;size;name;hash;date;data;nilsimsa;");
		moreprint("+ : -desc         Descending sort (if -orderby)");
#if defined(_WIN32)
		moreprint("+ : -sfx autoz    Make SFX autoz.exe (on Win)");
		moreprint("+ : -sfxto foldr  Set -to into the SFX module");
		moreprint("+ : -sfxforce     Set -force into the SFX module");
		moreprint("+ : -sfxnot       Like -not for SFX");
		moreprint("+ : -sfxonly      Like -only for SFX");
		moreprint("+ : -sfxuntil     Like -until for SFX");
		moreprint("+ : -longpath     Adding on Windows filenames longer than 255");
#endif
	}
	if (i_usage && i_example) 
		moreprint("    Examples:");
	
	if (i_example)
	{
		moreprint("Add two folders to archive:          a z:\\1.zpaq c:\\data\\* d:\\pippo\\*");
		moreprint("Add folder, storing full hash SHA3:  a z:\\2.zpaq c:\\nz\\ -sha3");
		moreprint("Add folder, then verification:       a z:\\3.zpaq c:\\nz\\ -test");
		moreprint("Add two files:                       a z:\\4.zpaq.zpaq c:\\vecchio.sql r:\\1.txt");
		moreprint("Add as zpaq 7.15 (no checksum):      a z:\\5.zpaq c:\\audio -715");
		moreprint("Add and mark version:                a z:\\6.zpaq c:\\data\\* -comment first_copy");
	#if defined(_WIN32) || defined(_WIN64)
		moreprint("Add by a VSS (Windows admin):        a z:\\7.zpaq c:\\users\\utente\\* -vss");
	#endif
		moreprint("Add folder with timestamping (zfs):  a z:\\8.zpaq c:\\data\\* -timestamp 2021-12-30_01:03:04");
		moreprint("Create multipart archive:            a \"z:\\9_????.zpaq\" c:\\data\\");
		moreprint("Create indexed multipart archive:    a \"z:\\a_???.zpaq\" c:\\data\\ -index z:\\a_000.zpaq");
		moreprint("Add folder, with encryption:         a z:\\b.zpaq c:\\nz\\ -key mygoodpassword");
		moreprint("Add folder, maximum compress:        a z:\\c.zpaq c:\\nz\\ -m5");
		moreprint("Store the filelist VFILE:            a z:\\d.zpaq c:\\nz\\ -filelist");
		moreprint("Add WITHOUT CRC-32/hash (like 715):  a z:\\e.zpaq c:\\nz\\ -nochecksum");
		moreprint("Add 2nd copy to USB drive (U):       a \"z:\\f_???.zpaq\" c:\\nz\\ -copy u:\\usb");
		moreprint("Launch pippo.bat after OK:           a \"z:\\g_???.zpaq\" c:\\nz\\ -exec_ok u:\\pippo.bat");
		moreprint("Archive file if bigger of 10GB:      a z:\\h.zpaq c:\\nz\\ -freeze y:\\archived -maxsize 10000000000");
#if defined(_WIN32)
		moreprint("Make z:\\2.exe from z:\\1.zpaq:        a z:\\1.zpaq *.cpp -sfx z:\\2.exe");
		moreprint("2.exe extract/overwrite into z:\\kom: a z:\\1.zpaq *.cpp -sfx z:\\2.exe -sfxto z:\\kom -sfxforce");
#endif
		moreprint("Prepare a debug archive...for me     a z:\\1.zpaq c:\\nz\\ -debug -zero");
		moreprint("In-place 7.15 to zpaqfranz  1/2      a z:\\1.zpaq c:\\nz\\ -touch");
		moreprint("In-place 7.15 to zpaqfranz  2/2      a z:\\1.zpaq c:\\nz\\");
	}
}

void help_rd(bool i_usage,bool i_example)
{
	if (i_usage)
	{
		moreprint("CMD   rd (remove directory on Windows)");
		moreprint("+ :               Delete hard-to-remove dir (like rd /s or rm -r)");
		moreprint("+ : -kill         Wet run (default: DRY run)\n");
		moreprint("+ : -force        Remove folder if not-zero files present\n");
		moreprint("+ : -space        Do not check if writeable (ex. 0 bytes free)\n");
	}
	if (i_usage && i_example) moreprint("    Examples:");
	if (i_example)
		moreprint("Remove folder z:\\kajo:     rd z:\\kajo -force -kill -space");
}

void help_w(bool i_usage,bool i_example)
{
	if (i_usage)
	{
		moreprint("CMD   w (Chunked-extraction)");
		moreprint("+ :               Extract/test in chunks, on disk or 'ramdisk' (RAM)");
		moreprint("+ :               The output -to folder MUST BE EMPTY");
		moreprint("+ : -maxsize X    Maxsize of the chunk @ X bytes\n");
		moreprint("+ : -ramdisk      Use 'RAMDISK'\n");
		moreprint("+ : -frugal       Use less possible RAM (default: get 75% of free RAM)'\n");
		moreprint("+ : -ssd          Multithread writing from ramdisk\n");
		moreprint("+ : -test         Do not write on media\n");
		moreprint("+ : -verbose      Show useful infos\n");
		moreprint("+ : -checksum     Do CRC-32 / hashes test\n");
		moreprint("+ : -verify       Do a 'check-against-filesystem'\n");
		moreprint("+ : -paranoid     Extract to filesystem, then delete if OK (need -verify)\n");
		#ifdef _WIN32
		moreprint("+ : -longpath     Extracting on Windows filenames longer than 255");
		#endif
	}
	if (i_usage && i_example) moreprint("    Examples:");
	if (i_example)
	{
		moreprint("Extract to a spinning drive:         w z:\\1.zpaq -to p:\\muz7\\ -ramdisk -longpath");
		moreprint("Paranoid check into folder muz7:     w z:\\1.zpaq -to z:\\muz7\\ -paranoid -verify -verbose -frugal -longpath");
		moreprint("Paranoid  max chunksize 1000000000:  w z:\\1.zpaq -to z:\\muz7\\ -paranoid -verify -maxsize 1000000000");
		moreprint("Test in RAM (no disk write,M/T)      w z:\\1.zpaq -ramdisk -test -checksum -ssd -frugal");
		moreprint("Top test (W/disk write on SSD z:\\)   w z:\\1.zpaq -to z:\\kajo -ramdisk -paranoid -verify -checksum -longpath -ssd");
	}
}
void help_x(bool i_usage,bool i_example)
{
	if (i_usage)
	{
		moreprint("CMD   x (extract)");
		moreprint("+ :               During extraction,if CRC-32s are present, the codes are checked.");
		moreprint("+ : -checksum     force a full hash-code verify (if added with -checksum)");
		moreprint("+ : -zero         extract to dummy, 0-length files. Da a empty-full restore.");
		moreprint("+ : -zero -debug  extract full-sized files, 0 filled (Dry restore)");
		moreprint("+ : -utf          change everything non latin to latin (Linux/*Nix => NTFS compatibility)");
		moreprint("+ : -fix255       shrink max file name, avoid different case collision (Linux => NTFS)");
		moreprint("                  (pippo.txt and PIPPO.txt are be silently overwritten by 7.15).");
		moreprint("+ : -fixeml       compress .eml filenames.");
#ifdef _WIN32
		moreprint("+ : -fixreserved  fix reserved filenames on Windows (ex. LPT1).");
#endif
		moreprint("+ : -flat         emergency restore of everything into a single folder (Linux => NTFS)");
		moreprint("+ : -filelist     show (if any) a stored filelist");
		moreprint("+ : -force        Force overwrite AND extracting of corrupted files (if any)");
		moreprint("+ : -space        Do not check free space before extract");
		moreprint("+ : -find/replace Replace part of text");
		moreprint("+ : -replace X    Juxtapose X to stored path");
		#ifdef _WIN32
		moreprint("+ : -longpath     Extracting on Windows filenames longer than 255");
		#endif
	}
	if (i_usage && i_example) moreprint("    Examples:");
	if (i_example)
	{
		moreprint("Extract into folder muz7:            x z:\\1.zpaq -to z:\\muz7\\");
		moreprint("0-bytes files (check restoration):   x z:\\1.zpaq -to z:\\muz7\\ -kill");
		moreprint("Extract into single directory:       x z:\\1.zpaq -to z:\\muz7\\ -flat");
		moreprint("Extract without utf,<255,.eml:       x z:\\1.zpaq -to z:\\muz7\\ -utf -fix255 -fixeml");
		moreprint("Extract forcing overwrite:           x z:\\1.zpaq -to z:\\muz7\\ -force");
		moreprint("Extract version K:                   x z:\\1.zpaq -to z:\\muz7\\ -until K");
		moreprint("Extract last versions of multipart:  x \"z:\\a_???\" -to z:\\ugo");
		moreprint("Extract into muz7 every versions:    x z:\\1.zpaq -to z:\\muz7\\ -all");
		moreprint("Show the filelist (if any):          x z:\\1.zpaq -filelist");
		moreprint("Show the filelist (if any) of v3:    x z:\\1.zpaq -filelist -until 3");
		moreprint("Extract all *.xls into new archive:  x z:\\1.zpaq *.xls -repack onlyxls.zpaq");
		moreprint("Extract from a VSS (Windows):        x z:\\1.zpaq \\\\?\\GLOBALROOT\\Device\\HarddiskVolumeShadowCopy1\\path -to d:\\output");
		moreprint("Replace path in extract              x 1.zpaq -find /tank/ -replace z:\\uno\\");
		moreprint("Change path in extract, longpath     x 1.zpaq -replace z:\\uno\\ -longpath");		
	}
}
void help_l(bool i_usage,bool i_example)
{
	if (i_usage)
	{
		moreprint("CMD   l (list)");
		moreprint("+ :               If source folders are specified, do a compare of the archive's content.");
		moreprint("                  A 'verify' more than a 'list', much faster than the standard,");
		moreprint("                  as it performs a block calc  codes of source files, but not of");
		moreprint("                  the archived ones; also checks the CRC-32, to intercept any SHA1 collisions.");
		moreprint("                  Use the exact same parameters of add(), just use l instead of a.");
		moreprint("+ : -force        Shows all files (even marked as corrupted)");
		moreprint("+ : -checksum     Shows CRC-32/hash, if any");
		moreprint("+ : -summary      Compact file list");
		moreprint("+ : -comment foo  Extract version foo, if possible");
		moreprint("+ : -find pippo   Just like |grep -i pippo");
		moreprint("+ : -replace foo  Replace -find with -replace in the output");
		moreprint("+ : -to knb       Do the standard rename()");
		moreprint("+ : -utc          Do not convert to localtime (show UTC)");
		
	}
	if (i_usage && i_example) moreprint("    Examples:");
	if (i_example)
	{
		moreprint("Last version:                        l z:\\1.zpaq");
		moreprint("Last version w/checksums:            l z:\\1.zpaq -checksum");
		moreprint("Compact output:                      l z:\\1.zpaq -checksum -summary");
		moreprint("Compact output renamed:              l z:\\1.zpaq -checksum -summary -to z:\\knb");
		moreprint("All (every) version:                 l z:\\1.zpaq -all");
		moreprint("Version comments (if any):           l z:\\1.zpaq -comment");
		moreprint("V.comments verbose (if any):         l z:\\1.zpaq -comment -all");
		moreprint("Only stored 'zpaq.cpp':              l z:\\1.zpaq -find zpaq.cpp -pakka");
		moreprint("Find-and-replace (like awk or sed)   l r:\\1.zpaq -find c:/biz/ -replace z:\\mydir\\");
		moreprint("List the 10 greatest file            l z:\\1.zpaq -n 10");
	}
}

void help_i(bool i_usage,bool i_example)
{
	if (i_usage)
	{
		moreprint("CMD   i (info)");
		moreprint("+ :               Directly shows the versions into the archive, with size and comments");
		moreprint("+ : -stat         Count 'weird' files");
	}
	if (i_usage && i_example) moreprint("    Examples:");
	if (i_example)
	{
		moreprint("Show versions info (command i):      i z:\\1.zpaq");
		moreprint("Count 'not good filenames'):         i z:\\1.zpaq -stat");
	}
}

void help_q(bool i_usage,bool i_example)
{
	if (i_usage)
	{
		moreprint("CMD   q Windows archiving of C: (*** admin rights mandatory ***)");
		moreprint("+ :               Take as much C: as possible (no Windows and swapfile)");
		moreprint("+ :               This is NOT a full backup (aka: bare-metal restorable)");
		moreprint("+ : -forcewindows INCLUDE Windows folder");
		moreprint("+ : -frugal       Exclude Windows, %programfiles% and %temp%");
		moreprint("+ : -all          Get everything (except swapfile)");
		moreprint("+ :               Just about all switches of add() (-key -m -only ...)");
		moreprint("+ :               except files selection (always C:/*) and -to");
		moreprint("+ :     ****      The folder c:/franzsnap MUST NOT EXIST");

	}
	if (i_usage && i_example) moreprint("    Examples:");
	if (i_example)
	{
		moreprint("NOT C:\\WINDOWS, NOT RECYCLE BIN      q z:\\1.zpaq");
		moreprint("Everything                           q z:\\1.zpaq -all");
		moreprint("Everything NOT C:\\DROPBOX            q z:\\1.zpaq -all -not c:/franzsnap/dropbox");
		moreprint("NOT C:\\WINDOWS, NOT %programs%       q z:\\1.zpaq -frugal");
		moreprint("Only C/C++ files and header          q z:\\1.zpaq -only *.c* -only *.h*");
	}
}
void help_g(bool i_usage,bool i_example)
{
	if (i_usage)
	{
		moreprint("CMD   g Run a q command (Windows archiving of C:)");
		moreprint("+ :               If the user is in the administrator group, BUT");
		moreprint("+ :               the current shell does not have admin rights, you");
		moreprint("+ :               the current shell does not have admin rights, you");
	}
	if (i_usage && i_example) moreprint("    Examples:");
	if (i_example)
	{
		moreprint("NOT C:\\WINDOWS, NOT RECYCLE BIN      g z:\\1.zpaq");
		moreprint("... same as command q, but with g");
	}
}


void help_dirsize(bool i_usage,bool i_example)
{
	if (i_usage)
	{
		moreprint("CMD   dirsize Show cumulative folder(s) size");
		moreprint("                  Case INsensitive ENDING with parameters (unless -force)");
		moreprint("                  i.e. marcus == /1/marcus, /tank/d/documenti/MARCUS");
		moreprint("+ : -force        Exact match; /tank/marcus != /tank/MARCUS");
	}
	if (i_usage && i_example) moreprint("    Examples:");
	if (i_example)
	{
			moreprint("Search with 2 parameters       :       dirsize z:\\1.zpaq marcus vanessa");
			moreprint("Getting size (insensitive)     :       dirsize z:\\1.zpaq /tank/d/documenti/marcus -force");
	}
}

void help_sfx(bool i_usage,bool i_example)
{
	if (i_usage)
	{
		moreprint("CMD   sfx (sfx module, with encryption support)");
		moreprint("+ :               (no switch): Write SFX along the .zpaq");
		moreprint("                  (w/switch) : Convert .zpaq (max 2GB) to Windows .EXE");
	}
	if (i_usage && i_example) moreprint("    Examples:");
	if (i_example)
	{
		moreprint("Create  z:\\1.exe               :      sfx z:\\1.zpaq");
		moreprint("Convert 1.zpaq to 2.exe        :      sfx z:\\1.zpaq -sfx z:\\2.exe");
	}
}
void help_rsync(bool i_usage,bool i_example)
{
	if (i_usage)
	{
		moreprint("CMD   rsync Delete dangling temporary rsync file");
		moreprint("+ : -kill         Wet run (default: dry run)");
	}
	if (i_usage && i_example) moreprint("    Examples:");
	if (i_example)
	{
		moreprint("Purge temporary (dry run):            rsync \\\\nas\\thebackup");
		moreprint("Purge temporary (WET run):            rsync \\\\nas\\thebackup -kill");
	}
}
void help_t(bool i_usage,bool i_example)
{
	if (i_usage)
	{
		moreprint("CMD   t (test)");
		moreprint("+ :               Check that all block are OK, and the CRC-32s of the individual ");
		moreprint("                  files corresponds to what would be generated by actually extracting.");
		moreprint("+ : -checksum     Enable hash checksums");
		moreprint("+ : -verify       Do a filesystem post-check: STORED CRC==DECOMPRESSED==FROM FILE.");
		moreprint("+ : -verify -ssd  Multithread verify (do NOT use on spinning drives)");
		moreprint("+ : -find pippo   For path-rework of verify");
		moreprint("+ : -replace plu  For path-rework of verify (find and replace)");
		moreprint("+ : -paranoid     Extract all into -to something, check every file with stored hash");
		moreprint("+ :               delete every equal files");
///		moreprint("+ : -ramdisk      Extract to RAM (high memory usage)");
	}
		
	if (i_usage && i_example) moreprint("    Examples:");
	if (i_example)
	{
		moreprint("Last version:                        t z:\\1.zpaq");
		moreprint("All versions:                        t z:\\1.zpaq -all");
		moreprint("Compare against filesystem:          t z:\\1.zpaq -verify");
		moreprint("Against filesystem, 4 threads:       t z:\\1.zpaq -verify -ssd -t4");
		moreprint("Real paranoid: extract all           t z:\\1.zpaq -to z:\\knb -paranoid");
		moreprint("Fast-SHA1 (nz the source dir):       t z:\\1.zpaq c:\\nz");
		moreprint("Cnk-SHA1+hash (nz the source dir):   t z:\\1.zpaq c:\\nz -checksum");
//		moreprint("Test in RAMDISK                      t 1.zpaq -test -ramdisk");
///		moreprint("Test filesystem + RAMDISK            t 1.zpaq -to z:\\tempdir -ramdisk");
	}
}
void help_v(bool i_usage,bool i_example)
{
	if (i_usage)
	{
		moreprint("CMD   v (verify)");
		moreprint("+ :               Verify all files (by hashes) against filesystem");
		moreprint("+ : -ssd          Multithread (for SSD/NVMe). Do NOT use on spinning drives");
		moreprint("+ : -tX           Limit -ssd to X threads");
		moreprint("+ : -until Y      Check the version Y");
		moreprint("+ : -find pippo   For path-rework of verify");
		moreprint("+ : -replace plu  For path-rework of verify (find and replace)");
		moreprint("+ : -verbose      Show distinct errors");
		moreprint("+ : -debug        Show lots of info");
		moreprint("+ : -output x.txt Put errors in x.txt");
	}
	if (i_usage && i_example) moreprint("    Examples:");
	if (i_example)
	{
		moreprint("Last version:                        v z:\\1.zpaq");
		moreprint("Show errors line by line:            v z:\\1.zpaq -verbose");
		moreprint("2n version:                          v z:\\1.zpaq -until 2");
		moreprint("Remake path:                         v z:\\1.zpaq -find c:\\dropbox -replace z:\\knb");
		moreprint("1st version, multithread:            v z:\\1.zpaq -until 1 -ssd");
	}
}
void help_p(bool i_usage,bool i_example)
{
	if (i_usage)
	{
		moreprint("CMD   p (paranoid test)");
		moreprint("+ :               Test the archive (** NOT multipart **) in a very paranoid fashion.");
		moreprint("                  ZPAQ reference decompressor is used to extract blocks in RAM.");
		moreprint("                  Runs on unzpaq206.cpp source instead of 7.15 extract: double check");
		moreprint("                  to avoid the risk of 'silent' bugs. The RAM needed can");
		moreprint("                  quickly become unmanageable (warn: be very careful with 32bit versions).");
		moreprint("+ : -noeta        Brief");
		moreprint("+ : -verbose      Shows positive checks");
		moreprint("+ : -verify       Next level (mine) of paranoia: check hashes against the filesystem.");
		moreprint("                  Essentially equivalent to extracting in a temporary folder and check");
		moreprint("                  against initial folders. For very paranoid people, or debug reason.");
	}
	if (i_usage && i_example) moreprint("    Examples:");
	if (i_example)
	{
		moreprint("Paranoid, use lots of RAM:           p z:\\1.zpaq");
		moreprint("Very paranoid, use lots of RAM:      p z:\\1.zpaq -verify");
	}
}
void help_c(bool i_usage,bool i_example)
{
	if (i_usage)
	{
		moreprint("CMD   c (compare dirs)");
		moreprint("+ :               Compare a 'master' directory (d0) against N 'slaves' (d1, d2... dN).");
		moreprint("                  The slaves are made by zpaq restores, or rsync, robocopy, zfs replica.");
		moreprint("                  It is not easy to check on different filesystems (ex. NAS-Linux, NTFS)");
		moreprint("                  By default check file name and file size (excluding .zfs), not the content.");
		moreprint("+ : -ssd          Concurrent threads will be created, each scan a slave dir (-t K to limit).");
		moreprint("                  NOT good for single spinning drives, good for multiple slaves on different media.");
		help_printhash(false);
		moreprint("+ : -maxsize X    Filter out on filesize");
		moreprint("+ : -minsize X    Filter out on filesize");
		moreprint("+ : -715          Work as 7.15 (with .zfs and ADS)");
		moreprint("+ : -forcezfs     Include .zfs");
	}
	if (i_usage && i_example) moreprint("    Examples:");
	if (i_example)
	{
		moreprint("Compare master d0 against d1,d2,d3:  c c:\\d0 k:\\d1 j:\\d2 p:\\d3");
		moreprint("Multithread compare:                 c c:\\d0 k:\\d1 j:\\d2 p:\\d3 -ssd");
		moreprint("Hashed compare d0 against d1,d2,d3:  c c:\\d0 k:\\d1 j:\\d2 p:\\d3 -verify");
	}
}

void help_s(bool i_usage,bool i_example)
{
	if (i_usage)
	{
		moreprint("CMD   s (size)");
		moreprint("+ :               Cumulative size of N directory, and free space (estimate for *Nix).");
		moreprint("                  Everything containing .zfs and :$DATA (Windows's ADS) ignored by default");
		moreprint("                  Very quick-and-dirty check of rsynced folders against the master");
		moreprint("+ : -ssd          for multithreaded executions (warning for single spinning drive)");
		moreprint("+ : -maxsize X    Filter out on filesize");
		moreprint("+ : -minsize X    Filter out on filesize");
		moreprint("+ : -715          Work as 7.15 (with .zfs and ADS)");
		moreprint("+ : -forcezfs     Include .zfs");
		moreprint("+ : -minsize X    Show a warning if free space < X");
		
		}
	if (i_usage && i_example) moreprint("    Examples:");
	if (i_example)
	{
		moreprint("Dir cumulative size (no .zfs/NTFS):  s r:\\vbox s:\\uno");
		moreprint("Multithreaded size:                  s r:\\vbox s:\\uno -ssd");
	}
}

void help_r(bool i_usage,bool i_example)
{
	if (i_usage)
	{
		moreprint("CMD   r ('robocopy')");
		moreprint("+ :               Mirror a master folder, just like robocopy /mir or rsync -a --delete");
		moreprint("                  to one or more slaves (destination) folders");
		moreprint("                  In archive and files substitute $hour $min $sec $weekday $year $month $day");
		moreprint("                  $week $date $time $datetime");
		moreprint("                  ENFORCING XLS, ignore .zfs and ADS by default");
		moreprint("+ : -kill         wet run (default: dry-run");
		moreprint("+ : -space        do not exit if not enough space reported");
		moreprint("+ : -ssd          run one thread for folder");
		moreprint("+ : -verify       after copy quick check if OK (only filename and size)");
		moreprint("+ : -checksum     heavy (hash) test of equality. Suggest: -xxh3 fast and reliable.");
		moreprint("+ : -maxsize X    Filter out on filesize");
		moreprint("+ : -minsize X    Filter out on filesize");
		moreprint("+ : -xls          Do not enforce backup of XLS/PPT");
		moreprint("+ : -715          Work as 7.15 (with .zfs and ADS)");
		moreprint("+ : -forcezfs     Include .zfs");
		moreprint("+ : -append       Only append data (*risky, use with zpaq archives)");
		moreprint("+ : -zero         Fill all output file with zeros (for debug)");
	
	}
	if (i_usage && i_example) moreprint("    Examples:");
	if (i_example)
	{
		moreprint("Robocopy d0 in d1,d2 (dry run):      r c:\\d0 k:\\d1 j:\\d2 p:\\d3");
		moreprint("Robocopy d0 in d1,d2 (WET run):      r c:\\d0 k:\\d1 j:\\d2 p:\\d3 -kill");
		moreprint("Robocopy with verify (WET run):      r c:\\d0 k:\\d1 j:\\d2 p:\\d3 -kill -verify");
		moreprint("Robocopy with hash verify (WET run): r c:\\d0 k:\\d1 j:\\d2 p:\\d3 -kill -verify -checksum -xxh3");
		moreprint("Robocopy d0 in d1, forced WET run:   r c:\\d0 k:\\d1 j:\\d2 -kill -space");
		moreprint("Robocopy append mode with subst      r c:\\d0 z:\\backup_$day -append -kill");
	}
}
void help_cp(bool i_usage,bool i_example)
{
	if (i_usage)
	{
		moreprint("CMD   cp ('friendly copy') ");
		moreprint("+ :               Copy files (with wildcards) into -to folder");
		moreprint("+ :               with 1 sec progression feedback. Huge file, tiny bandwidth");
		moreprint("                  and unreliable media (-verify)");
		moreprint("+ :               By default overwrite, use -paranoid to create unique name");
		moreprint("+ : -verify       Do an heavy (XXH3) check of copied data");
		moreprint("+ : -paranoid     Rename output file to do not overwrite");
		moreprint("+ : -append       Only append data (*risky, use with zpaq archives)");
		moreprint("+ : -force        Do no check if destination is writeable");
		moreprint("+ : -space        Do no check if enoungh destination free space");
	}
	if (i_usage && i_example) moreprint("    Examples:");
	if (i_example)
	{
		moreprint("Copy k:\\*.mp4 d:\\a.txt in z:\\pluto   cp k:\\*.mp4 d:\\a.txt -to z:\\pluto");
		moreprint("Copy with verify                     cp k:\\*.mp4 -to z:\\pluto -verify");
		moreprint("Copy WITHOUT overwrite               cp k:\\*.mp4 -to z:\\pluto -paranoid");
	}
}
void help_zfs(bool i_usage,bool i_example)
{
	if (i_usage)
	{
		moreprint("      Auxiliary zfs commands (typically for FreeBSD)");
		moreprint("      The user must have the rights to do this kind of stuff!");
		moreprint("      NOTE: you can use -output xx.sh to redirect the output");
		moreprint("      and edit your own script");
		moreprint("      !zpaqfranz cowardly do NOT execute!");
		moreprint("");
		moreprint("****  LUKE... REMEMBER... !USE THE DOUBLEQUOTES! ...");
		moreprint("");
		
		if ((g_optional=="zfslist") || (g_optional==""))
		moreprint("CMD   zfslist       Show (/filtering) existing zfs snapshot");	
		
		if ((g_optional=="zfspurge") || (g_optional==""))
		moreprint("CMD   zfspurge      Destroy selected zfs snapshot (works like zfslist)");	
		
		if ((g_optional=="zfsadd") || (g_optional==""))
		{
		moreprint("CMD   zfsadd        Freeze into an archive a selection of snapshots");
		moreprint("+ : -force        Do the freezing (wet run)");
		}
		moreprint("+ : -output pi.sh Write a script-ready on pi.sh");
		moreprint("+ : -pakka        Remove first line in output");
	}
	if (i_usage && i_example) moreprint("    Examples:");
	if (i_example)
	{
		if ((g_optional=="zfsadd") || (g_optional==""))
		{
		moreprint("zfsadd \"tank/d@2021\" \"--60d\" \"/temporaneo/kongo60.zpaq\" ");
		moreprint("zfsadd \"tank/d@2021\" \"--60d\" \"/temporaneo/kongo60.zpaq\" \"scanner\"");
		moreprint("zfsadd \"tank/d@2021\" \"--60d\" \"/temporaneo/kongo60.zpaq\" \"scanner\" -force");
		moreprint("zfsadd \"tank/d@2021\" \"--60d\" \"/temporaneo/kongo60.zpaq\" \"scanner\" -output ./dothejob.sh");
		}
		
		if ((g_optional=="zfslist") || (g_optional==""))
		{
		moreprint("zfslist  \"tank/d@\"");
		moreprint("zfslist  \"*\"");
		moreprint("zfslist  \"*\" \"syncoid\"");
		}
		
		if ((g_optional=="zfspurge") || (g_optional==""))
		{
		moreprint("zfspurge \"tank/d@2021\" \"--60d\"");
		moreprint("zfspurge \"*\" \"*\"");
		moreprint("zfspurge \"tank\" \"--7d\"");
		moreprint("zfspurge \"tank\" \"--7d\" -output mygoodscript.sh");
		
		}
	}
}

void help_z(bool i_usage,bool i_example)
{
	if (i_usage)
	{
		moreprint("CMD   z (delete empty directories, zero length)");
		moreprint("+ :               Remove empty directories in d0...dK folders. Conservative (ex hidden Thumbs.db)");
		moreprint("+ : -kill         Do a wet run (default dry run)");
		moreprint("+ : -verbose      Show infos");
#ifdef _WIN32
		moreprint("+ : -longpath     Extracting on Windows filenames longer than 255");
#endif

	}
	if (i_usage && i_example) moreprint("    Examples:");
	if (i_example)
	{
		moreprint("Delete empty dirs in d0,d1(dry run): z c:\\d0 k:\\d1");
		moreprint("Delete empty dirs in d0,d1(WET run): z c:\\d0 k:\\d1 -kill -longpath");
	}
}

void help_m(bool i_usage,bool i_example)
{
	if (i_usage)
	{
	moreprint("CMD   m (merge, consolidate)");
	moreprint("+ :                   Merge a splitted (multipart) archive into a single one,");
	moreprint("                      just like a concatenated cat or copy /b");
	moreprint("+ : -force            Overwrite existing output");
	moreprint("+ : -space            Ignore lack of free space");
	moreprint("+ : -verify           Double-check (XXH3 hash test)");
	}
	if (i_usage && i_example) moreprint("    Examples:");
	if (i_example)
	{
		moreprint("Merge (consolidate) multipart:       m \"p:\\test\\prova_???\" z:\\cons.zpaq -verify");
	}
}
void help_d(bool i_usage,bool i_example)
{
	if (i_usage)
	{
		moreprint("CMD   d (deduplicate)");
		moreprint("+ :               Deduplicate a single folder WITHOUT ASKING ANYTHING!");
		moreprint("+ :               Please note: a FOLDER==ending with /");
		moreprint("+ : -ssd          Multithread run");
		moreprint("+ : -force        Wet run (default: dry-run)");
		moreprint("+ : -verbose      Show duplicated files");
		moreprint("+ : -(somehash)   Use (somehash), one of the available next two lines, for detection");
		help_printhashline(false);
	}
	if (i_usage && i_example) moreprint("    Examples:");
	if (i_example)
	{
		moreprint("Deduplicate d0 (dry run, w/xxh3) :   d c:\\d0\\");
		moreprint("Deduplicate d0 (dry run,xxh3,M/T):   d c:\\d0\\ -ssd");
		moreprint("Deduplicate d0 WITHOUT MERCY (wet):  d c:\\d0\\ -kill");
		moreprint("Dedup WITHOUT MERCY (wet run,sha256):d c:\\d0\\ -force -sha256");
	}
}

void help_utf(bool i_usage,bool i_example)
{
	if (i_usage)
	{
		moreprint("CMD   utf (deal with strange filenames)");
		moreprint("+ :               Check (or sanitize) paths with non-latin chars and/or >260 length and/or case.");
		moreprint("                  Can become a real problem extracting on different filesystems (ex. *nix => NTFS)");
		moreprint("+ : -kill         Wet run (default dry run)");
		moreprint("+ : -utf          Sanitize filenames (strip non-latin)");
		moreprint("+ : -fix255       Sanitize file length and filecase collisions pippo.txt PIPPO.txt)");
		moreprint("+ : -fixeml       Sanitize .eml filenames (Fwd Fwd Fwd => Fwd)");
		moreprint("+ : -dirlength X  Set the 'fix' limit");
		moreprint("+ : -filelength Y Set the 'fix' limit");
	}
	if (i_usage && i_example) moreprint("    Examples:");
	if (i_example)
	{
		moreprint("Check UTF-filenames (dry run):       utf z:\\knb");
		moreprint("Sanitize UTF-filenames (wet run):    utf z:\\knb -kill");
		moreprint("Check >255 and case collisions:      utf z:\\knb -fix255");
		moreprint("Fix .eml filenames (dry run):        utf z:\\knb -fixeml");
	}
}

void help_f(bool i_usage,bool i_example)
{
	if (i_usage)
	{
		moreprint("CMD   f (fill, or wipe)");
		moreprint("+ :               Fill (wipe) 99% of free disk space in 500MB chunks");
		moreprint("                  Check if disk-controller-system-RAM-cache-cables are working fine");
		moreprint("+ : -verbose      Show write speed (useful to check speed consistency)");
		moreprint("+ : -force        Do NOT delete (after run) the temporary filename. By default free");
		moreprint("+ : -zero         Zero-fill instead of random. Use to prepare a thin VMDK shrink");
		moreprint("+ : -verify       For -zero: do a verify.");
	}
	if (i_usage && i_example) moreprint("    Examples:");
	if (i_example)
	{
		moreprint("Fill (wipe) almost all free space:   f z:\\");
		moreprint("Fill (wipe) keep temp files:         f z:\\ -force -verbose");
		moreprint("Zero free space (VM shrink):         f z:\\ -zero");
		moreprint("Zero free space (WITH verify):       f z:\\ -zero -verify");
	}
}

void help_sha1(bool i_usage,bool i_example)
{
	if (i_usage)
	{
		moreprint("CMD   sum");
		moreprint("CMD   sha1        (retained for historical reasons, 7.15 always uses SHA-1 only)");
		moreprint("+ :               Calculate hash/cksum of files/dirs, dupes and cumulative GLOBAL SHA256");
		moreprint("                  (If two directories have the same GLOBAL SHA256 they are ==)");
		moreprint("                  With no switches, by default, use SHA-1 (reliable, but not very fast)");
		help_printhash(false);
		moreprint("+ : -ssd          make N thread (do not use with spinning HDDs, but SSDs and NVMes)");
		moreprint("+ : -mm           use memory mapped file instead of 'regular' fread");
		moreprint("+ : -kill         show the files to be deleted to manually deduplicate");
		moreprint("+ : -checksum     get a 1-level checksum, for comparing hierarchically user-organized folders.");
		moreprint("+ : -summary      show only GLOBAL (fast manual compare of directories)");
		moreprint("+ : -forcezfs     force .zfs path (DEFAULT: skip)");
		moreprint("+ : -kill -force  runs a deduplication without ask anything!");
		moreprint("+ : -maxsize X    Filter out on filesize");
		moreprint("+ : -minsize X    Filter out on filesize");
		moreprint("+ : -715          Work as 7.15 (with .zfs and ADS)");
		moreprint("+ : -forcezfs     Include .zfs");
	}
	if (i_usage && i_example) moreprint("    Examples:");
	if (i_example)
	{
		moreprint("SHA1 of all files (and duplicated):  sum z:\\knb");
		moreprint("SHA1 multithread, only summary:      sum z:\\knb -ssd -summary");
		moreprint("XXH3 multithread:                    sum z:\\knb -ssd -xxh3");
		moreprint("CRC-32c HW accelerated:              sum z:\\knb -crc32c -pakka -noeta");
		moreprint("Hashes to be compared (dir1):        sum c:\\nz  -pakka -noeta -nosort -crc32c -find c:\\nz  -replace bakdir >1.txt");
		moreprint("Hashes to be compared (dir2):        sum z:\\knb -pakka -noeta -nosort -crc32c -find z:\\knb -replace bakdir >2.txt");
		moreprint("Duplicated files with sha256:        sum z:\\knb -kill -sha256");
		moreprint("Duplicated files minsize 1000000:    sum z:\\knb -kill -ssd -minsize 1000000");
		moreprint("MAGIC cumulative hashes of 1-level:  sum p:\\staff -xxh3 -checksum");
		moreprint("BLAKE3 multithread from memory map:  sum z:\\knb -ssd -blake3 -mm");
	}
}

void help_dir(bool i_usage,bool i_example)
{
	if (i_usage)
	{
		moreprint("CMD   dir (yes, dir as in Windows).");
		moreprint("+ :               I really hate ls: does not show the cumulative filesize (!)");
		moreprint("                  'Mini clone' of Windows's dir command, with the main switches");
		moreprint("+ : /s            Recursive (note: Win-switch must be BEFORE 'normal' switch");
		moreprint("+ : /os           Order by size");
		moreprint("+ : /a            Show all (hidden)");moreprint("+ : -checksum     Show hashes for every file");
		moreprint("+ : -(somehash)   Use (somehash) to find duplicate/show checksums");
		help_printhashline(false);
		moreprint("+ : -n X          like |tail -X");
		moreprint("+ : -maxsize X    Filter out on filesize");
		moreprint("+ : -minsize X    Filter out on filesize");
		
	}
	if (i_usage && i_example) moreprint("    Examples:");
	if (i_example)
	{
		moreprint("Windows-dir command clone:           dir /root/script /od");
		moreprint("Show the 10 largest .mp4 file in c:\\:dir c:\\ /s /os -n 10 -find .mp4");
		moreprint("Find .mp4 duplicate in C:\\:          dir c:\\ /s -crc32 -find .mp4");
		moreprint("How big is c:\\z,with subdirs?:       dir c:\\z /s -n 1");
		moreprint("100 biggest dup. files in c:\\z?:     dir c:\\z /s -crc32 -n 100");
		moreprint("Show -md5 cheksum, recurse by size:  dir z:\\cb /s /os -checksum -md5");
		moreprint("Like dir:                            dir z:\\cb\\*.avi");
	}
}

void help_k(bool i_usage,bool i_example)
{
	if (i_usage)
	{
		moreprint("CMD   k (kill, risky!)");
		moreprint("+ :               Kill (delete) all files and directories that arent in an archive");
		moreprint("                  removing excess files");
	}
	if (i_usage && i_example) moreprint("    Examples:");
	if (i_example)
	{
		moreprint("   RISKY COMMAND: DO NOT USE IF YOU DO NOT UNDERSTAND!");
		moreprint("Create an archive                    a z:\\1.zpaq c:\\z");
		moreprint("Extract into z:\\knb                  x z:\\1.zpaq c:\\z -to z:\\knb");
		moreprint("... something happens (change) in");
		moreprint("z:\\knb and we want to turn back");
		moreprint("WITHOUT delete everything and ");
		moreprint("extract again (maybe it's huge):     k z:\\1.zpaq c:\\z -to z:\\knb");
	}
}

void help_n(bool i_usage,bool i_example)
{
	if (i_usage)
	{
		moreprint("CMD   n (decimatioN)");
		moreprint("+ :               Keep -n X files in a folder (NO recursive scan), delete all the others");
		moreprint("                  At least one * must be used to filter.");
		moreprint("                  with -exec execute external command");
		moreprint("+ : -kill         Do a wet run (default dry run)");
		moreprint("+ : -exec p.bat   Instead of delete launch p.bat with parameter");
		moreprint("+ : /od           Order by date (default)");
		moreprint("+ : /on           Order by name");
		moreprint("+ : -verbose      Show infos");
		moreprint("+ : -force        Continue even if >50 files founded");
		
	}
	if (i_usage && i_example) moreprint("    Examples:");
	if (i_example)
	{
		moreprint("   RISKY COMMAND: DO NOT USE IF YOU DO NOT UNDERSTAND!");
		moreprint("Keep 10 newest files in z:\\1\\        n z:\\1\\*.txt -n 10 -kill");
		moreprint("Keep 20 ordered by name              n z:\\1\\dumpy_*.sql -n 20 -kill -force /on");
		moreprint("Keep 30 txt ordered by name          n z:\\1\\*.txt -n 20 -kill -force /on");
		moreprint("Check the last file with ugo.bat     n z:\\1\\*.txt -kill -exec ugo.bat");
	}
}

void help_mainswitches(bool i_usage,bool i_example)
{
	if (i_usage) /// no warning
		if (i_example)
			i_example=i_usage;
			
	moreprint("  -all [N]:     All versions (default 4 digits)");
	moreprint("  -key X:       Archive password X");
	moreprint("  -mN -method N:0=no compression, 1..5=faster..better ");
	moreprint("  -force:       Always overwrite");
	moreprint("  -test:        Verify (extract/add)");
	moreprint("  -kill:        Allow destructive operations ('wet runs')");
	moreprint("  -to out...:   Prefix files to out");
	moreprint("  -until N:     Roll back to N'th version");
}

void help_switches(bool i_usage,bool i_example)
{
	if (i_usage) /// no warning
		if (i_example)
			i_example=i_usage;
	
	char buffer[200];
	time_t now=time(NULL);
	tm* t=gmtime(&now);
	int64_t date=(t->tm_year+1900)*10000000000LL+(t->tm_mon+1)*100000000LL
      +t->tm_mday*1000000+t->tm_hour*10000+t->tm_min*100+t->tm_sec;

	sprintf(buffer,"  -until %s   Set date, roll back (UT, default time: 235959)",dateToString(date).c_str());
	moreprint(buffer);
	moreprint("  -not files...   Exclude. * and ? match any string or char");
	moreprint("       =[+-#^?]   List: exclude by comparison result");
	moreprint("  -only files...  Include only matches (default: *) example *pippo*.mp4");
	moreprint("  -always files   Always (force) adding some file");
	moreprint("  -noattributes   Ignore/don't save file attributes or permissions");
	moreprint("  -index F        Extract: create index F for archive");
	moreprint("                  Add: create suffix for archive indexed by F, update F");
	moreprint("  -sN -summary N  If >0 show only summary (sha1())");
}
void help_franzswitches(bool i_usage,bool i_example)
{
	if (i_usage) /// no warning
		if (i_example)
			i_example=i_usage;
	
	moreprint("+ : -utc          Do not convert to localtime (use UTC, like 715)");
	moreprint("+ : -715          Works just about like v7.15");
	moreprint("+ : -checksum     Store SHA1+CRC32 for every file");
	moreprint("+ : -verify       Force re-read of file during t (test command) or c");
	moreprint("+ : -noeta        Do not show ETA");
	moreprint("+ : -pakka        Output for PAKKA (briefly)");
	moreprint("+ : -verbose  -v  Show more");
	moreprint("+ : -zfs          Skip paths including .zfs");
	moreprint("+ : -forcezfs     Force paths including .zfs");
	moreprint("+ : -noqnap       Skip path including @Recently-Snapshot and @Recycle");
	moreprint("+ : -forcewindows Take $DATA$ and System Volume Information");
	moreprint("+ : -xls          Do NOT always force XLS/PPT");
	moreprint("+ : -nopath       Do not store path");
	moreprint("+ : -nosort       Do not sort file when adding or listing");
	moreprint("+ : -find       X Search for X in full filename (ex. list)");
	moreprint("+ : -replace    Y Replace X with Y in full filename (ex. list)");
	moreprint("+ : -n          X Only print last X lines in dir (like tail)/first X (list)");
	moreprint("+ : -limit      X (like -n)");
	moreprint("+ : -minsize    X Skip files by length (add(), list(), dir())");
	moreprint("+ : -maxsize    X Skip files by length (add(), list(), dir())");
	moreprint("+ : -filelength X Utf command: find file with length>X, extract maxfilelen");
	moreprint("+ : -dirlength  X Utf command: find dirs with length>X, extract maxdirlen");
	moreprint("+ : -comment foo  Add/find ASCII comment string to versions");
	#if defined(_WIN32) || defined(_WIN64)
	moreprint("+ : -vss          Do a VSS for drive C: (Windows with administrative rights)");
	#endif
	help_printhash(false);
	moreprint("+ : -exec_ok f.sh After OK launch f.sh");
	moreprint("+ : -exec_error z After NOT OK launch z");
	moreprint("+ : -exec_warn cz At Warn launch cz");
	moreprint("+ : -exec pip.bat Launch pip.bat %1 with command n");
	moreprint("+ : -output s.txt Output on s.txt too");
	moreprint("+ : -kill         Show 'script-ready' log of dup files");
	moreprint("+ : -kill         In extraction write 0-bytes file instead of data");
	moreprint("+ : -utf          Remove non-utf8 chars");
	moreprint("+ : -utf8         Like -utf");
	moreprint("+ : -fix255       Shrink total file length and case collisions (NTFS)");
	moreprint("+ : -fixeml       Heuristically compress .eml filenames (Fwd Fwd Fwd =>Fwd)");
	moreprint("+ : -flat         Everything in single path (emergency extract of strange files)");
	moreprint("+ : -debug        Show lot of infos (superverbose)");
	moreprint("+ : -timestamp X  Set version datetime@X 14 digit (2021-12-30_01:03:04)"); 	// force the timestamp
	moreprint("+ : -filelist     Store the add() list in VFILE-l-filelist.txt");
	moreprint("+ : -nodedup      Disabling deduplication");
	moreprint("+ : -orderby x    Sort file by ext;size;name;hash;date;data;nilsimsa;");
	moreprint("+ : -desc         Descending sort (if -orderby)");
	moreprint("+ : -tar          tar mode: turn off deduplication and compression");
	#ifdef _WIN32
	moreprint("+ : -longpath     add/extract on Windows filenames longer than 255");
	#endif
}
void help_voodooswitches(bool i_usage,bool i_example)
{
	if (i_usage) /// no warning
		if (i_example)
			i_example=i_usage;
	
	moreprint("  -repack F [X]   Extract to new archive F with key X (default: none)");
	moreprint("  -tN -threads N  Use N threads (default: 0 = all cores)");
	moreprint("  -fragment N     Use 2^N KiB average fragment size (default: 6)");
	moreprint("  -mNB -method NB Use 2^B MiB blocks (0..11, default: 04, 14, 26..56)");
	moreprint("  -method {xs}B[,N2]...[{ciawmst}[N1[,N2]...]]...  Advanced:");
	moreprint("  x=journaling (default). s=streaming (no dedupe)");
	moreprint("    N2: 0=no pre/post. 1,2=packed,byte LZ77. 3=BWT. 4..7=0..3 with E8E9");
	moreprint("    N3=LZ77 min match. N4=longer match to try first (0=none). 2^N5=search");
	moreprint("    depth. 2^N6=hash table size (N6=B+21: suffix array). N7=lookahead");
	moreprint("    Context modeling defaults shown below:");
	moreprint("  c0,0,0: context model. N1: 0=ICM, 1..256=CM max count. 1000..1256 halves");
	moreprint("    memory. N2: 1..255=offset mod N2, 1000..1255=offset from N2-1000 byte");
	moreprint("    N3...: order 0... context masks (0..255). 256..511=mask+byte LZ77");
	moreprint("    parse state, >1000: gap of N3-1000 zeros");
	moreprint("  i: ISSE chain. N1=context order. N2...=order increment");
	moreprint("  a24,0,0: MATCH: N1=hash multiplier. N2=halve buffer. N3=halve hash tab");
	moreprint("  w1,65,26,223,20,0: Order 0..N1-1 word ISSE chain. A word is bytes");
	moreprint("    N2..N2+N3-1 ANDed with N4, hash mulitpiler N5, memory halved by N6");
	moreprint("  m8,24: MIX all previous models, N1 context bits, learning rate N2");
	moreprint("  s8,32,255: SSE last model. N1 context bits, count range N2..N3");
	moreprint("  t8,24: MIX2 last 2 models, N1 context bits, learning rate N2");
}

void Jidac::load_help_map()
{
	/// a map is not so good, but we want to keep the executable small
	/// NOT in the constructor
	
	help_map.insert(std::pair<string, voidhelpfunction>("trim",help_trim));
	help_map.insert(std::pair<string, voidhelpfunction>("password",help_setpassword));
	help_map.insert(std::pair<string, voidhelpfunction>("dirsize",help_dirsize));

	///help_map.insert(std::pair<string, voidhelpfunction>("h",help_b));
	help_map.insert(std::pair<string, voidhelpfunction>("b",help_b));
	help_map.insert(std::pair<string, voidhelpfunction>("n",help_n));
	help_map.insert(std::pair<string, voidhelpfunction>("f",help_f));
	help_map.insert(std::pair<string, voidhelpfunction>("a",help_a));
#if defined(_WIN32)
	help_map.insert(std::pair<string, voidhelpfunction>("sfx",help_sfx));
	help_map.insert(std::pair<string, voidhelpfunction>("rd",help_rd));
	help_map.insert(std::pair<string, voidhelpfunction>("q",help_q));
	help_map.insert(std::pair<string, voidhelpfunction>("g",help_q));
#endif
	help_map.insert(std::pair<string, voidhelpfunction>("l",help_l));
	help_map.insert(std::pair<string, voidhelpfunction>("i",help_i));
	help_map.insert(std::pair<string, voidhelpfunction>("t",help_t));
	help_map.insert(std::pair<string, voidhelpfunction>("v",help_v));
	help_map.insert(std::pair<string, voidhelpfunction>("x",help_x));
	help_map.insert(std::pair<string, voidhelpfunction>("w",help_w));
	help_map.insert(std::pair<string, voidhelpfunction>("s",help_s));
	help_map.insert(std::pair<string, voidhelpfunction>("c",help_c));
	help_map.insert(std::pair<string, voidhelpfunction>("p",help_p));
	help_map.insert(std::pair<string, voidhelpfunction>("r",help_r));
	help_map.insert(std::pair<string, voidhelpfunction>("cp",help_cp));
	help_map.insert(std::pair<string, voidhelpfunction>("z",help_z));
	help_map.insert(std::pair<string, voidhelpfunction>("m",help_m));
	help_map.insert(std::pair<string, voidhelpfunction>("d",help_d));
	help_map.insert(std::pair<string, voidhelpfunction>("dir",help_dir));
	help_map.insert(std::pair<string, voidhelpfunction>("sum",help_sha1));
	help_map.insert(std::pair<string, voidhelpfunction>("utf",help_utf));
	help_map.insert(std::pair<string, voidhelpfunction>("k",help_k));
	help_map.insert(std::pair<string, voidhelpfunction>("rsync",help_rsync));
#if defined(unix)
	help_map.insert(std::pair<string, voidhelpfunction>("zfs",help_zfs));
#endif
	switches_map.insert(std::pair<string, voidhelpfunction>("main",help_mainswitches));
	switches_map.insert(std::pair<string, voidhelpfunction>("normal",help_switches));
	switches_map.insert(std::pair<string, voidhelpfunction>("franz",help_franzswitches));
	switches_map.insert(std::pair<string, voidhelpfunction>("voodoo",help_voodooswitches));
}


//// default help
void Jidac::usage() 
{
	/*
	load_help_map();
	string 	lista		="h parm: ";
	string	listaswitch	="        ";
	for (MAPPAHELP::iterator p=help_map.begin(); p!=help_map.end(); ++p) 
		lista+=p->first+" ";
	
	for (MAPPAHELP::iterator p=switches_map.begin(); p!=switches_map.end(); ++p) 
		listaswitch+=p->first+" ";
		*/
	moreprint("Usage: zpaqfranz command archive[.zpaq] files|directory... -switches...");
///	moreprint("Use double quote for multi-part archive name => \"test_?????.zpaq\"");
	moreprint("             h: **** Help on Help ****|  With great power comes great  ...  help!");
	moreprint("             a: Append files          |          t: Test (integrity)");
	moreprint("             x: Extract versions      |          l: List files");
	moreprint("             v: Verify on filesystem  |          i: Info (show versions)");
#if defined(_WIN32)
	moreprint("           sfx: Create SFX (Windows)  |         rd: Remove  'highlander'  folders");
#endif
///	moreprint("                                   Various");
	moreprint(" c d0 d1 d2...: Compare d0 to d1,d2.. | s d0 d1 d2: Cumulative size of d0, d1, d2");
	moreprint(" r d0 d1 d2...: Mirror  d0 in d1...   |       d d0: Deduplicate d0  WITHOUT MERCY");
	moreprint(" z d0 d1 d2...: Delete empty dirs     |        m X: Merge multipart archive");
	moreprint("          f d0: Fill /wipe free space |     utf d0: Detox filenames  in  d0");
	moreprint("  sum d0 d1...: Hashing/deduplication |     dir d0: Win dir (/s /a /os /od)");
	moreprint("     n d0 -n X: Keep X files in d0    |          b: CPU benchmarking (-all)");
	moreprint("   rsync d0 d1: Purge temporary rsync | cp X -to Y: Copy files (w/wildcards) to Y");
	moreprint("          trim: Trim incomplete add() |    dirsize: Get size of archive's folders");
#if defined(_WIN32)
	moreprint("      password: Add/remove/change pwd |   q z:\\foo: VSS-archive C: in z:\\foo.zpaq");
#else
	moreprint("      password: Add/remove/change pwd |");
#endif
#if defined(unix)
	moreprint(" zfsadd zfslist zfspurge              =>  zfs-specific commands (typically FreBSD)");
#endif
	moreprint("                                 Main | switches");
	moreprint("      -all [N]: All versions N digit  |     -key X: Use/set archive password to X");
	moreprint(" -mN -method N: 0..5= faster..better  |     -force: Always overwrite (extraction)");
	moreprint("         -test: Test (extract/add)    |      -kill: Allow destructive (NO dryrun)");
	moreprint("    -to out...: Prefix files to out   |   -until N: Roll back to N'th version");
}


void Jidac::helphelp()
{
	load_help_map();
	string 	lista		="";
	string	listaswitch	="OR one set of SWITCHES:  ";
	for (MAPPAHELP::iterator p=help_map.begin(); p!=help_map.end(); ++p) 
		lista+=p->first+" ";
	
	for (MAPPAHELP::iterator p=switches_map.begin(); p!=switches_map.end(); ++p) 
		listaswitch+=p->first+" ";
	
///	moreprint("Fork of zpaq 7.15 by   : www.francocorbelli.com                github.com/fcorbelli");
///	moreprint("Sourceforge            : sourceforge.net/projects/zpaqfranz");
  	///moreprint("                     Fork of zpaq 7.15 by Franco Corbelli (2022)");
	moreprint("");
	moreprint("zpaq fork that stores by default CRC32+XXHASH64 (SHA-1|SHA-2|SHA-3|MD5|XXH3|BLAKE3)");
	moreprint("with full backward zpaq 7.15 compatibility. Swiss army knife for disaster managers:");
	moreprint("comparing,hashing,deduplication,utf-8,empty dirs,SFX,ZFS & VSS support... and more.");
	moreprint("Doveryay, no proveryay;  trust, but verify; fidarsi e' bene, non fidarsi e' meglio.");
	moreprint("");
	moreprint("Runs on                  Win 32/64, Linux, Free/OpenBSD, Solaris, MacOS and others.");
	moreprint("www.francocorbelli.com   sourceforge.net/projects/zpaqfranz    github.com/fcorbelli");
	printbar('=');
	moreprint("Help ALL IN EVERYTHING : zpaqfranz h h                       zpaqfranz /? /?");
	moreprint("Help     on SOMETHING  : zpaqfranz h   SOMETHING             zpaqfranz /? SOMETHING");
	moreprint("Help     on SOMETHING  : zpaqfranz -?  SOMETHING             zpaqfranz -h SOMETHING");
	moreprint("Examples of SOMETHING  : zpaqfranz -he SOMETHING");
	moreprint("");
	moreprint("SOMETHING is a COMMAND");
	printbar('-');
	moreprint(lista.c_str());
	printbar('-');
	moreprint(listaswitch.c_str());
	printbar('-');
	
}	

//// print a lot more
void Jidac::usageall(string i_command) 
{
	load_help_map();
	MAPPAHELP::iterator a=help_map.find(i_command);
	
	if (a==help_map.end())
	{
		// maybe we want a switch ?
		if (i_command!="")
		{
			MAPPAHELP::iterator b=switches_map.find(i_command);
			if (b!=switches_map.end())
			{
				(*b->second)(true,true);
				exit(0);
			}
		}
		
//	if not found => show everything
		usage();
		moreprint("Usage full:");
		for (MAPPAHELP::iterator p=help_map.begin(); p!=help_map.end(); ++p) 
		{
			(*p->second)(true,true);
			morebar('-');
		}
		morebar('-');
		moreprint("Extended switches:");
		help_switches(true,true);
		morebar('-');
		moreprint("zpaqfranz switches:");
		help_franzswitches(true,true);
		morebar('-');
		moreprint("Voodoo switches");
		help_voodooswitches(true,true);
	}
	else
	{	// please note: first parameter help, second example
		(*a->second)(true,true);
		morebar('-');
	}
	exit(0);
}

void Jidac::examples(string i_command) 
{
	load_help_map();	// not in the constructor!
//	if not found => show everything
	MAPPAHELP::iterator a=help_map.find(i_command);
	
	if (a==help_map.end())
	{
		for (MAPPAHELP::iterator p=help_map.begin(); p!=help_map.end(); ++p) 
		{
			(*p->second)(false,true);
			morebar('-');
		}
	}
	else
	{	// please note: first parameter help, second example
		(*a->second)(false,true);
		morebar('-');
	}
}

void open_output(string i_filename)
{
	if (i_filename!="")
		if (g_output_handle==0)
		{
			g_output=i_filename;
			g_output_handle=fopen(i_filename.c_str(),"wb");
		}
}

string tail(string const& i_source, size_t const i_length) 
{
	if (i_length>=i_source.size()) 
		return i_source;
	return i_source.substr(i_source.size()-i_length);
}

// Rename name using tofiles[]
string Jidac::rename(string name) 
{
	if (replaceto!="")
	{
		if (searchfrom!="")
		{
			replace(name,searchfrom,replaceto);	
			if (flagdebug)
				printf("27144: name after search - replace %s\n",name.c_str());
		}
		else
		{
			name=replaceto+name;
			if (flagdebug)
				printf("27192: name after replace %s\n",name.c_str());
			
		}
	}
/*
	kludge
	extracting \\franzk\z\NS\something -to z:\pippo with longpath
	converted to
	z:\pippo\__franzk_z (...)
*/
#ifdef _WIN32
	if (flaglongpath)
		if (command=='x')
			if (tofiles.size()==1)
				if (iswindowsunc(name))
				{
					replace(name,"//","__");
					replace(name,"/","_");
					if (isdirectory(tofiles[0]))
						return tofiles[0]+name;
					else	
						return tofiles[0]+'/'+name;
				}
#endif
	if (flagnopath)
	{
		string myname=name;
		for (unsigned i=0; i<files.size(); ++i) 
		{
			string pathwithbar=files[i];
			if (pathwithbar[pathwithbar.size()-1]!='/')
				pathwithbar+="/";
			  if (strstr(name.c_str(), pathwithbar.c_str())!=0)
			  {
				myreplace(myname,pathwithbar,"");
				if (flagverbose)
					printf("Cutting path <<%s>> to <<%s>>\n",files[i].c_str(),myname.c_str());
				return myname;
			  }
		}
		return myname;
	}
	
	if (files.size()==0 && tofiles.size()>0)  // append prefix tofiles[0]
		name=append_path(tofiles[0], name);
	else 
	{  // replace prefix files[i] with tofiles[i]
		const int n=name.size();
		for (unsigned i=0; i<files.size() && i<tofiles.size(); ++i) 
		{
			const int fn=files[i].size();
			if (fn<=n && files[i]==name.substr(0, fn))
				return tofiles[i]+name.substr(fn);
        }
	}
  return name;
}

string Jidac::getpassword()
{
	char myline[251];
	unsigned int i=0;
    int c;

	printf("\nEnter password (max %d chars):",(int)sizeof(myline)-1);
	
	string myresult="";
	while (1)
	{
		while (( (c = getchar())!='\n') && (c!= EOF) && (i< sizeof(myline)-1) )
			myline[i++] = c;
		myline[i] = '\0';
		myresult=myline;
		if (myresult!="")
		{
			if (myresult[0]=='-')
			{
				printf("Password starting with - can be confused with switches, enter another one!\n");
				i=0;
				myresult="";
			}
			else
				break;
		}
	}
	return myresult;
}

// Parse the command line. Return 1 if error else 0.
int Jidac::doCommand(int argc, const char** argv) 
{
	// Initialize options to default values
	// Why some variables out of Jidac? Because of pthread: does not like very much C++ objects
	// quick and dirty.
	
	fullcommandline		="";
  	plainpassword		="";
	
	g_vss_shadow		="";
	g_franzotype		=2; //by default take CRC-32 AND XXHASH64
	g_sfx				="";
	g_sfxto				="";
	g_sfxnot			="";
	g_sfxonly			="";
	g_sfxuntil			="";
	g_sfxflagforce		=false;
	g_sfxflagall		=false;
	g_freeze			="";
	g_archive			="";
	g_output_handle		=NULL;
	g_output			="";
	g_exec_error		="";
	g_255				=0; // errors on longer than 255 chars
	g_exec_warn			="";
	g_exec_ok			="";
	g_exec				="";
	g_exec_text			="";
	g_copy				="";
	command				=0;
	flagforce			=false;
	flagzero			=false;
	flagnoattributes	=false;
	flagbarraod			=false;
	flagbarraon			=false;
	flagbarraos			=false;
	flagdebug			=false;
	flagnodedup			=false;
	flagtar				=false;
	flagramdisk			=false;
	flagssd				=false;
	flagtouch			=false;
	flagfrugal			=false;
	flagstat			=false;
	flagdesc			=false;
	flagtest			=false;
	flagskipzfs			=false; 
	flagverbose			=false;
	flagnoqnap			=false;
	flagforcewindows	=false;
	flagnopath			=false;
	flagnoeta			=false;
	flagpakka			=false;
	flagvss				=false;
	flagnosort			=false;
	flagchecksum		=false;
	flagnochecksum		=false;
	flagcrc32c			=false;
	flagentropy			=false;
	flagsha1			=false;
	flagverify			=false;
	flagkill			=false;
	flagutf				=false;
	flagfix255			=false;
	#ifdef _WIN32
	flagfixcase			=false;
	flagfixreserved		=false;
	flaglongpath		=false;
	#endif
	flagfixeml			=false;
	flagflat			=false;
	flagparanoid		=false;
	flagxxh3			=false;
	flagcrc32			=false;
	flagsha256			=false;
	flagwyhash			=false;
	flagwhirlpool		=false;
	flagmd5				=false;
	flagsha3			=false;
	flagblake3			=false;
	flagxxhash64		=false;
	flagdonotforcexls	=false;
	flagcomment			=false;
	flag715				=false;
	flagfilelist		=false;
	flagmm				=false;
	flagappend			=false;
	flagutc				=false;
	flaghw				=false;

	fragment			=6;
	minsize				=0;
	maxsize				=0;
	dirlength			=0;
	filelength			=0;
	all					=0;
	password			=0;  // no password
	index				=0;
	method				="";  // 0..5
	repack				="";
	new_password		=0;
	summary				=-1; 
	menoenne			=0;
	versioncomment		="";
	searchfrom			="";
	orderby				="";
	replaceto			="";
	searchhash			="";
	zpaqfranzexename	="";
	howmanythreads		=0; // 0 = auto-detect
	version				=DEFAULT_VERSION;
	date				=0;
 

	if (argc>1)
		for (int i=1; i<argc; i++)
		{
			string temp=argv[i];
			fullcommandline+=temp+" ";
		}
	
		
	if (argc>0)
	{
		zpaqfranzexename=argv[0];
#ifdef _WIN32
		zpaqfranzexename+=".exe";
#endif
	}		
	
#ifdef unix
	///	If I pretend to be... dir... work like dir!
	string myexename=extractfilename(zpaqfranzexename);
	///printf("Myexename %s\n",myexename.c_str());
	if (myexename=="dir")
	{
		files.clear();
		int i=0;
		while (++i<argc && argv[i][0]!='-')  // read filename args
			files.push_back(argv[i]);
		return dir();
	}
#endif	
	
	
  /// if we have a -pakka, set the flag early
	for (int i=0; i<argc; i++)
	{
		const string parametro=argv[i];
		if (stringcomparei(parametro,"-pakka"))
		{
			flagpakka=true;
			break;
		}
	}
  
	if (!flagpakka)
	{
#if defined (HWBLAKE3)
#ifdef HWSHA1
		moreprint("zpaqfranz v" ZPAQ_VERSION " (HW BLAKE3,SHA1), " ZSFX_VERSION " compiled " __DATE__);
#else
		moreprint("zpaqfranz v" ZPAQ_VERSION " (HW BLAKE3), " ZSFX_VERSION " compiled " __DATE__);
#endif

#else
		moreprint("zpaqfranz v" ZPAQ_VERSION " archiver, " ZSFX_VERSION " compiled " __DATE__);
#endif
	}

/// check some magic to show help in heuristic way
/// I know, it's bad, but help is always needed!

	if (argc==1) // zero parameters
	{
		usage();
		exit(0);
	}

	if (argc==2) // only ONE 
	{
		const string parametro=argv[1];
		if  ((stringcomparei(parametro,"help"))
			||
			(stringcomparei(parametro,"-h"))
			||
			(stringcomparei(parametro,"h"))
			||
			(stringcomparei(parametro,"?"))
			||
			(stringcomparei(parametro,"-?"))
			||
			(stringcomparei(parametro,"/?"))
			||
			(stringcomparei(parametro,"--help"))
			||
			(stringcomparei(parametro,"-help")))
			{
				helphelp();
				exit(0);
			}
		if ((stringcomparei(parametro,"-he"))
			||
			(stringcomparei(parametro,"-helpe"))
			||
			(stringcomparei(parametro,"-example"))
			||
			(stringcomparei(parametro,"-examples")))
			{
				examples("");
				exit(0);
			}
		
	}
	if (argc==3) // only TWO (-examples sha1) 
	{
		const string parametro=argv[1];
		const string comando=argv[2];
		
		if  ((stringcomparei(parametro,"help"))
			||
			(stringcomparei(parametro,"-h"))
			||
			(stringcomparei(parametro,"h"))
			||
			(stringcomparei(parametro,"?"))
			||
			(stringcomparei(parametro,"/?"))
			||
			(stringcomparei(parametro,"-?"))
			||
			(stringcomparei(parametro,"--help"))
			||
			(stringcomparei(parametro,"-help")))
			{
				if (comando=="h") /// zpaqfranz h h 
					usageall("");
				else
					usageall(comando);
				exit(0);
			}
		if ((stringcomparei(parametro,"-he"))
			||
			(stringcomparei(parametro,"-helpe"))
			||
			(stringcomparei(parametro,"-example"))
			||
			(stringcomparei(parametro,"-examples")))
			{
				examples(comando);
				exit(0);
			}
		
	}
	
  // Init archive state
	ht.resize(1);  // element 0 not used
	ver.resize(1); // version 0
	dhsize=dcsize=0;
	
	// Get date
	time_t now=time(NULL);
	tm* t=gmtime(&now);
	date=(t->tm_year+1900)*10000000000LL+(t->tm_mon+1)*100000000LL
      +t->tm_mday*1000000+t->tm_hour*10000+t->tm_min*100+t->tm_sec;

	g_optional="";
	
// Get optional options
	for (int i=1; i<argc; ++i) 
	{
		const string opt=argv[i];  // read command
		///printf("---- >opt  %s\n",opt.c_str());
		if (opt=="-715") 			
		{			
			flag715=true;
		}
		else
		if (opt=="/od")
		{
			flagbarraod=true;
			//i++;
		}
		else
		if (opt=="/on")
		{
			flagbarraon=true;
			///i++;
		}
		else
		if (opt=="/os")
		{
			flagbarraos=true;
			///i++;
		}
		else
		if ((opt=="benchmark") || (opt=="b"))
		{
			command='b';
		}
		else
		if ((opt=="trim"))
		{
			command='4'; ///opt[3]; /// note!
			while (++i<argc && argv[i][0]!='-')  // read filename args
				files.push_back(argv[i]);
			i--;
		}
		else
		if ((opt=="password"))
		{
			command='6'; ///opt[3]; /// note!
			while (++i<argc && argv[i][0]!='-')  // read filename args
				files.push_back(argv[i]);
			i--;
		}
		else // developing: zfs-easy-support
		if ((opt=="zfslist") || (opt=="zfspurge") || (opt=="zfsadd"))
		{
			command='9';
			g_optional=opt;
			while (++i<argc)  // read filename args
			{
				string dummy=argv[i];
				if (dummy=="-force")
					flagforce=true;
				else
					files.push_back(argv[i]);
			}
			--i;
		}
		else
		if ((
		opt=="add" 		|| 
		opt=="extract" 	|| 
		opt=="list" 	|| 
		opt=="k" 		|| 
		opt=="a"  		|| 
		opt=="x" 		|| 
		opt=="p" 		|| 
		opt=="t" 		||
		opt=="test" 	|| 
		opt=="l" 		|| 
		opt=="v"		||
		opt=="w"		||
		opt=="i" 		|| 
		opt=="q" 		|| 
		opt=="g" 		|| 
		opt=="sfx" 		|| 
		opt=="m"		||
		opt=="dirsize")
        && i<argc-1 && argv[i+1][0]!='-' && command==0) 
		{
			command=opt[0];
		///printf("comando %c\n",command);
		///exit(0);
			if (opt=="extract") 
				command='x';
			if (opt=="test") 
				command='t';
			if (opt=="sfx")
				command='y';
			if (opt=="dirsize")
			{
				command='5';
				g_optional="dirsize";
			}
			archive=argv[++i];  // append ".zpaq" to archive if no extension
			const char* slash=strrchr(argv[i], '/');
			const char* dot=strrchr(slash ? slash : argv[i], '.');
			if (!dot && archive!="") 
				archive+=".zpaq";
			while (++i<argc && argv[i][0]!='-')  // read filename args
				files.push_back(argv[i]);
			--i;
		}
		else if ((opt=="sha1") || (opt=="sum"))
		{
			command='1'; ///opt[3]; /// note!
			while (++i<argc && argv[i][0]!='-')  // read filename args
				files.push_back(argv[i]);
			i--;
		}
#if defined(_WIN32)
		else if ((opt=="rd"))
		{
			command='7'; ///running on Windows
			while (++i<argc && argv[i][0]!='-')  // read filename args
				files.push_back(argv[i]);
			i--;
		}
#endif
		else if ((opt=="rsync"))
		{
			command='3'; ///opt[3]; /// note!
			while (++i<argc && argv[i][0]!='-')  // read filename args
				files.push_back(argv[i]);
			i--;
		}
		else if (opt=="d")
		{
			command='d';
			while (++i<argc && argv[i][0]!='-')  // read filename args
				files.push_back(argv[i]);
			i--;
		}
		else if (opt=="dir")
		{
			command='2'; // YES 2
			while (++i<argc && argv[i][0]!='-')  // read filename args
				files.push_back(argv[i]);
			i--;
		}
		else if (
		(opt=="n") 			|| 
		(opt=="f") 			|| 
		(opt=="c") 			|| 
		(opt=="s") 			|| 
		(opt=="utf") 		|| 
		(opt=="r") 			|| 
		(opt=="robocopy") 	|| 
		(opt=="cp") 	|| 
		opt=="z")
		{
			command=opt[0];
			if (opt=="cp")
					command='o';
				
			while (++i<argc && argv[i][0]!='-')
			{
	//	a very ugly fix for last \ in Windows
				string candidate=argv[i];
				cutdoublequote(candidate);
				if (havedoublequote(candidate))
				{
					printf("WARNING: double quote founded in command line and cutted\n");
					candidate.pop_back();
					printf("||%s||\n",candidate.c_str());
				}
#endif	
			files.push_back(candidate);
			}
			i--;
		}

		else if (opt.size()<2 || opt[0]!='-') usage();
		else 
		if (opt=="-all") 
		{
			all=4;
			if (i<argc-1 && isdigit(argv[i+1][0])) 	all				=atoi(argv[++i]);
		}
		/// if i==argc-1 we are the last parameters, otherwise something exists
		else if (opt=="-fragment" 	&& i<argc-1)	fragment		=atoi(argv[++i]);
		else if (opt=="-minsize" 	&& i<argc-1) 	minsize			=atoll(argv[++i]);
		else if (opt=="-maxsize" 	&& i<argc-1) 	maxsize			=atoll(argv[++i]);
		else if (opt=="-filelength" && i<argc-1) 	filelength		=atoi(argv[++i]);
		else if (opt=="-dirlength" 	&& i<argc-1) 	dirlength		=atoi(argv[++i]);
		else if (opt=="-n" 			&& i<argc-1) 	menoenne		=atoi(argv[++i]);
		else if (opt=="-limit" 		&& i<argc-1) 	menoenne		=atoi(argv[++i]);
		else if (opt=="-index" 		&& i<argc-1) 	index			=argv[++i];
		else if (opt=="-method" 	&& i<argc-1) 	method			=argv[++i];
		else if (opt=="-threads" 	&& i<argc-1) 	howmanythreads	=atoi(argv[++i]);
		///	warning -t3 agains -to z:\pippo
		else if ((opt[0]=='-') && (isdigit(opt[2])))
		{
			///printf("check  %d argc-1 %d\n",i,argc-1);
		
	
			if (opt[1]=='m') method			=argv[i]+2;
			if (opt[1]=='s') summary		=atoi(argv[i]+2);
			if (opt[1]=='t') howmanythreads	=atoi(argv[i]+2);
		}
		/// retained for backwards compatibility; with or without parameter
		else if (opt=="-summary" 	&& i<argc-1)	
		{
			///printf("non  ultimo i %d  %d\n",i,argc);
			if(argv[i+1][0]!='-')
				summary=atoi(argv[++i]);
			else
				summary=1;	
		}
		
		else if (opt=="-summary" 	&& i>=argc-1)	
		{
			///printf("ultimo i %d  %d\n",i,argc);
			summary=1;
		}
		else if ((opt=="-find") || (opt=="-search"))
		{
			if (i!=argc-1) // not the last parameter
			if (searchfrom=="" && strlen(argv[i+1])>=1)
			{
				searchfrom=argv[i+1];
				i++;
			}
		}
		else if (opt=="-orderby")
		{
			if (i!=argc-1) // not the last parameter
			if (orderby=="" && strlen(argv[i+1])>=1)
			{
				orderby=argv[i+1];
				i++;
			}
		}
		else if ((opt=="-findhash") || (opt=="-searchhash"))
		{
			if (i!=argc-1) // not the last parameter
			if (searchhash=="" && strlen(argv[i+1])>=1)
			{
				searchhash=argv[i+1];
				i++;
			}
		}
		else if (opt=="-replace")
		{
			if (i!=argc-1) // not the last parameter
			if (replaceto=="" && strlen(argv[i+1])>=1)
			{
				replaceto=argv[i+1];
				i++;
			}
		}
		else if ((opt=="-exec_error") || (opt=="-exec_err"))
		{
			if (g_exec_error=="")
			{
				if (++i<argc && argv[i][0]!='-')  
					g_exec_error=argv[i];
				else
					i--;
			}
		}
		else if (opt=="-exec_warn")
		{
			if (g_exec_warn=="")
			{
				if (++i<argc && argv[i][0]!='-')  
					g_exec_warn=argv[i];
				else
					i--;
			}
		}	
		else if (opt=="-exec_ok")
		{
			if (g_exec_ok=="")
			{
				if (++i<argc && argv[i][0]!='-')  
					g_exec_ok=argv[i];
				else
					i--;
			}
		}
		else if (opt=="-copy")
		{
			if (g_copy=="")
			{
				if (++i<argc && argv[i][0]!='-')  
					g_copy=argv[i];
				else
					i--;
			}
		}
		else if (opt=="-freeze")
		{
			if (g_freeze=="")
			{
				if (++i<argc && argv[i][0]!='-')  
					g_freeze=argv[i];
				else
					i--;
			}
		}
		else if (opt=="-output")
		{
			if (g_output=="")
			{
				if (++i<argc && argv[i][0]!='-')  
					g_output=argv[i];
				else
					i--;
			}
		}
		else if (opt=="-sfx")
		{
			if (g_sfx=="")
			{
				if (++i<argc && argv[i][0]!='-')  
					g_sfx=argv[i];
				else
					i--;
			}
		}
		else if (opt=="-sfxto")
		{
			if (g_sfxto=="")
			{
				if (++i<argc && argv[i][0]!='-')  
					g_sfxto=argv[i];
				else
					i--;
					/*
				if (g_sfxto[0]!='"')
					g_sfxto='"'+g_sfxto;
				if (g_sfxto[g_sfxto.size()-1]!='"')
					g_sfxto+='"';
					*/
			}
		}
		else if (opt=="-exec")
		{
			if (g_exec=="")
			{
				if (++i<argc && argv[i][0]!='-')  
					g_exec=argv[i];
				else
					i--;
			}
		}
		else if (opt=="-comment")
		{
			flagcomment=true;
			if (++i<argc && argv[i][0]!='-')  
				versioncomment=argv[i];
			else
				i--;
		}
		else if (opt=="-timestamp") 	// force the timestamp: zfs freezing
		{
			if (i+1<argc)
				if (strlen(argv[i+1])>=1)
				{
					string mytimestamp=argv[i+1];
					i++;
					int64_t newdate=encodestringdate(mytimestamp);
					if (newdate!=-1)
					{
						printf("franz: -timestamp change from %s => %s\n",dateToString(date).c_str(),dateToString(newdate).c_str());
						date=newdate;
					}
				}
		}
		
		else if (opt=="-force" || opt=="-f") 		flagforce			=true;
		else if (opt=="-sfxforce") 					g_sfxflagforce		=true;
		else if (opt=="-sfxall") 					g_sfxflagall		=true;
		else if (opt=="-zero") 						flagzero			=true;
		else if (opt=="-noattributes") 				flagnoattributes	=true;
		else if (opt=="-test") 						flagtest			=true;
		else if (opt=="-zfs") 						flagskipzfs			=true;
		else if (opt=="-forcezfs") 					flagforcezfs		=true;
		else if (opt=="-space") 					flagspace   		=true;
		else if (opt=="-filelist") 					flagfilelist		=true;
		else if (opt=="-xls") 						flagdonotforcexls	=true;
		else if (opt=="-verbose") 					flagverbose			=true;
		else if (opt=="-v") 						flagverbose			=true;
		else if (opt=="-debug") 					flagdebug			=true;
#ifdef HWSHA1
		else if (opt=="-hw") 						flaghw				=true;
#endif
		else if (opt=="-nodedup") 					flagnodedup			=true;
		else if (opt=="-tar") 						flagtar				=true;
		else if (opt=="-ramdisk") 					flagramdisk			=true;
		else if (opt=="-ssd") 						flagssd				=true;
		else if (opt=="-touch") 					flagtouch			=true;
		else if (opt=="-frugal") 					flagfrugal			=true;
		else if (opt=="-stat") 						flagstat			=true;
		else if (opt=="-desc") 						flagdesc			=true;
		else if (opt=="-noqnap") 					flagnoqnap			=true;
		else if (opt=="-nopath") 					flagnopath			=true;
		else if (opt=="-nosort") 					flagnosort			=true;
		else if (opt=="-checksum") 					flagchecksum		=true;
		else if (opt=="-nochecksum") 				flagnochecksum		=true;
		else if (opt=="-crc32c") 					flagcrc32c			=true;
		else if (opt=="-entropy") 					flagentropy			=true;
		else if (opt=="-sha1") 						flagsha1			=true;// stub: by default flagsha1
		else if (opt=="-xxh3") 						flagxxh3			=true;
		else if (opt=="-sha256") 					flagsha256			=true;
		else if (opt=="-blake3") 					flagblake3			=true;
		else if (opt=="-mm") 						flagmm				=true;
		else if (opt=="-append") 					flagappend			=true;
		else if (opt=="-utc") 						flagutc				=true;
		else if (opt=="-whirlpool")					flagwhirlpool		=true;
		else if (opt=="-md5")						flagmd5				=true;
		else if (opt=="-sha3")						flagsha3			=true;
		else if (opt=="-nilsimsa")					flagnilsimsa		=true;
		
		else if (opt=="-wyhash")
		{		flagwyhash			=true;
				printf("\n****** WARNING: WYHASH IMPLEMENTATION IS JUST FOR TEST *******\n\n");
		}
		else if (opt=="-xxhash") 					flagxxhash64		=true;
		else if (opt=="-crc32") 					flagcrc32			=true;
		else if (opt=="-verify") 					flagverify			=true;
		else if (opt=="-kill") 						flagkill			=true;
		else if (opt=="-utf") 						flagutf				=true;
		else if (opt=="-utf8") 						flagutf				=true;//alias
		else if (opt=="-fix255") 					flagfix255			=true;
		#ifdef _WIN32
		else if (opt=="-fixcase") 					flagfixcase			=true;
		else if (opt=="-fixreserved") 				flagfixreserved		=true;
		else if (opt=="-longpath") 					flaglongpath		=true;
		#endif
		else if (opt=="-fixeml") 					flagfixeml			=true;
		else if (opt=="-flat") 						flagflat			=true;
		else if (opt=="-paranoid") 					flagparanoid		=true;
		else if (opt=="-noeta") 					flagnoeta			=true;
		else if (opt=="-pakka") 					flagpakka			=true;  // we already have pakka flag, but this is for remember
		else if (opt=="-vss") 						flagvss				=true;
		else if (opt=="-forcewindows") 				flagforcewindows	=true;
		else if (opt=="-not") 
		{  // read notfiles
			while (++i<argc && argv[i][0]!='-') 
			{
				if (argv[i][0]=='=')
					nottype=argv[i];
				else
					notfiles.push_back(argv[i]);
			}
			--i;
		}
		else if (opt=="-sfxnot") 
		{  // read notfiles
			while (++i<argc && argv[i][0]!='-') 
			{
				if (argv[i][0]=='=')
					sfxnottype=argv[i];
				else
					sfxnotfiles.push_back(argv[i]);
			}
			--i;
		}
		else if (opt=="-only") 
		{  // read onlyfiles
			while (++i<argc && argv[i][0]!='-')
				onlyfiles.push_back(argv[i]);
			--i;
		}
		else if (opt=="-sfxonly") 
		{  // read onlyfiles
			while (++i<argc && argv[i][0]!='-')
				sfxonlyfiles.push_back(argv[i]);
			--i;
		}
		else if (opt=="-always") 
		{  // read alwaysfiles
			while (++i<argc && argv[i][0]!='-')
				alwaysfiles.push_back(argv[i]);
			--i;
		}

		else if (opt=="-key") 
		{
			if (i<argc-1) // I am not the last parameter
				if (argv[i+1][0]!='-') // -key pippo -whirlpool
				{
					plainpassword="";
			//		printf("We take password\n");
					libzpaq::SHA256 sha256;
					for (const char* p=argv[++i]; *p; ++p)
					{
						sha256.put(*p);
						plainpassword+=*p;
					}
					memcpy(password_string, sha256.result(), 32);
					password=password_string;
				}
			if (password==NULL)
			{
				string spassword=getpassword();
				///printf("entered <<%s>>\n",spassword.c_str());
				if (spassword!="")
				{
					libzpaq::SHA256 sha256;
					for (unsigned int i=0;i<spassword.size();i++)
						sha256.put(spassword[i]);
					memcpy(password_string, sha256.result(), 32);
					password=password_string;
				}
				
			}
		}
		else if (opt=="-key2") //for setpassword 
		{
			if (i<argc-1) // I am not the last parameter
				if (argv[i+1][0]!='-') // -key pippo -whirlpool
				{
					libzpaq::SHA256 sha256;
					for (const char* p=argv[++i]; *p; ++p)
						sha256.put(*p);
					
					memcpy(new_password_string, sha256.result(), 32);
					new_password=new_password_string;

				}
			if (new_password==NULL)
			{
				string spassword=getpassword();
				if (spassword!="")
				{
					libzpaq::SHA256 sha256;
					for (unsigned int i=0;i<spassword.size();i++)
						sha256.put(spassword[i]);
					memcpy(new_password_string, sha256.result(), 32);
					new_password=new_password_string;
				}
			}
		}
		else
		if (opt=="-repack" && i<argc-1) 
		{
			repack=argv[++i];
			string estensione=prendiestensione(repack);
			if (estensione=="")
				repack+=".zpaq";
				
///			printf("Repack to %s\n",repack.c_str());
				
			if (i<argc-1 && argv[i+1][0]!='-') 
			{
				libzpaq::SHA256 sha256;
				for (const char* p=argv[++i]; *p; ++p) 
					sha256.put(*p);
				memcpy(new_password_string, sha256.result(), 32);
				new_password=new_password_string;
			}
		}
		else if (opt=="-to") 
		{  // read tofiles. Possible collision with -tthread
			while (++i<argc && argv[i][0]!='-')
			{
	// fix to (on windows) -to "z:\pippo pluto" going to a mess
				string mytemp=mytrim(argv[i]);
				myreplaceall(mytemp,"\"","");
				tofiles.push_back(mytemp);
				///printf("My temp %s\n",mytemp.c_str());
			}
			if (tofiles.size()==0)
				tofiles.push_back("");
			--i;
		}
		else 
		if (opt=="-until" && i+1<argc) 
		{  // read date

		  // Read digits from multiple args and fill in leading zeros
			version=0;
			int digits=0;
			if (argv[i+1][0]=='-')
			{  // negative version
				version=atol(argv[i+1]);
				if (version>-1)
					usage();
				++i;
			}
			else 
			{  // positive version or date
				while (++i<argc && argv[i][0]!='-') 
				{
					for (int j=0; ; ++j) 
					{
						if (isdigit(argv[i][j])) 
						{
							version=version*10+argv[i][j]-'0';
							++digits;
						}
						else 
						{
							if (digits==1)
								version=version/10*100+version%10;
							digits=0;
							if (argv[i][j]==0)
								break;
						}
					}
				}
				--i;
			}

		  // Append default time
			if (version>=19000000LL     && version<=29991231LL)
				version=version*100+23;
			if (version>=1900000000LL   && version<=2999123123LL)
				version=version*100+59;
			if (version>=190000000000LL && version<=299912312359LL)
				version=version*100+59;
			if (version>9999999) 
			{
				if (version<19000101000000LL || version>29991231235959LL) 
				{
					fflush(stdout);
					fprintf(stderr,"Version date %1.0f must be 19000101000000 to 29991231235959\n",double(version));
					g_exec_text="Version date must be 19000101000000 to 29991231235959";
					exit(1);
				}
				date=version;
			}
		}
		else
		if (opt=="-sfxuntil" && i+1<argc) 
		{  
			if (g_sfxuntil=="")
			{
				if (++i<argc && argv[i][0]!='-')  
					g_sfxuntil=argv[i];
				else
					i--;
			}
		}
		else 
		{
			printf("Unknown option ignored: %s\n", argv[i]);
		}
	}
			

//	write franzs' parameters (if not very briefly)
	if (!flagpakka)
	{
		string franzparameters="";

		if (flagbarraod)
			franzparameters+="Order by date (/od) ";
		
		if (flagbarraon)
			franzparameters+="Order by name (/on) ";
		
		if (flagbarraos)
			franzparameters+="Order by size (/os) ";
			
		if (flagforcezfs)
		{
			franzparameters+="force ZFS on (-forcezfs) ";
			flagskipzfs=false; // win over skip
		}

		if (flagskipzfs)
			franzparameters+="SKIP ZFS (-zfs) ";
		
		if (flag715)
			franzparameters+="mode -715 activated  " ;
		
		if (flagfilelist)
			franzparameters+="-flagfilelist " ;
		
		if (flagnoqnap)
			franzparameters+="Exclude QNAP snap & trash (-noqnap) ";

		if (flagforcewindows)
			franzparameters+="Force Windows stuff (-forcewindows) ";

		if (flagnopath)
			franzparameters+="Do not store path (-nopath) ";

		if (flagzero)
			franzparameters+="Zero file ";

		if (flagnosort)
			franzparameters+="-nosort ";

		if (flagdonotforcexls)
			franzparameters+="Do not force XLS/PPT (-xls) ";
		
		if (flagspace)
			franzparameters+="Do not check free space/writeability ";
		
		if (flagverbose)
			franzparameters+="-verbose ";
		
		if (flagchecksum)
			franzparameters+="-checksum ";
		
		if (flagnochecksum)
			franzparameters+="NO checksum (-nochecksum) ";
		
		if (flagcrc32c)
			franzparameters+="-crc32c ";
		
		if (flagentropy)
			franzparameters+="-entropy ";
		
		if (flagsha1)
			franzparameters+="-sha1 ";
		
		if (flagcrc32)
			franzparameters+="-crc32 ";
				
		if (flagxxh3)
			franzparameters+="-xxh3 ";
		
		if (flagsha256)
			franzparameters+="-sha256 ";
			
		if (flagwyhash)
			franzparameters+="-wyhash ";
	
		if (flagwhirlpool)
			franzparameters+="-whirlpool ";
	
		if (flagnilsimsa)
			franzparameters+="-nilsimsa ";
	
		if (flagmd5)
			franzparameters+="-md5 ";
	
		if (flagsha3)
			franzparameters+="-sha3 ";
	
		if (flagblake3)
			franzparameters+="-blake3 ";
			
		if (flagxxhash64)
			franzparameters+="xxhash64 (-xxhash) ";

		if (flagmm)
			franzparameters+="memory mapped file (-mm) ";
			
		if (flagappend)
			franzparameters+="append in copy (-append) ";
		
		if (flagutc)
			franzparameters+="UTC instead of local time (-utc) ";
		
		if (flagverify)
			franzparameters+="-verify ";
				
		if (flagkill)
			franzparameters+="do a wet run! (-kill) ";
				
		if (flagutf)
			franzparameters+="flagutf (-utf / -utf8) ";
		
		if (flagfix255)
			franzparameters+="-fix255 ";
		
		if (flagfixcase)
			flagstat=true;
		
#ifdef _WIN32
		if (flagfixcase)
			franzparameters+="-fixcase ";
		
		if (flagfixreserved)
			franzparameters+="-fixreserved ";
		
		if (flaglongpath)
			franzparameters+="Long path (on Windows) ";
#endif 	
		if (flagfixeml)
			franzparameters+="Fix eml filenames (-fixeml) ";
		
		if (flagflat)
			franzparameters+="Flat filenames (-flat) ";
		
		if (flagparanoid)
			franzparameters+="-paranoid ";
		
		if (flagnodedup)
			franzparameters+="-nodedup ";
		
		if (flagtar)
			franzparameters+="TAR mode ";
		
		if (flagramdisk)
			franzparameters+="-ramdisk ";
		
		if (flagssd)
			franzparameters+="-ssd ";
		
		if (flagtouch)
			franzparameters+="-touch ";
		
		if (flagfrugal)
			franzparameters+="-frugal ";
		
		if (flagstat)
			franzparameters+="-stat ";
				
		if (flagdebug)
			franzparameters+="DEBUG very verbose (-debug) ";
		
		if (flagdesc)
			if (orderby!="")
				franzparameters+="desc sort ";

#ifdef HWSHA1
		if (flaghw)
		{
			franzparameters+="SHA1 HW ";
			Sha1Prepare(true);
		}
		else
			Sha1Prepare(false);
#endif
		
		if (flagcomment)
			franzparameters+="Use comment (-comment) ";
	
		if (summary>0)
			franzparameters+="-summary ";

		char	temp[100];

		if (minsize)
		{
			sprintf(temp,"minsize %s ",migliaia(minsize));
			franzparameters+=temp;
		}
		if (maxsize)
		{
			sprintf(temp,"maxsize %s ",migliaia(maxsize));
			franzparameters+=temp;
		}
		if (dirlength)
		{
			sprintf(temp,"dirlength %s ",migliaia(dirlength));
			franzparameters+=temp;
		}
		if (filelength)
		{
			sprintf(temp,"filelength %s ",migliaia(filelength));
			franzparameters+=temp;
		}
		if (menoenne)
		{
			sprintf(temp,"limit (-n -limit) %u ",menoenne);
			franzparameters+=temp;
		}
		
#ifdef _WIN32
		if (flagvss)
		{
			franzparameters+=" VSS Volume Shadow Copy (-vss) ";
			if (!isadmin())
			{
				printf("\nImpossible to run VSS: admin rights required\n");
				return 2;
			}	
		}
#endif	
		if (franzparameters!="")
			printf("franz:%s\n",franzparameters.c_str());

		if (orderby!="")
			printf("franz:orderby    <<%s>>\n",orderby.c_str());

		if (searchhash!="")
			printf("franz:find hash  <<%s>>\n",searchhash.c_str());

		if (searchfrom!="")
			printf("franz:find       <<%s>>\n",searchfrom.c_str());

		if (replaceto!="")
			printf("franz:replace    <<%s>>\n",replaceto.c_str());
		
		if (g_exec_error!="")
			printf("franz:exec_error <<%s>>\n",g_exec_error.c_str());
		
		if (g_exec_warn!="")
			printf("franz:exec_warn  <<%s>>\n",g_exec_warn.c_str());
				
		if (g_exec_ok!="")
			printf("franz:exec_ok    <<%s>>\n",g_exec_ok.c_str());
		
		if (g_exec!="")
			printf("franz:exec       <<%s>>\n",g_exec.c_str());
	
		if (g_copy!="")
			printf("franz:copy       <<%s>>\n",g_copy.c_str());

		if (g_output!="")
		{
			printf("franz:output     <<%s>>\n",g_output.c_str());
			open_output(g_output);
		}

		if (g_sfx!="")
			printf("franz:sfx        <<%s>>\n",g_sfx.c_str());

		if (g_sfxto!="")
			printf("franz:sfxto      <<%s>>\n",g_sfxto.c_str());
	}
	
	if (howmanythreads<1) 
		howmanythreads=numberOfProcessors();


  // Test date
	if (now==-1 || date<19000000000000LL || date>30000000000000LL)
		error("date is incorrect, use -until YYYY-MM-DD HH:MM:SS to set");

  // Adjust negative version
	if (version<0) 
	{
		Jidac jidac(*this);
		jidac.version=DEFAULT_VERSION;
		jidac.read_archive(archive.c_str());
		version+=jidac.ver.size()-1;
		printf("Version %1.0f\n", version+.0);
	}

/*
	Substitute $day into archive and files
*/

	archive=format_datetime(archive);
	for (unsigned int i=0;i<files.size();i++)
		files[i]=format_datetime(files[i]);
	
// Load dynamic functions in Windows Vista and later
#ifndef unix
	HMODULE h=GetModuleHandle(TEXT("kernel32.dll"));
	if (h==NULL) 
		printerr("14717","GetModuleHandle",0);
	else 
	{
		findFirstStreamW=(FindFirstStreamW_t)GetProcAddress(h, "FindFirstStreamW");
		findNextStreamW=(FindNextStreamW_t)GetProcAddress(h, "FindNextStreamW");
///		getFinalPathNameByHandleW=(GetFinalPathNameByHandleW_t)GetProcAddress(h, "GetFinalPathNameByHandleW");
		/*
		if (getFinalPathNameByHandleW==NULL)
			printf("ZEROOO\n");
		else
			printf("CIaiamoooo\n");
		exit(0);
		*/
		
	}
///  if (!findFirstStreamW || !findNextStreamW)
///broken XP parser    printf("Alternate streams not supported in Windows XP.\n");
#endif
	
	
	if (flag715)
	{
		flagutc				=true;
		flagzero			=false;
		flagforcezfs		=true;
		flagdonotforcexls	=true;
		flagforcewindows	=true;
		flagcrc32			=false;
		flagentropy			=false;
		flagchecksum		=false;
		flagnochecksum		=true;
		flagfilelist		=false;
		flagxxh3			=false; // checksumming add new style
		flagxxhash64		=false; // checksumming add new style
		flagfixeml			=false;
		flagfix255			=false;
		flagtouch			=false;
		flagramdisk			=false;
#ifdef _WIN32
		flagfixcase			=false;
		flagfixreserved		=false;
		flaglongpath		=false;
#endif
		flagutf				=false;
		flagflat			=false;
		flagparanoid		=false;
		g_franzotype		=0;
		printf("**** Activated V7.15 mode ****\n");
		printf("T forcezfs,donotforcexls,forcewindows; F crc32,checksum,filelist,xxhash,xxh3,fixeml,fix255,fixreserved,longpath,utf,flat\n");
	}




  // Execute command
	if (command=='a' && files.size()>0) // enforce: we do not want to change anything when adding
	{
		if (flagtar)
		{
			flagnodedup=true;
			method='0';
		}
		flagfixeml			=false;
		flagfix255			=false;
		flagutf				=false;
		flagfixcase			=false;
		
#ifdef _WIN32
		flagfixreserved		=false;
#endif
		flagflat			=false;
		flagparanoid		=false;
		
		if (flag715 || flagnochecksum)
			g_franzotype=FRANZO_NONE;
		else
		if (flagcrc32)
			g_franzotype=FRANZO_CRC_32;
		else
		if (flagsha1 || flagchecksum) //backward compatibility 51
			g_franzotype=FRANZO_SHA_1; //SHA1
		else
		if (flagsha256)
			g_franzotype=FRANZO_SHA_256;
		else
		if (flagxxh3)
			g_franzotype=FRANZO_XXH3;
		else
		if (flagblake3)
			g_franzotype=FRANZO_BLAKE3;
		else
		if (flagsha3)
			g_franzotype=FRANZO_SHA3;
		else
		if (flagmd5)
			g_franzotype=FRANZO_MD5;
		else
			g_franzotype=FRANZO_XXHASH64; // by default 2 (CRC32+XXHASH64)
	
		return add();
	}
	else if (command=='n') return decimation();
	else if (command=='1') return summa();
	else if (command=='2') return dir();
	else if (command=='3') return purgersync();
	else if (command=='4') return trim();
	else if (command=='5') return zpaqdirsize();
	else if (command=='6') return setpassword();
	else if (command=='7') return rd();
	else if (command=='b') return benchmark();
	else if (command=='c') return dircompare(false,false);
	else if (command=='d') return deduplicate();
	else if (command=='f') return fillami();
#ifdef _WIN32
	else if (command=='g') return adminrun();
#endif
	else if (command=='i') return info();
	else if (command=='k') return kill();
	else if (command=='l') return list();
	else if (command=='m') return consolidate(archive);
	else if (command=='o') return mycopy();
	else if (command=='p') return paranoid();
#ifdef _WIN32
	else if (command=='q') return windowsc();
#endif
	else if (command=='r') return robocopy();
	else if (command=='s') return dircompare(true,false); 
	else if (command=='t') return test();
	else if (command=='u') return utf();
	else if (command=='v') return verify(true);
	else if (command=='w') return extractw();
	else if (command=='x') return extract();
	else if (command=='y') return sfx();
	else if (command=='z') return zero();
	else if (command=='9') return zfs(g_optional);
	else usage();
	return 0;
}


bool Jidac::getfoldersize(string i_folder,uint64_t& o_totalsize,uint32_t & o_totalfile,uint32_t& o_totaldir)
{
	o_totalsize=0;
	o_totalfile=0;
	o_totaldir=0;
	if (i_folder=="")
		return false;
	
	/// we need to cut last / for Windows longpath
	if (isdirectory(i_folder))
		i_folder=i_folder.substr(0,i_folder.size()-1);
	
	DTMap mydestinationdir;
	if (flagdebug)
	{
		printf("29247: Scanning dir <<");
		printUTF8(i_folder.c_str());
		printf(">>\n");
	}
	scandir(true,mydestinationdir,i_folder);
	
	printbar(' ',false);
	printf("\r");
	
	for (DTMap::iterator p=mydestinationdir.begin(); p!=mydestinationdir.end(); ++p) 
	{
		if (!isdirectory(p->first))
		{
			o_totalsize+=p->second.size;
			o_totalfile++;
		}
		else
			o_totaldir++;
	}
	
	if (flagdebug)
		printf("29260: files %s dirs %s size %s\n",migliaia(o_totalfile),migliaia2(o_totaldir),migliaia3(o_totalsize));
	
	if (o_totalfile || o_totaldir || o_totalsize)
		return true;
	return false;
}

int Jidac::rd()
{
	printf("Remove Directory ");
	if (files.size()==0)
	{
		printf("29241: rd exactly at least one folder\n");
		return 2;
	}
	// cut the last / because we want longfile support on Windows

	for (unsigned int i=0;i<files.size();i++)
	{
		if (isdirectory(files[i]))
			files[i]=files[i].substr(0, files[i].size()-1);
#ifdef _WIN32
		if (flaglongpath)
			if (iswindowspath(files[i]))
				if (!islongpath(files[i]))
					files[i]="//?/"+files[i];
#endif

		uint64_t 		totalsize=0;
		unsigned int 	totalfile=0;
		unsigned int 	totaldir=0;
		
		if (!direxists(files[i]))
		{
			printf("\nFolder %d does not exist? ",i);
			printUTF8(files[i].c_str());
			printf("\n");
			return 1;
		}
		if (!getfoldersize(files[i],totalsize,totalfile,totaldir))
		{
			printf("29284: cannot enumerate folder %d ",i);
			printUTF8(files[i].c_str());
			printf("\n");
			return 1;
		}
		if (!flagspace)
			if (!saggiascrivibilitacartella(files[i]))
			{
				printf("\n29289: cannot write into %d ",i);
				printUTF8(files[i].c_str());
				printf(" -space to bypass");
				return 1;
			}
		printf("\n");
		printbar('=');
		printf("Files %s for %s bytes (%s)\n",migliaia(totalfile),migliaia(totalsize),tohuman(totalsize));
		if (totalsize>0) 
			if (!flagforce)
			{
				printf("29301: the folder size is not zero, use -force to bypass\n");
				return 2;
			}

		if (flagkill)
		{
			if (totalsize>0)
				if (!getcaptcha("y","Remove folder WITH subfolders?"))
					return 1;
				
			if (stermina(files[i],totalfile))
			{
				printf("\nOK: folder %i does not seems to exist anymore ",i);
				printUTF8(files[i].c_str());
				printf("\n");
			}
		}
		else
		{
			printf("29310: dry run. Use -kill for a wet-run\n");
			return 2;
		}
	}
	return 0;
}

uint32_t checkfilename(
const string&	i_filename,
int* 			o_toolongfilenames,
int* 			o_adsfilenames,
int* 			o_utf8names,
int* 			o_reservedfilenames,
int*			o_windowspath,
int*			o_windowsunc)
{
	if (i_filename=="")
		return 0;
	
	uint32_t	risultato=0;
	
	if (o_toolongfilenames)
		if (i_filename.length()>255)
		{
			(*o_toolongfilenames)++;
			risultato&=FIX_TOOLONG;
		}

	if (o_adsfilenames)
		if (strstr(i_filename.c_str(), ":$DATA"))
			if (mypos("VCOMMENT",i_filename)!=0)
			{
				(*o_adsfilenames)++;
				risultato&=FIX_ADS;
			}
	if (o_utf8names)
		if (i_filename!=utf8toansi(i_filename))
		{
			(*o_utf8names)++;
			risultato&=FIX_UTF8;
		}	

	if (o_reservedfilenames)
	{
		string fixed;
		if (isreserved(i_filename,fixed))
		{
			(*o_reservedfilenames)++;
			risultato&=FIX_RESERVED;
		}	
	}
	
	if (o_windowspath)
		if (iswindowspath(i_filename))
		{
			(*o_windowspath)++;
			risultato&=FIX_WINDOWSPATH;
		}
	
	if (o_windowsunc)
		if (iswindowsunc(i_filename))
		{
			(*o_windowsunc)++;
			risultato&=FIX_WINDOWSUNC;
		}
		
	return risultato;
}


/////////////////////////// read_archive //////////////////////////////

// Read arc up to -date into ht, dt, ver. Return place to
// append. If errors is not NULL then set it to number of errors found.
int64_t Jidac::read_archive(const char* arc, int *errors, int i_myappend,bool i_quiet) 
{
	if (errors) *errors=0;
	dcsize=dhsize=0;
	assert(ver.size()==1);

	const bool i_renamed=command=='l' || command=='a' || command=='5' ; ///5 for dirsize arrggghh hidden parameter!

	const bool i_isinfo=(command=='i') && (!flagstat); // -stat? Do a lot of work

	unsigned files=0;  // count

	// Open archive
	InputArchive in(arc, password);

	if (!in.isopen()) 
	{
		if (command!='a') 
		{
			fflush(stdout);
			printUTF8(arc, stderr);
			fprintf(stderr, " not found.\n");
			g_exec_text=arc;
			g_exec_text+=" not found";
			if (errors) ++*errors;
		}
		return 0;
	}
	
	if (!i_quiet)
		if (!flagpakka)
		{
			printUTF8(arc);
			if (version==DEFAULT_VERSION) printf(": ");
				else 
			printf(" -until %1.0f: ", version+0.0);
			fflush(stdout);
		}
		
  // Test password
  
	char s[4]={0};
	const int nr=in.read(s, 4);
	if (nr>0 && memcmp(s, "7kSt", 4) && (memcmp(s, "zPQ", 3) || s[3]<1))
	{
		printf("zpaqfranz error:password incorrect\n");
		error("password incorrect");
	}
    in.seek(-nr, SEEK_CUR);
  

	// Scan archive contents
	string lastfile=archive; // last named file in streaming format
  
	if (lastfile.size()>5 && lastfile.substr(lastfile.size()-5)==".zpaq")
		lastfile=lastfile.substr(0, lastfile.size()-5); // drop .zpaq
	
	int64_t block_offset=32*(password!=0);  // start of last block of any type
	int64_t data_offset=block_offset;    // start of last block of d fragments
	bool found_data=false;   // exit if nothing found
	bool first=true;         // first segment in archive?
	StringBuffer os(32832);  // decompressed block
  
	int toolongfilenames	=0;
	int adsfilenames		=0;
	int utf8names			=0;
	int casecollision		=0;
	int reservedfilenames	=0;
	int windowsunc			=0;
	int windowspath			=0;
	uint64_t parts			=0;
	
  // Detect archive format and read the filenames, fragment sizes,
  // and hashes. In JIDAC format, these are in the index blocks, allowing
  // data to be skipped. Otherwise the whole archive is scanned to get
  // this information from the segment headers and trailers.
	bool done=false;
	if (!i_quiet)
		printf("\n");
	uint64_t startblock=mtime();
	while (!done) 
	{
		libzpaq::Decompresser d;
		try 
		{
			d.setInput(&in);
			double mem=0;
			while (d.findBlock(&mem)) 
			{
				found_data=true;

        // Read the segments in the current block
				StringWriter filename, comment;
				int segs=0;  // segments in block
				bool skip=false;  // skip decompression?
				while (d.findFilename(&filename)) 
				{
					if (filename.s.size()) 
					{
						for (unsigned i=0; i<filename.s.size(); ++i)
							if (filename.s[i]=='\\') 
								filename.s[i]='/';
						lastfile=filename.s.c_str();
					}
				
					comment.s="";
					d.readComment(&comment);

          // Test for JIDAC format. Filename is jDC<fdate>[cdhi]<num>
          // and comment ends with " jDC\x01". Skip d (data) blocks.
					if (comment.s.size()>=4 && comment.s.substr(comment.s.size()-4)=="jDC\x01") 
					{
						if (filename.s.size()!=28 || filename.s.substr(0, 3)!="jDC")
							error("bad journaling block name");
						if (skip) 
							error("mixed journaling and streaming block");

            // Read uncompressed size from comment
						int64_t usize=0;
						unsigned i;
						for (i=0; i<comment.s.size() && isdigit(comment.s[i]); ++i) 
						{
							usize=usize*10+comment.s[i]-'0';
							if (usize>0xffffffff) 
								error("journaling block too big");
						}

            // Read the date and number in the filename
						int64_t fdate=0, num=0;
						for (i=3; i<17 && isdigit(filename.s[i]); ++i)
							fdate=fdate*10+filename.s[i]-'0';
						if (i!=17 || fdate<19000000000000LL || fdate>=30000000000000LL)
							error("bad date");
						for (i=18; i<28 && isdigit(filename.s[i]); ++i)
							num=num*10+filename.s[i]-'0';
						if (i!=28 || num>0xffffffff) 
							error("bad fragment");


            // Decompress the block.
						os.resize(0);
						os.setLimit(usize);
						d.setOutput(&os);
						libzpaq::SHA1 sha1;
						d.setSHA1(&sha1);
						if (strchr("chi", filename.s[17])) 
						{
							if (mem>1.5e9) 
								error("index block requires too much memory");
							d.decompress();
							char sha1result[21]={0};
							d.readSegmentEnd(sha1result);
							if ((int64_t)os.size()!=usize) 
								error("bad block size");
							if (usize!=int64_t(sha1.usize())) 
								error("bad checksum size");
							if (sha1result[0] && memcmp(sha1result+1, sha1.result(), 20))
								error("bad checksum");
							if ( ++parts % 1000 ==0)
								if (!flagnoeta)
									printf("Block %10s K %12s (block/s)\r",migliaia(parts/1000),migliaia2(parts/((mtime()-startblock+1)/1000.0)));
						}
						else
							d.readSegmentEnd();

            // Transaction header (type c).
            // If in the future then stop here, else read 8 byte data size
            // from input and jump over it.
						if (filename.s[17]=='c') 
						{
							if (os.size()<8) 
								error("c block too small");
							data_offset=in.tell()+1-d.buffered();
							const char* s=os.c_str();
							int64_t jmp=btol(s);
							if (jmp<0) 
								printf("Incomplete transaction ignored\n");
							if (jmp<0 || 
							(version<19000000000000LL && int64_t(ver.size())>version)
							|| (version>=19000000000000LL && version<fdate)) 
							{
								done=true;  // roll back to here
								goto endblock;	// WOW, a goto! I never seen one from C-64 back 1985!
							}
							else 
							{
								dcsize+=jmp;
								if (jmp) in.seek(data_offset+jmp, SEEK_SET);
								ver.push_back(VER());
								ver.back().firstFragment=ht.size();
								ver.back().offset=block_offset;
								ver.back().data_offset=data_offset;
								ver.back().date=ver.back().lastdate=fdate;
								ver.back().csize=jmp;
								if (all) 
								{
									string fn=itos(ver.size()-1, all)+"/"; ///peusa1 versioni
									if (i_renamed) 
										fn=rename(fn);
									
									if (isselected(fn.c_str(), false,-1))
										dt[fn].date=fdate;
								}
								if (jmp) 
									goto endblock;
							}
						}

            // Fragment table (type h).
            // Contents is bsize[4] (sha1[20] usize[4])... for fragment N...
            // where bsize is the compressed block size.
            // Store in ht[].{sha1,usize}. Set ht[].csize to block offset
            // assuming N in ascending order.
						else 
						if (filename.s[17]=='h') 
						{
							assert(ver.size()>0);
							if (fdate>ver.back().lastdate) 
								ver.back().lastdate=fdate;
							if (os.size()%24!=4) 
								error("bad h block size");
							const unsigned n=(os.size()-4)/24;
							if (num<1 || num+n>0xffffffff) 
								error("bad h fragment");
							const char* s=os.c_str();
							const unsigned bsize=btoi(s);
							dhsize+=bsize;
							assert(ver.size()>0);
							if (int64_t(ht.size())>num) 
							{
								fflush(stdout);
								fprintf(stderr,
								  "Unordered fragment tables: expected >= %d found %1.0f\n",
								  int(ht.size()), double(num));
								 g_exec_text="Unordered fragment tables";
							}
							
							for (unsigned i=0; i<n; ++i) 
							{
								if (i==0) 
								{
									block.push_back(Block(num, data_offset));
									block.back().usize=8;
									block.back().bsize=bsize;
									block.back().frags=os.size()/24;
								}
								while (int64_t(ht.size())<=num+i) 
									ht.push_back(HT());
								memcpy(ht[num+i].sha1, s, 20);
								s+=20;
								assert(block.size()>0);
								unsigned f=btoi(s);
								if (f>0x7fffffff) 
									error("fragment too big");
								block.back().usize+=(ht[num+i].usize=f)+4u;
							 }
							data_offset+=bsize;
						}

            // Index (type i)
            // Contents is: 0[8] filename 0 (deletion)
            // or:       date[8] filename 0 na[4] attr[na] ni[4] ptr[ni][4]
            // Read into DT
						else 
						if (filename.s[17]=='i') 
						{
				
							assert(ver.size()>0);
							if (fdate>ver.back().lastdate) 
								ver.back().lastdate=fdate;
							const char* s=os.c_str();
							const char* const end=s+os.size();
			
							while (s+9<=end) 
							{
								DT dtr;
								dtr.date=btol(s);  // date
								if (dtr.date) 
									++ver.back().updates;
								else 
									++ver.back().deletes;
					
								const int64_t len=strlen(s);
								if (len>65535) 
									error("filename too long");
					
								string fn=s;  // filename ren
								
								if (!i_isinfo)
								{
								if ((flagstat) && (command!='5') && (command!='6'))
						//-stat, we ask for extended infos
						//not useful with dirsize, setpassword, info
								{
									checkfilename(fn,
									&toolongfilenames,
									&adsfilenames,
									&utf8names,
									NULL,// reserved file names, only on WIN32
									&windowspath,
									&windowsunc);
									string fixed;
#ifdef _WIN32
									if (isreserved(fn,fixed))
									{
										reservedfilenames++;
										if (flagfixreserved)
										{
											printf("29229: WARNING changed reserved <<");
											printUTF8(fn.c_str());
											printf(">>\n");
											fn=fixed;
											printf("29230: to filesystem compatible <<");
											printUTF8(fn.c_str());
											printf(">>\n");
										}
									}
#endif
								}
								else

#ifdef _WIN32
								checkfilename(fn,  /// by default check only toolong and utf
								&toolongfilenames,
								NULL,
								NULL,
								NULL,
								NULL,
								NULL);
#else				// *nix can restore (almost) everything, no warnings needed by default
#endif

									if (all) 
									{
										if (i_myappend)
											fn=itos(ver.size()-1, all)+"|$1"+fn;
										else
											fn=append_path(itos(ver.size()-1, all), fn);
									}
		
								}
					bool issel=false;
						if (!i_isinfo)
							issel=isselected(fn.c_str(), i_renamed,-1);
													
					s+=len+1;  // skip filename
					if (s>end) 
						error("filename too long");
					if (dtr.date) 
					{
						++files;
						if (s+4>end) 
							error("missing attr");
						unsigned na=0;
	
						na=btoi(s);  // attr bytes
				  
						if (s+na>end || na>65535) 
							error("attr too long");
						
						if (!i_isinfo)
					
						if (na>FRANZOFFSET) //Get FRANZOFFSET
						{
							assert((na-8)<FRANZOFFSETSHA256); // cannot work on too small buffer
							for (unsigned int i=0;i<(na-8);i++)
								dtr.franz_block[i]=*(s+(na-(na-8))+i);
							dtr.franz_block_size=(na-8);
							dtr.franz_block[(na-8)]=0x0;
							if (flagstat)
							{
								string myhashtype="";
								string myhash="";
								string mycrc32="";
					
								decode_franz_block(false,dtr.franz_block,
								myhashtype,
								myhash,
								mycrc32);	
									
								if (strstr(myhash.c_str(),"!ERROR!"))
								{
									if (flagforce)
									{
										if (flagverbose)
											printf("27752: *** 'strange' but -force     -> included ");
									}
									else
									{
										if (flagverbose)
											printf("27754: *** 'strange' and NOT -force -> skipped  ");
										issel=false;
										if (errors)
											(*errors)++;
									}
									
									if (flagverbose)
									{
										printUTF8(fn.c_str());
										printf("\n");
									}
								}
							}
						}
				
						for (unsigned i=0; i<na; ++i, ++s)  // read attr
							if (i<8) 
								dtr.attr+=int64_t(*s&255)<<(i*8);
					
						if (flagnoattributes) 
							dtr.attr=0;
						if (s+4>end) 
							error("missing ptr");
						unsigned ni=btoi(s);  // ptr list size
				  
						if (ni>(end-s)/4u) 
							error("ptr list too long");
						if (issel) 
							dtr.ptr.resize(ni);
						for (unsigned i=0; i<ni; ++i) 
						{  // read ptr
							const unsigned j=btoi(s);
							if (issel) 
								dtr.ptr[i]=j;
						}
					}
/// UBUNTU
					if (!i_isinfo)		//info command: we want versions, not files (2 times faster)
						if (issel)
							dt[fn]=dtr;
			///		dt.insert(std::pair<string, DT>(fn,dtr));
				}  // end while more files
            }  // end if 'i'
            else 
			{
				printf("Skipping %s %s\n",filename.s.c_str(), comment.s.c_str());
				error("Unexpected journaling block");
            }
          }  // end if journaling

          // Streaming format
          else 
		  {

            // If previous version does not exist, start a new one
            if (ver.size()==1) 
			{
				if (version<1) 
				{
					done=true;
					goto endblock;
				}
				ver.push_back(VER());
				ver.back().firstFragment=ht.size();
				ver.back().offset=block_offset;
				ver.back().csize=-1;
			}

			char sha1result[21]={0};
			d.readSegmentEnd(sha1result);
            skip=true;
            string fn=lastfile;
            if (all) fn=append_path(itos(ver.size()-1, all), fn); ///peusa3
            if (isselected(fn.c_str(), i_renamed,-1)) {
              DT& dtr=dt[fn];
              if (filename.s.size()>0 || first) {
                ++files;
                dtr.date=date;
                dtr.attr=0;
                dtr.ptr.resize(0);
                ++ver.back().updates;
              }
              dtr.ptr.push_back(ht.size());
            }
            assert(ver.size()>0);
            if (segs==0 || block.size()==0)
              block.push_back(Block(ht.size(), block_offset));
            assert(block.size()>0);
            ht.push_back(HT(sha1result+1, -1));
          }  // end else streaming
          ++segs;
          filename.s="";
          first=false;
        }  // end while findFilename
        if (!done) block_offset=in.tell()-d.buffered();
      }  // end while findBlock
      done=true;
    }  // end try
    catch (std::exception& e) {
      in.seek(-d.buffered(), SEEK_CUR);
      fflush(stdout);
      fprintf(stderr, "Skipping block at %1.0f: %s\n", double(block_offset),
              e.what());
		g_exec_text="Skipping block";
      if (errors) ++*errors;
    }
endblock:;
  }  // end while !done
  if (in.tell()>32*(password!=0) && !found_data)
    error("archive contains no data");
	if (!i_quiet)
	if (!flagpakka)
	printf("%d versions, %s files, %s fragments, %s blocks, %s bytes (%s)\n", 
      int(ver.size()-1), migliaia(files), migliaia2(unsigned(ht.size())-1),
      migliaia3(parts),migliaia4(block_offset),tohuman(block_offset));



		
	if (!i_quiet)
	{
		
#ifdef _WIN32
		if (flagstat)
		{
			vector<string> kollisioni;
			uint32_t fixati=casekollision(dt,kollisioni,flagfixcase);
			casecollision=kollisioni.size();
			if (casecollision>0)
			{
				printf("Case collisions        %9s (try -fixcase)\n",migliaia(casecollision));
				if (flagverbose)
					for (unsigned int i=0;i<kollisioni.size();i++)
					{
						printf("     collision  <<");
						printUTF8(kollisioni[i].c_str());
						printf(">>\n");
					}
			}
			if (flagfixcase)
				if (fixati>0)
					printf("-fixcase fixed         %9s files\n",migliaia(fixati));
			kollisioni.clear();	
		}
#endif

		if (toolongfilenames)
		{
#ifdef _WIN32	
			if (!flaglongpath)
				if (!flagtest)
					if (!flagvss)
						printf("Long filenames (>255)  %9s *** WARNING *** (suggest -longpath or -fix255 or -flat)\n",migliaia(toolongfilenames));
#else
			if (!flagtest)
			printf("Long filenames (>255)  %9s\n",migliaia(toolongfilenames));
#endif
		}
		if (utf8names)
			printf("Non-latin (UTF-8)      %9s\n",migliaia(utf8names));
	
		if (adsfilenames)
			printf("ADS ($:DATA)           %9s\n",migliaia(adsfilenames));

		if (windowspath)
			printf("Windows path           %9s\n",migliaia(windowspath));

		if (windowsunc)
			printf("Windows UNC            %9s\n",migliaia(windowsunc));

		if (reservedfilenames)
		{
#ifdef _WIN32
			printf("Reserved WIN filenames %9s *** WARNING *** (suggested -fixreserved or -flat) \n",migliaia(reservedfilenames));
#else
			printf("Reserved filenames     %9s\n",migliaia(reservedfilenames));
#endif
		}
	}
  // Calculate file sizes
	for (DTMap::iterator p=dt.begin(); p!=dt.end(); ++p) 
		for (unsigned i=0; i<p->second.ptr.size(); ++i) 
		{
			unsigned j=p->second.ptr[i];
			if (j>0 && j<ht.size() && p->second.size>=0) 
			{
				if (ht[j].usize>=0) 
					p->second.size+=ht[j].usize;
				else 
					p->second.size=-1;  // unknown size
			}
		}
  
	return block_offset;
}

// Test whether filename and attributes are selected by files, -only, and -not
// If rn then test renamed filename.
// if i_size >0 check file size too (minsize,maxsize)

bool Jidac::isselected(const char* filename, bool rn,int64_t i_size) 
{
	if (g_optional=="dirsize")
		return true; //dirsize, take ALL the stuff, for pos() filtering
	if (g_optional=="zfsadd")
		return true; // skip all this stuff, take everything
	
	bool matched=true;
	
	if (!flagforcezfs)
		if (flagskipzfs) //this is an "automagically" exclude for zfs' snapshots
			if (iszfs(filename))
			{
				if (flagverbose)
					printf("Verbose: Skip .zfs %s\n",filename);
				return false;
			}

	if (flagnoqnap) //this is an "automagically" exclude for qnap's snapshots
		if (
			(strstr(filename, "@Recently-Snapshot")) 
			||
			(strstr(filename, "@Recycle")) 
			)
			{
				if (flagverbose)
					printf("Verbose: Skip qnap %s\n",filename);
				return false;
			}
			
	if (!flagforcewindows) //this "automagically" exclude anything with System Volume Information
	{
		if (strstr(filename, "System Volume Information")) 
		{
			if (flagverbose)
				printf("Verbose: Skip System Volume Information %s\n",filename);
			return false;
		}
		if (strstr(filename, "$RECYCLE.BIN")) 
		{
			if (flagverbose)
				printf("Verbose: Skip trash %s\n",filename);
			return false;
		}
	}			

/// search for fake file (ASCII versions)

	if (isads(filename))
	{
		if (mypos("VCOMMENT ",filename)>-1)
			return true;
		if (mypos("VFILE-",filename)>-1)
			return true;
	}
		
	if  (!flagforcewindows)
		if (isads(filename))
			return false;
	
	if (i_size>0)
	{
		if (maxsize)
			if (maxsize<(uint64_t)i_size)
			{
				if (flagverbose)
					printf("Verbose: (-maxsize) too big   %19s %s\n",migliaia(i_size),filename);
				return false;
			}
		if (minsize)
			if (minsize>(uint64_t)i_size)
			{
				if (flagverbose)
					printf("Verbose: (-minsize) too small %19s %s\n",migliaia(i_size),filename);
				return false;
			}
	}
	
  if (files.size()>0) {
    matched=false;
    for (unsigned i=0; i<files.size() && !matched; ++i) {
      if (rn && i<tofiles.size()) {
        if (ispath(tofiles[i].c_str(), filename)) matched=true;
      }
      else if (ispath(files[i].c_str(), filename)) matched=true;
    }
  }
  
  if (!matched) return false;
  
  if (onlyfiles.size()>0) 
  {
	matched=false;
    for (unsigned i=0; i<onlyfiles.size() && !matched; ++i)
	{
		///printf("ZEKE:Testo %s su %s\n",onlyfiles[i].c_str(),filename);
	 if (ispath(onlyfiles[i].c_str(), filename))
	 {
        matched=true;
		///printf("MAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\n");
	 }
	}
  }
  
  if (!matched) return false;
  for (unsigned i=0; i<notfiles.size(); ++i) {
    if (ispath(notfiles[i].c_str(), filename))
      return false;
  }
  
  return true;
}

#ifdef _WIN32
string my_realpath(std::string const& i_path) 
{
	if (i_path=="")
			return "";
		
	char linkbuffer[66000]={0};
	size_t	linksize=66000;
	
    HANDLE h = CreateFileW(utow(i_path.c_str()).c_str(), 0, 0, NULL, OPEN_EXISTING, FILE_FLAG_OPEN_REPARSE_POINT, NULL);
    char buffer[MAXIMUM_REPARSE_DATA_BUFFER_SIZE];
    DWORD dwBytesReturned = 0;
    DeviceIoControl(h, FSCTL_GET_REPARSE_POINT, NULL, 0, buffer, sizeof(buffer), &dwBytesReturned, 0);
    typedef struct
    {
        ULONG ReparseTag;
        USHORT ReparseDataLength;
        USHORT Reserved;
        union
        {
            struct
            {
                USHORT SubstituteNameOffset;
                USHORT SubstituteNameLength;
                USHORT PrintNameOffset;
                USHORT PrintNameLength;
                ULONG Flags;
                WCHAR PathBuffer[1];
            } SymbolicLinkReparseBuffer;
            struct
            {
                USHORT SubstituteNameOffset;
                USHORT SubstituteNameLength;
                USHORT PrintNameOffset;
                USHORT PrintNameLength;
                WCHAR PathBuffer[1];
            } MountPointReparseBuffer;
            struct
            {
                UCHAR  DataBuffer[1];
            } GenericReparseBuffer;
        };
    } REPARSE_DATA_BUFFER;
    REPARSE_DATA_BUFFER* pRDB = reinterpret_cast<REPARSE_DATA_BUFFER*>(buffer);
    if (pRDB->ReparseTag == IO_REPARSE_TAG_SYMLINK)
    {
        int nameLength = pRDB->SymbolicLinkReparseBuffer.SubstituteNameLength / sizeof(wchar_t);
        wchar_t* pName = (wchar_t*)((char*)pRDB->SymbolicLinkReparseBuffer.PathBuffer + pRDB->SymbolicLinkReparseBuffer.SubstituteNameOffset);
        WideCharToMultiByte(CP_UTF8, 0, pName, nameLength, linkbuffer, linksize, NULL, NULL);
        return linkbuffer;
    }
    CloseHandle(h);
    return "";
}
#endif
/*
std::wstring GetLinkTarget(const char* i_link) 
{
    // Open file for querying only (no read/write access).
	
								 
	


	
	HANDLE h=CreateFileW(utow(i_link).c_str(), 
	0,                                 FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                                 nullptr, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, nullptr );
					
						   
	if (h==INVALID_HANDLE_VALUE)
	{
		printf("30334: failed createfile %s\n",i_link);
		return L"";
	}
    
	
    const size_t requiredSize = getFinalPathNameByHandleW( h, nullptr, 0,FILE_NAME_NORMALIZED );
    if ( requiredSize == 0 ) 
	{
		printf("30342: requiredsize==0\n");
		return L"";
	}
	printf("requireddd size %d\n",requiredSize);
	
	std::vector<wchar_t> buffer( requiredSize );
    getFinalPathNameByHandleW( h, buffer.data(),
                                 static_cast<DWORD>( buffer.size() ),
                                 FILE_NAME_NORMALIZED );

	CloseHandle(h);
    return std::wstring( buffer.begin(), buffer.end() - 1 );
}
*/
/*
	This is a kludge to get the filesize of a symlinked file on Windows,
	in a (more or less) "portable" (against compilators) way
*/
int64_t dim(string i_filename)
{
	///printf("k1\n");
    FILE* inFile = freadopen(i_filename.c_str());
	///printf("k2\n");
    if (inFile==NULL) 
		return 0;
	int64_t realsize=prendidimensionehandle(inFile);
	fclose(inFile);
	return realsize;
}		



#ifdef _WIN32
int64_t	getwinattributes(string i_filename)
{
	WIN32_FIND_DATA ffd;
    if ( (i_filename.size()>0) && (isdirectory(i_filename)))
		i_filename+="*";
	HANDLE h=FindFirstFile(utow(i_filename.c_str()).c_str(), &ffd);
	if (h!=INVALID_HANDLE_VALUE)
	{
		FindClose(h);
		return ffd.dwFileAttributes;
	}
	return 0;
}
/// reworked https://github.com/JFLarvoire/SysToolsLib/blob/master/C/MsvcLibX/src/readlink.c


typedef struct _REPARSE_READ_BUFFER 
{
	DWORD  ReparseTag;
	WORD   ReparseDataLength;
	WORD   Reserved;
	UCHAR  DataBuffer[1];
} REPARSE_READ_BUFFER, *PREPARSE_READ_BUFFER;

bool getreparsepointW(bool i_flagdebug,const string i_path, char *i_buf, size_t i_bufsize,size_t& o_byteletti,DWORD& o_tag,string& o_type) 
{
	o_byteletti	=0;
	o_tag		=0;
	o_type		="";
	printf("REPPAAA\n");
	return true;
	wstring wi_path=utow(i_path.c_str());
	
	PREPARSE_READ_BUFFER pIoctlBuf;

	DWORD attributi = GetFileAttributesW(wi_path.c_str());
	if (attributi==INVALID_FILE_ATTRIBUTES) 
	{
		printf("37390: failed GetFileAttributesW\n");
		return false;
	}

	if (!(attributi & FILE_ATTRIBUTE_REPARSE_POINT)) 
	{
		printf("37396: fake file is not a reparse point\n");
		return false;
	}

	DWORD flag=FILE_FLAG_OPEN_REPARSE_POINT;
	if (attributi & FILE_ATTRIBUTE_DIRECTORY) 
		flag|=FILE_FLAG_BACKUP_SEMANTICS;
	
	HANDLE h=CreateFileW(wi_path.c_str(),0,FILE_SHARE_READ | FILE_SHARE_WRITE,NULL,OPEN_EXISTING,flag,NULL);

	if (h==INVALID_HANDLE_VALUE) 
	{
		printf("37413: cannot createfile on reparse point\n");
		return false;
	}

	DWORD byteletti;
 	BOOL fattoio=DeviceIoControl(h,FSCTL_GET_REPARSE_POINT,NULL,0,i_buf,(DWORD)i_bufsize,&byteletti,NULL);
	CloseHandle(h);
	if (!fattoio) 
	{
		printf("37429: DeviceIoControl kaputt\n");
		return false;
	}

	if (byteletti<8) 
	{
		printf("37438: something wrong\n");
		return false;
	}
  
	pIoctlBuf 	= (PREPARSE_READ_BUFFER)i_buf;
	
	o_tag		=pIoctlBuf->ReparseTag;
	o_byteletti	=pIoctlBuf->ReparseDataLength;
	
    switch (o_tag) 
	{
		case 0x00000000: 	o_type="Reserved0"; break;	
		case 0x00000001: 	o_type="Reserved1"; break;
		case 0x00000002: 	o_type="Reserved2"; break;
		case 0xA0000003: 	o_type="Mount point or junction"; break;
		case 0xC0000004: 	o_type="Hierarchical Storage Manager"; break;
		case 0x80000005: 	o_type="Home server drive extender"; break;
		case 0x80000006: 	o_type="Hierarchical Storage Manager Product #2"; break;
		case 0x80000007: 	o_type="Single-instance storage filter driver"; break;
		case 0x80000008: 	o_type="Windows boot Image File"; break;
		case 0x80000009: 	o_type="Cluster Shared Volume"; break;
		case 0x8000000A: 	o_type="Distributed File System"; break;
		case 0x8000000B: 	o_type="Filter manager test harness"; break;
		case 0xA000000C: 	o_type="Symbolic link"; break;
		case 0xA0000010: 	o_type="Internet Information Services cache"; break;
		case 0x80000012: 	o_type="Distributed File System R filter"; break;
		case 0x80000013: 	o_type="Deduplicated file"; break;
		case 0x80000014: 	o_type="NFS symbolic link"; break;
		case 0xC0000014: 	o_type="APPXSTREAM (Not used?)"; break;
		case 0x80000015: 	o_type="Placeholder for a OneDrive file"; break;
		case 0x80000016: 	o_type="Dynamic File filter"; break;
		case 0x80000017: 	o_type="Windows Overlay Filesystem compressed file"; break;
		case 0x80000018: 	o_type="Windows Container Isolation filter"; break;
		case 0xA0000019: 	o_type="NPFS server silo named pipe symbolic link into the host silo"; break;
		case 0x9000001A: 	o_type="Cloud Files filter"; break;
		case 0x8000001B: 	o_type="Application Execution link"; break;
		case 0x9000001C: 	o_type="Projected File System VFS filter, ex for git"; break;
		case 0xA000001D: 	o_type="Linux Sub-System Symbolic Link"; break;
		case 0x8000001E: 	o_type="Azure File Sync (AFS) filter"; break;
		case 0xA000001F: 	o_type="Windows Container Isolation filter tombstone"; break;
		case 0xA0000020: 	o_type="Unhandled Windows Container Isolation filter"; break;
		case 0xA0000021: 	o_type="One Drive (Not used?)"; break;
		case 0xA0000022: 	o_type="Projected File System VFS filter tombstone, ex for git"; break;
		case 0xA0000023: 	o_type="Linux Sub-System Socket"; break;
		case 0xA0000024: 	o_type="Linux Sub-System FIFO"; break;
		case 0xA0000025: 	o_type="Linux Sub-System Character Device"; break;
		case 0xA0000026: 	o_type="Linux Sub-System Block Device"; break;
		case 0xA0000027: 	o_type="Windows Container Isolation filter Link"; break;
		default:			o_type="35701: Microsoft strikes back!"; break;
    }
	
	if (!i_flagdebug)
		return true;

    unsigned int ul;
    unsigned int u;
    unsigned int uMax;

	for (ul = 0; ul < (unsigned)(pIoctlBuf->ReparseDataLength); ul += 16) 
	{
		printf("%08X ", ul);

		uMax = (unsigned)(pIoctlBuf->ReparseDataLength) - ul;
		if (uMax > 16) 
			uMax = 16;

      /* Display the hex dump */
		for (u=0; u<16; u++) 
		{
			if (!(u&3)) 
				printf(" ");
			if (u < uMax) 
				printf("%2.2X ", ((unsigned char *)pIoctlBuf->DataBuffer)[ul + u]);
			else 
				printf("   ");
		}

      /* Display the ASCII characters dump */
		for (u=0; u<16; u++) 
		{
			char c = ((char *)pIoctlBuf->DataBuffer)[ul + u];
			if (!(u&7)) 
				printf(" ");
			if (c < ' ') 
				c = ' ';
			if ((unsigned char)c > '\x7F') 
				c = ' ';
			printf("%c", c);
		}

		printf("\n");
    }
	return true;
}
#endif


// Insert external filename (UTF-8 with "/") into dt if selected
// by files, onlyfiles, and notfiles. If filename
// is a directory then also insert its contents.
// In Windows, filename might have wildcards like "file.*" or "dir/*"
// In zpaqfranz, sometimes, we DO not want to recurse
void Jidac::scandir(bool i_checkifselected,DTMap& i_edt,string filename, bool i_recursive)
{

  // Don't scan diretories excluded by -not
  for (unsigned i=0; i<notfiles.size(); ++i)
    if (ispath(notfiles[i].c_str(), filename.c_str()))
      return;

	if (!flagforcezfs)
		if (flagskipzfs)
			if (iszfs(filename))
			{
				if (flagverbose)
					printf("Verbose: Skip .zfs ----> %s\n",filename.c_str());
				return;
			}
	if (flagnoqnap)
	{
		if (filename.find("@Recently-Snapshot")!=std::string::npos)
		{
			if (flagverbose)
				printf("Verbose: Skip qnap snapshot ----> %s\n",filename.c_str());

			return;
		}
		if (filename.find("@Recycle")!=std::string::npos)
		{
			if (flagverbose)
				printf("Verbose: Skip qnap recycle ----> %s\n",filename.c_str());
			return;
		}
	}
	
#ifdef unix
// Add regular files and directories
	while (filename.size()>1 && filename[filename.size()-1]=='/')
		filename=filename.substr(0, filename.size()-1);  // remove trailing /
	
	struct stat sb;
	if (!lstat(filename.c_str(), &sb)) 
	{
		if (S_ISREG(sb.st_mode))
			addfile(i_checkifselected,i_edt,filename, decimal_time(sb.st_mtime), sb.st_size,'u'+(sb.st_mode<<8));

    // Traverse directory
		if (S_ISDIR(sb.st_mode)) 
		{
			addfile(i_checkifselected,i_edt,filename=="/" ? "/" : filename+"/", decimal_time(sb.st_mtime),0, 'u'+(int64_t(sb.st_mode)<<8));
			DIR* dirp=opendir(filename.c_str());
			if (dirp) 
			{
				for (dirent* dp=readdir(dirp); dp; dp=readdir(dirp)) 
				{
					if (strcmp(".", dp->d_name) && strcmp("..", dp->d_name)) 
					{
						string s=filename;
						if (s!="/") s+="/";
						s+=dp->d_name;
						if (i_recursive)        
							scandir(i_checkifselected,i_edt,s);
						else
						{
							if (!lstat(s.c_str(), &sb)) 
							{
								if (S_ISREG(sb.st_mode))
									addfile(i_checkifselected,i_edt,s, decimal_time(sb.st_mtime), sb.st_size,'u'+(sb.st_mode<<8));
								if (S_ISDIR(sb.st_mode)) 
									addfile(i_checkifselected,i_edt,s=="/" ? "/" :s+"/", decimal_time(sb.st_mtime),0, 'u'+(int64_t(sb.st_mode)<<8));
							}
						}          			
					}
				}
				closedir(dirp);
			}
			else
				perror(filename.c_str());
		}
	}
	else
		perror(filename.c_str());

#else  // Windows: expand wildcards in filename
	
  // Expand wildcards
  WIN32_FIND_DATA ffd;
  string t=filename;
  
  if (t.size()>0 && t[t.size()-1]=='/') t+="*";
  HANDLE h=FindFirstFile(utow(t.c_str()).c_str(), &ffd);
  if (h==INVALID_HANDLE_VALUE
      && GetLastError()!=ERROR_FILE_NOT_FOUND
      && GetLastError()!=ERROR_PATH_NOT_FOUND)
    printerr("15367",t.c_str(),0);
	while (h!=INVALID_HANDLE_VALUE) 
	{

		// For each file, get name, date, size, attributes
		SYSTEMTIME st;
		int64_t edate=0;
		if (FileTimeToSystemTime(&ffd.ftLastWriteTime, &st))
			edate=st.wYear*10000000000LL+st.wMonth*100000000LL+st.wDay*1000000
				+st.wHour*10000+st.wMinute*100+st.wSecond;
		int64_t esize=ffd.nFileSizeLow+(int64_t(ffd.nFileSizeHigh)<<32);
		const int64_t eattr='w'+(int64_t(ffd.dwFileAttributes)<<8);
	
		// Ignore links, the names "." and ".." or any unselected file
		t=wtou(ffd.cFileName);
	
		/// Ok this is rather weird, but is Microsoft afterall
		/// a SYMLINK in a VSS can become rather tricky
		/// this should (?) get the "real" name of a SYMLINK
		/// Microsoft documentations sucks big time
		///string solonome=extractfilename(t);
		if ((ffd.dwFileAttributes & FILE_ATTRIBUTE_REPARSE_POINT) && !(ffd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
		{
			string miofilename=path(filename)+t;
			string nuovonome=my_realpath(miofilename);
			if (nuovonome!="")
			{
				int64_t newsize=dim(nuovonome);
				esize=newsize;
			}
			string percorso="";
		
			size_t destra= nuovonome.rfind(t);
			if (destra!=std::string::npos)
				percorso=myleft(nuovonome,destra)+"*";
			if (percorso!="")
				filename=percorso;
	}
	
/*
	dir /al /s c:\programdata
NOT_CONTENT_INDEXED
archive;NOT_CONTENT_INDEXED;REPARSE_POINT

*/

	if (flagdebug) // sometimes Windows get very strange attributes
	{
		string myfn=path(filename)+t;
		printf("FATTR %08X RES0 %08X ",(unsigned int)ffd.dwFileAttributes,(unsigned int)ffd.dwReserved0);
		printUTF8(myfn.c_str());
		printf("\n");
		string temp=decodewinattribute(ffd.dwFileAttributes);
		printf("%s\n",temp.c_str());
	}

   	if (t=="." || t=="..") 
		edate=0;  // don't add, of course
	
	/*
		OK, now test Windows crazy fake files
	*/
	
	if ((ffd.dwFileAttributes & FILE_ATTRIBUTE_REPARSE_POINT) && (ffd.dwReserved0==IO_REPARSE_TAG_SYMLINK))
	{
		int64_t newsize=dim(filename);
		if (flagdebug)
			printf("29300: maybe Windows-symlinked file, fake size %s real size %s %s\n",migliaia(esize),migliaia(newsize),filename.c_str());
		esize=newsize;
	}
		
	if (ffd.dwFileAttributes & FILE_ATTRIBUTE_REPARSE_POINT)
	{
	/*
		REPARSE_POINTS are a nightmare
		For now: just skip
		char buffer[100000];
		int bufsize=100000;
	
		size_t 	byteletti;
		DWORD 	tag;
		string	tipo;
		string thefile=path(filename)+t;

		if (flagverbose)
			printf("30908: try to get reparse point %s\n",thefile.c_str());
		if (getreparsepointW(false,thefile,buffer,bufsize,byteletti,tag,tipo))
		{
			if (flagverbose)
			{
				printf("30911: Reparse <<%s>>\n",thefile.c_str());
				printf("30912: TAG %08X LEN %11s |%s|\n",tag,migliaia(byteletti),tipo.c_str());
			}
		}
		else
		{
			if (flagverbose)
				printf("31072: fallito getreparsepointW %s\n",thefile.c_str());
		}
		*/
	}
	
	if ((ffd.dwFileAttributes & FILE_ATTRIBUTE_REPARSE_POINT) && (!(ffd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)))
	{
		/// Houston, we have a strange deduplicated .vhdx file?
		/// add as by default
		if (flagdebug)
			printf("Verbose: found something strange (VHDX?) %s\n",t.c_str());
	}
	else
	{
		///	A junction?
		if ((ffd.dwFileAttributes & FILE_ATTRIBUTE_REPARSE_POINT) && (ffd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
		{
			if (flagdebug)
				printf("30908: discard REPARSE POINT & DIRECTORY\n");
			edate=0;  // don't add
		}
	}
    
	string fn=path(filename)+t;

    // Save directory names with a trailing / and scan their contents
    // Otherwise, save plain files
    if (edate) 
	{
		if (ffd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) fn+="/";
		addfile(i_checkifselected,i_edt,fn, edate, esize, eattr);
		
		if (i_recursive)
		{
			if (ffd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) 
			{
				fn+="*";
				scandir(i_checkifselected,i_edt,fn);
			}
      // enumerate alternate streams (Win2003/Vista or later)
      else 
	  if (findFirstStreamW && findNextStreamW) 
	  {
		if (flagforcewindows)
		{
			WIN32_FIND_STREAM_DATA fsd;
			HANDLE ah=findFirstStreamW(utow(fn.c_str()).c_str(),
				FindStreamInfoStandard, &fsd, 0);
			while (ah!=INVALID_HANDLE_VALUE && findNextStreamW(ah, &fsd))
				addfile(i_checkifselected,i_edt,fn+wtou(fsd.cStreamName), edate,
              fsd.StreamSize.QuadPart, eattr);
			if (ah!=INVALID_HANDLE_VALUE) FindClose(ah);
		}
      }
	  }
    }
    if (!FindNextFile(h, &ffd)) {
      if (GetLastError()!=ERROR_NO_MORE_FILES) printerr("15417",(fn+fn).c_str(),ffd.dwFileAttributes);
      break;
    }
  }
  FindClose(h);
#endif
}

	
	
// Add external file and its date, size, and attributes to dt
void Jidac::addfile(bool i_checkifselected,DTMap& i_edt,string filename, int64_t edate,
                    int64_t esize, int64_t eattr) 
{

	if (i_checkifselected)
		if (!isselected(filename.c_str(), false,esize)) 
			return;
	
	//	OK, let's handle longpath on VSS by a kludge
	//	cook some spaghetti code!
	if (command=='q')
		if (filename.size()>250)
			myreplace(filename,"c:/franzsnap",g_vss_shadow);

	DT& d=i_edt[filename];
	d.date=edate;
	d.size=esize;
	d.attr=flagnoattributes?0:eattr;
	d.data=0;
	g_bytescanned+=esize;
	g_filescanned++;

	if (flagnoeta==false)
		if (!(i_edt.size() % 1000))
		{
			double scantime=mtime()-g_start+1;
			printf("Scanning %10s %2.2fs %10s file/s (%21s)\r",migliaia(i_edt.size()),scantime/1000.0,migliaia3((int)(i_edt.size()/(scantime/1000.0))),migliaia2(g_bytescanned));
			fflush(stdout);
		}
}

//////////////////////////////// add //////////////////////////////////

// Append n bytes of x to sb in LSB order
inline void puti(libzpaq::StringBuffer& sb, uint64_t x, int n) {
  for (; n>0; --n) sb.put(x&255), x>>=8;
}


// A CompressJob is a queue of blocks to compress and write to the archive.
// Each block cycles through states EMPTY, FILLING, FULL, COMPRESSING,
// COMPRESSED, WRITING. The main thread waits for EMPTY buffers and
// fills them. A set of compressThreads waits for FULL threads and compresses
// them. A writeThread waits for COMPRESSED buffers at the front
// of the queue and writes and removes them.

// Buffer queue element
struct CJ {
  enum {EMPTY, FULL, COMPRESSING, COMPRESSED, WRITING} state;
  StringBuffer in;       // uncompressed input
  StringBuffer out;      // compressed output
  string filename;       // to write in filename field
  string comment;        // if "" use default
  string method;         // compression level or "" to mark end of data
  Semaphore full;        // 1 if in is FULL of data ready to compress
  Semaphore compressed;  // 1 if out contains COMPRESSED data
  CJ(): state(EMPTY) {}
};

// Instructions to a compression job
class CompressJob {
public:
  Mutex mutex;           // protects state changes
private:
  int job;               // number of jobs
  CJ* q;                 // buffer queue
  unsigned qsize;        // number of elements in q
  int front;             // next to remove from queue
  libzpaq::Writer* out;  // archive
  Semaphore empty;       // number of empty buffers ready to fill
  Semaphore compressors; // number of compressors available to run
public:
  friend ThreadReturn compressThread(void* arg);
  friend ThreadReturn writeThread(void* arg);
  CompressJob(int threads, int buffers, libzpaq::Writer* f):
      job(0), q(0), qsize(buffers), front(0), out(f) {
    q=new CJ[buffers];
    if (!q) throw std::bad_alloc();
    init_mutex(mutex);
    empty.init(buffers);
    compressors.init(threads);
    for (int i=0; i<buffers; ++i) {
      q[i].full.init(0);
      q[i].compressed.init(0);
    }
  }
  ~CompressJob() {
    for (int i=qsize-1; i>=0; --i) {
      q[i].compressed.destroy();
      q[i].full.destroy();
    }
    compressors.destroy();
    empty.destroy();
    destroy_mutex(mutex);
    delete[] q;
  }      
  void write(StringBuffer& s, const char* filename, string method,
             const char* comment=0);
  vector<int> csize;  // compressed block sizes
};

// Write s at the back of the queue. Signal end of input with method=""
void CompressJob::write(StringBuffer& s, const char* fn, string method,
                        const char* comment) {
  for (unsigned k=(method=="")?qsize:1; k>0; --k) {
    empty.wait();
    lock(mutex);
    unsigned i, j;
    for (i=0; i<qsize; ++i) {
      if (q[j=(i+front)%qsize].state==CJ::EMPTY) {
        q[j].filename=fn?fn:"";
        q[j].comment=comment?comment:"jDC\x01";
        q[j].method=method;
        q[j].in.resize(0);
        q[j].in.swap(s);
        q[j].state=CJ::FULL;
        q[j].full.signal();
        break;
      }
    }
    release(mutex);
    assert(i<qsize);  // queue should not be full
  }
}

// Compress data in the background, one per buffer
ThreadReturn compressThread(void* arg) {
  CompressJob& job=*(CompressJob*)arg;
  int jobNumber=0;
  try {

    // Get job number = assigned position in queue
    lock(job.mutex);
    jobNumber=job.job++;
    assert(jobNumber>=0 && jobNumber<int(job.qsize));
    CJ& cj=job.q[jobNumber];
    release(job.mutex);

    // Work until done
    while (true) {
      cj.full.wait();
      lock(job.mutex);

      // Check for end of input
      if (cj.method=="") {
        cj.compressed.signal();
        release(job.mutex);
        return 0;
      }

      // Compress
      assert(cj.state==CJ::FULL);
      cj.state=CJ::COMPRESSING;
      release(job.mutex);
      job.compressors.wait();
	       libzpaq::compressBlock(&cj.in, &cj.out, cj.method.c_str(),
          cj.filename.c_str(), cj.comment=="" ? 0 : cj.comment.c_str());
      cj.in.resize(0);
      lock(job.mutex);

	///	printf("\nFarei qualcosa <<%s>> %08X size %ld\n",myblock.filename.c_str(),myblock.crc32,myblock.crc32size);

	  cj.state=CJ::COMPRESSED;
      cj.compressed.signal();
      job.compressors.signal();
      release(job.mutex);
    }
  }
  catch (std::exception& e) {
    lock(job.mutex);
    fflush(stdout);
    fprintf(stderr, "job %d: %s\n", jobNumber+1, e.what());
	g_exec_text="job error";
    release(job.mutex);
    exit(1);
  }
  return 0;
}

// Write compressed data to the archive in the background
ThreadReturn writeThread(void* arg) {
  CompressJob& job=*(CompressJob*)arg;
  try {

    // work until done
    while (true) {

      // wait for something to write
      CJ& cj=job.q[job.front];  // no other threads move front
      cj.compressed.wait();

      // Quit if end of input
      lock(job.mutex);
      if (cj.method=="") {
        release(job.mutex);
        return 0;
      }

      // Write to archive
      assert(cj.state==CJ::COMPRESSED);
      cj.state=CJ::WRITING;
      job.csize.push_back(cj.out.size());
      if (job.out && cj.out.size()>0) {
        release(job.mutex);
        assert(cj.out.c_str());
        const char* p=cj.out.c_str();
        int64_t n=cj.out.size();
        
		g_scritti+=n; // very rude
		const int64_t N=1<<30;
        while (n>N) {
          job.out->write(p, N);
          p+=N;
          n-=N;
        }
        job.out->write(p, n);
        lock(job.mutex);
      }
      cj.out.resize(0);
      cj.state=CJ::EMPTY;
      job.front=(job.front+1)%job.qsize;
      job.empty.signal();
      release(job.mutex);
    }
  }
  catch (std::exception& e) {
    fflush(stdout);
    fprintf(stderr, "zpaqfranz exiting from writeThread: %s\n", e.what());
	g_exec_text="exiting from writethread";
    exit(1);
  }
  return 0;
}

// Write a ZPAQ compressed JIDAC block header. Output size should not
// depend on input data.
void writeJidacHeader(libzpaq::Writer *out, int64_t date,
                      int64_t cdata, unsigned htsize) {
  if (!out) return;
  assert(date>=19000000000000LL && date<30000000000000LL);
  StringBuffer is;
  puti(is, cdata, 8);
  libzpaq::compressBlock(&is, out, "0",
      ("jDC"+itos(date, 14)+"c"+itos(htsize, 10)).c_str(), "jDC\x01");
}

// Maps sha1 -> fragment ID in ht with known size
class HTIndex {
  vector<HT>& htr;  // reference to ht
  libzpaq::Array<unsigned> t;  // sha1 prefix -> index into ht
  unsigned htsize;  // number of IDs in t

  // Compuate a hash index for sha1[20]
  unsigned hash(const char* sha1) {
    return (*(const unsigned*)sha1)&(t.size()-1);
  }

public:
  // r = ht, sz = estimated number of fragments needed
  HTIndex(vector<HT>& r, size_t sz): htr(r), t(0), htsize(1) {
    int b;
    for (b=1; sz*3>>b; ++b);
    t.resize(1, b-1);
    update();
  }

  // Find sha1 in ht. Return its index or 0 if not found.
  unsigned find(const char* sha1) {
    unsigned h=hash(sha1);
    for (unsigned i=0; i<t.size(); ++i) {
      if (t[h^i]==0) return 0;
      if (memcmp(sha1, htr[t[h^i]].sha1, 20)==0) return t[h^i];
    }
    return 0;
  }

  // Update index of ht. Do not index if fragment size is unknown.
  void update() {
    char zero[20]={0};
    while (htsize<htr.size()) {
      if (htsize>=t.size()/4*3) {
        t.resize(t.size(), 1);
        htsize=1;
      }
      if (htr[htsize].usize>=0 && memcmp(htr[htsize].sha1, zero, 20)!=0) {
        unsigned h=hash((const char*)htr[htsize].sha1);
        for (unsigned i=0; i<t.size(); ++i) {
          if (t[h^i]==0) {
            t[h^i]=htsize;
            break;
          }
        }
      }
      ++htsize;
    }
  }    
};


// For writing to two archives at once
struct WriterPair: public libzpaq::Writer {
  OutputArchive *a, *b;
  void put(int c) {
    if (a) a->put(c);
    if (b) b->put(c);
  }
  void write(const char* buf, int n) {
    if (a) a->write(buf, n);
    if (b) b->write(buf, n);
  }
  WriterPair(): a(0), b(0) {}
};





void Jidac::write715attr(libzpaq::StringBuffer& i_sb, uint64_t i_data, unsigned int i_quanti)
{
	assert(i_sb);
	assert(i_quanti<=8);
	puti(i_sb, i_quanti, 4);
	puti(i_sb, i_data, i_quanti);
}


void Jidac::writefranzattr(libzpaq::StringBuffer& i_sb, uint64_t i_data, unsigned int i_quanti,string i_filename,uint32_t i_crc32fromfragments,uint32_t i_crc32,string i_thehash)
{

	assert(i_sb);
	assert(i_filename.length()>0); 	// I do not like empty()
	assert(i_quanti<8);				//just to be sure at least 1 zero pad, so < and not <=
	assert(i_filename!="");

	uint32_t writtencrc;
	if (flagverify)
		writtencrc=i_crc32fromfragments;
	else
		writtencrc=i_crc32;
		
	if (g_franzotype==FRANZO_NONE)	// 7.15
	{
		write715attr(i_sb,i_data,i_quanti);
		return;
	}

	if (flagverify)
		if (i_crc32!=i_crc32fromfragments)
		{
			printf("\nGURU-C: on file %s\n",i_filename.c_str());
			printf("GURU: CRC-32 from fragments %08X\n",i_crc32fromfragments);
			printf("GURU: CRC-32 from file      %08X\n",i_crc32);
//			if (!flagdebug)
	///			error("Guru-C checking crc32");
		}

	if (g_franzotype==FRANZO_CRC_32) /// store only CRC-32
	{
		char mybuffer[FRANZOFFSET]={0};
		sprintf(mybuffer+41,"%08X",writtencrc);
		puti(i_sb, 8+FRANZOFFSET, 4); 	// 8+FRANZOFFSET block
		puti(i_sb, i_data, i_quanti);
		puti(i_sb, 0, (8 - i_quanti));  // pad with zeros (for 7.15 little bug)
		i_sb.write(mybuffer,FRANZOFFSET);
		if (flagdebug)
			printf("Mode1: CRC32 by frag <<%s>> %s\n",mybuffer+41,i_filename.c_str());
	}
	else
	if (g_franzotype==FRANZO_XXHASH64) ///2= 52 (XXHASH64-0-CRC32)
	{
		assert(i_thehash.length()==32);
		char mybuffer[FRANZOFFSET]={0};
		sprintf(mybuffer+8,	"%s",i_thehash.c_str());
		sprintf(mybuffer+41,"%08X",writtencrc);
		puti(i_sb, 8+FRANZOFFSET, 4); 	// 8+FRANZOFFSET block
		puti(i_sb, i_data, i_quanti);
		puti(i_sb, 0, (8 - i_quanti));  // pad with zeros (for 7.15 little bug)
		i_sb.write(mybuffer,FRANZOFFSET);
		/// please note the dirty trick: start by +10
		if (flagdebug)
				printf("Mode2: XXHASH64: <<%s>> CRC32 <<%s>> %s\n",mybuffer+8,mybuffer+41,i_filename.c_str());
	}
	else
	if (g_franzotype==FRANZO_SHA_1)  //3= 51 (SHA1-0-CRC32)
	{
		
		//printf("Scrivo CRC32  <<%08X>>\n",writtencrc);
		
///		assert(i_thehash.length()==64);
		char mybuffer[FRANZOFFSETSHA256]={0};
		sprintf(mybuffer,	"08"); //<<< look at this
		sprintf(mybuffer+2,	"%s",i_thehash.c_str());
		sprintf(mybuffer+2+64+1,"%08X",writtencrc);
		puti(i_sb, 8+FRANZOFFSETSHA256, 4); 	// 8+FRANZOFFSET block
		puti(i_sb, i_data, i_quanti);
		puti(i_sb, 0, (8 - i_quanti));  // pad with zeros (for 7.15 little bug)
		i_sb.write(mybuffer,FRANZOFFSETSHA256); ///please note the dirty trick: start by +8		
		if (flagdebug)
				printf("Model8: SHA1 <<%s>> CRC32 <<%s>> %s\n",mybuffer+2,mybuffer+67,i_filename.c_str());

	}
	else
	if (g_franzotype==FRANZO_SHA_256) ///4= 52 (01-SHA256-0-CRC32)
	{
		assert(i_thehash.length()==64);
		char mybuffer[FRANZOFFSETSHA256]={0};
		sprintf(mybuffer,	"04"); //<<< look at this
		sprintf(mybuffer+2,	"%s",i_thehash.c_str());
		sprintf(mybuffer+2+64+1,"%08X",writtencrc);
		puti(i_sb, 8+FRANZOFFSETSHA256, 4); 	// 8+FRANZOFFSET block
		puti(i_sb, i_data, i_quanti);
		puti(i_sb, 0, (8 - i_quanti));  // pad with zeros (for 7.15 little bug)
		i_sb.write(mybuffer,FRANZOFFSETSHA256);
		/// please note the dirty trick: start by +8
		if (flagdebug)
				printf("Mode4: SHA256 <<%s>> CRC32 <<%s>> %s\n",mybuffer+2,mybuffer+67,i_filename.c_str());
	}
	else
	if (g_franzotype==FRANZO_SHA3) ///2= 52 (01-SHA3-0-CRC32)
	{
		assert(i_thehash.length()==64);
		char mybuffer[FRANZOFFSETSHA256]={0};
		sprintf(mybuffer,	"02"); //<<< look at this
		sprintf(mybuffer+2,	"%s",i_thehash.c_str());
		sprintf(mybuffer+2+64+1,"%08X",writtencrc);
		puti(i_sb, 8+FRANZOFFSETSHA256, 4); 	// 8+FRANZOFFSET block
		puti(i_sb, i_data, i_quanti);
		puti(i_sb, 0, (8 - i_quanti));  // pad with zeros (for 7.15 little bug)
		i_sb.write(mybuffer,FRANZOFFSETSHA256); ///please note the dirty trick: start by +8		
		if (flagdebug)
				printf("Mode7: SHA3 <<%s>> CRC32 <<%s>> %s\n",mybuffer+2,mybuffer+67,i_filename.c_str());
	}
	else
	if (g_franzotype==FRANZO_MD5) ///1= 52 (01-MD5-0-CRC32)
	{
		assert(i_thehash.length()==32);
		char mybuffer[FRANZOFFSETSHA256]={0};
		sprintf(mybuffer,	"01"); //<<< look at this
		sprintf(mybuffer+2,	"%s",i_thehash.c_str());
		sprintf(mybuffer+2+64+1,"%08X",writtencrc);
		puti(i_sb, 8+FRANZOFFSETSHA256, 4); 	// 8+FRANZOFFSET block
		puti(i_sb, i_data, i_quanti);
		puti(i_sb, 0, (8 - i_quanti));  // pad with zeros (for 7.15 little bug)
		i_sb.write(mybuffer,FRANZOFFSETSHA256); ///please note the dirty trick: start by +8		
		if (flagdebug)
				printf("Mode8: MD5 <<%s>> CRC32 <<%s>> %s\n",mybuffer+2,mybuffer+67,i_filename.c_str());
	}
	else
	if (g_franzotype==FRANZO_BLAKE3) ///3= 52 (01-BLAKE3-0-CRC32)
	{
		assert(i_thehash.length()==64);
		char mybuffer[FRANZOFFSETSHA256]={0};
		sprintf(mybuffer,	"03"); //<<< look at this
		sprintf(mybuffer+2,	"%s",i_thehash.c_str());
		sprintf(mybuffer+2+64+1,"%08X",writtencrc);
		puti(i_sb, 8+FRANZOFFSETSHA256, 4); 	// 8+FRANZOFFSET block
		puti(i_sb, i_data, i_quanti);
		puti(i_sb, 0, (8 - i_quanti));  // pad with zeros (for 7.15 little bug)
		i_sb.write(mybuffer,FRANZOFFSETSHA256); ///please note the dirty trick: start by +8		
		if (flagdebug)
				printf("Mode6: BLAKE3 <<%s>> CRC32 <<%s>> %s\n",mybuffer+2,mybuffer+67,i_filename.c_str());
	}
	else
	if (g_franzotype==FRANZO_XXH3) ///5= 52 (00XXH3-0-CRC32)
	{	
		assert(i_thehash.length()==32);
		char mybuffer[FRANZOFFSETSHA256]={0};
		sprintf(mybuffer,	"09"); //<<< look at this
		sprintf(mybuffer+2,	"%s",i_thehash.c_str());
		sprintf(mybuffer+2+64+1,"%08X",writtencrc);
		puti(i_sb, 8+FRANZOFFSETSHA256, 4); 	// 8+FRANZOFFSET block
		puti(i_sb, i_data, i_quanti);
		puti(i_sb, 0, (8 - i_quanti));  // pad with zeros (for 7.15 little bug)
		i_sb.write(mybuffer,FRANZOFFSETSHA256); ///please note the dirty trick: start by +8		
		/// please note the dirty trick: start by +8
		if (flagdebug)
				printf("Mode5: XXH3: <<%s>> CRC32 <<%s>> %s\n",mybuffer+2,mybuffer+67,i_filename.c_str());
				///printf("Mode5: XXH3: <<%s>> CRC32 <<%s>> %s\n",mybuffer+10,mybuffer+41,i_filename.c_str());
	}
	else
		perror("22144: unknown franzotype");
}

/////////////////////////////// extract ///////////////////////////////

// Return true if the internal file p
// and external file contents are equal or neither exists.
// If filename is 0 then return true if it is possible to compare.
// In the meantime calc the crc32 of the entire file

bool Jidac::equal(DTMap::const_iterator p, const char* filename,uint32_t &o_crc32,string i_myhashtype,string i_myhash,string& o_hash) 
{
	o_crc32=0;
	o_hash="";
	if (i_myhash=="FAKE")
		o_hash="FAKE";
  // test if all fragment sizes and hashes exist
	if (filename==0) 
	{
		static const char zero[20]={0};
		for (unsigned i=0; i<p->second.ptr.size(); ++i) 
		{
			unsigned j=p->second.ptr[i];
			if (j<1 || j>=ht.size() || ht[j].usize<0 || !memcmp(ht[j].sha1, zero, 20))
				return false;
		}
		return true;
	}

  // internal or neither file exists
	if (p->second.date==0) 
		return !exists(filename);

  // directories always match
	if (p->first!="" && isdirectory(p->first))
		return exists(filename);

  // compare sizes
	FP in=fopen(filename, RB);
	if (in==FPNULL) 
		return false;
	fseeko(in, 0, SEEK_END);
	if (ftello(in)!=p->second.size) 
		return fclose(in), false;


  // compare hashes chunk by chunk.
	fseeko(in, 0, SEEK_SET);
	libzpaq::SHA1 sha1;
	const int BUFSIZE=4096;
	char buf[BUFSIZE];

	bool	flagshow=false;
	if (!flagnoeta)
		if (flagverbose || (p->second.size>100000000)) //only 100MB+ files
			flagshow=true;
			
	if (flagshow)
		printf("\n");

	int64_t 	done				=0;
	int 		ultimapercentuale	=-1;

	uint64_t myseed = 0;
	XXHash64 myhash(myseed);
	SHA3 sha3;
	MD5 md5;
	blake3_hasher hasher;
	blake3_hasher_init(&hasher);
	franzSHA256 mysha256;
	XXH3_state_t state128;
    (void)XXH3_128bits_reset(&state128);
	libzpaq::SHA1 mysha1;
	
	int64_t timestart=mtime();
	for (unsigned i=0; i<p->second.ptr.size(); ++i) 
	{
		unsigned f=p->second.ptr[i];
		if (f<1 || f>=ht.size() || ht[f].usize<0) 
			return fclose(in), false;
    
		double percentuale=0;
		if (flagshow)
		{
			percentuale=100.0*((double)i/(double)p->second.ptr.size());
			int proper=percentuale;
			if (percentuale>0)
				if (proper!=ultimapercentuale)
				{
					if (proper==99)
							proper=100;
					double tempo=(mtime()-timestart+1)/1000.0;
					int myspeed=done/tempo;
					printf("SHA1 %03d %% (%12s) @ %12s/s\r",proper,tohuman(done),tohuman2(myspeed));
					ultimapercentuale=percentuale;
				}
		}

			
		for (int j=0; j<ht[f].usize;) 
		{
			int n=ht[f].usize-j;
			
			if (n>BUFSIZE) 
				n=BUFSIZE;
			
			int r=fread(buf, 1, n, in);
			o_crc32=crc32_16bytes(buf,r,o_crc32);
			done+=r;
			g_worked+=r;
			
			if (flagchecksum)
			{
				if (i_myhashtype=="XXHASH64")
					myhash.add(buf,r);

				if (i_myhashtype=="SHA-3")
					sha3.add(buf,r);
			
				if (i_myhashtype=="MD5")
					md5.add(buf,r);
			
				if (i_myhashtype=="BLAKE3")
					blake3_hasher_update(&hasher,buf,r);
		
				if (i_myhashtype=="SHA-256")
					mysha256.update((const uint8_t*)buf,r);
			
				if (i_myhashtype=="XXH3")
					(void)XXH3_128bits_update(&state128,buf,r);
				
				if (i_myhashtype=="SHA-1")
					mysha1.write(buf,r);
			}
		
			if (r!=n) 
			{
				return fclose(in), false;
			}
			sha1.write(buf, n);
			j+=n;
		}
		
		
		if (memcmp(sha1.result(), ht[f].sha1, 20)!=0) 
		{	
			return fclose(in), false;
		}
		
	
	}
	//if (flagshow)
		//printf("\n");
				
	if (fread(buf, 1, BUFSIZE, in)!=0) 
		return fclose(in), false;
	fclose(in);
	

	if (flagchecksum)
	{
		if (i_myhashtype=="XXHASH64")
		{
			char temp[33];
			sprintf(temp,"%016llX",(unsigned long long)myhash.hash());
			o_hash=temp;
		}
		else
		if (i_myhashtype=="SHA-3")
			o_hash= sha3.getHash();
		else
		if (i_myhashtype=="MD5")
			o_hash=md5.getHash();
		else
		if (i_myhashtype=="BLAKE3")
		{
			uint8_t output[BLAKE3_OUT_LEN];
			blake3_hasher_finalize(&hasher, output, BLAKE3_OUT_LEN);
			o_hash=binarytohex((const unsigned char*)output,BLAKE3_OUT_LEN);	
		}
		else
		if (i_myhashtype=="SHA-256")
			o_hash=mysha256.gethex();
		else
		if (i_myhashtype=="XXH3")
		{
			XXH128_hash_t myhash=XXH3_128bits_digest(&state128);
			char buf[33];
			sprintf(buf,"%016llX%016llX",(unsigned long long)myhash.high64,(unsigned long long)myhash.low64);
			o_hash=buf;
		}
		else
		if (i_myhashtype=="SHA-1")
		{
			char sha1result[20];
			memcpy(sha1result, mysha1.result(), 20);
			o_hash=binarytohex((const unsigned char*)sha1result,20);
		}
		else
			printf("\n29573: WARNING unknown hasher algo %s\n",i_myhashtype.c_str());
		
	}
	
	return true;
}

// An extract job is a set of blocks with at least one file pointing to them.
// Blocks are extracted in separate threads, set READY -> WORKING.
// A block is extracted to memory up to the last fragment that has a file
// pointing to it. Then the checksums are verified. Then for each file
// pointing to the block, each of the fragments that it points to within
// the block are written in order.

struct ExtractJob {         // list of jobs
	int	chunk;
  Mutex mutex;              // protects state
  Mutex write_mutex;        // protects writing to disk
  int job;                  // number of jobs started
  Jidac& jd;                // what to extract
  FP outf;                  // currently open output file
  DTMap::iterator lastdt;   // currently open output file name
  double maxMemory;         // largest memory used by any block (test mode)
  int64_t total_size;       // bytes to extract
  int64_t total_done;       // bytes extracted so far
  ExtractJob(Jidac& j): chunk(0),job(0), jd(j), outf(FPNULL), lastdt(j.dt.end()),
      maxMemory(0), total_size(0), total_done(0) {
    init_mutex(mutex);
    init_mutex(write_mutex);
  }
  ~ExtractJob() {
    destroy_mutex(mutex);
    destroy_mutex(write_mutex);
  }
};




// Decompress blocks in a job until none are READY
ThreadReturn decompressThread(void* arg) {
  ExtractJob& job=*(ExtractJob*)arg;
  int jobNumber=0;
	char	byte0={0};
  // Get job number
  lock(job.mutex);
  jobNumber=++job.job;
  release(job.mutex);

  ///printf("K1 %s\n",job.jd.archive.c_str());
  // Open archive for reading
  InputArchive in(job.jd.archive.c_str(), job.jd.password);
  if (!in.isopen()) return 0;
  StringBuffer out;

  // Look for next READY job.
  int next=0;  // current job
  while (true) {
    lock(job.mutex);
    for (unsigned i=0; i<=job.jd.block.size(); ++i) {
      unsigned k=i+next;
      if (k>=job.jd.block.size()) k-=job.jd.block.size();
      if (i==job.jd.block.size()) {  // no more jobs?
        release(job.mutex);
        return 0;
      }
      Block& b=job.jd.block[k];
      if (b.state==Block::READY && b.size>0 && b.usize>=0) {
        b.state=Block::WORKING;
        release(job.mutex);
        next=k;
        break;
      }
    }
    Block& b=job.jd.block[next];

    // Get uncompressed size of block
    unsigned output_size=0;  // minimum size to decompress
    assert(b.start>0);
    for (unsigned j=0; j<b.size; ++j) {
      assert(b.start+j<job.jd.ht.size());
      assert(job.jd.ht[b.start+j].usize>=0);
      output_size+=job.jd.ht[b.start+j].usize;
    }

    // Decompress
    double mem=0;  // how much memory used to decompress
    try {
      assert(b.start>0);
      assert(b.start<job.jd.ht.size());
      assert(b.size>0);
      assert(b.start+b.size<=job.jd.ht.size());
	  ///printf("Andiamo su offset  %lld  %lld\n",b.offset,output_size);
      in.seek(b.offset, SEEK_SET);
      libzpaq::Decompresser d;
      d.setInput(&in);
      out.resize(0);
      assert(b.usize>=0);
      assert(b.usize<=0xffffffffu);
      out.setLimit(b.usize);
      d.setOutput(&out);
      if (!d.findBlock(&mem)) error("archive block not found");
      if (mem>job.maxMemory) job.maxMemory=mem;
      while (d.findFilename()) {
        d.readComment();
        while (out.size()<output_size && d.decompress(1<<14))
		{
		//		printf("|");
		};
        lock(job.mutex);
///		printf("\n");
	///		printf("out size %lld\n",out.size());
	//	printf(".........................................................\n");
    ///	printf("---------------- %s  %s\n",migliaia(job.total_size),migliaia2(job.total_done));
		print_progress(job.total_size, job.total_done,-1,-1);
        /*
		if (job.jd.summary<=0)
          printf("[%d..%d] -> %1.0f\n", b.start, b.start+b.size-1,
              out.size()+0.0);
      */
	  
	  release(job.mutex);
        if (out.size()>=output_size) break;
        d.readSegmentEnd();
      }
      if (out.size()<output_size) {
        lock(job.mutex);
        fflush(stdout);
        fprintf(stderr, "output [%u..%u] %d of %u bytes\n",
             b.start, b.start+b.size-1, int(out.size()), output_size);
        release(job.mutex);
        error("unexpected end of compressed data");
      }

      // Verify fragment checksums if present
      uint64_t q=0;  // fragment start
      libzpaq::SHA1 sha1;
      assert(b.extracted==0);
      for (unsigned j=b.start; j<b.start+b.size; ++j) {
        assert(j>0 && j<job.jd.ht.size());
        assert(job.jd.ht[j].usize>=0);
        assert(job.jd.ht[j].usize<=0x7fffffff);
        if (q+job.jd.ht[j].usize>out.size())
          error("Incomplete decompression");
        char sha1result[20];
        sha1.write(out.c_str()+q, job.jd.ht[j].usize);
        memcpy(sha1result, sha1.result(), 20);
        q+=job.jd.ht[j].usize;
        if (memcmp(sha1result, job.jd.ht[j].sha1, 20)) {
          lock(job.mutex);
          fflush(stdout);
          fprintf(stderr, "Job %d: fragment %u size %d checksum failed\n",
                 jobNumber, j, job.jd.ht[j].usize);
		g_exec_text="fragment checksum failed";
          release(job.mutex);
          error("bad checksum");
        }
        ++b.extracted;
      }
    }

    // If out of memory, let another thread try
    catch (std::bad_alloc& e) {
      lock(job.mutex);
      fflush(stdout);
      fprintf(stderr, "Job %d killed: %s\n", jobNumber, e.what());
	  g_exec_text="Job killed";
      b.state=Block::READY;
      b.extracted=0;
      out.resize(0);
      release(job.mutex);
      return 0;
    }

    // Other errors: assume bad input
    catch (std::exception& e) {
      lock(job.mutex);
      fflush(stdout);
      fprintf(stderr, "Job %d: skipping [%u..%u] at %1.0f: %s\n",
              jobNumber, b.start+b.extracted, b.start+b.size-1,
              b.offset+0.0, e.what());
      release(job.mutex);
      continue;
    }

    // Write the files in dt that point to this block
    lock(job.write_mutex);
    for (unsigned ip=0; ip<b.files.size(); ++ip) {
      DTMap::iterator p=b.files[ip];
      if (p->second.date==0 || p->second.data<0
          || p->second.data>=int64_t(p->second.ptr.size()))
        continue;  // don't write
		
      // Look for pointers to this block
      const vector<unsigned>& ptr=p->second.ptr;
      int64_t offset=0;  // write offset
      for (unsigned j=0; j<ptr.size(); ++j) {
        if (ptr[j]<b.start || ptr[j]>=b.start+b.extracted) {
          offset+=job.jd.ht[ptr[j]].usize;
          continue;
        }

        // Close last opened file if different
        if (p!=job.lastdt) {
          if (job.outf!=FPNULL) {
            assert(job.lastdt!=job.jd.dt.end());
            assert(job.lastdt->second.date);
            assert(job.lastdt->second.data
                   <int64_t(job.lastdt->second.ptr.size()));
            fclose(job.outf);
            job.outf=FPNULL;
          }
          job.lastdt=job.jd.dt.end();
        }

		string filename;
        // Open file for output
        if (job.lastdt==job.jd.dt.end()) 
		{
			filename=job.jd.rename(p->first);

			if (flagramdisk)
				if (!isdirectory(filename))
					if (p->second.pramfile==NULL)
					{
						p->second.pramfile=new franzfs;
						(*p->second.pramfile).init(p->second.size);
					}

			assert(job.outf==FPNULL);
			if (p->second.data==0) 
			{
				if (!job.jd.flagtest) 
				{
					if (flagdebug)
					{
						printf("17544: MAKEPATH:");
						printUTF8(filename.c_str());
						printf("\n");
					}
					makepath(filename);
				}
				lock(job.mutex);
				print_progress(job.total_size, job.total_done,-1,-1);
				release(job.mutex);
            
				if (!job.jd.flagtest) 
				{
					
/// sometimes (in Windows) the path is not made (ex. path too long)
/// let's try to make (is just a fix). Please note utw

#ifdef _WIN32
					string percorso=extractfilepath(filename);
					if (percorso!="")
					{
						if (!flaglongpath)
						myreplaceall(percorso,"/","\\");
						if (!direxists(percorso))
						{
							if (flagdebug)
								printf("17577: ERROR DIRNOTEX %s\n",percorso.c_str());
						
							string temppercorso=percorso;
							size_t barra;
							string percorsino;
				
							while (1==1)
							{
								barra=temppercorso.find('\\');
								if (barra==string::npos)
									break;
								percorsino+=temppercorso.substr(0, barra)+'\\';
								if (direxists(percorsino))
								{
									if (flagdebug)
										printf("17583: Small path exists %s\n",percorsino.c_str());
								}
								else
								{
									string dafare=percorsino;
									///dafare.pop_back();
									if (flagdebug)
										printf("\n\n17950: Make path of %03d\n---\n%s\n---\n",(int)dafare.length(),dafare.c_str());
									bool creazione=CreateDirectory(utow(dafare.c_str()).c_str(), 0);
									if (!flaglongpath)
									if (!creazione)
										printerr("17519",dafare.c_str(),0);
								}
								temppercorso=temppercorso.substr(barra+1,temppercorso.length());
							}
						}
						if (!flaglongpath)
						if (!direxists(percorso))
						{
							printf("17620: percorso does not exists <<%s>>\n",percorso.c_str());
				///exit(0);
						}
					}
#endif				

		///		filename=nomefileseesistegia(filename);
				/*
				if (fileexists(filename))
				{
						printf("KKKKKKKKKKKKKKOOOOOOOOOOOOOOOOOOOOOOOOOOOOO %s\n",filename.c_str());
						printf("Dim %08d\n\n",prendidimensionefile(filename.c_str()));
						
				}
				*/
				job.outf=fopen(filename.c_str(), WB);
				if (job.outf==FPNULL) 
				{
					lock(job.mutex);
					printerr("17451",filename.c_str(),0);
					release(job.mutex);
				}
#ifndef unix
              else if ((p->second.attr&0x200ff)==0x20000+'w') {  // sparse?
                DWORD br=0;
                if (!DeviceIoControl(job.outf, FSCTL_SET_SPARSE,
                    NULL, 0, NULL, 0, &br, NULL))  // set sparse attribute
                  printerr("17459",filename.c_str(),0);
              }
#endif
            }
          }
          else if (!job.jd.flagtest)
		  {
		///	printf("Scriverei su %s\n",filename.c_str());
			job.outf=fopen(filename.c_str(), RBPLUS);  // update existing file
          }
		  if (!job.jd.flagtest && job.outf==FPNULL) break;  // skip errors
          job.lastdt=p;
          assert(job.jd.flagtest || job.outf!=FPNULL);
        }
        assert(job.lastdt==p);

        // Find block offset of fragment
        uint64_t q=0;  // fragment offset from start of block
        for (unsigned k=b.start; k<ptr[j]; ++k) {
          assert(k>0);
          assert(k<job.jd.ht.size());
          if (job.jd.ht[k].usize<0) error("streaming fragment in file");
          assert(job.jd.ht[k].usize>=0);
          q+=job.jd.ht[k].usize;
        }
        assert(q+job.jd.ht[ptr[j]].usize<=out.size());

        // Combine consecutive fragments into a single write
        assert(offset>=0);
        ++p->second.data;
        uint64_t usize=job.jd.ht[ptr[j]].usize;
        assert(usize<=0x7fffffff);
        assert(b.start+b.size<=job.jd.ht.size());
        while (j+1<ptr.size() && ptr[j+1]==ptr[j]+1
               && ptr[j+1]<b.start+b.size
               && job.jd.ht[ptr[j+1]].usize>=0
               && usize+job.jd.ht[ptr[j+1]].usize<=0x7fffffff) {
          ++p->second.data;
          assert(p->second.data<=int64_t(ptr.size()));
          assert(job.jd.ht[ptr[j+1]].usize>=0);
          usize+=job.jd.ht[ptr[++j]].usize;
        }
        assert(usize<=0x7fffffff);
        assert(q+usize<=out.size());

        // Write the merged fragment unless they are all zeros and it
        // does not include the last fragment.
        uint64_t nz=q;  // first nonzero byte in fragments to be written
        while (nz<q+usize && out.c_str()[nz]==0) ++nz;
		
		
        if ((nz<q+usize || j+1==ptr.size())) 

			//if (stristr(job.lastdt->first.c_str(),"Globals.pas"))
			//if (stristr(job.lastdt->first.c_str(),"globals.pas"))
			{

/// let's calc the CRC32 of the block, and store (keyed by filename)
/// in comments debug code
				if (offset>g_scritti)
					g_scritti=offset;
					
				uint32_t crc;
				crc=crc32_16bytes(out.c_str()+q, usize);
	
				s_crc32block myblock;
				myblock.crc32=crc;
				myblock.crc32start=offset;
				myblock.crc32size=usize;
				myblock.filename=job.lastdt->first;
///				myblock.xxh3="";
				g_crc32.push_back(myblock);
				/*
				char mynomefile[100];
				sprintf(mynomefile,"z:\\globals_%014lld_%014lld_%08X",offset,offset+usize,crc);
				///printf("Outfile %s %lld Seek to %08lld   size %08lld crc %08lld %s\n",mynomefile,job.outf,offset,usize,crc,job.lastdt->first.c_str());

				FILE* myfile=fopen(mynomefile, "wb");
				fwrite(out.c_str()+q, 1, usize, myfile);
				
				fclose(myfile);
				*/
			}


		if (job.jd.flagtest && (nz<q+usize || j+1==ptr.size())) 
			if (flagramdisk)
					if (!isdirectory(filename))
						if (p->second.pramfile!=NULL)
							(*p->second.pramfile).ramwrite(offset,(char*)out.c_str()+q,usize);
			
		if (!job.jd.flagtest && (nz<q+usize || j+1==ptr.size())) 
		{
/// with -zero do not write
			if (flagzero)
			{
/// -zero -debug: write all zeros in output
				if (flagdebug)
				{
					///seek to the end and write a 0
					fseeko(job.outf, offset+usize, SEEK_SET);
					fwrite(&byte0, 1, 1, job.outf);
				}
			}
			else
			{				
				if (flagdebug)
					printf("17716:OFFSET-WRITE   %19s  size  %12s %s\n",migliaia(offset),migliaia2(usize),job.lastdt->first.c_str());
				
				if (flagramdisk)
				{
					/// do a "ramdisk" write
					if (!isdirectory(filename))
						if (p->second.pramfile!=NULL)
							(*p->second.pramfile).ramwrite(offset,(char*)out.c_str()+q,usize);
				}
				else
				{	// write on realfilesystem
					fseeko(job.outf, offset, SEEK_SET);
					fwrite(out.c_str()+q, 1, usize, job.outf);
				}
			}
		}	

        offset+=usize;
        lock(job.mutex);
        job.total_done+=usize;
        release(job.mutex);
		///printf("Scrittoni %f\n",(double)job.total_done);
		
        // Close file. If this is the last fragment then set date and attr.
        // Do not set read-only attribute in Windows yet.
        if (p->second.data==int64_t(ptr.size())) {
          assert(p->second.date);
          assert(job.lastdt!=job.jd.dt.end());
          assert(job.jd.flagtest || job.outf!=FPNULL);
          if (!job.jd.flagtest) {
            assert(job.outf!=FPNULL);
            string fn=job.jd.rename(p->first);
            int64_t attr=p->second.attr;
            int64_t date=p->second.date;
            if ((p->second.attr&0x1ff)=='w'+256) attr=0;  // read-only?
            if (p->second.data!=int64_t(p->second.ptr.size()))
              date=attr=0;  // not last frag
            close(fn.c_str(), date, attr, job.outf);
            job.outf=FPNULL;
          }
          job.lastdt=job.jd.dt.end();
        }
      } // end for j
    } // end for ip

    // Last file
    release(job.write_mutex);
  } // end while true

  
	
  // Last block
  return 0;
}



ThreadReturn decompressthreadramdisk(void* arg) 
{
	ExtractJob& job=*(ExtractJob*)arg;
	int jobNumber=0;
  // Get job number
	lock(job.mutex);
	jobNumber=++job.job;
	release(job.mutex);

	InputArchive in(job.jd.archive.c_str(), job.jd.password);
	if (!in.isopen()) 
		return 0;
	StringBuffer out;

  // Look for next READY job.
	int next=0;  // current job
	while (true) 
	{
		lock(job.mutex);
		for (unsigned i=0; i<=job.jd.block.size(); ++i) 
		{
			unsigned k=i+next;
			if (k>=job.jd.block.size()) 
				k-=job.jd.block.size();
			if (i==job.jd.block.size()) 
			{  // no more jobs?
				release(job.mutex);
				return 0;
			}
			Block& b=job.jd.block[k];
			if (b.state==Block::READY && b.size>0 && b.usize>=0) 
			{
				b.state=Block::WORKING;
				release(job.mutex);
				next=k;
				break;
			}
		}
		Block& b=job.jd.block[next];

    // Get uncompressed size of block
		unsigned output_size=0;  // minimum size to decompress
		assert(b.start>0);
		for (unsigned j=0; j<b.size; ++j) 
		{
			assert(b.start+j<job.jd.ht.size());
			assert(job.jd.ht[b.start+j].usize>=0);
			output_size+=job.jd.ht[b.start+j].usize;
		}

    // Decompress
    double mem=0;  // how much memory used to decompress
	try 
	{
		assert(b.start>0);
		assert(b.start<job.jd.ht.size());
		assert(b.size>0);
		assert(b.start+b.size<=job.jd.ht.size());
		
		in.seek(b.offset, SEEK_SET);
		libzpaq::Decompresser d;
		d.setInput(&in);
		out.resize(0);
		assert(b.usize>=0);
		assert(b.usize<=0xffffffffu);
		out.setLimit(b.usize);
		d.setOutput(&out);
		if (!d.findBlock(&mem)) 
			error("31284 archive block not found");
		if (mem>job.maxMemory) 
			job.maxMemory=mem;
		while (d.findFilename()) 
		{
			d.readComment();
        	while (out.size()<output_size && d.decompress(1<<14))
				;
		
			lock(job.mutex);
			print_progress(job.total_size, job.total_done,-1,-1);
			release(job.mutex);
			if (out.size()>=output_size) 
				break;
			d.readSegmentEnd();
		}
		if (out.size()<output_size)
		{
			lock(job.mutex);
			fflush(stdout);
			fprintf(stderr, "31836 output [%u..%u] %d of %u bytes\n",b.start, b.start+b.size-1, int(out.size()), output_size);
			release(job.mutex);
			error("31838 unexpected end of compressed data");
		}

      // Verify fragment checksums if present
		uint64_t q=0;  // fragment start
		libzpaq::SHA1 sha1;
		assert(b.extracted==0);
		for (unsigned j=b.start; j<b.start+b.size; ++j) 
		{
			assert(j>0 && j<job.jd.ht.size());
			assert(job.jd.ht[j].usize>=0);
			assert(job.jd.ht[j].usize<=0x7fffffff);
			if (q+job.jd.ht[j].usize>out.size())
				error("31318 Incomplete decompression");
			
			if (flagchecksum)
			{
				char sha1result[20];
				sha1.write(out.c_str()+q, job.jd.ht[j].usize);
				memcpy(sha1result, sha1.result(), 20);
				q+=job.jd.ht[j].usize;
			
				if (memcmp(sha1result, job.jd.ht[j].sha1, 20)) 
				{
					lock(job.mutex);
					fflush(stdout);
					fprintf(stderr, "31327 Job %d: fragment %u size %d checksum failed\n",jobNumber, j, job.jd.ht[j].usize);
					g_exec_text="31327 fragment checksum failed";
					release(job.mutex);
					error("31330 bad checksum");
				}
			}
			else
				q+=job.jd.ht[j].usize;
			
			++b.extracted;
		}
    }

    // If out of memory, let another thread try
    catch (std::bad_alloc& e) 
	{
		lock(job.mutex);
		fflush(stdout);
		fprintf(stderr, "31341 Job %d killed: %s\n", jobNumber, e.what());
		g_exec_text="31341 Job killed";
		b.state=Block::READY;
		b.extracted=0;
		out.resize(0);
		release(job.mutex);
		return 0;
    }

    // Other errors: assume bad input
    catch (std::exception& e) 
	{
		lock(job.mutex);
		fflush(stdout);
		fprintf(stderr, "31355 Job %d: skipping [%u..%u] at %1.0f: %s\n",jobNumber, b.start+b.extracted, b.start+b.size-1,b.offset+0.0, e.what());
		release(job.mutex);
		continue;
    }

    // Write the files in dt that point to this block
    lock(job.write_mutex);
    for (unsigned ip=0; ip<b.files.size(); ++ip) 
	{
		DTMap::iterator p=b.files[ip];
		if (p->second.date==0 || p->second.data<0
          || p->second.data>=int64_t(p->second.ptr.size()))
        continue;  // don't write
		
      // Look for pointers to this block
		const vector<unsigned>& ptr=p->second.ptr;
		int64_t offset=0;  // write offset
		for (unsigned j=0; j<ptr.size(); ++j) 
		{
			if (ptr[j]<b.start || ptr[j]>=b.start+b.extracted) 
			{
				offset+=job.jd.ht[ptr[j]].usize;
				continue;
			}

			// Close last opened file if different
			if (p!=job.lastdt) 
				job.lastdt=job.jd.dt.end();

			if (job.lastdt==job.jd.dt.end()) 
			{
				if (!isdirectory(job.jd.rename(p->first)))
					if (p->second.pramfile==NULL)
					{
						p->second.pramfile=new franzfs;
						(*p->second.pramfile).init(p->second.size);
					}
					
				if (p->second.pramfile==NULL)
					error("31399 cannot init ramdisk");

				if (p->second.data==0) 
				{
					lock(job.mutex);
					print_progress(job.total_size, job.total_done,-1,-1);
					release(job.mutex);
				}
				
				job.lastdt=p;
			}
			assert(job.lastdt==p);

			// Find block offset of fragment
			uint64_t q=0;  // fragment offset from start of block
			for (unsigned k=b.start; k<ptr[j]; ++k) 
			{
				assert(k>0);
				assert(k<job.jd.ht.size());
				if (job.jd.ht[k].usize<0) 
					error("31420 streaming fragment in file");
				assert(job.jd.ht[k].usize>=0);
				q+=job.jd.ht[k].usize;
			}
			assert(q+job.jd.ht[ptr[j]].usize<=out.size());

			// Combine consecutive fragments into a single write
			assert(offset>=0);
			++p->second.data;
			uint64_t usize=job.jd.ht[ptr[j]].usize;
			assert(usize<=0x7fffffff);
			assert(b.start+b.size<=job.jd.ht.size());
			while (j+1<ptr.size() && ptr[j+1]==ptr[j]+1
				   && ptr[j+1]<b.start+b.size
				   && job.jd.ht[ptr[j+1]].usize>=0
				   && usize+job.jd.ht[ptr[j+1]].usize<=0x7fffffff) 
			{
				++p->second.data;
				assert(p->second.data<=int64_t(ptr.size()));
				assert(job.jd.ht[ptr[j+1]].usize>=0);
				usize+=job.jd.ht[ptr[++j]].usize;
			}
			assert(usize<=0x7fffffff);
			assert(q+usize<=out.size());

			// Write the merged fragment unless they are all zeros and it
			// does not include the last fragment.
			uint64_t nz=q;  // first nonzero byte in fragments to be written
			while (nz<q+usize && out.c_str()[nz]==0) ++nz;
			
			
			if ((nz<q+usize || j+1==ptr.size())) 
			{
				if (offset>g_scritti)
					g_scritti=offset;
				
				if (!(flagzero && flagdebug))		//-zero -debug =>write an all zeroed-file
					if (p->second.pramfile!=NULL)
						(*p->second.pramfile).ramwrite(offset,(char*)out.c_str()+q,usize);
			}
			offset+=usize;
			lock(job.mutex);
			job.total_done+=usize;
			release(job.mutex);
			if (p->second.data==int64_t(ptr.size())) 
			{
				assert(job.lastdt!=job.jd.dt.end());
				job.lastdt=job.jd.dt.end();
			}
		} // end for j
	} // end for ip

    // Last file
    release(job.write_mutex);
  } // end while true

  // Last block
  return 0;
}



// Streaming output destination
struct OutputFile: public libzpaq::Writer {
  FP f;
  void put(int c) {
    char ch=c;
    if (f!=FPNULL) fwrite(&ch, 1, 1, f);
  }
  void write(const char* buf, int n) {if (f!=FPNULL) fwrite(buf, 1, n, f);}
  OutputFile(FP out=FPNULL): f(out) {}
};
int64_t copywitheta(int64_t i_tobecopied,libzpaq::Reader& in, libzpaq::Writer& out, uint64_t n=~0ull) 
{
  const unsigned BUFSIZE=4096;
  int64_t result=0;
  char buf[BUFSIZE];
  int64_t	inizio=mtime();
  while (n>0) 
  {
    int nc=n>BUFSIZE ? BUFSIZE : n;
    int nr=in.read(buf, nc);
    if (nr<1) break;
		out.write(buf, nr);
    result+=nr;
	avanzamento(result,i_tobecopied,inizio);
    n-=nr;
  }
  return result;
}

// Copy at most n bytes from in to out (default all). Return how many copied.
int64_t copy(libzpaq::Reader& in, libzpaq::Writer& out, uint64_t n=~0ull) 
{
  const unsigned BUFSIZE=4096;
  int64_t result=0;
  char buf[BUFSIZE];
  while (n>0) 
  {
    int nc=n>BUFSIZE ? BUFSIZE : n;
    int nr=in.read(buf, nc);
    if (nr<1) break;
		out.write(buf, nr);
    result+=nr;
	 n-=nr;
  }
  return result;
}



uint32_t crchex2int(const char *hex) 
{
	assert(hex);
	uint32_t val = 0;
	for (int i=0;i<8;i++)
	{
        uint8_t byte = *hex++; 
        if (byte >= '0' && byte <= '9') byte = byte - '0';
        else if (byte >= 'a' && byte <='f') byte = byte - 'a' + 10;
        else if (byte >= 'A' && byte <='F') byte = byte - 'A' + 10;    
        val = (val << 4) | (byte & 0xF);
    }
    return val;
}

void Jidac::printsanitizeflags()
{
		printf("\n");
		printf("******\n");
		if (flagflat)
			printf("****** WARNING: all files FLATted, without non-latin chars, max %d length\n",(int)FRANZMAXPATH);
		else
		{
			if (flagutf)
				printf("****** -utf    No Non-latin chars\n");
			if (flagfix255)
				printf("****** -fix255 Shrink filenames to %d, case insensitive\n",(int)FRANZMAXPATH);
			if (flagfixeml)
				printf("****** -fixeml Heuristic compress .eml filenames (Fwd Fwd Fwd=>Fwd etc)\n");
#ifdef _WIN32
			if (flagfixreserved)
				printf("****** -fixreserved (fix LPT1 etc)\n");
			if (flagfixcase)
				printf("****** -fixcase (fix pippo.txt and PIPPO.txt)\n");
#endif
		}
		printf("******\n\n");
}



int Jidac::testverify() 
{
	getpasswordifempty();

	if (files.size()<=0)
		return -1;
	if (archive=="")
		return -1;
		
	printf("Compare archive content of:");


	read_archive(archive.c_str());

  // Read external files into edt
	uint64_t howmanyfiles=0;
	
	g_bytescanned=0;
	g_filescanned=0;
	g_worked=0;
	files_count.clear();
	
	edt.clear();
	for (unsigned i=0; i<files.size(); ++i)
	{
		scandir(true,edt,files[i].c_str());
		files_count.push_back(edt.size()-howmanyfiles);
		howmanyfiles=edt.size();
	}
	printf("\n");
 	for (unsigned i=0; i<files.size(); ++i)
		if (isdirectory(files[i]))
			printf("%9s in <<%s>>\n",migliaia(files_count[i]),files[i].c_str());
	
	
	if (files.size()) 
		printf("Total files found: %s\n", migliaia(edt.size()));
	printf("\n");

  // Compute directory sizes as the sum of their contents
	DTMap* dp[2]={&dt, &edt};
	for (int i=0; i<2; ++i) 
		for (DTMap::iterator p=dp[i]->begin(); p!=dp[i]->end(); ++p) 
		{
			int len=p->first.size();
			if (len>0 && p->first[len]!='/') 
				for (int j=0; j<len; ++j) 
					if (p->first[j]=='/') 
					{
						DTMap::iterator q=dp[i]->find(p->first.substr(0, j+1));
						if (q!=dp[i]->end())
							q->second.size+=p->second.size;
					}
		}

	vector<DTMap::iterator> filelist;
	for (DTMap::iterator p=edt.begin(); p!=edt.end(); ++p) 
	{
		DTMap::iterator a=dt.find(rename(p->first));
		if (a!=dt.end() && (all || a->second.date)) 
		{
			a->second.data='-';
			filelist.push_back(a);
		}
		p->second.data='+';
		filelist.push_back(p);
	}
	
	for (DTMap::iterator a=dt.begin(); a!=dt.end(); ++a) 
		if (a->second.data!='-' && (all || a->second.date)) 
		{
			a->second.data='-';
			filelist.push_back(a);
		}
	
	int64_t usize=0;
	unsigned matches=0, mismatches=0, internal=0, external=0,hashmatches=0;
	uint32_t crc32fromfile;
	int64_t	hashchecked=0;
	int64_t	tobetested=0;
	
	vector<string> risultati;
	vector<bool> risultati_utf8;
	char linebuffer[1000];
	unsigned int ultimapercentuale=200;
	unsigned int percentuale;
	
	for (unsigned fi=0;fi<filelist.size(); ++fi) 
	{
		DTMap::iterator p=filelist[fi];
		
		if (menoenne)
			if ((mismatches+external+internal)>menoenne)
				break;
		
		if (!flagnoeta)
		{
			percentuale=100*fi/filelist.size();
			if (ultimapercentuale!=percentuale)
			{
				printf("Done %02d%% %10s of %10s, diff %s bytes so far\r",percentuale,tohuman(g_worked),tohuman2(g_bytescanned),migliaia2(usize));
				ultimapercentuale=percentuale;
			}
		}
		
    // Compare external files
		if (p->second.data=='-' && fi+1<filelist.size() && filelist[fi+1]->second.data=='+') 
		{
			DTMap::iterator p1=filelist[fi+1];
	
			string myhashtype="";
			string myhash="";
			string mycrc32="";
			string hashfromfile="";
			
			if (!isdirectory(p1->first))
			{
					decode_franz_block(false,p->second.franz_block,
					myhashtype,
					myhash,
					mycrc32);
					tobetested+=p->second.size;
			}
/*
			if (myhashtype!="")
				printf("30133:  %s\n",myhashtype.c_str());
	*/		
	
			if (equal(p, p1->first.c_str(),crc32fromfile,myhashtype,myhash,hashfromfile)) //crc32 of second parameters
			{
				if (!isdirectory(p1->first))
				{
					if (hashfromfile!="")
					{
						if (flagdebug)
							printf("Check hash for %s\n",p->first.c_str());
						hashchecked+=p->second.size;
			
						if (hashfromfile!=myhash)
						{
							
							p->second.data='#';
							sprintf(linebuffer,"\nHASH %s NOT MATCH STORED %s vs FROM FILE %s ",myhashtype.c_str(),myhash.c_str(),hashfromfile.c_str());
							risultati.push_back(linebuffer);
							risultati_utf8.push_back(false);
							
							sprintf(linebuffer,"%s\n",p1->first.c_str());
							risultati.push_back(linebuffer);
							risultati_utf8.push_back(true);
						}
						else
						{	
							hashmatches++;
							p->second.data='=';
							++fi;
						}
		
					}
					else
					if (mycrc32!="")
					{
						if (flagdebug)
							printf("Check CRC-32 for %s\n",p->first.c_str());
						
						uint32_t crc32stored=crchex2int(mycrc32.c_str());
						if (crc32stored!=crc32fromfile)
						{
							p->second.data='#';
							sprintf(linebuffer,"\nCRC-32 NOT MATCH STORED %s vs FROM FILE %08X ",mycrc32.c_str(),crc32fromfile);
							risultati.push_back(linebuffer);
							risultati_utf8.push_back(false);
							
							sprintf(linebuffer,"%s\n",p1->first.c_str());
							risultati.push_back(linebuffer);
							risultati_utf8.push_back(true);
						}
						else
						{	
						/// if very, do a full hash verify!
							p->second.data='=';
							++fi;
						}
					}
					else
					{
						if (flagdebug)
							printf("No zpaqfranz check for %s\n",p->first.c_str());
						
						/// crc-32 is not stored in the archive, cannot tell anything
						p->second.data='=';
						++fi;
					}
					
				}	
				else
				{
					/// directory always match
					p->second.data='=';
					++fi;
				}
			}
			else
			{
				p->second.data='#';
				p1->second.data='!';
			}
		}


		if (p->second.data=='=') ++matches;
		if (p->second.data=='#') ++mismatches;
		if (p->second.data=='-') ++internal;
		if (p->second.data=='+') ++external;

		if (p->second.data!='=') 
		{
			if (!isdirectory(p->first))
				usize+=p->second.size;
				
			sprintf(linebuffer,"%c %s %19s ", char(p->second.data),dateToString(p->second.date).c_str(), migliaia(p->second.size));
			risultati.push_back(linebuffer);
			risultati_utf8.push_back(false);
			
			
			sprintf(linebuffer,"%s\n",p->first.c_str());
			risultati.push_back(linebuffer);
			risultati_utf8.push_back(true);
	  
			if (p->second.data=='!')
			{
				sprintf(linebuffer,"\n");
				risultati.push_back(linebuffer);
				risultati_utf8.push_back(false);
			}
		}
	}  
	printf("\n\n");

	bool myerror=false;
	
	if (menoenne)
		if ((mismatches+external+internal)>menoenne)
			printf("**** STOPPED BY TOO MANY ERRORS -n %d\n",menoenne);
			
	if  (mismatches || external || internal)
		for (unsigned int i=0;i<risultati.size();i++)
		{
			if (risultati_utf8[i])
				printUTF8(risultati[i].c_str());
			else
			printf("%s",risultati[i].c_str());
		}

	if (matches)
		printf("%08d = same\n",matches);
	
	if (hashmatches)
	{
		printf("%08d ==very same (hash checked) %19s\n",hashmatches,migliaia(hashchecked));
		printf("               to be tested by hash %19s\n",migliaia(tobetested));
		if (hashchecked!=tobetested)
		{
			printf("****** WARN: something strange hash checking    *******\n");
			printf("******       some file(s) stored without hash?  *******\n");
			printf("******       hash does not match?               *******\n");
		}
	}
	if (mismatches)
	{
		printf("%08d #different\n",mismatches);
		myerror=true;
	}
	if (external)
	{
		printf("%08d +external (file missing in ZPAQ)\n",external);
		myerror=true;
	}
	if (internal)
	{
		printf("%08d -internal (file in ZPAQ but not on disk)\n",internal);
		myerror=true;
	}
	printf("Total different file size: %s bytes\n",migliaia(usize));
 	if (myerror)
		return 2;
	else
		return 0;
}

int Jidac::info() 
{
	flagcomment=true;
	versioncomment="";
	all=4;
	return enumeratecomments();
}


int Jidac::zpaqdirsize() 
{
	if (archive=="")
	{
		printf("31002: empty archive name\n");
		return 2;
	}
	
	if (files.size()==0)
	{
		printf("30969: at least one folder needed\n");
		return 2;
	}
		
	getpasswordifempty();
	int errors=0;
	read_archive(archive.c_str(),&errors,0,true); /// note: kudged isselected
	if (flagdebug)
		printf("\n\n31016: dtsize %s\n\n",migliaia(dt.size()));
/// just a bit... overkill

	DTMap* dp[2]={&dt, &edt};
	for (int i=0; i<2; ++i) 
		for (DTMap::iterator p=dp[i]->begin(); p!=dp[i]->end(); ++p) 
		{
			int len=p->first.size();
			if (len>0 && p->first[len]!='/') 
				for (int j=0; j<len; ++j) 
				{
					if (p->first[j]=='/') 
					{
						DTMap::iterator q=dp[i]->find(p->first.substr(0, j+1));
						if (q!=dp[i]->end())
							q->second.size+=p->second.size;
					}
				}
		}
	
/*
	a "complex" thing... just to sort the output (!)
*/
	vector<DTMap::iterator> filelist;
	printf("\n\n");
	
	if (flagforce)
	{
		printf("31019: case sensitive == search, because of -force switch\n");
		for (unsigned int i=0;i<files.size();i++)
		{
			if (!isdirectory(files[i]))
					files[i]+='/';
			DTMap::iterator a=dt.find(files[i]);
			if (a!=dt.end())
				filelist.push_back(a);
			else
			{
				if (flagdebug)
					printf("31004: WARNING cannot find folder in the zpaq %s\n",files[i].c_str());
			}
		}
	}
	else
	{
/// case insensitive. I know, very slow, but who cares?
		printf("31038: case iNSeNsITIVE right search, because NO -force switch\n");
	
	
		for (unsigned int i=0;i<files.size();i++)
		{
			if (!isdirectory(files[i]))
					files[i]+='/';
			files[i]=stringtolower(files[i]);

			unsigned int oldsize=filelist.size();

			for (DTMap::iterator a=dt.begin(); a!=dt.end(); ++a)
				if (isdirectory(a->first))
				{
					int posizione=myposi(files[i],a->first);
					if (posizione>-1)
						if ((unsigned int)posizione==(unsigned int)(a->first.size()-files[i].size()))
							filelist.push_back(a);
				}
			if (flagdebug)
				if (filelist.size()==oldsize)
					printf("31053: WARNING cannot find folder in the zpaq <<%s>>\n",files[i].c_str());
		}
	}

	sort(filelist.begin(), filelist.end(), compareFragmentList);
	printf("\n\n");
	
	for (unsigned fi=0;fi<filelist.size(); ++fi) 
	{
		DTMap::iterator p=filelist[fi];
		printf("%19s [%s] <<",migliaia(p->second.size),dateToString(p->second.date).c_str());
		printUTF8(p->first.c_str());
		printf(">>\n");
	}
	
	if (flagforce) // .find() search
	{
		if (filelist.size()==files.size())
			return 0;
		else
		{
			printf("31094: folder searched %s != founded %s\n",migliaia(files.size()),migliaia2(filelist.size()));
			return 1;
		}
	}
	
	return 0;
}

// List contents
int Jidac::list() 
{
	getpasswordifempty();

	if (flagcomment)
	{
		enumeratecomments();
		return 0;
	}
	if (files.size()>=1)
		return testverify();

  // Read archive into dt, which may be "" for empty.
  int64_t csize=0;
  int errors=0;
  bool flagshow;
  
	if (archive!="") csize=read_archive(archive.c_str(),&errors,1); /// AND NOW THE MAGIC ONE!
	printf("\n");



	g_bytescanned=0;
	g_filescanned=0;
	g_worked=0;
	vector<DTMap::iterator> filelist;

	for (DTMap::iterator a=dt.begin(); a!=dt.end(); ++a) 
		if (a->second.data!='-' && (all || a->second.date)) 
		{
			a->second.data='-';
			filelist.push_back(a);
		}
	

  // Sort by size desc
 	if (menoenne) // sort by size desc
	{
		printf("Sort by size desc, limit to %d\n",menoenne);
		sort(filelist.begin(), filelist.end(), compareFragmentList);
	}

	int64_t usize=0;
	map<int, string> mappacommenti;
	
	//searchcomments(versioncomment,filelist);
		
	///VCOMMENT 00000002 seconda_versione:$DATA
	for (unsigned i=0;i<filelist.size();i++) 
	{
		DTMap::iterator p=filelist[i];
		if (isads(p->first))
		{
			string fakefile=p->first;
			myreplace(fakefile,":$DATA","");
			size_t found = fakefile.find("VCOMMENT "); 
			if (found != string::npos)
			{
    			string numeroversione=fakefile.substr(found+9,8);
//esx		
	//	int numver=0;//std::stoi(numeroversione.c_str());
#ifdef ESX
 int numver=0;
#else		
int numver=std::stoi(numeroversione.c_str());
#endif
				string commento=fakefile.substr(found+9+8+1,65000);
				mappacommenti.insert(std::pair<int, string>(numver, commento));
			}
/*
			found = fakefile.find("VLIST "); 
			if (found != string::npos)
			{
    			printf("EUREKAAAAAAAAAAAAAAAA %s\n",fakefile.c_str());
				exit(0);
			}
*/

		}
	}
	   
		   
	unsigned fi;
	for (fi=0;fi<filelist.size(); ++fi) 
	{
    
		if (menoenne) /// list -n 10 => sort by size and stop at 10
			if (fi>=menoenne)
				break;
			
		DTMap::iterator p=filelist[fi];
		flagshow=true;
		
		if (isads(p->first))
			if (strstr(p->first.c_str(),"VCOMMENT "))
				flagshow=false;
		
/// a little of change if -search is used
		if (searchfrom!="")
			flagshow=stristr(p->first.c_str(),searchfrom.c_str());
			
/// redundant, but not a really big deal

		if (flagchecksum)
			if (isdirectory(p->first))
				flagshow=false;

		if ((minsize>0) || (maxsize>0))
			if (isdirectory(p->first))
				flagshow=false;
						
		if (maxsize>0)
		{
			if (maxsize<(uint64_t)p->second.size) 
				flagshow=false;
		}
		if (minsize>0)
		{
			if (minsize>(uint64_t)p->second.size)
				flagshow=false;
		}
		
		if (flagshow)
		{
			if (!strchr(nottype.c_str(), p->second.data)) 
			{
				if (p->first!="" && (!isdirectory(p->first)))
					usize+=p->second.size;
	
				if (summary<=0) // special output
				{
					printf("%c %s %19s ", char(p->second.data),dateToString(p->second.date).c_str(), migliaia(p->second.size));
					if (!flagnoattributes)
					printf("%s ", attrToString(p->second.attr).c_str());
				}
				
				string myfilename=p->first;
				string myhashtype="";
				string myhash="";
				string mycrc32="";
				
				if (flagchecksum)
				{
					int franzotypedetected=
						decode_franz_block(isdirectory(myfilename),p->second.franz_block,
						myhashtype,
						myhash,
						mycrc32);
					
					if (franzotypedetected>1)
					{
						if ((myhashtype!="") && (myhash!=""))
							myhash=myhashtype+": "+myhash+" ";
						if (mycrc32!="")
							mycrc32="CRC32: "+mycrc32+" ";
					}
				}		
							
				if (all)
				{
					string rimpiazza="|";
				
					if (!isdirectory(myfilename))
	//					rimpiazza+="FOLDER ";
		//			else
					{
						rimpiazza+=myhash;
						rimpiazza+=mycrc32;
					}
					if (!myreplace(myfilename,"|$1",rimpiazza))
						myreplace(myfilename,"/","|");
				}
				else
				{
					if (tofiles.size()>0)
						myfilename=rename(myfilename);
					myfilename=myhash+mycrc32+myfilename;	
				}
				
				
/// search and replace, if requested	
				if ((searchfrom!="") && (replaceto!=""))
					replace(myfilename,searchfrom,replaceto);
								
				printUTF8(myfilename.c_str());
			  
				unsigned v;  // list version updates, deletes, compressed size
			if (all>0 && p->first.size()==all+1u && (v=atoi(p->first.c_str()))>0
          && v<ver.size()) 
				{  // version info
		
					std::map<int,string>::iterator commento;
		
					commento=mappacommenti.find(v); 
					if(commento== mappacommenti.end()) 
						printf(" +%d -%d -> %s", ver[v].updates, ver[v].deletes,
						(v+1<ver.size() ? migliaia(ver[v+1].offset-ver[v].offset) : migliaia(csize-ver[v].offset)));
					else
						printf(" +%d -%d -> %s <<%s>>", ver[v].updates, ver[v].deletes,
						(v+1<ver.size() ? migliaia(ver[v+1].offset-ver[v].offset) : migliaia(csize-ver[v].offset)),commento->second.c_str());
        		
				/*
			if (summary<0)  // print fragment range
			printf(" %u-%u", ver[v].firstFragment,
              v+1<ver.size()?ver[v+1].firstFragment-1:unsigned(ht.size())-1);
*/
				}
				
				printf("\n");
			}
		}
	}  // end for i = each file version

  // Compute dedupe size

	int64_t ddsize=0, allsize=0;
	unsigned nfiles=0, nfrags=0, unknown_frags=0, refs=0;
	vector<bool> ref(ht.size());
	for (DTMap::const_iterator p=dt.begin(); p!=dt.end(); ++p) 
	{
		if (p->second.date) 
		{
			++nfiles;
			for (unsigned j=0; j<p->second.ptr.size(); ++j) 
			{
				unsigned k=p->second.ptr[j];
				if (k>0 && k<ht.size()) 
				{
					++refs;
					if (ht[k].usize>=0) 
						allsize+=ht[k].usize;
					if (!ref[k]) 
					{
						ref[k]=true;
						++nfrags;
						if (ht[k].usize>=0) 
							ddsize+=ht[k].usize;
						else 
						++unknown_frags;
					}
				}
			}
		}
	}
	
  // Print archive statistics
	printf("\n%21s (%s) of %s (%s) in %s files shown\n",migliaia(usize),tohuman(usize),migliaia2(allsize),tohuman2(allsize),migliaia3(fi));
	printf("%21s compressed \n",migliaia((csize+dhsize-dcsize)));
	
  
  
  if (unknown_frags)
    printf("%u fragments have unknown size\n", unknown_frags);

  if (dhsize!=dcsize)  // index?
    printf("Note: %s of %s compressed bytes are in archive\n",
        migliaia(dcsize+0.0), migliaia2(dhsize+0.0));
		
		
  return 0;
}




/////////// HASHING-checksumming functions



string sha3_calc_file(const char * i_filename,bool i_flagcalccrc32,uint32_t& o_crc32,const int64_t i_inizio,const int64_t i_totali,int64_t& io_lavorati)
{
	o_crc32=0;
	
	FILE* myfile = freadopen(i_filename);
	if(myfile==NULL )
 		return "";
	
	int64_t lunghezza	=prendidimensionehandle(myfile);
	int64_t	letti		=0;

	const int BUFSIZE	=65536*8;
	unsigned char 				unzBuf[BUFSIZE];
	int 				n=BUFSIZE;
			
	SHA3 sha3;

	while (1)
	{
		int r=fread(unzBuf, 1, n, myfile);
		sha3.add(unzBuf,r);
		if (i_flagcalccrc32)
			o_crc32=crc32_16bytes(unzBuf,r,o_crc32);
 		io_lavorati+=r;
		letti+=r;
		if (r!=n) 
			break;
		if ((flagnoeta==false) && (i_inizio>0))
			myavanzamentoby1sec(io_lavorati,i_totali,i_inizio,false);
	}
	fclose(myfile);

    string risultato = sha3.getHash();
	if (lunghezza!=letti)
	{
		printf("\n29884: *** CORRUPTED FILE DETECTED! expected %s readed %s bytes *** ",migliaia(lunghezza),migliaia2(letti));
		printUTF8(i_filename);
		printf("\n");
	}
	

	return risultato;
}

string md5_calc_file(const char * i_filename,bool i_flagcalccrc32,uint32_t& o_crc32,const int64_t i_inizio,const int64_t i_totali,int64_t& io_lavorati)
{
	o_crc32=0;
	
	FILE* myfile = freadopen(i_filename);
	if(myfile==NULL )
 		return "";
	int64_t lunghezza	=prendidimensionehandle(myfile);
	int64_t	letti		=0;

	const int BUFSIZE	=65536*8;
	unsigned char 				unzBuf[BUFSIZE];
	int 				n=BUFSIZE;
			
	MD5 md5;

	while (1)
	{
		int r=fread(unzBuf, 1, n, myfile);
		md5.add(unzBuf,r);
		if (i_flagcalccrc32)
			o_crc32=crc32_16bytes(unzBuf,r,o_crc32);
 		io_lavorati+=r;
		letti+=r;
		if (r!=n) 
			break;
		if ((flagnoeta==false) && (i_inizio>0))
			myavanzamentoby1sec(io_lavorati,i_totali,i_inizio,false);
	}
	fclose(myfile);

    string risultato = md5.getHash();
	if (lunghezza!=letti)
	{
		printf("\n29926: *** CORRUPTED FILE DETECTED! expected %s readed %s bytes *** ",migliaia(lunghezza),migliaia2(letti));
		printUTF8(i_filename);
		printf("\n");
	}
	return risultato;
}

string whirlpool_calc_file(const char * i_filename,bool i_flagcalccrc32,uint32_t& o_crc32,const int64_t i_inizio,const int64_t i_totali,int64_t& io_lavorati)
{
	o_crc32=0;
	
	FILE* myfile = freadopen(i_filename);
	if(myfile==NULL )
 		return "";
	
	int64_t lunghezza	=prendidimensionehandle(myfile);
	int64_t	letti		=0;

	const int BUFSIZE	=65536*8;
	unsigned char 				unzBuf[BUFSIZE];
	int 				n=BUFSIZE;
				
	NESSIEstruct hasher;
	NESSIEinit(&hasher);
	while (1)
	{
		int r=fread(unzBuf, 1, n, myfile);
		NESSIEadd(unzBuf,r*8,&hasher);
		if (i_flagcalccrc32)
			o_crc32=crc32_16bytes(unzBuf,r,o_crc32);
 		io_lavorati+=r;
		letti+=r;
		if (r!=n) 
			break;
		if ((flagnoeta==false) && (i_inizio>0))
			myavanzamentoby1sec(io_lavorati,i_totali,i_inizio,false);
	}
	fclose(myfile);

	unsigned char buffer[512]={0};
	NESSIEfinalize(&hasher,buffer);

	if (lunghezza!=letti)
	{
		printf("\n29970: *** CORRUPTED FILE DETECTED! expected %s readed %s bytes *** ",migliaia(lunghezza),migliaia2(letti));
		printUTF8(i_filename);
		printf("\n");
	}
	return binarytohex(buffer,64);
}
/*
string sha1hw_calc_file(const char * i_filename,bool i_flagcalccrc32,uint32_t& o_crc32,const int64_t i_inizio,const int64_t i_totali,int64_t& io_lavorati)
{
	o_crc32=0;
	
	FILE* myfile = freadopen(i_filename);
	if(myfile==NULL )
 		return "";
	
	const int BUFSIZE	=65536*8;
	char 				unzBuf[BUFSIZE];
	int 				n=BUFSIZE;
	
	CSha1	myhasher;
	Sha1_Init	(&myhasher);
	
 
	while (1)
	{
		int r=fread(unzBuf, 1, n, myfile);
		Sha1_Update	(&myhasher,(const Byte*)unzBuf,r);
	
		if (i_flagcalccrc32)
			o_crc32=crc32_16bytes(unzBuf,r,o_crc32);
 		
		io_lavorati+=r;
		if (r!=n) 
			break;
		if ((flagnoeta==false) && (i_inizio>0))
			avanzamento(io_lavorati,i_totali,i_inizio);

	}
	fclose(myfile);

	char sha1result[20];
	Sha1_Final	(&myhasher,(Byte*)sha1result);
	return binarytohex((const unsigned char*)sha1result,20);
}
*/
string sha1_calc_file(const char * i_filename,bool i_flagcalccrc32,uint32_t& o_crc32,const int64_t i_inizio,const int64_t i_totali,int64_t& io_lavorati)
{
/*
	if (flaghw)
		return sha1hw_calc_file(i_filename,i_flagcalccrc32,o_crc32,i_inizio,i_totali,io_lavorati);
*/
	o_crc32=0;
	
	FILE* myfile = freadopen(i_filename);
	if(myfile==NULL )
 		return "";
	int64_t lunghezza	=prendidimensionehandle(myfile);
	int64_t	letti		=0;

	
	const int BUFSIZE	=65536*8;
	char 				unzBuf[BUFSIZE];
	int 				n=BUFSIZE;
				
	libzpaq::SHA1 sha1;
	while (1)
	{
		int r=fread(unzBuf, 1, n, myfile);
		sha1.write(unzBuf,r);
		
		if (i_flagcalccrc32)
			o_crc32=crc32_16bytes(unzBuf,r,o_crc32);
 		
		io_lavorati+=r;
		letti+=r;
		if (r!=n) 
			break;
		if ((flagnoeta==false) && (i_inizio>0))
			myavanzamentoby1sec(io_lavorati,i_totali,i_inizio,false);
	}
	fclose(myfile);
	
	char sha1result[20];
	memcpy(sha1result, sha1.result(), 20);
	if (lunghezza!=letti)
	{
		printf("\n30056: *** CORRUPTED FILE DETECTED! expected %s readed %s bytes *** ",migliaia(lunghezza),migliaia2(letti));
		printUTF8(i_filename);
		printf("\n");
	}
	
	return binarytohex((const unsigned char*)sha1result,20);
}

string fileentropy(const char * i_filename,const int64_t i_inizio,const int64_t i_totali,int64_t& io_lavorati)
{
	
	FILE* myfile = freadopen(i_filename);
	if(myfile==NULL )
 		return "";
	
	int64_t lunghezza	=prendidimensionehandle(myfile);
	int64_t	letti		=0;
	
	const int BUFSIZE	=65536*8;
	unsigned char 		buf[BUFSIZE];
	int 				n=BUFSIZE;
				
	size_t f[256] = { 0 };

	while (1)
	{
		int r=fread(buf, 1, n, myfile);
		io_lavorati+=r;
		letti+=r;
		for(int i=0;i<r;i++)
			f[buf[i]]++;
		if (r!=n) 
			break;
		if (flagnoeta==false)
			myavanzamentoby1sec(io_lavorati,i_totali,i_inizio,false);
	}
	fclose(myfile);
	if (lunghezza!=letti)
	{
		printf("\n31357: *** CORRUPTED FILE DETECTED! expected %s readed %s bytes *** ",migliaia(lunghezza),migliaia2(letti));
		printUTF8(i_filename);
		printf("\n");
	}
	double entropy=0.0;
	double byteletti=letti;
		
	if (letti>0)
		for(size_t i=0;i<256; i++)
			if (f[i])
			{
				double prob=(double)f[i]/byteletti;
				entropy += prob * log2(prob);
			}
	
	char buffer[32];
	if (entropy)
		snprintf(buffer, sizeof(buffer), "%8.4f", (float)-entropy);
	else
		snprintf(buffer, sizeof(buffer), "%8.4f", (float)0); ///quick "fix" for -0.0000
	
	return buffer;
}	

string crc32_calc_file(const char * i_filename,const int64_t i_inizio,const int64_t i_totali,int64_t& io_lavorati)
{
	FILE* myfile = freadopen(i_filename);
	if(myfile==NULL )
		return "";
	int64_t lunghezza	=prendidimensionehandle(myfile);
	int64_t	letti		=0;
		
	char data[65536*16];
    uint32_t crc=0;
	int got=0;
	
	while ((got=fread(data,sizeof(char),sizeof(data),myfile)) > 0) 
	{
		crc=crc32_16bytes (data, got, crc);
		io_lavorati+=got;	
		letti+=got;
		if ((flagnoeta==false) && (i_inizio>0))
			myavanzamentoby1sec(io_lavorati,i_totali,i_inizio,false);
	}
	fclose(myfile);
	
	char temp[9];
	sprintf(temp,"%08X",crc);
	if (lunghezza!=letti)
	{
		printf("\n30090: *** CORRUPTED FILE DETECTED! expected %s readed %s bytes *** ",migliaia(lunghezza),migliaia2(letti));
		printUTF8(i_filename);
		printf("\n");
	}
	return temp;
}

std::string xxhash64_calc_file(const char * i_filename,bool i_flagcalccrc32,uint32_t& o_crc32,const int64_t i_inizio,const int64_t i_totali,int64_t& io_lavorati)
{
	o_crc32=0;
	FILE* myfile = freadopen(i_filename);
	if(myfile==NULL )
 		return "";
	int64_t lunghezza	=prendidimensionehandle(myfile);
	int64_t	letti		=0;

	
	const int BUFSIZE	=65536*8;
	char 				unzBuf[BUFSIZE];
	int 				n=BUFSIZE;
				
	uint64_t myseed = 0;
    XXHash64 myhash(myseed);
    
	while (1)
	{
		int r=fread(unzBuf, 1, n, myfile);
		myhash.add(unzBuf,r);
		
		if (i_flagcalccrc32)
			o_crc32=crc32_16bytes(unzBuf,r,o_crc32);
		io_lavorati+=r;
		letti+=r;
 		if (r!=n) 
			break;
		if ((flagnoeta==false) && (i_inizio>0))
			myavanzamentoby1sec(io_lavorati,i_totali,i_inizio,false);
	}
	fclose(myfile);
	
	char temp[33];
	sprintf(temp,"%016llX",(unsigned long long)myhash.hash());
	if (lunghezza!=letti)
	{
		printf("\n30134: *** CORRUPTED FILE DETECTED! expected %s readed %s bytes *** ",migliaia(lunghezza),migliaia2(letti));
		printUTF8(i_filename);
		printf("\n");
	}
	return temp;
	
}


// WARNING: I am not sure AT ALL that in this mode a streamed-chunked-wyhash is computable
// Just a test, with memory mapped file
string wyhash_calc_file(const char * i_filename,bool i_flagcalccrc32,uint32_t& o_crc32,const int64_t i_inizio,const int64_t i_totali,int64_t& io_lavorati)
{
	o_crc32=0;
	
	int64_t lunghezza=prendidimensionefile(i_filename);
/*	
	if (lunghezza<=0)
		return "";
*/
	int64_t	letti		=0;


#ifdef unix

	int myfilehandle=open(i_filename,O_RDONLY);
	if (myfilehandle<=0)
	{
		printf("25098 in open\n");
		return "";
	}
	char *data=(char *)mmap(0,lunghezza,PROT_READ,MAP_PRIVATE,myfilehandle,0);
	if (data==MAP_FAILED)
	{
        printf("25098: map failed\n");
		if (myfilehandle>0)
			close(myfilehandle);
		
        return "";
    }
#else
	wstring wfilename=utow(i_filename);
	HANDLE myfile=CreateFile(wfilename.c_str(),GENERIC_READ,FILE_SHARE_READ | FILE_SHARE_WRITE,0,OPEN_EXISTING,FILE_ATTRIBUTE_NORMAL,0);
	if (myfile==INVALID_HANDLE_VALUE) 
	{
		printf("25057: Invalid handle for %s\n",i_filename);
		return "";
	}
	HANDLE mapping=CreateFileMapping(myfile,0,PAGE_READONLY, 0, 0, 0);
	if (mapping==0) 
	{
		if (myfile!=0)
			CloseHandle(myfile);
		return "";
	}
	const char* data=(const char*)MapViewOfFile(mapping,FILE_MAP_READ,0,0,0);
#endif
	
	string risultato="";
	uint64_t _wyp[4];
	make_secret(0,_wyp);

	if (data)
	{
		uint64_t mywyhash=wyhash(data,lunghezza,0,_wyp);

		char buffer[33];
		sprintf(buffer,"%16llX",(unsigned long long)mywyhash);
		risultato=buffer;

		if (i_flagcalccrc32)
			o_crc32=crc32_16bytes(data,lunghezza,o_crc32);

		io_lavorati+=lunghezza;	
		letti+=lunghezza;
		if (flagnoeta==false)
			myavanzamentoby1sec(io_lavorati,i_totali,i_inizio,false);
	}
#ifdef unix
	if (myfilehandle!=0)
		close(myfilehandle);
	if (lunghezza>0)
	{
		int errore=munmap(data,lunghezza);
		if (errore!=0)
		{
			printf("25109: unmapping guru\n");
			return "";
		}
	}
	if (lunghezza!=letti)
	{
		printf("\n30227: *** CORRUPTED FILE DETECTED! expected %s readed %s bytes *** ",migliaia(lunghezza),migliaia2(letti));
		printUTF8(i_filename);
		printf("\n");
	}
	return risultato;

#else
	else
	{
		printf("25095: data empty\n");
		if (mapping!=0)
			CloseHandle(mapping);
		if (myfile!=0)
			CloseHandle(myfile);
		return "";
	}	
    
	UnmapViewOfFile(data);
	CloseHandle(mapping);
	CloseHandle(myfile);
	
	if (lunghezza!=letti)
	{
		printf("\n30244: *** CORRUPTED FILE DETECTED! expected %s readed %s bytes *** ",migliaia(lunghezza),migliaia2(letti));
		printUTF8(i_filename);
		printf("\n");
	}
	return risultato;
#endif
}



string mm_hash_calc_file(int i_algo,const char * i_filename,bool i_flagcalccrc32,uint32_t& o_crc32,const int64_t i_inizio,const int64_t i_totali,int64_t& io_lavorati)
{
	o_crc32=0;
	char buffer[100];
	
	string risultato	="26304:ERROR";
	int64_t lunghezza	=prendidimensionefile(i_filename);
	char* data	=NULL;
	char zero			=0; /// my zerobytelong "file"

#ifdef unix
	int myfilehandle=0; // for unix
#else
	HANDLE mapping		=0;
	HANDLE myfile		=0;
#endif

	if (lunghezza==0)
	{	// 0 length file. Fix to get same results as "normal" hash
		data=&zero;
	}
	else
	{
#ifdef unix
		myfilehandle=open(i_filename,O_RDONLY);
		if (myfilehandle<=0)
			return "26364: ERROR IN OPEN";
		
		data=(char *)mmap(0,lunghezza,PROT_READ,MAP_PRIVATE,myfilehandle,0);
		if (data==MAP_FAILED)
		{
			if (myfilehandle>0)
				close(myfilehandle);
			return "26369: map failed";
		}
#else
		wstring wfilename=utow(i_filename);
		myfile=CreateFile(wfilename.c_str(),GENERIC_READ,FILE_SHARE_READ | FILE_SHARE_WRITE,0,OPEN_EXISTING,FILE_ATTRIBUTE_NORMAL,0);
		if (myfile==INVALID_HANDLE_VALUE) 
		{
			printf("25057: Invalid handle for %s\n",i_filename);
			return "26311:ERROR";
		}

		mapping=CreateFileMapping(myfile,0,PAGE_READONLY, 0, 0, 0);
		if (mapping==0) 
		{
			if (myfile!=0)
				CloseHandle(myfile);
			return "26322:ERROR";
		}
		data=(char*)MapViewOfFile(mapping,FILE_MAP_READ,0,0,0);
#endif
	}
	if (data)
	{
		if (i_algo==ALGO_NILSIMSA)
		{
			nilsimsa_compute(data,lunghezza,buffer);
			risultato=binarytohex((const unsigned char*)buffer,64);
		}
		else
		if (i_algo==ALGO_WYHASH)
		{
			uint64_t _wyp[4];
			make_secret(0,_wyp);
			uint64_t mywyhash=wyhash(data,lunghezza,0,_wyp);
			sprintf(buffer,"%16llX",(unsigned long long)mywyhash);
			risultato=buffer;
		}
		else
		if (i_algo==ALGO_XXHASH64)
		{
			uint64_t myseed = 0;
			XXHash64 myhash(myseed);
			myhash.add(data,lunghezza);
			sprintf(buffer,"%016llX",(unsigned long long)myhash.hash());
			risultato=buffer;
		}
		else
		if (i_algo==ALGO_SHA1)
		{
			libzpaq::SHA1 sha1;
			for (int64_t i=0;i<lunghezza;i++)
				sha1.put(*(data+i));
			
			char sha1result[20];
			memcpy(sha1result, sha1.result(), 20);
			risultato=binarytohex((const unsigned char*)sha1result,20);
			
		}
		else
		if (i_algo==ALGO_SHA256)
		{
			libzpaq::SHA256 sha256;
			for (int64_t i=0;i<lunghezza;i++)
				sha256.put(*(data+i));
			char sha256result[32];
			memcpy(sha256result, sha256.result(), 32);
			risultato=binarytohex((const unsigned char*)sha256result,32);
		}
		else
		if (i_algo==ALGO_BLAKE3)
		{
			blake3_hasher hasher;
			blake3_hasher_init(&hasher);
			blake3_hasher_update(&hasher,data,lunghezza);
			uint8_t output[BLAKE3_OUT_LEN];
			blake3_hasher_finalize(&hasher, output, BLAKE3_OUT_LEN);
			risultato=binarytohex((const unsigned char*)output,BLAKE3_OUT_LEN);
		}
		else
		if (i_algo==ALGO_WHIRLPOOL)
		{
			NESSIEstruct hasher;
			NESSIEinit(&hasher);
			
			/// note: a bigger numbit. Will it works?
			NESSIEadd64((const unsigned char*)data,lunghezza*8,&hasher); /// <-- whirlpool works on BITS, so *8
			NESSIEfinalize(&hasher,(unsigned char*)buffer);
			risultato=binarytohex((const unsigned char*)buffer,64);
		}
		else
		if (i_algo==ALGO_MD5)
		{
			MD5 md5;
			md5.add(data,lunghezza);
			string mymd5 = md5.getHash();
			risultato=mymd5;
		}
		else
		if (i_algo==ALGO_SHA3)
		{
			SHA3 sha3;
			sha3.add(data,lunghezza);
			string mysha3 = sha3.getHash();
			risultato=mysha3;
		}
		else
		if (i_algo==ALGO_XXH3)
		{
			XXH3_state_t state128;
			(void)XXH3_128bits_reset(&state128);
			(void)XXH3_128bits_update(&state128,data,lunghezza);
			XXH128_hash_t myhash=XXH3_128bits_digest(&state128);
			char buffer[33];
			sprintf(buffer,"%016llX%016llX",(unsigned long long)myhash.high64,(unsigned long long)myhash.low64);
			risultato=buffer;
		}
		else
		if (i_algo==ALGO_CRC32C)
		{
			uint32_t crc=0;
			crc=crc32c(crc, (const unsigned char*)data,lunghezza);
			char buffer[33];
			sprintf(buffer,"%08X",crc);
			risultato=buffer;
		}
		else
		if ((i_algo==ALGO_CRC32) || (i_flagcalccrc32))
		{
			o_crc32=crc32_16bytes(data,lunghezza,o_crc32);
			char buffer[33];
			sprintf(buffer,"%08X",o_crc32);
			risultato=buffer;
		}
		else
		{
			perror("25087: unknown algo");
		}
		io_lavorati+=lunghezza;	
		if ((flagnoeta==false) && (i_inizio>0))
			myavanzamentoby1sec(io_lavorati,i_totali,i_inizio,false);
	}
#ifdef unix
	if (myfilehandle!=0)
		close(myfilehandle);    
	if (lunghezza>0)
	{
		int errore=munmap(data,lunghezza);
		if (errore!=0)
			return "26506: unmapping guru";
	}
#else
	else
	{
		printf("25095: data empty\n");
		if (mapping!=0)
			CloseHandle(mapping);
		if (myfile!=0)
			CloseHandle(myfile);
		return "26441: ERROR";
	}	
    
	if (lunghezza>0)
		UnmapViewOfFile(data);
	if (mapping!=0)
		CloseHandle(mapping);
	if (myfile!=0)
		CloseHandle(myfile);
#endif


	return risultato;
}


string nilsimsa_calc_file(const char * i_filename,bool i_flagcalccrc32,uint32_t& o_crc32,const int64_t i_inizio,const int64_t i_totali,int64_t& io_lavorati)
{
	return mm_hash_calc_file(ALGO_NILSIMSA,i_filename,i_flagcalccrc32,o_crc32,i_inizio,i_totali,io_lavorati);

}
/// take sha256
string sha256_calc_file(const char * i_filename,bool i_flagcalccrc32,uint32_t& o_crc32,const int64_t i_inizio,const int64_t i_totali,int64_t& io_lavorati)
{
	o_crc32=0;
	
	FILE* myfile = freadopen(i_filename);
	if(myfile==NULL )
 		return "";
	
	int64_t lunghezza	=prendidimensionehandle(myfile);
	int64_t	letti		=0;
	
	const int BUFSIZE	=65536*8;
	unsigned char 		buf[BUFSIZE];
	int 				n=BUFSIZE;
				
	franzSHA256 mysha256;
	while (1)
	{
		int r=fread(buf, 1, n, myfile);
		mysha256.update(buf,r);
		if (i_flagcalccrc32)
			o_crc32=crc32_16bytes(buf,r,o_crc32);
 		io_lavorati+=r;
		letti+=r;
		if (r!=n) 
			break;
		if (flagnoeta==false)
			myavanzamentoby1sec(io_lavorati,i_totali,i_inizio,false);
	}
	fclose(myfile);
	if (lunghezza!=letti)
	{
		printf("\n30410: *** CORRUPTED FILE DETECTED! expected %s readed %s bytes *** ",migliaia(lunghezza),migliaia2(letti));
		printUTF8(i_filename);
		printf("\n");
	}
	
	return mysha256.gethex();
}	
	


string xxhash_calc_file(const char * i_filename,bool i_flagcalccrc32,uint32_t& o_crc32,const int64_t i_inizio,const int64_t i_totali,int64_t& io_lavorati)
{
	o_crc32=0;
	FILE* inFile = freadopen(i_filename);
	if (inFile==NULL) 
		return "";
	
	int64_t lunghezza	=prendidimensionehandle(inFile);
	int64_t	letti		=0;
	
	size_t const blockSize = 65536;
	unsigned char buffer[blockSize];
	size_t readSize;
	
	XXH3_state_t state128;
    (void)XXH3_128bits_reset(&state128);
	
	while ((readSize = fread(buffer, 1, blockSize, inFile)) > 0) 
	{
		(void)XXH3_128bits_update(&state128, buffer, readSize);
		if (i_flagcalccrc32)
			o_crc32=crc32_16bytes(buffer,readSize,o_crc32);
		io_lavorati+=readSize;
		letti+=readSize;
		if (flagnoeta==false) 
				myavanzamentoby1sec(io_lavorati,i_totali,i_inizio,false);
	}
	fclose(inFile);
	XXH128_hash_t myhash=XXH3_128bits_digest(&state128);
	char buf[33];
	sprintf(buf,"%016llX%016llX",(unsigned long long)myhash.high64,(unsigned long long)myhash.low64);
	string risultato=buf;
	if (lunghezza!=letti)
	{
		printf("\n30463: *** CORRUPTED FILE DETECTED! expected %s readed %s bytes *** ",migliaia(lunghezza),migliaia2(letti));
		printUTF8(i_filename);
		printf("\n");
	}
	return risultato;
}

string blake3_calc_file(const char * i_filename,bool i_flagcalccrc32,uint32_t& o_crc32,const int64_t i_inizio,const int64_t i_totali,int64_t& io_lavorati)
{
	o_crc32=0;
	
    FILE* inFile = freadopen(i_filename);
	if (inFile==NULL) 
		return "";
	
	int64_t lunghezza	=prendidimensionehandle(inFile);
	int64_t	letti		=0;
	
	blake3_hasher hasher;
	blake3_hasher_init(&hasher);
	unsigned char buffer[65536];
	ssize_t readSize;

	while ((readSize = fread(buffer, 1, sizeof(buffer), inFile)) > 0) 
	{
		blake3_hasher_update(&hasher, buffer, readSize);

		if (i_flagcalccrc32)
			o_crc32=crc32_16bytes(buffer,readSize,o_crc32);
		io_lavorati+=readSize;
		letti+=readSize;
	
		if (flagnoeta==false)
				myavanzamentoby1sec(io_lavorati,i_totali,i_inizio,false);
	}
	fclose(inFile);
	
	uint8_t output[BLAKE3_OUT_LEN];
	blake3_hasher_finalize(&hasher, output, BLAKE3_OUT_LEN);
	if (lunghezza!=letti)
	{
		printf("\n30505: *** CORRUPTED FILE DETECTED! expected %s readed %s bytes *** ",migliaia(lunghezza),migliaia2(letti));
		printUTF8(i_filename);
		printf("\n");
	}
	
	return binarytohex((const unsigned char*)output,BLAKE3_OUT_LEN);	
}


#define SIZE (262144*3)
#define CHUNK SIZE
string crc32c_calc_file(const char * i_filename,const int64_t i_inizio,const int64_t i_totali,int64_t& io_lavorati)
{
	FILE* myfile = freadopen(i_filename);
	
	if( myfile==NULL )
    	return 0;
	
	int64_t lunghezza	=prendidimensionehandle(myfile);
	int64_t	letti		=0;
    
	char buffer[SIZE];
    ssize_t got;
    size_t off, n;
    uint32_t crc=0;
	
    while ((got = fread(buffer, sizeof(char),SIZE,myfile)) > 0) 
	{
		off = 0;
        do 
		{
            n = (size_t)got - off;
            if (n > CHUNK)
                n = CHUNK;
            crc = crc32c(crc, (const unsigned char*)buffer + off, n);
            off += n;
        } while (off < (size_t)got);
				
		io_lavorati+=got;
		letti+=got;
		if (flagnoeta==false)
			if (i_totali)
			myavanzamentoby1sec(io_lavorati,i_totali,i_inizio,false);

    }
    fclose(myfile);
	char buf[9];
	sprintf(buf,"%08X",crc);
	string risultato=buf;
	if (lunghezza!=letti)
	{
		printf("\n30556: *** CORRUPTED FILE DETECTED! expected %s readed %s bytes *** ",migliaia(lunghezza),migliaia2(letti));
		printUTF8(i_filename);
		printf("\n");
	}
	return risultato;
}


string hash_calc_file(int i_algo,const char * i_filename,bool i_flagcalccrc32,uint32_t& o_crc32,const int64_t i_inizio,const int64_t i_totali,int64_t& io_lavorati)
{
	o_crc32=0;
	if (flagmm)
	{
	///	printbar('=');
		///printf("USING MEMORY MAPPED!!!\n");
		///printbar('=');
		return mm_hash_calc_file(i_algo,i_filename,i_flagcalccrc32,o_crc32,i_inizio,i_totali,io_lavorati);
	}
	if (i_algo==ALGO_BLAKE3)
		return blake3_calc_file(i_filename,i_flagcalccrc32,o_crc32,i_inizio,i_totali,io_lavorati);
	else
	if (i_algo==ALGO_NILSIMSA)		// memory mapped file
		return nilsimsa_calc_file(i_filename,i_flagcalccrc32,o_crc32,i_inizio,i_totali,io_lavorati);
	else
	if (i_algo==ALGO_WYHASH)		// memory mapped file
		return wyhash_calc_file(i_filename,i_flagcalccrc32,o_crc32,i_inizio,i_totali,io_lavorati);
	else
	if (i_algo==ALGO_WHIRLPOOL)		
		return whirlpool_calc_file(i_filename,i_flagcalccrc32,o_crc32,i_inizio,i_totali,io_lavorati);
	else
	if (i_algo==ALGO_MD5)		
		return md5_calc_file(i_filename,i_flagcalccrc32,o_crc32,i_inizio,i_totali,io_lavorati);
	else
	if (i_algo==ALGO_SHA3)		
		return sha3_calc_file(i_filename,i_flagcalccrc32,o_crc32,i_inizio,i_totali,io_lavorati);
	else
	if (i_algo==ALGO_XXHASH64)
		return xxhash64_calc_file(i_filename,i_flagcalccrc32,o_crc32,i_inizio,i_totali,io_lavorati);
	else
	if (i_algo==ALGO_SHA1)
		return sha1_calc_file(i_filename,i_flagcalccrc32,o_crc32,i_inizio,i_totali,io_lavorati);
	else
	if (i_algo==ALGO_CRC32C)
		return crc32c_calc_file(i_filename,i_inizio,i_totali,io_lavorati);
	else
	if (i_algo==ALGO_CRC32)
		return crc32_calc_file(i_filename,i_inizio,i_totali,io_lavorati);
	else
	if (i_algo==ALGO_ENTROPY)
		return fileentropy(i_filename,i_inizio,i_totali,io_lavorati);
	else
	if (i_algo==ALGO_XXH3)
		return xxhash_calc_file(i_filename,i_flagcalccrc32,o_crc32,i_inizio,i_totali,io_lavorati);
	else
	if (i_algo==ALGO_SHA256)
		return sha256_calc_file(i_filename,i_flagcalccrc32,o_crc32,i_inizio,i_totali,io_lavorati);
	else
		error("GURU 13480 algo ??");
	
	return "";
}


string shash_calc_file(string i_algo,const char * i_filename,bool i_flagcalccrc32,uint32_t& o_crc32,const int64_t i_inizio,const int64_t i_totali,int64_t& io_lavorati)
{
	o_crc32=0;

	if (i_algo=="BLAKE3")
		return blake3_calc_file(i_filename,i_flagcalccrc32,o_crc32,i_inizio,i_totali,io_lavorati);
	else
	if (i_algo=="WYHASH")		// memory mapped file
		return wyhash_calc_file(i_filename,i_flagcalccrc32,o_crc32,i_inizio,i_totali,io_lavorati);
	else
	if (i_algo=="WHIRLPOOL")		
		return whirlpool_calc_file(i_filename,i_flagcalccrc32,o_crc32,i_inizio,i_totali,io_lavorati);
	else
	if (i_algo=="MD5")		
		return md5_calc_file(i_filename,i_flagcalccrc32,o_crc32,i_inizio,i_totali,io_lavorati);
	else
	if (i_algo=="NILSIMSA")		
		return nilsimsa_calc_file(i_filename,i_flagcalccrc32,o_crc32,i_inizio,i_totali,io_lavorati);
	else
	if (i_algo=="SHA-3")		
		return sha3_calc_file(i_filename,i_flagcalccrc32,o_crc32,i_inizio,i_totali,io_lavorati);
	else
	if (i_algo=="XXHASH64")
		return xxhash64_calc_file(i_filename,i_flagcalccrc32,o_crc32,i_inizio,i_totali,io_lavorati);
	else
	if (i_algo=="SHA-1")
		return sha1_calc_file(i_filename,i_flagcalccrc32,o_crc32,i_inizio,i_totali,io_lavorati);
	else
	if (i_algo=="CRC32-C")
		return crc32c_calc_file(i_filename,i_inizio,i_totali,io_lavorati);
	else
	if (i_algo=="CRC-32")
		return crc32_calc_file(i_filename,i_inizio,i_totali,io_lavorati);
	else
	if (i_algo=="ENTROPY")
		return fileentropy(i_filename,i_inizio,i_totali,io_lavorati);
	else
	if (i_algo=="XXH3")
		return xxhash_calc_file(i_filename,i_flagcalccrc32,o_crc32,i_inizio,i_totali,io_lavorati);
	else
	if (i_algo=="SHA-256")
		return sha256_calc_file(i_filename,i_flagcalccrc32,o_crc32,i_inizio,i_totali,io_lavorati);
	else
		error("GURU 31223 algo ??");
	
	return "";
}

bool 	iszpaqfranzvirtualfile(const string& i_filename)
{
	if (mypos("VCOMMENT ",i_filename)>-1)
		return true;
	if (mypos("VFILE-",i_filename)>-1)
		return true;
	return false;
}

bool isletterpath(const string& i_filename)
{
	if (i_filename=="")
			return false;
	if (isalpha(i_filename[0]))
			return true;
	return false;
}



int Jidac::setpassword() 
{
	if (files.size()!=2)
	{
		printf("32447: setpassword require exactly two file-parameters: source and destination\n");
		return 2;
	}
	
	archive=files[0];
	if (!iszpaq(archive))
			archive+=".zpaq";

	repack=files[1];
	if (!iszpaq(repack))
			repack+=".zpaq";
	  
	string part0=subpart(archive,0);
	if (part0!=archive) 
	{  
		printf("32528: so sorry, this seems a multipart archive, abort\n");
		return 2;
	}

	if (!flagspace)
		if (!saggiascrivibilitacartella(repack.c_str()))
		{
			printf("32471: Cannot write on output %s\n",repack.c_str());
			printf("32472: Aborting. Use -space to bypass and enforcing.\n");
			return 2;
		}
	
	printf("\n\nOpening the source achive\n");

	getpasswordifempty();

	if (password!=NULL)
	{
		printf("32479: please take note: if the source password is incorrect\n");
		printf("32480: the output file will be silently corrupted\n");
		printf("\n\n");
	}
	
	if (new_password==NULL)
	{
		printf("New password (-key2) empty, enter . for NO password\n");
		string spassword=getpassword();
		if (spassword==".")
			printf("32478: password in output removed\n");
		else
		{
			if (spassword!="")
			{
				libzpaq::SHA256 sha256;
				for (unsigned int i=0;i<spassword.size();i++)
					sha256.put(spassword[i]);
				memcpy(new_password_string, sha256.result(), 32);
				new_password=new_password_string;
			}
		}
	}

	InputArchive in(archive.c_str(), password);

	int64_t lavoro=in.totalsize();
	
	if (!flagspace)
	{
		int64_t spazio=getfreespace(repack);
		if (spazio<lavoro+1024)
		{
			printf("32515: The free space seems tiny %s on %s\n",migliaia(spazio),repack.c_str());
			printf("32516: Aborting. Use -space to bypass and enforcing.\n");
			return 2;
		}
	}
	
	if (flagforce) 
		delete_file(repack.c_str());
	if (exists(repack)) 
		error("32507: output file exists and no -force");

	char salt[32]={0};
	if (new_password) 
		libzpaq::random(salt, 32);

	printf("Running for %s bytes\n",migliaia(in.totalsize()));
	
	if (password!=NULL)
		printf("Source password:       present\n");
	else
		printf("Source password:       none\n");
	
	if (new_password!=NULL)
		printf("Destination password:  present\n");
	else
		printf("Destination password:  none\n");
		
	OutputArchive out(repack.c_str(), new_password, salt, 0);
	copywitheta(lavoro,in, out);
	printf("\n");
	printf("Source      %19s <<", migliaia(in.tell()));
	printUTF8(archive.c_str());
	printf(">>\n");
	printf("Destination %19s <<", migliaia(out.tell()));
	printUTF8(repack.c_str());
	printf(">>\n");
	out.close();
	
	printf("\nNow quick check of the output file\n");
	password=new_password;
	read_archive(repack.c_str()); /// AND NOW THE MAGIC ONE!
	return 0;
}
  
// Extract files from archive. If force is true then overwrite
// existing files and set the dates and attributes of exising directories.
// Otherwise create only new files and directories. Return 1 if error else 0.


struct tparametriramtodisk
{
	///vector<string> 	o_hashcalculated;
	vector<string> 	filenameondisk;
	vector<int64_t>	filedate;
	vector<int64_t>	fileattr;
	vector<string> 	algo;
	vector<string> 	filehash;
	vector<int64_t>	filesize;
	vector<char*>	data;
	vector<string> 	filecrc;
	vector<uint32_t> filefix;
	
	int				tnumber;
	uint64_t		timestart;
	bool			flagtest;
	uint64_t		o_timeend;
	int64_t			o_hashedsize;
	int64_t			o_crcsize;
	int64_t			o_writtenbythread;
	int64_t			o_timecrc;
	int64_t			o_timehash;
	int64_t			o_timefilesystem;
	int64_t			o_timewrite;
	uint32_t		o_writeerror;
	uint32_t		o_fileok;
	uint32_t		o_fileerror;
	uint32_t		o_filesnotchecked;
	uint32_t		o_filewithoutcrc;
	uint32_t		o_filecrc;
	uint32_t		o_filecrcok;
	uint32_t		o_filecrcerror;
	
};

void * scriviramtodisk(void *t) 
{
	assert(t);
	tparametriramtodisk* par= ((struct tparametriramtodisk*)(t));
	
	char buffer[100];
	string hashstringato;
	string crc32fromram;
	string hashfromfile		="";
	
	par->o_crcsize			=0;
	par->o_hashedsize		=0;
	par->o_writtenbythread	=0;
	par->o_timecrc			=0;
	par->o_timehash			=0;
	par->o_timefilesystem	=0;
	par->o_timewrite		=0;
	
	par->o_writeerror		=0;

	par->o_fileok			=0;
	par->o_fileerror		=0;
	par->o_filesnotchecked	=0;
	par->o_filewithoutcrc	=0;
	par->o_filecrc			=0;
	par->o_filecrcok		=0;
	par->o_filecrcerror		=0;

	for (unsigned int i=0;i<par->filenameondisk.size();i++)
	{
		if (flagchecksum)
		if (!isdirectory(par->filenameondisk[i]))
			if (par->data[i]!=NULL)
				{
					hashfromfile="";
					if (par->filecrc[i]!="")
					{
						int64_t startcrc=mtime();
						
						par->o_filecrc++;
						uint32_t crc=0;
						crc=crc32_16bytes (par->data[i],par->filesize[i],crc);
						sprintf(buffer,"%08X",crc);
						crc32fromram=buffer;
						if (crc32fromram==par->filecrc[i])
							par->o_filecrcok++;
						else
						{
							if (flagverbose)
								printf("33162: ERROR CRC stored %s  from ram|%s|\n",par->filecrc[i].c_str(),crc32fromram.c_str());
							par->o_filecrcerror++;
						}
						par->o_crcsize+=par->filesize[i];
						par->o_timecrc+=(mtime()-startcrc);
					}
					else
					par->o_filewithoutcrc++;
				
				
					int64_t starthash=mtime();
					
					if (par->algo[i]=="")
						par->o_filesnotchecked++;
					else
					if (par->algo[i]=="XXHASH64")
					{
						uint64_t myseed = 0;
						XXHash64 myhash64(myseed);
						myhash64.add(par->data[i],par->filesize[i]);
						sprintf(buffer,"%016llX",(unsigned long long)myhash64.hash());
						hashstringato=buffer;
						par->o_hashedsize+=par->filesize[i];
					}
					else
					if (par->algo[i]=="SHA-1")
					{
						libzpaq::SHA1 sha1;
						sha1.write(par->data[i],par->filesize[i]);
						char sha1result[20];
						memcpy(sha1result, sha1.result(), 20);
						hashstringato=binarytohex((const unsigned char*)sha1result,20);
						par->o_hashedsize+=par->filesize[i];
					}
					else
					if (par->algo[i]=="SHA-256")
					{
						libzpaq::SHA256 sha256;
						for (int64_t i=0;i<par->filesize[i];i++)
							sha256.put(*(par->data[i]+i));
						char sha256result[32];
						memcpy(sha256result, sha256.result(), 32);
						hashstringato=binarytohex((const unsigned char*)sha256result,32);
						par->o_hashedsize+=par->filesize[i];
					}
					else
					if (par->algo[i]=="BLAKE3")
					{
						blake3_hasher hasher;
						blake3_hasher_init(&hasher);
						blake3_hasher_update(&hasher,par->data[i],par->filesize[i]);
						uint8_t output[BLAKE3_OUT_LEN];
						blake3_hasher_finalize(&hasher, output, BLAKE3_OUT_LEN);
						hashstringato=binarytohex((const unsigned char*)output,BLAKE3_OUT_LEN);
						par->o_hashedsize+=par->filesize[i];
					}
					else
					if (par->algo[i]=="SHA-3")
					{
						SHA3 sha3;
						sha3.add(par->data[i],par->filesize[i]);
						hashstringato=sha3.getHash();
						par->o_hashedsize+=par->filesize[i];
					}
					else
					if (par->algo[i]=="MD5")
					{
						MD5 md5;
						md5.add(par->data[i],par->filesize[i]);
						hashstringato=md5.getHash();
						par->o_hashedsize+=par->filesize[i];
					}
					else
					if (par->algo[i]=="XXH3")
					{
						XXH3_state_t state128;
						(void)XXH3_128bits_reset(&state128);
						(void)XXH3_128bits_update(&state128,par->data[i],par->filesize[i]);
						XXH128_hash_t myhash=XXH3_128bits_digest(&state128);
						char buffer[33];
						sprintf(buffer,"%016llX%016llX",(unsigned long long)myhash.high64,(unsigned long long)myhash.low64);
						hashstringato=buffer;
						par->o_hashedsize+=par->filesize[i];
					}
					else
						error("33964: unknown myhashtype");
					
					if (flagdebug)
						printf("33966: INFO hash stored %s %s  from ram|%s| %s\n",par->algo[i].c_str(),par->filecrc[i].c_str(),hashstringato.c_str(),par->filenameondisk[i].c_str());
					
					
					if (par->filehash[i]!=hashstringato)
					{
						par->o_fileerror++;
						if (flagverbose)
							printf("33968: ERROR hash stored %s %s  from ram|%s| %s\n",par->algo[i].c_str(),par->filecrc[i].c_str(),hashstringato.c_str(),par->filenameondisk[i].c_str());
					}
					else
					{
						if (hashstringato!="")
							par->o_fileok++;
					}
					int64_t temp=(mtime()-starthash);///*0.001;
					par->o_timehash+=temp;
				}
			
		if (!par->flagtest)
		{
			int64_t startfilesystem=mtime();
			makepath(par->filenameondisk[i], par->filedate[i],par->fileattr[i]);
			FP myfile=fopen(par->filenameondisk[i].c_str(), WB);
			par->o_timefilesystem+=(mtime()-startfilesystem);
			
			int64_t startwrite=mtime();
			
	/// splitting for 32-bit version. I know, it is weird, but necessary
			int64_t	scritti=0;
			int64_t	n=1000000000;
			int64_t w=0;
			while (1)
			{
				int64_t dascrivere=par->filesize[i]-scritti;
				if (dascrivere>n)
						dascrivere=n;
				w=fwrite(par->data[i]+scritti,1,dascrivere,myfile);
				scritti+=w;
				if (w!=n)
					break;
			}
			
			///size_t scritti=fwrite(par->data[i],1,par->filesize[i],myfile);
			par->o_writtenbythread+=scritti;
			fclose(myfile);
			close(par->filenameondisk[i].c_str(),par->filedate[i],par->fileattr[i]);
			par->o_timewrite+=(mtime()-startwrite);
			
			if (scritti!=par->filesize[i])
			{
				if (flagverbose)
				{
					printf("33549: written != expected %21s %21s on ",migliaia(scritti),migliaia2(par->filesize[i]));
					printUTF8(par->filenameondisk[i].c_str());
					printf("\n");
				}
				par->o_writeerror++;
			}
		}
		myavanzamentoby1sec(g_fwritten,g_ramdisksize,par->timestart,false);
	}
	
	par->o_timeend=mtime();
			
	pthread_exit(NULL);
	return 0;
}



int Jidac::extract() 
{
/*	if (flagramdisk)
	  if (!flagtest)
		  if ((tofiles.size()!=1) && (!flagzero))
		  {
				printf("33096: **** ERROR -ramdisk but no -test: you need -to temporary folder\n");
				printf("33096: OK: zpaqfranz x 1.zpaq -test -ramdisk\n");
				printf("33096: OK: zpaqfranz x 1.zpaq -ramdisk -zero -to z:\\tempfolder\n");
				printf("33096: NO: zpaqfranz x 1.zpaq -ramdisk\n");
				return 2;
		  }

  if (flagramdisk)
	  if (!flagtest)
		  flagzero=false;
	*/
	#ifdef _WIN32
		
/// check if some kind of UNC Windows path \\franzk\pippo\..., turn OFF flaglongpath
		if (flaglongpath)
		{
			for (unsigned int i=0;i<tofiles.size();i++)
			{
				if (islonguncpath(tofiles[i]))
				{
					printf("31904: error, cannot extract on explicit UNC -to\n");
					return 2;
				}
				if (iswindowsunc(tofiles[i]))
				{
					printf("31935: found UNC Windows, incompatible with -longpath, turning OFF %s\n",tofiles[i].c_str());
					flaglongpath=false;
					break;
				}
			}
			
			for (DTMap::iterator p=dt.begin(); p!=dt.end(); ++p) 
				if (iswindowsunc(p->first))
				{
					printf("31915: found UNC Windows, incompatible with -longpath, turning OFF %s\n",p->first.c_str());
					flaglongpath=false;
					break;
				}
			if (tofiles.size()>0)
			{
				for (unsigned int i=0;i<tofiles.size();i++)
					if (!islongpath(tofiles[i]))
						tofiles[i]="//?/"+tofiles[i];
				printf("31876: INFO: setting Windows' long filenames\n");
				if (flagdebug)
					for (unsigned int i=0;i<tofiles.size();i++)
						printf("31879: Tofiles %d %s\n",i,tofiles[i].c_str());
				
			}
		}	
	#endif
	
	getpasswordifempty();

	if (flagparanoid)
	{
		if (tofiles.size()==0)
		{
			printf("-paranoid needs a -to\n");
			return 2;
		}
		if (command=='x')
		{
			printf("30244: -paranoid is a t (test) thing\n");
			return 1;
		}
		
	}


	if (!flagspace)
		if (tofiles.size()==1)
		{
			if (files.size()==1)
				if (isdirectory(tofiles[0]))
					if (!isdirectory(files[0]))
					{
						if (iswildcards(files[0]))
						{
							if (flagdebug)
								printf("31745: wildcard in files[0]: do nothing\n");
						}
						else
						{
							if (flagdebug)
								printf("31749: no wildcard, check if a filename is selected\n");
							string onlyname=extractfilename(files[0]);
							if (onlyname!="")
							{
								tofiles[0]+=onlyname;
								printf("31744: MAGIC: selected 1 file extracting to a folder => merge to %s\n",tofiles[0].c_str());
							}
						}
					}
			if (!saggiascrivibilitacartella(tofiles[0].c_str()))
			{
				printf("Cannot write on <<-to %s>>\n",tofiles[0].c_str());
				printf("Aborting. Use -space to bypass and enforcing.\n");
				return 2;
				///error("Path seems not writeable");
			}
		}
		
	if (flagzero)
	{
		if (flagforce)
		{
			printf("-kill incompatible with -force\n");
			return 2;
		}
		printf("\n");
		printf("****** WARNING: -zero switch. Create 0 bytes files (NO data written)\n");
		printf("****** Full-scale extraction test (UTF-8 strange filenames, path too long...)\n");
		printf("****** Highly suggested output on RAMDISK\n\n");
	}
	
	string kunfile=g_gettempdirectory()+"VFILE-kun.txt";
	myreplaceall(kunfile,"\\","/");
	kunfile=nomefileseesistegia(kunfile);
	if (flagfilelist)
	{
		printf("Autoselect\n"); // too slow DTMap::iterator a=dt.find("VFILE-l-filelist.txt");
			files.clear();
		files.push_back("VFILE-l-filelist.txt");
		flagforce=true;
		tofiles.clear();
		tofiles.push_back(kunfile);
	}
	


	g_scritti=0;
  // Encrypt or decrypt whole archive
	if ((repack!="") && all) 
	{
		if (files.size()>0 || tofiles.size()>0 || onlyfiles.size()>0 || flagnoattributes || version!=DEFAULT_VERSION || method!="")
			error("-repack -all does not allow partial copy");
	  
		string part0=subpart(archive, 0);
		if (part0!=archive) 
		{  
			printf("32528: so sorry, this seems a multipart archive, abort\n");
			return 2;
		}
		
		InputArchive in(archive.c_str(), password);
		if (flagforce) 
			delete_file(repack.c_str());
		if (exists(repack)) 
			error("output file exists");

    	char salt[32]={0};
		if (new_password) 
			libzpaq::random(salt, 32);

		printf("Changing password for %s bytes\n\n",migliaia(in.totalsize()));
		OutputArchive out(repack.c_str(), new_password, salt, 0);
		copywitheta(in.totalsize(),in, out);
		printf("\n");
		printf("Source      %19s <<", migliaia(in.tell()));
		printUTF8(archive.c_str());
		printf(">>\n");
		printf("Destination %19s <<", migliaia(out.tell()));
		printUTF8(repack.c_str());
		printf(">>\n");
		out.close();
		return 0;
  }
  
///printf("ZA\n");

	int	errors=0;
	int64_t sz=read_archive(archive.c_str(),&errors);
	if (sz<1) error("archive not found");
///printf("ZB\n");

#ifdef _WIN32

	if (flaglongpath)
	{
		if ((searchfrom!="") && (replaceto!=""))
		{
			/// the rename() function will replace
			if (flagdebug)
					printf("32146: -longpath and search and replace ON\n");
		}
		else
		if (tofiles.size()==1)
		{
			/// a special rename() kludge for tofiles.size==1 and flaglongpath
			if (flagdebug)
					printf("32152: -longpath and ONE to: deal with rename()\n");
		}
		else
		{
			if (flagdebug)
					printf("32158: -longpath, check for some UNC\n");
				
			/// extract longpath files, from UNC, is not so easy
			/// spaghetti? well, it is not my fault, it is Windows' lasagna-code
			
			for (DTMap::iterator p=dt.begin(); p!=dt.end(); ++p) 
				if (iswindowsunc(p->first))
				{
					printf("\n\n32133: WARNING: -longpath with Windows UNC, use ONE -to something /  -find -replace to manually adjust\n");
					printf("32134:     zpaqfranz x z:\\1.zpaq -find //franzk/z/NS -replace \\\\?\\z:\\here -longpath\n");
					printf("32134:     zpaqfranz x z:\\1.zpaq -find //franzk/z/NS -replace \\\\?\\UNC\\nas\\share\\somewhere -longpath\n");
					printf("32135:     zpaqfranz x z:\\1.zpaq -to z:\\here -longpath  [note: ONLY ONE local folder]\n\n");
					break;
				}
		}
	}
#endif
	if (flagcomment)
		if (versioncomment.length()>0)
		{
			// try to find the comment, but be careful: 1, and only 1, allowed
			vector<DTMap::iterator> myfilelist;
			int versione=searchcomments(versioncomment,myfilelist);
			if (versione>0)
			{
				printf("Found version -until %d scanning again...\n",versione);
				version=versione;
	
				ver.clear();
				block.clear();
				dt.clear();
				ht.clear();
				ht.resize(1);  // element 0 not used
				ver.resize(1); // version 0
				dhsize=dcsize=0;
				sz=read_archive(archive.c_str());
			}
			else
			if (versione==0)
				error("Cannot find version comment");
			else
				error("Multiple match for version comment. Please use -until");
		}
///printf("ZC\n");

  // test blocks
  for (unsigned i=0; i<block.size(); ++i) {
    if (block[i].bsize<0) error("negative block size");
    if (block[i].start<1) error("block starts at fragment 0");
    if (block[i].start>=ht.size()) error("block start too high");
    if (i>0 && block[i].start<block[i-1].start) error("unordered frags");
    if (i>0 && block[i].start==block[i-1].start) error("empty block");
    if (i>0 && block[i].offset<block[i-1].offset+block[i-1].bsize)
      error("unordered blocks");
    if (i>0 && block[i-1].offset+block[i-1].bsize>block[i].offset)
      error("overlapping blocks");
  }
///printf("ZD\n");

  // Create index instead of extract files
  if (index) {
    if (ver.size()<2) error("no journaling data");
    if (flagforce) delete_file(index);
    if (exists(index)) error("index file exists");

    // Get salt
    char salt[32];
    if (ver[1].offset==32) {  // encrypted?
      FP fp=fopen(subpart(archive, 1).c_str(), RB);
      if (fp==FPNULL) error("cannot read part 1");
      if (fread(salt, 1, 32, fp)!=32) error("cannot read salt");
      salt[0]^='7'^'z';  // for index
      fclose(fp);
    }
    InputArchive in(archive.c_str(), password);
    OutputArchive out(index, password, salt, 0);
    for (unsigned i=1; i<ver.size(); ++i) {
      if (in.tell()!=ver[i].offset) error("I'm lost");

      // Read C block. Assume uncompressed and hash is present
      static char hdr[256]={0};  // Read C block
      int hsize=ver[i].data_offset-ver[i].offset;
      if (hsize<70 || hsize>255) error("bad C block size");
      if (in.read(hdr, hsize)!=hsize) error("EOF in header");
      if (hdr[hsize-36]!=9  // size of uncompressed block low byte
          || (hdr[hsize-22]&255)!=253  // start of SHA1 marker
          || (hdr[hsize-1]&255)!=255) {  // end of block marker
        for (int j=0; j<hsize; ++j)
          printf("%d%c", hdr[j]&255, j%10==9 ? '\n' : ' ');
        printf("at %1.0f\n", ver[i].offset+.0);
        error("C block in weird format");
      }
      memcpy(hdr+hsize-34, 
          "\x00\x00\x00\x00\x00\x00\x00\x00"  // csize = 0
          "\x00\x00\x00\x00"  // compressed data terminator
          "\xfd"  // start of hash marker
          "\x05\xfe\x40\x57\x53\x16\x6f\x12\x55\x59\xe7\xc9\xac\x55\x86"
          "\x54\xf1\x07\xc7\xe9"  // SHA-1('0'*8)
          "\xff", 34);  // EOB
      out.write(hdr, hsize);
      in.seek(ver[i].csize, SEEK_CUR);  // skip D blocks
      int64_t end=sz;
      if (i+1<ver.size()) end=ver[i+1].offset;
      int64_t n=end-in.tell();
      if (copy(in, out, n)!=n) error("EOF");  // copy H and I blocks
    }
    printUTF8(index);
    printf(" -> %s\n", migliaia(out.tell()));
    out.close();
    return 0;
  }

///printf("ZE\n");

  // Label files to extract with data=0.
  // Skip existing output files. If force then skip only if equal
  // and set date and attributes.
  ExtractJob job(*this);
  int total_files=0, skipped=0;
  int tobeerased=0,erased=0;
  int real_dirs=0;
  uint32_t crc32fromfile;
	int kollision=0;

	if ((flagutf) || (flagflat) || flagfix255 || flagfixcase || (flagparanoid))
	{
/// we make a copy of the map (dt) into mymap, changing the filenames
/// wy do not in rename()? Because we need very dirty string manipulations

		printsanitizeflags();
		

		int64_t filesbefore=0;
		int64_t dirsbefore=0;
		
		if (flagdebug)
			for (DTMap::iterator p=dt.begin(); p!=dt.end(); ++p) 
			{
				if ((p->second.date && p->first!="") && (!isdirectory(p->first)))
					dirsbefore++;
				else
					filesbefore++;
			}
				
		DTMap mymap;
		int kollisioni=0;
		MAPPAFILEHASH mappacollisioni;
		for (DTMap::iterator p=dt.begin(); p!=dt.end(); ++p) 
		{
			string newname=sanitizzanomefile(p->first,filelength,kollisioni,mappacollisioni);
			/*macos*/
			auto ret=mymap.insert( std::pair<string,DT>(newname,p->second) );
			if (ret.second==false) 
				printf("18298: KOLLISION! %s\n",newname.c_str());
		}
		
		dt=mymap;
		
		if (flagdebug)
		{
			int64_t filesafter=0;
			int64_t dirsafter=0;
	
			for (DTMap::iterator p=dt.begin(); p!=dt.end(); ++p) 
			{
				if ((p->second.date && p->first!="") && (!isdirectory(p->first)))
					dirsafter++;
				else
					filesafter++;
			}
			
			printf("18181:size  before %12s\n",migliaia(dt.size()));
			printf("17995:Files before %12s\n",migliaia(filesbefore));
			printf("17996:dirs  before %12s\n",migliaia(dirsbefore));
			printf("\n\n");
			printf("18181:size  after  %12s\n",migliaia(dt.size()));
			printf("17995:Files before %12s\n",migliaia(filesafter));
			printf("17996:dirs  before %12s\n",migliaia(dirsafter));
		}
	///if (flagdebug)
	}
	
#ifdef _WIN32
	if (!flaglongpath)
		for (DTMap::iterator p=dt.begin(); p!=dt.end(); ++p) 
			if ((p->second.date && p->first!=""))
			{
				string filename=rename(p->first);
				if (filename.length()>254)
				{
					printf("WARN: path too long %03d ",(int)filename.length());
					printUTF8(filename.c_str());
					printf("\n");
				}
			}
#endif
	
	for (DTMap::iterator p=dt.begin(); p!=dt.end(); ++p) 
	{
		p->second.data=-1;  // skip
	    
		if (p->second.date && p->first!="") 
		{
			string fn=rename(p->first);
			const bool isdir=isdirectory(p->first);
			if (isdir)
				real_dirs++;
				
			string dummy="";
			if ((repack=="") && !flagtest && flagforce && !isdir && equal(p, fn.c_str(),crc32fromfile,"","",dummy)) 
			{
				// identical
				if (flagverbose)
				{
					printf("= ");
					printUTF8(fn.c_str());
					printf("\n");
				}
				close(fn.c_str(), p->second.date, p->second.attr);
				++skipped;
			}
			else 
			if ((repack=="") && !flagtest && !flagforce && exists(fn)) 
			{  
				// exists, skip
				if (flagverbose)
				{
					printf("? ");
					printUTF8(fn.c_str());
					printf("\n");
				}
				++skipped;
			}
			else 
			if (isdir)  // update directories later
				p->second.data=0;
			else 
			if (block.size()>0) 
			{  // files to decompress
				p->second.data=0;
				unsigned lo=0, hi=block.size()-1;  // block indexes for binary search
				for (unsigned i=0; p->second.data>=0 && i<p->second.ptr.size(); ++i) 
				{
					unsigned j=p->second.ptr[i];  // fragment index
					if (j==0 || j>=ht.size() || ht[j].usize<-1) 
					{
						fflush(stdout);
						printUTF8(p->first.c_str(), stderr);
						fprintf(stderr, ": bad frag IDs, skipping...\n");
						p->second.data=-1;  // skip
						continue;
					}
					assert(j>0 && j<ht.size());
					if (lo!=hi || lo>=block.size() || j<block[lo].start
						|| (lo+1<block.size() && j>=block[lo+1].start)) 
					{
						lo=0;  // find block with fragment j by binary search
						hi=block.size()-1;
						while (lo<hi) 
						{
							unsigned mid=(lo+hi+1)/2;
							assert(mid>lo);
							assert(mid<=hi);
							if (j<block[mid].start) 
								hi=mid-1;
							else 
							(lo=mid);
						}
					}
					assert(lo==hi);
					assert(lo>=0 && lo<block.size());
					assert(j>=block[lo].start);
					assert(lo+1==block.size() || j<block[lo+1].start);
					unsigned c=j-block[lo].start+1;
					if (block[lo].size<c) block[lo].size=c;
					if (block[lo].files.size()==0 || block[lo].files.back()!=p)
						block[lo].files.push_back(p);
				}
				++total_files;
				job.total_size+=p->second.size;
				///printf("FACCIO QUALCOSA SU %s per size %d\n",fn.c_str(),p->second.size);
				if (!flagtest)
				if (fileexists(fn))
				{
					if (flagverbose)
					{
						printf("* ");
						printUTF8(fn.c_str());
						printf("\n");
					}
					tobeerased++;
					if (delete_file(fn.c_str()))
						erased++;
					else
					printf("************ HIGHLANDER FILE! %s\n",fn.c_str());
				}
				
			}
		}  // end if selected
	}  // end for

	if (!flagforce && skipped>0)
		printf("%08d ?existing files skipped (-force overwrites).\n", skipped);
	if (flagforce && skipped>0)
		printf("%08d =identical files skipped.\n", skipped);
	if (flagforce && tobeerased>0)
		printf("%08d !=different files to be owerwritten => erased %08d\n",tobeerased,erased);
	if (tobeerased!=erased)
		printf("**** GURU **** WE HAVE SOME HIGHLANDER!\n");
		
  // Repack to new archive
	if (repack!="") 
	{

    // Get total D block size
    if (ver.size()<2) error("cannot repack streaming archive");
    int64_t csize=0;  // total compressed size of D blocks
    for (unsigned i=0; i<block.size(); ++i) {
      if (block[i].bsize<1) error("empty block");
      if (block[i].size>0) csize+=block[i].bsize;
    }
	
    InputArchive in(archive.c_str(), password);

    // Open output
    if (!flagforce && exists(repack)) 
		error("repack output exists");
	
    delete_file(repack.c_str());
    char salt[32]={0};
    if (new_password) libzpaq::random(salt, 32);
    OutputArchive out(repack.c_str(), new_password, salt, 0);
    int64_t cstart=out.tell();

    // Write C block using first version date
    writeJidacHeader(&out, ver[1].date, -1, 1);
    int64_t dstart=out.tell();
///printf("ZJ\n");

    // Copy only referenced D blocks. If method then recompress.
    for (unsigned i=0; i<block.size(); ++i) {
      if (block[i].size>0) {
        in.seek(block[i].offset, SEEK_SET);
        copy(in, out, block[i].bsize);
      }
    }
    printf("Data %s -> ",migliaia(csize));
    csize=out.tell()-dstart;
    printf(" %s\n", migliaia(csize));

    // Re-create referenced H blocks using latest date
    for (unsigned i=0; i<block.size(); ++i) {
      if (block[i].size>0) {
        StringBuffer is;
        puti(is, block[i].bsize, 4);
        for (unsigned j=0; j<block[i].frags; ++j) {
          const unsigned k=block[i].start+j;
          if (k<1 || k>=ht.size()) error("frag out of range");
          is.write((const char*)ht[k].sha1, 20);
          puti(is, ht[k].usize, 4);
        }
        libzpaq::compressBlock(&is, &out, "0",
            ("jDC"+itos(ver.back().date, 14)+"h"
            +itos(block[i].start, 10)).c_str(),
            "jDC\x01");
      }
    }
///printf("ZK\n");

    // Append I blocks of selected files
    unsigned dtcount=0;
    StringBuffer is;
    for (DTMap::iterator p=dt.begin();; ++p) {
		///printf("ZK-1\n");

      if (p!=dt.end() && p->second.date>0 && p->second.data>=0) {
        string filename=rename(p->first);
        puti(is, p->second.date, 8);
        is.write(filename.c_str(), strlen(filename.c_str()));
        is.put(0);
		

        if ((p->second.attr&255)=='u') // unix attributes
				write715attr(is,p->second.attr,3);
		else 
		if ((p->second.attr&255)=='w') // windows attributes
				write715attr(is,p->second.attr,5);
		else 
			puti(is, 0, 4);  // no attributes

        puti(is, p->second.ptr.size(), 4);  // list of frag pointers
        for (unsigned i=0; i<p->second.ptr.size(); ++i)
          puti(is, p->second.ptr[i], 4);
      }
      if (is.size()>16000 || (is.size()>0 && p==dt.end())) {
        libzpaq::compressBlock(&is, &out, "1",
            ("jDC"+itos(ver.back().date)+"i"+itos(++dtcount, 10)).c_str(),
            "jDC\x01");
        is.resize(0);
      }
      if (p==dt.end()) break;
    }
///printf("ZL\n");

    // Summarize result
    printUTF8(archive.c_str());
    printf(" %s -> ", migliaia(sz));
    printUTF8(repack.c_str());
    printf(" %s\n", migliaia(out.tell()));

    // Rewrite C block
    out.seek(cstart, SEEK_SET);
    writeJidacHeader(&out, ver[1].date, csize, 1);
    out.close();
    return 0;
  }

	g_crc32.clear();
	
  // Decompress archive in parallel
	printf("Extracting %s bytes (%s) in %s files (%s folders) with %d threads\n",migliaia(job.total_size), tohuman(job.total_size),migliaia2(total_files), migliaia4(real_dirs),howmanythreads);
	
	if (!flagspace)
		if (tofiles.size()==1)
		{
			if (!saggiascrivibilitacartella(tofiles[0].c_str()))
			{
				printf("Cannot write on <<-to %s>>\n",tofiles[0].c_str());
				printf("Aborting. Use -space to bypass and enforcing.\n");
				error("Path seems not writeable");
			}
			#ifdef _WIN32
			if (!flaglongpath)
			#endif
			{
				
				int64_t spazio=getfreespace(tofiles[0]);
				if (spazio<job.total_size)
				{
					printf("Free space on <<-to %s>>\n",tofiles[0].c_str());
					printf("is      %21s\n",migliaia(spazio));
					printf("needed  %21s\n",migliaia(job.total_size));
					if (!isdirectory(tofiles[0]))
						printf("33646: -to is a single file, NOT a folder. Maybe you miss the final /?\n");
					printf("Aborting extraction. Use -space to bypass and enforcing.\n");
					error("Not enough free space");
				}
			}
		}
	
	vector<ThreadID> tid(howmanythreads);
	for (unsigned i=0; i<tid.size(); ++i) 
		run(tid[i], decompressThread, &job);

	
		///printf(	
  // Extract streaming files
	unsigned segments=0;  // count
	InputArchive in(archive.c_str(), password);
	///printf();
	
	if (in.isopen()) 
	{
		FP outf=FPNULL;
		////printf(");
		
		DTMap::iterator dtptr=dt.end();
		///printf(");
		for (unsigned i=0; i<block.size(); ++i) 
		{
			///printf(");
			if (block[i].usize<0 && block[i].size>0) 
			{
				///printf(");
				Block& b=block[i];
				try 
				{
					///printf();
					in.seek(b.offset, SEEK_SET);
					libzpaq::Decompresser d;
					d.setInput(&in);
					if (!d.findBlock()) 
						error("block not found");
					StringWriter filename;
					///printf();
		
					for (unsigned j=0; j<b.size; ++j) 
					{
						if (!d.findFilename(&filename)) 
							error("segment not found");
						d.readComment();

						// Start of new output file
						if (filename.s!="" || segments==0) 
						{
							unsigned k;
							///printf(");
					
							for (k=0; k<b.files.size(); ++k) 
							{  // find in dt
								if (b.files[k]->second.ptr.size()>0
									&& b.files[k]->second.ptr[0]==b.start+j
									&& b.files[k]->second.date>0
									&& b.files[k]->second.data==0)
								break;
							}
							if (k<b.files.size()) 
							{  // found new file
								///printf();
		
								if (outf!=FPNULL) 
									fclose(outf);
								
								outf=FPNULL;
								string outname=rename(b.files[k]->first);
								dtptr=b.files[k];
								lock(job.mutex);
									printf("> ");
									printUTF8(outname.c_str());
									printf("\n");

									///printf(");
			
									if (!flagtest) 
									{
										///printf();
										makepath(outname);
										///printf();
			  
										outf=fopen(outname.c_str(), WB);
										
										if (outf==FPNULL) 
										{
											printerr("18330",outname.c_str(),0);
										}
									}
								release(job.mutex);
							}
							else 
							{  // end of file
								if (outf!=FPNULL) 
									fclose(outf);
								outf=FPNULL;
								dtptr=dt.end();
							}
						}
			///printf("Z4\n");
            // Decompress segment
						libzpaq::SHA1 sha1;
						d.setSHA1(&sha1);
						OutputFile o(outf);
						d.setOutput(&o);
						d.decompress();

            ///printf("Z5\n");
            // Verify checksum
						char sha1result[21];
						d.readSegmentEnd(sha1result);
						if (sha1result[0]==1) 
						{
							if (memcmp(sha1result+1, sha1.result(), 20)!=0)
								error("checksum failed");
						}
						else 
						if (sha1result[0]!=0)
							error("unknown checksum type");
						++b.extracted;
						if (dtptr!=dt.end()) 
							++dtptr->second.data;
						filename.s="";
						++segments;
					}
				}
				catch(std::exception& e) 
				{
					lock(job.mutex);
					printf("Skipping block: %s\n", e.what());
					release(job.mutex);
				}
			}
		}
		if (outf!=FPNULL) 
			fclose(outf);
	}
	if (segments>0) 
		printf("%u streaming segments extracted\n", segments);

	///printf("Z6\n");

  // Wait for threads to finish
  for (unsigned i=0; i<tid.size(); ++i) join(tid[i]);
///printf("Z7\n");

  // Create empty directories and set file dates and attributes
  if (!flagtest) {
    for (DTMap::reverse_iterator p=dt.rbegin(); p!=dt.rend(); ++p) {
      if (p->second.data>=0 && p->second.date && p->first!="") {
        string s=rename(p->first);
        if (p->first[p->first.size()-1]=='/')
          makepath(s, p->second.date, p->second.attr);
        else if ((p->second.attr&0x1ff)=='w'+256)  // read-only?
          close(s.c_str(), 0, p->second.attr);
      }
    }
  }

	if (flagramdisk)
	{
		/// extract
		printf("\n");
		printf("RAM       %12s (heap memory used %s bytes)",tohuman(g_ramdisksize),migliaia(g_ramdisksize)); 
		printf("34079: writing from ramdisk to disk\n");
		int64_t startwrite=mtime();
		uint64_t expected=0;
		uint64_t written=0;
		for (DTMap::iterator p=dt.begin(); p!=dt.end(); ++p) 
		{
			string fn=rename(p->first);
			makepath(fn);
			if (!isdirectory(fn))
			{
				if (p->second.pramfile!=NULL)
				{
					printf("not dir %s\n",fn.c_str());
					expected+=(*p->second.pramfile).filesize;
					if (flagdebug)
						printf("34092: ramdisk-out  %12s %s\n",migliaia((*p->second.pramfile).filesize),fn.c_str());
					FP myfile=fopen(fn.c_str(), WB);
					int64_t	scritti=0;
					int64_t	n=1000000000;
					int64_t w=0;
					while (1)
					{
						int64_t dascrivere=(*p->second.pramfile).filesize-scritti;
						if (dascrivere>n)
							dascrivere=n;
						w=fwrite((*p->second.pramfile).data+scritti,1,dascrivere,myfile);
						scritti+=w;
						if (w!=n)
							break;
					}
		
					//size_t scritti=fwrite((*p->second.pramfile).data, 1, (*p->second.pramfile).filesize, myfile);
					written+=scritti;
					fclose(myfile);
				}
			}
		}
		double writetime=(1+mtime()-startwrite)*0.001;
		
		printf("34093: written %21s expected %21s time %f @ %s\n",migliaia(written),migliaia2(expected),writetime,migliaia3((written/writetime)));
		
	}
	
  unsigned extracted=0;

	if (!flagramdisk)
	{
		// Report failed extractions, plain old 715
		for (DTMap::iterator p=dt.begin(); p!=dt.end(); ++p) 
		{
			string fn=rename(p->first);
			if (p->second.data>=0 && p->second.date
				&& fn!="" && fn[fn.size()-1]!='/') 
			{
				++extracted;
				if (p->second.ptr.size()!=unsigned(p->second.data)) 
				{
					fflush(stdout);
					if (++errors==1)
						fprintf(stderr,"\nFailed (extracted/total fragments, file):\n");
					fprintf(stderr, "33783: UKONE %u/%u ",int(p->second.data), int(p->second.ptr.size()));
					printUTF8(fn.c_str(), stderr);
					fprintf(stderr, "\n");
				}
			}
		 }
	}
	if (kollision>0)
		printf("\nFilenames collisions %08d\n",(int)kollision);	

	if (errors>0) 
	{
		fflush(stdout);
		fprintf(stderr,"\nExtracted %s files (%s errors) using %s bytes x %d threads\n",
			migliaia(extracted), migliaia3(errors), migliaia4(job.maxMemory),
			int(tid.size()));
	}
  
  	if (flagfilelist)
		if (errors==0)
		{
			if (fileexists(kunfile))
			{
				FILE* myfile = freadopen(kunfile.c_str());
				if (myfile!=NULL)
				{
					char data[65536*16];
					int got=0;
					while ((got=fread(data,sizeof(char),sizeof(data),myfile)) > 0) 
						fwrite(data,1,got,stdout);
					fclose(myfile);
					delete_file(kunfile.c_str());
				}
			}
			else
			{
				printf("\n20543: Cannot work the filelist. Archive created without -filelist ?\n");
				errors=1;
			}
		}
		
	if (flagparanoid)
	{
		printf("\n\nFULL-extract hashing check (aka:paranoid)\n");
		int64_t	dimensionetotale=0;
		int		dalavorare=0;
		for (DTMap::iterator p=dt.begin(); p!=dt.end(); ++p) 
			if (p->second.date && p->first!="") 
			{
				string fn=rename(p->first);
				if (!isdirectory(fn))
				{
				if (fileexists(fn))
					if (p->second.hashtype!="")
					{
						dimensionetotale+=p->second.size;
						dalavorare++;
					}
				}
			}
	  
		int64_t inizio=mtime();
		int		uguali=0;
		int		diversi=0;
		int64_t lavorati=0;
					
		for (DTMap::iterator p=dt.begin(); p!=dt.end(); ++p) 
			if (p->second.date && p->first!="") 
			{
				string fn=rename(p->first);
				if (iszpaqfranzvirtualfile(p->first))
				{
					if (flagdebug)
					printf("33042: found a virtualfile %s\n",fn.c_str());
					if (fileexists(fn))
						delete_file(fn.c_str());
				}
				if (!isdirectory(fn))
					if (p->second.hashtype!="")
						if (fileexists(fn))			// no fakefile-dirs
						{
							uint32_t dummycrc;
					
							string hashfromfile=shash_calc_file(
							p->second.hashtype,
							fn.c_str(),
							false,				/// do not want CRC-32
							dummycrc,	
							inizio,				/// start time
							dimensionetotale,	/// total bytes
							lavorati);			/// done so far

							///hashfromfile="dummy";
							if (hashfromfile==p->second.hexhash)
							{
								uguali++;
								delete_file(fn.c_str());
							}
							else
							{
								diversi++;
								if (flagverbose)
									printf("!= from file %s from archive %s <<%s>>\n",hashfromfile.c_str(),p->second.hexhash.c_str(),fn.c_str());
							}
						}

			}
		if (dalavorare>0)
		{
			printf("Total bytes          %s\n",migliaia(dimensionetotale));
			printf("Bytes checked        %s\n",migliaia(lavorati));
			printf("Files to be checked  %08d\n",dalavorare);
			printf("Files ==             %08d\n",uguali);
			printf("Files !=             %08d\n",diversi);
			if ((dalavorare!=uguali) || (lavorati!=dimensionetotale))
			{
				printf("*** ERROR IN PARANOID EXTRACT CHECK! ***\n");
				errors=1;
			}
			removetempdirifempty(tofiles[0],true);
		}
  }
 /*
	if (flagramdisk)
		if (tofiles.size()==1)
			removetempdirifempty(tofiles[0],true);
*/
  return errors>0;
}



/////////////////////////////// list //////////////////////////////////

/// quanti==1 => version (>0)
/// quanti==0 => 0
/// else  => -1 multiple match
int Jidac::searchcomments(string i_testo,vector<DTMap::iterator> &filelist)
{
	unsigned int quanti=0;
	int versione=-1;
	filelist.clear();
	
	for (DTMap::iterator a=dt.begin(); a!=dt.end(); ++a) 
	{
		a->second.data='-';
		filelist.push_back(a);
	}
		   
	///VCOMMENT 00000002 seconda_versione:$DATA
	for (unsigned i=0;i<filelist.size();i++) 
	{
		DTMap::iterator p=filelist[i];
		if (isads(p->first))
		{
			string fakefile=p->first;
			myreplace(fakefile,":$DATA","");
			size_t found = fakefile.find("VCOMMENT "); 
			if (found != string::npos)
			{
				///printf("KKKKKKKKKKKKKKKKK <<%s>>\n",fakefile.c_str());
					
				string numeroversione=fakefile.substr(found+9,8);
//esx
	///			int numver=0; //stoi(numeroversione.c_str());
#ifdef ESX
	int numver=0;
#else
				
int numver=std::stoi(numeroversione.c_str());
#endif
				string commento=fakefile.substr(found+9+8+1,65000);
				if (i_testo.length()>0)
				{
					/*
					printf("COMMENTO %s\n",commento.c_str());
					printf("i_testo %s\n",i_testo.c_str());
					*/
					if (!stringcomparei(commento,i_testo))
						continue;
					/*
					size_t start_comment = commento.find(i_testo);
					if (start_comment == std::string::npos)
					continue;
				*/
				}
    			mappacommenti.insert(std::pair<int, string>(numver, commento));
				versione=numver;
				quanti++;
			}
		}
	}
	if (quanti==1)
		return versione;
	else
	if (quanti==0)
		return 0;
	else
		return -1;
	
}
int Jidac::enumeratecomments()
{
	getpasswordifempty();

	  // Read archive into dt, which may be "" for empty.
	int64_t csize=0;
	int errors=0;

	if (archive!="") 
		csize=read_archive(archive.c_str(),&errors,1); /// AND NOW THE MAGIC ONE!
	printf("\nVersion(s) enumerator\n");
	
	vector<DTMap::iterator> filelist;
	searchcomments(versioncomment,filelist);

	for (MAPPACOMMENTI::const_iterator p=mappacommenti.begin(); p!=mappacommenti.end(); ++p) 
			printf("%08d <<%s>>\n",p->first,p->second.c_str());

  
	for (DTMap::iterator p=edt.begin(); p!=edt.end(); ++p) 
	{
		DTMap::iterator a=dt.find(rename(p->first));
		if (a!=dt.end() && (true || a->second.date)) 
		{
			a->second.data='-';
			filelist.push_back(a);
		}
		p->second.data='+';
		filelist.push_back(p);
	}
  
	for (DTMap::iterator a=dt.begin(); a!=dt.end(); ++a) 
		if (a->second.data!='-' && (true || a->second.date)) 
		{
			a->second.data='-';
			filelist.push_back(a);
		}
  
	if (all)
	{
		printf("-------------------------------------------------------------------------\n");
		printf("< Ver  > <  date  > < time >  < added > <removed>    <    bytes added   >\n");
		printf("-------------------------------------------------------------------------\n");
		for (unsigned fi=0;fi<filelist.size() /*&& (true || int(fi)<summary)*/; ++fi) 
		{
			DTMap::iterator p=filelist[fi];
			unsigned v;  
			if (p->first.size()==all+1u && (v=atoi(p->first.c_str()))>0 && v<ver.size()) 
			{
				printf("%08u %s ",v,dateToString(p->second.date).c_str());
				printf(" +%08d -%08d -> %20s", ver[v].updates, ver[v].deletes,
					migliaia((uint64_t)((v+1<ver.size() ? ver[v+1].offset : csize)-ver[v].offset+0.0)));
		
				std::map<int,string>::iterator commento;
				commento=mappacommenti.find(v); 
				if(commento!= mappacommenti.end()) 
					printf(" <<%s>>", commento->second.c_str());
				printf("\n");
			}
		}
	}

	return 0;		   
}


// no to_string on old gcc
string myto_string(int64_t i_number)
{
	char buffer[100];
	sprintf(buffer,"%lld",(long long)i_number);
	string risultato=buffer; // explicit converting
	return risultato;
}


int Jidac::kill() 
{
	getpasswordifempty();

	printf("KILL of:");

	if (files.size()<=0)
		return -1;
	if (archive=="")
		return -1;
		

	read_archive(archive.c_str());

  // Read external files into edt
	///uint64_t howmanyfiles=0;
	
	g_bytescanned=0;
	g_filescanned=0;
	g_worked=0;
	files_count.clear();
	edt.clear();
	

	
	///string cartellaoutput=append_path(tofiles[0], files[0]);
	string cartellaoutput=tofiles[0];
	/*
	printf("FILES %s\n",files[0].c_str());
	printf("TOFILES %s\n",tofiles[0].c_str());
	printf("cartellaoutput  %s\n",cartellaoutput.c_str());
*/
	scandir(false,edt,cartellaoutput);
	if (edt.size()) 
		printf("Total files found: %s\n", migliaia(edt.size()));
	else	
	{
		printf("Found nothing in filesystem\n");
		return 1;
	}
	printf("\n");
	
	vector<string> inzpaqrinominato;
	vector<string> tobekilled;
	vector<string> dirtobekilled;
	
	for (DTMap::iterator a=dt.begin(); a!=dt.end(); ++a) 
	{
		string dentrofile=a->first;
		myreplace(dentrofile,files[0],tofiles[0]);
		if (a->second.date==0)
		{
			if (flagverbose)
				printf("DELETED ");
		}
		else
			inzpaqrinominato.push_back(dentrofile);
		if (flagverbose)
			printf("Into zpaq %s  > renamed %s\n",a->first.c_str(),dentrofile.c_str());
	}

	std::sort(inzpaqrinominato.begin(), inzpaqrinominato.end());

	uint64_t		sizetobekilled=0;
	for (DTMap::iterator a=edt.begin(); a!=edt.end(); ++a) 
		if (binary_search(inzpaqrinominato.begin(),inzpaqrinominato.end(),a->first)==false)
		{
			if (isdirectory(a->first))
				dirtobekilled.push_back(a->first);
			else
			{
				tobekilled.push_back(a->first);
				sizetobekilled+=a->second.size;
			}
		}
	for (unsigned int i=0;i<dirtobekilled.size();i++)
	{
		printf("Dir  to be killed ");
		printUTF8(dirtobekilled[i].c_str());
		printf("\n");
	
	}
	for (unsigned int i=0;i<tobekilled.size();i++)
	{
		printf("File to be killed ");
		printUTF8(tobekilled[i].c_str());
		printf("\n");
	}
	
	printf("\n");
	
	unsigned int 	totaltobekilled=dirtobekilled.size()+tobekilled.size();
	if (totaltobekilled==0)
	{
		printf("Nothing to do\n");
		return 0;
	}
	printf("Directories to be removed %s\n",migliaia(dirtobekilled.size()));
	printf("Files       to be removed %s (%s bytes)\n",migliaia2(tobekilled.size()),migliaia(sizetobekilled));
#ifdef ESX
	string captcha="KILL";
#else	
	string captcha="kilL"+myto_string(dirtobekilled.size()+tobekilled.size()+sizetobekilled);
#endif

	printf("Captcha to continue %s\n",captcha.c_str());
	char myline[81];
    int dummy=scanf("%80s", myline);
	if (dummy==888888)
		printf("no-warning-please\n");
	
	if (myline!=captcha)
	{
		printf("Wrong captcha\n");
		return 1;
	}
	printf("Captcha OK\n");
	
	unsigned int killed=0;
	unsigned int killeddir=0;

	for (unsigned int i=0;i<tobekilled.size();i++)
		if (delete_file(tobekilled[i].c_str()))
				killed++;
	
/// OK iterating instead of recursing
	while (killeddir!=dirtobekilled.size())
		for (unsigned int i=0;i<dirtobekilled.size();i++)
			if (delete_dir(dirtobekilled[i].c_str()))
				killeddir++;

	printf("Dir  to be removed %s -> killed %s\n",migliaia(dirtobekilled.size()),migliaia2(killeddir));
	printf("File to be removed %s -> killed %s\n",migliaia(tobekilled.size()),migliaia2(killed));
	if ((killeddir+killed)!=(dirtobekilled.size()+tobekilled.size())) 
	{	
		printf("FAILED !! some highlander !!\n");
		return 1;
	}
	
	return 0;
	
}

/*

	section: multithread
*/
struct tparametrihash
{
	vector<string> 	o_hashcalculated;
	
	vector<string> 	originalfilenames;
	vector<string> 	filestobehashed;
	vector<string> 	filehash;
	vector<string> 	algo;
	
	uint64_t		timestart;
	uint64_t		timeend;
	int64_t			inizio;
	int64_t 		dimensione;
	int				tnumber;
};

void * scansionahash(void *t) 
{
	assert(t);
	tparametrihash* par= ((struct tparametrihash*)(t));
	vector<string>& tmpfilestobehashed	= par->filestobehashed;
	vector<string>& tmpalgo				= par->algo;
	if (tmpfilestobehashed.size()!=tmpalgo.size())
	{
		printf("51569: FILETOBEHASHED != ALGO\n");
		exit(0);
	}
	vector<string>& tmphashcalculated	= par->o_hashcalculated;
		
	for (unsigned int i=0;i<tmpfilestobehashed.size();i++)
	{
		uint32_t dummycrc;
		tmphashcalculated.push_back(hash_calc_file(string2algo(tmpalgo[i]),tmpfilestobehashed[i].c_str(),false,dummycrc,par->inizio,par->dimensione,g_dimensione));
		///tmphashcalculated.push_back(hash_calc_file(flag2algo(),tmpfilestobehashed[i].c_str(),false,dummycrc,par->inizio,par->dimensione,g_dimensione));
		///printf("INIZIO %lld dimensione %lld lavora %lld\n",par->inizio,par->dimensione,g_dimensione);
	}
	pthread_exit(NULL);
	return 0;
}


bool ischecksum()
{
	return (flagcrc32 || flagcrc32c || flagxxh3 || flagxxhash64 || flagsha1 || flagsha256 || flagblake3 || flagwyhash || flagwhirlpool || flagmd5 || flagnilsimsa || flagsha3 || flagentropy);
}	
int Jidac::deduplicate() 
{
	printf("*** DIRECTLY DELETE DUPLICATED FILES ***\n");
	if (files.size()==0)
	{
		printf("Sorry, works only on exactly 1 dir\n");
		return 1;
	}
	if (files.size()>1)
	{
		printf("Sorry, works only on exactly 1 dir\n");
		return 1;
	}
	if (!isdirectory(files[0]))
	{
		printf("Sorry, you must enter a directory\n");
		return 1;
	}
	if (flagverbose)
	summary=-1;
	else
	summary=1;
	flagchecksum=false;
	flagverify=true;
	
	if (!ischecksum())
		flagxxh3=true;
	flagkill=true;
	
	if (!flagforce)
		printf("-force not present: dry run\n");
	return summa();
}

struct tparametribenchmark
{
	int 		chunksize;		// no big data :-)
	uint32_t* 	buffer32bit;
	int			timelimit;
	string		runningalgo;
	int			tnumber;
	
	string		risultato;
	double		speed;
};

string do_benchmark(int i_tnumber,int i_timelimit,string i_runningalgo,int i_chunksize,uint32_t* buffer32bit,double& o_speed)
{
	
	int64_t lavorati=0;
	uint64_t starttutto=mtime();	

	uint64_t totalrandtime=0;
	uint64_t totalhashtime=0;
	int	ultimotrascorso=0;	
	int	buffersize=i_chunksize*4-7;
	
	int i=0;
	while (1)
	{
		uint64_t startrandom=mtime();
		populateRandom_xorshift128plus(buffer32bit, i_chunksize,324+i,4444+i);
		uint64_t randtime=mtime()-startrandom;
		
			
		if (i_runningalgo=="XXH3")
		{
			XXH3_state_t state128;
			(void)XXH3_128bits_reset(&state128);
			(void)XXH3_128bits_update(&state128, buffer32bit, buffersize);
		}
		else
		if (i_runningalgo=="SHA-1")
		{
			libzpaq::SHA1 sha1;
			sha1.write((const char*)buffer32bit,buffersize);
		}
		else
		if (i_runningalgo=="SHA-256")
		{
			franzSHA256 mysha256;
			mysha256.update((const uint8_t*)buffer32bit,buffersize);
		}
		else
		if (i_runningalgo=="WYHASH")
		{
			uint64_t _wyp[4];
			make_secret(0,_wyp);
			wyhash((const char*)buffer32bit,buffersize,0,_wyp);
		}
		else
		if (i_runningalgo=="MD5")
		{
			MD5 md5;
    		md5.add((const char*)buffer32bit,buffersize);
		}
		else
		if (i_runningalgo=="SHA-3")
		{
			SHA3 sha3;
    		sha3.add((const char*)buffer32bit,buffersize);
		}
		else
		if (i_runningalgo=="WHIRLPOOL")
		{
				NESSIEstruct hasher;
				NESSIEinit(&hasher);
				NESSIEadd((const unsigned char*)buffer32bit,buffersize*8,&hasher);
		}
		else
		if (i_runningalgo=="BLAKE3")
		{
			blake3_hasher hasher;
			blake3_hasher_init(&hasher);
			blake3_hasher_update(&hasher, (const char*)buffer32bit,buffersize);
		}
		else
		if (i_runningalgo=="CRC-32")
		{
			uint32_t crc=0;
			crc=crc32_16bytes ((const char*)buffer32bit,buffersize, crc);
		}
		else
		if (i_runningalgo=="CRC-32C")
		{
			uint32_t crc=0;
			crc = crc32c(crc, (const unsigned char*)buffer32bit,buffersize);
		}
		else
		if (i_runningalgo=="XXHASH64")
		{
			uint64_t myseed = 0;
			XXHash64 myhash(myseed);
			myhash.add((const unsigned char*)buffer32bit,buffersize);
		}
		
		
		totalhashtime=mtime()-starttutto-randtime;

		if (totalhashtime<=0)
			totalhashtime=1;

		lavorati+= (i_chunksize*4);
	

		totalrandtime	+=randtime;
		
		double hashingtime=totalhashtime/1000.0;
		o_speed=lavorati/hashingtime;

		
		int trascorso=(int)((mtime()-starttutto+1)/1000.0);
		
		if (trascorso!=ultimotrascorso)
		{
			if (i_tnumber<0) /// not a pthread
			{
				printf("%03d s %12s: speed (%11s/s) ",trascorso,i_runningalgo.c_str(),
				tohuman3((uint64_t)o_speed));
				
				if (flagverbose)
					printf("\n");
				else
					printf("\r");
			}
			else
			{
				pthread_mutex_lock(&g_mylock);		
				setupConsole();
				printf("\033[%d;0H",(int)i_tnumber+1);
				restoreConsole();
				printf("Thread %02d %03d s %12s: speed (%11s/s)",i_tnumber,trascorso,i_runningalgo.c_str(),tohuman3((uint64_t)o_speed));
				pthread_mutex_unlock(&g_mylock);	
			}
			ultimotrascorso=trascorso;
		}
		if ((int)((mtime()-starttutto)/1000)>=i_timelimit)
			break;
		i++;
	}
	
	double hashingtime=totalhashtime/1000.0;
	o_speed=lavorati/hashingtime;
	lavorati+=mtime()-starttutto;
	
	int trascorso=(int)((mtime()-starttutto+1)/1000.0);
	printf("%08d s %12s: speed (%11s/s) ",trascorso,i_runningalgo.c_str(),tohuman3((uint64_t)o_speed));
	printf("\n");
	
	char buf[100];
	sprintf(buf,"%12s: %11s/s (done %11s)",i_runningalgo.c_str(),tohuman((uint64_t)o_speed),tohuman2((uint64_t)lavorati));
	string risultato=buf;
	return risultato;
}
void * benchmark_thread(void *t) 
{
	assert(t);
	tparametribenchmark* par= ((struct tparametribenchmark*)(t));
	
	par->risultato=do_benchmark(par->tnumber,par->timelimit,par->runningalgo,par->chunksize,par->buffer32bit,par->speed);
	pthread_exit(NULL);
	return 0;
}

struct s_benchmark
{
    string	algoritmo;
	double	speed;
	string 	risultati;
};

bool compare_s_benchmark(const s_benchmark &a, const s_benchmark &b)
{
    return a.speed < b.speed;
}

string filecopy(bool i_singlefile,bool i_append,string i_infile,string i_outfile,bool i_verify,bool i_donotcheckspace,bool i_overwrite)
{
	if ((i_infile)=="")
		return "";
		
	if ((i_outfile)=="")
		return "";

	string nowarn;
	if (i_append)
		nowarn="NO-WARN";
		
		
	string percorso=i_outfile;
	
	if (i_singlefile)
		percorso=extractfilepath(i_outfile);
	
	if (!isdirectory(percorso))
		percorso+="/";

	if (!direxists(percorso))
		makepath(percorso);
	
	int64_t dimensionedacopiare	=prendidimensionefile(i_infile.c_str());
	
	if (!i_donotcheckspace)
	{
		int64_t spaziolibero	=getfreespace(percorso);
		if (spaziolibero<dimensionedacopiare)
		{
			printf("34878: impossible to make a copy of %s insufficient free space %s on <<%s>>\n",migliaia(dimensionedacopiare),migliaia2(spaziolibero),percorso.c_str());
			return "";
		}
	}
	
	string solofile=extractfilename(i_infile);
	string filedefinitivo=percorso+solofile;
	if (i_singlefile)
			filedefinitivo=i_outfile;
	
	if (!i_overwrite)
	{
		if (flagdebug)
			printf("Pre not overwrite %s\n",filedefinitivo.c_str());
		
		filedefinitivo=nomefileseesistegia(filedefinitivo);
		
		if (flagdebug)
			printf("Post not overwrite %s\n",filedefinitivo.c_str());
		
	}
	if (flagdebug)
		printf("ready to make a copy in %s\n",filedefinitivo.c_str());
		
	int64_t	lunghezzadefinitivo=0;
	/*
	if (fileexists(filedefinitivo))
		if (i_append)
		{
			printf("Proverei un append\n");
			lunghezzadefinitivo=prendidimensionefile(filedefinitivo.c_str());
			
			if (dimensionedacopiare<lunghezzadefinitivo)
				lunghezzadefinitivo=0; /// overwrite
		}
*/
	FILE* outFile=NULL;	
#ifdef _WIN32
	wstring widename=utow(filedefinitivo.c_str());
	if (lunghezzadefinitivo>0)
	outFile=_wfopen(widename.c_str(), L"ab" );
	else
	outFile=_wfopen(widename.c_str(), L"wb" );
#else
	if (lunghezzadefinitivo>0)
	outFile=fopen(filedefinitivo.c_str(), "ab");
	else
	outFile=fopen(filedefinitivo.c_str(), "wb");
#endif

	if (outFile==NULL)
	{
		printf("32827 :CANNOT OPEN outfile %s\n",filedefinitivo.c_str());
		return "";
	}
	size_t const blockSize = 65536;
	unsigned char buffer[blockSize];
	int64_t donesize=0;

	XXH3_state_t state128;
    (void)XXH3_128bits_reset(&state128);
	if (i_verify)
		if (flagverbose)
			printf("verify: trust, but check...\n");
		
	
	FILE* inFile = freadopen(i_infile.c_str());
	if (inFile==NULL) 
	{
#ifdef _WIN32
	int err=GetLastError();
#else
	int err=1;
#endif
	printf("\32849: ERR <%s> kind %d\n",i_infile.c_str(),err); 
	if (outFile!=NULL)
		fclose(outFile);
	
	return "";
	}
	
	/*
	if (lunghezzadefinitivo>0)
		inFile.seek(lunghezzadefinitivo, SEEK_SET);
	*/
		
	size_t readSize;
	int64_t	chunk_readed=0;
	int64_t	chunk_written=0;
	int64_t startcopy=mtime();
	bool	hostampato=false;
	while ((readSize = fread(buffer, 1, blockSize, inFile)) > 0) 
	{
		int64_t written=fwrite(buffer,1,readSize,outFile);
		chunk_written+=written;
		chunk_readed+=readSize;
		donesize+=written;
		if (lunghezzadefinitivo==0) /// the append case
			if (flagverify)
				(void)XXH3_128bits_update(&state128, buffer, readSize);
		if (!flagnoeta)
			hostampato |= myavanzamentoby1sec(donesize,dimensionedacopiare,startcopy,false);
	}
	if (hostampato)
		printf("                                                                         \r");

	fclose(inFile);
	fclose(outFile);
	if (flagdebug)
	{
		printf("Done\n");
		printf("Written  %20s\n",migliaia(donesize));
		printf("Expected %20s\n\n",migliaia(dimensionedacopiare));
	}
	
	if (donesize!=dimensionedacopiare)
	{
		printf("32876: GURU bytes written does not match expected\n");
		return "";
	}
	if (flagverify)
	{
		if (!flagnoeta)
		{
			printbar('=');
			printf("Checking ...\n");
		}
		XXH128_hash_t myhash=XXH3_128bits_digest(&state128);
		char risultato[33];
		sprintf(risultato,"%016llX%016llX",(unsigned long long)myhash.high64,(unsigned long long)myhash.low64);
		
		uint32_t dummycrc32;
		int64_t startverify=mtime();
		int64_t io_lavorati=0;
		string hashreloaded=xxhash_calc_file(filedefinitivo.c_str(),false,dummycrc32,startverify,dimensionedacopiare,io_lavorati);
		if (flagdebug)
		{
			printf("Expected   XXH3 hash of the output file %s\n",risultato);
			printf("Calculated XXH3 hash of the output file %s\n",hashreloaded.c_str());
		}
		if (hashreloaded!=risultato)
		{
			printf("29658: GURU hash of output file does not match!\n");
			return "";
		}
	}
	return filedefinitivo;
}

int Jidac::trim()
{
	
	if (files.size()!=1)
	{
		printf("33679: TRIM works with ONLY one single .zpaq file (no multipart)\n");
		return 2;
	}
	if (tofiles.size()>1)
	{
		printf("33856: TROM -to with only ONE output, please\n");
		return 2;
	}
	
	archive=files[0];  // append ".zpaq" to archive if no extension
	if (!iszpaq(archive))
			archive+=".zpaq";

	printf("TRIMMING on %s\n",archive.c_str());
	int64_t archivesize=prendidimensionefile(archive.c_str());
	
	getpasswordifempty();

  // Read archive or index into ht, dt, ver.
	int errors=0;
	string arcname=archive;  // input archive name
	if (index) 
		arcname=index;
	int64_t header_pos=0;
	if (exists(subpart(arcname, 1).c_str()))
		header_pos=read_archive(arcname.c_str(), &errors);

  // Set arcname, offset, header_pos, and salt to open out archive
	arcname=archive;  // output file name
  
	int64_t offset=0;  // total size of existing parts
	char salt[32]={0};  // encryption salt
	if (password) 
		libzpaq::random(salt, 32);

  // Remote archive
	if (index) 
		error("33709: cannot trim with an index");
	
    string part0=subpart(archive, 0);
    if (part0!=archive) 
	{  // multi-part?
		printf("34084: so sorry, this seems a multipart archive, abort\n");
		return 2;
    }

    // Get salt from first part if it exists
    if (password) {
      FP fp=fopen(subpart(archive, 1).c_str(), RB);
      if (fp==FPNULL) {
        if (header_pos>32) error("archive first part not found");
        header_pos=32;
      }
      else {
        if (fread(salt, 1, 32, fp)!=32) error("cannot read salt");
        fclose(fp);
      }
    }
  
	if (!exists(arcname))
	{
		printf("33763: archive does not seems to exists ");
		printUTF8(arcname.c_str());
		printf("\n");
        ///fclose(fp);
		return 2;
	}
	if (header_pos+offset>archivesize)
	{
		printf("33771: invalid offset %s vs filesize %s\n",migliaia(header_pos+offset),migliaia2(archivesize));
        ///fclose(fp);
		return 2;
	}
	if (header_pos+offset==archivesize)
	{
		printf("33779: TRIM seems not necessary on size %s\n",migliaia(header_pos+offset));
        ///fclose(fp);
		return 1;
	}
	
	
	if (tofiles.size()==1)
	{
		string	trimmeddestination=tofiles[0];
		if (isdirectory(trimmeddestination))
		{
			printf("33962: error -to is a folder, must be a file\n");
			return 2;
		}
		if (!iszpaq(trimmeddestination))
			trimmeddestination+=".zpaq";

		if (!flagforce)
			if (!saggiascrivibilitacartella(trimmeddestination))
			{
				printf("33700: sorry -to folder seems not writeable. Use -force to bypass\n");
				return 2;
			}

		int64_t spaziolibero=0;
		spaziolibero=getfreespace(trimmeddestination);
		if (spaziolibero<archivesize)
		{
			printf("\n");
			printbar('*');
			printf("WARNING FREE SPACE SEEMS %s NEEDED %s\n",migliaia(spaziolibero),migliaia2(archivesize));
			printbar('*');
		}
		
		printf("DOING COPY (before trimming)\n");
		
		string risultato;

		risultato=filecopy(
		true, // singlefile
		false, // append
		archive,trimmeddestination,
		flagverify, //verify
		true,  //donocheckspace
		false ///overwrite
		); //overwrite
		if (risultato=="")
		{
			printf("33729: ERROR: %s\n",risultato.c_str());
			return 2;
		}

		arcname=risultato;
	}

	printf("Trim ");
	printUTF8(arcname.c_str());
	printf(" at offset %s + %s\n", migliaia(header_pos), migliaia2(offset));
				
	
	if ((tofiles.size()==0) && (!flagkill))
	{
		printf("33783: dry run without -to: -kill to execute in-place\n");
		return 1;
	}
		
	if (truncate(arcname.c_str(),header_pos+offset))
	{
		printf("33772: something wrong in trimming\n");
		return 2;
	}
	int64_t nuovadim=prendidimensionefile(arcname.c_str());
	if (nuovadim==(header_pos+offset))
	{
		printf("34019: DONE on ");
		printUTF8(arcname.c_str());
		printf(" (%s)\n",migliaia(nuovadim));
	}
	return 0;

}

/*

//	purgersync("\\\\10.0.0.119\\condivisioni\\Utenti\\MANUALI\\MANUALI TECNICI XLS\\.*.*");
	purgersync("\\\\10.0.0.119\\condivisioni\\Utenti\\*");
*/
int Jidac::purgersync()
{
	printf("PURGING RSYNC TEMPORARY FILES ");
	if (!flagkill)
			printf(" : DRY RUN (no -kill)");
	printf("\n");
	if (files.size()==0)
	{
		printf("No folder selected\n");
		return 1;
	}
	DTMap	myedt;
	
	for (unsigned int i=0;i<files.size();i++)
	{
		printf("SCAN FOLDER %02d ",i);
		printUTF8(files[i].c_str());
		printf("\n");
		scandir(false,myedt,files[i].c_str(),true);
	}
	
	printf("Files to be checked %s\n",migliaia(myedt.size()));
	int	erased=0;
	int tobeerased=0;
	for (DTMap::iterator p=myedt.begin(); p!=myedt.end(); ++p) 
	{
		string	filename=p->first;
		myreplaceall(filename,"\\","/");
		string percorso=extractfilepath(filename);
		filename=extractfilename(filename);
		int		lunghezza=filename.length();
		if (lunghezza>10)
		{
			if (filename[0]=='.')
				if (filename[lunghezza-7]=='.')
				{
					string estensionefinale=myright(filename,6);
					
					bool	spazzatura=true;
					for (unsigned int i=0;i<estensionefinale.length();i++)
					{
						if ((!isdigit(estensionefinale[i])) && (!isalpha(estensionefinale[i])))
						{
							spazzatura=false;
							break;
						}
								
					}
					if (spazzatura)
					{
						string senzaestensione=myleft(filename,filename.length()-7);
						string estensione=prendiestensione(senzaestensione);
						if ((estensione.length()>0) && (estensione.length()<=4))
						{
							string filetobepurged=percorso+filename;
#if defined (_WIN32)
							printf("del ");
#else
							printf("rm ");
#endif
							printf("\"");
							printUTF8(filetobepurged.c_str());
							printf("\"");
							printf("\n");
							tobeerased++;
							if (flagkill)
							{
								printf("Deleting...\n");
								if (delete_file(filetobepurged.c_str()))
										erased++;
							}
						}
					}
				}
		}
	}
	
	if (flagkill)
	{
		printf("Erased  %08d / %08d\n",erased,tobeerased);
		
		if (tobeerased==erased)
			return 0;
		else
			return 1;
	}	
	
	if (tobeerased>0)
		return 0;
	else
		return 2;
}
bool isfilesequal(string i_source,string i_destination,bool i_flagfast=false)
{
	if (i_source=="")
		return false;

	if (i_destination=="")
		return false;

	if ((isdirectory(i_source)) && (isdirectory(i_destination)))
		return true;

	if (!((   (!isdirectory(i_source)) && (!isdirectory(i_destination)) )))
		return false;

	if (!fileexists(i_source))
		return false;

	if (!fileexists(i_destination))
		return false;

	FILE* source_file = freadopen(i_source.c_str());
	if (source_file==NULL) 
	{
#ifdef _WIN32
		int err=GetLastError();
#else
		int err=1;
#endif
		printf("\n27547 ERR <%s> kind %d\n",i_source.c_str(),err); 
		return false;
	}

	
	fseeko(source_file, 0, SEEK_END);
	int64_t sorgente_dimensione=ftello(source_file);
	fseeko(source_file, 0, SEEK_SET);
	
	FILE* destination_file = freadopen(i_destination.c_str());
	if (destination_file==NULL) 
	{
#ifdef _WIN32
		int err=GetLastError();
#else
		int err=1;
#endif
		printf("\n27555 ERR <%s> kind %d\n",i_destination.c_str(),err); 
		fclose(source_file);
		return false;
	}
	fseeko(destination_file, 0, SEEK_END);
	int64_t destinazione_dimensione=ftello(destination_file);
	fseeko(destination_file, 0, SEEK_SET);
	
	if (i_flagfast)
	{
		if (sorgente_dimensione<destinazione_dimensione)
		{
			if (flagdebug)
					printf("32805: sorgente < destinazione\n");
			fclose(source_file);
			fclose(destination_file);
			return false;
		}
	}
	else
	{
		if (sorgente_dimensione!=destinazione_dimensione)
		{
			fclose(source_file);
			fclose(destination_file);
			return false;
		}
	}
	size_t const blockSize 			= 65536;
	unsigned char buffersource		[blockSize];
	unsigned char bufferdestination	[blockSize];
	size_t readsource;
	size_t readdestination;
	if ((uint64_t)sorgente_dimensione<blockSize*4)
		i_flagfast=false;
	
	
	if (i_flagfast)
	{
			if (flagdebug)
				printf("Do a fast check!\n");
			
			readsource 		= 	fread(buffersource, 		1, blockSize, source_file);
			readdestination	=	fread(bufferdestination, 	1, blockSize, destination_file);
			if (readsource!=readdestination)
			{
				if (flagdebug)
					printf("32823: head read source != read dest %s %s\n",migliaia(readsource),migliaia2(readdestination));
				fclose(source_file);
				fclose(destination_file);
				return false;
			}
			if (memcmp(buffersource, bufferdestination, readsource))
			{
				if (flagdebug)
					printf("32831: head failed mem compare\n");
				fclose(source_file);
				fclose(destination_file);
				return false;
			}
			
			fseeko(source_file, 		blockSize/2, SEEK_SET);
			fseeko(destination_file, 	blockSize/2, SEEK_SET);
	
			readsource 		= 	fread(buffersource, 		1, blockSize, source_file);
			readdestination	=	fread(bufferdestination, 	1, blockSize, destination_file);
			if (readsource!=readdestination)
			{
				if (flagdebug)
					printf("32844: body read source != read dest %s %s\n",migliaia(readsource),migliaia2(readdestination));
				fclose(source_file);
				fclose(destination_file);
				return false;
			}
			if (memcmp(buffersource, bufferdestination, readsource))
			{
				if (flagdebug)
					printf("32851: body failed mem compare\n");
				fclose(source_file);
				fclose(destination_file);
				return false;
			}
			
			
			
			
			fseeko(source_file, 		destinazione_dimensione-blockSize, SEEK_SET);
			fseeko(destination_file, 	destinazione_dimensione-blockSize, SEEK_SET);
	
			readsource 		= 	fread(buffersource, 		1, blockSize, source_file);
			readdestination	=	fread(bufferdestination, 	1, blockSize, destination_file);
			if (readsource!=readdestination)
			{
				if (flagdebug)
					printf("32867: tail read source != read dest %s %s\n",migliaia(readsource),migliaia2(readdestination));
				fclose(source_file);
				fclose(destination_file);
				return false;
			}
			if (memcmp(buffersource, bufferdestination, readsource))
			{
				if (flagdebug)
					printf("32874: tail failed mem compare\n");
				fclose(source_file);
				fclose(destination_file);
				return false;
			}
			
	}
	else
	{
		while ((readsource = fread(buffersource, 1, blockSize, source_file)) > 0) 
		{
			readdestination=fread(bufferdestination, 1, blockSize, destination_file);
			
			if (readsource!=readdestination)
			{
				///printf("27631: read source != read dest %s %s\n",migliaia(readsource),migliaia2(readdestination));
				fclose(source_file);
				fclose(destination_file);
				return false;
			}
		
			if (memcmp(buffersource, bufferdestination, readsource))
			{
			///	printf("27640: failed mem compare\n");
				fclose(source_file);
				fclose(destination_file);
				return false;
			}
	///		confrontatitotale+=readsource;
		}
	}
	fclose(source_file);
	fclose(destination_file);
	if (flagdebug)
			if (i_flagfast)
					printf("32929: fast files ==\n");
	return true;
}


int Jidac::mycopy()
{
	printf("Your friendly neighborhood cp/copy ");
	
	if (flagverify)
		printf(" without a trusting attitude (-verify) ");
	
	if (flagparanoid)
		printf(" no overwrite (-paranoid) ");
		
	printf("\n");
	if (files.size()==0)
	{
		printf("33433: No source files\n");
		return 2;
	}
	if (tofiles.size()!=1)
	{
		printf("33438: exactly one -to required\n");
		return 2;
	}

	string	todirectory=tofiles[0];
	if (!isdirectory(todirectory))
			todirectory+='/';

	if (!flagforce)
		if (!saggiascrivibilitacartella(todirectory))
		{
			printf("33493: sorry -to directory seems not writeable. Use -force to bypass\n");
			return 2;
		}

	vector<string> 	sourcelist;
	vector<int64_t> sourcesize;
	int64_t			totalsourcesize=0;
	for (unsigned int i=0;i<files.size();i++)
	{
		scandir(false,edt,files[i].c_str(),false);
		for (DTMap::iterator p=edt.begin(); p!=edt.end(); ++p) 
		{
			if (!isdirectory(p->first))
			{
				sourcelist.push_back(p->first);
				sourcesize.push_back(p->second.size);
				totalsourcesize+=p->second.size;
			}
		}
	}
	
	if (sourcelist.size()==0)
	{
		printf("33461: cannot build source file list\n");
		return 2;
	}
	
	int64_t spaziolibero=0;
	
	spaziolibero=getfreespace(todirectory);
	if (spaziolibero<totalsourcesize)
	{
		printf("\n");
		printbar('*');
		printf("WARNING FREE SPACE %s NEEDED %s\n",migliaia(spaziolibero),migliaia2(totalsourcesize));
		printbar('*');
		if (!flagspace)
		{
			printf("34794: quit because not enough space; -space to bypass\n");
			return 2;
		}
	}
		
	printf("         Space needed             Space free\n");
	bool		allok=true;
	int64_t		totalwritten=0;
	int			fileswritten=0;
	for (unsigned int i=0;i<sourcelist.size();i++)
	{
		string 	filesource	=sourcelist[i];
		int64_t	filesize	=sourcesize[i];
		spaziolibero=getfreespace(todirectory);
		
		printf("%21s  %21s  %s\n",migliaia(filesize),migliaia2(spaziolibero),filesource.c_str());
		
		string risultato;

		risultato=filecopy(
		false, // not a single file, but a folder as output
		flagappend, // append
		filesource,todirectory,
		flagverify, //verify
		true,  //donocheckspace
		!flagparanoid); //overwrite
		if (risultato=="")
		{
			printf("ERROR: %s\n",risultato.c_str());
			allok=false;
		}
		else
		{
			totalwritten+=prendidimensionefile(risultato.c_str());
			fileswritten++;
		}
	}
	printf("---------------------\n");
	printf("%21s   bytes written\n",migliaia(totalwritten));
	printf("%21s   bytes expected\n",migliaia(totalsourcesize));
	
	printf("%21s   files OK\n",migliaia(fileswritten));
	printf("%21s   files expected\n",migliaia(sourcelist.size()));
	
	if (totalwritten!=totalsourcesize)
	{
		printf("33497: Written %s != expected %s\n",migliaia(totalwritten),migliaia2(totalsourcesize));
		allok=false;
	}
	
	if (allok)
		return 0;
	else	
		return	2;
}





/*
	This function is rather tricky: report the "just about free" memory of the system.
	It depends on both the operating system and the compiler (and architecture)
	
	It is needed for the -ramdisk switch
	
	If you have compiling problems, for example because you are using a "strange" system, 
	just change the source code to return 0;
	
	As today tested on (64 bit)
	
	- Windows
	- FreeBSD
	- OpenBSD 6.6/7.1
	- Debian
	- Solaris 11
	- OmniOS
	- MacOS 11

	Thanks for testing on various Unixes to
	https://github.com/dertuxmalwieder
	
*/
#ifdef _WIN32
int64_t internal_getramdisksize()
{
	if (flagdebug)
		printf("Hello Windows\n");
	MEMORYSTATUSEX statex;
	statex.dwLength=sizeof(statex);
	if (GlobalMemoryStatusEx(&statex))
		return statex.ullAvailPhys;
	return 0;
}
#endif

#ifdef SOLARIS 
//this is a reworked m_sunos5.c machine-specific top source code
// need a -lkstat to build
#include <kvm.h>
#include <kstat.h>

int64_t internal_getramdisksize()
{
	if (flagdebug)
		printf("Hello Solaris\n");
	long freemem;
    static kstat_t 		*ks = NULL;
	kvm_t 				*kd;
	static kstat_ctl_t 	*kc = NULL;
    kstat_named_t 		*kn;

    /* total comes from sysconf */
    ///*freemem = sysconf(_SC_PHYS_PAGES);
	
	if ((kc=kstat_open()) == NULL)
		error("36416: unable to open kstat");
		
// Solaris compilers does not like some "direct assign", firing warnings
// So this seems ugly, but for a reason
	char	p_unix			[100];
	char	p_system_pages	[100];
	char	p_freemem		[100];
	sprintf(p_unix,"unix");
	sprintf(p_system_pages,"system_pages");
	sprintf(p_freemem,"freemem");
	
	ks = kstat_lookup(kc, p_unix, 0, p_system_pages);
	
	if (ks==NULL)
		error("36340: ks is null, quit");

	if (kstat_read(kc,ks,0)!=-1)
	{
		kn=(kstat_named_t*)kstat_data_lookup(ks, p_freemem);
		if (kn!=NULL)
			freemem=(long)(kn->value.ui32);
		else
			error("36440: guru on kstat lookup");
	}
	else
		error("36443: guru on kstat_read");
	
// yes, skip overflow on "strange" compilators. Slow, but who cares?
	int pagesize 			= getpagesize();
	int64_t big_pagesize 	= pagesize;
	int64_t big_freemem		= freemem;
	int64_t	big_ram	=big_freemem*big_pagesize;
	return big_ram;
}
#endif


#ifdef __OpenBSD__  // OpenBSD is not == FreeBSD.
int64_t internal_getramdisksize()
{

	if (flagdebug)
		printf("Hello OpenBSD\n");

	static int uvmexp_mib[] = {CTL_VM, VM_UVMEXP};
	struct uvmexp uvmexp;
	size_t size;
	size = sizeof(uvmexp);
	
	if (sysctl(uvmexp_mib, 2, &uvmexp, &size, NULL, 0) == -1) 
		error("36445 sysctl failed");
	
	int pagesize = getpagesize();
	
	// yes, skip overflow on "strange" compilators. Slow, but who cares?
	int64_t	big_pagesize	=pagesize;
	int64_t big_free		=uvmexp.free;
	int64_t	big_ram			=big_pagesize*big_free;

	return big_ram;
}
#endif


#ifdef __APPLE__ // Mac OS/X

#include <mach/mach.h>

int64_t internal_getramdisksize()
{
	if (flagdebug)
		printf("Hello Mac\n");

	kern_return_t	status;
	unsigned int count = HOST_VM_INFO_COUNT;
	static vm_statistics_data_t	vm_stats;

	status = host_statistics(mach_host_self(), HOST_VM_INFO,(host_info_t)&vm_stats, &count);

	if(status!=KERN_SUCCESS)
		error("36487:  vm_statistics() failed");
	
	int pagesize = getpagesize();
	
	int64_t	big_pagesize	=pagesize;
	int64_t big_free		=vm_stats.free_count;
	int64_t	big_ram			=big_pagesize*big_free;
	return big_ram;
}
#endif

#ifdef BSD  // FreeBSD 
#ifndef __OpenBSD__ 	// OpenBSD does not have sysctlbyname (yet)
#ifndef __APPLE__   	// Mac is different (of course)
int64_t internal_getramdisksize()
{
	if (flagdebug)
		printf("Hello FreeBSD\n");
	int pagesize	=0;
	int inactive	=0;
	int free		=0;
	size_t size 	= sizeof free;
	sysctlbyname("vm.stats.vm.v_free_count", &free, &size, NULL, 0);
	sysctlbyname("vm.stats.vm.v_inactive_count", &inactive, &size, NULL, 0);
	size = sizeof pagesize;
	sysctlbyname("vm.stats.vm.v_page_size", &pagesize, &size, NULL, 0);
	return (free+inactive)*pagesize;/// / 1024 ;
}
#endif
#endif
#endif


/// play old "file-like", should work in just about all flavours of Linux
#ifdef linux
int64_t internal_getramdisksize()
{
	if (flagdebug)
		printf("Hello Linux\n");
	
    FILE *meminfo = fopen("/proc/meminfo", "r");
    if(meminfo == NULL)
	{
		printf("43998: error, cannot open /proc/meminfo, maybe I am NOT running on Linux?\n");
		return 0;
	}

    char line[256];
    while(fgets(line, sizeof(line), meminfo))
    {
        int ram;
        if(sscanf(line, "MemTotal: %d kB", &ram) == 1)
        {
            fclose(meminfo);
            return ram*1024;
        }
    }
    fclose(meminfo);
    printf("44014: invalid /proc/meminfo format\n");
	return 0;
}
	
/*
///  More modern, but I do not like

#include <sys/sysinfo.h>

   int sysinfo(struct sysinfo *info);

   struct sysinfo {
       long uptime;             //// Seconds since boot /
       unsigned long loads[3];  //// 1, 5, and 15 minute load averages /
       unsigned long totalram;  //// Total usable main memory size /
       unsigned long freeram;   /// Available memory size /
       unsigned long sharedram; //// Amount of shared memory /
       unsigned long bufferram; //// Memory used by buffers /
       unsigned long totalswap; //// Total swap space size /
       unsigned long freeswap;  //// swap space still available /
       unsigned short procs;    //// Number of current processes /
       unsigned long totalhigh; //// Total high memory size /
       unsigned long freehigh;  //// Available high memory size /
       unsigned int mem_unit;   //// Memory unit size in bytes /
       char _f[20-2*sizeof(long)-sizeof(int)]; // Padding for libc5 
   };*/

#endif

int64_t getramdisksize()
{
	return internal_getramdisksize(); /// if you get an error HERE substitute with return 0;
	///return 0;
}
int contabit(unsigned int u)
{
	unsigned int uCount;
	uCount=u-((u >> 1) & 033333333333)-((u >> 2) & 011111111111);
	return ((uCount + (uCount >> 3)) & 030707070707) % 63;
}

int bittino(int i)
{
	i=~i;
	return contabit((i&(-i))-1);
}

string windows_get_free_letter()
{
#ifdef _WIN32
	DWORD unita=GetLogicalDrives();
	///1234567890123456789012345678
	///                   IHGFEDCBA
	///0010000010001111111010010100
	/*
	printf("unita  %08X\n",unita);
	printf("bittino %d\n",bittino(unita));
	*/
	char	unitalibera='A'+bittino(unita);
	///printf("Unita |%c|\n",unitalibera);
	//unitalibera='C';
	string s(1, unitalibera);
	string percorso=s+":/";
	if (getfreespace(percorso)==0)
		return s;
#endif
	return "";
}


#ifdef _WIN32
HRESULT ModifyPrivilege(
    IN LPCTSTR szPrivilege,
    IN BOOL fEnable)
{
    HRESULT hr = S_OK;
    TOKEN_PRIVILEGES NewState;
    LUID             luid;
    HANDLE hToken    = NULL;

    // Open the process token for this process.
    if (!OpenProcessToken(GetCurrentProcess(),
                          TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
                          &hToken ))
    {
        printf("Failed OpenProcessToken\n");
        return ERROR_FUNCTION_FAILED;
    }

    // Get the local unique ID for the privilege.
    if ( !LookupPrivilegeValue( NULL,
                                szPrivilege,
                                &luid ))
    {
        CloseHandle( hToken );
        printf("Failed LookupPrivilegeValue\n");
        return ERROR_FUNCTION_FAILED;
    }

    // Assign values to the TOKEN_PRIVILEGE structure.
    NewState.PrivilegeCount = 1;
    NewState.Privileges[0].Luid = luid;
    NewState.Privileges[0].Attributes = 
              (fEnable ? SE_PRIVILEGE_ENABLED : 0);

    // Adjust the token privilege.
    if (!AdjustTokenPrivileges(hToken,
                               FALSE,
                               &NewState,
                               0,
                               NULL,
                               NULL))
    {
        printf("Failed AdjustTokenPrivileges\n");
        hr = ERROR_FUNCTION_FAILED;
    }

    // Close the handle.
    CloseHandle(hToken);

    return hr;
}




/* NTFS reparse point definitions */

/* Constants from http://msdn.microsoft.com/en-us/library/dd541667.aspx */
/* Some, but not all, of them also defined in recent versions of winnt.h. */
/* All seem to come from NT DDK's ntifs.h, for installable file system drivers. */
/* Since the list varies a lot, redefine them one by one as needed */
/* Bit 31 = Tag owned by Microsoft
   Bit 30 = Reserved for Microsoft. Must be 0 for non-MS tags.
   Bit 29 = Surrogate bit. Points to another file of directory.
   Bit 28 = Directory bit. Any directory with this reparse tag can have children.
   Bits 16-27: Invalid and must be 0. */
/* Reparse tags, with the exception of IO_REPARSE_TAG_SYMLINK,
   are processed on the server and are not processed by a client after transmission over the wire. */
/* See https://github.com/prsyahmi/GpuRamDrive/blob/master/GpuRamDrive/3rdparty/inc/imdisk/ntumapi.h
   for a list of non-Microsoft reparse tags */


#define REPARSE_READ_BUFFER_HEADER_SIZE (sizeof(REPARSE_READ_BUFFER) - sizeof(UCHAR))

typedef struct _REPARSE_SYMLINK_READ_BUFFER { // For tag IO_REPARSE_TAG_SYMLINK
  DWORD  ReparseTag;
  WORD   ReparseDataLength;
  WORD   Reserved;
  WORD   SubstituteNameOffset;
  WORD   SubstituteNameLength;
  WORD   PrintNameOffset;
  WORD   PrintNameLength;
  ULONG  Flags;
  WCHAR  PathBuffer[1];
} SYMLINK_READ_BUFFER, *PSYMLINK_READ_BUFFER;
#define SYMLINK_READ_BUFFER_HEADER_SIZE (sizeof(SYMLINK_READ_BUFFER) - sizeof(WCHAR))

typedef struct _REPARSE_MOUNTPOINT_READ_BUFFER { // For tag IO_REPARSE_TAG_MOUNT_POINT, aka. junctions
  DWORD  ReparseTag;
  WORD   ReparseDataLength;
  WORD   Reserved;
  WORD   SubstituteNameOffset;
  WORD   SubstituteNameLength;
  WORD   PrintNameOffset;
  WORD   PrintNameLength;
  WCHAR  PathBuffer[1];
} MOUNTPOINT_READ_BUFFER, *PMOUNTPOINT_READ_BUFFER;
#define MOUNTPOINT_READ_BUFFER_HEADER_SIZE (sizeof(MOUNTPOINT_READ_BUFFER) - sizeof(WCHAR))

typedef struct _REPARSE_MOUNTPOINT_WRITE_BUFFER {
  DWORD  ReparseTag;
  DWORD  ReparseDataLength;
  WORD   Reserved;
  WORD   ReparseTargetLength;
  WORD   ReparseTargetMaximumLength;
  WORD   Reserved1;
  WCHAR  ReparseTarget[1];
} MOUNTPOINT_WRITE_BUFFER, *PMOUNTPOINT_WRITE_BUFFER;
#define MOUNTPOINT_WRITE_BUFFER_HEADER_SIZE (sizeof(MOUNTPOINT_WRITE_BUFFER) - sizeof(WCHAR))

// Universal Windows Platform (UWP) Application Execution Links
// Ref: https://www.tiraniddo.dev/2019/09/overview-of-windows-execution-aliases.html
typedef struct _REPARSE_APPEXECLINK_READ_BUFFER { // For tag IO_REPARSE_TAG_APPEXECLINK
  DWORD  ReparseTag;
  WORD   ReparseDataLength;
  WORD   Reserved;
  ULONG  Version;	// Currently version 3
  WCHAR  StringList[1];	// Multistring (Consecutive strings each ending with a NUL)
  /* There are normally 4 strings here. Ex:
	Package ID:	L"Microsoft.WindowsTerminal_8wekyb3d8bbwe"
	Entry Point:	L"Microsoft.WindowsTerminal_8wekyb3d8bbwe!App"
	Executable:	L"C:\Program Files\WindowsApps\Microsoft.WindowsTerminal_1.4.3243.0_x64__8wekyb3d8bbwe\wt.exe"
	Applic. Type:	l"0"	// Integer as ASCII. "0" = Desktop bridge application; Else sandboxed UWP application
  */     
} APPEXECLINK_READ_BUFFER, *PAPPEXECLINK_READ_BUFFER;

// LinuX Sub-System (LXSS) Symbolic Links
typedef struct _REPARSE_LX_SYMLINK_BUFFER {
  DWORD  ReparseTag;
  WORD	 ReparseDataLength;
  WORD	 Reserved;
  DWORD  FileType; 	// Value is apparently always 2 for symlinks.
  char   PathBuffer[1];	// POSIX path of symlink. UTF-8. Not \0 terminated.
} LX_SYMLINK_READ_BUFFER, *PLX_SYMLINK_READ_BUFFER;
#endif





int Jidac::benchmark()
{
	int64_t myram=getramdisksize();
	printf("RAM seems %s\n",migliaia(myram));
	
	vector<string> 	array_cpu;
	vector<float> 	array_single;
	vector<float> 	array_multi;
	
	array_cpu	.push_back("Atom N2800      (phy)  4");
	array_multi	.push_back(113);
	array_single.push_back(407);
	
	array_cpu	.push_back("Xeon E3 1245 V2 (vir)  4");
	array_multi	.push_back(819);
	array_single.push_back(2415);
	
	array_cpu	.push_back("i5-6200U        (phy)  2");
	array_multi	.push_back(352);
	array_single.push_back(1903);
	
	array_cpu	.push_back("Xeon E5 2620 V4 (phy)  8");
	array_multi	.push_back(1520);
	array_single.push_back(1848);
	
	array_cpu	.push_back("Xeon E5 2630 V4 (phy) 10");
	array_multi	.push_back(1596);
	array_single.push_back(1552);
	
	array_cpu	.push_back("Xeon D-1541     (vir)  8");
	array_multi	.push_back(1619);
	array_single.push_back(2031);

	array_cpu	.push_back("i5-3570         (phy)  4");
	array_multi	.push_back(852);
	array_single.push_back(2956);
	
	array_cpu	.push_back("i7-4790K        (phy)  4");
	array_multi	.push_back(1700);
	array_single.push_back(3265);
	
	array_cpu	.push_back("i7-8700K        (phy)  6");
	array_multi	.push_back(1836);
	array_single.push_back(3358);
	
	array_cpu	.push_back("i9-10900        (phy) 10");
	array_multi	.push_back(3049);
	array_single.push_back(3705);
	
	array_cpu	.push_back("AMD-5950X       (phy) 16");
	array_multi	.push_back(5843);
	array_single.push_back(4798);
	
	
	int			chunksize=100000;
	int			timelimit=5;
	
	if (all)
		timelimit=20;
		
	if (menoenne>0)
	{
		if (menoenne<1000)
			timelimit=menoenne;
		else
		{
			printf("Time limit (-n    -limit) must be <1000\n");
			return 1;
		}
	}
	if (minsize>0)
	{
		if (minsize<=2000000000)
			chunksize=minsize/4;
		else
		{
			printf("Chunk (-minsize) must be <= 2000000000 (2 billion)\n");
			return 1;
		}
	}
	uint32_t *buffer32bit = (uint32_t*)malloc(chunksize*sizeof(uint32_t));
	if (buffer32bit==0)
	{
		printf("21202: GURU cannot alloc the buffer32bit\n");
		return 1;
	}
	
	vector<string> thehashes;
	string hashes="";
	
	if (!ischecksum())
		hashes="XXHASH64;XXH3;SHA-1;SHA-256;BLAKE3;CRC-32;CRC-32C;WYHASH;WHIRLPOOL;MD5;SHA-3;NILSIMSA";
	else
	{
		if (flagxxhash64)
			hashes+="XXHASH64;";
		if (flagxxh3)
			hashes+="XXH3;";
		if (flagsha1)
			hashes+="SHA-1;";
		if (flagsha256)
			hashes+="SHA-256;";
		if (flagblake3)
			hashes+="BLAKE3;";
		if (flagcrc32)
			hashes+="CRC-32;";
		if (flagcrc32c)
			hashes+="CRC-32C;";
		if (flagwyhash)
			hashes+="WYHASH;";
		if (flagwhirlpool)
			hashes+="WHIRLPOOL;";
		if (flagmd5)
			hashes+="MD5;";
		if (flagnilsimsa)
			hashes+="NILSIMSA;";
		if (flagsha3)
			hashes+="SHA-3;";
	}
	explode(hashes,';',thehashes);
	if (thehashes.size()==0)
	{
		printf("27144: strange hash selection\n");
		free(buffer32bit);
		return 1;
	}

	if (all)
		if ((thehashes.size()!=1) && (thehashes.size()!=12))
		{
			printf("When benchmarking with -all (multithread), ONE algo or nothing (all)\n");
			free(buffer32bit);
			return 1;
		}
	
	vector<s_benchmark> 			vettorerisultati;     
	vector<tparametribenchmark> 	vettoreparametribenchmark; // pthread

	printf("Benchmarks: ");
	for (unsigned int i=0;i<thehashes.size();i++)
		printf("%s ",thehashes[i].c_str());
	printf("\n");
	printf("Time limit %10d s  (-n X)\n",timelimit);
	printf("Chunks of  %12s  (-minsize Y)\n",tohuman(chunksize*4));
	printf("\n");
	
	
	double			franzomips=0;
	
	if (all)
	{
		int mythreads=howmanythreads;
		tparametribenchmark	myblock;

		for (int i=0;i<mythreads;i++)
		{
			myblock.tnumber=i;
			myblock.chunksize=chunksize;
			myblock.buffer32bit=buffer32bit;
			myblock.timelimit=timelimit;
			if (thehashes.size()==12)
				myblock.runningalgo="SHA-3";
			else
				myblock.runningalgo=thehashes[0];
			vettoreparametribenchmark.push_back(myblock);
		}	

		int rc;
		pthread_t* threads = new pthread_t[mythreads];

		pthread_attr_t attr;
		void *status;

		// ini and set thread joinable
		pthread_attr_init(&attr);
		pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_JOINABLE);

///		printf("\nCreating %d hashing thread(s) with %s\n\n",mythreads,mygetalgo().c_str());

		setupConsole();
		printf("\033[2J"); //cls
		restoreConsole();
	
		for(int i = 0; i < mythreads; i++ ) 
		{	
			rc 	= pthread_create(&threads[i], &attr, benchmark_thread, (void*)&vettoreparametribenchmark[i]);
			if (rc) 
			{
				printf("Error creating thread\n");
				exit(-1);
			}
		}
	

		pthread_attr_destroy(&attr);
		for(int i = 0; i <mythreads; i++ ) 
		{
			rc = pthread_join(threads[i], &status);
			if (rc) 
			{
				error("Unable to join\n");
				exit(-1);
			}
		}
		
		setupConsole();
		printf("\033[2J"); //cls
		printf("\033[%d;0H",(int)1);
		restoreConsole();
		
		string 			risultato;
		s_benchmark		block;
		
		
		double total_speed=0;
		for (int i=0;i<mythreads;i++)
		{
			total_speed+=vettoreparametribenchmark[i].speed;
			franzomips+=vettoreparametribenchmark[i].speed;
		}
		
		printf("Total speed %s /s\n",tohuman((uint64_t)total_speed));

		if (thehashes.size()==12)
		{
			franzomips/=1000000;
			
			for (unsigned int i=0;i<array_cpu.size();i++)
				array_multi[i]=franzomips/array_multi[i]*100.0;
		}

		delete [] threads;
	}
	else
	{
/// NO pthread
		string 			risultato;
		double			speed;
		s_benchmark		block;
		
		for (unsigned int i=0;i<thehashes.size();i++)
		{
			risultato=do_benchmark(-1,timelimit,thehashes[i],chunksize,buffer32bit,speed);
			block.algoritmo=thehashes[i];
			block.speed=speed;
			block.risultati=risultato;
			vettorerisultati.push_back(block);
			if (thehashes[i]!="BLAKE3") // no HW implementation, please
				franzomips+=speed;
		}
		/// magic 3500 single 4875 (5885 multi
		if (thehashes.size()==12)
		{
			franzomips/=thehashes.size()-1;
			franzomips/=1000000;
			
			for (unsigned int i=0;i<array_cpu.size();i++)
				array_single[i]=franzomips/array_single[i]*100.0;
		}
		std::sort(vettorerisultati.begin(), vettorerisultati.end(), compare_s_benchmark);
		printf("\nResults:\n\n");
		
		for (unsigned int i=0;i<vettorerisultati.size();i++)
			printf("%s\n",vettorerisultati[i].risultati.c_str());
	}
	free(buffer32bit);
	///sysctl hw.model hw.machine hw.ncpu
	if (thehashes.size()==12)
	{			
		if (all)
			printf("\nfranzomips multi thread index %s ",migliaia((uint64_t)(franzomips*7.0)));
		else
			printf("\nfranzomips single thread index %s ",migliaia((uint64_t)franzomips));
			
		printf("(quick CPU check, raw %s)\n",migliaia((uint64_t)franzomips));
			
		for (unsigned int i=0;i<array_cpu.size();i++)
			if (all)
				printf("%s %10.2f %%\n",array_cpu[i].c_str(),array_multi[i]);
			else
				printf("%s %10.2f %%\n",array_cpu[i].c_str(),array_single[i]);			
	}
	return 0;
}
/*
46184

Single Thread Rating: 3499
*/

int Jidac::summa() 
{
#ifdef ESX
	return 0;
#else
	if (!flagpakka)
	{
		printf("Getting %s",mygetalgo().c_str());
		if (flagmm)
			printf(" WITH MEMORY MAPPED FILES ");
		if (!flagforcezfs)
			printf(" ignoring .zfs and :$DATA\n");
	}

	if (flagkill)
		if (flagforce)
			if (!getcaptcha("iamsure","Delete files without confirmation"))
				return 1;

	int quantifiles					=0;
	int64_t total_size				=0;  
	unsigned int duplicated_files	=0;
	uint64_t duplicated_size		=0;
	uint64_t scannedsize			=0;
	vector<string> myfiles;
	
	flagskipzfs					=true;  // strip down zfs
	int64_t startscan=mtime();
	
	g_bytescanned=0;
	g_filescanned=0;
	g_dimensione=0;
	g_worked=0;


	vector<string> mydirs;
	
	if (flagchecksum)
	{
		printf("Getting cumulative 1-level SHA256\n");
		if (files.size()!=1)
		{
			printf("Error: with -checksum exactly one directory can be searched\n");
			return 1;
		}
		uint64_t startscan=0;			
///		if (!isdirectory(files[0]))
	///		files[0]+="/";
		scandir(false,edt,files[0].c_str(),false);
		
		for (DTMap::iterator p=edt.begin(); p!=edt.end(); ++p) 
			if (p->first != files[0])
			{
			if (isdirectory(p->first))
				mydirs.push_back(p->first);
			else
				myfiles.push_back(p->first);
			}
		uint64_t scantime=mtime()-startscan;
		
		if (myfiles.size()+mydirs.size()==0)
		{
			printf("Nothing to do\n");
			return 0;
		}
		libzpaq::SHA256 sha256;
		libzpaq::SHA256 globalesha256;
	/*macos*/
		std::vector<std::pair<string, string>> vec;
		
		uint64_t hashtime=0;
		uint64_t printtime=0;
		uint64_t total_size=0;
		
		for (unsigned int i=0;i<mydirs.size();i++)
		{
			if (!flagnoeta)
				printf("Scanning %s\r",mydirs[i].c_str());
			edt.clear();
			startscan=mtime();
			scandir(true,edt,mydirs[i].c_str(),true);
			scantime+=mtime()-startscan;
			
			vec.clear();
			for (DTMap::iterator p=edt.begin(); p!=edt.end(); ++p) 
				if (!isdirectory(p->first))
				{
					startscan=mtime();
					uint32_t dummycrc;
					vec.push_back(make_pair("dummy",hash_calc_file(flag2algo(),p->first.c_str(),false,dummycrc,-1,-1,g_dimensione)));
					total_size+=p->second.size;
					hashtime+=mtime()-startscan;
				}
				
			std::sort(vec.begin(), vec.end(),sortbyval);

			for (unsigned int j=0;j<vec.size();j++)
				for (const char* p=vec[j].second.c_str(); *p; ++p) 
				{
					sha256.put(*p);
					globalesha256.put(*p);
				}

			scantime=mtime();
			char sha256result[32];
			memcpy(sha256result, sha256.result(), 32);
			myprintf("MAGIC_%s: ",mygetalgo().c_str());
			for (int j=0; j <= 31; j++)
				myprintf("%02X", (unsigned char)sha256result[j]);

			myprintf(" ");
			string directorypurgata=mydirs[i];
			myreplace(directorypurgata,files[0],"");
			printUTF8(directorypurgata.c_str());
			myprintf("\n");
			printtime+=mtime()-scantime;
			
		}
		
		vec.clear();
		
		startscan=mtime();
		uint32_t dummycrc;
		for (unsigned int i=0;i<myfiles.size();i++)
			vec.push_back(make_pair("dummy",hash_calc_file(flag2algo(),myfiles[i].c_str(),false,dummycrc,-1,-1,g_dimensione)));
		hashtime+=mtime()-startscan;
		
		std::sort(vec.begin(), vec.end(),sortbyval);

		for (unsigned int j=0;j<vec.size();j++)
			for (const char* p=vec[j].second.c_str(); *p; ++p) 
					globalesha256.put(*p);
		
		scantime=mtime();
		char sha256result[32];
		memcpy(sha256result, globalesha256.result(), 32);
		myprintf("\nGLOBAL_MAGIC_%s: ",mygetalgo().c_str());
		for (int j=0; j <= 31; j++)
			myprintf("%02X:", (unsigned char)sha256result[j]);
		myprintf("\n");
		printtime+=mtime()-scantime;
		
		if (!flagnoeta)
			{
				printf("Algo %s\n",mygetalgo().c_str());
				printf("Scanning filesystem time  %f s\n",scantime/1000.0);
				printf("Data transfer+CPU   time  %f s\n",hashtime/1000.0);
				printf("Data output         time  %f s\n",printtime/1000.0);
				printf("Total size  %19s (%10s)\n",migliaia(total_size),tohuman(total_size));
				int64_t myspeed=(int64_t)(total_size*1000.0/(hashtime));
				printf("Worked on %s bytes avg speed (hashtime) %s B/s\n",migliaia(total_size),migliaia2(myspeed));
			}
		return 0;
	}
	
	for (unsigned i=0; i<files.size(); ++i)
		scandir(true,edt,files[i].c_str());


	if (flagverify)
	{
//	deduplication: I am very lazy, so do a lot of copy
		printf("\n*** Searching for duplicates with %s minsize %s ***\n",mygetalgo().c_str(),migliaia(minsize));
// get size and name
		std::vector<std::pair<uint64_t,string>> filestobepurged;
		for (DTMap::iterator p=edt.begin(); p!=edt.end(); ++p) 
			if (p->second.date && p->first!="" && (!isdirectory(p->first)) && (!isads(p->first)) ) 
			{
				if (minsize>0)
				{
					if ((uint64_t)p->second.size>minsize)
					{
						filestobepurged.push_back(make_pair(p->second.size,p->first));
						scannedsize+=p->second.size;
					}
				}
				else
				{
					filestobepurged.push_back(make_pair(p->second.size,p->first));
					scannedsize+=p->second.size;
				}
			}
// ok, let's purge
		std::sort(filestobepurged.begin(), filestobepurged.end(),sortbysize);
		myfiles.clear();
		unsigned int i=0;
// get only files with equal size
// from filestobepurged to myfiles
		while (i<filestobepurged.size())
		{
			int j=i;
			if (filestobepurged[j].first==filestobepurged[j+1].first)
			{
				myfiles.push_back(filestobepurged[j].second);
				total_size+=filestobepurged[j].first;
				quantifiles++;
			}
			while (filestobepurged[j].first==filestobepurged[j+1].first)
			{
				myfiles.push_back(filestobepurged[j+1].second);
				total_size+=filestobepurged[j+1].first;
				quantifiles++;
				j++;
			}
			j++;
			i=j;
		}
	}
	else
	{
//	default: get everything
		for (DTMap::iterator p=edt.begin(); p!=edt.end(); ++p) 
			if (p->second.date && p->first!="" && (!isdirectory(p->first)) && (!isads(p->first)) ) 
			{
				if (minsize>0)
				{
					if ((uint64_t)p->second.size>minsize)
					{
						myfiles.push_back(p->first);
						total_size+=p->second.size;
						quantifiles++;
					}
				}
				else
				{
					myfiles.push_back(p->first);
					total_size+=p->second.size;
					quantifiles++;
				}

			}
		scannedsize=total_size;
	}	
	
	if (myfiles.size()==0)
	{
		printf("Nothing to do\n");
		return 0;
	}
	
	
	vector<string> myhash;
	vector<tparametrihash> 	vettoreparametrihash;

	int mythreads=howmanythreads;
	
	if (!flagssd)
		mythreads=1;
		
	tparametrihash 	myblock;
	for (int i=0;i<mythreads;i++)
	{
		myblock.tnumber=(i%mythreads);
		myblock.inizio=mtime();
		myblock.dimensione=total_size;
		myblock.timestart=0;
		myblock.timeend=0;
		vettoreparametrihash.push_back(myblock);
	}
	printbar(' ');
	///if (!flagnoeta)
	///printf("Computing filesize for %s files/directory...\n",migliaia(files.size()));
	
    
	
	int64_t inizio		=mtime();
	double scantime=(inizio-startscan)/1000.0;
	if (!flagnoeta)
	printf("Found (%s) => %s bytes (%s) / %s files in %f\n",tohuman2(scannedsize),migliaia(total_size),tohuman(total_size),migliaia2(quantifiles),scantime);
	
	for (unsigned int i=0;i<myfiles.size();i++)
	{
		vettoreparametrihash[i%mythreads].filestobehashed.push_back(myfiles[i]);
		vettoreparametrihash[i%mythreads].algo.				push_back(mygetalgo().c_str());
	}
	int totfile=0;
	for (int i=0;i<mythreads;i++)
	{
		if (flagdebug)
			printf("Thread [%02d] files %s\n",i,migliaia(vettoreparametrihash[i].filestobehashed.size()));
		totfile+=+vettoreparametrihash[i].filestobehashed.size();
	}
	if (flagverbose)
	printf("Total files %s -> in threads %s\n",migliaia(myfiles.size()),migliaia2(totfile));
	
	

	int rc;
	///pthread_t threads[mythreads];
	pthread_t* threads = new pthread_t[mythreads];

	pthread_attr_t attr;
	void *status;

		// ini and set thread joinable
	pthread_attr_init(&attr);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_JOINABLE);

	if (!flagnoeta)
		printf("\nCreating %d hashing thread(s) with %s\n",mythreads,mygetalgo().c_str());
	
	uint64_t iniziohash=mtime();
	for(int i = 0; i < mythreads; i++ ) 
	{
		vettoreparametrihash[i].timestart=mtime();
		rc = pthread_create(&threads[i], &attr, scansionahash, (void*)&vettoreparametrihash[i]);
		if (rc) 
		{
			printf("Error creating thread\n");
			exit(-1);
		}
	}

	pthread_attr_destroy(&attr);
	for(int i = 0; i <mythreads; i++ ) 
	{
		rc = pthread_join(threads[i], &status);
		if (rc) 
		{
			error("Unable to join\n");
			exit(-1);
		}
	///		printf("Thread completed %d status %d\n",i,status);
	}
	uint64_t hashtime=mtime()-iniziohash+1;
	
	vector<std::pair<string, string>> vec;
	
	for(int i = 0; i <mythreads; i++ )
		for (unsigned int j=0;j<vettoreparametrihash[i].filestobehashed.size();j++)
			vec.push_back(make_pair(vettoreparametrihash[i].filestobehashed[j],vettoreparametrihash[i].o_hashcalculated[j]));

	if ((!flagnosort) || (flagverify))
	std::sort(vec.begin(), vec.end(),sortbyval);
	libzpaq::SHA256 sha256;
	
	int64_t startprint=mtime();

	uint64_t testedbytes=0;
	int64_t deletedfiles=0;
	int64_t deletedsize=0;
	vector<string> sortato;
	int	errori=0;
	
	for (unsigned int i=0;i<vec.size();i++)
	{
			
		string filename=vec[i].first;
		DTMap::iterator p=edt.find(filename);
	
		if (p != edt.end())
			testedbytes+=p->second.size;
		
		for (const char* p=vec[i].second.c_str(); *p; ++p) 
			sha256.put(*p);
    
		if (searchfrom!="")
			if (replaceto!="")
				replace(filename,searchfrom,replaceto);	
		
					
		if (flagkill)
		{
					
// get ready to make a script (no kill whatsoever!) by hand
			if (i>0)
				if (vec[i-1].second==vec[i].second)
				{
					if (summary<0)
					{
						#if defined(_WIN32) || defined(_WIN64)
						myreplaceall(filename,"/","\\");
						#endif
						printf("=== \"");
						
						if (g_output_handle!=0)
							fprintf(g_output_handle,"    \"");
						
						printUTF8(filename.c_str());
						myprintf("\"\n");
					}
					duplicated_files++;
					if (p != edt.end())
						duplicated_size+=p->second.size;
					if (flagforce)
						if (delete_file(filename.c_str()))
						{
							deletedfiles++;
							if (p != edt.end())
								deletedsize+=p->second.size;
						}
				}
		}
		else
		{
			if (summary<0)
			{
				myprintf("%s: %s ",mygetalgo().c_str(),vec[i].second.c_str());
				if (p != edt.end())
				{
					myprintf("[%19s] ",migliaia(p->second.size));
				}
			}
			if (!flagnosort)
			{			
				if (i==0)
				{	
					if (summary<0)
						myprintf("    ");
				}	
				else
				{
					if (vec[i-1].second==vec[i].second)
					{
						if (summary<0)
						{
							printf("=== ");
							if (g_output_handle!=0)
								fprintf(g_output_handle,"    ");
	
						}
						duplicated_files++;
						if (p != edt.end())
							duplicated_size+=p->second.size;
					}
					else
					{
						if (summary<0)
							myprintf("    ");
					}
				}
			}
			if (summary<0)
			{
				printUTF8(filename.c_str());
				myprintf("\n");
			}
			
			/// check if, for some reason, we cannot read a file (ex. corrupted, ACL etc)
			if ((p->second.size)>0)
			{
				if (vec[i].second==emptyalgo(mygetalgo().c_str()))
				{
					myprintf("\n\n");
					myprintf("32609: **** GURU ERROR non zero-length file get empty hash!\n");
					myprintf("32609: **** A non-empty file have the same hash of empty one!\n");
					myprintf("\n\n");
					errori=2;
				}
			}
		}
	}
	
	int64_t printtime=mtime()-startprint;
	if (summary>0)
	
	{
		///printf("Algo %s by %d threads\n",mygetalgo().c_str(),mythreads);
		printf("Scanning filesystem time  %15.3f s\n",scantime);
		printf("Data transfer+CPU   time  %15.3f s\n",hashtime/1000.0);
		printf("Data output         time  %15.3f s\n",printtime/1000.0);
		printf("Total size                %19s (%10s)\n",migliaia(scannedsize),tohuman(scannedsize));
		printf("Tested size               %19s (%10s)\n",migliaia(testedbytes),tohuman(testedbytes));
		if (!flagnosort)
		{
		printf("Duplicated size           %19s (%10s)\n",migliaia(duplicated_size),tohuman(duplicated_size));
		printf("Duplicated files          %19s\n",migliaia(duplicated_files));
		}
		int64_t myspeed=(int64_t)(testedbytes*1000.0/(hashtime));
		printf("Worked on %s bytes avg speed (hashtime) %s B/s\n",migliaia(total_size),migliaia2(myspeed));
		char sha256result[32];
		memcpy(sha256result, sha256.result(), 32);
		printf("GLOBAL SHA256: ");
		for (int j=0; j <= 31; j++)
			printf("%02X", (unsigned char)sha256result[j]);
		printf("\n");
	}

	if (flagkill)
		if (flagforce)
			if (deletedfiles)
				printf("Duplicated deleted files %s for %s bytes\n",migliaia2(deletedfiles),migliaia(deletedsize));
	
	delete [] threads;
	return errori;
#endif
}


/*

	Section: main
*/

/// control-c handler
void my_handler(int s)
{
	// 2==control-C (maybe)
	if (s==2)
	{	
#ifdef _WIN32
		if (command=='q')
		{
			printf("*** VSS RUNNING, DETACHING\n");
			vss_deleteshadows("c:\\franzsnap");
		}
#endif
		setupConsole();
		printf("\033[?25h");
		fflush(stdout);
		restoreConsole();
	}
	exit(1); 
}


///#include <windows.h>
///#include <cstdio>
// Convert argv to UTF-8 and replace \ with /
#ifdef unix
	int main(int argc, const char** argv) 
	{
#else
	#ifdef _MSC_VER
		int wmain(int argc, LPWSTR* argw) 
		{
	#else
		int main() 
		{
			int argc=0;
			LPWSTR* argw=CommandLineToArgvW(GetCommandLine(), &argc);
	#endif

///	This is Windows: take care of parameters
	vector<string> args(argc);

	libzpaq::Array<const char*> argp(argc);
	for (int i=0; i<argc; ++i) 
	{
		args[i]=wtou(argw[i]);
		argp[i]=args[i].c_str();
	}
	const char** argv=&argp[0];
#endif
	g_start=mtime();  		// get start time

#ifndef SOLARIS // solaris does not like this things very much
	signal (SIGINT,my_handler); // the control-C handler
#endif

#ifdef _WIN32
//// set UTF-8 for console
	SetConsoleCP(65001);
	SetConsoleOutputCP(65001);
	OSVERSIONINFO vi;// = {0};
	vi.dwMajorVersion=0;
	vi.dwMinorVersion=0;
	vi.dwPlatformId=0;
	vi.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
	GetVersionEx(&vi);
	windows7_or_above = (vi.dwMajorVersion >= 6) && (vi.dwMinorVersion >= 1);
#endif


	struct hash_check dummycheck;
	dummycheck.algotype=ALGO_SHA1;
	g_mychecks.insert(std::pair<string, hash_check>("SHA-1",dummycheck));
	
	dummycheck.algotype=ALGO_SHA256;
	g_mychecks.insert(std::pair<string, hash_check>("SHA-256",dummycheck));

	dummycheck.algotype=ALGO_XXHASH64;
	g_mychecks.insert(std::pair<string, hash_check>("XXHASH64",dummycheck));

	dummycheck.algotype=ALGO_XXH3;
	g_mychecks.insert(std::pair<string, hash_check>("XXH3",dummycheck));

	dummycheck.algotype=ALGO_BLAKE3;
	g_mychecks.insert(std::pair<string, hash_check>("BLAKE3",dummycheck));

	dummycheck.algotype=ALGO_SHA3;
	g_mychecks.insert(std::pair<string, hash_check>("SHA-3",dummycheck));

	dummycheck.algotype=ALGO_MD5;
	g_mychecks.insert(std::pair<string, hash_check>("MD5",dummycheck));

	dummycheck.algotype=ALGO_NILSIMSA;
	g_mychecks.insert(std::pair<string, hash_check>("NILSIMSA",dummycheck));


	int errorcode=0;
	try 
	{
		Jidac jidac;
		errorcode=jidac.doCommand(argc, argv);
	}
	catch (std::exception& e) 
	{
		fflush(stdout);
		fprintf(stderr, "23013: zpaqfranz error: %s\n", e.what());
		errorcode=2;
	}
  
	fflush(stdout);
	if (g_fwritten!=g_fexpected)
	{
		printf("\n");
		printbar('*');
		printf("Something STRANGE happened. Archive seems corrupt. Media full?\n");
		printf("WRITTEN BYTES  %19s\n",migliaia(g_fwritten));
		printf("EXPECTED       %19s\n",migliaia(g_fexpected));
		printbar('*');
		errorcode=2;
	  }
#ifndef ESX	  
	if (command=='q')
	fprintf(stderr, "\n%1.3f seconds (%s)  on VSS operation\n", (mtime()-g_start)/1000.0,timetohuman((mtime()-g_start)/1000.0).c_str());
	else
	fprintf(stderr, "\n%1.3f seconds (%s)  %s\n", (mtime()-g_start)/1000.0,timetohuman((mtime()-g_start)/1000.0).c_str(),
      errorcode>1 ? "(with errors)" :
      errorcode>0 ? "(with warnings)" : "(all OK)");
#endif
	if (g_255)
		fprintf(stderr, "\nSeems %08d errors by path/filename too long (>255)\n", g_255);

	if (errorcode==2)
	{
		if (flagdebug)
				printf("33026: call xcommand on errorcode==2\n");
		xcommand(g_exec_error,g_exec_text);
	}
	else
	if (errorcode==1)
	{
		if (flagdebug)
			printf("33033: call xcommand on errorcode==1\n");

		xcommand(g_exec_warn,g_exec_text);
	}
	else
	{
		if (flagdebug)
			printf("33040: call xcommand with a different errorcode (not 1, not 2) %d\n",errorcode);

/// when adding multipart archive, and no errors, take the last filename
		if (g_archive!="")
		{
			g_exec_text=g_archive;
			if (flagdebug)
				printf("33047: g_archive not null, setting g_exec_text to %s\n",g_exec_text.c_str());
		}
		if (g_exec_ok!="")
			xcommand(g_exec_ok,g_exec_text);
	}	

	if (g_output_handle!=0)
		fclose(g_output_handle);

	return errorcode;
}

int Jidac::utf() 
{

#ifdef ESX
	printf("GURU: sorry: ESXi does not like this things\n");
	exit(0);
#else

		
	vector<string> sourcefile;     
	
	g_bytescanned=0;
	g_filescanned=0;
	g_worked=0;
	edt.clear();
	
	for (unsigned i=0; i<files.size(); ++i)
		scandir(true,edt,files[i].c_str());
	
	for (DTMap::iterator p=edt.begin(); p!=edt.end(); ++p) 
		if (!isdirectory(p->first))
			sourcefile.push_back(p->first);
	
	vector<string> strange;     
	
	printf("\nCheck directories %s\n",migliaia(sourcefile.size()));
	for (int unsigned i=0;i<sourcefile.size();i++)
	{
		string filename=extractfilepath(sourcefile[i]);
		string ansifilename=utf8toansi(filename);
			
		string ragione="";
		if (filename!=ansifilename)
			ragione+="CHAR |";

		if (dirlength>0)
			if (filename.length()>dirlength)
				ragione+="LEN "+myto_string(dirlength)+"-|";

		if (ragione!="")
			strange.push_back(padleft(ragione,15)+filename);
	}
	
	sort( strange.begin(), strange.end() );
	strange.erase( unique( strange.begin(), strange.end() ), strange.end() );
	if (!flagutf)
		for (int unsigned i=0;i<strange.size();i++)
		{
			printf("DIR:%08lu <<",(long unsigned int)strange[i].length());
			printUTF8(strange[i].c_str());
			printf(">>\n");
		}
	printf("DIR:Total %s\n",migliaia(strange.size()));
	
	strange.clear();
	printf("\nCheck files %s\n",migliaia(sourcefile.size()));
	
	for (unsigned int i=0;i<sourcefile.size();i++)
	{
		string filename=extractfilename(sourcefile[i]);
		string ansifilename=utf8toansi(filename);
	
		string ragione="";
		
		if (filename!=ansifilename)
			ragione+="CHAR |";

		if (filelength>0)
			if (filename.length()>filelength)
				ragione+="LEN "+myto_string(filelength)+"-|";
		if (ragione!="")
			strange.push_back(padleft(ragione,15)+filename);

	}
	sort( strange.begin(), strange.end() );
	strange.erase( unique( strange.begin(), strange.end() ), strange.end() );
	
	if (!flagutf)
		for (unsigned int i=0;i<strange.size();i++)
		{
			printf("FILE:%08ld <<",(long int)strange[i].length());
			printUTF8(strange[i].c_str());
			printf(">>\n");
		}
	printf("FILE:Total %s\n",migliaia(strange.size()));

	if (!flagutf)
		return 0;
		
	printf("******* RENAME STRANGE FILES\n");

	printsanitizeflags();

	if (!flagkill)
	printf("******* -kill not present => this is a dry run\n");
	
	int rinominati=0;
	int nonrinominati=0;
	int kollision=0;
	MAPPAFILEHASH mappacollisioni;
	MAPPASTRINGASTRINGA mappatofrom;
	
	for (unsigned int i=0;i<sourcefile.size();i++)
	{
		if (isdirectory(sourcefile[i]))
		{
			printf("This is strange, dir skipped %s\n",sourcefile[i].c_str());
		}
		else
		{
		string newname=sanitizzanomefile(sourcefile[i],filelength,kollision,mappacollisioni);
		
		if ((newname!=sourcefile[i]))
		{
			if (flagdebug)
			{
				printf("25733: pre       <<%s>>\n",sourcefile[i].c_str());
				printf("25734: Inserisco <<%s>>\n\n\n",newname.c_str());
			}
			mappatofrom.insert(std::pair<string, string>(newname, "DUMMY"));
						
			string sfrom=sourcefile[i];
#ifdef _WIN32
			myreplaceall(sfrom,"/","\\");
#endif
			string sto=newname; 
#ifdef _WIN32
			sto=nomefileseesistegia(sto);
			myreplaceall(sto,"/","\\");
#endif
			if (flagverbose)
			{
				printf("FROM: ");
				printUTF8(sfrom.c_str());
				printf("\nTO:   %s\n\n",sto.c_str());
			}
			
			if (flagkill)
			{
#ifdef _WIN32				
				std::wstring wfrom=utow(sfrom.c_str());  
				std::wstring wto=utow(sto.c_str());  
				if (!MoveFileW(wfrom.c_str(),wto.c_str()))
				{
					nonrinominati++;
					printf("ERROR WIN renaming\n");
					printf("from <<");
					printUTF8(sfrom.c_str());
					printf(">>\n");
					printf("to   <<%s>>\n",sto.c_str());
					
					printf("ERROR renaming <<");
					printUTF8(sfrom.c_str());
					printf(">> to <<%s>>\n",sto.c_str());
					if (flagverbose)
						for (unsigned int j=0;j<sfrom.length();j++)
							printf("%03d %03d %c\n",j,sto[j],sto[j]);
				}
#else
				if (::rename(sfrom.c_str(), sto.c_str()) != 0)
				{
					nonrinominati++;
					printf("ERROR NIX renaming\n");
					printf("from <<%s>>\n",sfrom.c_str());
					printf("to   <<%s>>\n",sto.c_str());
					if (flagverbose)
						for (unsigned int j=0;j<sfrom.length();j++)
							printf("%03d %03d %c\n",j,sto[j],sto[j]);

				}
#endif	
				else
					rinominati++;		
		///		printf("Renaming %08d failed %08d\r",rinominati,nonrinominati);
			}
			else
				nonrinominati++;

		}
		}
	}
	printf("\n");
	printf("Candidates  %08d\n",rinominati+nonrinominati);
	if (flagkill)
	{
		printf("Renamed     %08d\n",rinominati);
		printf("Failed      %08d\n",nonrinominati);
	}
	else
		printf("*** dry run\n");
	if (nonrinominati>0)
		return 2;
	else
		return 0;
#endif	
}


	
/// a patched... main()!
int unz(const char * archive,const char * key)
{
	/// really cannot run on ESXi: take WAY too much RAM
	if (!archive)
		return 0;
	
	uint64_t until=0;
	bool index=false;
 	
	printf("PARANOID TEST: working on %s\n",archive);

	
  // Journaling archive state
	std::map<uint32_t, unsigned> bsize;  // frag ID -> d block compressed size
	std::map<std::string, unzDT> unzdt;   // filename -> date, attr, frags
	std::vector<std::string> frag;  // ID -> hash[20] size[4] data
	std::string last_filename;      // streaming destination
	uint64_t ramsize=0;
	uint64_t csize=0;                    // expected offset of next non d block
	bool streaming=false, journaling=false;  // archive type
	int64_t inizio=mtime();
	uint64_t lavorati=0;
  // Decompress blocks
	unzInputFile in;  // Archive
	in.open(archive, key);
	int64_t total_size=in.getfilesize();
	
	unzDecompresser d;
	d.setInput(&in);
	////unzOutputFile out;   // streaming output
	bool done=false;  // stop reading?
	bool firstSegment=true;
  
	while (!done && d.findBlock()) 
  {
	unzBuf filename(65535);
    while (!done && d.findFilename(&filename)) 
	{
		unzBuf comment(65535);
		d.readComment(&comment);
		
		unzverify_utf8(filename.s.c_str());
		
		// Test for journaling or streaming block. They cannot be mixed.
		uint64_t jsize=0;  // journaling block size in comment
		if (comment.s.size()>=4 && comment.s.substr(comment.s.size()-4)=="jDC\x01") 
		{

        // read jsize = uncompressed size from comment as a decimal string
			unsigned i;
			for (i=0; i<comment.s.size()-5 && isdigit(comment.s[i]); ++i) 
			{
				jsize=jsize*10+comment.s[i]-'0';
				if (jsize>>32) unzerror("size in comment > 4294967295");
			}
			if (i<1) 
				unzerror("missing size in comment");
			if (streaming) 
				unzerror("journaling block after streaming block");
			journaling=true;
		}
		else 
		{
			if (journaling) 
			unzerror("streaming block after journaling block");
			if (index) 
				unzerror("streaming block in index");
			streaming=true;
			///d.setOutput(&out);
			///d.setOutput();
		}
		/*
		if (streaming)
		printf("Streaming\n");
		if (journaling)
		printf("journaling\n");
		*/
      // Test journaling filename. The format must be
      // jDC[YYYYMMDDHHMMSS][t][NNNNNNNNNN]
      // where YYYYMMDDHHMMSS is the date, t is the type {c,d,h,i}, and
      // NNNNNNNNNN is the 10 digit first fragment ID for types c,d,h.
      // They must be in ascending lexicographical order.

		uint64_t date=0, id=0;  // date and frag ID from filename
		char type=0;  // c,d,h,i
		if (journaling)  // di solito
		{
			if (filename.s.size()!=28) 
				unzerror("filename size not 28");
			if (filename.s.substr(0, 3)!="jDC") 
				unzerror("filename not jDC");
			type=filename.s[17];
			if (!strchr("cdhi", type)) 
				unzerror("type not c,d,h,i");
			
			if (filename.s<=last_filename) 
			unzerror("filenames out of order");
        
			last_filename=filename.s;

        // Read date
			for (int i=3; i<17; ++i) 
			{
				if (!isdigit(filename.s[i])) 
					unzerror("non-digit in date");
				date=date*10+filename.s[i]-'0';
			}
			verify_date(date);

        // Read frag ID
			for (int i=18; i<28; ++i) 
			{
				if (!isdigit(filename.s[i])) 
					unzerror("non-digit in fragment ID");
				id=id*10+filename.s[i]-'0';
			}
			if (id<1 || id>4294967295llu) 
				unzerror("fragment ID out of range");
		}

      // Select streaming output file
		if (streaming && (firstSegment || filename.s!="")) 
		{
			std::string fn=filename.s;
			/// out.open(fn.c_str());
		}
		firstSegment=false;

		// Decompress
		fflush(stdout);
		unzBuf seg(jsize);
		if (journaling) 
			d.setOutput(&seg);
		unzSHA1 sha1;
		d.setSHA1(&sha1);
		d.decompress();
		if (journaling && seg.s.size()!=jsize) 
			unzerror("incomplete output");

      // Verify checksum
		char checksum[21];
		d.readSegmentEnd(checksum);
//		if (!noeta)
///		printf("s");
		if (checksum[0]==1) 
		{
			if (memcmp(checksum+1, sha1.result(), 20)) 
				unzerror("unzSHA1 mismatch");
      //  else printf("OK");
   ///   printf("\nZ1: SHA1 checksum OK\n");
		}
		else 
		if (checksum[0]==0) 
			printf("not checked");
		else unzerror("invalid checksum type");
      ///printf("\n");
      
		filename.s="";

      // check csize at first non-d block
		if (csize && strchr("chi", type)) 
		{
			if (csize!=offset) 
			{
				printf("Z2:    csize=%1.0f, offset=%1.0f\n",double(csize), double(offset));		
				unzerror("csize does not point here");
			}
			csize=0;
		}
///printf("=======================================\n");

      // Get csize from c block
		const size_t len=seg.s.size();
		if (type=='c') 
		{
			if (len<8) 
				unzerror("c block too small");
        
			csize=unzget8(seg.s.data());
			lavorati+=csize;
		
			if (flagnoeta==false)
			{
				///printf("\n");
				print_datetime();
				printf("%20s (%15s)\n", migliaia(lavorati),migliaia(csize));
			}
        // test for end of archive marker
			if (csize>>63) 
			{
				printf("Incomplete transaction at end of archive (OK)\n");
				done=true;
			}
			else 
			if (index && csize!=0) 
				unzerror("nonzero csize in index");

        // test for rollback
			if (until && date>until) 
			{
				printf("Rollback: %1.0f is after %1.0f\n",double(date), double(until));
			done=true;
			}

        // Set csize to expected offset of first non d block
        // assuming 1 more byte for unread end of block marker.
			csize+=in.tell()+1;
		}

      // Test and save d block
		if (type=='d') 
		{
			if (index) 
				unzerror("d block in index");
			bsize[id]=in.tell()+1-offset;  // compressed size
   ///     printf("    %u -> %1.0f ", bsize[id], double(seg.s.size()));

        // Test frag size list at end. The format is f[id..id+n-1] fid n
        // where fid may be id or 0. sizes must sum to the rest of block.
			if (len<8) 
				unzerror("d block too small");
			
			const char* end=seg.s.data()+len;  // end of block
			uint32_t fid=unzget4(end-8);  // 0 or ID
			const uint32_t n=unzget4(end-4);    // number of frags
			
			if (fid==0) 
			fid=id;
			///if (!noeta)
				//printf("u");
				///printf(".");
        ///printf("[%u..%u) ", fid, fid+n);
			if (fid!=id) 
				unzerror("missing ID");
			if (n>(len-8)/4) 
				unzerror("frag list too big");
			uint64_t sum=0;  // computed sum of frag sizes
			for (unsigned i=0; i<n; ++i) 
				sum+=unzget4(end-12-4*i);
		//if (!noeta)
			//printf("");	//printf("m");
        ///printf("= %1.0f ", double(sum));
			if (sum+n*4+8!=len) 
				unzerror("bad frag size list");

        // Save frag hashes and sizes. For output, save data too.
			const char* data=seg.s.data();  // uncompressed data
			const char* flist=data+sum;  // frag size list
			assert(flist+n*4+8==end);
			for (uint32_t i=0; i<n; ++i) 
			{
				while (frag.size()<=id+i) 
					frag.push_back("");
				if (frag[id+i]!="") 
					unzerror("duplicate frag ID");
				uint32_t f=unzget4(flist);  // frag size
				unzSHA1 sha1;
				for (uint32_t j=0; j<f; ++j) 
					sha1.put(data[j]);
				const char* h=sha1.result();  // frag hash
				frag[id+i]=std::string(h, h+20)+std::string(flist, flist+4);
				frag[id+i]+=std::string(data, data+f);
				data+=f;
				flist+=4;
				ramsize+=frag[id+i].size();
			}
			assert(data+n*4+8==end);
			assert(flist+8==end);
			///if (!noeta)
				///printf("o"); //printf("O");
			///printf("OK\n");
		}

      // Test and save h block. Format is: bsize (sha1[20] size)...
      // where bsize is the compressed size of the d block with the same id,
      // and each size corresonds to a fragment in that block. The list
      // must match the list in the d block if present.

		if (type=='h') 
		{
			if (len%24!=4) 
			unzerror("bad h block size");
			uint32_t b=unzget4(seg.s.data());
			b++;
///if (!noeta)
				///printf("O");//printf("i");
        ///printf("    [%u..%u) %u ", uint32_t(id), uint32_t(id+len/24), b);

        // Compare hashes and sizes
			const char* p=seg.s.data()+4;  // next hash, size
			uint32_t sum=0;  // uncompressed size of all frags
			for (uint32_t i=0; i<len/24; ++i) 
			{
				if (index) 
				{
					while (frag.size()<=id+i) frag.push_back("");
					if (frag[id+i]!="") unzerror("data in index");
						frag[id+i]=std::string(p, p+24);
				}
				else 
				if (id+i>=frag.size() || frag[id+i].size()<24)
					unzerror("no matching d block");
				else 
				if (frag[id+i].substr(0, 24)!=std::string(p, p+24))
					unzerror("frag size or hash mismatch");
				
				sum+=unzget4(p+20);
				p+=24;
			}
			///if (!noeta)
				///printf("0");//printf("o");
        ///printf("-> %u OK\n", sum);
		}
		
      // Test i blocks and save files to extract. Format is:
      //   date filename 0 na attr[0..na) ni ptr[0..ni)   (to update)
      //   0    filename                                  (to delete)
      // Date is 64 bits in YYYYMMDDHHMMSS format.

		if (type=='i') 
		{
			const char* p=seg.s.data();
			const char* end=p+seg.s.size();
			while (p<end) 
			{

          // read date
				if (end-p<8) 
				unzerror("missing date");
				
				unzDT f;
				f.date=unzget8(p), p+=8;
				if (f.date!=0) 
					verify_date(f.date);

          // read filename
				std::string fn;
				while (p<end && *p) 
				{
				///		if (*p>=0 && *p<32) printf("^%c", *p+64);
       ///     else putchar(*p);
					fn+=*p++;
				}
				if (p==end) 
					unzerror("missing NUL in filename");
				++p;
				if (fn.size()>65535) 
				unzerror("filename size > 65535");
				unzverify_utf8(fn.c_str());

          // read attr
				if (f.date>0) 
				{
					if (end-p<4) 
						unzerror("missing attr size");
					uint32_t na=unzget4(p);
					p+=4;
					if (na>65535) 
					unzerror("attr size > 65535");
	
					///printf("2 NA VALE %d\n",na);
	
					if (na>FRANZOFFSET) // houston we have a FRANZBLOCK? 
					{
						assert((na-8)<FRANZOFFSETSHA256); // cannot work on too small buffer
						/// paranoid works with SHA1, not CRC32. Get (if any)
						for (unsigned int i=0;i<(na-8);i++)
							f.sha1hex[i]=*(p+(na-(na-8))+i);
						f.sha1hex[(na-8)]=0x0;
						///printf("---FRANZ OFFSET---\n");
					}
					else
					{
						f.sha1hex[0]=0x0;
					///printf("---NORMAL OFFSET---\n");
					}
			
					for (unsigned i=0; i<na; ++i) 
					{
						if (end-p<1) 
							unzerror("missing attr");
						uint64_t a=*p++&255;
						if (i<8) 
							f.attr|=a<<(i*8);
					}

					// read frag IDs
					if (end-p<4) 
						unzerror("missing frag ptr size");
					uint32_t ni=unzget4(p);
					p+=4;
					for (uint32_t i=0; i<ni; ++i) 
					{
						if (end-p<4) 
							unzerror("missing frag ID");
						uint32_t a=unzget4(p);
						p+=4;
						f.ptr.push_back(a);

					// frag must refer to valid data except in an index
						if (!index) 
						{
							if (a<1 || a>=frag.size()) 
								unzerror("frag ID out of range");
							if (frag[a]=="") 
								unzerror("missing frag data");
						}
					}
				}
/// UBUNTU
			unzdt[fn]=f;
///			unzdt.insert(std::pair<string, unzDT>(fn,f));
	
			}
		}
		printf("\r");
		print_datetime();
		printf("Remaining %3s %% frags %12s (RAM used ~ %15s)\r",migliaia2(100-(offset*100/(total_size+1))),migliaia(frag.size()),migliaia2(ramsize));

    }  // end while findFilename
    offset=in.tell();
  }  // end while findBlock
	printf("\n%s bytes of %s tested\n", migliaia(in.tell()), archive);

	printbar('-');
	printf("Second stage: rebuilding hashes\n");
  	
	std::vector<unzDTMap::iterator> mappadt;
	std::vector<unzDTMap::iterator> vf;
	std::map<std::string, unzDT>::iterator p;

	int64_t iniziocalcolo=mtime();
		
	for (p=unzdt.begin(); p!=unzdt.end(); ++p)
		mappadt.push_back(p);
		
	std::sort(mappadt.begin(), mappadt.end(),unzcompareprimo);
	
	for (unsigned int i=0; i<mappadt.size(); ++i) 
	{
		unzDTMap::iterator p=mappadt[i];
		unzDT f=p->second;
		if (f.date) 
		{
			uint64_t size=0;
			for (uint32_t i=0; i<f.ptr.size(); ++i)
				if (f.ptr[i]>0 && f.ptr[i]<frag.size() && frag[f.ptr[i]].size()>=24)
					size+=unzget4(frag[f.ptr[i]].data()+20);
			if (!index) 
			{
				std::string fn=p->first;
				
				if ((!isads(fn)) && (!iszfs(fn)) && (!isdirectory(fn)))
				{
					int64_t startrecalc=mtime();
	
					string hashstoredinzpaq="";
					string myhashtype="";
					string mycrc32="";
				
					int unzfranzotype=decode_franz_block(isdirectory(p->first),p->second.sha1hex,
					myhashtype,
					hashstoredinzpaq,
					mycrc32);
				
					if (unzfranzotype==FRANZO_XXHASH64)
					{
						uint64_t myseed = 0;
						XXHash64 myhash(myseed);
						for (uint32_t i=0; i<f.ptr.size(); ++i) 
							if (f.ptr[i]<frag.size())
								for (uint32_t j=24; j<frag[f.ptr[i]].size(); ++j)
									myhash.add(&frag[f.ptr[i]][j],1);
						sprintf(p->second.sha1decompressedhex,"%016llX",(unsigned long long)myhash.hash());
						
					}
					else
					if (unzfranzotype==FRANZO_SHA_1)
					{
						unzSHA1 mysha1;
						for (uint32_t i=0; i<f.ptr.size(); ++i) 
							if (f.ptr[i]<frag.size())
								for (uint32_t j=24; j<frag[f.ptr[i]].size(); ++j)
									mysha1.put(frag[f.ptr[i]][j]);
										
						char sha1result[20];
						memcpy(sha1result, mysha1.result(), 20);
						for (int j=0; j <= 19; j++)
							sprintf(p->second.sha1decompressedhex+j*2,"%02X", (unsigned char)sha1result[j]);
						p->second.sha1decompressedhex[40]=0x0;
					}
					else
					if (unzfranzotype==FRANZO_SHA_256)
					{
						unzSHA256 mysha256;
						for (uint32_t i=0; i<f.ptr.size(); ++i) 
							if (f.ptr[i]<frag.size())
								for (uint32_t j=24; j<frag[f.ptr[i]].size(); ++j)
									mysha256.put(frag[f.ptr[i]][j]);
										
						char sha256result[32];
						memcpy(sha256result, mysha256.result(), 32);
						for (int j=0; j <= 31; j++)
							sprintf(p->second.sha1decompressedhex+j*2,"%02X", (unsigned char)sha256result[j]);
						p->second.sha1decompressedhex[64]=0x0;
					}
					else
					if (unzfranzotype==FRANZO_BLAKE3)
					{
						blake3_hasher hasher;
						blake3_hasher_init(&hasher);
									
						for (uint32_t i=0; i<f.ptr.size(); ++i) 
							if (f.ptr[i]<frag.size())
								for (uint32_t j=24; j<frag[f.ptr[i]].size(); ++j)
									blake3_hasher_update(&hasher, &frag[f.ptr[i]][j],1);

						uint8_t output[BLAKE3_OUT_LEN];
						blake3_hasher_finalize(&hasher, output, BLAKE3_OUT_LEN);
						for (int j=0; j < BLAKE3_OUT_LEN; j++)
							sprintf(p->second.sha1decompressedhex+j*2,"%02X", (unsigned char)output[j]);
						p->second.sha1decompressedhex[64]=0x0;
					}
					else
					if (unzfranzotype==FRANZO_SHA3)
					{
						SHA3 hasher;
									
						for (uint32_t i=0; i<f.ptr.size(); ++i) 
							if (f.ptr[i]<frag.size())
								for (uint32_t j=24; j<frag[f.ptr[i]].size(); ++j)
									hasher.add(&frag[f.ptr[i]][j],1);

						sprintf(p->second.sha1decompressedhex,"%s",hasher.getHash().c_str());
						p->second.sha1decompressedhex[64]=0x0;
					}
					else
					if (unzfranzotype==FRANZO_MD5)
					{
						MD5 hasher;
									
						for (uint32_t i=0; i<f.ptr.size(); ++i) 
							if (f.ptr[i]<frag.size())
								for (uint32_t j=24; j<frag[f.ptr[i]].size(); ++j)
									hasher.add(&frag[f.ptr[i]][j],1);

						memset(p->second.sha1decompressedhex,0,64);
						sprintf(p->second.sha1decompressedhex,"%s",hasher.getHash().c_str());
									
					}
					else
					if (unzfranzotype==FRANZO_XXH3)
					{
						XXH3_state_t state128;
						(void)XXH3_128bits_reset(&state128);
						for (uint32_t i=0; i<f.ptr.size(); ++i) 
							if (f.ptr[i]<frag.size())
								for (uint32_t j=24; j<frag[f.ptr[i]].size(); ++j)
									(void)XXH3_128bits_update(&state128, &frag[f.ptr[i]][j],1);
						XXH128_hash_t myhash=XXH3_128bits_digest(&state128);
						sprintf(p->second.sha1decompressedhex,"%016llX%016llX",(unsigned long long)myhash.high64,(unsigned long long)myhash.low64);
					}
					else

						error("25904: unknown unzfranzotype");


					vf.push_back(p);
					
					if (flagverbose)
						printf("File <<%-20s>> %08u of %08lld (%20s) %1.3f %s\n",myhashtype.c_str(),i+1,(long long)mappadt.size(),migliaia(size),(mtime()-startrecalc)/1000.0,fn.c_str());
						
				}
			}
		}
	}
	std::sort(vf.begin(), vf.end(), unzcomparesha1hex);
	int64_t finecalcolo=mtime();
	
	printf("Calc time (hash rebuild from fragments) %f\n",(finecalcolo-iniziocalcolo)/1000.0);
	printbar('-');
	printf("Third stage");
	
	if (flagverify || flagparanoid)
		printf(": with check against filesystem");
	printf("\n");
	
	
//////////////////////////////
/////// now some tests
/////// if possible check SHA1 into the ZPAQ with SHA1 extracted with SHA1 of the current file

		unsigned int status_e=0;
		
		unsigned int status_nohash=0;
		unsigned int status_filenotfound=0;
		unsigned int status_1=0;
		unsigned int status_2=0;
		
		std::string hashfromfile;

		for (unsigned i=0; i<vf.size(); ++i) 
		{
			unzDTMap::iterator p=vf[i];

			string finalfile=p->first;
			if (finalfile!="VFILE-l-filelist.txt")
			{
			string hashstoredinzpaq	="";
			string myhashtype		="";
			string mycrc32			="";
				
			int myfranzo=decode_franz_block(isdirectory(p->first),p->second.sha1hex,
					myhashtype,
					hashstoredinzpaq,
					mycrc32);
			if (myfranzo==-1)
				error("33351: archive use an unknown hasher!");

			string unzfranzostring="";
		
			if (flagverify || flagparanoid)
			{
				MAPPACHECK::iterator a=g_mychecks.find(myhashtype);
				if (a!=g_mychecks.end())
				{
					unzfranzostring=decodefranzoffset(a->second.algotype);
					myreplace(unzfranzostring,"+CRC-32","");				

					if (!fileexists(p->first.c_str()))
					{
							if (flagdebug)
								printf("25919: FILE NOT FOUND on %s: FILE %s\n",myhashtype.c_str(),p->first.c_str());
							status_filenotfound++;
					}
					else
					{
						uint32_t dummycrc;
						int64_t dummy;
						hashfromfile=hash_calc_file(
						a->second.algotype,
						p->first.c_str(),
						true,	/// <--- look at this
						dummycrc,
						-1,-1,dummy);
					}
				}
			}

			std::string hashdecompresso=p->second.sha1decompressedhex;
	
			if (flagverify || flagparanoid)
				if (hashfromfile=="")
					status_nohash++;
				
			bool localok=true;
			if (!hashstoredinzpaq.empty())
			{
				if (hashstoredinzpaq==hashdecompresso)
					status_1++;
				else
					localok=false;
			}			
			if (!hashfromfile.empty())
			{
				if (hashfromfile==hashdecompresso)
					status_2++;
				else
					localok=false;
			}

			
			if ((!localok) || (flagverbose))
				if (unzfranzostring!="")
				{
					printf("%14s: %s\n",myhashtype.c_str(),p->first.c_str());
					printf("DECOMPRESSED  : %s\n",hashdecompresso.c_str());
				
					if (!hashstoredinzpaq.empty())
					printf("STORED IN ZPAQ: %s\n",hashstoredinzpaq.c_str());
				
					if (!hashfromfile.empty())
					printf("FROM FILE     : %s\n",hashfromfile.c_str());
					printf("\n");
					
					if (!localok)
						status_e++;
				}
			}
		}

	int64_t fine=mtime();
	
	unsigned int total_files=vf.size();
	
	printf("SUMMARY  %1.3f s\n",(fine-inizio)/1000.0);
	printf("Total   : %08d\n",total_files);

	if (status_e>0)
	printf("ERRORS  : %08d (ERROR:  something WRONG)\n",status_e);
	
	if (status_nohash>0)
	printf("WARNING : %08d (UNKNOWN:cannot verify nohash)\n",status_nohash);
	
	if (status_filenotfound>0)
	printf("WARNING : %08d (UNKNOWN:file not found)\n",status_filenotfound);
	
	if (status_1>0)
	printf("GOOD    : %08d of %08d (stored=decompressed)\n",status_1,total_files);
	
	if (status_2>0)
	printf("SURE    : %08d of %08d (stored=decompressed=file on disk)\n",status_2,total_files);
		
	if (status_e==0)
	{
		if (status_nohash+status_filenotfound)
			printf("Unknown (cannot verify)\n");
		else
		{
			if (flagverify || flagparanoid)
			printf("All OK (paranoid test with check against filesystem)\n");
			else
			printf("All OK (paranoid test)\n");
		}
	}
	else
	{
		printf("WITH ERRORS\n");
		return 2;
	}
	return 0;
}


///

/*
ZPAQ does not store blocks of zeros at all.
This means that they are not, materially, in the file, 
and therefore cannot be used to calculate the CRC-32.

This is a function capable of doing it, 
even for large sizes (hundreds of gigabytes or more in the case of thick virtual machine disks),
up to ~9.000TB

The function I wrote split a number into 
its powers of 2, takes the CRC-32 code from a precomputed table, 
and finally combines them. 
It's not the most efficient method (some 10-20 iterations are typically needed), 
but it's still decent

*/
const uint32_t zero_block_crc32[54] =
{
0xD202EF8D,0x41D912FF,0x2144DF1C,0x6522DF69,0xECBB4B55,0x190A55AD,0x758D6336,0xC2A8FA9D,
0x0D968558,0xB2AA7578,0xEFB5AF2E,0xF1E8BA9E,0xC71C0011,0xD8F49994,0xAB54D286,0x011FFCA6,
0xD7978EEB,0x7EE8CDCD,0xE20EEA22,0x75660AAC,0xA738EA1C,0x8D89877E,0x1147406A,0x1AD2BC45,
0xA47CA14A,0x59450445,0xB2EB30ED,0x80654151,0x2A0E7DBB,0x6DB88320,0x5B64C2B0,0x4DBDF21C,
0xD202EF8D,0x41D912FF,0x2144DF1C,0x6522DF69,0xECBB4B55,0x190A55AD,0x758D6336,0xC2A8FA9D,
0x0D968558,0xB2AA7578,0xEFB5AF2E,0xF1E8BA9E,0xC71C0011,0xD8F49994,0xAB54D286,0x011FFCA6,
0xD7978EEB,0x7EE8CDCD,0xE20EEA22,0x75660AAC,0xA738EA1C,0x8D89877E
};
uint32_t crc32ofzeroblock(uint64_t i_size) 
{
	assert(i_size<9.007.199.254.740.992); //8D89877E 2^53 9.007.199.254.740.992
	if (i_size==0)
		return 0;
	uint32_t mycrc=0;
	unsigned int i=0;
	while (i_size > 0)
	{
		if ((i_size%2)==1)
			mycrc=crc32_combine(mycrc,zero_block_crc32[i],1<<i);
		i_size=i_size/2;
		i++;
	}
   	return mycrc;
}


uint32_t crc32zeros(int64_t i_size)
{
	uint64_t inizio=mtime();
	uint32_t crc=crc32ofzeroblock(i_size);
	g_zerotime+=mtime()-inizio;
	return crc;
}




/// concatenate multipart archive into one zpaq
/// check for freespace and (optionally) hash check
int Jidac::consolidate(string i_archive)
{
	/*
	printf("COnsolido\n");
	join_split();
	
	return 0;
*/
	assert(i_archive);
	printf("*** Merge (consolidate) ***\n");
	
	vector<string>	chunk_name;
	vector<int64_t>	chunk_size;
	
	const string part0=subpart(i_archive, 0);
	for (unsigned i=1; ;i++) 
	{
		const string parti=subpart(i_archive, i);
		if (i>1 && parti==part0) 
			break;
		if (!fileexists(parti))
			break;
		int64_t dimensione=prendidimensionefile(parti.c_str());
		if (dimensione<0)
			break;
		chunk_size.push_back(dimensione);
		chunk_name.push_back(parti);
	}
	if (chunk_name.size()==0)
	{
		printf("29515: Something strange: cannot find archive chunks\n");
		return 2;
	}
	int64_t total_size=0;
	for (int unsigned i=0;i<chunk_name.size();i++)
	{
		printf("Chunk %08d %20s <<%s>>\n",i,migliaia(chunk_size[i]),chunk_name[i].c_str());
		total_size+=chunk_size[i];
	}
	printbar('-');
	printf("Total %s %20s (%s)\n",migliaia2(chunk_name.size()),migliaia(total_size),tohuman(total_size));
	if (files.size()!=1)
	{
		printf("29545: exactly one file as output for consolidate\n");
		return 1;
	}
	
	string outfile=files[0];
	if (fileexists(outfile))
		if (!flagforce)
		{
			printf("29553: outfile exists, and no -force. Quit %s\n",outfile.c_str());
			return 1;
		}
	int64_t spazio=getfreespace(outfile);
	printf("Outfile    <<%s>>\n",outfile.c_str());
	printf("Free space %20s\n",migliaia(spazio));
	printf("Needed     %20s\n",migliaia(total_size));
	
	if (spazio<total_size)
		if (!flagspace)
		{
			printf("29564: Free space seems < needed, and no -space. Quit\n");
			return 1;
		}

#ifdef _WIN32
	wstring widename=utow(outfile.c_str());
	FILE* outFile=_wfopen(widename.c_str(), L"wb" );
#else
	FILE* outFile=fopen(outfile.c_str(), "wb");
#endif

	if (outFile==NULL)
	{
		printf("29579 :CANNOT OPEN outfile %s\n",outfile.c_str());
		return 2;
	}
	size_t const blockSize = 65536;
	unsigned char buffer[blockSize];
	int64_t donesize=0;
	int64_t startcopy=mtime();

	XXH3_state_t state128;
    (void)XXH3_128bits_reset(&state128);
	if (flagverify)
		printf("-verify: trust, but check...\n");
		
	for (int unsigned i=0;i<chunk_name.size();i++)
	{
		string	sorgente_nome=chunk_name[i];
		
		FILE* inFile = freadopen(sorgente_nome.c_str());
		if (inFile==NULL) 
		{
#ifdef _WIN32
		int err=GetLastError();
#else
		int err=1;
#endif
		printf("\n29585: ERR <%s> kind %d\n",sorgente_nome.c_str(),err); 

		return 2;
		}
		
		size_t readSize;
		int64_t	chunk_readed=0;
		int64_t	chunk_written=0;
		while ((readSize = fread(buffer, 1, blockSize, inFile)) > 0) 
		{
			int64_t written=fwrite(buffer,1,readSize,outFile);
			chunk_written+=written;
			chunk_readed+=readSize;
			donesize+=written;
			if (flagverify)
				(void)XXH3_128bits_update(&state128, buffer, readSize);
			avanzamento(donesize,total_size,startcopy);
		}
		
		fclose(inFile);
		if (flagverbose)
			printf("Chunk %08d R %20s W %20s E %20s\n",i,migliaia(chunk_readed),migliaia2(chunk_written),migliaia3(chunk_size[i]));
		if ((chunk_readed!=chunk_written) || (chunk_readed!=chunk_size[i]))
		{
			printf("29632: GURU on chunk %d Read, Write, Expec not equal!\n",i);
			return 1;
		}
	}
	fclose(outFile);
	printf("Done\n");
	printf("Written  %20s\n",migliaia(donesize));
	printf("Expected %20s\n\n",migliaia(total_size));
	if (donesize!=total_size)
	{
		printf("29645: GURU bytes written does not match expected\n");
		return 1;
	}
	if (flagverify)
	{
		printf("-flagverify: double check...\n");
		XXH128_hash_t myhash=XXH3_128bits_digest(&state128);
		char risultato[33];
		sprintf(risultato,"%016llX%016llX",(unsigned long long)myhash.high64,(unsigned long long)myhash.low64);
		
		uint32_t dummycrc32;
		int64_t startverify=mtime();
		int64_t io_lavorati=0;
		string hashreloaded=xxhash_calc_file(outfile.c_str(),false,dummycrc32,startverify,total_size,io_lavorati);
		printf("Expected   XXH3 hash of the output file %s\n",risultato);
		printf("Calculated XXH3 hash of the output file %s\n",hashreloaded.c_str());
		if (hashreloaded!=risultato)
		{
			printf("29658: GURU hash of output file does not match!\n");
			return 1;
		}
	}
	return 0;
	
}


int Jidac::test() 
{
	getpasswordifempty();

	if ((files.size()>0) && (!flagparanoid))
	{
		/// zpaqfranz t z:\1.zpaq k:\sorgente
		if (flagchecksum)
		printf("SHA-1-chunked verify+HASH checksum\n");
		else
		printf("SHA-1-chunked verify\n");
		return list();
	}
	if (flagparanoid)
	{
		if (tofiles.size()!=1)
		{
			printf("-paranoid needs a -to\n");
			return 2;
		}
		
		uint64_t tofoldersize=0;
		uint32_t tofoldernumber=0;
		uint32_t tofolderfolder=0;
		
		if (getfoldersize(tofiles[0],tofoldersize,tofoldernumber,tofolderfolder))
			if (tofoldersize>0)
			{
				printf("37333: WARNING the folder <<");
				printUTF8(tofiles[0].c_str());
				printf(">> contain %s bytes\n\n\n",migliaia(files_size[0]));		
				if (!getcaptcha("withoutmercy","Extract-check-delete without confirmation"))
					return 1;
			}
		return extract();
	}

	flagtest=true;
	summary=1;
  
	const int64_t sz=read_archive(archive.c_str());
	if (sz<1) error("archive not found");
	
 	
	for (unsigned i=0; i<block.size(); ++i) 
	{
		if (block[i].bsize<0) error("negative block size");
		if (block[i].start<1) error("block starts at fragment 0");
		if (block[i].start>=ht.size()) error("block start too high");
		if (i>0 && block[i].start<block[i-1].start) error("unordered frags");
		if (i>0 && block[i].start==block[i-1].start) error("empty block");
		if (i>0 && block[i].offset<block[i-1].offset+block[i-1].bsize)
			error("unordered blocks");
		if (i>0 && block[i-1].offset+block[i-1].bsize>block[i].offset)
			error("overlapping blocks");
	}

	///printf("franz: fine test blocchi\n");

  // Label files to extract with data=0.
  ExtractJob job(*this);
  int total_files=0;
  for (DTMap::iterator p=dt.begin(); p!=dt.end(); ++p) 
  {
		p->second.data=-1;  // skip
		if (p->second.date && p->first!="") 
		{
			const string fn=rename(p->first);
///			printf("--------------------> %s\n",fn.c_str());
			const bool isdir=p->first[p->first.size()-1]=='/';
			
			if (isdir)  // update directories later
				p->second.data=0;
			else 
				if (block.size()>0) 
			{  // files to decompress
				p->second.data=0;
				unsigned lo=0, hi=block.size()-1;  // block indexes for binary search
				for (unsigned i=0; p->second.data>=0 && i<p->second.ptr.size(); ++i) 
				{
					unsigned j=p->second.ptr[i];  // fragment index
					///printf("Fragment index %lld\n",j);
					if (j==0 || j>=ht.size() || ht[j].usize<-1) 
					{
						fflush(stdout);
						printUTF8(p->first.c_str(), stderr);
						fprintf(stderr, ": bad frag IDs, skipping...\n");
						p->second.data=-1;  // skip
						continue;
					}
					assert(j>0 && j<ht.size());
					
					if (lo!=hi || lo>=block.size() || j<block[lo].start
						|| (lo+1<block.size() && j>=block[lo+1].start)) 
						{
							lo=0;  // find block with fragment j by binary search
							hi=block.size()-1;
							while (lo<hi) 
							{
								unsigned mid=(lo+hi+1)/2;
								assert(mid>lo);
								assert(mid<=hi);
								if (j<block[mid].start) 
									hi=mid-1;
								else 
									(lo=mid);
							}
						}
						assert(lo==hi);
						assert(lo>=0 && lo<block.size());
						assert(j>=block[lo].start);
						assert(lo+1==block.size() || j<block[lo+1].start);
						unsigned c=j-block[lo].start+1;
						if (block[lo].size<c) 
							block[lo].size=c;
						if (block[lo].files.size()==0 || block[lo].files.back()!=p)
						{
							block[lo].files.push_back(p);
						///	printf("+++++++++++Pushato %s\n",p->first.c_str());
						}
				}
				++total_files;
				job.total_size+=p->second.size;
			}
		}  // end if selected
  }  // end for

///	dimtotalefile=job.total_size;
	printf("Check %s in %s files with %d threads\n",migliaia(job.total_size), migliaia2(total_files), howmanythreads);
	vector<ThreadID> tid(howmanythreads);
	
	for (unsigned i=0; i<tid.size(); ++i) 
		run(tid[i], decompressThread, &job);

  // Wait for threads to finish
	for (unsigned i=0; i<tid.size(); ++i) 
		join(tid[i]);

 
 
  // Report failed extractions
  unsigned extracted=0, errors=0;
  for (DTMap::iterator p=dt.begin(); p!=dt.end(); ++p) 
  {
    string fn=rename(p->first);
    if (p->second.data>=0 && p->second.date
        && fn!="" && fn[fn.size()-1]!='/') {
      ++extracted;
      if (p->second.ptr.size()!=unsigned(p->second.data)) {
        fflush(stdout);
        if (++errors==1)
          fprintf(stderr,
          "\nFailed (extracted/total fragments, file):\n");
        fprintf(stderr, "UJO %u/%u ",
                int(p->second.data), int(p->second.ptr.size()));
        printUTF8(fn.c_str(), stderr);
        fprintf(stderr, "\n");
      }
    }
  }
	if (errors>0) 
	{
		fflush(stdout);
		fprintf(stderr,
			"\nChecked %u of %u files OK (%u errors)"
			" using %1.3f MB x %d threads\n",
			extracted-errors, extracted, errors, job.maxMemory/1000000,
			int(tid.size()));
	}
	else
	{
		printf("No error detected in 1st stage (7.15, RAM ~ %s), try zpaqfranz (if enabled)\n",tohuman((uint64_t)(tid.size()*job.maxMemory)));
	}
//// OK now check against CRC32 and the entire World (if any)

	uint64_t startverify=mtime();
	
	sort(g_crc32.begin(),g_crc32.end(),comparecrc32block);
	
	unsigned int 	status_e		=0; //all kinds of error
	unsigned int 	status_e_hash	=0; //errors on hashes by file
	unsigned int 	status_e_crc	=0;	//errors on crcs by file
	unsigned int 	status_e_blocks	=0;	//errors on crcs by blocks
	
	unsigned int 	status_0		=0;
	unsigned int 	status_1		=0;
	uint32_t 		checkedfiles	=0;
	uint32_t 		uncheckedfiles	=0;
	
	unsigned int 	parti			=1;
	int64_t 		lavorati		=0;
	uint64_t 		dalavorare		=0;
	
	uint32_t 		currentcrc32	=0;
	uint32_t 		crc32stored		=0;
		
	
	for (unsigned int i=0;i<g_crc32.size();i++)
		dalavorare+=g_crc32[i].crc32size;
	
	printf("Checking  %s blocks with CRC32 (%s)\n",migliaia(g_crc32.size()),migliaia2(dalavorare));
	
	uint32_t 	parts=0;
	uint64_t	zeroedblocks=0;
	uint32_t	howmanyzero=0;
	g_zerotime=0;
	
	/*
	printf("======================\n");
	for (unsigned int i=0;i<g_crc32.size();i++)
	{
				printf("Start %08d %08lld\n",i,g_crc32[i].crc32start);
				printf("Size  %08d %08lld\n",i,g_crc32[i].crc32size);
	}
	printf("======================\n");
	*/
	
	unsigned int i=0;
	while (i<g_crc32.size())
	{
		if ( ++parts % 1000 ==0)
			if (!flagnoeta)
				printf("Block %08u K %s\r",i/1000,migliaia(lavorati));
            
		s_crc32block it=g_crc32[i];
		DTMap::iterator p=dt.find(it.filename);

		crc32stored=0;

		string myhashtype="";
		string myhash="";
		string mycrc32="";
				
		if (p != dt.end())
		{
			decode_franz_block(isdirectory(it.filename),p->second.franz_block,
			myhashtype,
			myhash,
			mycrc32);
			crc32stored=crchex2int(mycrc32.c_str());
		}
		
		if (flagdebug)
		{
			printf("MYhashtype   %s\n",myhashtype.c_str());
			printf("Myhash       %s\n",myhash.c_str());
			printf("Mycrc32      %s\n",mycrc32.c_str());
			printf("\n");
		}
/// Houston, we have something that start with a sequence of zeros, let's compute the missing CRC		
		if (it.crc32start>0)
		{
			uint64_t holesize=it.crc32start;
			/*
			printf("Holesize iniziale %ld\n",holesize);
			*/
			
			uint32_t zerocrc	=crc32zeros(holesize);
			currentcrc32		=crc32_combine(currentcrc32, zerocrc,holesize);
			lavorati			+=holesize;	
			zeroedblocks		+=holesize;
			howmanyzero++;
			/*
			char mynomefile[100];
			sprintf(mynomefile,"z:\\globals_%014lld_%014lld_%08X_prezero",holestart,holestart+holesize,zerocrc);
			FILE* myfile=fopen(mynomefile, "wb");
			fwrite(g_allzeros, 1, holesize, myfile);
			fclose(myfile);				
			*/
		}
		
		
		currentcrc32=crc32_combine(currentcrc32, it.crc32,it.crc32size);
		lavorati+=it.crc32size;
		
		while (g_crc32[i].filename==g_crc32[i+1].filename)
		{
			if ((g_crc32[i].crc32start+g_crc32[i].crc32size) != (g_crc32[i+1].crc32start))
			{
/// Houston: we have an "hole" of zeros from i to i+1 block. Need to take the fair CRC32
				/*
				printf("############################## HOUSTON WE HAVE AN HOLE %d %d\n",i,g_crc32.size());
				printf("Start %08lld\n",g_crc32[i].crc32start);
				printf("Size  %08lld\n",g_crc32[i].crc32size);
				printf("End   %08lld\n",g_crc32[i].crc32start+g_crc32[i].crc32size);
				printf("Next  %08lld\n",g_crc32[i+1].crc32start);
				*/
				///uint64_t holestart=g_crc32[i].crc32start+g_crc32[i].crc32size;
				///printf("Holestart  %08lld\n",holestart);
				
				uint64_t holesize=g_crc32[i+1].crc32start-(g_crc32[i].crc32start+g_crc32[i].crc32size);
				///printf("Hole Size  %08lld\n",holesize);
				/*
				uint32_t zerocrc;
				zerocrc=crc32_16bytes (allzeros,(uint32_t)holesize);
				//printf("zero  %08X\n",zerocrc);
				currentcrc32=crc32_combine(currentcrc32, zerocrc,(uint32_t)holesize);
				
				*/
				uint32_t zerocrc=crc32zeros(holesize);
				currentcrc32=crc32_combine(currentcrc32, zerocrc,holesize);
				lavorati+=holesize;
				zeroedblocks+=holesize;
				howmanyzero++;
				/*
				char mynomefile[100];
				sprintf(mynomefile,"z:\\globals_%014lld_%014lld_%08X_zero",holestart,holestart+holesize,zerocrc);
				FILE* myfile=fopen(mynomefile, "wb");
				fwrite(g_allzeros, 1, holesize, myfile);
				fclose(myfile);
				*/
				
			}
			i++;
			s_crc32block myit=g_crc32[i];
			currentcrc32=crc32_combine (currentcrc32, myit.crc32,myit.crc32size);
			lavorati+=myit.crc32size;
			parti++;
		}
		
		string filedefinitivo=g_crc32[i].filename;
		if ((searchfrom!="") && (replaceto!=""))
					replace(filedefinitivo,searchfrom,replaceto);
			
		if (flagdebug)
			printf("Stored %08X calculated %08X %s\n",crc32stored,currentcrc32,filedefinitivo.c_str());

		if (mycrc32!="")
		{
			if (currentcrc32==crc32stored)
			{
				if (flagdebug)
					printf("GOOD: STORED %08X = DECOMPRESSED %s\n",crc32stored,filedefinitivo.c_str());
				status_1++;
			}
			else
			{
				printf("ERROR:  STORED CRC-32 %08X != DECOMPRESSED %08X (ck %08d) %s\n",crc32stored,currentcrc32,parti,filedefinitivo.c_str());
				status_e_blocks++;
			}
		}
		else
		{	// we have and old style ZPAQ without CRC32
			uncheckedfiles++;
			///printf("CRC32: %08X %08X (parti %08d) %s\n",currentcrc32,chekkone,parti,filedefinitivo.c_str());
		}
		parti=1;
		currentcrc32=0;
		i++;
	}
	printf("\nVerify time %f s\n",(mtime()-startverify)/1000.0);
	
	printf("Blocks %19s (%12s)\n",migliaia(dalavorare),migliaia2(g_crc32.size()));
	printf("Zeros  %19s (%12s) %f s\n",migliaia(zeroedblocks),migliaia2(howmanyzero),(g_zerotime/1000.0));
	printf("Total  %19s speed %s/sec\n",migliaia(dalavorare+zeroedblocks),migliaia2((uint64_t)((dalavorare+zeroedblocks)/((mtime()-startverify+1)/1000.0))));
	
	
	if (checkedfiles>0)
		printf("Checked       : %08d of %08d (zpaqfranz)\n",checkedfiles,total_files);

	if (uncheckedfiles>0)
	{
		printf("UNcheck       : %08d of %08d (zpaq 7.15)\n",uncheckedfiles,total_files);
			status_0=uncheckedfiles;
	}
	
	if (status_e_hash)
	printf("ERRORS HASH   : %08d (ERROR verifyng hash from disk)\n",status_e_hash);
	if (status_e_crc)
	printf("ERRORS CRC FI : %08d (ERROR verifyng CRC-32 from disk)\n",status_e_crc);
	if (status_e_blocks)
	printf("ERRORS        : %08d (ERROR in rebuilded CRC-32, SHA-1 collisions?)\n",status_e_blocks);
	status_e = status_e_hash+status_e_crc+status_e_blocks;
	if (status_e)
	morebar('-');
	
	if (status_0)
	printf("WARNING       : %08d (Cannot say anything)\n",status_0);
	
	if (status_1)
	printf("GOOD          : %08d of %08d (stored=decompressed)\n",status_1,total_files);
	
	if (status_e==0)
	{
		if (status_0)
			printf("VERDICT       : UNKNOWN  (Cannot say anything)\n");
		else
			printf("VERDICT       : OK (CRC-32 stored vs decompressed)\n");
	}
	else
	{
		printf("WITH ERRORS\n");
		errors=2;
	}
	

	if (flagverify)
	{
		printbar('+');
		printf("Re-testing (hashing) from filesystem (-verify) if possible\n");
		errors+=verify(false);
	}
	
  return (errors+status_e)>0;
}





/*
We need something out of an object (Jidac), addfile() and scandir(), 
because pthread does not like very much objects.
Yes, quick and dirty
*/
void myaddfile(uint32_t i_tnumber,DTMap& i_edt,string i_filename, int64_t i_date,int64_t i_size, bool i_flagcalchash) 
{
	///Raze to the ground ads and zfs as soon as possible
	if (!flag715)
		if (isads(i_filename))
			return;
		
	if (!flagforcezfs)
		if (iszfs(i_filename))
			return;
				
	if (minsize>0)
		if ((uint64_t)i_size<minsize)
		{
			if (flagdebug)
				printf("27072: (-minsize) too small %19s %s\n",migliaia(i_size),i_filename.c_str());
			return;
		}
	if (maxsize>0)
		if ((uint64_t)i_size>maxsize)
		{
			if (flagdebug)
				printf("27080: (-maxsize) too large %19s %s\n",migliaia(i_size),i_filename.c_str());
			return;
		}


	
	int64_t dummy;
	DT& d=i_edt[i_filename];
	d.date=i_date;
	d.size=i_size;
	d.attr=0;
	d.data=0;
	d.hexhash="";
	
	if (i_flagcalchash)
		if (!isdirectory(i_filename))
		{
			int64_t starthash=mtime();
			uint32_t dummycrc;
			///printf("k1 lemmada\n");
			d.hexhash=hash_calc_file(flag2algo(),i_filename.c_str(),false,dummycrc,mtime(),prendidimensionefile(i_filename.c_str()),dummy);
			if (flagverbose)
			{
				printf("%s: |%s| [%d] %6.3f ",mygetalgo().c_str(),d.hexhash.c_str(),i_tnumber,(mtime()-starthash)/1000.0);
				printUTF8(i_filename.c_str());
				printf("\n");
			}
		}
///  thread safe, but... who cares? 
	pthread_mutex_lock(&g_mylock);

	///printf("i_tnumber %d\n",i_tnumber);
	///printf("size %d\n",g_arraybytescanned.size());
	g_arraybytescanned[i_tnumber]+=i_size;
	g_arrayfilescanned[i_tnumber]++;
	
	if (!flagnoeta)
	{
		if (i_flagcalchash)
		{
			if (!(g_arrayfilescanned[i_tnumber] % 100))
			{
				for (unsigned int i=0; i<g_arraybytescanned.size();i++)
					printf("Checksumming |%02d|%10s %12s\n",i,tohuman(g_arraybytescanned[i]),migliaia(g_arrayfilescanned[i]));
				setupConsole();
				printf("\033[%dA",(int)g_arraybytescanned.size());
				restoreConsole();
			}
		}
		else
		{
			if (!(g_arrayfilescanned[i_tnumber] % 1000))
			{
				for (unsigned int i=0; i<g_arraybytescanned.size();i++)
					printf("|%02d|%10s %12s\n",i,tohuman(g_arraybytescanned[i]),migliaia(g_arrayfilescanned[i]));
				setupConsole();
				printf("\033[%dA",(int)g_arraybytescanned.size());
				restoreConsole();
			}
		}
		fflush(stdout);
	}
	pthread_mutex_unlock(&g_mylock);
}

void myscandir(uint32_t i_tnumber,DTMap& i_edt,string filename, bool i_recursive,bool i_flagcalchash)
{
	
	///Raze to the ground ads and zfs as soon as possible
	if (isads(filename))
	{
		if (flagverbose)
			printf("Skip :$DATA ----> %s\n",filename.c_str());
		return;
	}
	if (!flagforcezfs)
		if (iszfs(filename))
		{
			if (flagverbose)
				printf("Skip .zfs ----> %s\n",filename.c_str());
			return;
		}
	
#ifdef unix
// Add regular files and directories
  while (filename.size()>1 && filename[filename.size()-1]=='/')
    filename=filename.substr(0, filename.size()-1);  // remove trailing /
	struct stat sb;
	if (!lstat(filename.c_str(), &sb)) 
	{
		if (S_ISREG(sb.st_mode))
		myaddfile(i_tnumber,i_edt,filename, decimal_time(sb.st_mtime), sb.st_size,i_flagcalchash);

    // Traverse directory
		if (S_ISDIR(sb.st_mode)) 
		{
			myaddfile(i_tnumber,i_edt,filename=="/" ? "/" : filename+"/", decimal_time(sb.st_mtime),0, i_flagcalchash);
			DIR* dirp=opendir(filename.c_str());
			if (dirp) 
			{
				for (dirent* dp=readdir(dirp); dp; dp=readdir(dirp)) 
				{
					if (strcmp(".", dp->d_name) && strcmp("..", dp->d_name)) 
					{
						string s=filename;
						if (s!="/") s+="/";
						s+=dp->d_name;
						if (i_recursive)        
							myscandir(i_tnumber,i_edt,s,true,i_flagcalchash);
						else
						{
							if (!lstat(s.c_str(), &sb)) 
							{
								if (S_ISREG(sb.st_mode))
									myaddfile(i_tnumber,i_edt,s, decimal_time(sb.st_mtime), sb.st_size,i_flagcalchash);
								if (S_ISDIR(sb.st_mode)) 
									myaddfile(i_tnumber,i_edt,s=="/" ? "/" :s+"/", decimal_time(sb.st_mtime),0, i_flagcalchash);
							}
						}          			
					}
				}
				closedir(dirp);
			}
			else
				perror(filename.c_str());
		}
	}
	else
		perror(filename.c_str());

#else  // Windows: expand wildcards in filename
	
  // Expand wildcards
	WIN32_FIND_DATA ffd;
	string t=filename;
	
///	printf("t1:   %s\n",t.c_str());
	if (t.size()>0 && t[t.size()-1]=='/') 
		t+="*";

	///printf("t2:   %s\n",t.c_str());
	
	HANDLE h=FindFirstFile(utow(t.c_str()).c_str(), &ffd);
	if (h==INVALID_HANDLE_VALUE && GetLastError()!=ERROR_FILE_NOT_FOUND && GetLastError()!=ERROR_PATH_NOT_FOUND)
		printerr("29617",t.c_str(),0);

///	printf("t22:   %s\n",t.c_str());
	
	
	while (h!=INVALID_HANDLE_VALUE) 
	{

    // For each file, get name, date, size, attributes
		SYSTEMTIME st;
		int64_t edate=0;
		if (FileTimeToSystemTime(&ffd.ftLastWriteTime, &st))
			edate=st.wYear*10000000000LL+st.wMonth*100000000LL+st.wDay*1000000
				+st.wHour*10000+st.wMinute*100+st.wSecond;
		const int64_t esize=ffd.nFileSizeLow+(int64_t(ffd.nFileSizeHigh)<<32);
    
    // Ignore links, the names "." and ".." or any unselected file
		t=wtou(ffd.cFileName);
		
/*
		if (t=="tempisinca.xls")
		{
			printf("MOROOOOOOOOOOOO %s\n",t.c_str());
			exit(0);
		}
		*/
		if (flagdebug) // sometimes Windows get very strange attributes
		{
			printf("%08X MY new t2 %s\n",(unsigned int)ffd.dwFileAttributes,t.c_str());
			string temp=decodewinattribute(ffd.dwFileAttributes);
			printf("%s\n",temp.c_str());
			printf("\n");
		}

		if (t=="." || t=="..") 
			edate=0;  // don't add, of course

		if ((ffd.dwFileAttributes & FILE_ATTRIBUTE_REPARSE_POINT) && (!(ffd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)))
		{
				/// Houston, we have a strange deduplicated .vhdx file?
				/// add as by default
				if (flagverbose)
					printf("Verbose: found something strange2 (VHDX?) %s\n",t.c_str());
		}
		else
		{
			///	A junction?
			if ((ffd.dwFileAttributes & FILE_ATTRIBUTE_REPARSE_POINT) && (ffd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
				edate=0;  // don't add
		}
		
		string fn=path(filename)+t;
	
	
    // Save directory names with a trailing / and scan their contents
    // Otherwise, save plain files
		if (edate) 
		{
			if (ffd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) 
				fn+="/";
			
			
			myaddfile(i_tnumber,i_edt,fn, edate, esize, i_flagcalchash);
			if (i_recursive)
				if (ffd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) 
				{
					fn+="*";
					myscandir(i_tnumber,i_edt,fn,true,i_flagcalchash);
				}
		}
		if (!FindNextFile(h, &ffd)) 
		{
			if (GetLastError()!=ERROR_NO_MORE_FILES) 
				printerr("29656",fn.c_str(),ffd.dwFileAttributes);
			break;
		}
	}
  FindClose(h);
#endif
}



///	parameters to run scan threads
struct tparametri
{
	bool		recursive;
	string 		directorytobescanned;
	DTMap		theDT;
	bool		flagcalchash;
	uint64_t	timestart;
	uint64_t	timeend;
	int	tnumber;
};


///	run a myscandir() instead of Jidac::scandir() (too hard to use a member)
void * scansiona(void *t) 
{
	assert(t);
	tparametri* par= ((struct tparametri*)(t));
	DTMap& tempDTMap = par->theDT;
	myscandir(par->tnumber,tempDTMap,par->directorytobescanned,par->recursive,par->flagcalchash);
	par->timeend=mtime();
	pthread_exit(NULL);
	return 0;
}




/// make a "robocopy" from source to destination file.
/// if "someone" call with valid parameters do NOT do a getfileinfo (slow)
string secure_copy_file(
const string i_filename,const string i_outfilename,int64_t i_startcopy,int64_t i_totalsize,int64_t i_totalcount,int64_t& o_writtensize,int64_t& o_donesize,int64_t& o_donecount,
int64_t i_sorgente_size,
int64_t i_sorgente_date,
int64_t i_sorgente_attr,
int64_t i_destinazione_size,
int64_t i_destinazione_date,
int64_t i_destinazione_attr
)
{
	static int ultimapercentuale=0;
	/*
	string solonome=extractfilename(i_filename);
	if (solonome=="tempisinca.xls")
		printf("K1 MUORO %s\n",solonome.c_str());
	*/
	if (flagdebug)
	{
		printf("\n");
		printf("From:   %s\n",i_filename.c_str());
		printf("To:     %s\n",i_outfilename.c_str());
	}
	if (i_filename=="")
		return "30833:SOURCE-EMPTY";
	
	if (i_outfilename=="")
		return "30836:DEST-EMPTY";
	
	if (isdirectory(i_filename))
	{
		makepath(i_outfilename);
		return "OK";
	}
	
	int64_t sorgente_dimensione=0;
	int64_t sorgente_data=0;
	int64_t sorgente_attr=0;
	
	int64_t destinazione_dimensione=0;
	int64_t destinazione_data=0;
	int64_t destinazione_attr=0;
	
	bool	sorgente_esiste=false;
	bool	destinazione_esiste=false;
	/*
	hopefully the source is ALWAYS existing!
	int64_t start_sorgente_esiste=mtime();
	sorgente_esiste		=getfileinfo(i_filename,sorgente_dimensione,sorgente_data,sorgente_attr);
	g_robocopy_check_sorgente+=mtime()-start_sorgente_esiste;
	*/
	sorgente_esiste=true;		// trust in caller
	sorgente_dimensione=i_sorgente_size;
	sorgente_data=i_sorgente_date;
	sorgente_attr=i_sorgente_attr;
	
	if (i_destinazione_size>=0)
	{
		/// someone call us with valid size=> take the parameters
		destinazione_esiste=true;
		destinazione_dimensione=i_destinazione_size;
		destinazione_data=i_destinazione_date;
		destinazione_attr=i_destinazione_attr;
	}
	else
	{
		/// houston, we have to make ourself
		int64_t start_destinazione_esiste=mtime();
		destinazione_esiste	=getfileinfo(i_outfilename,destinazione_dimensione,destinazione_data,destinazione_attr);
		g_robocopy_check_destinazione+=mtime()-start_destinazione_esiste;
	}
	
	if (flagdebug)
	{
		printf("Sorgente     esiste  %d\n",(int)sorgente_esiste);
		printf("Sorgente     size    %s\n",migliaia(sorgente_dimensione));
		printf("Sorgente     data    %s\n",migliaia(sorgente_data));
		printf("Destinazione esiste  %d\n",(int)destinazione_esiste);
		printf("Destinazione size    %s\n",migliaia(destinazione_dimensione));
		printf("Destinazione data    %s\n",migliaia(destinazione_data));
		printf("\n");
	}
	
	if (!flagdonotforcexls)
		if (isxls(i_filename))
		{
///	Old Office (2000) can change xls (and ppt) metadata without "touching"
/// Therefore size-and-date algo does not work, to detect change, making hash check fail 
/// (zpaq, rsync, robocopy for example)
/// The changes are in the beginning of the file, so a 64K block comparison is normally 
/// faster than the full hash computation (for different files). 
/// Obviously for the very same files it is almost identical
/*
	if (solonome=="tempisinca.xls")
		printf("K2 MUORO %s\n",solonome.c_str());
*/
			if (flagdebug)
				printf("27584: enforcing xls/ppt test %s\n",i_filename.c_str());

			destinazione_esiste=isfilesequal(i_filename,i_outfilename,flagzero);
			if (destinazione_esiste)
			{
				if (flagdebug)
					printf("Equal XLS: skip %s\n",i_outfilename.c_str());
				close(i_outfilename.c_str(),sorgente_data,sorgente_attr);
				return "=";
			}
			else
			{
	///			printf("K3: da uccidere!\n");
				if (flagdebug)
					printf("Different XLSs!\n");
			}
			
		}
		
	if (destinazione_esiste)
	{
		if (flagdebug)
			printf("Esiste1\n");
			
		if (sorgente_esiste)
		{
			if (flagdebug)
			{
				printf("Esiste2\n");
			}
				if (destinazione_dimensione==sorgente_dimensione)
				{
					if (flagdebug)
						printf("Stessa dimensione\n");
					if (flagdebug)
					{
						printf("39590: PPP %s\n",migliaia(myabs(destinazione_data,sorgente_data)));
					}
				/// this 2 is really important: it is the modulo-differences
				/// 1 or even 0 is not good for NTFS or Windows
				
					if (myabs(destinazione_data,sorgente_data)<=2)
					{
						if (flagdebug)
							printf("Stessa data\n");
						if (flagkill)
							if (sorgente_attr!=destinazione_attr)
								close(i_outfilename.c_str(),sorgente_data,sorgente_attr);
					
						o_donesize+=sorgente_dimensione;
						o_donecount++;
						
						if (!flagnoeta)
						{
							int percentuale=100*o_donecount/(i_totalcount+1);
							if (percentuale%10==0)
								if (percentuale!=ultimapercentuale)
								{
									printf("Done %02d %% %12s /%12s (%11s /%11s)\n",percentuale,migliaia(o_donecount),migliaia2(i_totalcount),tohuman(o_donesize),tohuman2(i_totalsize));
									ultimapercentuale=percentuale;
								}
						}
						
						return "=";
					}
				}
		}
		if (flagkill)
			if ((!flagappend) && (!iszpaq(i_outfilename)))
			{
				delete_file(i_outfilename.c_str());
			if (flagdebug)
				printf("Cancellato %s\n",i_outfilename.c_str());
			}
	}
	
	if (!flagkill)
		return "OK";
		
	size_t const blockSize = 65536;
	unsigned char buffer[blockSize];
	FILE* inFile = freadopen(i_filename.c_str());

	if (inFile==NULL) 
	{
#ifdef _WIN32
		int err=GetLastError();
#else
		int err=1;
#endif
		printf("\nERR <%s> kind %d\n",i_filename.c_str(),err); 

		return "KAPUTT";
	}

	if (flagappend)
	{
		if (destinazione_dimensione>=sorgente_dimensione)
			flagappend=false;	// full overwrite

		if (!iszpaq(i_filename))
		{
			if (flagdebug)
				printf("35672: not a ZPAQ / not flagappend!\n");
			flagappend=false;
		}
		else
		{
			if (flagdebug)
				printf("35677: we have a ZPAQ and a --append!\n");
		}
	}

	/// to fix excluded myaddfiles()
	makepath(i_outfilename);
	
	FILE* outFile=NULL;

	if (flagdebug)
	{
		if (fileexists(i_outfilename))
			printf("ESISTE file %s\n",i_outfilename.c_str());
		else
			printf("NON ESISTE APPEND %s\n",i_outfilename.c_str());
	}

	if (flagappend)
		if (!isfilesequal(i_filename,i_outfilename,true))
		{
			if (flagdebug)
					printf("35768: fast check failed, turn back to full copy %s %s\n",i_filename.c_str(),i_outfilename.c_str());
			flagappend=false;
		}

#ifdef _WIN32
	wstring widename=utow(i_outfilename.c_str());

	if (flagappend)
	{
		if (flagdebug)
			printf("\nApro con APPEND \n");
		outFile=_wfopen(widename.c_str(), L"ab" );
	}
	else
	{
		if (flagdebug)
			printf("\nApro con WRITE \n");
		outFile=_wfopen(widename.c_str(), L"wb" );
	}
#else
	if (flagappend)
		outFile=fopen(i_outfilename.c_str(), "ab");
	else
		outFile=fopen(i_outfilename.c_str(), "wb");
#endif
/*
	if (solonome=="tempisinca.xls")
		printf("K5 sono su apertura %s %s\n",solonome.c_str(),i_outfilename.c_str());
*/
	if (outFile==NULL) 
		return "30847:CANNOT OPEN outfile "+i_outfilename;
	
	size_t readSize;

#define LARGEFILE 100000000

	int larghezzaconsole=terminalwidth();
	if (larghezzaconsole>=50)
		larghezzaconsole=50;
	else
		larghezzaconsole=0;
	
	if (flagnoeta)
		larghezzaconsole=0;
		
	int64_t scrittitotali=0;
	int64_t dascrivere=sorgente_dimensione;

	int lastbarra=0;
	if ((sorgente_dimensione>LARGEFILE) && (larghezzaconsole>0))
		printf("%s",tohuman(sorgente_dimensione));
	
	
	if (flagappend)
	{
		if (destinazione_dimensione<sorgente_dimensione)
		{
			if (flagdebug)
			{
				printf("\nFaccio APPEND\n");
				printf("Sorgente dimensione     %19s\n",migliaia(sorgente_dimensione));
				printf("Destinazione dimensione %19s\n",migliaia(destinazione_dimensione));
			}
			fseeko(inFile	,destinazione_dimensione, SEEK_SET);
			
			if (flagdebug)
				printf("Seekato a %s\n",migliaia(destinazione_dimensione));
			dascrivere=sorgente_dimensione-destinazione_dimensione;
			
			if (flagdebug)
				printf("Da scrivere             %19s\n",migliaia(dascrivere));
		}
	}
	
	/*
	if (solonome=="tempisinca.xls")
		printf("K6 sono su apertura %s %s\n",solonome.c_str(),i_outfilename.c_str());
*/
	while ((readSize = fread(buffer, 1, blockSize, inFile)) > 0) 
	{
		if (flagzero)
			memset(buffer,0,sizeof(buffer));

		int scritti=fwrite(buffer,1,readSize,outFile);
	/*	
		if (solonome=="tempisinca.xls")
			printf("K7 scritti %19s\n",migliaia(scritti));
*/
		///printf("Scritti %19s\n",migliaia(scritti));
		scrittitotali+=scritti;
		o_donesize+=scritti;
		o_writtensize+=scritti;
		if ((sorgente_dimensione>LARGEFILE) && (larghezzaconsole>0))
		{
			int barra=larghezzaconsole*scrittitotali/(sorgente_dimensione+1);
			if (barra>lastbarra)
			{
				printf(".");
				lastbarra=barra;
			}
		}
		else
			myavanzamento(o_donesize,i_totalsize,i_startcopy);
		
	}
	if (flagappend)
		if (flagdebug)
		{
			printf("\nScritti %s\n",migliaia(scrittitotali));
		}	
	
	if ((sorgente_dimensione>LARGEFILE) && (larghezzaconsole>0))
		printf("\r                                                            \r");

	myavanzamento(o_donesize,i_totalsize,i_startcopy);
	fclose(inFile);
	fclose(outFile);
	
	/*
	if (solonome=="tempisinca.xls")
		printf("K7 faccio il touccione su i_outfilename %%s\n",i_outfilename.c_str());
*/
/// note: this is a "touch" for the attr
	close(i_outfilename.c_str(),sorgente_data,sorgente_attr);
	
	o_donecount++;
	
	
	if (scrittitotali!=dascrivere)
	{
		printf("\n");
		printf("35107: HOUSTON something seems wrong: expected %s, done %s\n",migliaia(dascrivere),migliaia2(scrittitotali));
		printf("35107: Corrupted source files? Lost connection? Cannot access? Media full?\n");
		return "35109: COPY CORRUPTED";
	}
	
	return "OK";
	
}


#ifdef unix

#include <stdio.h>
#include <string.h>
#include <string>
#include <cstdio>
#include <iostream>
#include <memory>
#include <stdexcept>
#include <string>
#ifndef ESX
#include <array>
#endif
#include <vector>

std::string exec(const char* cmd) 
{
    #ifdef ESX
	return "";
#else

	std::array<char, 128> buffer;
    std::string result;
    std::unique_ptr<FILE, decltype(&pclose)> pipe(popen(cmd, "r"), pclose);
 ////  if (!pipe) 
     ////   throw std::runtime_error("popen() failed!");

    while (fgets(buffer.data(), buffer.size(), pipe.get()) != nullptr) 
        result += buffer.data();
    return result;
#endif
}
#else
// a debug function
string exec(const char* cmd) 
{
	printf("Debug function (Windows does not have ZFS!) reading .\\lista.txt\n");
	string risultato;
	string i_filename=".\\lista.txt";
	string dummy=cmd;
		
    FILE* inFile = freadopen(i_filename.c_str());
	if (inFile==NULL) 
		return "";
	char buffer[65536*4]; /// max a 256KB snapshot-debug-list.
	
	if ((uint64_t)prendidimensionefile(i_filename.c_str())>sizeof(buffer))
	{
		printf("30571: debug GURU loading a too big lista.txt\n");
		error("seppuku");
	}
	
	fread(buffer, 1, sizeof(buffer), inFile);
	risultato=buffer;
	fclose(inFile);
	return risultato;
}

#endif

int pos(const std::string &i_stringa,const std::string& i_cerca)
{
    return (i_stringa.find(i_cerca));
}



string Jidac::zfs_get_snaplist(string i_header,string i_footer,vector<string>& o_array_primachiocciola,vector<string>& o_array_dopochiocciola)
{
	string filebatch="/tmp/exec_zfs.sh";
	filebatch=nomefileseesistegia(filebatch);
	if (flagdebug)
		printf("36337 script EXECUTING %s\n",filebatch.c_str());
	FILE* batch=fopen(filebatch.c_str(), "wb");
	fprintf(batch,"zfs list -t snapshot\n");
	fclose(batch);
	
	if (chmod(filebatch.c_str(),0700)!=0)
		return "30515: error on chmod";

	string snapshotlist=exec(filebatch.c_str());
	if (snapshotlist=="")
		return "30490: snapshot list empty";
	
	string temp;

	int 			posizioneused	=-1;
	unsigned int 	i				=0;
	while (i<snapshotlist.length())
	{
		if (snapshotlist[i]!=10)
			temp+=snapshotlist[i];
		else
		{
			if (pos(temp,"NAME")==0)
				posizioneused=pos(temp,"USED");
			if (stristr(temp.c_str(),i_header.c_str()))
			{
				
				if (posizioneused>=0)
				{
					temp=temp.substr(0,posizioneused);
				
					int posizionechiocciola=pos(temp,"@");
				
					if (posizionechiocciola>0)
					{
						
						string primachiocciola=temp.substr(0,posizionechiocciola);
						string nomesnap=temp.substr(posizionechiocciola+1,temp.length());
						
						string trimmato="";
						for (unsigned int i=0;i<nomesnap.length();i++)
							if (nomesnap[i]!=' ')
								trimmato+=nomesnap[i];
							else
								break;
						
						nomesnap=trimmato;
						int posizionefooter=pos(nomesnap,i_footer);
						if ((i_footer=="") || (posizionefooter>=0))
						{
							nomesnap=mytrim2(nomesnap);
							o_array_dopochiocciola.push_back(nomesnap);
								
							primachiocciola=mytrim2(primachiocciola);
							o_array_primachiocciola.push_back(primachiocciola);	
						}
						
					}
				}
			}
			temp="";
		}
		i++;
	}
	
	delete_file(filebatch.c_str());
	return snapshotlist;

}

string	heuristic_output_search(vector<string>& i_array)
{
	for (unsigned int i=0;i<i_array.size();i++)
	{
		if (i_array[i]=="-output")
			if (i+1<i_array.size())
				if (i_array[i+1]!="")
					return i_array[i+1];
	}
	return "";
}
int Jidac::zfs(string command)
{
	if (flagdebug)
	{
		printf("*** ZFS support functions ***\n");
		printf("With command %s\n",command.c_str());
	}
	
	
	if (command=="zfsadd")
		if (files.size()<3)
			{
				printf("For zfsadd you need at least 3 parameters\n\n");
				printf("*** DO NOT FORGET THE DOUBLEQUOTE ***\n\n");
				help_zfs(true,true);
				return 1;
			}

	if ((command=="zfspurge") || (command=="zfslist"))
		if (files.size()<1) // impossible
		{
			printf("For zfspurge/zfslist you need at least 1 parameter\n\n");
			printf("*** DO NOT FORGET THE DOUBLEQUOTE ***\n\n");
			help_zfs(true,true);
			return 1;
		}
		
		
	if ((command=="zfspurge") || (command=="zfslist") || (command=="zfsadd"))
	{
		string 	header		=files[0];//"tank/d@2021";
		string 	footer		="";
		string	exepath		=zpaqfranzexename;
		string  zpaqfile	=""; ///zfsadd
		string 	onlysubdir	=""; ///zfsadd
				
		if (files.size()>1)
			footer=files[1];
			
		if (header=="*")
			header="";

		if (footer=="*")
			footer="";
			
		vector<string> array_primachiocciola;
		vector<string> array_dopochiocciola;
		
		string risul=zfs_get_snaplist(header,footer,array_primachiocciola,array_dopochiocciola);
		vector<string> thefile;

//		this is a double check that the rebuilded snapshot name does really exists in the
//		original file. Split one lines at time
		explode(risul,'\n',thefile);

/*
		for (unsigned int i=0;i<thefile.size();i++)
			printf("LINE   %08d |%s|\n",i,thefile[i].c_str());
*/	
		if (array_primachiocciola.size()==0)
		{
			printf("32030: nothing to do. Do you use the doublequote?\n");
			return 1;
		}
		
		
		string	myoutput=heuristic_output_search(files);
		if (myoutput!="")
			open_output(myoutput);
		
		if (command=="zfsadd")
		{
		/*
		
		Files  0 tank/d@2021
		Files  1 --60d
		Files  2 z:/kongo60.zpaq
		(3)

		Files  0 tank/d@2021
		Files  1 --60d
		Files  2 z:/kongo60.zpaq
		Files  3 scanner
		(4)
		
		Files  0 tank/d@2021
		Files  1 --60d
		Files  2 z:/kongo60.zpaq
		files  3 "scanner"
		Files  4 -output
		Files  5 z:/1.bat
		(6)
		
		Files  0 tank/d@2021
		Files  1 --60d
		Files  2 z:/kongo60.zpaq
		Files  3 -output
		Files  4 z:/1.bat
		
		(5)
		*/
			if (flagdebug)
				for (unsigned int i=0;i<files.size();i++)
					printf("Files  %d %s\n",i,files[i].c_str());
			
			///exepath		=files[2];//"/tmp/47/zpaqfranz";
			zpaqfile	=files[2];//"/temporaneo/kongo7.zpaq";
			
			if (files.size()>3)
			{
				///printf("entro1\n");
				
				if (files[3]!="-output")
				{
					///printf("entro2\n");
					onlysubdir=files[3];
					if (onlysubdir[0]=='/') 
						onlysubdir.erase(0,1);
					if (onlysubdir!="")
						if (!isdirectory(onlysubdir))
						onlysubdir+="/";
				}
				
			}

			///if (flagdebug)
			{
				
				printf("Exepath  : %s\n",exepath.c_str());
				printf("Zpaqfile : %s\n",zpaqfile.c_str());
				printf("Header   : %s\n",header.c_str());
				printf("Footer   : %s\n",footer.c_str());
				if (onlysubdir!="")
					printf("Subdir   : %s\n",onlysubdir.c_str());
				if (myoutput!="")
					printf("Output on: %s\n",myoutput.c_str());
			}
			
		}
		vector<string> 	snapshot_folder;
		vector<int64_t>	snapshot_date;
		vector<string>  snapshot_to;
		
		for (unsigned int i=0;i<array_primachiocciola.size();i++)
		{
			string prima_chiocciola	=array_primachiocciola	[i];
			string dopo_chiocciola	=array_dopochiocciola	[i];
			
			string tutto=prima_chiocciola+"@"+dopo_chiocciola;
			
			string doublecheck=tutto+" "; // please note the space
			bool flagtrovato=false;
			for (unsigned int j=0;j<thefile.size();j++)
				if (pos(thefile[j],doublecheck)>=0)
				{
					flagtrovato=true;
					break;
				}
			if (flagtrovato)
			{
				if (command=="zfsadd")
				{
					if (prima_chiocciola[0]!='/') 
						prima_chiocciola="/"+prima_chiocciola;
			
					string percorso=prima_chiocciola+"/.zfs/snapshot/"+dopo_chiocciola+"/";
			
					string timestamp=dopo_chiocciola;
					myreplace(timestamp,footer,"");
			
					int64_t testdate=encodestringdate(timestamp);
					if (testdate==-1)
					{
						printf("30640: timestamp is strange %s\n",timestamp.c_str());
						return 2;
					}
					else
					{
						snapshot_date.push_back(testdate);
						snapshot_folder.push_back(percorso+onlysubdir);
						snapshot_to.push_back(prima_chiocciola+"/"+onlysubdir);
					}
					
					tutto=exepath+" a "+zpaqfile+" "+percorso+onlysubdir+" -to "+prima_chiocciola+"/"+onlysubdir+" -timestamp "+timestamp;
				}
				else
				if (command=="zfspurge")
					myprintf("zfs destroy ");
				if (!flagforce)
				myprintf("%s\n",tutto.c_str());
			}
			else
			{
				printf("30816: guru evalutating <<%s>>\n",doublecheck.c_str());
				return 2;
			}
		}
		
		if (g_output_handle)
		{
			fclose(g_output_handle);
#ifdef unix
// ok we want the +x
		chmod(g_output.c_str(),0700);
#endif
		}
		if ((command=="zfsadd") && (flagforce)) /// -force, to be checked
			if (snapshot_date.size()>0)
			{
				archive=zpaqfile;
				bool allok=true;
				for (unsigned int i=0;i<snapshot_date.size();i++)
				{
					printbar('-');
					printf("Freezing %8s of %8s snapshots\n",migliaia(i+1),migliaia2(snapshot_date.size()));
					reset();
					printf("Folder %s\n",snapshot_folder[i].c_str());
					printf("To     %s\n",snapshot_to[i].c_str());
					files.push_back(snapshot_folder[i]);
					date=snapshot_date[i];
					tofiles.push_back(snapshot_to[i]);
					command='a'; /// hidden parameter in read_archive with reflex on issel
					if (add()!=0)
						allok=false;
				}
				if (!allok)
					return 2;
			}
	}
	return 0;
}
/// find and delete 0-length dirs
/// in a slow (but hopefully) safe way
/// to be merged with Jidac::removeemptydirs(string i_folder,bool i_kill)

int Jidac::zero()
{
	printf("*** Delete empty folders (zero length) *** ");
	if (!flagforcezfs)
		printf("* ignoring .zfs and :$DATA ");
	printf("\n");

	if (files.size()==0)
	{
		printf("40127: no folder selected\n");
		return 1;
	}

	flagverbose=true;
	int risultato=0;
	for (unsigned i=0; i<files.size(); ++i)
		risultato+=removeemptydirs(files[i],flagkill);

	return risultato;
}	


/// robocopy /mir a master folder to one or more

int Jidac::robocopy()
{
	int risultato=0;
	
	printf("*** ROBOCOPY MODE *** ");
	if (!flagkill)
		printf("*** -kill missing: dry run *** ");
	if (!flagforcezfs)
		printf("*** ignoring .zfs and :$DATA ***");
	printf("\n");
	
	if (files.size()<2)
	{
		printf("40188: at least two folders needed\n");
		return 1;
	}
	
	if (!direxists(files[0]))
	{
		printf("27420: Master dir does not exists\n");
		return 1;
	}
	
	/// slow, but the cardinality is so small
	vector<string> checkdupe;
	
	for (unsigned int i=0;i<files.size();i++)
	{
		if (!isdirectory(files[i]))
				files[i]=files[i]+'/';
		string	outputfolder=files[i];
		
#ifdef _WIN32
	outputfolder=stringtolower(outputfolder);
#endif
		checkdupe.push_back(outputfolder);
	}
	
	if (flagdebug)
	{
		printf("Size checkdup %s\n",migliaia(checkdupe.size()));
		for (unsigned int i=0;i<files.size();i++)
			printf("40228: %03d files[i] %s  checkdupe [i] |%s|\n",i,files[i].c_str(),checkdupe[i].c_str());
	}

	for (unsigned int i=1;i<files.size();i++)
		if (checkdupe[0]==checkdupe[i])
		{
			printf("40222: a slave dir is == to the master, quit\n");
			return 1;
		}
#ifdef _WIN32
	if (flaglongpath)
		for (unsigned int i=0;i<files.size();i++)
			files[i]=makelongpath(files[i]);

	if (flagdebug)
		for (unsigned int i=0;i<files.size();i++)
			printf("40245: after %03d files[i] %s\n",i,files[i].c_str());

#endif

	franzparallelscandir(false,true,true);


///27437: space needed
	
	if (!flagspace)
		if (files_size[0]>0)
		{
			bool	spazioinsufficiente=false;
			for (unsigned int i=1;i<files.size();i++)
			{
				int64_t spaziolibero=getfreespace(files[i]);
				if (spaziolibero>=0)
				{
					if (files_size[0]>spaziolibero)
					{
						printf("27437: space needed %s but only %s reported free on <<%s>>\n",tohuman(files_size[0]),tohuman2(spaziolibero),files[i].c_str());
						spazioinsufficiente=true;
					}
				}
			}
		
			if (spazioinsufficiente)
			{
				printf("27441: exit, not enough space; use -space if you want\n");
				return 1;
			}
		}

	///exit(0);

	int64_t 	startscan=mtime();
	uint64_t 	strangethings;
	
	printf("\nMaster  %s (%s files %s) <<%s>>\n",migliaia(files_size[0]),tohuman(files_size[0]),migliaia2(files_count[0]),files[0].c_str());
	printbar('-');
		
	int64_t total_size				=files_size[0];
	int64_t total_count				=files_count[0];
	int64_t done_size				=0;
	int64_t done_count				=0;
	int64_t written_size			=0;
	int robocopied					=0;
	uint64_t robocopiedsize			=0;
	int robodeleted					=0;
	uint64_t robodeletedsize		=0;
	int roboequal					=0;
	uint64_t roboequalsize			=0;
	int64_t timecopy				=0;
	int64_t timedelete				=0;

	int xlscopied					=0;
	uint64_t xlscopiedsize			=0;
	
	g_robocopy_check_sorgente		=0;
	g_robocopy_check_destinazione	=0;

///	we start by 1 (the first slave); 0 is the master
	for (unsigned i=1; i<files.size(); ++i)
	{
		strangethings=0;
		if (flagkill)
			if (!exists(files[i]))
				makepath(files[i]);

		if (!exists(files[i]))
		{
			if (!flagkill)
			{
				printf("Dir %d (slavez) DOES NOT EXISTS %s\n",i,files[i].c_str());
				risultato=1;
			}
		}
		else
		{
		///	first stage: delete everything in slave-i that is NOT i master-0
			int64_t startdelete=mtime();
			for (DTMap::iterator p=files_edt[i].begin(); p!=files_edt[i].end(); ++p) 
			{
				string filenamei=p->first;
				string filename0=filenamei;
				myreplace(filename0,files[i],files[0]);
				DTMap::iterator cerca=files_edt[0].find(filename0);
				if  (cerca==files_edt[0].end())
				{
					if (flagdebug)
						printf("Delete %s\n",p->first.c_str());
					if (!flagkill)
					{
							//fake: dry run
						robodeleted++;
						robodeletedsize+=p->second.size;
					}
					else
					{
						string temp=p->first;
					
					///	printf("AAAAAAAAAAAAAAAAAAAAA %s\n",temp.c_str());
						bool riuscito=true;
						if (isdirectory(temp))
						{
							stermina(temp); // risky!!
							riuscito=delete_dir(temp.c_str())==0;
						}
						else
						{ 
						/// delete without mercy!
							/*riuscito*/delete_file(temp.c_str());
						}
						if (!riuscito)
							printf("31293: ERROR DELETING  <%s>\n",p->first.c_str());
						else
						{
							robodeleted++;
							robodeletedsize+=p->second.size;
						}
					}
				}
				if (menoenne>0)
					if (strangethings>menoenne)
					{
						printf("30146: **** TOO MANY STRANGE THINGS (-n %d)  %s\n",menoenne,migliaia(strangethings));
						break;
					}
			}	
			/// OK now do the copy from master-0 to slave-i
			timedelete=mtime()-startdelete;
			int64_t globalstartcopy=mtime();
			
			for (DTMap::iterator p=files_edt[0].begin(); p!=files_edt[0].end(); ++p) 
			{
				string filename0=p->first;
				string filenamei=filename0;
				myreplace(filenamei,files[0],files[i]);
				DTMap::iterator cerca=files_edt[i].find(filenamei);
					
				int64_t dest_size=-1;
				int64_t dest_date=-1;
				int64_t dest_attr=-1;
				if  (cerca==files_edt[i].end())
				{
					/// the file does not exists, maintain default -1 (=>secure_copy_file do yourself)
					///printf("NON ! %s\n",filenamei.c_str());
				}
				else
				{
				/// the destination exists, get data from the scanned-data
					
					dest_size=cerca->second.size;
					dest_date=cerca->second.date;
					dest_attr=cerca->second.attr;
				
				}

					int64_t startcopy=mtime();
					string copyfileresult=secure_copy_file(
					filename0,filenamei,globalstartcopy,total_size*(files.size()-1),total_count*(files.size()-1),written_size,done_size,done_count,
					p->second.size,
					p->second.date,
					p->second.attr,
					dest_size,
					dest_date,
					dest_attr);
					/// the return code can be OK (file copied) or = (file not copied because it is ==)
					if ((copyfileresult!="OK") && (copyfileresult!="="))
					{
						printf("31170: error robocoping data  <%s> to %s\n",copyfileresult.c_str(),filenamei.c_str());
						risultato=2;
					}
					else
					{
						if (!isdirectory(filename0))
						{
							if (copyfileresult=="OK")
							{
								robocopiedsize+=p->second.size;
								robocopied++;

								if (!flagdonotforcexls)
									if (isxls(filename0))
									{
										xlscopiedsize+=p->second.size;
										xlscopied++;
									}

								timecopy+=mtime()-startcopy;
							}
							else
							{
								roboequalsize+=p->second.size;
								roboequal++;
							}
						}
					}
								
				if (menoenne>0)
					if (strangethings>menoenne)
					{
						printf("30125: **** TOO MANY STRANGE THINGS (-n %d)  %s\n",menoenne,migliaia(strangethings));
						break;
					}
			}
		}
	}	

	timecopy++; //avoid some div by zero
	timedelete++;
	printf("\n");
	if (!flagkill)
		printf("FAKE: dry run!\n");
	printf("=   %12s %20s B\n",migliaia(roboequal),migliaia2(roboequalsize));
	printf("+   %12s %20s B in %9.2fs %15s/sec\n",migliaia(robocopied),migliaia2(robocopiedsize),(timecopy/1000.0),migliaia3((uint64_t)(robocopiedsize/(timecopy/1000.0))));
	if (xlscopied>0)
	printf("xls %12s %20s B\n",migliaia(xlscopied),migliaia2(xlscopiedsize));
	
	printf("-   %12s %20s B in %9.2fs %15s/sec\n",migliaia(robodeleted),migliaia2(robodeletedsize),(timedelete/1000.0),migliaia3((uint64_t)(robodeletedsize/(timedelete/1000.0))));

	printf("\nRobocopy time  %9.2f s\n",((mtime()-startscan)/1000.0));
	printf("Slaves getinfo %9.2f s\n",g_robocopy_check_destinazione/1000.0);
	printf("Written bytes %s (%s)\n",migliaia(written_size),tohuman(written_size));
		
		
	if (not flagverify)
		return risultato;
		
	printf("*** ROBOCOPY: do a (-verify) ");
	if (!flagforcezfs)
		printf(" ignoring .zfs and :$DATA");
	printf("\n");
	return dircompare(false,true);
}

/// do a s (get size) or c (compare). The second flag is for output when called by robocopy
int Jidac::dircompare(bool i_flagonlysize,bool i_flagrobocopy)
{
/// If you specify a checksum, do hard compare
	
	bool hashscelto=ischecksum();
	
	if (flagchecksum)
		if (!hashscelto)
			flagxxh3=true;
			
	int risultato=0;
	
	if (i_flagonlysize)
		printf("Get directory size ");
	else
	{
		if (!i_flagrobocopy)
			printf("Dir compare (%s dirs to be checked) ",migliaia(files.size()));
		if (files.size()<2)
			error("28212: At least two directories required\n");
	}
	
	if (!flagforcezfs)
			printf(" ignoring .zfs and :$DATA\n");

	franzparallelscandir(flagchecksum,true,true);
	
	printbar('=');
	for (unsigned i=0; i<files.size(); ++i)
	{
		int64_t spazio=getfreespace(files[i]);
	
		if (spazio<0)
			spazio=0;
		printf("Free %d %21s (%12s)  <<%s>>\n",i,migliaia(spazio),tohuman(spazio),files[i].c_str());
		
		
		if (minsize)
			if (minsize>(uint64_t)spazio)
			{
				printf("***************************************\n");
				printf("|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|\n");
				printf("WARN: free space < of minsize   %19s  %19s\n",migliaia(spazio),migliaia2(minsize));
				printf("|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|\n");
				printf("***************************************\n");
				
				
			}
	}

	uint64_t total_size	=0;
	///uint64_t total_files=0;
	int64_t delta_size	=0;
	int64_t delta_files	=0;
	
	printbar('=');
	for (unsigned int i=0;i<files_size.size();i++)
	{
		if (i==0)
			printf("Dir  %d %21s |%12s| |%12s| %9.2f <<%s>>\n",i,migliaia(files_size[i]),"Delta bytes",									 migliaia3(files_count[i]),files_time[i]/1000.0,files[i].c_str());
		else
		{
			printf("Dir  %d %21s |%12s| |%12s| %9.2f <<%s>>\n",i,migliaia(files_size[i]),tohuman(myabs(files_size[0],files_size[i])),migliaia3(files_count[i]),files_time[i]/1000.0,files[i].c_str());
			delta_size	+= myabs(files_size[0],files_size[i]);
			delta_files	+= myabs(files_count[0],files_count[i]);
		}
		total_size	+=files_size[i];
///		total_files	+=files_count[i];
	}
	printbar('=');
	printf("Total  |%21s| (%s)\n",migliaia(total_size),tohuman(total_size));
	printf("Delta  |%21s| %21s|files\n",migliaia(delta_size),migliaia2(delta_files));
	
/// only a s (size)? Done	
	if (i_flagonlysize)
		return 0;
	
	uint64_t strangethings;
	printf("\nDir 0 (master) %s (files %s) <<%s>>\n",migliaia(files_size[0]),migliaia2(files_count[0]),files[0].c_str());
	printbar('-');
	
	bool flagerror=false;

/// check from 1 (the first slave)
	for (unsigned i=1; i<files.size(); ++i)
	{
		strangethings=0;
		if (!exists(files[i]))
		{
			printf("[%03d] ERROR DOES NOT EXISTS <<",i);
			printUTF8(files[i].c_str());
			printf(">>\n");
			flagerror=true;
			risultato=1;
		}
		else
		{
			if ((files_size[i]!=files_size[0]) || (files_count[i]!=files_count[0]))
			{
				printf("Dir %d (slave) IS DIFFERENT time %6g <<%s>>\n",i,files_time[i]/1000.0,files[i].c_str());
				printf("size  %24s (files %s)\n",migliaia(files_size[i]),migliaia2(files_count[i]));
			}
				
			for (DTMap::iterator p=files_edt[0].begin(); p!=files_edt[0].end(); ++p) 
			{
				string filename0=p->first;
				string filenamei=filename0;
				myreplace(filenamei,files[0],files[i]);
				DTMap::iterator cerca=files_edt[i].find(filenamei);
				if  (cerca==files_edt[i].end())
				{
					printf("missing (not in %d) ",i);
					printUTF8(filename0.c_str());
					printf("\n");
					flagerror=true;
					strangethings++;
				}
				if (menoenne>0)
					if (strangethings>menoenne)
					{
						printf("30125: **** TOO MANY STRANGE THINGS (-n %d)  %s\n",menoenne,migliaia(strangethings));
						break;
					}
			}
			for (DTMap::iterator p=files_edt[i].begin(); p!=files_edt[i].end(); ++p) 
			{
				string filenamei=p->first;
				string filename0=filenamei;
				myreplace(filename0,files[i],files[0]);
				DTMap::iterator cerca=files_edt[0].find(filename0);
				if  (cerca==files_edt[0].end())
				{
					printf("excess  (not in 0) ");
					printUTF8(filename0.c_str());
					printf("\n");
					flagerror=true;
					strangethings++;
				}
				if (menoenne>0)
					if (strangethings>menoenne)
					{
						printf("30146: **** TOO MANY STRANGE THINGS (-n %d)  %s\n",menoenne,migliaia(strangethings));
						break;
					}
			}	
			for (DTMap::iterator p=files_edt[0].begin(); p!=files_edt[0].end(); ++p) 
			{
				string filename0=p->first;
				string filenamei=filename0;
				myreplace(filenamei,files[0],files[i]);
				DTMap::iterator cerca=files_edt[i].find(filenamei);
				if  (cerca!=files_edt[i].end())
				{
					if (p->second.size!=cerca->second.size)
					{
						printf("diff size  %18s (0) %18s (%d) %s\n",migliaia(p->second.size),migliaia2(cerca->second.size),i,filename0.c_str());
						flagerror=true;
						strangethings++;
					}
					else
					if (flagchecksum)
					{
						if (p->second.hexhash!=cerca->second.hexhash)
						{
							printf("%s different %s (0) vs %s (%d) ",mygetalgo().c_str(),p->second.hexhash.c_str(),cerca->second.hexhash.c_str(),i);
							printUTF8(filename0.c_str());
							printf("\n");
							flagerror=true;
							strangethings++;
						}
					}
				}
				if (menoenne>0)
					if (strangethings>menoenne)
					{
						printf("30146: **** TOO MANY STRANGE THINGS (-n %d)  %s\n",menoenne,migliaia(strangethings));
						break;
					}
			}
			if (!flagerror)
				if ((files_size[i]==files_size[0]) && (files_count[i]==files_count[0]))
				{
					printf("[%03d] == <<",i);
					printUTF8(files[i].c_str());	
					printf(">>\n");
				}
			printbar('-');
		}
	}	
	if (!flagerror)
	{
		if (flagchecksum)
			printf("NO diff FOR SURE in slave dirs (checksum check %s)\n",mygetalgo().c_str());
		else
			printf("NO diff in slave dirs (fast check, only size)\n");
	}
	else
	{
		printf("DIFFERENT SLAVE DIRS!!\n");
		risultato=2;
	}
	return risultato;
}



/// scans one or more directories, with one or more threads
/// return total time
int64_t Jidac::franzparallelscandir(bool i_flaghash,bool i_recursive,bool i_forcedir)
{

	if (flagverbose)
		flagnoeta=true;

	files_edt.clear();
	files_size.clear();
	files_count.clear();
	files_time.clear();
	g_arraybytescanned.clear();
	g_arrayfilescanned.clear();

	if (files.size()==0)
	{
		if (flagdebug)
			printf("28403: files.size zero\n");
		return 0;
	}
	if (i_forcedir)
		for (unsigned i=0; i<files.size(); ++i)
			if (!isdirectory(files[i]))
				files[i]+='/';

	int64_t startscan=mtime();
	
	int quantifiles			=0;
	g_bytescanned			=0;
	g_worked				=0;
			
	if (flagssd)	// OK let's make different threads
	{
		vector<tparametri> 	vettoreparametri;
		vector<DTMap>		vettoreDT;
		
		tparametri 	myblock;
		DTMap		mydtmap;
	
		for (unsigned int i=0;i<files.size();i++)
		{
			vettoreDT.push_back(mydtmap);
			myblock.tnumber=i;
			myblock.directorytobescanned=files[i];
			myblock.recursive=i_recursive;
			myblock.theDT=vettoreDT[i];
			myblock.flagcalchash=i_flaghash;//flagverify;
			myblock.timestart=mtime();
			myblock.timeend=myblock.timestart;
			vettoreparametri.push_back(myblock);
		}
	
		int rc;
		pthread_t* threads = new pthread_t[files.size()];
		pthread_attr_t attr;
		void *status;

		// ini and set thread joinable
		pthread_attr_init(&attr);
		pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_JOINABLE);

		printf("Creating %s scan threads\n",migliaia(files.size()));
			
		if (!flagnoeta)
		{
			setupConsole();
			printf("\033[?25l");	
			fflush(stdout);
			restoreConsole();
		}
		for(unsigned int i = 0; i < files.size(); i++ ) 
		{
			print_datetime();
			printf("Scan dir |%02d| <<%s>>\n",i,files[i].c_str());
		}
		for(unsigned int i = 0; i < files.size(); i++ ) 
		{
			g_arraybytescanned.push_back(0);
			g_arrayfilescanned.push_back(0);
			
			rc = pthread_create(&threads[i], &attr, scansiona, (void*)&vettoreparametri[i]);
			if (rc) 
			{
				printf("Error creating thread\n");
				exit(-1);
			}
		}
		printf("\n");

		// free attribute and wait for the other threads
		pthread_attr_destroy(&attr);
		for(unsigned int i = 0; i < files.size(); i++ ) 
		{
			rc = pthread_join(threads[i], &status);
			if (rc) 
			{
				error("Unable to join\n");
				exit(-1);
			}
			///printf("Thread completed %d status %d\n",i,status);
		}
		if (!flagnoeta)
		{
			setupConsole();
			printf("\033[%dB",(int)g_arraybytescanned.size());
			printf("\033[?25h");
			fflush(stdout);
			restoreConsole();
		}
		printf("\nParallel scan ended in %f s\n",(mtime()-startscan)/1000.0);
	
		for (unsigned i=0; i<files.size(); ++i)
		{
			uint64_t sizeofdir=0;
			uint64_t dircount=0;
			for (DTMap::iterator p=vettoreparametri[i].theDT.begin(); p!=vettoreparametri[i].theDT.end(); ++p) 
			{
				string filename=rename(p->first);
				if (p->second.date && p->first!="" && (!isdirectory(p->first)) && (!isads(filename))) 
				{
					sizeofdir+=p->second.size;
					dircount++;
					quantifiles++;
				}
				if (flagdebug)
				{
					printUTF8(filename.c_str());
					printf("\n");
				}
			}
			files_edt.push_back(vettoreparametri[i].theDT);
			files_size.push_back(sizeofdir);
			files_count.push_back(dircount);
			files_time.push_back(vettoreparametri[i].timeend-vettoreparametri[i].timestart+1);
		}
		delete[] threads;
	
	}
	else
	{	// single thread. Do a sequential scan

		g_arraybytescanned.push_back(0);
		g_arrayfilescanned.push_back(0);
	
		for (unsigned i=0; i<files.size(); ++i)
		{
			DTMap myblock;
			print_datetime();
			printf("Scan dir <<%s>>\n",files[i].c_str());
			uint64_t blockstart=mtime();
			myscandir(0,myblock,files[i].c_str(),i_recursive,i_flaghash);
			
			uint64_t sizeofdir=0;
			uint64_t dircount=0;
		
			for (DTMap::iterator p=myblock.begin(); p!=myblock.end(); ++p) 
			{
				string filename=rename(p->first);
				if (p->second.date && p->first!="" && (!isdirectory(p->first)) && (!isads(filename))) 
				{
					sizeofdir+=p->second.size;
					dircount++;
					quantifiles++;
				}
				if (flagdebug)
				{
					printUTF8(filename.c_str());
					printf("\n");
				}
			}
			files_edt.push_back(myblock);
			files_size.push_back(sizeofdir);
			files_count.push_back(dircount);
			files_time.push_back(mtime()-blockstart);
		}
	}
	return mtime()-startscan;
}	


/// wipe free space-check if can write and read OK
int Jidac::fillami() 
{

#ifdef ESX
	printf("GURU: sorry: ESXi does not like this things\n");
	exit(0);
#endif
	if (files.size()!=1)
	{
		printf("FILL: exactly one directory\n");
		return 2;
	}
	if (!isdirectory(files[0]))
	{
		printf("FILL: you need to specify a directory, not a file (last bar)\n");
		return 2;
	}
	moreprint("");
	if (flagzero)
	moreprint("Almost all free space will be filled by zeroed 512MB files.");
	else
	moreprint("Almost all free space will be filled by pseudorandom 512MB files,");
	if (!flagzero)
	moreprint("then checked from the ztempdir-created folder (2GB+ needed).");
	moreprint("");
	moreprint("These activities can reduce the media life,");
	moreprint("especially for solid state drives (SSDs) and if repeated several times.");
	moreprint("");
	if (flagforce)
	{
		moreprint("*** Temporary files are NOT deleted (no -force, to enforce zfs's scrub) ***");
		moreprint("");
	}
	
	if (!getcaptcha("ok","Fill (wipe) free space"))
				return 1;
	
	string outputdir=files[0]+"ztempdir/";
	makepath(outputdir);
	if (!direxists(outputdir))
	{
		printf("\n28599: impossible to makepath %s\n",outputdir.c_str());
		return 2;
	}
	unsigned int percent=99;
		
	int64_t spazio=getfreespace(outputdir);
	printf("Free space %12s (%s) <<%s>>\n",migliaia(spazio),tohuman(spazio),outputdir.c_str());
	if (!flagzero)
		if (spazio<600000000)
		{
			printf("28607: less than 600.000.000 bytes free on %s\n",outputdir.c_str());
			return 2;
		}
	
	uint64_t spacetowrite=spazio*percent/100;
	printf("To write   %12s (%s) %d percent\n",migliaia(spacetowrite),tohuman(spacetowrite),percent);

	uint32_t chunksize=(2<<28)/sizeof(uint32_t); //half gigabyte in 32 bits at time
	
	int chunks=spacetowrite/(chunksize*sizeof(uint32_t));
	
		
	chunks--; // just to be sure

	
	if (chunks<=0)
	{
		if (flagzero)
			chunks=1;
		else
		{
			printf("Abort: there is something strange on free space (2GB+)\n");
			return 1;
		}
	}
	printf("%d chunks of (%s) will be written\n",chunks,tohuman(chunksize*sizeof(uint32_t)));
		
	uint32_t *buffer32bit = (uint32_t*)malloc(chunksize*sizeof(uint32_t));
	if (buffer32bit==0)
	{
		printf("28628: GURU cannot alloc the buffer\n");
		return 2;
	}
	uint64_t starttutto=mtime();	
	uint64_t hashtime=0;
	uint64_t totaliotime=0;
	uint64_t totalhashtime=0;
	uint64_t totalrandtime=0;
		
	vector<string> chunkfilename;     
	vector<string> chunkhash;     
	
	assert(outputdir.size()<200);
	char mynomefile[200+100];
	
	memset(buffer32bit,0,chunksize*4);

	for (int i=0;i<chunks;i++)
	{
		/// pseudorandom population (not cryptographic-level, but enough)
		uint64_t startrandom=mtime();
		if (!flagzero)
			populateRandom_xorshift128plus(buffer32bit, chunksize,324+i,4444+i);
		uint64_t randtime=mtime()-startrandom;
		
		/// get XXH3, fast and reliable (not cryptographic-level, but enough)
		uint64_t starthash=mtime();
		XXH3_state_t state128;
		(void)XXH3_128bits_reset(&state128);
		(void)XXH3_128bits_update(&state128, buffer32bit, chunksize*4);
		XXH128_hash_t myhash=XXH3_128bits_digest(&state128);
		char risultato[33];
		sprintf(risultato,"%016llX%016llX",(unsigned long long)myhash.high64,(unsigned long long)myhash.low64);
		chunkhash.push_back(risultato);
		hashtime=mtime()-starthash;
		
		sprintf(mynomefile,"%szchunk_%05d_$%s",outputdir.c_str(),i,risultato);
		chunkfilename.push_back(mynomefile);
		double percentuale=(double)i/(double)chunks*100.0;
		if (i==0)
			percentuale=0;
			
		printf("%03d%% ",(int)percentuale);
		
		uint64_t startio=mtime();
		FILE* myfile=fopen(mynomefile, "wb");
		fwrite(buffer32bit, sizeof(uint32_t), chunksize, myfile);
		fclose(myfile);			
		uint64_t iotime=mtime()-startio;
		
		
		uint64_t randspeed=(uint64_t)	(chunksize*sizeof(uint32_t)/((randtime+1)/1000.0));
		uint64_t hashspeed=(uint64_t)	(chunksize*sizeof(uint32_t)/((hashtime+1)/1000.0));
		uint64_t iospeed=(uint64_t)	(chunksize*sizeof(uint32_t)/((iotime+1)/1000.0));
		
		double trascorso=(mtime()-starttutto+1)/1000.0;
		double eta=((double)trascorso*(double)chunks/(double)i)-trascorso;
		if (i==0)
			eta=0;

		if (eta<356000)
		{
			printf("ETA %0d:%02d:%02d",int(eta/3600), int(eta/60)%60, int(eta)%60);
			printf(" todo (%10s) rnd (%10s/s) hash (%10s/s) W (%10s/s)",
			tohuman(sizeof(uint32_t)*uint64_t(chunksize)*(uint64_t)(chunks-i)),
			tohuman2(randspeed),
			tohuman3(hashspeed),
			tohuman4(iospeed));
			if (flagverbose)
				printf("\n");
			else
				printf("\r");
		}
		totaliotime		+=iotime;
		totalrandtime	+=randtime;
		totalhashtime	+=hashtime;
		
	}
	uint64_t timetutto=mtime()-starttutto;
	printf("Total time %f  rnd %f  hash %f  write %f\n",timetutto/1000.0,totalrandtime/1000.0,totalhashtime/1000.0,totaliotime/1000.0);
	free(buffer32bit);
	
	if (chunkfilename.size()!=chunkhash.size())
	{
		printf("Guru 23925: filename size != hash size\n");
		return 2;
	}
	if (chunkfilename.size()!=(unsigned int)chunks)
	{
		printf("Abort: expecting %d chunks but %d founded\n",chunks,(unsigned int)chunkfilename.size());
		return 2;
	}
	
	/// by default zero to shrink vmdks
	bool flagallok=true;
	
	bool doverify=true;
	
	if (flagzero)
		if (!flagverify)
			doverify=false;
	
	if (doverify)
	{
		printf("******* VERIFY\n");
		
		g_bytescanned=0;
		g_filescanned=0;
		g_worked=0;
		edt.clear();
		int64_t lavorati=0;
		
		uint64_t startverify=mtime();
		
		for (int unsigned i=0;i<chunkfilename.size();i++)
		{
			string filename=chunkfilename[i];
			printf("Reading chunk %05d ",i);
			
			uint32_t dummycrc32;
			///uint64_t starthash=mtime();
			string filehash=xxhash_calc_file(filename.c_str(),false,dummycrc32,-1,-1,lavorati);
			uint64_t hashspeed=(uint64_t)(lavorati/((mtime()-startverify+1)/1000.0));
			printf(" (%12s/s) ",tohuman(hashspeed));

			bool flagerrore=(filehash!=chunkhash[i]);
				
			if (flagerrore)
			{
				printf("ERROR\n");
				flagallok=false;
			}
			else
			{
				printf("OK %s",chunkhash[i].c_str());
				if (flagverbose)
					printf("\n");
				else
					printf("\r");
			}
		}

		printf("\n");
		uint64_t verifytime=mtime()-startverify;
		printf("Verify time %f (%10s) speed (%10s/s)\n",verifytime/1000.0,tohuman(lavorati),tohuman2((uint64_t)(lavorati/(verifytime/1000.0))));
	}
	
	if (flagallok)
	{
		printf("+OK all OK\n");
		if (!flagforce)
		{
			for (int unsigned i=0;i<chunkfilename.size();i++)
			{
				delete_file(chunkfilename[i].c_str());
				printf("Deleting tempfile %05d / %05d\r",i,(unsigned int)chunkfilename.size()-1);
			}
			delete_dir(outputdir.c_str());
			printf("\n");
		}
		else
		{
			printf("REMEMBER: temp file in %s\n",outputdir.c_str());
		}
	}	
	else
		printf("ERROR: SOMETHING WRONG\n");
	return 0;

	
}

/*
	On FreeBSD (and zfs) home is very often a symlink, but the readlink() sometimes
	report relative links (/home => usr/home)
*/
#ifdef unix
string my_realpath(std::string const& i_path) 
{
	char buf[33000]; //No PATH_MAX]; on Solaris
    char *res=realpath(i_path.c_str(),buf);
    if (res) 
	{ 
		return buf;
    } 
	else 
	{
		if (flagdebug)
			printf("38761: error on realpath of %s\n",i_path.c_str());
		return i_path;
    }
}
#endif


int  Jidac::dir() 
{
	bool barras	=false;
	bool barraos=false;
	bool barraod=false;
	bool barraa	=false;
	
/*esx*/
#ifndef ESX
	if (files.size()==0)
	{
		if (flagdebug)
			printf("38759: push .\n");
		files.push_back(".");
	}
#endif
	string cartella=files[0];

	if ((cartella=="/s") || (cartella=="/os") || (cartella=="/od") || (cartella=="/a"))
	{
		files.push_back(cartella);
		files[0]="./";
		cartella=files[0];
	}
	///if	(!isdirectory(cartella))
		///cartella+='/';
	if (cartella==".")
			cartella+='/';
#ifdef unix
	if (flagdebug)
		printf("38802: folder before %s\n",cartella.c_str());
	string nuovacartella=my_realpath(cartella);
	if (flagdebug)
		printf("38805: folder after %s\n",nuovacartella.c_str());
	
	if	(!isdirectory(nuovacartella))
		nuovacartella+='/';
	if (cartella!=nuovacartella)
	{
		printf("38798: WARNING path : <<");
		printUTF8(cartella.c_str());
		printf(">>\nresolved to         : <<");
		printUTF8(nuovacartella.c_str());
		printf(">>\n");
	}
	cartella=nuovacartella;
	files[0]=cartella;
#endif
	
	if (!isdirectory(cartella))
		if (!realfileexists(cartella))
			if (direxists(cartella))
				cartella+='/';

	if (files.size()>1)
		for (unsigned i=0; i<files.size(); i++) 
		{
				barras	|=(stringcomparei(files[i],"/s"));
				barraos	|=(stringcomparei(files[i],"/os"));
				barraod	|=(stringcomparei(files[i],"/od"));
				barraa	|=(stringcomparei(files[i],"/a"));
		}
	
	
	printf("==== Scanning dir <<");
	printUTF8(cartella.c_str());
	printf(">> ");
		
	if (barras)
		printf(" /s");
	if (barraos)
		printf(" /os");
	if (barraod)
		printf(" /od");
	if (barraa)
		printf(" /a");
			
	printf("\n");
		
	bool		flagduplicati	=false;
	int64_t 	total_size		=0;
	int 		quantifiles		=0;
	int 		quantedirectory	=0;
	int64_t		dummylavorati	=0;
	int			quantihash		=0;
	int64_t		hash_calcolati	=0;
	uint64_t	iniziohash		=0;
	uint64_t	finehash			=0;
		
	flagduplicati=ischecksum(); //(flagcrc32 || flagcrc32c || flagxxh3 || flagxxhash64 || flagsha1 || flagsha256 || flagmd5 || flagblake3 || flagxxhash64 || flagsha3);
	if (flagchecksum)
			flagduplicati=false;
		
	g_bytescanned=0;
	g_filescanned=0;
	g_worked=0;
	scandir(true,edt,cartella,barras);
	printbar(' ',false);
	printf("\r");

	vector <s_fileandsize> fileandsize;
	
	for (DTMap::iterator p=edt.begin(); p!=edt.end(); ++p) 
	{
		bool flagaggiungi=true;

#ifdef _WIN32	
		if (!barraa)
			flagaggiungi=((int)attrToString(p->second.attr).find("H") < 0);
		flagaggiungi &= (!isads(p->first));
#endif
		
		if (searchfrom!="")
			flagaggiungi &= (stristr(p->first.c_str(),searchfrom.c_str())!=0);
	
		if (flagaggiungi)
		{
			s_fileandsize myblock;
			myblock.filename=p->first;
			myblock.size=p->second.size;
			myblock.attr=p->second.attr;
			myblock.date=p->second.date;
			myblock.isdir=isdirectory(p->first);
			myblock.flaghashstored=false;
				
			if (flagduplicati)
			{
				if (!myblock.isdir)
				{
					if (minsize)
					{
						if (myblock.size>minsize)
							fileandsize.push_back(myblock);
					}
					else
					if (maxsize)
					{
						if (myblock.size<minsize)
							fileandsize.push_back(myblock);
					}
					else
						fileandsize.push_back(myblock);
					
				}
			}
			else
				fileandsize.push_back(myblock);
		}
	}
		
	if (flagduplicati)
	{
		if (flagdebug)
		{
			printf("Pre-sort\n");
			for (unsigned int i=0;i<fileandsize.size();i++)
				printf("PRE %08d  %s %s\n",i,migliaia(fileandsize[i].size),fileandsize[i].filename.c_str());
		}
	
		sort(fileandsize.begin(),fileandsize.end(),comparefilenamesize);
	
		if (flagdebug)
		{
			printf("Post-sort\n");
			for (unsigned int i=0;i<fileandsize.size();i++)
				printf("POST %08d  %s %s\n",i,migliaia(fileandsize[i].size),fileandsize[i].filename.c_str());
		}
	
		iniziohash=mtime();
	
		int64_t dalavorare=0;
		for (unsigned int i=0;i<fileandsize.size();i++)
			if (i<fileandsize.size()-1)
			{
				bool entrato=false;
				while (fileandsize[i].size==fileandsize[i+1].size)
				{
					if (!entrato)
					{
						dalavorare+=fileandsize[i].size;
						entrato=true;
					}
					
					dalavorare+=fileandsize[i+1].size;
					i++;
					if (i==fileandsize.size())
						break;
				}
			}
		
		printf("\nStart checksumming %s / %s bytes ...\n",migliaia(fileandsize.size()),migliaia2(dalavorare));
		int larghezzaconsole=terminalwidth()-2;
		if (larghezzaconsole<10)
			larghezzaconsole=80;

		int64_t ultimapercentuale=0;
		int64_t rapporto;
		int64_t percentuale;
		
		for (unsigned int i=0;i<fileandsize.size();i++)
		{
			if (i<fileandsize.size()-1)
			{
				bool entrato=false;
				while (fileandsize[i].size==fileandsize[i+1].size)
				{
					if (!entrato)
					{
						bool saveeta=flagnoeta;
						flagnoeta=true;
						uint32_t dummycrc;
						string temp=hash_calc_file(flag2algo(),fileandsize[i].filename.c_str(),false,dummycrc,0,0,dummylavorati);
						flagnoeta=saveeta;

						fileandsize[i].hashhex=temp;
						fileandsize[i].flaghashstored=true;
						quantihash++;
						hash_calcolati+=fileandsize[i].size;
						entrato=true;
						if (flagdebug)
							printf("%08d HASH %s %s %19s %s\n",i,fileandsize[i].hashhex.c_str(),dateToString(fileandsize[i].date).c_str(),migliaia(fileandsize[i].size),fileandsize[i].filename.c_str());
						else
						{
							rapporto=larghezzaconsole*hash_calcolati/(dalavorare+1);
							percentuale=100*hash_calcolati/(dalavorare+1);
							if (!flagnoeta)
							{
								printf("Done %03d ",(unsigned int)percentuale);
								if (percentuale>ultimapercentuale)
								{
									if (rapporto>10)
									{
										for (unsigned j=0;j<rapporto-10;j++)
											printf(".");
										ultimapercentuale=percentuale;
									}
								}
								printf("\r");
							}
						}
					
					}
					
					bool saveeta=flagnoeta;
					flagnoeta=true;
					uint32_t dummycrc;
					string temp=hash_calc_file(flag2algo(),fileandsize[i+1].filename.c_str(),false,dummycrc,0,0,dummylavorati);
					flagnoeta=saveeta;
					
					fileandsize[i+1].hashhex=temp;
					fileandsize[i+1].flaghashstored=true;
					quantihash++;
					hash_calcolati+=fileandsize[i+1].size;
					if (flagdebug)
						printf("%08d HASH-2 %s %s %19s %s\n",i+1,fileandsize[i+1].hashhex.c_str(),dateToString(fileandsize[i+1].date).c_str(),migliaia(fileandsize[i+1].size),fileandsize[i+1].filename.c_str());
					else
					{
						rapporto=larghezzaconsole*hash_calcolati/(dalavorare+1);
						percentuale=100*hash_calcolati/(dalavorare+1);
						if (!flagnoeta)
						{
							printf("Done %03d ",(unsigned int)percentuale);
							if (percentuale>ultimapercentuale)
								{
									if (rapporto>10)
									{
										for (unsigned j=0;j<rapporto-10;j++)
											printf(".");
										ultimapercentuale=percentuale;
									}
								}
								
							printf("\r");
						}
					}
					
					i++;
					if (i==fileandsize.size())
						break;
					
				}
				
			}
		}
		finehash=mtime();
		printf("\n");
		sort(fileandsize.begin(),fileandsize.end(),comparecrc32);
	
		if (flagdebug)
		{
			printf("Hash taken %08d %s\n",quantihash,migliaia(hash_calcolati));
			printf("Before shrink %s\n",migliaia(fileandsize.size()));
			printf("Time %f\n",(finehash-iniziohash)/1000.0);
	
			for (unsigned int i=0;i<fileandsize.size();i++)
				printf("before shrink %08d  %s %s\n",i,fileandsize[i].hashhex.c_str(),fileandsize[i].filename.c_str());
		}
	
		int limite=-1;
		for (unsigned int i=0;i<fileandsize.size(); i++)
		{
			if (flagdebug)
				printf("%d size %s <<%s>>\n",i,migliaia(fileandsize.size()),fileandsize[i].hashhex.c_str());
		
			if (!fileandsize[i].flaghashstored)
			{
				limite=i;
				break;
			}	
		}
	
		if (flagverbose)
		printf("Limit founded %d\n",limite);
		
		if (limite>-1)
			for (int i=fileandsize.size()-1;i>=limite;i--)
				fileandsize.pop_back();
	
	
		if (flagdebug)
		{
			printf("After shrink %s\n",migliaia(fileandsize.size()));

			for (unsigned int i=0;i<fileandsize.size();i++)
				printf("After shrinking %08d  %s %s\n",i,fileandsize[i].hashhex.c_str(),fileandsize[i].filename.c_str());
		}
	
		sort(fileandsize.begin(),fileandsize.end(),comparesizehash);
	
		if (flagdebug)
		{
			printf("After re-sort %s\n",migliaia(fileandsize.size()));

			for (unsigned int i=0;i<fileandsize.size();i++)
				printf("After re-sort %08d  %s %s\n",i,fileandsize[i].hashhex.c_str(),fileandsize[i].filename.c_str());
		}
	
	}
	else
	{

		if (barraod)
			sort(fileandsize.begin(),fileandsize.end(),comparefilenamedate);
	
		if (barraos)
			sort(fileandsize.begin(),fileandsize.end(),comparefilenamesize);
	}
	unsigned int inizio=0;
	if (menoenne)
		if (menoenne<fileandsize.size())
			inizio=fileandsize.size()-menoenne;
	
	
	int64_t tot_duplicati=0;
	
	
	for (unsigned int i=inizio;i<fileandsize.size();i++)
		if (fileandsize[i].isdir)
		{
			if (fileandsize[i].filename[0]=='.')
				if (fileandsize[i].filename[1]=='/')
					 fileandsize[i].filename=fileandsize[i].filename.substr(2,fileandsize[i].filename.size()-3);
		}
		else
		{
			if (fileandsize[i].filename[0]=='.')
				if (fileandsize[i].filename[1]=='/')
					fileandsize[i].filename=fileandsize[i].filename.substr(2,string::npos);
		}
		
		
	for (unsigned int i=inizio;i<fileandsize.size();i++)
		if (fileandsize[i].isdir)
		{
		
			printf("%s    <DIR>               ",dateToString(fileandsize[i].date,!flagutc).c_str());
			printUTF8(fileandsize[i].filename.c_str());
			printf("\n");
			quantedirectory++;
		}
		else
		{
			total_size+=fileandsize[i].size;
			quantifiles++;
			
			if (flagduplicati)
			{
				if (i<fileandsize.size()-1)
				{
					bool entrato=false;

					//if (memcmp(fileandsize[i].crc32hex,fileandsize[i+1].crc32hex,8)==0)
					if (fileandsize[i].hashhex==fileandsize[i+1].hashhex)
					{
						if (flagverbose)
							printf("%s ",fileandsize[i].hashhex.c_str());
						
						printf("%s %19s ",dateToString(fileandsize[i].date,!flagutc).c_str(),migliaia(fileandsize[i].size));
						printUTF8(fileandsize[i].filename.c_str());
						printf("\n");
						
						while (fileandsize[i].hashhex==fileandsize[i+1].hashhex)
						{
							if (flagverbose)
							printf("%s ",fileandsize[i].hashhex.c_str());

							
							printf("================= %19s ",migliaia(fileandsize[i+1].size));
							printUTF8(fileandsize[i+1].filename.c_str());
							printf("\n");
							tot_duplicati+=fileandsize[i].size;
							entrato=true;
							i++;
							if (i==fileandsize.size())
								break;
						}
					}
					if (entrato)
						printf("\n");
				}
				
			}
			else
			{
				printf("%s %22s ",dateToString(fileandsize[i].date,!flagutc).c_str(),migliaia(fileandsize[i].size));
				if (flagchecksum)
				{
					uint32_t dummycrc;
					string temp=hash_calc_file(flag2algo(),fileandsize[i].filename.c_str(),false,dummycrc,0,0,dummylavorati);
					printf("|| %s:%s ",mygetalgo().c_str(),temp.c_str());
				}
				printUTF8(fileandsize[i].filename.c_str());
				printf("\n");
			}
		}
	           
	printf("    %10s File %20s byte\n",migliaia(quantifiles),migliaia2(total_size));
	if (!flagduplicati)
	printf("    %10s dir ",migliaia(quantedirectory));
	else
	printf("                   ");
		
	if (!isdirectory(cartella))
	{
		string percorso=extractfilepath(cartella);
		if (percorso=="")
			cartella="./";
		else
			cartella=percorso;
			
		///printf("PERCO |%s|\n",percorso.c_str());
	}
	int64_t spazio=getfreespace(cartella);
	printf(" %20s bytes (%s) free",migliaia(spazio),tohuman(spazio));
	
	printf("\n");
	if (flagduplicati)
	{
		printf("\n          Duplicated %19s byte\n",migliaia(tot_duplicati));
		printf("Hashed %8s files %18s bytes in %f s %s /s\n",migliaia(quantihash),migliaia2(hash_calcolati),(finehash-iniziohash)/1000.0,migliaia2((uint64_t)(hash_calcolati/((finehash-iniziohash+1)/1000.0))));
	}
	return 0;
}


int Jidac::decimation()
{
	bool flagthelastone=false;
	
	if (g_exec!="")
		flagthelastone=true;
	
	if (flagthelastone)
		printf("*** Run the last ones *** ");
	else
		printf("*** Decimation *** ");
	
	printf("*** -kill missing: dry run *** ");
	if (!flagforcezfs)
		printf("*** ignoring .zfs and :$DATA ***");
	
	printf("\n\n");
	
	if (g_exec!="")
		if (!fileexists(g_exec))
		{
			printf("29066: -g_exec does not exists\n");
			return 2;
		}

	if (flagthelastone)
		if (menoenne<=0)
			menoenne=1;
			
	
	if (menoenne<=0)
	{
		printf("28960: -n or -limit not set\n");
		return 1;
	}

	flagbarraod=true; // by default, sort by date
	
	if (flagbarraon)
		flagbarraod=false; // if /on, sort by name
		
	if (files.size()>1)
	{
		printf("28966: only one dir can be elaborated\n");
		return 1;
	}

	if (mypos("*",files[0])==-1)
	{
		printf("29053: * pattern requested (ex. /tmp/dump_*.sql)\n");
		return 1;
	}
	franzparallelscandir(false,false,false);
	printf("\n");

	if (files_edt[0].size()==0)
	{
		printf("29048: empty result, nothing to do\n");
		return 0;
	}
	
	if (!flagthelastone)
		if (!flagforce)
			if (files_edt[0].size()>50)
			{
				printf("29024: founded lots of files (%s), no -force => quit (security measure)\n",migliaia(files_edt[0].size()));
				return 1;
			}
	
	vector<string> 		scannedfiles;
		
	if (flagbarraod)
	{
		printf("Order by DATE (/od or default)\n");
		vector<DTMap::iterator> filelist;

		for (DTMap::iterator a=files_edt[0].begin(); a!=files_edt[0].end(); ++a) 
			filelist.push_back(a);
		sort(filelist.begin(), filelist.end(), comparedatethenfilename);
		
		for (unsigned int i=0; i<filelist.size();i++)
			scannedfiles.push_back(filelist[i]->first);
	}
	else
	{
		printf("Order by NAME (/on)\n");
		for (DTMap::iterator p=files_edt[0].begin(); p!=files_edt[0].end(); ++p) 
			scannedfiles.push_back(p->first);
	}
	
	if (scannedfiles.size()<=menoenne)
	{
		if (flagthelastone)
			menoenne=scannedfiles.size();
		else
		{
			printf("28977: candidate %s less or equal to limit %s => do nothing\n",migliaia(menoenne),migliaia2(scannedfiles.size()));
			return 0;
		}
	}
	vector<string> tobedeleted;
	
	if (flagthelastone)
	{
		for (unsigned int i=1;i<=menoenne;i++)
			tobedeleted.push_back(scannedfiles[scannedfiles.size()-i]);
	}
	else
	{
		for (unsigned int i=0;i<scannedfiles.size()-menoenne;i++)
			tobedeleted.push_back(scannedfiles[i]);
		
		if (flagverbose)
			for (unsigned int i=scannedfiles.size()-menoenne;i<scannedfiles.size();i++)
				printf("KEEP   %s\n",scannedfiles[i].c_str());
	}
	printf("\n");
	
	printf("Candidate (to be elaborated) %12s\n",migliaia(tobedeleted.size()));
	if (tobedeleted.size()==0)
	{
		printf("28985: Nothing to do\n");
		return 0;
	}
	
	if (!flagkill)
		printf("28990: dry run (no -kill)\n");

	if (flagthelastone)
	{
		printf("Executing  %s times <<%s>>\n",migliaia(tobedeleted.size()),g_exec.c_str());
		for (unsigned int i=0;i<tobedeleted.size();i++)
		{
			#ifdef _WIN32	
				myreplaceall(tobedeleted[i],"/","\\");
			#endif
			printf("%08d with param <<%s>>\n",i+1,tobedeleted[i].c_str());
			if (flagkill)
				xcommand(g_exec,tobedeleted[i]);
		}
		return 0;
	}
	
	int deleted=0;
	int highlander=0;
	for (unsigned int i=0;i<tobedeleted.size();i++)
	{
		if (flagverbose)
		{
			printf("DELETE <<");
			printUTF8(tobedeleted[i].c_str());
			printf(">>\n");
		}
		if (flagkill)
		{
			if (delete_file(tobedeleted[i].c_str()))
				deleted++;
			else
				highlander++;
		}
	}
	
	if (deleted>0)
	printf("Deleted                      %12s\n",migliaia(deleted));
	if (highlander>0)
	printf("Highlander                   %12s\n",migliaia(highlander));
	
	if (highlander>0)
		return 2;
		
	return 0;
}	

// Add or delete files from archive. Return 1 if error else 0.
// Note: by flagverify do a CRC32-integrity check (@zpaqfranz)
///zpaqfranz a z:\1 \\?\UNC\franzk\z\cb -longpath -debug
int Jidac::add() 
{
	
	//if (tofiles.size()==1)
		///printf("KA------------------- to %s\n",tofiles[0].c_str());

	#ifdef _WIN32
	if (flaglongpath)
		if (tofiles.size()==0)
		{
			unsigned int	howmanyshort=0;
			for (unsigned int i=0;i<files.size();i++)
			{
		///		if (islonguncpath(files[i]))
			///			printf("LONG UNC %s\n",files[i].c_str());
				if ((!islongpath(files[i])) && (!islonguncpath(files[i])))
					howmanyshort++;
			}
			if (howmanyshort==files.size())
			{
				printf("38992: INFO: getting Windows' long filenames\n");
				if (flagdebug)
					for (unsigned int i=0;i<files.size();i++)
						printf("38994: %03d From %s\n",i,files[i].c_str());
				
				for (unsigned int i=0;i<files.size();i++)
				{
				/// very dirty trick to get the exact "caseness"
				/// because some Windows does not like to mix
				/// z:\NS, \\?\Z:\ns\ and z:\ns
				
					DTMap	myedt;
					scandir(false,myedt,files[i].c_str(),false);
					if (myedt.size()>0)
						files[i]=myedt.begin()->first;

					if (isalpha(files[i][0]))
					{					
						tofiles.push_back(files[i]);
						files[i]="//?/"+files[i];
					}
					else
					{
				/// with UNC, you are on your own
				/// (very limited support)
						tofiles.push_back(files[i]);
						files[i]="//?/UNC/"+tail(files[i],files[i].size()-2);
					}
					
				}
				if (flagdebug)
				{
					printbar('-');
					for (unsigned int i=0;i<tofiles.size();i++)
					{
						printf("39027: %03d From %s\n",i,files[i].c_str());
						printf("39028: %03d To   %s\n",i,tofiles[i].c_str());
					}
				}
			}
		}
	#endif
	
	///if (tofiles.size()==1)
		///printf("KB------------------- to %s\n",tofiles[0].c_str());

	getpasswordifempty();
	
	if (g_freeze!="")
	{
		if (maxsize>0)
		{
			if (fileexists(archive))
			{
				int64_t dimensionefile=prendidimensionefile(archive.c_str());
				if (dimensionefile>(int64_t)maxsize)
				{
					printf("Freezing archive size %s vs maxsize %s\n",migliaia(dimensionefile),migliaia2(maxsize));
					string filescritto=filecopy(false,false,archive,g_freeze,true,false,false);
					if (filescritto!="")
					{
						printf("Moved <<%s>> to <<%s>>\n",archive.c_str(),filescritto.c_str());
						printf("Deleting (by -freeze) <<%s>>\n",archive.c_str());
						delete_file(archive.c_str());
					}
					else
						printf("34971: ERROR doing -freeze from %s to %s\n",archive.c_str(),filescritto.c_str());
				}
			}
		}
		else
			error("-freeze without -maxsize");
	}
	if (flagvss)
	{
		if (flagtest)
			error("incompatible -vss and -test");
		if (flagnopath)
			error("incompatible -vss and -nopath");
	}
	
	g_scritti=0;
	string primalettera="";
	string cartellalocale="";
		
	if (flagvss)
	{

#if defined(_WIN32)
///	command q is hardcoded. Why? Because it is so much simplier
/// the generic switch -vss is just about abandoned
		if (command=='q')
		{			
			cartellalocale="c:\\franzsnap";
			if (!flagspace)
				if (direxists(cartellalocale))
				{
					printf("42236: abort because folder already exists %s\n",cartellalocale.c_str());
					printf("42236: you need to rename/delete or try -space to bypass\n");
					exit(0);
				}
		}
	
		char mydrive=0; // only ONE letter, only ONE VSS snapshot
		// abort for something like zpaqfranz a z:\1.zpaq c:\pippo d:\pluto -vss
		// abort for zpaqranz a z:\1.zpaq \\server\dati -vss
		// etc
		for (unsigned i=0; i<files.size(); ++i)
		{
			string temp=files[i];
			
			if (temp[1]!=':')
				error("VSS need X:something as path (missing :)");
				
			char currentdrive=toupper(temp[0]);
			if (!isalpha(currentdrive))
				error("VSS need X:something as path (X not isalpha)");
			
			if (mydrive)
			{
				if (mydrive!=currentdrive)
				error("VSS can only runs on ONE drive");
			}
			else
				mydrive=currentdrive;
		}

		string	fileoutput	=g_gettempdirectory()+"outputz.txt";
		string	filebatch	=g_gettempdirectory()+"vsz.bat";
		fileoutput			=nomefileseesistegia(fileoutput); // this will proliferate batch files, but they are tiny
		filebatch			=nomefileseesistegia(filebatch);
		print_datetime();
		printf("VSS: starting\n");
    
		if (fileexists(fileoutput))
			if (remove(fileoutput.c_str())!=0)
					error("Highlander outputz.txt");

		if (fileexists(filebatch))
			if (remove(filebatch.c_str())!=0)
				error("Highlander vsz.bat");
		
		FILE* batch=fopen(filebatch.c_str(), "wb");
		fprintf(batch,"@echo OFF\n");
		fprintf(batch,"@wmic shadowcopy delete /nointeractive\n");
		fprintf(batch,"@wmic shadowcopy call create Volume=%c:\\\n",mydrive);
		fprintf(batch,"@vssadmin list shadows >%s\n",fileoutput.c_str());
		fclose(batch);
		
		waitexecute(filebatch,"",SW_HIDE);

		if (!fileexists(fileoutput))
			error("VSS Output file KO");
	
		string globalroot="";
		char line[1024];

		FILE* myoutput=fopen(fileoutput.c_str(), "rb");
		
		/* note that fgets don't strip the terminating \n (or \r\n) but we do not like it  */
		
		while (fgets(line, sizeof(line), myoutput)) 
        	if (strstr(line,"GLOBALROOT"))
			{
				globalroot=line;
				myreplaceall(globalroot,"\n","");
				myreplaceall(globalroot,"\r","");
				break;
			}
		
		fclose(myoutput);
		if (flagdebug)
		printf("Global root |%s|\n",globalroot.c_str());
///	sometimes VSS is not available
		if (globalroot=="")
			error("VSS cannot continue. Maybe impossible to take snapshot?");

		string volume="";

		int posstart=globalroot.find("\\\\");
			
		if (posstart>0)
			for (unsigned i=posstart; i<globalroot.length(); ++i)
				g_vss_shadow=g_vss_shadow+globalroot.at(i);
		if (flagdebug)
			printf("VSS VOLUME <<<%s>>>\n",g_vss_shadow.c_str());
		myreplaceall(g_vss_shadow,"\\","/");
		if (flagdebug)
			printf("VSS SHADOW <<<%s>>>\n",g_vss_shadow.c_str());
		
		
		string	filesubba	=g_gettempdirectory()+"subba.bat";
		filesubba=nomefileseesistegia(filesubba);
		print_datetime();
		printf("VSS: intermediate\n");
		if (fileexists(filesubba))
			if (remove(filesubba.c_str())!=0)
					error("Highlander subba.txt");

		
		string 	vss_windows_style=g_vss_shadow;
		myreplaceall(vss_windows_style,"/","\\");
		
		FILE* subbatch=fopen(filesubba.c_str(), "wb");
		fprintf(subbatch,"@echo OFF\n");
		fprintf(subbatch,"rmdir %s\n",cartellalocale.c_str());
		fprintf(subbatch,"mklink /d %s %s\\ \n",cartellalocale.c_str(),vss_windows_style.c_str());
		///fprintf(subbatch,"subst %s: %s\n",primalettera.c_str(),cartellalocale.c_str());
		fclose(subbatch);
		waitexecute(filesubba,"",SW_HIDE);
	
		///int64_t	liberavss=getfreespace(primalettera+":");
		int64_t	liberavss=getfreespace(cartellalocale.c_str());
		///printf("SPazio lebero vss %s\n",migliaia(liberavss));
		if (liberavss==0)
		{
			///printf("42360: something wrong preparing %s\n",primalettera.c_str());
			printf("42360: something wrong preparing %s\n",cartellalocale.c_str());
			return 2;
		}
		
		
		if (command!='q')
		{
			if (flagdebug)
				printf("42139: tofiles because not q\n");
			tofiles.clear();
			for (unsigned i=0; i<files.size(); ++i)
				tofiles.push_back(files[i]);
			string replaceme=tofiles[0].substr(0,2);
			if (flagdebug)
			printf("-------------- %s -------\n",replaceme.c_str());
			
			for (unsigned i=0; i<files.size(); ++i)
			{
				if (flagdebug)
					printf("PRE  FILES %s\n",files[i].c_str());
				myreplace(files[i],replaceme,g_vss_shadow);
				if (flagdebug)
					printf("POST FILES %s\n",files[i].c_str());
				if (strstr(files[i].c_str(), "GLOBALROOT")==0)
					error("VSS fail: strange post files");
			}	
			}
		else
		{/// command q, windows c backup
			tofiles.clear();
			files.clear();
			string cartellaunix=cartellalocale;
			myreplaceall(cartellaunix,"\\","/");
			cartellaunix+="/*";
			files.push_back(cartellaunix);
			
			///printf("dal vss\n");
			//system( "dir /b /s C:\\Users\\utente\\AppData\\Local\\Microsoft\\WindowsApps" );
			///printf("moro\n");
			///exit(0);
		}
		if (flagdebug)
		{
			for (unsigned i=0; i<files.size(); ++i)
				printf("files %s\n",files[i].c_str());
			printf("\n");
			for (unsigned i=0; i<tofiles.size(); ++i)
				printf("TOFILESSS %s\n",tofiles[i].c_str());
			printf("\n");
			
		}
		
#else
		printf("Volume Shadow Copies runs only on Windows\n");
#endif
		print_datetime();
		printf("VSS: end\n");
	}

/*
	if (tofiles.size()==1)
		printf("KC------------------- to %s\n",tofiles[0].c_str());
*/
				
	string ffranzotype=decodefranzoffset(g_franzotype);
	if (flagverify)
		ffranzotype+=" + CRC-32 by fragments";
	if (flagverbose)
	printf("Integrity check type: %s\n",ffranzotype.c_str());
	

  // Read archive or index into ht, dt, ver.
  int errors=0;
  const bool archive_exists=exists(subpart(archive, 1).c_str());
  string arcname=archive;  // input archive name
  if (index) arcname=index;
  int64_t header_pos=0;
  if (exists(subpart(arcname, 1).c_str()))
    header_pos=read_archive(arcname.c_str(), &errors);

  // Set arcname, offset, header_pos, and salt to open out archive
  arcname=archive;  // output file name
  
  int64_t offset=0;  // total size of existing parts
  char salt[32]={0};  // encryption salt
  if (password) libzpaq::random(salt, 32);

  // Remote archive
  if (index) {
    if (dcsize>0) error("index is a regular archive");
    if (version!=DEFAULT_VERSION) error("cannot truncate with an index");
    offset=header_pos+dhsize;
    header_pos=32*(password && offset==0);
    arcname=subpart(archive, ver.size());
    if (exists(arcname)) {
      printUTF8(arcname.c_str(), stderr);
      fprintf(stderr, ": archive exists\n");
	  g_exec_text=arcname;
	  g_exec_text+=" archive exists";
      error("archive exists");
    }
    if (password) {  // derive archive salt from index
      FP fp=fopen(index, RB);
      if (fp!=FPNULL) {
        if (fread(salt, 1, 32, fp)!=32) error("cannot read salt from index");
        salt[0]^='7'^'z';
        fclose(fp);
      }
    }
  }

  // Local single or multi-part archive
  else {
    int parts=0;  // number of existing parts in multipart
    string part0=subpart(archive, 0);
    if (part0!=archive) {  // multi-part?
      for (int i=1;; ++i) {
        string partname=subpart(archive, i);
        if (partname==part0) error("too many archive parts");
        FP fp=fopen(partname.c_str(), RB);
        if (fp==FPNULL) break;
        ++parts;
        fseeko(fp, 0, SEEK_END);
        offset+=ftello(fp);
        fclose(fp);
      }
      header_pos=32*(password && parts==0);
      arcname=subpart(archive, parts+1);
      if (exists(arcname)) error("part exists");
    }

    // Get salt from first part if it exists
    if (password) {
      FP fp=fopen(subpart(archive, 1).c_str(), RB);
      if (fp==FPNULL) {
        if (header_pos>32) error("archive first part not found");
        header_pos=32;
      }
      else {
        if (fread(salt, 1, 32, fp)!=32) error("cannot read salt");
        fclose(fp);
      }
    }
  }

	g_archive=arcname; /// for multipart the last
	
  // Set method
  if (method=="") method="1";
  if (method.size()==1) {  // set default blocksize
    if (method[0]>='2' && method[0]<='9') method+="6";
    else method+="4";
  }
  if (strchr("0123456789xs", method[0])==0)
    error("-method must begin with 0..5, x, s");
  assert(method.size()>=2);
  if (method[0]=='s' && index) error("cannot index in streaming mode");

  // Set block and fragment sizes
  if (fragment<0) fragment=0;
  const int log_blocksize=20+atoi(method.c_str()+1);
  if (log_blocksize<20 || log_blocksize>31) error("blocksize must be 0..11");
  const unsigned blocksize=(1u<<log_blocksize)-4096;
  const unsigned MAX_FRAGMENT=fragment>19 || (8128u<<fragment)>blocksize-12
      ? blocksize-12 : 8128u<<fragment;
  const unsigned MIN_FRAGMENT=fragment>25 || (64u<<fragment)>MAX_FRAGMENT
      ? MAX_FRAGMENT : 64u<<fragment;

  // Don't mix streaming and journaling
  for (unsigned i=0; i<block.size(); ++i) {
    if (method[0]=='s') {
      if (block[i].usize>=0)
        error("cannot update journaling archive in streaming format");
    }
    else if (block[i].usize<0)
      error("cannot update streaming archive in journaling format");
  }
  
	g_bytescanned=0;
	g_filescanned=0;
	g_worked=0;
	for (unsigned i=0; i<files.size(); ++i)
		scandir(true,edt,files[i].c_str());
	printbar(' ',false);
	printf("\r");
	
	
	unsigned int	maxfilelength=0;
#ifdef _WIN32
	if (!flaglongpath)
		for (DTMap::iterator p=edt.begin(); p!=edt.end(); ++p) 
		{
			string filename=rename(p->first);
			if (filename.size()>maxfilelength)
				maxfilelength=filename.size();
		}
#endif
	
	///if (tofiles.size()==1)
		///printf("K1------------------- to %s\n",tofiles[0].c_str());

  // Sort the files to be added by filename extension and decreasing size
  vector<DTMap::iterator> vf;
  int64_t total_size=0;  // size of all input
  int64_t total_done=0;  // input deduped so far
  int64_t total_xls=0;
  int64_t file_xls=0;

	int toolongfilenames=0;
	int adsfilenames=0;
	int utf8names=0;
	int casecollision=0;
	int	folders=0;
	
  
	FILE* myoutfile=NULL;
	string tempfile="";

///	What is a file list? Just about a dir with redirection on a .txt
/// Why? Because I am paranoid: this is THE file list, dt must be ==
  
	if (flagfilelist)
	{
		tempfile=g_gettempdirectory()+"VFILE-l-filelist.txt";
		myreplaceall(tempfile,"\\","/");
		printf("\nTemp dir <<%s>>\n",tempfile.c_str());
		myoutfile=fopen(tempfile.c_str(), "wb");
		if (myoutfile)
		{
			fprintf(myoutfile,"This is filelist for version %s\n",migliaia(ver.size()));
			for (DTMap::iterator p=edt.begin(); p!=edt.end(); ++p) 
			{
				string filename=rename(p->first);
				///printf("Filelist name %s\n",filename.c_str());
				if (searchfrom!="")
					if (replaceto!="")
						replace(filename,searchfrom,replaceto);
		
				fprintf(myoutfile,"%s %19s ", dateToString(p->second.date).c_str(), migliaia(p->second.size));
				printUTF8(filename.c_str(),myoutfile);
				fprintf(myoutfile,"\n");
			}
			fclose(myoutfile);
			int64_t dimensionelista=0;
			int64_t dimensionedata=0;
			int64_t dimensioneattr=0;
			if (getfileinfo(tempfile,dimensionelista,dimensionedata,dimensioneattr))
			{
				printf("Uncompressed filelist size %s\n",migliaia(dimensionelista));
				addfile(false,edt,tempfile,dimensionedata,dimensionelista,dimensioneattr);
			}
			
		}
	} 

  
  for (DTMap::iterator p=edt.begin(); p!=edt.end(); ++p) 
  {
		string filename=rename(p->first);
		DTMap::iterator a=dt.find(filename);

		if (isdirectory(filename))
			folders++;
		
		if (strstr(filename.c_str(), ":$DATA"))
			adsfilenames++;
	
		if (filename.length()>255)
			toolongfilenames++;
					
		if (flagverbose)
			if (filename!=utf8toansi(filename))
				utf8names++;

	/// by default ALWAYS force XLS to be re-packed
	/// this is because sometimes Excel change the metadata (then SHA1 & CRC32)
	/// WITHOUT touching attr or filesize
	if (!flagdonotforcexls) 
		if (isxls(filename))
		{
			if (flagdebug)
				printf("\nENFORCING XLS/PPT %s\n",filename.c_str());
			total_xls+=p->second.size;
			file_xls++;
		}

///	converting ancient 7.15 archives to zpaqfranz (aka: storing hashes) is not
/// trivial. A very quick-and-dirty method is run TWO times
/// zpaqfranz a z:\1.zpaq c:\dropbox -touch
/// zpaqfranz a z:\1.zpaq c:\dropbox
/// space and time wasted, but afterall about 10 SLOCs

	if (flagtouch)
		p->second.date+=1;  // just a little bit...

    if (a!=dt.end()) a->second.data=1;  // keep
    if (
			p->second.date && p->first!="" && p->first[p->first.size()-1]!='/' && 
			(
				flagforce || 
				a==dt.end() || 
				( (!(isads(filename))) && (!flagdonotforcexls) && (isxls(filename))) || 
				p->second.date!=a->second.date || 
				p->second.size!=a->second.size
			)
		) 
			
	{
      total_size+=p->second.size;

      // Key by first 5 bytes of filename extension, case insensitive
      int sp=0;  // sortkey byte position
      for (string::const_iterator q=p->first.begin(); q!=p->first.end(); ++q){
        uint64_t c=*q&255;
        if (c>='A' && c<='Z') c+='a'-'A';
        if (c=='/') sp=0, p->second.data=0;
        else if (c=='.') sp=8, p->second.data=0;
        else if (sp>3) p->second.data+=c<<(--sp*8);
      }

      // Key by descending size rounded to 16K
      int64_t s=p->second.size>>14;
      if (s>=(1<<24)) s=(1<<24)-1;
      p->second.data+=(1<<24)-s-1;
	  
		vf.push_back(p);
    }
	
  }
  
  /*
  if (!flagnosort)
	std::sort(vf.begin(), vf.end(), compareFilename);
*/
		
	if (menoenne>0)
	{
		int	dastampare=vf.size();
		if (menoenne<(unsigned int)dastampare)
				dastampare=menoenne;
		for (int i=0;i<dastampare; i++) 
			printf("1 %19s %s %s\n",migliaia(vf[i]->second.size),vf[i]->second.hexhash.c_str(),vf[i]->first.c_str());
	}
	
///	Changin' the order of file, before archiving

	if (orderby.size()>0)
	{
		/// ext;size;name;hash;date;data;nilsimsa;
		g_theorderby.clear();
		if (orderby[orderby.size()-1]!=';')
			orderby+=';';
			
		explode(orderby,';',g_theorderby);
		if (g_theorderby.size()>0)
		{
			for (unsigned int i=0;i<g_theorderby.size();i++)
			{
				if (
					(g_theorderby[i]!="ext") &&
					(g_theorderby[i]!="nilsimsa") &&
					(g_theorderby[i]!="size") &&
					(g_theorderby[i]!="name") &&
					(g_theorderby[i]!="hash") &&
					(g_theorderby[i]!="date") &&
					(g_theorderby[i]!="data") 
					)
				printf("\n38022: WARNING: discarded orderby |%s|\n",g_theorderby[i].c_str());
			}

			printf("\nMaking the orderby\n");
			
			MAPPAFILEHASH mappacollisioni;
			int64_t starthashsort=mtime();
			int64_t	hashed=0;
			
			if ( std::find(g_theorderby.begin(), g_theorderby.end(), "hash") != g_theorderby.end() )
			for (unsigned i=0; i<vf.size(); i++) 
			{
				DTMap::iterator p=vf[i];
				string	filename=p->first;
				uint32_t dummycrc=0;
				string thehash=hash_calc_file(ALGO_XXHASH64,filename.c_str(),false,dummycrc,starthashsort,total_size,hashed);
				if (thehash!="")
					p->second.hexhash=thehash;
				else
					printf("38082: error taking hash %s\n",filename.c_str());
			}
			
			if ( std::find(g_theorderby.begin(), g_theorderby.end(), "nilsimsa") != g_theorderby.end() )
			{
				printf("Getting nilsimsa digest\n");
				for (unsigned i=0; i<vf.size(); i++) 
				{
					DTMap::iterator p=vf[i];
					string	filename=p->first;
					uint32_t dummycrc=0;
					string thehash=mm_hash_calc_file(ALGO_NILSIMSA,filename.c_str(),false,dummycrc,starthashsort,total_size,hashed);
					if (thehash!="")
						p->second.hexhash=thehash;
					else
						printf("38402: error taking hash %s\n",filename.c_str());
				}
			}
			std::sort(vf.begin(), vf.end(), compareorderby);
		}
	}
	else
	{
		if (!flagnosort)
		{
			if (flagdebug)
				printf("Default sort\n");
			std::sort(vf.begin(), vf.end(), compareFilename);
		}
	}
	
	if (menoenne>0)
	{
		int	dastampare=vf.size();
		if (menoenne<(unsigned int)dastampare)
				dastampare=menoenne;
		for (int i=0;i<dastampare; i++) 
			printf("2 %19s %s %s\n",migliaia(vf[i]->second.size),vf[i]->second.hexhash.c_str(),vf[i]->first.c_str());
	}
	

///	Mmmhh... seems nothing to do. Exit early and quickly
	if ((total_size==0) && (vf.size()==0))
	{
		printf("\nTotal size and file count == zero, quit. Already archived/wrong/inaccessible source ?\n");
		return 1;	
	}

 
  // Test for reliable access to archive
  if (archive_exists!=exists(subpart(archive, 1).c_str()))
    error("archive access is intermittent");

  if (exists(arcname)) printf("Updating ");
  else printf("Creating ");
  printUTF8(arcname.c_str());
  printf(" at offset %s + %s\n", migliaia(header_pos), migliaia2(offset));

  // Open output
  OutputArchive out(arcname.c_str(), password, salt, offset);
  out.seek(header_pos, SEEK_SET);


  // Start compress and write jobs
  vector<ThreadID> tid(howmanythreads*2-1);
  ThreadID wid;
  CompressJob job(howmanythreads, tid.size(), &out);

	
	printf("Adding %s (%s) in %s files (%s dirs), %d threads ",migliaia(total_size), tohuman(total_size),migliaia2(int(vf.size())),migliaia3(folders),howmanythreads);

	if (flagverbose)
		printf("-method %s ",method.c_str());
	
	printf("@ %s ",dateToString(date).c_str());
	
	
	if (flagcomment)
		if (versioncomment.length()>0)
			printf("<<%s>>",versioncomment.c_str());
	printf("\n");

	if (casecollision>0)
		printf("Case collisions       %9s (-fix255)\n",migliaia(casecollision));
	if (toolongfilenames)
	{
#ifdef _WIN32	
	if (!flagvss)
		printf("Long filenames (>255) %9s *** WARNING *** (-fix255)\n",migliaia(toolongfilenames));
#else
	printf("Long filenames (>255) %9s\n",migliaia(toolongfilenames));
#endif

	}
	if (utf8names)
		printf("Non-latin (UTF-8)     %9s\n",migliaia(utf8names));
	if (adsfilenames)
		printf("ADS ($:DATA)          %9s\n",migliaia(adsfilenames));


	for (unsigned i=0; i<tid.size(); ++i) 
		run(tid[i], compressThread, &job);
	run(wid, writeThread, &job);

  // Append in streaming mode. Each file is a separate block. Large files
  // are split into blocks of size blocksize.
  int64_t dedupesize=0;  // input size after dedupe
  if (method[0]=='s') {
    StringBuffer sb(blocksize+4096-128);
    for (unsigned fi=0; fi<vf.size(); ++fi) {
      DTMap::iterator p=vf[fi];
      print_progress(total_size, total_done,g_scritti,-1);
	  
/*     
	 if (summary<=0) {
        printf("+ ");
        printUTF8(p->first.c_str());
        printf(" %1.0f\n", p->second.size+0.0);
      }
	  */
      FP in=fopen(p->first.c_str(), RB);
	  
	  
      if (in==FPNULL) {
        printerr("16570",p->first.c_str(),0);
        total_size-=p->second.size;
        ++errors;
        continue;
      }
      uint64_t i=0;
      const int BUFSIZE=4096;
      char buf[BUFSIZE];
      while (true) {
        int r=fread(buf, 1, BUFSIZE, in);
        sb.write(buf, r);
        i+=r;
        if (r==0 || sb.size()+BUFSIZE>blocksize) {
          string filename="";
          string comment="";
          if (i==sb.size()) {  // first block?
            filename=rename(p->first);
            comment=itos(p->second.date);
            if ((p->second.attr&255)>0) {
              comment+=" ";
              comment+=char(p->second.attr&255);
              comment+=itos(p->second.attr>>8);
            }
          }
          total_done+=sb.size();
          job.write(sb, filename.c_str(), method, comment.c_str());
          assert(sb.size()==0);
        }
        if (r==0) break;
      }
      fclose(in);
    }

    // Wait for jobs to finish
    job.write(sb, 0, "");  // signal end of input
    for (unsigned i=0; i<tid.size(); ++i) join(tid[i]);
    join(wid);

    // Done
    const int64_t outsize=out.tell();
    printf("%1.0f + (%1.0f -> %1.0f) = %s\n",
        double(header_pos),
        double(total_size),
        double(outsize-header_pos),
        migliaia(outsize));
    out.close();
    return errors>0;
  }  // end if streaming

  // Adjust date to maintain sequential order
  if (ver.size() && ver.back().lastdate>=date) {
    const int64_t newdate=decimal_time(unix_time(ver.back().lastdate)+1);
    fflush(stdout);
    fprintf(stderr, "Warning: adjusting date from %s to %s\n",
      dateToString(date).c_str(), dateToString(newdate).c_str());
    assert(newdate>date);
    date=newdate;
  }

  // Build htinv for fast lookups of sha1 in ht
  HTIndex htinv(ht, ht.size()+(total_size>>(10+fragment))+vf.size());
  const unsigned htsize=ht.size();  // fragments at start of update

  // reserve space for the header block
  writeJidacHeader(&out, date, -1, htsize);
  const int64_t header_end=out.tell();

  // Compress until end of last file
  assert(method!="");
  StringBuffer sb(blocksize+4096-128);  // block to compress
  unsigned frags=0;    // number of fragments in sb
  unsigned redundancy=0;  // estimated bytes that can be compressed out of sb
  unsigned text=0;     // number of fragents containing text
  unsigned exe=0;      // number of fragments containing x86 (exe, dll)
  const int ON=4;      // number of order-1 tables to save
  unsigned char o1prev[ON*256]={0};  // last ON order 1 predictions
  libzpaq::Array<char> fragbuf(MAX_FRAGMENT);
  vector<unsigned> blocklist;  // list of starting fragments

	///int64_t	crckanz=0;
 // For each file to be added
  for (unsigned fi=0; fi<=vf.size(); ++fi) 
  {

	string workingfile="";
	
	FP in=FPNULL;
    const int BUFSIZE=4096;  // input buffer
    char buf[BUFSIZE];
    int bufptr=0, buflen=0;  // read pointer and limit
	
	DTMap::iterator p;
	
    if (fi<vf.size()) 
	{
      assert(vf[fi]->second.ptr.size()==0);
      p=vf[fi];
		workingfile=p->first;
		/// mik printf("lavoro %s\n",p->first.c_str());

      // Open input file
      bufptr=buflen=0;
      in=fopen(p->first.c_str(), RB);
	   
	  
      if (in==FPNULL) 
	  {  // skip if not found
			p->second.date=0;
			total_size-=p->second.size;
///	Houston, we got an error. Try to figure why re-opening the file (on Windows)
/// Microsoft filesystem is so complex, better some help
			int64_t attrib=0;
#ifdef _WIN32
			attrib=getwinattributes(p->first);
#endif
			printerr("16672",p->first.c_str(),attrib);
			++errors;
			continue;
      }
		// get expected filesize. Slow down a bit. But I like very much 
		///if (flagverbose)
		{
			fseeko(in, 0, SEEK_END);
			p->second.expectedsize=ftello(in);
			fseeko(in, 0, SEEK_SET);
		}
		p->second.data=1;  // add
    }

	
	int		ultimapercentuale=0;
	
    // Read fragments
    int64_t fsize=0;  // file size after dedupe
    for (unsigned fj=0; true; ++fj) {
      int64_t sz=0;  // fragment size;
      unsigned hits=0;  // correct prediction count
      int c=EOF;  // current byte
      unsigned htptr=0;  // fragment index
      char sha1result[20]={0};  // fragment hash
      unsigned char o1[256]={0};  // order 1 context -> predicted byte
      if (fi<vf.size()) {
        int c1=0;  // previous byte
        unsigned h=0;  // rolling hash for finding fragment boundaries
        libzpaq::SHA1 sha1;
        assert(in!=FPNULL);
        while (true) {
			if (bufptr>=buflen) bufptr=0, buflen=fread(buf, 1, BUFSIZE, in);
	
	///	zero-length file (-debug -zero -kill)
	/// or zero-filled file (-debug -zero)
	
			if (flagdebug)
				if (flagzero)
				{
					if (flagkill)
						bufptr=buflen;
					else
						memset(buf,0,buflen);
				}
				
			if (g_franzotype>0)
				if (bufptr==0)
					if (buflen>0) 
					{
						/// check for strange things (corrupted files, lost connection...)
						p->second.hashedsize+=buflen;
				
///	this is why pre-get filesize: % of big files into global %				
						///if (flagverbose)
						if (p->second.expectedsize>100000000)
						{
							int percentuale=(int)(100.0*p->second.hashedsize/p->second.expectedsize)+1;
							int modulo=10;
							
							if (p->second.expectedsize>1000000000)
								modulo=1;
						
							if (percentuale!=ultimapercentuale)
							if (percentuale%modulo==0)
							{
								print_progress(total_size, total_done,g_scritti,ultimapercentuale);
								ultimapercentuale=percentuale;
							}
						}
						
	///	compute CRC-32 (always) in zpaqfranz, then the hash
						p->second.file_crc32=crc32_16bytes(buf,buflen,p->second.file_crc32);
	
						if (g_franzotype==FRANZO_XXHASH64)
							if (p->second.pfile_xxhash64)
								(*p->second.pfile_xxhash64).add(buf,buflen);

						if (g_franzotype==FRANZO_SHA_1)
							if (p->second.pfile_sha1)
								(*p->second.pfile_sha1).write(buf,buflen);
												
						if (g_franzotype==FRANZO_SHA_256)
							if (p->second.pfile_sha256)
								for (int i=0;i<buflen;i++)
									(*p->second.pfile_sha256).put(*(buf+i));
								
						if (g_franzotype==FRANZO_XXH3)
							if (p->second.pfile_xxh3)
								(void)XXH3_128bits_update(p->second.pfile_xxh3, buf,buflen);
						
						if (g_franzotype==FRANZO_BLAKE3)
							if (p->second.pfile_blake3)
								blake3_hasher_update(p->second.pfile_blake3, buf,buflen);
						
						if (g_franzotype==FRANZO_SHA3)
							if (p->second.pfile_sha3)
								(*p->second.pfile_sha3).add(buf,buflen);
					
						if (g_franzotype==FRANZO_MD5)
							if (p->second.pfile_md5)
							(*p->second.pfile_md5).add(buf,buflen);
					}
					///
          if (bufptr>=buflen) c=EOF;
          else c=(unsigned char)buf[bufptr++];
          if (c!=EOF) {
            if (c==o1[c1]) h=(h+c+1)*314159265u, ++hits;
            else h=(h+c+1)*271828182u;
            o1[c1]=c;
            c1=c;
			///if (!flagnodedup)
            sha1.put(c);
            fragbuf[sz++]=c;
	///		printf("sz %08d\n",sz);
          }
          if (c==EOF
              || sz>=MAX_FRAGMENT
              || (fragment<=22 && h<(1u<<(22-fragment)) && sz>=MIN_FRAGMENT))
            break;
        }
        assert(sz<=MAX_FRAGMENT);
        total_done+=sz;

		
        // Look for matching fragment
        assert(uint64_t(sz)==sha1.usize());
		memcpy(sha1result, sha1.result(), 20);
		if (flagnodedup)
			htptr=0;
		else
			htptr=htinv.find(sha1result);
		}  // end if fi<vf.size()

/// OK, lets RE-compute CRC-32 of the fragment, and store
/// used for debug


		uint32_t crc;
		if (flagverify)
			if (g_franzotype>0)
			{
				crc=crc32_16bytes(&fragbuf[0],(uint32_t) sz);
				if (htptr)
				{
					ht[htptr].crc32=crc;
					ht[htptr].crc32size=sz;
				}
			}


      if (htptr==0) {  // not matched or last block

        // Analyze fragment for redundancy, x86, text.
        // Test for text: letters, digits, '.' and ',' followed by spaces
        //   and no invalid UTF-8.
        // Test for exe: 139 (mov reg, r/m) in lots of contexts.
        // 4 tests for redundancy, measured as hits/sz. Take the highest of:
        //   1. Successful prediction count in o1.
        //   2. Non-uniform distribution in o1 (counted in o2).
        //   3. Fraction of zeros in o1 (bytes never seen).
        //   4. Fraction of matches between o1 and previous o1 (o1prev).
        int text1=0, exe1=0;
        int64_t h1=sz;
        unsigned char o1ct[256]={0};  // counts of bytes in o1
        static const unsigned char dt[256]={  // 32768/((i+1)*204)
          160,80,53,40,32,26,22,20,17,16,14,13,12,11,10,10,
            9, 8, 8, 8, 7, 7, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5,
            4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 3, 3, 3,
            3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
            2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
            1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
            1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
            1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
            1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
            1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1};
        for (int i=0; i<256; ++i) {
          if (o1ct[o1[i]]<255) h1-=(sz*dt[o1ct[o1[i]]++])>>15;
          if (o1[i]==' ' && (isalnum(i) || i=='.' || i==',')) ++text1;
          if (o1[i] && (i<9 || i==11 || i==12 || (i>=14 && i<=31) || i>=240))
            --text1;
          if (i>=192 && i<240 && o1[i] && (o1[i]<128 || o1[i]>=192))
            --text1;
          if (o1[i]==139) ++exe1;
        }
        text1=(text1>=3);
        exe1=(exe1>=5);
        if (sz>0) h1=h1*h1/sz; // Test 2: near 0 if random.
        unsigned h2=h1;
        if (h2>hits) hits=h2;
        h2=o1ct[0]*sz/256;  // Test 3: bytes never seen or that predict 0.
        if (h2>hits) hits=h2;
        h2=0;
        for (int i=0; i<256*ON; ++i)  // Test 4: compare to previous o1.
          h2+=o1prev[i]==o1[i&255];
        h2=h2*sz/(256*ON);
        if (h2>hits) hits=h2;
        if (hits>sz) hits=sz;

        // Start a new block if the current block is almost full, or at
        // the start of a file that won't fit or doesn't share mutual
        // information with the current block, or last file.
        bool newblock=false;
        if (frags>0 && fj==0 && fi<vf.size()) {
          const int64_t esize=vf[fi]->second.size;
          const int64_t newsize=sb.size()+esize+(esize>>14)+4096+frags*4;
          if (newsize>blocksize/4 && redundancy<sb.size()/128) newblock=true;
          if (newblock) {  // test for mutual information
            unsigned ct=0;
            for (unsigned i=0; i<256*ON; ++i)
              if (o1prev[i] && o1prev[i]==o1[i&255]) ++ct;
            if (ct>ON*2) newblock=false;
          }
          if (newsize>=blocksize) newblock=true;  // won't fit?
        }
        if (sb.size()+sz+80+frags*4>=blocksize) newblock=true; // full?
        if (fi==vf.size()) newblock=true;  // last file?
        if (frags<1) newblock=false;  // block is empty?

        // Pad sb with fragment size list, then compress
        if (newblock) {
          assert(frags>0);
          assert(frags<ht.size());
          for (unsigned i=ht.size()-frags; i<ht.size(); ++i)
            puti(sb, ht[i].usize, 4);  // list of frag sizes
          puti(sb, 0, 4); // omit first frag ID to make block movable
          puti(sb, frags, 4);  // number of frags
          string m=method;
          if (isdigit(method[0]))
            m+=","+itos(redundancy/(sb.size()/256+1))
                 +","+itos((exe>frags)*2+(text>frags));
          string fn="jDC"+itos(date, 14)+"d"+itos(ht.size()-frags, 10);
          print_progress(total_size, total_done,g_scritti,ultimapercentuale);

/*         
		 if (summary<=0)
            printf("[%u..%u] %u -method %s\n",
                unsigned(ht.size())-frags, unsigned(ht.size())-1,
                unsigned(sb.size()), m.c_str());
*/  
  if (method[0]!='i')
		  {
				
				
			job.write(sb, fn.c_str(), m.c_str());
		  }
          else {  // index: don't compress data
            job.csize.push_back(sb.size());
            sb.resize(0);
          }
          assert(sb.size()==0);
          blocklist.push_back(ht.size()-frags);  // mark block start
		  frags=redundancy=text=exe=0;
          memset(o1prev, 0, sizeof(o1prev));
        }

        // Append fragbuf to sb and update block statistics
        assert(sz==0 || fi<vf.size());
        sb.write(&fragbuf[0], sz);
		
        
        ++frags;
        redundancy+=hits;
        exe+=exe1*4;
        text+=text1*2;
        if (sz>=MIN_FRAGMENT) {
          memmove(o1prev, o1prev+256, 256*(ON-1));
          memcpy(o1prev+256*(ON-1), o1, 256);
        }
      }  // end if frag not matched or last block

      // Update HT and ptr list
      if (fi<vf.size()) 
	  {
        if (htptr==0) {
          htptr=ht.size();
          ht.push_back(HT(sha1result, sz));
          htinv.update();
          fsize+=sz;
        }
        vf[fi]->second.ptr.push_back(htptr);

///OK store the crc. Very dirty (to be fixed in future)
		//crckanz++;
		///crc=crc32_16bytes(&fragbuf[0],(uint32_t) sz);
		if (flagverify)
			if (g_franzotype>0)
			{
				ht[htptr].crc32=crc;
				ht[htptr].crc32size=sz;
			}
	}
      if (c==EOF) break;
	///printf("Fragment fj %ld\n",fj);
    }  // end for each fragment fj
	
	
    if (fi<vf.size()) {
      dedupesize+=fsize;
	  ///print_datetime();	
	  /// check errori 
      print_progress(total_size, total_done,g_scritti,ultimapercentuale);
      assert(in!=FPNULL);
      fclose(in);
      in=FPNULL;
    }
  }  // end for each file fi
  assert(sb.size()==0);

	////printf("KKKKKKKKKKKKKKKKKKKKKKKKKKANZAAAAAAAAAA  %d\n",crckanz);
	
  // Wait for jobs to finish
  job.write(sb, 0, "");  // signal end of input
  for (unsigned i=0; i<tid.size(); ++i) join(tid[i]);
  join(wid);

  // Open index
  salt[0]^='7'^'z';
  OutputArchive outi(index ? index : "", password, salt, 0);
  WriterPair wp;
  wp.a=&out;
  if (index) wp.b=&outi;
  writeJidacHeader(&outi, date, 0, htsize);

  // Append compressed fragment tables to archive
  int64_t cdatasize=out.tell()-header_end;
  StringBuffer is;
  assert(blocklist.size()==job.csize.size());
  blocklist.push_back(ht.size());
  for (unsigned i=0; i<job.csize.size(); ++i) {
    if (blocklist[i]<blocklist[i+1]) {
      puti(is, job.csize[i], 4);  // compressed size of block
      for (unsigned j=blocklist[i]; j<blocklist[i+1]; ++j) {
        is.write((const char*)ht[j].sha1, 20);
        puti(is, ht[j].usize, 4);
      }
      libzpaq::compressBlock(&is, &wp, "0",
          ("jDC"+itos(date, 14)+"h"+itos(blocklist[i], 10)).c_str(),
          "jDC\x01");
      is.resize(0);
    }
  }

  // Delete from archive
  int dtcount=0;  // index block header name
  int removed=0;  // count
  for (DTMap::iterator p=dt.begin(); p!=dt.end(); ++p) {
    if (p->second.date && !p->second.data) {
      puti(is, 0, 8);
      is.write(p->first.c_str(), strlen(p->first.c_str()));
      is.put(0);
	  /*
      if (summary<=0) {
        printf("- ");
        printUTF8(p->first.c_str());
        printf("\n");
      }
	  */
      ++removed;
      if (is.size()>16000) {
        libzpaq::compressBlock(&is, &wp, "1",
            ("jDC"+itos(date)+"i"+itos(++dtcount, 10)).c_str(), "jDC\x01");
        is.resize(0);
      }
    }
  }
	
  // Append compressed index to archive
	int added=0;  // count
	for (DTMap::iterator p=edt.begin();; ++p) 
	{
		if (p!=edt.end()) 
		{
			string filename=rename(p->first);

			/// Fix longpath on VSS ( reference the addfile() )
			///	hardcoded, do you like it?
			if (command=='q')
			{
				myreplace(filename,g_vss_shadow,"c:/franzsnap");
			///	myreplace(filename,"c:/franzsnap","c:");
			}
			
			if (searchfrom!="")
				if (replaceto!="")
					replace(filename,searchfrom,replaceto);

///			by using FRANZOFFSET we need to cut down the attr during this compare
			DTMap::iterator a=dt.find(filename);
			if (p->second.date && (a==dt.end() // new file
			|| a->second.date!=p->second.date  // date change
			|| ((int32_t)a->second.attr && (int32_t)a->second.attr!=(int32_t)p->second.attr)  // attr ch. get less bits
			|| a->second.size!=p->second.size  // size change
			|| (p->second.data && a->second.ptr!=p->second.ptr))) 
			{ 

///				we want to strip the path of VLIST
				if (mypos("VFILE-",filename)>-1)
				{
					printf("\nWe get a VFILE\n");
					filename=extractfilename(filename);
				}
	
				uint32_t currentcrc32=0;
				if (flagverify)
				{
					for (unsigned i=0; i<p->second.ptr.size(); ++i)
						currentcrc32=crc32_combine(currentcrc32, ht[p->second.ptr[i]].crc32,ht[p->second.ptr[i]].crc32size);
					if (currentcrc32!=p->second.file_crc32)
						printf("29604 SOMETHING WRONG ON %s\n",p->first.c_str());
				}		
			
				++added;
				
///				date and filename
				puti(is, p->second.date, 8);
				is.write(filename.c_str(), strlen(filename.c_str()));
				is.put(0);
			
				string 	hashtobewritten="";
				string	hasherror="";
				
				if (!(flagdebug && flagzero && flagkill))
				{
///				zpaqfranz: write hashes and/or CRC-32
					if (g_franzotype==FRANZO_CRC_32) /// store only CRC-32
					{
						hashtobewritten="";
						if (flagdebug)
							printf("Mode1: CRC32 by frag <<%08X>> for %s\n",currentcrc32,p->first.c_str());
					}
					else
					if (g_franzotype==FRANZO_XXHASH64)
					{
						char temp[17]={0};
						sprintf(temp,"%016llX",(unsigned long long)(*p->second.pfile_xxhash64).hash());
						hashtobewritten=temp;
						if (flagdebug)
							printf("Model2: XXHASH64 %s %s\n",hashtobewritten.c_str(),p->first.c_str());				
						p->second.hashtype="XXHASH64";
						p->second.hexhash=hashtobewritten;
						hasherror="!ERROR!         ";
					}
					else
					if (g_franzotype==FRANZO_SHA_1)
					{
						char sha1result[21]={0};
						memcpy(sha1result, (*p->second.pfile_sha1).result(), 20);
					
						hashtobewritten=binarytohex((const unsigned char*)sha1result,20);
						if (flagdebug)
							printf("Mode3: SHA1 %s %s\n",hashtobewritten.c_str(),p->first.c_str());
						p->second.hashtype="SHA-1";
						p->second.hexhash=hashtobewritten;
						hasherror="!ERROR!                                 ";
					}
					else
					if (g_franzotype==FRANZO_SHA_256)
					{
						char sha256result[33]={0};
						memcpy(sha256result, (*p->second.pfile_sha256).result(), 32);
						hashtobewritten=binarytohex((const unsigned char*)sha256result,32);
						if (flagdebug)
							printf("Mode4: SHA256 %s %s\n",hashtobewritten.c_str(),p->first.c_str());
						p->second.hashtype="SHA-256";
						p->second.hexhash=hashtobewritten;	
						hasherror="!ERROR!                                                         ";
					}
					else
					if (g_franzotype==FRANZO_BLAKE3)
					{
						uint8_t output[BLAKE3_OUT_LEN];
						blake3_hasher_finalize(p->second.pfile_blake3, output, BLAKE3_OUT_LEN);
						hashtobewritten=binarytohex((const unsigned char*)output,BLAKE3_OUT_LEN);
						if (flagdebug)
							printf("Mode6: BLAKE3 %s %s\n",hashtobewritten.c_str(),p->first.c_str());
						p->second.hashtype="BLAKE3";
						p->second.hexhash=hashtobewritten;
						hasherror="!ERROR!                                                         ";
					}
					else
					if (g_franzotype==FRANZO_SHA3)
					{
						hashtobewritten=(*p->second.pfile_sha3).getHash();
						if (flagdebug)
							printf("Mode7: SHA3 %s %s\n",hashtobewritten.c_str(),p->first.c_str());
						p->second.hashtype="SHA-3";
						p->second.hexhash=hashtobewritten;
						hasherror="!ERROR!                                                         ";
					}
					else
					if (g_franzotype==FRANZO_MD5)
					{
						hashtobewritten=(*p->second.pfile_md5).getHash();
						if (flagdebug)
							printf("Mode8: MD5 %s %s\n",hashtobewritten.c_str(),p->first.c_str());
						p->second.hashtype="MD5";
						p->second.hexhash=hashtobewritten;
						hasherror="!ERROR!                         ";
					}
					else
					if (g_franzotype==FRANZO_XXH3)
					{
						char xxh3result[33]={0};
						XXH128_hash_t myhash=XXH3_128bits_digest(p->second.pfile_xxh3);
						sprintf(xxh3result,"%016llX%016llX",(unsigned long long)myhash.high64,(unsigned long long)myhash.low64);
						hashtobewritten=xxh3result;
						if (flagdebug)
							printf("Model5: XXH3 %s %s\n",hashtobewritten.c_str(),p->first.c_str());
						p->second.hashtype="XXH3";
						p->second.hexhash=hashtobewritten;
						hasherror="!ERROR!                         ";
					}
					
					///	intercept (some) strange things, enforcing a fake hash (will be reported on verify of course) 
					if (hashtobewritten!="")
					{
						if ((p->second.size!=p->second.hashedsize) && (p->second.hashedsize==0))
						{
							if (!flagvss)
							{
								printf("38383: ERROR expected %19s getted 0 bytes  ",migliaia(p->second.size));
								printUTF8(filename.c_str());
								printf("\n");
							}
							hashtobewritten=hasherror;
						}
						else
						if (p->second.size!=p->second.hashedsize)
						{
							if (!flagvss)
							{
								printf("38385: WARN expected %19s getted %19s for ",migliaia(p->second.size),migliaia2(p->second.hashedsize));
								printUTF8(filename.c_str());
								printf("\n");
							}
	///						hashtobewritten=hasherror;
						}

					}
				}
				
							
///				write attributes, if any. u=unix, w=windows. Look @ size (3 vs 5)
				if ((p->second.attr&255)=='u')
						writefranzattr(is,p->second.attr,3,filename,currentcrc32,p->second.file_crc32,hashtobewritten);
				else 
				if ((p->second.attr&255)=='w')
						writefranzattr(is,p->second.attr,5,filename,currentcrc32,p->second.file_crc32,hashtobewritten);
				else 
					puti(is, 0, 4);  // no attributes
			
				if (a==dt.end() || p->second.data) 
					a=p;  // use new frag pointers
				puti(is, a->second.ptr.size(), 4);  // list of frag pointers
				
				for (unsigned i=0; i<a->second.ptr.size(); ++i)
					puti(is, a->second.ptr[i], 4);
			}
		}
		else
		{
			if (versioncomment.length()>0)
			{
/// quickly store a fake file (for backward compatibility) with the version comment			
				///VCOMMENT 00000002 seconda_versione:$DATA
				char versioni8[32];
				sprintf(versioni8,"%08lld",(long long)ver.size());
				versioni8[8]=0x0;
				string fakefile="VCOMMENT "+string(versioni8)+" "+versioncomment+":$DATA"; //hidden windows file
				puti(is, 0, 8); // this is the "date". 0 is good, but do not pass paranoid compliance test. damn
				is.write(fakefile.c_str(), strlen(fakefile.c_str()));
				is.put(0);
			///	puti(is, 0, 4);  // no attributes
			///	puti(is, 0, 4);  // list of frag pointers
			}
		}
		if (is.size()>16000 || (is.size()>0 && p==edt.end())) 
		{
			libzpaq::compressBlock(&is, &wp, "1",
				("jDC"+itos(date)+"i"+itos(++dtcount, 10)).c_str(), "jDC\x01");
			is.resize(0);
		}
		if (p==edt.end()) 
			break;
	}	

	printbar(' ',false);
	printf("\r%s +added, %s -removed.\n", migliaia(added), migliaia2(removed));
	assert(is.size()==0);

  // Back up and write the header
  outi.close();
  int64_t archive_end=out.tell();
  out.seek(header_pos, SEEK_SET);
  writeJidacHeader(&out, date, cdatasize, htsize);
  out.seek(0, SEEK_END);
  int64_t archive_size=out.tell();
  out.close();

  // Truncate empty update from archive (if not indexed)
  if (!index) 
  {
		if (added+removed==0 && archive_end-header_pos==104) // no update
			archive_end=header_pos;
		if (archive_end<archive_size) 
		{
			if (archive_end>0) 
			{
				if (flagverbose)
				printf("truncating archive from %s to %s\n",migliaia(archive_size), migliaia2(archive_end));
				if (truncate(arcname.c_str(), archive_end)) 
					printerr("17092",archive.c_str(),0);
			}
			else 
			if (archive_end==0) 
			{
				if (delete_file(arcname.c_str()))
					if (flagverbose)
					{
						printf("deleted ");
						printUTF8(arcname.c_str());
						printf(" : no data to be archived\n");
					}
			}
		}
  }
  fflush(stdout);
  
	if (archive_end) //sometimes the unencrypted .zpaq is empty
	{
		if (flagverbose)
			if (total_xls)
					printf("Forced XLS/PPT has included %s bytes in %s files\n",migliaia(total_xls),migliaia2(file_xls));

		int64_t speed=0;
		int64_t ticks=mtime()-g_start;
		if (ticks>0) 	// not divide by zero, please
			speed=total_size/(ticks/1000.0);
		
		  if (flagverbose)
			fprintf(stderr, "\n %21s starting size\n %21s data to be added\n %21s after deduplication\n+%21s after compression\n %21s total size\nTotal speed %s/s\n",
			  migliaia(header_pos), migliaia2(total_size), migliaia3(dedupesize),
			  migliaia4(archive_end-header_pos), migliaia5(archive_end),tohuman(speed));
			else
			  
		  fprintf(stderr, "\n%s + (%s -> %s -> %s) = %s @ %s/s\n",
			  migliaia(header_pos), migliaia2(total_size), migliaia3(dedupesize),
			  migliaia4(archive_end-header_pos), migliaia5(archive_end),tohuman(speed));
	}
	
#if defined(_WIN32)
	if (flagvss)
		vss_deleteshadows(cartellalocale);
	
	if (!flaglongpath)
		if (!flagvss) // hard-coded kludge for long vss files
			if (maxfilelength>255)
				printf("\n*** WINDOWS WARNING *** found file length >255. Suggestion: use -longpath switch\n");
#endif
		
	if (flagfilelist)
		if (fileexists(tempfile))
		{
			if (flagdebug)
				printf("42972: deleting tempfile %s\n",tempfile.c_str());
			delete_file(tempfile.c_str());
		}
		

	///do a second copy (ex. to USB)	
	if (errors==0)
		if (g_copy!="")
		{
			string filescritto=filecopy(false,false,g_archive,g_copy,true,false,false);
			
			if (filescritto!="")
				printf("Copied <<%s>> to <<%s>>\n",g_archive.c_str(),filescritto.c_str());
			else
				printf("34971: ERROR doing -copy from %s to %s\n",g_archive.c_str(),filescritto.c_str());
		}
	
	/// late -test    
	if (flagtest)
	{
		printbar('=');
		if (flagverbose)
			printf("43054: Do a testverify()\n");
		all=false;
		ver.clear();
		block.clear();
		dt.clear();
		ht.clear();
		edt.clear();
		ht.resize(1);  // element 0 not used
		ver.resize(1); // version 0
		dhsize=dcsize=0;
		errors=testverify();
	}	
	if (flagverify)
	{
		printbar('=');
		if (flagverbose)
			printf("43070: Do a verify()\n");
		
		all=false;
		ver.clear();
		block.clear();
		dt.clear();
		ht.clear();
		edt.clear();
		ht.resize(1);  // element 0 not used
		ver.resize(1); // version 0
		dhsize=dcsize=0;
		
		errors=verify(true); //re-read, again
	}	
	
	if (g_sfx!="")
		errors+=writesfxmodule(g_sfx);

	if (!(flagdebug && flagzero && flagkill))
		if (total_size!=(total_done))
		{
			printf("\n");
			printf("38271: HOUSTON expected %s, done %s, diff %s\n",migliaia(total_size),migliaia2(total_done),migliaia3(myabs(total_size,total_done)));
			if (flagvss)
			{
				printf("38271: This could be 'normal' for a VSS operation\n");
			}
			else
			{
				printf("38271: Corrupted source files? Lost connection? Cannot access? Media full?\n");
				printf("38271: =>The updated .zpaq archive is almost certainly incompleted\n");
			}
			g_exec_text="38271: HOUSTON something seems wrong expected vs done";
			errors=2;
		}
#ifdef _WIN32
// this is a new thing: takes "strange" file access error, for debug (cannot access, denied etc)
	if (flagverbose)
		enumerateerrors();
#endif 

	return errors;
}



/*
	Section: sfx
	
	The two binaries (zsfx.exe for Windows 64 bit, and zsfx32.exe for Win32)
	are compressed with smallz4
	https://create.stephan-brumme.com/smallz4
	
	c:\nz\smallz4-v1.5.exe -f zsfx.exe zsfx.exe.lz4
	c:\nz\smallz4-v1.5.exe -f zsfx32.exe zsfx32.exe.lz4
	
	then base64-encoded (https://www.base64encode.org/)
	
	The 32-bit is about 2/3 of the 64 (~220K vs ~320K)
	but slower. In fact not a big deal
	
*/
#if defined(_WIN32) && (defined(_WIN64))  
char zsfx_mime64[]={"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6AETKwgAEwIEABMuEAATMQgABBwAEzMQACpCGzAAEzYYABc5MAAABAAeOxgAATAAEz4QABNBCAATCBwAE0oQABNNCAATCRgAH1cwAAQTWhAAE10IABMKYAATaBAAG2vYABNuEAAbcZAAE3MQABt2wAATeBAAG3tIABN+EAAbgagAE4sQABOOCAATDDAAE5sQABueYAAToBAAE6MIABMHGAATqxAAG654ABOxEAAbtMAAE7YQABu5GAATuxAAG75IABPBEAAbxDAAE8YQABvJMAATzBAAJjwZeAUABAAfzxgABB7SGAABSAAf1RgABBPYGAAb23gAE94QACY4FxgAAAgAE+EYABvkwAAT5hAAG+lIABPsEAAq7yB4ABPzEAAb9jAAE/kQACb8INAFAXgCEyEQABohMAATDhAAKhEhkAATExAAGxYwABMZEAAbHBgAEx8QABsiSAATJBAAG57wABMnGAAqKiEgARMtEAATMAgAEwX0ABM2EAAbOXgAHjx4AAEEABM/EAAbQhgAE0QQACpHIfgBE0sQABtOYAATURAAG1QYABNXEAAbWvAAE1wQABtfMAATYhAAG2UwABNnEAAqaiHgARNuEAAbcSABHnRIAAEEABN3EAAbengAEwGwAhd9MAAAZAATfxAAG4IwABOFEAAbiJAAE4wQABOPCAATEBgAE6AQABuj2AATpRAAG6hgABOrEAAqriGABB+4GAAEE7sQABS+wAIDSAATyhAAG82oABPREAAq1CGYBB/cGAAEE98QABficAIBoAgDEAAT6wgAEwYwAA8BAAUAIhkQZZIfcWFyAGJvb2wFAEJlYW4AEgAAuSNwZG91YmxlAMoeEyAMAIFmbG9hdABfXwgAMDEyOIUjB0kANmludBIACA0AAUUABhsAAQ4ASl9faW5EAAUSAAHcJQYYAAIPAGJ2b2lkAHfhCgKVAA5VAAITAJRkZWNpbWFsMzIKACQ2NAoAAF4AQWhhbGbnADE4X3QIACMxNgkATzMyX3QwAQQqkChwCgwQABOcEAADq0wjAKEQABMHBAAbqSAAG64QABOzEAAeBhAAAYQHG7pwAAgQAAAgACrGKBACCBAAACAAJswouAcbABAAACAAKtcoqAoMEAAq5SgIDAgQAAEIBhooIAsm9ihACB8CHzsQG/8QAQgQAABkACoEKZAACBAAACQAExIQ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XZNd911bXr5eIF+BX+JfQWChYP9gXWG5YRVicWLLYiVjfmPWYy5khGTaZDBlhGXYZSpmfWbOZh5nbme9ZwxoWWimaPJoPWmHadFpGmpiaqpq8Wo3a3xrwGsEbEdsimzLbAxtTW2MbcttCW5GboNuv277bjVvb2+pb+FvGXBRcIdwvXDzcChxXHGPccJx9XEmcldyiHK4cudyFnNEc3Jzn3PLc/dzInRNdHd0oXTKdPN0G3VDdWp1kHW2ddx1AXYmdkp2bXaRdrN21nb3dhl3Ondad3p3mne5d9h39ncUeDF4T3hreIh4pHi/eNp49XgQeSp5Q3ldeXZ5jnmneb951nnteQR6G3oxekd6XXpyeoh6nHqxesV62XrtegB7E3smezh7S3tde257gHuRe6J7s3vDe9R75HvzewN8EnwhfDB8P3xNfFx8anx4fIV8k3ygfK18unzGfNN833zrfPd8A30PfRp9JX0wfTt9Rn1RfVt9ZX1vfXl9g32NfZZ9oH2pfbJ9u33Efc191X3efeZ97n32ff59Bn4OfhV+HX4kfix+M346fkF+R35OflV+W35ifmh+bn51fnt+gX6Gfox+kn6Xfp1+on6ofq1+sn63frx+wX7Gfst+0H7Uftl+3n7ifuZ+637vfvN+9377fv9+A38Hfwt/D38SfxZ/Gn8dfyF/JH8ofyt/Ln8xfzV/OH87fz5/QX9Ef0d/SX9Mf09/Un9Uf1d/Wn9cf19/YX9kf2Z/aH9rf21/b39yf3R/dn94f3p/fH9+f4B/gn+Ef4Z/iH+Kf4x/jX+Pf5F/k3+Uf5Z/mH+Zf5t/nH+ef59/oX+if6R/pX+nf6h/qX+rf6x/rX+uf7B/sX+yf7N/tX+2f7d/uH+5f7p/u3+8f71/vn+/f8B/wX/Cf8N/xH/Ff8Z/x3/If8l/yX/Kf8t/zH/Nf85/zn/Pf9B/0X/Rf9J/03/Tf9R/1X/Vf9Z/13/Xf9h/2X/Zf9p/2n/bf9t/3H/df91/3n/ef99/33/gf+B/4X/hf+J/4n/jAgCR5H/kf+V/5X/mAgBR53/nf+gCABHpAgAR6gIAEesCABHsAgAT7QIAE+4CABHvAgAV8AIAE/ECABXyAgAV8wIAFfQCABn1AgAX9gIAG/cCABv4AgAf+QIAAB/6AgAEH/sCAAgf/AIAEh/9AgAgH/4CAEQX/wIAE7DwJxNAyHQTEPAnE2AQABsw4HQEMAAboDAAE+AQACvwYaAnAyAAIyBlCAALUAAFcAAPIAAMH6AgAAwfsCAADBPAIAAvYGMgAAMT0CAAL6BiIAADH/AgAAwvEGYgAAsvMGagAAsfUCAADC9wZsAACx+QIAAMH7CgAAwf0IAADB7gIAAJEAIT8CAABBAAEwAIAEBOMTBfV1mRYWJpdjExNV9fPmObZF91bndpbmRFIABAN19fY01MAU5UEF+tTB9FWhEMCkAAETlgAEZlaWdukVkfRUAAF28yMF9fc2mDABolTjk6Wi8yNGJaBR9FQAATHjZ6Wg9CAA5IU3QxMH9Vk1N0MTFsb2dpY7JaABAAAaszBhAAEjLbMwf9WgpQAH8ybGVuZ3RoIAAHcW91dF9vZl9XAA8gAAAeMxBbCiAAAyozDmEAAiAAFDTvYA4hAAEgAE41dW5kIQAGIAATNhVkI19hBjQKIAAXOL5WABAAFzkuXAEQAAm7ADVTdDkJAg+cKgISLAAsE0IIACKMFggAP1goANgqAiKEXBgAIhBnCAAijioIAC/mKjAAAxOWMAATzFgAE/ZYACoKKTAABHgFIsCrMHoTkAgAK2DxCAASvggAE/AIABPACAAiUL8IABPQCAAMAQATIDgEIyCsQAAPYAAUE+BQACIwwAgALkDBYAAJsD4SFdgAE2LoABMaCAATMAgAEwIQARM4CAAb+NB7EzIYABN+CAATKTgAH1GQAQQTMHAAE45gASNweXABGnkwABNAAAEj8Lk4AQMIAB+w0AAEE2AwACMwuiAAAwgAH8AwAAQTgDAAIoAeMC0TUAgAL+DQMAADBMgFIsAfKAATcAgAH/AwAAQUwGAAEyGAfh8hMAALFOBgABMoYAAfKDAACxMAeAYjQCooAB8pMAALEyAwACPAK2AAHyswAAsTQDAAIjAsKAATIAgALwDRgAEEAzAAIuAwKAAvkDBgAAsTgDAAI6AygAEfMjAACxOgMAAjIDTYfx8zgAEMBGAAEzVgAB81gAEMAzAAIvCWKAATwAgAL+DwgAEEBLAJE5cYAQMIAD/w8AIwfhqIBQQCBwQFAwZ8LxMGcD4fBd0YBxcCsz4A0xYTIFsYE4C3Fx82iC3/rjWAywQMABeoDAAxdMsE8gEQAfYB8BGwBAAQEAAALhEAAASwBAAwEQAAeREAAAywBACAEQAApnAt8AWwBACwFAAAzRQAACiwBADQFAAA7aqdwLAEAPAUAAAJFQAAaEgA8AUVAAAcFQAAcLAEACAVAAAhFQAAdFQAoBUAAI8VAAB4sAQsBoEAsxUAAICwBAgAcVEWAACEsAQIAHGMFgAAkLAECABwjRYAAJiwBOQFAEgHQQCcsAQIAPEE/RYAAKywBAD+FgAA3icAALywBAgAcRooAADUsAQIAFApKAAA2HgAEShEBkAA3LAE3AcAoAZBAOSwBAgAIKEondARBAgAcPUoAADwsASoB4AACSkAAPywBKwHIAArJRshsQQIAHE3KQAACLEECABxQykAAAyxBAgAcfwpAAAQsQQIAHFcKgAAMLEECABxjioAAFCxBAgAceYqAABYsQQIAPEEBysAAGixBAAIKwAAZisAAHCxBAgAccQrAAB4sQQIAHECLAAAgLEECABwQSwAAIyxBKwIgQByLAAAlLEECABxgywAAJyxBAgA8QQNLQAArLEEAA4tAABMLQAAxLEECABxFS4AANCxBAgAcSYuAADYsQQIAHG9LgAA4LEECABxEi8AAPCxBAgAcYkvAAD8sQQIAHH6LwAAHLIECABx7jAAACSyBAgA8QSjMQAAXLIEAKQxAADxWAAAcLIECABxE1kAAIiyBAgAcVxZAACQsgQIAHH7WQAAmLIECABxc1oAAKCyBAgAcbNaAADAsgQIAHEXWwAAxLIECABxdlsAAMyyBAgAcQJcAADUsgQIAHAyXAAA4LIERAgAKAhAAOyyBJgJgACVXAAA/LIEdAmBAMBcAAAEswQIAHGvXQAADLMECABxdF4AADCzBAgAcRBfAABYswQIAHHiYAAAfLMECABxpWEAALSzBAgAcZRiAADcswQIABAqfuwhswQIAHF4YwAACLQECABxW2QAABS0BAgAcdxlAABAtAQIAHAPZwAAhLQELAqBAOhsAAC0tAQIAHH1bAAAzLQECABxXm4AANC0BAgA8QQvcAAADLUEADBwAAA+cQAATLUECADwBE9xAABctQQAUHEAAG95AABstQToCIEAnHkAANy1BAgAccx5AADktQQIAPEE7XkAAOy1BADueQAABnoAAPS1BAgAcRx6AAD4tQQIAHEvegAA/LUECABxQHoAAAS2BAgA8QRZewAADLYEAFp7AACwfQAAQLYECABx7n0AAHi2BAgA8RCHgwAA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Az1wAsAkDAAcAh6C3AoPHAIFQwkMBgX8C1TABAMBUFw2cYBeAgCnXgJcNgAIABABeAYTMowBDBgBDzgYAR8AgBcIDCgCDoAMCowFDBwiD+gCBQ/QDgUMcAsP2BYBDwQMBg5MGQ8MAAYApAk0AZ8A6gAPsBo6D1QJDQ80AwEAKAIecsQHCTwHCGAACJgDDRwGEQHtjhABxnah1AYAAMQFAAA0BM3DEAH2ixPUwaEAMdchNAntlzYBAA0YABBUSdcAuaFTCAAANAcgABYLIAAidArVoSI0CBwACBQHBJADCwwYD/QABgXEFQuoARtiKAQEtBYXokAGAMQBFjJoCw4AAgOsJBdSkAIMNAAPEAAdALQLFkK0CxABxAoagsQKD0wFAg/oHCAPiBcGDgweDiAIDAAJDJABD4AGBkoHAA5iMDYJaAgHsAoB6AAb8ugADmAEA6QHHhGgNg/UEhUIEAMMoAQO7A8JSAAPAQAdF2T2eZdoEwUARAUFAIQUAKasFAUAZAUFAPQCFACm2BUFANQHBQA0BRQAb+gVBQAUCkJ6AxMkGAATPAgAG04oABNkEAATgggAE5AIABOkCAATtAgAE8IIABPSCAAT5ggAE/YIACIOCwgAEyAIABMyCAATSggAE1YIABNoCAATeggAE44IABOkCAATuAgAE84IABPkCAAT8ggAIgoMCAATGggAEzAIABNECAATVggAE3AIABOCCAATnAgAE7AIABPECAAT1AgAE+YIACICDQgAExYIABMqCAATQggAE1IIABNoCAATdggAE4wIABOeCAATqggAE7oIABPOCAAT8AgAE/4IACIODggAEyIIABM8CAATSggAE14IABNqCAATgAgAE5IIABOgCAATsAgAE8oIABPeCAAT8ggAIhAPCAATGAgAEygIABNACAATTAgAE1oIABNoCAATgggAE5IIABOgCAATsggAE8IIABPcCAAT8ggAIwgQcAAaEHACEyQQABM8CAATUggAE2gIABN4CAAThAgAE5IIABOkCAATuAgAE8IIABPQCAAT4ggAE+wIABP2CAAiAhEIABMSCAATHAgAEy4IABM4CAATQggAE1QIABNeCAATaggAE3YIABN+CAATiAgAE5AIABOaCAATpAgAE64IABO4CAATwggAE8wIABPUCAAT3AgAE+QIABPuCAAT9ggAIwAS+AID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"};
#endif

#if defined(_WIN32) && (!defined(_WIN64))  
char zsfx_mime64[]={"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"};
#endif

#if !defined(_WIN32)
///	Unix or Linux
char zsfx_mime64[]=
{"RVJST1I="};
#endif


int b64invs[] = { 62, -1, -1, -1, 63, 52, 53, 54, 55, 56, 57, 58,
	59, 60, 61, -1, -1, -1, -1, -1, -1, -1, 0, 1, 2, 3, 4, 5,
	6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20,
	21, 22, 23, 24, 25, -1, -1, -1, -1, -1, -1, 26, 27, 28,
	29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42,
	43, 44, 45, 46, 47, 48, 49, 50, 51 };

int ismime(char i_c)
{
	if ((i_c>='0') && (i_c<='9'))
		return 1;
	if ((i_c >='A') && (i_c<='Z'))
		return 1;
	if ((i_c>='a') && (i_c <= 'z'))
		return 1;
	if ((i_c=='+') || (i_c=='/') || (i_c =='='))
		return 1;
	return 0;
}

size_t mimesize(const char *i_input)
{
	if (i_input==NULL)
		return 0;

	size_t len;
	size_t ret;
	size_t i;

	len=strlen(i_input); // risky!
	ret=len/4*3;

	for (i=len; i-->0;) 
		if (i_input[i] == '=') 
			ret--;
		else 
			break;

	return ret;
}


int mime2binary(const char *i_in, unsigned char *o_out, size_t outlen)
{
	if (i_in==NULL)
		return 0;
	if (o_out==NULL)
		return 0;
		
	size_t lunghezza=strlen(i_in);
	if ((outlen<mimesize(i_in)) || (lunghezza % 4 != 0))
		return 0;
		
	for (unsigned int i=0; i<lunghezza; i++) 
		if (!ismime(i_in[i])) 
			return 0;
	
	size_t i;
	size_t j;
	int    temp;

	for (i=0,j=0;i<lunghezza;i+=4,j+=3) 
	{
		temp= b64invs[i_in[i]-43];
		temp= (temp << 6) | b64invs[i_in[i+1]-43];
		temp= i_in[i+2]=='=' ? temp << 6 : (temp << 6) | b64invs[i_in[i+2]-43];
		temp= i_in[i+3]=='=' ? temp << 6 : (temp << 6) | b64invs[i_in[i+3]-43];
		o_out[j] = (temp >> 16) & 0xFF;
		if (i_in[i+2] != '=')
			o_out[j+1] = (temp >> 8) & 0xFF;
		if (i_in[i+3] != '=')
			o_out[j+2] = temp & 0xFF;
	}
	return 1;
}




/*
	Section: lz4
*/

// //////////////////////////////////////////////////////////
// smallz4cat.c
// Copyright (c) 2016-2019 Stephan Brumme. All rights reserved.
// see https://create.stephan-brumme.com/smallz4/
//
// "MIT License":
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"),
// to deal in the Software without restriction, including without limitation
// the rights to use, copy, modify, merge, publish, distribute, sublicense,
// and/or sell copies of the Software, and to permit persons to whom the Software
// is furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//

#ifndef FALSE
#define FALSE 0
#define TRUE  1
#endif

/// error handler
static void unlz4error(const char* msg)
{
  // smaller static binary than fprintf(stderr, "ERROR: %s\n", msg);
  fputs("ERROR: ", stderr);
  fputs(msg,       stderr);
  fputc('\n',      stderr);
  exit(1);
}


typedef unsigned char (*GET_BYTE)  (void* userPtr);
typedef void          (*SEND_BYTES)(const unsigned char*, unsigned int, void* userPtr);

struct s_lz4parameter
{
	unsigned char*	source;		//my memory buffer
	FILE* out;
	unsigned int  	pos;		//readed so far
	unsigned int	size;
	unsigned int	extracted;	//written so far
	s_lz4parameter(): source(0), out(0), pos(0), size(0),extracted(0){};
}; 

/// read a single byte
static unsigned char getByteFromIn(void* userPtr) // parameter "userPtr" not needed
{
	/// cast user-specific data
	struct s_lz4parameter* user = (struct s_lz4parameter*)userPtr;
	return user->source[user->pos++];
}

/// write a block of bytes
static void sendBytesToOut(const unsigned char* data, unsigned int numBytes, void* userPtr)
{
  /// cast user-specific data
  struct s_lz4parameter* user = (struct s_lz4parameter*)userPtr;
  if (data != NULL && numBytes > 0)
	if (user->out != NULL)
	{
		size_t written=fwrite(data, 1, numBytes, user->out);
		user->extracted+=written;
	}
}


// ==================== LZ4 DECOMPRESSOR ====================


/// decompress everything in input stream (accessed via getByte) and write to output stream (via sendBytes)
void unlz4_userPtr(GET_BYTE getByte, SEND_BYTES sendBytes, void* userPtr)
{
  // signature
  unsigned char signature1 = getByte(userPtr);
  unsigned char signature2 = getByte(userPtr);
  unsigned char signature3 = getByte(userPtr);
  unsigned char signature4 = getByte(userPtr);
  unsigned int  signature  = (signature4 << 24) | (signature3 << 16) | (signature2 << 8) | signature1;
  unsigned char isModern   = (signature == 0x184D2204);
  unsigned char isLegacy   = (signature == 0x184C2102);
  if (!isModern && !isLegacy)
    unlz4error("invalid signature");

  unsigned char hasBlockChecksum   = FALSE;
  unsigned char hasContentSize     = FALSE;
  unsigned char hasContentChecksum = FALSE;
  unsigned char hasDictionaryID    = FALSE;
  if (isModern)
  {
    // flags
    unsigned char flags = getByte(userPtr);
    hasBlockChecksum   = flags & 16;
    hasContentSize     = flags &  8;
    hasContentChecksum = flags &  4;
    hasDictionaryID    = flags &  1;

    // only version 1 file format
    unsigned char version = flags >> 6;
    if (version != 1)
      unlz4error("only LZ4 file format version 1 supported");

    // ignore blocksize
    char numIgnore = 1;

    // ignore, skip 8 bytes
    if (hasContentSize)
      numIgnore += 8;
    // ignore, skip 4 bytes
    if (hasDictionaryID)
      numIgnore += 4;

    // ignore header checksum (xxhash32 of everything up this point & 0xFF)
    numIgnore++;

    // skip all those ignored bytes
    while (numIgnore--)
      getByte(userPtr);
  }

  // don't lower this value, backreferences can be 64kb far away
#define HISTORY_SIZE 64*1024
  // contains the latest decoded data
  unsigned char history[HISTORY_SIZE];
  // next free position in history[]
  unsigned int  pos = 0;

  // dictionary compression is a recently introduced feature, just move its contents to the buffer

  // parse all blocks until blockSize == 0
  while (1)
  {
    // block size
    unsigned int blockSize = getByte(userPtr);
    blockSize |= (unsigned int)getByte(userPtr) <<  8;
    blockSize |= (unsigned int)getByte(userPtr) << 16;
    blockSize |= (unsigned int)getByte(userPtr) << 24;

    // highest bit set ?
    unsigned char isCompressed = isLegacy || (blockSize & 0x80000000) == 0;
    if (isModern)
      blockSize &= 0x7FFFFFFF;

    // stop after last block
    if (blockSize == 0)
      break;

    if (isCompressed)
    {
      // decompress block
      unsigned int blockOffset = 0;
      unsigned int numWritten  = 0;
      while (blockOffset < blockSize)
      {
        // get a token
        unsigned char token = getByte(userPtr);
        blockOffset++;

        // determine number of literals
        unsigned int numLiterals = token >> 4;
        if (numLiterals == 15)
        {
          // number of literals length encoded in more than 1 byte
          unsigned char current;
          do
          {
            current = getByte(userPtr);
            numLiterals += current;
            blockOffset++;
          } while (current == 255);
        }

        blockOffset += numLiterals;

        // copy all those literals
        if (pos + numLiterals < HISTORY_SIZE)
        {
          // fast loop
          while (numLiterals-- > 0)
            history[pos++] = getByte(userPtr);
        }
        else
        {
          // slow loop
          while (numLiterals-- > 0)
          {
            history[pos++] = getByte(userPtr);

            // flush output buffer
            if (pos == HISTORY_SIZE)
            {
              sendBytes(history, HISTORY_SIZE, userPtr);
              numWritten += HISTORY_SIZE;
              pos = 0;
            }
          }
        }

        // last token has only literals
        if (blockOffset == blockSize)
          break;

        // match distance is encoded in two bytes (little endian)
        unsigned int delta = getByte(userPtr);
        delta |= (unsigned int)getByte(userPtr) << 8;
        // zero isn't allowed
        if (delta == 0)
          unlz4error("invalid offset");
        blockOffset += 2;

        // match length (always >= 4, therefore length is stored minus 4)
        unsigned int matchLength = 4 + (token & 0x0F);
        if (matchLength == 4 + 0x0F)
        {
          unsigned char current;
          do // match length encoded in more than 1 byte
          {
            current = getByte(userPtr);
            matchLength += current;
            blockOffset++;
          } while (current == 255);
        }

        // copy match
        unsigned int referencePos = (pos >= delta) ? (pos - delta) : (HISTORY_SIZE + pos - delta);
        // start and end within the current 64k block ?
        if (pos + matchLength < HISTORY_SIZE && referencePos + matchLength < HISTORY_SIZE)
        {
          // read/write continuous block (no wrap-around at the end of history[])
          // fast copy
          if (pos >= referencePos + matchLength || referencePos >= pos + matchLength)
          {
            // non-overlapping
            memcpy(history + pos, history + referencePos, matchLength);
            pos += matchLength;
          }
          else
          {
            // overlapping, slower byte-wise copy
            while (matchLength-- > 0)
              history[pos++] = history[referencePos++];
          }
        }
        else
        {
          // either read or write wraps around at the end of history[]
          while (matchLength-- > 0)
          {
            // copy single byte
            history[pos++] = history[referencePos++];

            // cannot write anymore ? => wrap around
            if (pos == HISTORY_SIZE)
            {
              // flush output buffer
              sendBytes(history, HISTORY_SIZE, userPtr);
              numWritten += HISTORY_SIZE;
              pos = 0;
            }
            // wrap-around of read location
            referencePos %= HISTORY_SIZE;
          }
        }
      }

      // all legacy blocks must be completely filled - except for the last one
      if (isLegacy && numWritten + pos < 8*1024*1024)
        break;
    }
    else
    {
      // copy uncompressed data and add to history, too (if next block is compressed and some matches refer to this block)
      while (blockSize-- > 0)
      {
        // copy a byte ...
        history[pos++] = getByte(userPtr);
        // ... until buffer is full => send to output
        if (pos == HISTORY_SIZE)
        {
          sendBytes(history, HISTORY_SIZE, userPtr);
          pos = 0;
        }
      }
    }

    if (hasBlockChecksum)
    {
      // ignore checksum, skip 4 bytes
      getByte(userPtr); getByte(userPtr); getByte(userPtr); getByte(userPtr);
    }
  }

  if (hasContentChecksum)
  {
    // ignore checksum, skip 4 bytes
    getByte(userPtr); getByte(userPtr); getByte(userPtr); getByte(userPtr);
  }

  // flush output buffer
  sendBytes(history, pos, userPtr);
}

/*
	Very, very advanced encryption here :-)
*/

void scambia(string& i_str)
{
    int n=i_str.length();
    for (int i=0;i<n/2;i++)
        std::swap(i_str[i],i_str[n-i-1]);
}
string ahahencrypt(string i_string)
{
	string risultato="";
	for (unsigned int i=0;i<i_string.size();i++)
        risultato+=i_string[i] ^33;
    return risultato;
}

///	decode the mime64 into memory (~150KB, not very big),
///	decompress by LZ4 (not very big ~300KB)
/// write into i_outfile
int Jidac::decompress_sfx_to_file(FILE* i_outfile)
{
	if (i_outfile==NULL)
		return 0;
		
	///	put down the zsfx.exe
	size_t 	zsfx_exe_len=mimesize(zsfx_mime64);
	char*	zsfx_exe;
	zsfx_exe=(char*)malloc(zsfx_exe_len);
	if (zsfx_exe==NULL)
	{
		printf("87420: error in malloc zsfx\n");
		return 0;
	}
	if (!mime2binary(zsfx_mime64,(unsigned char *)zsfx_exe,zsfx_exe_len)) 
	{
		printf("87425: mime decoder kaputt!\n");
		return 0;
	}
	
	// redundant, but better be sure
	struct s_lz4parameter user;
	user.source		=(unsigned char*)zsfx_exe;
	user.size		=zsfx_exe_len;
	user.out		=i_outfile;
	user.pos		=0;
	user.extracted	=0;
	// do the "magic"
	unlz4_userPtr(getByteFromIn,sendBytesToOut,&user);
	free(zsfx_exe);
	return user.extracted;
}
	

int Jidac::writesfxmodule(string i_filename)
{
#if defined(_WIN32)

	printf("\n\n*** GOING SFX\n");
	if (password!=NULL)
	{
		printf("64855: this kind of SFX-ZPAQ does NOT support encryption (yet)\n");
		return 1;
	}
	if (i_filename=="")
	{
		printf("75396: sfx filename empty\n");
		return 2;
	}
	int64_t dimensionezpaq=prendidimensionefile(archive.c_str());
	if (dimensionezpaq>2000000000)
	{
		printf("75411: ZPAQ archive size %s\n",migliaia(dimensionezpaq));
		printf("75412: max .EXE size 2.000.000.000, abort\n");
		return 2;
	}
	
	string g_franzo_start	="dnE3pipUzeiUo8BMxVKlQTIfLjmskQbhlqBobVVr";
	scambia(g_franzo_start);
	
	string g_franzo_end		="xzUpA6PsHSE0N5Xe4ctJ2Gz7QTNLDyOXAp4kiEOo";
	scambia(g_franzo_end);

	string i_thecommands="x pippo.zpaq";
	if (g_sfxto!="")
		i_thecommands+=" -to "+g_sfxto;
	
	if (g_sfxflagforce)
		i_thecommands+=" -force";
	
	if (g_sfxflagall)
		i_thecommands+=" -all";
	
	if (sfxnotfiles.size()>0)
	{
		i_thecommands+=" -not ";
		for (unsigned int i=0;i<sfxnotfiles.size();i++)
			i_thecommands+=sfxnotfiles[i]+' ';
	}
	
	if (sfxonlyfiles.size()>0)
	{
		i_thecommands+=" -only ";
		for (unsigned int i=0;i<sfxonlyfiles.size();i++)
			i_thecommands+=sfxonlyfiles[i]+' ';
	}
	
	if (g_sfxuntil!="")
		i_thecommands+=" -until "+g_sfxuntil;
	
	printf("Command line  : %s\n",i_thecommands.c_str());
	printf("Archive name  : %s\n",archive.c_str());
	printf("Output  name  : %s\n",i_filename.c_str());

	string outfile	=prendinomefileebasta(i_filename);
	string percorso	=extractfilepath(i_filename);
	outfile=percorso+outfile+".exe";
	
	if (fileexists(outfile))
		if (!flagforce)
		{
			printf("64890: output file exists and no -force, abort %s\n",outfile.c_str());
			return 2;
		}
		
	printf("Working on    : %s\n",outfile.c_str());

	std::wstring widename=utow(outfile.c_str());
	FILE* outFile=_wfopen(widename.c_str(), L"wb" );
	if (outFile==NULL)
	{
		printf("2017 :CANNOT OPEN outfile %s\n",outfile.c_str());
		return 2;
	}

	int zsfx_exe_len=decompress_sfx_to_file(outFile);
	if (zsfx_exe_len==0)
	{
		printf("38944: guru extracting sfx\n");
		fclose(outFile);
		exit(0);
	}
	
	size_t const 	blockSize = 65536;
	unsigned char 	buffer[blockSize];
	size_t 	readSize;
	
	/// yes, one byte at time. Why? Because some too smart compilers can substitute too much
	/// please note: the strings are already inverted 
	
	for (unsigned int i=0;i<g_franzo_start.size();i++)
		fwrite(&g_franzo_start[i],1,1,outFile);

	/// High security!
	string ahahaencrypted=ahahencrypt(i_thecommands);
	for (unsigned int i=0;i<i_thecommands.size();i++)
		///fwrite(&i_thecommands[i],1,1,outFile);
		fwrite(&ahahaencrypted[i],1,1,outFile);
	
	for (unsigned int i=0;i<g_franzo_end.size();i++)
		fwrite(&g_franzo_end[i],1,1,outFile);
	
	///	Now append the .zpaq. Please note: no handling for multipart (in fact, not too hard)
	FILE* inFile = freadopen(archive.c_str());
	if (inFile==NULL) 
	{
		int err=GetLastError();
		printf("\n2077: ERR <%s> on archive kind %d\n",archive.c_str(),err); 
		return 2;
	}
	
	while ((readSize = fread(buffer, 1, blockSize, inFile)) > 0) 
		fwrite(buffer,1,readSize,outFile);

	fclose(outFile);
	
	///	Just debug stuff
	printf("SFX written on: %s\n",outfile.c_str());
	printf("\n");
	int64_t sfxsize	=zsfx_exe_len;
	int64_t zpaqsize=prendidimensionefile(archive.c_str());
	int64_t sfxtotal=prendidimensionefile(outfile.c_str());
	
	printf("SFX module    : %19s\n",migliaia(sfxsize));
	printf("Block1        : %19s\n",migliaia(g_franzo_start.size()));
	printf("Command       : %19s\n",migliaia(i_thecommands.size()));
	printf("Block2        : %19s\n",migliaia(g_franzo_end.size()));
	printf("Start         :                      %s\n",migliaia(sfxsize+g_franzo_start.size()+i_thecommands.size()+g_franzo_end.size()));
	printf("ZPAQ archive  : %19s\n",migliaia(zpaqsize));

	printf("Expected      : %19s\n",migliaia(sfxsize+zpaqsize+g_franzo_start.size()+g_franzo_end.size()+i_thecommands.size()));
	printf("Written       : %19s\n",migliaia(sfxtotal));
#else
	printf("75371: sfx module supported only on Windows\n");
#endif
	return 0;
}

int Jidac::sfx()
{
	
#if defined(_WIN32)
	printf("Creating SFX module for archive ");
	printUTF8(archive.c_str());
	printf("\n");

	if (g_sfx!="")
	{
		writesfxmodule(g_sfx);
		return 0;
	}
	
	string outfile	=prendinomefileebasta(archive);
	string percorso	=extractfilepath(archive);
	outfile=percorso+outfile+".exe";
	
	if (fileexists(outfile))
		if (!flagforce)
		{
			printf("64979: output file exists and no -force, abort %s\n",outfile.c_str());
			return 2;
		}
	
	printf("Working on    : %s\n",outfile.c_str());

	std::wstring widename=utow(outfile.c_str());
	FILE* outFile=_wfopen(widename.c_str(), L"wb" );
	if (outFile==NULL)
	{
		printf("64989 :CANNOT OPEN outfile %s\n",outfile.c_str());
		return 2;
	}

	int zsfx_exe_len=decompress_sfx_to_file(outFile);
	if (zsfx_exe_len==0)
	{
		printf("39041: guru extracting sfx\n");
		fclose(outFile);
		exit(0);
	}
	fclose(outFile);

	///	Just debug stuff
	int64_t written=prendidimensionefile(outfile.c_str());
	if (written==zsfx_exe_len)
	{
		printf("SFX written   : %s bytes\n",migliaia(written));
		return 0;
	}
	
	printf("65006: something wrong: written %s expected %s\n",migliaia(written),migliaia2(zsfx_exe_len));
	return 2;
	
#else
	printf("64969: sfx module supported only on Windows\n");
#endif

	return 0;
}

/* 
more general resource-like extraction (future)
*/
int Jidac::decompress_mime64_to_file(FILE* i_outfile,const char* i_mime64)
{
	if (i_outfile==NULL)
		return 0;
	if (i_mime64==NULL)
		return 0;
		
	///	put down the file
	size_t 	the_exe_len=mimesize(i_mime64);
	char*	the_exe;
	the_exe=(char*)malloc(the_exe_len);
	if (the_exe==NULL)
	{
		printf("45953: error in malloc\n");
		return 0;
	}
	if (!mime2binary(i_mime64,(unsigned char *)the_exe,the_exe_len)) 
	{
		printf("45960: mime decoder kaputt!\n");
		return 0;
	}
	
	// redundant, but better be sure
	struct s_lz4parameter user;
	user.source		=(unsigned char*)the_exe;
	user.size		=the_exe_len;
	user.out		=i_outfile;
	user.pos		=0;
	user.extracted	=0;
	// do the "magic"
	unlz4_userPtr(getByteFromIn,sendBytesToOut,&user);
	free(the_exe);
	return user.extracted;
}


int Jidac::writeresource(string i_filename,bool i_force,const char* i_mime64)
{
#if defined(_WIN32)

	printf("\n\n*** WRITING RESOURCE\n");
	
	if (i_filename=="")
	{
		printf("45987: resource filename empty\n");
		return 2;
	}

	string outfile	=prendinomefileebasta(i_filename);
	string percorso	=extractfilepath(i_filename);
	outfile=percorso+outfile+".exe";

	printf("percorso %s\n",percorso.c_str());
	printf("outfile %s\n",outfile.c_str());
	
	if (fileexists(outfile))
		if (!i_force)
		{
			printf("46001: output file exists and no -force, abort %s\n",outfile.c_str());
			return 2;
		}
		
	printf("Working on    : %s\n",outfile.c_str());

	std::wstring widename=utow(outfile.c_str());
	FILE* outFile=_wfopen(widename.c_str(), L"wb" );
	if (outFile==NULL)
	{
		printf("46011 :CANNOT OPEN outfile %s\n",outfile.c_str());
		return 2;
	}

	int the_exe_len=decompress_mime64_to_file(outFile,i_mime64);
	if (the_exe_len==0)
	{
		printf("46018: guru extracting sfx\n");
		fclose(outFile);
		exit(0);
	}
	if (outFile!=NULL)
		fclose(outFile);
#else
	printf("46024: resource module supported only on Windows\n");
#endif
	return 0;
}




/*
	Section: verify and command w (chunked extraction)
	         running on pthread
*/


int Jidac::verify(bool i_readfile) 
{
	getpasswordifempty();

	flagforce		=true;
	flagtest		=true;
	summary			=1;
	bool myflagall	=all;
	
	all=false;
	if (i_readfile)
	{
		const int64_t sz=read_archive(archive.c_str());
		if (sz<1) 
			error("archive not found");
	}
	all=myflagall;	
	
	if (flagssd)
	myprintf("\nVerify hashes of one version vs filesystem (multithreaded)\n");
		else
	myprintf("\nVerify hashes of one version vs filesystem (1 thread, -ssd for multithread)\n");
	
	int 		checkedbyhash=0;
	uint64_t 	hashtotali=0;
	int			tobechecked=0;
	int			nohashfound=0;
	
	vector<string> 	myfiles;
	vector<string> 	myfilesoriginal;		//in fact redundant
	vector<string> 	myfilehash;
	vector<string> 	myalgo;
		
	for (DTMap::iterator p=dt.begin(); p!=dt.end(); ++p) 
		if (p->second.date && p->first!="") 
		{
			string finalfile=rename(p->first);
		
			if (!isdirectory(finalfile))
			if (p->second.size>0)
			if (finalfile!="VFILE-l-filelist.txt")
			{
				hashtotali+=p->second.size;
				tobechecked++;
				
				string myhashtype	="";
				string myhash		="";
				string mycrc32		="";
				
				decode_franz_block(false,p->second.franz_block,
					myhashtype,
					myhash,
					mycrc32);
					
				if (myhashtype!="")
				{
					MAPPACHECK::iterator a=g_mychecks.find(myhashtype);
		
					if (a!=g_mychecks.end())
					{
						if ((searchfrom!="") && (replaceto!=""))
							replace(finalfile,searchfrom,replaceto);
						myfiles.push_back(finalfile);
						myfilesoriginal.push_back(p->first);
						myfilehash.push_back(myhash);
						myalgo.push_back(myhashtype);
					}
					else
					{
						printf("39202: unknown algo |%s| for %s\n",myhashtype.c_str(),finalfile.c_str());
					}
				}
				else
					nohashfound++;
			}
		}

	unsigned int mythreads=howmanythreads;

	if (flagssd)
	{
		if (myfiles.size()<mythreads)
			mythreads=myfiles.size();
	}
	else
		mythreads=1;

	vector<tparametrihash> 	vettoreparametrihash;

	tparametrihash 	myblock;
	for (unsigned int i=0;i<mythreads;i++)
	{
		myblock.tnumber		=(i%mythreads);
		myblock.inizio		=mtime();
		myblock.dimensione	=hashtotali;
		myblock.timestart	=0;
		myblock.timeend		=0;
		vettoreparametrihash.push_back(myblock);
	}
	
	for (unsigned int i=0;i<myfiles.size();i++)
	{
		vettoreparametrihash[i%mythreads].filestobehashed.	push_back(myfiles[i]);
		vettoreparametrihash[i%mythreads].algo.				push_back(myalgo[i]);
		vettoreparametrihash[i%mythreads].filehash.			push_back(myfilehash[i]);
		vettoreparametrihash[i%mythreads].originalfilenames.push_back(myfilesoriginal[i]);

	}
	
	int totfile=0;
	for (unsigned int i=0;i<mythreads;i++)
	{
		if (flagdebug)
			printf("Thread [%02d] files %s\n",i,migliaia(vettoreparametrihash[i].filestobehashed.size()));
		totfile+=+vettoreparametrihash[i].filestobehashed.size();
	}
	
	int rc;
	pthread_t* threads = new pthread_t[mythreads];

	pthread_attr_t attr;
	void *status;

	pthread_attr_init(&attr);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_JOINABLE);

	if (!flagnoeta)
		printf("Total files %s -> in %03d threads -> %s to be checked\n",migliaia(myfiles.size()),mythreads,migliaia2(totfile));
	int64_t	startrunning=mtime();
	for(unsigned int i=0; i<mythreads; i++ ) 
	{
		vettoreparametrihash[i].timestart=mtime();
		rc = pthread_create(&threads[i], &attr, scansionahash, (void*)&vettoreparametrihash[i]);
		if (rc) 
		{
			printf("39264: Error creating thread\n");
			exit(-1);
		}
	}

	pthread_attr_destroy(&attr);
	for(unsigned int i=0; i <mythreads; i++ ) 
	{
		rc = pthread_join(threads[i], &status);
		if (rc) 
		{
			error("39275: Unable to join\n");
			exit(-1);
		}
	}
	if (flagverbose)
		printf("Scan done, preparing report...\n");
	
///	printf("k1\n");
	for(unsigned int i=0;i<mythreads;i++)
		for (unsigned int j=0;j<vettoreparametrihash[i].filestobehashed.size();j++)
		{
			string finalfile		=vettoreparametrihash[i].filestobehashed[j];
			string myhashtype		=vettoreparametrihash[i].algo[j];
	///		printf("k2 skkkkkkkkkkkkkk |%s|\n",myhashtype.c_str());
			if (myhashtype=="")
			{
				nohashfound++;
				if (flagverbose)
					printf("44039: NO hashtype %s\n",finalfile.c_str());
			}
			else
			{
				MAPPACHECK::iterator a	=g_mychecks.find(myhashtype);
				
				if (a!=g_mychecks.end())
				{
					checkedbyhash++;
					if (vettoreparametrihash[i].o_hashcalculated[j]=="")
					{
						if (flagverbose || (g_output!=""))
							myprintf("FILE NOT FOUND on %s: FILE %s\n",myhashtype.c_str(),finalfile.c_str());
						a->second.checkednotfound++;
					}
					else
					{
						if (vettoreparametrihash[i].o_hashcalculated[j]==vettoreparametrihash[i].filehash[j])
						{
							if (flagdebug)
								printf("GOOD %s:  STORED == FROM FILE %s\n",myhashtype.c_str(),finalfile.c_str());
							a->second.checkedok++;
							
						///	Getting the filesize is slow (very slow on network), then waste some RAM
						///  a->second.checksize+=prendidimensionefile(finalfile.c_str());
							DTMap::iterator p=dt.find(vettoreparametrihash[i].originalfilenames[j]);
							if (p!=dt.end())
								a->second.checksize+=p->second.size; 
							else
							{
								if (flagdebug)
									printf("38931: Cannot find originalfilename %s\n",vettoreparametrihash[i].originalfilenames[j].c_str());
							}
						}
						else
						{
							if (flagverbose || (g_output!=""))
							{
								myprintf("ERROR on %s: STORED HASH %s VS %s IN FILE ",myhashtype.c_str(),vettoreparametrihash[i].filehash[j].c_str(),vettoreparametrihash[i].o_hashcalculated[j].c_str());
								printUTF8(finalfile.c_str());
								myprintf("\n");
							}
							a->second.checkedfailed++;
						}
					}
				}
				else
				{
					nohashfound++;
					if (flagverbose)
						printf("26620: algo unknown (or no algo!) %s\n",finalfile.c_str());
				}
			}
		}

	
	///		write the results (if any)
	int risultato=0;
	bool outsomething=(nohashfound>0);
	
	if (nohashfound>0)
		risultato=1;
		
	for (MAPPACHECK::iterator p=g_mychecks.begin(); p!=g_mychecks.end(); ++p) 
		outsomething |= (p->second.checkedok+p->second.checkedfailed+p->second.checkednotfound);

	if (outsomething)
	{
		morebar('-');
		int64_t	byteshashed=0;
		for (MAPPACHECK::iterator p=g_mychecks.begin(); p!=g_mychecks.end(); ++p) 
		{
			byteshashed+=p->second.checksize;
			if (p->second.checkedok)
				myprintf("OK   %8s : %08d of %08d (%12s hash check against file on disk)\n",p->first.c_str(),p->second.checkedok,tobechecked,tohuman(p->second.checksize));
			if (p->second.checkedfailed)
			{
				myprintf("FAIL %8s : %08d of %08d (   FAILED    hash check against file on disk)\n",p->first.c_str(),p->second.checkedfailed,tobechecked);
				risultato=2;
			}
			if (p->second.checkednotfound)
			{
				myprintf("WARN %8s : %08d of %08d (file not found, cannot check hash)\n",p->first.c_str(),p->second.checkednotfound,tobechecked);
				if (risultato!=2)
					risultato=1;
			}
		}
		if (nohashfound)
			myprintf("UNKNOWN/NOHASH: %08d of %08d (legacy 7.15 archive?)\n",nohashfound,tobechecked);
		morebar('-');
		if (flagverbose)
		printf("Total hashed bytes %s @ %s B/s\n",migliaia((uint64_t)byteshashed),migliaia2((uint64_t)(byteshashed/((mtime()-startrunning)/1000.0))));
	}
	///	not really necessary, but...
	delete [] threads;
	return risultato;
}





void Jidac::handleflaglongpath()
{ 
#ifdef _WIN32
	if (!flaglongpath)
			return;
		
/// check if some kind of UNC Windows path \\franzk\pippo\..., turn OFF flaglongpath
	for (unsigned int i=0;i<tofiles.size();i++)
	{
		if (islonguncpath(tofiles[i]))
		{
			printf("44480: error, cannot work on explicit UNC -to\n");
			error("explicit UNC -to");
		}
		if (iswindowsunc(tofiles[i]))
		{
			printf("44485: found UNC Windows, incompatible with -longpath, turning OFF %s\n",tofiles[i].c_str());
			flaglongpath=false;
			break;
		}
	}
	
	for (DTMap::iterator p=dt.begin(); p!=dt.end(); ++p) 
		if (iswindowsunc(p->first))
		{
			printf("44495: found UNC Windows, incompatible with -longpath, turning OFF %s\n",p->first.c_str());
			flaglongpath=false;
			break;
		}

	if (flaglongpath)
		if (tofiles.size()>0)
		{
			for (unsigned int i=0;i<tofiles.size();i++)
				if (!islongpath(tofiles[i]))
					tofiles[i]="//?/"+tofiles[i];
			if (flagverbose || flagdebug)
				printf("44505: INFO: setting Windows' long filenames\n");
			if (flagdebug)
				for (unsigned int i=0;i<tofiles.size();i++)
					printf("44508: tofiles %d %s\n",i,tofiles[i].c_str());
		}
#endif
}	
	
int Jidac::extractw() 
{
	printf("**** CHUNKED EXTRACTION/TEST ****\n");
	if (flagverify && flagtest)
	{
		printf("44477: -verify and -test incompatible (-test does not write on disk)\n");
		printf("44477: maybe you mean -test -checksum ?\n");
		return 1;
	}
	if (!flagtest)
		if (tofiles.size()!=1)
		{
			printf("42845: you need exactly one -to\n");
			return 2;
		}
	
	if (flagparanoid && !flagverify)
	{
		printf("44059: WARNING -paranoid without -verify: ignored\n");
		flagparanoid=false;
	}

	
	
	/// transform -tofiles on WIN32 (if neeeded)
	handleflaglongpath();
	
	string outputdirectory="";
	
	if (flagtest)
		tofiles.push_back("K:/dummy/");
	else
	{
		if (!isdirectory(tofiles[0]))
			tofiles[0]+='/';
		outputdirectory=tofiles[0];
		
		uint64_t tofoldersize=0;
		uint32_t tofoldernumber=0;
		uint32_t tofolderfolder=0;
		if (getfoldersize(tofiles[0],tofoldersize,tofoldernumber,tofolderfolder))
			if (tofoldersize>0)
			{
				printf("42854: WARNING the folder <<");
				printUTF8(tofiles[0].c_str());
				printf(">> already contain %s bytes\n\n\n",migliaia(tofoldersize));		
				if (!getcaptcha("deleteall","Data can be overwritten, use EMPTY folder!"))
					return 1;
			}
	}

	///if (flagverify)
	if (flagverify && flagparanoid)
		tofiles[0]+="zfranz/";

	
	getpasswordifempty();
	g_scritti		=0;
	int	errors		=0;
	int64_t sz=read_archive(archive.c_str(),&errors);
	if (sz<1) 
		error("44504: archive not found");
	
	for (unsigned i=0; i<block.size(); ++i) 
	{
		if (block[i].bsize<0) 
			error("negative block size");
		if (block[i].start<1) 
			error("block starts at fragment 0");
		if (block[i].start>=ht.size()) 
			error("block start too high");
		if (i>0 && block[i].start<block[i-1].start) 
			error("unordered frags");
		if (i>0 && block[i].start==block[i-1].start) 
			error("empty block");
		if (i>0 && block[i].offset<block[i-1].offset+block[i-1].bsize)
		  error("unordered blocks");
		if (i>0 && block[i-1].offset+block[i-1].bsize>block[i].offset)
		  error("overlapping blocks");
	}

	int64_t	totalarchive=0;
	
	vector <s_fileandsize> fileandsize;
	vector <s_fileandsize> chunkfile;
	
	for (DTMap::iterator p=dt.begin(); p!=dt.end(); ++p) 
		if (!isdirectory(p->first))
				if (p->second.size>0)
				{
					totalarchive+=p->second.size;
					
					string myhashtype	="";
					string myhash		="";
					string mycrc32		="";
				
					decode_franz_block(false,p->second.franz_block,
					myhashtype,
					myhash,
					mycrc32);
					MAPPACHECK::iterator a=g_mychecks.find(myhashtype);
					
					s_fileandsize myblock;
					myblock.filename	=p->first;
					myblock.size		=p->second.size;
					myblock.attr		=p->second.attr;
					myblock.date		=p->second.date;
					myblock.data		=p->second.data;
					myblock.isdir		=isdirectory(p->first);
					if (a!=g_mychecks.end())
					{
						myblock.hashtype=myhashtype;
						myblock.hashhex=myhash;
						myblock.flaghashstored=true;
					}
					else
						myblock.flaghashstored=false;
					fileandsize.push_back(myblock);
				}
	sort(fileandsize.begin(),fileandsize.end(),comparefilenamesize);

	int64_t biggestfile=fileandsize[fileandsize.size()-1].size*1.1;
	if (flagverbose)
		printf("Minimum needed  (+10%%) %21s %s\n",migliaia(biggestfile),fileandsize[fileandsize.size()-1].filename.c_str());
	
	int64_t freediskspace=0;
	int64_t	freeramdisk=0;
	if (flagramdisk)
	{
		freeramdisk=getramdisksize()*75/100;
		if (flagverbose)
			printf("Free RAM (-25%%)        %21s (as reported by OS)\n",migliaia(freeramdisk));
	}
	
	if (flagtest)
		freediskspace=totalarchive;
	else
	{
		if (tofiles.size()>0) //really extract
		{
			freediskspace=getfreespace(outputdirectory)*90/100;
			/// overall free space, for extract WITHOUT chunk (paranoid)
			if (!flagspace)
			{
				if (flagverbose)
					printf("Free work space (-10%%) %21s on <<-to %s>>\n",migliaia(freediskspace),outputdirectory.c_str());
				if (! (flagverify && flagparanoid))
					if (freediskspace<totalarchive)
					{
						printf("41173: free space too small %s, at least %s (bypass with -space)\n",migliaia(freediskspace),migliaia2(totalarchive+1));
						return 1;
					}
			}
		}
	}
	
	int64_t spazio=0;
	
	if (flagramdisk)
		spazio=freeramdisk;
	else
		spazio=freediskspace;
	
	if (maxsize>0)
		spazio=maxsize;
	
	if (flagfrugal)
		spazio=biggestfile;
	
	///printf("Spazioooo %s\n",migliaia(spazio));

	unsigned		int	chunkscount	=0;
	int64_t			chunkcorrente	=0;
	unsigned int 	indice			=0;

	string	initialtofiles=tofiles[0];
	char	chunksbuffer[10];
	chunkfiles.clear();

//	count the chunks in advance
	int	quantichunk=0;
	while (indice<fileandsize.size())
		if ((chunkcorrente+(int64_t)fileandsize[indice].size)>spazio)
		{
			chunkcorrente=0;
			quantichunk++;
		}
		else
		{
			chunkcorrente+=fileandsize[indice].size;
			indice++;
		}

	quantichunk++;
	
	if (spazio>totalarchive)
			spazio=totalarchive;
	printf("Chunks %04d x          %21s (total decompressed size %s)\n",quantichunk,migliaia(spazio),migliaia2(totalarchive));

	if (!flagspace)
		if (!flagtest)
		{
			if (spazio<biggestfile)
			{
				printf("41165: chunk size (-maxsize) too small %s, at least %s needed (bypass with -space)\n",migliaia(spazio),migliaia2(biggestfile+1));
				return 1;
			}
			if (tofiles.size()>0)
				if (freediskspace<spazio)
				{
					printf("41173: free disk space too small %s, at least %s (bypass with -space)\n",migliaia(freediskspace),migliaia2(spazio+1));
					return 1;
				}
		}

	if ((!flagtest) && (!(flagverify && flagparanoid)))
	{
		if (flagverbose)
		{
			print_datetime();
			printf("44567: creating folders tree and zero-bytes files\n");
		}
		for (DTMap::iterator p=dt.begin(); p!=dt.end(); ++p) 
		{
			string thefolder=rename(p->first);
			if (isdirectory(thefolder))
				makepath(thefolder,p->second.date,p->second.attr);
			else
			{
				if (p->second.size==0)
				{
					FILE* myfile=fopen(thefolder.c_str(), "wb");
					fclose(myfile);
					close(thefolder.c_str(),p->second.data,p->second.attr);
				}
			}
		}
		if (flagverbose)
		{
			print_datetime();
			printf("44574: end\n");
		}
	}	


	///printf("Total chunks           %21s (please be patient!)\n",migliaia(quantichunk));
	
//	reset and start from scratch
	indice=0;
	chunkcorrente=0;
	int	chunkinlavorazione=1;
	while (indice<fileandsize.size())
		if ((chunkcorrente+(int64_t)fileandsize[indice].size)>spazio)
		{
			printbar('=');
			
			errors+=extractqueue2(chunkscount,quantichunk);
			
			if (flagverify)
				errors+=multiverify(chunkfile);

			if (errors==0)
			printf("Stage XTR %04d : errors  %d (0=good)\n",chunkinlavorazione,errors);
			else
			printf("Stage XTR %04d : errors  %d (0=good) *** NOT GOOD ***\n",chunkinlavorazione,errors);
			
			chunkcorrente=0;
			chunkscount++;
			chunkfile.clear();
			chunkfiles.clear();
			chunkinlavorazione++;
		}
		else
		{
			if (flagverify && flagparanoid)	// split the output in different dirs
			{
				sprintf(chunksbuffer,"%08d",chunkscount);
				tofiles[0]=initialtofiles+chunksbuffer+"/";
			}
			else
				tofiles[0]=initialtofiles;
				
			chunkcorrente+=fileandsize[indice].size;
			string fn=fileandsize[indice].filename;
			if (!isdirectory(fn))
			{
				string writtenfilename=rename(fn);
				fileandsize[indice].writtenfilename=writtenfilename;
				chunkfile.push_back(fileandsize[indice]);
				chunkfiles.push_back(fn);
				indice++;
			}
		}
	
	printbar('=');
	/// finalize "spare" chunk
			
	errors+=extractqueue2(chunkscount,quantichunk);
	
	if (flagverify)
		errors+=multiverify(chunkfile);
	
	if (errors==0)
		printf("Stage VEF %04d : errors  %d (0=good)\n",chunkinlavorazione,errors);
	else
		printf("Stage VEF %04d : errors  %d (0=good) *** NOT GOOD ***\n",chunkinlavorazione,errors);

	printbar('=');

	if (flagverify && flagparanoid)
			if (!removetempdirifempty(outputdirectory,true))
				errors++;
	return errors>0;
}


bool Jidac::removetempdirifempty(string i_folder,bool i_deleteifsizezero=false)
{
	if (flagdebug)
		printf("\n44385 removetempdirifempty on %s\n",i_folder.c_str());
		
	if (i_folder=="")
		return false;
	
	if (isdirectory(i_folder))
		i_folder=i_folder.substr(0,i_folder.size()-1);
	
	if (flagdebug)
		printf("\n44394 ready on %s\n",i_folder.c_str());
	
	if (!direxists(i_folder))
	{
		printf("\nFolder does not exist? ");
		printUTF8(i_folder.c_str());
		printf("\n");
		return false;
	}
	
	
	if (flagdebug)
		printf("\n44406 removeemptydirs on %s\n",i_folder.c_str());
	
	removeemptydirs(i_folder,true);


	uint64_t 		totalsize=0;
	unsigned int 	totalfile=0;
	unsigned int 	totaldir=0;
	bool 			somefile=false;
	
	if (flagdebug)
		printf("\n44417 getfoldersize on %s\n",i_folder.c_str());
	
	getfoldersize(i_folder,totalsize,totalfile,totaldir);
	if (flagdebug)
	{
		printf("43308: files %s folders %s size %s ",migliaia(totalfile),migliaia2(totaldir),migliaia3(totalsize));
		
		if ((totalfile==0) && (totalsize==0))
			printf("THIS IS GOOD");
		else
			printf("*** SOMETHING HERE ***");
		
		printf("\n");
	}
	
	if (totalfile)			// houston, we have a file, do nothing
		somefile=true;
		
	if (totalsize>0)		// houston, we have some byte, do nothing
		somefile=true;
		
	if (totalsize==0) 		// if only empty file, and forced, delete
		if (i_deleteifsizezero)
			somefile=false;
		
	if (somefile)
	{
		printf("41279: some files founded in %s, do nothing\n",i_folder.c_str());
	}
	else
	{
		if (flagverbose)
		{
			printf("44445: No files found (this is good): deleting everything in <<");
			printUTF8(i_folder.c_str());
			printf(">>\n");
		}
		return stermina(i_folder,totalfile); 
	}
	return false;
}

int Jidac::multiverify(vector <s_fileandsize>& i_arrayfilename)
{
	printf("VERIFY (=re-read from filesystem) and compare hashes\n");
	
	
	/* reset global */
	g_dimensione=0;
	for (MAPPACHECK::iterator p=g_mychecks.begin(); p!=g_mychecks.end(); ++p) 
	{
		p->second.checkedok			=0;
		p->second.checkedfailed		=0;
		p->second.checkednotfound	=0;
	}
	
	int 		checkedbyhash	=0;
	uint64_t 	hashtotali		=0;
	int			nohashfound		=0;
	
	vector<string> 	myfiles;
	vector<string> 	myfilehash;
	vector<string> 	myfilesoriginal;		//in fact redundant
	vector<string> 	myalgo;
	
	for (unsigned int i=0;i<i_arrayfilename.size();i++)
		if (i_arrayfilename[i].hashhex!="")
		{
			myfiles			.push_back(i_arrayfilename[i].writtenfilename);
			myfilesoriginal	.push_back(i_arrayfilename[i].filename);
			myfilehash		.push_back(i_arrayfilename[i].hashhex);
			myalgo			.push_back(i_arrayfilename[i].hashtype);
			hashtotali+=i_arrayfilename[i].size;
		}
	
	unsigned int mythreads=howmanythreads;

	if (flagssd)
	{
		if (myfiles.size()<mythreads)
			mythreads=myfiles.size();
	}
	else
		mythreads=1;

	vector<tparametrihash> 	vettoreparametrihash;

	tparametrihash 	myblock;
	for (unsigned int i=0;i<mythreads;i++)
	{
		myblock.tnumber		=(i%mythreads);
		myblock.inizio		=mtime();
		myblock.dimensione	=hashtotali;
		myblock.timestart	=0;
		myblock.timeend		=0;
		vettoreparametrihash.push_back(myblock);
	}
	
	for (unsigned int i=0;i<myfiles.size();i++)
	{
		vettoreparametrihash[i%mythreads].filestobehashed.	push_back(myfiles[i]);
		vettoreparametrihash[i%mythreads].algo.				push_back(myalgo[i]);
		vettoreparametrihash[i%mythreads].filehash.			push_back(myfilehash[i]);
		vettoreparametrihash[i%mythreads].originalfilenames.push_back(myfilesoriginal[i]);
	}
	
	int totfile=0;
	for (unsigned int i=0;i<mythreads;i++)
	{
		if (flagdebug)
			printf("Thread [%02d] files %s\n",i,migliaia(vettoreparametrihash[i].filestobehashed.size()));
		totfile+=+vettoreparametrihash[i].filestobehashed.size();
	}
	
	int rc;
	pthread_t* threads = new pthread_t[mythreads];

	pthread_attr_t attr;
	void *status;

	pthread_attr_init(&attr);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_JOINABLE);

	if (flagverbose)
		printf("Total files %s -> in %03d threads -> %s to be checked\n",migliaia(myfiles.size()),mythreads,migliaia2(totfile));
	int64_t	startrunning=mtime();
	for(unsigned int i=0; i<mythreads; i++ ) 
	{
		vettoreparametrihash[i].timestart=mtime();
		rc = pthread_create(&threads[i], &attr, scansionahash, (void*)&vettoreparametrihash[i]);
		if (rc) 
		{
			printf("39264: Error creating thread\n");
			exit(-1);
		}
	}

	pthread_attr_destroy(&attr);
	for(unsigned int i=0; i <mythreads; i++ ) 
	{
		rc = pthread_join(threads[i], &status);
		if (rc) 
		{
			error("39275: Unable to join\n");
			exit(-1);
		}
	}
	
	for(unsigned int i=0;i<mythreads;i++)
		for (unsigned int j=0;j<vettoreparametrihash[i].filestobehashed.size();j++)
		{
			string finalfile		=vettoreparametrihash[i].filestobehashed[j];
			string myhashtype		=vettoreparametrihash[i].algo[j];
			MAPPACHECK::iterator a	=g_mychecks.find(myhashtype);
			
			
			if (myhashtype=="")
			{
				nohashfound++;
				if (flagverbose)
					printf("44695: NO hashtype %s\n",finalfile.c_str());
			}
			else
			{
			if (a!=g_mychecks.end())
			{
				checkedbyhash++;
				if (vettoreparametrihash[i].o_hashcalculated[j]=="")
				{
					if (flagverbose || (g_output!=""))
					{
						myprintf("FILE NOT FOUND on %s: FILE ",myhashtype.c_str());
						printUTF8(finalfile.c_str());
						myprintf("\n");

					}
					a->second.checkednotfound++;
				}
				else
				{
					if (vettoreparametrihash[i].o_hashcalculated[j]==vettoreparametrihash[i].filehash[j])
						{
							if (flagdebug)
								printf("GOOD %s:  STORED == FROM FILE %s\n",myhashtype.c_str(),finalfile.c_str());
							a->second.checkedok++;
						///	Getting the filesize is slow (very slow on network), then waste some RAM
						///  a->second.checksize+=prendidimensionefile(finalfile.c_str());
							DTMap::iterator p=dt.find(vettoreparametrihash[i].originalfilenames[j]);
							if (p!=dt.end())
								a->second.checksize+=p->second.size; 
							else
							{
								if (flagdebug)
									printf("38931: Cannot find originalfilename %s\n",vettoreparametrihash[i].originalfilenames[j].c_str());
							}
						}
						else
						{
							if (flagverbose || (g_output!=""))
							{
								myprintf("ERROR on %s: STORED HASH %s VS %s IN FILE ",myhashtype.c_str(),vettoreparametrihash[i].filehash[j].c_str(),vettoreparametrihash[i].o_hashcalculated[j].c_str());
								printUTF8(finalfile.c_str());
								myprintf("\n");
							}
							a->second.checkedfailed++;
						}
					}
				}
				else
				{
	///				printf("BOIONEEEEE %s\n",finalfile.c_str());
					nohashfound++;
					if (flagverbose)
						printf("44750: algo unknown (or no algo!) %s\n",finalfile.c_str());
				}
				
			}
		}

	
	///		report the results (if any)
	int risultato=0;
	bool outsomething=(nohashfound>0);
	
	if (nohashfound>0)
		risultato=1;
		
	for (MAPPACHECK::iterator p=g_mychecks.begin(); p!=g_mychecks.end(); ++p) 
		outsomething |= (p->second.checkedfailed+p->second.checkednotfound);
	
	if (flagverbose)
		outsomething=true;
	
	if (outsomething)
	{
		if (!flagverbose)
			printf("\n");
		morebar('-');
		int64_t	byteshashed=0;
		for (MAPPACHECK::iterator p=g_mychecks.begin(); p!=g_mychecks.end(); ++p) 
		{
			byteshashed+=p->second.checksize;
			if (p->second.checkedok)
				if (flagverbose)
					printf("OK   %8s : %08d of %08d (%12s hash check against file on disk)\n",p->first.c_str(),p->second.checkedok,(int)myfiles.size(),tohuman(p->second.checksize));
			if (p->second.checkedfailed)
			{
				myprintf("FAIL %8s : %08d of %08d (   FAILED    hash check against file on disk) ***\n",p->first.c_str(),p->second.checkedfailed,myfiles.size());
				risultato=2;
			}
			if (p->second.checkednotfound)
			{
				myprintf("WARN %8s : %08d of %08d (file not found, cannot check hash)\n",p->first.c_str(),p->second.checkednotfound,myfiles.size());
				if (risultato!=2)
					risultato=1;
			}
		}
		if (nohashfound)
			myprintf("UNKNOWN/NOHASH: %08d of %08d (legacy 7.15 archive?)\n",nohashfound,myfiles.size());
		morebar('-');
		if (flagverbose)
			printf("Total hashed bytes %s @ %s B/s\n",migliaia((uint64_t)byteshashed),migliaia2((uint64_t)(byteshashed/((mtime()-startrunning)/1000.0))));
	}
	
	delete [] threads;
	///printf("=========== > risultato  %d\n",risultato);
	
	if (flagverify)
		if (flagparanoid) 
		{
			if (flagdebug)
				printf("44950: -paranoid, deleting files with OK matches\n");
			bool	alldeleted=true;
			
			uint32_t	tobedeleted=0;
			for(unsigned int i=0;i<mythreads;i++)
				tobedeleted+=vettoreparametrihash[i].filestobehashed.size();
			
			uint32_t	testati=0;
			int			percentualestampata=0;

			printf("Purging ");
			
			for(unsigned int i=0;i<mythreads;i++)
				for (unsigned int j=0;j<vettoreparametrihash[i].filestobehashed.size();j++)
				{
					testati++;
					int percentuale=(int)(100.0*testati/tobedeleted);
					if ((percentuale %10 ==0))
					if (percentuale!=percentualestampata)
					{
						//printf("Purging %02d %\r",percentuale);
						printf("%d ",percentuale);
					percentualestampata=percentuale;
					}
					if (vettoreparametrihash[i].o_hashcalculated[j]!="")
					{
						if (vettoreparametrihash[i].o_hashcalculated[j]==vettoreparametrihash[i].filehash[j])
						{	
///printf("scancello %s\n",vettoreparametrihash[i].filestobehashed[j].c_str());
					
							if (!delete_file(vettoreparametrihash[i].filestobehashed[j].c_str()))
							{
								if (flagverbose || (g_output!=""))
								{
									myprintf("45256: cannot delete ");
									printUTF8(vettoreparametrihash[i].filestobehashed[j].c_str());
									myprintf("\n");
								}
								alldeleted=false;
							}
						}
						else
						{
						alldeleted=false;
						if (flagverbose)
						{
							printf("44697: NON DELETED ");
							printUTF8(vettoreparametrihash[i].filestobehashed[j].c_str());
							printf("\n");
						}
						}
					}
					else
						alldeleted=false;
				}
			printf("\r");
			printbar(' ',false);
			printf("\r");
			if (flagverbose)
				if (!alldeleted)
				{
					printf("MMMMMMMMMMMMMMMMMMMMMMMMMMMMM\n");
					printf("MMMMMMMMMMMMMMMMMMMMMMMMMMMMM\n");
					printf("MMMMMMMMMMMMMMMMMMMMMMMMMMMMM\n");
					printf("MMMMMMMM  GURUUUU  MMMMMMMMMM\n");
					printf("MMMMMMMMMMMMMMMMMMMMMMMMMMMMM\n");
					printf("MMMMMMMMMMMMMMMMMMMMMMMMMMMMM\n");
					printf("MMMMMMMMMMMMMMMMMMMMMMMMMMMMM\n");
				}
			
			if (flagverbose)
				printf("44667: removing temp dir (if empty) %s\n",tofiles[0].c_str());
			
			if (!removetempdirifempty(tofiles[0],false))
			{
				if (flagverbose)
				{
					printf("44719: something left in ");
					printUTF8(tofiles[0].c_str());
					printf("\n");
				}
				risultato++;
			}
			else
			{
				if (flagdebug)
				{
					printf("44732: folder removed ");
					printUTF8(tofiles[0].c_str());
					printf("\n");
				}
			}
		}
	///printf("$$$$$$$$$$$$$$$$$$$$$$$$\n");
	return risultato;
}



int Jidac::extractqueue2(int i_chunk,int i_chunksize)
{
	if (i_chunk<0)
	{
		printf("44664: chunk must be >=0\n");
		return 0;
	}
	if (chunkfiles.size()==0)
	{
		printf("44669: WARN: chunfiles.size == 0\n");
		return 0;
	}

	vector<Block> preblock=block;      			// this takes me about 3 full day of old-school debugging
	
	/// a mandatory sort (for binary_search)
	sort(chunkfiles.begin(),chunkfiles.end()); // for binary search instead of .find

	int	errors		=0;
	int total_files	=0;
	int filesinchunk=0;
	
	ExtractJob job(*this);

	for (DTMap::iterator p=dt.begin(); p!=dt.end(); ++p) 
	{
		p->second.data=-1;  // skip by default
		if (std::binary_search(chunkfiles.begin(), chunkfiles.end(), p->first)) 
		{
			string fn=rename(p->first);
			string dummy="";
			if (block.size()>0)  
			{  // files to decompress
				filesinchunk++;
				p->second.data=0;
				unsigned lo=0, hi=block.size()-1;  // block indexes for binary search
				for (unsigned i=0; p->second.data>=0 && i<p->second.ptr.size(); ++i) 
				{
					unsigned j=p->second.ptr[i];  // fragment index
					if (j==0 || j>=ht.size() || ht[j].usize<-1) 
					{
						fflush(stdout);
						printUTF8(p->first.c_str(), stderr);
						fprintf(stderr, ": bad frag IDs, skipping...\n");
						p->second.data=-1;  // skip
						continue;
					}
					assert(j>0 && j<ht.size());
					if (lo!=hi || lo>=block.size() || j<block[lo].start
						|| (lo+1<block.size() && j>=block[lo+1].start)) 
					{
						lo=0;  // find block with fragment j by binary search
						hi=block.size()-1;
						while (lo<hi) 
						{
							unsigned mid=(lo+hi+1)/2;
							assert(mid>lo);
							assert(mid<=hi);
							if (j<block[mid].start) 
								hi=mid-1;
							else 
							(lo=mid);
						}
					}
					assert(lo==hi);
					assert(lo>=0 && lo<block.size());
					assert(j>=block[lo].start);
					assert(lo+1==block.size() || j<block[lo+1].start);
					unsigned c=j-block[lo].start+1;
					if (block[lo].size<c) block[lo].size=c;
					if (block[lo].files.size()==0 || block[lo].files.back()!=p)
						block[lo].files.push_back(p);
				}
				++total_files;
				job.total_size+=p->second.size;
				
				/// w extract only on EMPTY folder (for speed)
				/*
				if (fileexists(fn))
				{
					if (flagverbose)
					{
						printf("* ");
						printUTF8(fn.c_str());
						printf("\n");
					}
					tobeerased++;
					if (flagforce)
					{
						if (delete_file(fn.c_str()))
							erased++;
						else
							printf("************ 44752 HIGHLANDER FILE! %s\n",fn.c_str());
					}
				}
				*/
			}
			else
				printf("43406 BLOCK ZERO %s\n",fn.c_str());
			
		}  // end if selected
	}  // end for
	
	
	g_crc32.clear();
	
  // Decompress archive in parallel
	if (flagverbose)
	printf("Chunk %03d/%03d %21s bytes (%s) in %s files by %d threads\n",i_chunk+1,i_chunksize,migliaia(job.total_size), tohuman(job.total_size),migliaia2(total_files),howmanythreads);

	int64_t startextract=mtime();
	vector<ThreadID> tid(howmanythreads);
	for (unsigned i=0; i<tid.size(); ++i)
		if (flagramdisk)
			run(tid[i], decompressthreadramdisk, &job);
		else
			run(tid[i], decompressThread, &job);
		
  
// Wait for threads to finish
	for (unsigned i=0; i<tid.size(); ++i) 
		join(tid[i]);

	printbar(' ',false);
	printf("\r");	
 // Report failed extractions (on filesystem)
	if (!flagramdisk)
	{
		unsigned extracted=0;
		for (DTMap::iterator p=dt.begin(); p!=dt.end(); ++p) 
		{
			string fn=rename(p->first);
			if (std::binary_search(chunkfiles.begin(), chunkfiles.end(), p->first)) 
			{
				++extracted;
				if (p->second.ptr.size()!=unsigned(p->second.data)) 
				{
					fflush(stdout);
					if (++errors==1)
						fprintf(stderr,"\nFailed (extracted/total fragments, file):\n");
					printf( "SOK p->second.data %u / p->second.ptr.size() %u ",int(p->second.data), int(p->second.ptr.size()));
					printUTF8(fn.c_str());
					printf("\n");
				}
			}
		}
		if (errors>0) 
		{
			fflush(stdout);
			fprintf(stderr,"\nExtracted %s files (%s errors) using %s bytes x %d threads\n",
			migliaia(extracted), migliaia3(errors), migliaia4(job.maxMemory),
			int(tid.size()));
		}
		block=preblock; ///AARRRGHHH!!
		chunkfiles.clear();
		return errors>0;
	}



	
// going back to ramdisk
	int64_t endextract=mtime();
	double	time_extract=(endextract-startextract)*0.001+0.001;
	if (flagverbose)
	{
		printf("RAMDISK       %21s bytes (%s) ",migliaia(g_ramdisksize),tohuman(g_ramdisksize)); 
		printf("time %.2f s @ %s (%s/s)\n",time_extract,migliaia(job.total_size/time_extract),tohuman(job.total_size/time_extract));
	}
	int64_t 	startwrite=mtime();
	int64_t 	expected=0;
	uint32_t	file_expected=0;
	
	vector<string> 		myfiles;
	vector<int64_t> 	mydate;
	vector<int64_t> 	myattr;
	vector<string> 		myfilehash;
	vector<string> 		myalgo;
	vector<char*> 		mydata;
	vector<int64_t> 	myfilesize;
	vector<string> 		myfilecrc;
	

	for (DTMap::iterator p=dt.begin(); p!=dt.end(); ++p) 
		if (std::binary_search(chunkfiles.begin(), chunkfiles.end(), p->first)) 
		{
			string finalfile=rename(p->first);
			if ((searchfrom!="") && (replaceto!=""))
				replace(finalfile,searchfrom,replaceto);
			
			string myhashtype	="";
			string myhash		="";
			string mycrc32		="";
		
			if (!isdirectory(finalfile))
			{	
				decode_franz_block(false,p->second.franz_block,
					myhashtype,
					myhash,
					mycrc32);
				myfilesize.push_back((*p->second.pramfile).filesize);
				expected+=(*p->second.pramfile).filesize;
				mydata.push_back((*p->second.pramfile).data);
				file_expected++;
			}
			else
			{
				myfilesize.push_back(0);
				mydata.push_back(NULL);
			}
			myfiles.push_back(finalfile);
			myfilehash.push_back(myhash);
			myfilecrc.push_back(mycrc32);
			myalgo.push_back(myhashtype);
			mydate.push_back(p->second.date);
			myattr.push_back(p->second.attr);
		}

	unsigned int mythreads=howmanythreads;
		
	if (myfiles.size()<mythreads)
		mythreads=myfiles.size();
		
	if (flagssd)
	{
		if (myfiles.size()<mythreads)
			mythreads=myfiles.size();
	}
	else
		mythreads=1;
		
	vector<tparametriramtodisk> vettoreramtodisk;
	tparametriramtodisk 	myblock;
	for (unsigned int i=0;i<mythreads;i++)
	{
		myblock.tnumber		=(i%mythreads);
		myblock.timestart	=mtime();
		myblock.o_timeend	=0;
		myblock.flagtest	=flagtest;
		vettoreramtodisk.push_back(myblock);
	}
	if (flagdebug)
	{
		printf("33817: myfiles    %12s\n",migliaia(myfiles.size()));
		printf("33817: mydate     %12s\n",migliaia(mydate.size()));
		printf("33817: myattr     %12s\n",migliaia(myattr.size()));
		printf("33817: myalgo     %12s\n",migliaia(myalgo.size()));
		printf("33817: myfilehash %12s\n",migliaia(myfilehash.size()));
		printf("33817: mysize     %12s\n",migliaia(myfilesize.size()));
		printf("33817: mydata     %12s\n",migliaia(mydata.size()));
		printf("33817: mycrc32    %12s\n",migliaia(myfilecrc.size()));
	}

	for (unsigned int i=0;i<myfiles.size();i++)
	{
		vettoreramtodisk[i%mythreads].filenameondisk	.push_back(myfiles[i]);
		vettoreramtodisk[i%mythreads].filedate			.push_back(mydate[i]);
		vettoreramtodisk[i%mythreads].fileattr			.push_back(myattr[i]);
		vettoreramtodisk[i%mythreads].algo				.push_back(myalgo[i]);
		vettoreramtodisk[i%mythreads].filehash			.push_back(myfilehash[i]);
		vettoreramtodisk[i%mythreads].filesize			.push_back(myfilesize[i]);
		vettoreramtodisk[i%mythreads].data				.push_back(mydata[i]);
		vettoreramtodisk[i%mythreads].filecrc			.push_back(myfilecrc[i]);
	}

	int totfile=0;
	for (unsigned int i=0;i<mythreads;i++)
	{
		if (flagdebug)
			printf("Thread [%02d] files %s\n",i,migliaia(vettoreramtodisk[i].filenameondisk.size()));
		totfile+=+vettoreramtodisk[i].filenameondisk.size();
	}

	int rc;
	pthread_t* threads = new pthread_t[mythreads];

	pthread_attr_t attr;
	void *status;

	pthread_attr_init(&attr);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_JOINABLE);

	assert(myfiles.size()==totfile);
	printbar(' ',false);
	printf("\r");
	if (flagverbose)
		printf("Running %d threads on %s files\n",mythreads,migliaia(myfiles.size()));

	for(unsigned int i=0; i<mythreads; i++ ) 
	{
		vettoreramtodisk[i].timestart=mtime();
		rc = pthread_create(&threads[i], &attr, scriviramtodisk, (void*)&vettoreramtodisk[i]);
		if (rc)
		{
			printf("39264: Error creating thread\n");
			exit(-1);
		}
	}

	pthread_attr_destroy(&attr);
	for(unsigned int i=0; i <mythreads; i++ ) 
	{
		rc = pthread_join(threads[i], &status);
		if (rc) 
		{
			error("33821: Unable to join\n");
			exit(-1);
		}
	}

	int64_t			t_crcsize			=0;
	int64_t			t_hashedsize		=0;
	int64_t			t_writtenbythread	=0;
	int64_t			t_timecrc 			=1;
	int64_t			t_timehash			=1;
	int64_t			t_timefilesystem	=1;
	int64_t			t_timewrite			=1;
	uint32_t		t_writeerror		=0;
	uint32_t		t_fileok			=0;
	uint32_t		t_fileerror			=0;
	uint32_t		t_filesnotchecked	=0;
	uint32_t		t_filewithoutcrc	=0;
	uint32_t		t_filecrc			=0;
	uint32_t		t_filecrcok			=0;
	uint32_t		t_filecrcerror		=0;

	for(unsigned int i=0;i<mythreads;i++)
	{
		t_crcsize			+=vettoreramtodisk[i].o_crcsize;
		t_hashedsize		+=vettoreramtodisk[i].o_hashedsize;
		t_writtenbythread	+=vettoreramtodisk[i].o_writtenbythread;
		t_timecrc			+=vettoreramtodisk[i].o_timecrc;
		t_timehash			+=vettoreramtodisk[i].o_timehash;
		t_timefilesystem	+=vettoreramtodisk[i].o_timefilesystem;
		t_timewrite			+=vettoreramtodisk[i].o_timewrite;
		t_writeerror		+=vettoreramtodisk[i].o_writeerror;
		t_fileok			+=vettoreramtodisk[i].o_fileok;
		t_fileerror			+=vettoreramtodisk[i].o_fileerror;
		t_filesnotchecked	+=vettoreramtodisk[i].o_filesnotchecked;
		t_filewithoutcrc	+=vettoreramtodisk[i].o_filewithoutcrc;
		t_filecrc			+=vettoreramtodisk[i].o_filecrc;
		t_filecrcok			+=vettoreramtodisk[i].o_filecrcok;
		t_filecrcerror		+=vettoreramtodisk[i].o_filecrcerror;
	}
	
	double writetime=(1+mtime()-startwrite)*0.001;

	if (t_filecrcerror)
		errors++;
	
	if (t_fileerror)
		errors++;
		
	bool	issomething=(t_filecrcerror || t_fileerror || (t_crcsize!=expected) || t_filewithoutcrc || (t_hashedsize!=expected) || (t_filesnotchecked!=0) || (t_fileok!=file_expected));
	
	if (flagverbose)
	if (flagverify || flagchecksum)
	{	
		if (issomething)
			printbar('-');
		printf("CRC-32 %21s ",migliaia(t_crcsize));
		if (t_crcsize==expected)
			printf("[OK] ");
		else
			printf("[WARN] ");
		printf("(%8.2f s) @ %8s/s ",t_timecrc*0.001,tohuman(t_crcsize/(t_timecrc*0.001)));

		printf("UNKN %s ",migliaia(t_filewithoutcrc));
		if (t_filewithoutcrc==0)
			printf("[OK] ");
		else
			printf("[WARN] ");
				
		printf("GOOD %s ",migliaia(t_filecrcok));
		if (t_filecrcok==file_expected)
			printf("[OK] ");
		else
			printf("[WARN] ");
		
		printf("BAD %s ",migliaia(t_filecrcerror));
		if (t_filecrcerror==0)
			printf("[OK]");
		else
			printf("[FAULT: -verbose] ");
		printf("\n");
		
		
		printf("HASHes %21s ",migliaia(t_hashedsize));
		if (t_hashedsize==expected)
			printf("[OK] ");
		else
			printf("[WARN] ");

		printf("(%8.2f s) @ %8s/s ",t_timehash*0.001,tohuman(t_hashedsize/(t_timehash*0.001)));
		
		printf("UNKN %s ",migliaia(t_filesnotchecked));
		if (t_filesnotchecked==0)
			printf("[OK] ");
		else
			printf("[WARN] ");
		
		printf("GOOD %s ",migliaia(t_fileok));
		if (t_fileok==file_expected)
			printf("[OK] ");
		else
			printf("[WARN] ");
		
		printf("BAD %s ",migliaia(t_fileerror));
		if (t_fileerror==0)
			printf("[OK] ");
		else
			printf("[FAULT! -verbose] ");
		printf("\n");
		
		printbar('-');
	}
	
	if (!flagtest)
	{
		if (flagverbose)
		{
			printf("Time on FS (%6.2f s) writing data (%6.2f s) @ %s/s\n",t_timefilesystem*0.001,t_timewrite*0.001,tohuman(t_writtenbythread/(t_timewrite*0.001)));
			printf("Written by threads %21s / reported write errors %d ",migliaia(t_writtenbythread),t_writeerror);
			
			if (t_writeerror==0)
				printf("[OK] ");
			else
				printf("[FAULT!] ");
			printf("\n");
		}
	}
	if (flagverbose)
	{
		printf("Bytes expected     %21s (%6.2f s) @ %s B/s ",migliaia2(expected),writetime,migliaia3((t_writtenbythread/writetime)));
		if (!flagtest)
		{
			if (t_writtenbythread==expected)
				printf("[OK]");
			else
				printf("[FAULT!] ");
		}
		printf("\n");
		printf("RAMDISK releasing  %21s bytes ",migliaia(g_ramdisksize));
	}
	
	for (DTMap::iterator p=dt.begin(); p!=dt.end(); ++p) 
		if (std::binary_search(chunkfiles.begin(), chunkfiles.end(), p->first)) 
			if (p->second.pramfile!=NULL)
				(*p->second.pramfile).reset();
		
	if (flagverbose)
		printf("to %s (should be zero)\n",migliaia(g_ramdisksize));
	if (g_ramdisksize!=0)
		printf("\n\n45519: WARNING SOMETHING WRONG WITH RAM!\n");
	
	block=preblock; ///AARRRGHHH!!
	
	chunkfiles.clear();
	return errors>0;
}

int Jidac::removeemptydirs(string i_folder,bool i_kill)
{
	if (i_folder=="")
		return 0;
#ifdef _WIN32
	if (flaglongpath)
		if (iswindowspath(i_folder))
			if (!islongpath(i_folder))
				i_folder="//?/"+i_folder;
#endif	
	
	if (isdirectory(i_folder))
		i_folder=i_folder.substr(0,i_folder.size()-1);
	
	DTMap mydestinationdir;
	if (flagdebug)
	{
		printf("45124: Scanning dir <<");
		printUTF8(i_folder.c_str());
		printf(">>\n");
	}
	//checkifselected? false
	scandir(false,mydestinationdir,i_folder);
	printbar(' ',false);
	printf("\r");

	vector<string> scannedfiles;

	for (DTMap::iterator p=mydestinationdir.begin(); p!=mydestinationdir.end(); ++p) 
		scannedfiles.push_back(p->first);
	printf("Scanned files %s\n",migliaia(scannedfiles.size()));
	
	vector<string> tobedeleted;
	
	int candidati=0;
	for (unsigned int i=0;i<scannedfiles.size();i++)
		if (i<scannedfiles.size())
			if (isdirectory(scannedfiles[i]))
				{
					string corrente=scannedfiles[i];
					bool flagfigli=false;
					for (unsigned int j=i+1;j<scannedfiles.size();j++)
					{
						string prossima=extractfilepath(scannedfiles[j]);
						string nomefile=extractfilename(scannedfiles[j]);
				/// we count everything, even Thumbs.db as "non empty dirs"
				///		if ((nomefile!="Thumbs.db"))
						{
							if (mypos(corrente,prossima)!=0)
							{
			///				printf("---> esco prossima non  corrente |%s| |%s|\n",prossima.c_str(),corrente.c_str());
								break;
							}
							else
							{
								if (!isdirectory(scannedfiles[j]))
								{
				///				printf("Figliuolo!! %s\n",scannedfiles[j].c_str());
									flagfigli=true;
									break;
								}
							}
						}
					}
					if (flagfigli==0)
						tobedeleted.push_back(scannedfiles[i]);
				}
	
	candidati=tobedeleted.size();
	
	///printf("\n");
	if (flagdebug)
	{
		printbar('-');
		for (unsigned int i=0;i<tobedeleted.size();i++)
		{
			printf("45264: TO BE DELETED <<");
			printUTF8(tobedeleted[i].c_str());
			printf(">>\n");
		}
		printbar('-');
	}
	
	if (candidati==0)
	{
		if (flagverbose)
		{
			printf("45291: zero candidates <<");
			printUTF8(i_folder.c_str());
			printf(">>\n");
		}
		return 0;
	}
	if (!i_kill)
	{
		printf("45344: Empty folders        %12s on <<",migliaia(candidati));
		printUTF8(i_folder.c_str());
		printf(">>\n");
		printf("45347: dry run, exiting (no -kill)\n");
		return 0;
	}	
	
	if (flagverbose)
		printf("45291: Empty folders %12s ",migliaia(candidati));
	

	int lastrun=tobedeleted.size();
	int newrun=0;
	int64_t startdelete=mtime();
	int runs=0;
///	OK we want to be safe, so we iterate as many times as possible
/// to use delete_dir() instead of "erredbarras".
/// So only "really" empty will be deleted.
/// Not fast at all but safer.

	while (lastrun>newrun)
	{
		runs++;
		for (unsigned int i=0;i<tobedeleted.size();i++)
			if (delete_dir(tobedeleted[i].c_str()))
				tobedeleted.erase(tobedeleted.begin()+i);
		newrun=tobedeleted.size();
		if (flagdebug)
			printf("\nlastrun - newrun %d %d\n",lastrun,newrun);
		if (lastrun>newrun)
		{
			lastrun=newrun;
			newrun=0;
		}
	}
	
	if (flagverbose)
	{
		printf(" time %.2f sec, runs %04d, highlanders %s <<",(mtime()-startdelete)/1000.0,runs,migliaia(tobedeleted.size()));
		printUTF8(i_folder.c_str());
		printf(">>\n");
	}
	if (tobedeleted.size()>0)
		if (flagdebug)
			for (unsigned int i=0;i<tobedeleted.size();i++)
			{
				printf("Highlander <<");
				printUTF8(tobedeleted[i].c_str());
				printf(">>\n");
			}

	if (tobedeleted.size()==0)
		return 0;
	else
		return 1;
}


/*
	Section: 	command q. Backup of Windows C:
				command g  Launch a powershell (non need for a cmd-administrator)
*/

int Jidac::adminrun()
{
	printf("*** LAUNCH C: ARCHIVING  ***\n");
#ifndef _WIN32
	printf("46452: Windows C: backup works... on Windows\n");
	return 2;
#else
	if (archive=="")
	{
		printf("46458: need an archive (.zpaq)\n");
		return 2;
	}

	if (fullcommandline=="")
	{
		printf("46464: command line empty\n");
		return 2;
	}
	replace(fullcommandline,"g ","q ");
	wchar_t myexepath[_MAX_PATH];
	GetModuleFileName(NULL,myexepath,_MAX_PATH);
	string myexename=wtou(myexepath);
///	get the "right" path is not easy, registry digging needed.
///	too "complex", try to run
#ifdef _WIN64
	string runme="c:\\Windows\\SysWOW64\\WindowsPowerShell\\v1.0\\powershell.exe";
#else
#ifdef _WIN32
#endif
	string runme="c:\\Windows\\system32\\WindowsPowerShell\\v1.0\\powershell.exe";
#endif
	string parms="-Command \"Start-Process '"+myexename+"' '"+fullcommandline+"' -Wait -Verb runAs\"";
	waitexecute(runme,parms,SW_HIDE);
	return 0;
#endif
}

int Jidac::windowsc()
{
	printf("*** (KIND OF) WINDOWS C: BACKUP  ***\n");
#ifndef _WIN32
	printf("46173: Windows C: backup works... on Windows\n");
	return 2;
#else

	if (archive=="")
	{
		printf("45757: need an archive (.zpaq)\n");
		return 2;
	}

	if (!isadmin())
	{
		printf("\n46178: you need admin rights, quit\n");
		return 2;
	}
	
	HRESULT hr;

	hr=ModifyPrivilege(SE_BACKUP_NAME, TRUE);
    if (hr>0) printf("46406: Failed to become BACKUP\n");

	hr=ModifyPrivilege(SE_AUDIT_NAME, TRUE);
    if (hr>0) printf("46414: Failed to become AUDIT\n");
    
	hr=ModifyPrivilege(SE_SECURITY_NAME, TRUE);
    if (hr>0) printf("46414: Failed to become SECURITY\n");

	if (tofiles.size()!=0)
		printf("46041: -to ignored\n");
	
	if (files.size()!=0)
		printf("46042: files ignored (try to copy all C:)\n");
/*
	printf("Outside VSS\n");
	system( "dir /b /s C:\\Users\\utente\\AppData\\Local\\Microsoft\\WindowsApps" );


	exit(0);
*/
	tofiles.clear();
	tofiles.push_back("c:/");
	files.clear();
	files.push_back("c:/");

	notfiles.push_back("c:/franzsnap/pagefile.sys");
	notfiles.push_back("c:/franzsnap/swapfile.sys");
	notfiles.push_back("c:/franzsnap/System Volume Information/*");
	notfiles.push_back("*/AppData/Local/Microsoft/WindowsApps/*");	// no full reparse point, yet
	printf("Excluding ALWAYS pagefile.sys, swapfile.sys, System Volume Information, WindowsApps\n");
	
	if (all)
	{
		flagforcewindows=true;
		all=false;
	}
	else	
	{
		if (flagfrugal)
		{
			notfiles.push_back("c:/franzsnap/program files/*");
			notfiles.push_back("c:/franzsnap/program files (x86)/*");
			notfiles.push_back("c:/franzsnap/program files (x86)/*");
			printf("Excluding        %%programfiles%% and x86 (because -frugal)\n");
		}
		if (!flagforcewindows)
		{
			notfiles.push_back("c:/franzsnap/windows/*");
			notfiles.push_back("c:/franzsnap/$RECYCLE.BIN/*");

			string tempdir=g_gettempdirectory();
			myreplaceall(tempdir,"\\","/");
			tempdir+="*";
			if (flagdebug)
				printf("TEMP |%s|\n",tempdir.c_str());
			notfiles.push_back(tempdir);
			printf("Excluding        C:\\WINDOWS, TEMP, RECYCLE.BIN, ADS and .zfs bypass with -forcewindows\n");
		}
	}
	
	flagvss=true;
	return add();
#endif
}
