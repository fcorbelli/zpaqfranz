/*
                                  __
           _____ __   __ _  __ _ / _|_ __ __ _ _ __  ____
          |_  / '_ \ / _` |/ _` | |_| '__/ _` | '_ \|_  /
           / /| |_) | (_| | (_| |  _| | | (_| | | | |/ /
          /___| .__/ \__,_|\__, |_| |_|  \__,_|_| |_/___|
              |_|             |_|
         Swiss army knife for backup and disaster recovery
Like 7z or RAR on steroids,with deduplicated "snapshots" (versions)
Conceptually similar to Mac time machine, but much more efficiently
Keeps backup always-to-always, no need to ever prune (CryptoLocker)
Easily handles millions of files and TBs of data, non-latin support
Cloud backups with full encryption, minimal data transfer/bandwidth
Data integrity check CRC32+XXHASH|SHA-1|SHA-2|SHA-3|MD5|XXH3|BLAKE3
Thorough data verification, multithread support (real world 1GB+/s)
Specific zfs handling functions,full multiplatform interoperability
Particularly suitable for minimal space storage of virtual machines

Windows, FreeBSD, OpenBSD, Linux, MacOS, Solaris, OmniOS and others

WWW: https://github.com/fcorbelli/zpaqfranz

FACT: the best software for backup/disaster recovery your ever seen 
      (just joking)

           Provided as-is, with no warranty whatsoever,
                     by Franco Corbelli
                  franco@francocorbelli.com


MIT License
Copyright (c) 2021-2025 Franco Corbelli

Permission is hereby granted, free of charge, to any person
obtaining a copy of this software and associated documentation
files (the "Software"), to deal in the Software without
restriction, including without limitation the rights to use,
copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the
Software is furnished to do so, subject to the following
conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
OTHER DEALINGS IN THE SOFTWARE.
*/



#define ZPAQFULL ///NOSFTPSTART
///NOSFTPEND

#define ZPAQ_VERSION "63.4d"
#define ZPAQ_DATE "(2025-09-30)"



/*
By NOT defining ZPAQFULL, you'll get the 
full version of zpaqfranz, with all features enabled.

Here's the "spiegone"
https://github.com/fcorbelli/zpaqfranz/wiki/Security:-open-software
*/
 
#ifdef OPEN ///NOSFTPSTART
	#undef ZPAQFULL
#endif ///NOSFTPEND

///	optional align for malloc (sparc64,HPPA) via -DALIGNMALLOC
#define STR(a) #a
#define XSTR(a) STR(a)

#ifdef ALIGNMALLOC
#define	MALLOC_ALIGN 4
#endif // corresponds to #ifdef (#ifdef ALIGNMALLOC)

#ifdef MALLOC_ALIGN
	#define TEXT_ALIGN "." XSTR(MALLOC_ALIGN)
#else
	#define TEXT_ALIGN ""
#endif // corresponds to #ifdef (#ifdef MALLOC_ALIGN)
	
/// "automagically" compiling (well, sort of)
/// NO Windows? => no HWBLAKE,NOSHA1, YES unix
#ifndef _WIN32
	#undef 	HWBLAKE3
	#undef 	HWSHA1
	#undef 	unix
	#define unix
#endif // corresponds to #ifndef (#ifndef _WIN32)

#ifdef _WIN32
	#undef	SOLARIS
	#undef	ANCIENT
	#undef	BIG
	#undef	ESX
	#undef	ALIGNMALLOC
	#undef	unix
#endif // corresponds to #ifdef (#ifdef _WIN32)

#ifdef _WIN64
	#undef  HWSHA2
	#define HWSHA2

#ifdef HWSHA1
   #ifdef HWSHA2
	   #undef HWSHA2
   #endif // corresponds to #ifdef (#ifdef HWSHA2)
#endif // corresponds to #ifdef (#ifdef HWSHA1)

#endif // corresponds to #ifdef (#ifdef _WIN64)

#if defined(_WIN32) && ( defined(HWSHA1) || defined(HWSHA2) )
   #ifndef _WIN64
	   #undef HWSHA1
	   #undef HWSHA2
   #endif // corresponds to #ifndef (#ifndef _WIN64)
#endif // corresponds to #if (#if defined(_WIN32) && ( defined(HWSHA1) || defined(HWSHA2) ))

#define ZSFX_VERSION ""

#ifdef ZPAQFULL ///NOSFTPSTART
#if defined(_WIN64)
	#undef ZSFX_VERSION
	#define ZSFX_VERSION "SFX64 55.1,"
#endif // corresponds to #if (#if defined(_WIN64))
#if defined(_WIN32) && (!defined(_WIN64))
	#undef ZSFX_VERSION
	#define ZSFX_VERSION "-SFX32 55.1,"
#endif // corresponds to #if (#if defined(_WIN32) && (!defined(_WIN64)))

#endif ///NOSFTPEND


#ifdef HWBLAKE3
	#define TEXT_HWBLAKE3 "BLK3,"
#else
	#define TEXT_HWBLAKE3 ""
#endif // corresponds to #ifdef (#ifdef HWBLAKE3)

#ifdef HWSHA1
	#define TEXT_HWSHA1 "SHA1,"
#else
	#define TEXT_HWSHA1 ""
#endif // corresponds to #ifdef (#ifdef HWSHA1)

#ifdef HWSHA2
	#define TEXT_HWSHA2 "SHA1/2,"
#else
	#define TEXT_HWSHA2 ""
#endif // corresponds to #ifdef (#ifdef HWSHA2)

#if defined(HWBLAKE) || defined(HWSHA1) || defined(HWSHA2)
	#define TEXT_HWPRE ",HW "
#else
	#define TEXT_HWPRE ""
#endif // corresponds to #if (#if defined(HWBLAKE) || defined(HWSHA1) || defined(HWSHA2))

#ifdef IPV6
	#define TEXT_IPV "6,"
#else
	#define TEXT_IPV "4,"
#endif // corresponds to #ifdef (#ifdef IPV6)

#define LARGEFILE 100000000

/// some compiler define, some not
#define __LITTLE_ENDIAN 1234
#define __BIG_ENDIAN    4321

#ifdef	BIG
	#define __BYTE_ORDER __BIG_ENDIAN
	#define TEXT_BIG "-B"
#else
	#define __BYTE_ORDER __LITTLE_ENDIAN
	#define TEXT_BIG "-L"
#endif // corresponds to #ifdef	BIG (#ifdef	BIG)

#ifdef ESX
	#undef  unix
	#define unix 	1
	#undef  ANCIENT
	#define ANCIENT 1
	#undef  TEXT_BIG
	#define TEXT_BIG ""
	#undef  TEXT_IPV
	#define TEXT_IPV "4,"
	#undef  IPV6
#endif // corresponds to #ifdef (#ifdef ESX)

#ifdef NAS
	#define ANCIENT
	#undef HWSHA1
	#undef HWSHA2
	#undef HWBLAKE3
	#undef SOLARIS
	#undef BIG
	#undef DEBUG
	#undef ESX
	#undef ALIGNMALLOC
#ifdef ZPAQFULL ///NOSFTPSTART
	#undef SFTP
#endif ///NOSFTPEND
	#undef unix
	#define unix 1
#endif // corresponds to #ifdef (#ifdef NAS)

#ifdef ANCIENT
     #if __cplusplus < 201103L
        const class {
        public:
            template<class T>
            operator T*() const { return 0; }
            template<class C, class T>
            operator T C::*() const { return 0; }
        private:
            void operator&() const;
        } nullptr = {};
    #endif
    #define INT64_MIN (-9223372036854775807LL - 1)
    #define INT64_MAX 9223372036854775807LL
    #define errno 0
#ifdef ZPAQFULL ///NOSFTPSTART
    #undef SFTP
#endif ///NOSFTPEND
#endif


#define DATE_1980 1980*10000000000LL+1*100000000LL+1*1000000


/*

**This is zpaqfranz**, a patched — but (maybe :) compatible — fork of ZPAQ version 7.15
([http://mattmahoney.net/dc/zpaq.html](http://mattmahoney.net/dc/zpaq.html)).

Starting from branch 51, all source code has been merged into a single `.cpp` file,
with the goal of making it as easy as possible to compile on "unusual" systems
(e.g., NAS devices, vSphere, etc.), since no `make` is required anymore.

So please be patient if the source code appears non-linear — updating and compiling are now trivial.

The source is a fusion of various software components from different authors,
so there is no consistent programming style throughout.

I've made considerable effort to maintain compatibility with the unmodified version (7.15)
as well as with older C++ standards — even at the cost of slower or less elegant workarounds —
and to minimize compiler warnings as much as possible.

As of branch 63, you can now build a 100% open-source version (i.e., fully human-readable).


So don't be surprised if it looks like what in Italy
we call "zibaldone" or in Emilia-Romagna "mappazzone".
As Kirk McKusick once said: "nobody has offered to pay me the $25K to have me do it"
:)

GitHub links

#ifdef ZPAQFULL ///NOSFTPSTART
SFX modules (Windows)
https://github.com/fcorbelli/zpaqfranz/tree/main/ZSFX
https://github.com/fcorbelli/zsfx

Embedded AUTOTEST file
https://github.com/fcorbelli/zpaqfranz/tree/main/AUTOTEST
#endif ///NOSFTPEND

Windows stuff (assembly and object code for HW acceleration)
https://github.com/fcorbelli/zpaqfranz/tree/main/WINDOWS

NON-Windows stuff
https://github.com/fcorbelli/zpaqfranz/tree/main/NONWINDOWS

Manual (pod)
https://github.com/fcorbelli/zpaqfranz/tree/main/man

Wiki
https://github.com/fcorbelli/zpaqfranz/wiki



Portions of software by other authors, mentioned later, are included.
As far as I know this is allowed by the licenses.

**** I apologize if I have unintentionally violated any rule ****
****    Please report and I will fix as soon as possible     ****


        _      _____ _____ ______ _   _  _____ ______  _____ 
       | |    |_   _/ ____|  ____| \ | |/ ____|  ____|/ ____|
       | |      | || |    | |__  |  \| | (___ | |__  | (___  
       | |      | || |    |  __| | . ` |\___ \|  __|  \___ \ 
       | |____ _| || |____| |____| |\  |____) | |____ ____) |
       |______|_____\_____|______|_| \_|_____/|______|_____/ 
                                                       
Credits and copyrights and licenses and links and internal bookmarks

 0 [Public domain]                zpaq http://mattmahoney.net/dc/zpaq.html
	This software is provided as-is, with no warranty.
	I, Matt Mahoney, release this software into
	the public domain.   This applies worldwide.
	In some countries this may not be legally possible; if so:
	I grant anyone the right to use this software for any purpose,
	without any conditions, unless such conditions are required by law.

 1 [Public domain]                zpaq.AES from libtomcrypt by Tom St Denis
 /// LICENSE_START.1
 /// LICENSE_END.1
 
	LibTomCrypt is licensed under DUAL licensing terms.
	Choose and use the license of your needs.
	[LICENSE #1]
	LibTomCrypt is public domain.  As should all quality software be.
	Tom St Denis
	[/LICENSE #1]

	[LICENSE #2]

	DO WHAT THE FUCK YOU WANT TO PUBLIC LICENSE
	Version 2, December 2004
	Copyright (C) 2004 Sam Hocevar <sam@hocevar.net>
	Everyone is permitted to copy and distribute verbatim or modified
	copies of this license document, and changing it is allowed as long
	as the name is changed.
	DO WHAT THE FUCK YOU WANT TO PUBLIC LICENSE
	TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION

	0. You just DO WHAT THE FUCK YOU WANT TO. 
	[/LICENSE #2]

 2 [Public domain]                zpaq.salsa20 by D. J. Bernstein
 /// LICENSE_START.2
 /// LICENSE_END.2
	From the reference
	salsa20-ref.c version 20051118
	D. J. Bernstein
	Public domain.

 3 [Public domain]                unzpaq206.cpp by Matt Mahoney
 /// LICENSE_START.3
 /// LICENSE_END.3
	This software is provided as-is, with no warranty.
	I, Matt Mahoney, release this software into
	the public domain.   This applies worldwide.
	In some countries this may not be legally possible; if so:
	I grant anyone the right to use this software for any purpose,
	without any conditions, unless such conditions are required by law.

 4 [Public domain]                zpaq.Include mod by data man and reg2s patch from encode.su forum
    Public forum                  https://encode.su/threads/456-zpaq-updates

 5 [Public domain]                Sha1Opt.asm and 7zAsm.asm by Igor Pavlov
 /// LICENSE_START.5
 /// LICENSE_END.5
    *** NOTE: those asm are used only on Windows ***
    https://sourceforge.net/p/sevenzip/discussion/45797/thread/7d394aca49/?limit=25#521d
 	Hello, I am the developer of a little zpaq's fork (zpaqfranz)	(...)
	I integrated two of yours source code into mine	(...)
	Even if the performance increases very little (maybe 10%), can I use it?
	I think it is right to ask this explicitly before releasing the new version or zpaqfranz
	Thank you
	Franco Corbelli
	(Igor Pavlov, 2022-07-22)
		Yes, you can use any public domain code from 7-zip in any project.
	
 6 [MIT license]                  zpaq.Code from libdivsufsort 2.0 (C) Yuta Mori, 2003-2008
 /// LICENSE_START.6
 /// LICENSE_END.6
 	The MIT License (MIT)
	Copyright (c) 2003-2008 Yuta Mori All rights reserved.
	Permission is hereby granted, free of charge, to any person obtaining a copy
	of this software and associated documentation files (the "Software"), to deal
	in the Software without restriction, including without limitation the rights
	to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	copies of the Software, and to permit persons to whom the Software is
	furnished to do so, subject to the following conditions:
	The above copyright notice and this permission notice shall be included in all
	copies or substantial portions of the Software.
	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
	SOFTWARE.

 7 [MIT License]                  Embedded Artistry (memory-aligned malloc)           https://github.com/embeddedartistry
 /// LICENSE_START.7
 /// LICENSE_END.7
	MIT License
	Copyright (c) 2017 Embedded Artistry
	Permission is hereby granted, free of charge, to any person obtaining a copy
	of this software and associated documentation files (the "Software"), to deal
	in the Software without restriction, including without limitation the rights
	to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	copies of the Software, and to permit persons to whom the Software is
	furnished to do so, subject to the following conditions:
	The above copyright notice and this permission notice shall be included in all
	copies or substantial portions of the Software.
	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
	SOFTWARE.

 8 [MIT License]                  Nilsimsa implementation by Sepehr Laal              https://github.com/3p3r/nilsimsa-lite/blob/master/nilsimsa.c
 /// LICENSE_START.8
 /// LICENSE_END.8
	MIT License
	Copyright (c) 2017 Sepehr Laal
	Permission is hereby granted, free of charge, to any person obtaining a copy
	of this software and associated documentation files (the "Software"), to deal
	in the Software without restriction, including without limitation the rights
	to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	copies of the Software, and to permit persons to whom the Software is
	furnished to do so, subject to the following conditions:
	The above copyright notice and this permission notice shall be included in all
	copies or substantial portions of the Software.
	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
	SOFTWARE.
#ifdef ZPAQFULL ///NOSFTPSTART
 9 [MIT License]                  zsfx by ... me                                      https://github.com/fcorbelli/zsfx
	MIT License
	Copyright (c) 2022 Franco Corbelli
	Permission is hereby granted, free of charge, to any person obtaining a copy
	of this software and associated documentation files (the "Software"), to deal
	in the Software without restriction, including without limitation the rights
	to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	copies of the Software, and to permit persons to whom the Software is
	furnished to do so, subject to the following conditions:
	The above copyright notice and this permission notice shall be included in all
	copies or substantial portions of the Software.
	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
	SOFTWARE.
#endif ///NOSFTPEND

10 [zlib license]                 Crc32.h Copyright (c) 2011-2019 Stephan Brumme      https://create.stephan-brumme.com/crc32/
 /// LICENSE_START.10
 /// LICENSE_END.10
	This code is licensed under the zlib License:
	This software is provided 'as-is', without any express or implied
	warranty. In no event will the authors be held liable for any damages
	arising from the use of this software.
	Permission is granted to anyone to use this software for any purpose,
	including commercial applications, and to alter it and redistribute it
	freely, subject to the following restrictions:
	1. The origin of this software must not be misrepresented; you must not
	   claim that you wrote the original software. If you use this software
	   in a product, an acknowledgment in the product documentation would be
	   appreciated but is not required.
	2. Altered source versions must be plainly marked as such, and must not be
	   misrepresented as being the original software.
	3. This notice may not be removed or altered from any source distribution.

11 [zlib license]                 part of hash-library (MD5, SHA-3) by Stephan Brumme https://github.com/stbrumme/hash-library
 /// LICENSE_START.11
 /// LICENSE_END.11
	zlib License
	Copyright (c) 2014,2015 Stephan Brumme
	This software is provided 'as-is', without any express or implied warranty. In no event will the authors be held liable for any damages arising from the use of this software.
	Permission is granted to anyone to use this software for any purpose, including commercial applications, and to alter it and redistribute it freely, subject to the following restrictions:
	1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software.
	   If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
	2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
	3. This notice may not be removed or altered from any source distribution.

12 [zlib license]                 crc32c.c Copyright (C) Mark Adler              https://github.com/madler/brotli/blob/master/crc32c.c
 /// LICENSE_START.12
 /// LICENSE_END.12
	crc32c.c -- compute CRC-32C using the Intel crc32 instruction
	Copyright (C) 2013, 2015, 2021 Mark Adler
	This software is provided 'as-is', without any express or implied
	warranty.  In no event will the author be held liable for any damages
	arising from the use of this software.
	Permission is granted to anyone to use this software for any purpose,
	including commercial applications, and to alter it and redistribute it
	freely, subject to the following restrictions:
	1. The origin of this software must not be misrepresented; you must not
	 claim that you wrote the original software. If you use this software
	 in a product, an acknowledgment in the product documentation would be
	 appreciated but is not required.
	2. Altered source versions must be plainly marked as such, and must not be
	 misrepresented as being the original software.
	3. This notice may not be removed or altered from any source distribution.
	Mark Adler
	madler@alumni.caltech.edu

13 [The Unlicense]                wyhash (experimental) WangYi                        https://github.com/wangyi-fudan/wyhash
 /// LICENSE_START.13
 /// LICENSE_END.13
	This is free and unencumbered software released into the public domain.
	Anyone is free to copy, modify, publish, use, compile, sell, or
	distribute this software, either in source code form or as a compiled
	binary, for any purpose, commercial or non-commercial, and by any
	means.
	In jurisdictions that recognize copyright laws, the author or authors
	of this software dedicate any and all copyright interest in the
	software to the public domain. We make this dedication for the benefit
	of the public at large and to the detriment of our heirs and
	successors. We intend this dedication to be an overt act of
	relinquishment in perpetuity of all present and future rights to this
	software under copyright law.
	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
	EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
	IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR
	OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
	ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
	OTHER DEALINGS IN THE SOFTWARE.
	For more information, please refer to <http://unlicense.org/>

14 [BSD 2-Clause license]         xxHash Copyright (C) 2012-2020 Yann Collet          https://github.com/memcached/memcached/blob/master/xxhash.h
 /// LICENSE_START.14
 /// LICENSE_END.14
	xxHash - Extremely Fast Hash algorithm
	Header File
	Copyright (C) 2012-2020 Yann Collet
	BSD 2-Clause License (https://www.opensource.org/licenses/bsd-license.php)
	Redistribution and use in source and binary forms, with or without
	modification, are permitted provided that the following conditions are
	met:
	   * Redistributions of source code must retain the above copyright
		 notice, this list of conditions and the following disclaimer.
	   * Redistributions in binary form must reproduce the above
		 copyright notice, this list of conditions and the following disclaimer
		 in the documentation and/or other materials provided with the
		 distribution.
	THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
	"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
	LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
	A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
	OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
	SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
	LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
	THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
	(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
	OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	You can contact the author at:
	  - xxHash homepage: https://www.xxhash.com
	  - xxHash source repository: https://github.com/Cyan4973/xxHash

15 [CC0 1.0 / Apache License 2.0] BLAKE3 hasher                                       https://github.com/BLAKE3-team/BLAKE3
 /// LICENSE_START.15
 /// LICENSE_END.15
	This work is released into the public domain with CC0 1.0. Alternatively, it is
	licensed under the Apache License 2.0.
	-------------------------------------------------------------------------------
	Creative Commons Legal Code
	CC0 1.0 Universal
		CREATIVE COMMONS CORPORATION IS NOT A LAW FIRM AND DOES NOT PROVIDE
		LEGAL SERVICES. DISTRIBUTION OF THIS DOCUMENT DOES NOT CREATE AN
		ATTORNEY-CLIENT RELATIONSHIP. CREATIVE COMMONS PROVIDES THIS
		INFORMATION ON AN "AS-IS" BASIS. CREATIVE COMMONS MAKES NO WARRANTIES
		REGARDING THE USE OF THIS DOCUMENT OR THE INFORMATION OR WORKS
		PROVIDED HEREUNDER, AND DISCLAIMS LIABILITY FOR DAMAGES RESULTING FROM
		THE USE OF THIS DOCUMENT OR THE INFORMATION OR WORKS PROVIDED
		HEREUNDER.
	Statement of Purpose
	The laws of most jurisdictions throughout the world automatically confer
	exclusive Copyright and Related Rights (defined below) upon the creator
	and subsequent owner(s) (each and all, an "owner") of an original work of
	authorship and/or a database (each, a "Work").
	Certain owners wish to permanently relinquish those rights to a Work for
	the purpose of contributing to a commons of creative, cultural and
	scientific works ("Commons") that the public can reliably and without fear
	of later claims of infringement build upon, modify, incorporate in other
	works, reuse and redistribute as freely as possible in any form whatsoever
	and for any purposes, including without limitation commercial purposes.
	These owners may contribute to the Commons to promote the ideal of a free
	culture and the further production of creative, cultural and scientific
	works, or to gain reputation or greater distribution for their Work in
	part through the use and efforts of others.
	For these and/or other purposes and motivations, and without any
	expectation of additional consideration or compensation, the person
	associating CC0 with a Work (the "Affirmer"), to the extent that he or she
	is an owner of Copyright and Related Rights in the Work, voluntarily
	elects to apply CC0 to the Work and publicly distribute the Work under its
	terms, with knowledge of his or her Copyright and Related Rights in the
	Work and the meaning and intended legal effect of CC0 on those rights.
	1. Copyright and Related Rights. A Work made available under CC0 may be
	protected by copyright and related or neighboring rights ("Copyright and
	Related Rights"). Copyright and Related Rights include, but are not
	limited to, the following:
	  i. the right to reproduce, adapt, distribute, perform, display,
		 communicate, and translate a Work;
	 ii. moral rights retained by the original author(s) and/or performer(s);
	iii. publicity and privacy rights pertaining to a person's image or
		 likeness depicted in a Work;
	 iv. rights protecting against unfair competition in regards to a Work,
		 subject to the limitations in paragraph 4(a), below;
	  v. rights protecting the extraction, dissemination, use and reuse of data
		 in a Work;
	 vi. database rights (such as those arising under Directive 96/9/EC of the
		 European Parliament and of the Council of 11 March 1996 on the legal
		 protection of databases, and under any national implementation
		 thereof, including any amended or successor version of such
		 directive); and
	vii. other similar, equivalent or corresponding rights throughout the
		 world based on applicable law or treaty, and any national
		 implementations thereof.
	2. Waiver. To the greatest extent permitted by, but not in contravention
	of, applicable law, Affirmer hereby overtly, fully, permanently,
	irrevocably and unconditionally waives, abandons, and surrenders all of
	Affirmer's Copyright and Related Rights and associated claims and causes
	of action, whether now known or unknown (including existing as well as
	future claims and causes of action), in the Work (i) in all territories
	worldwide, (ii) for the maximum duration provided by applicable law or
	treaty (including future time extensions), (iii) in any current or future
	medium and for any number of copies, and (iv) for any purpose whatsoever,
	including without limitation commercial, advertising or promotional
	purposes (the "Waiver"). Affirmer makes the Waiver for the benefit of each
	member of the public at large and to the detriment of Affirmer's heirs and
	successors, fully intending that such Waiver shall not be subject to
	revocation, rescission, cancellation, termination, or any other legal or
	equitable action to disrupt the quiet enjoyment of the Work by the public
	as contemplated by Affirmer's express Statement of Purpose.
	3. Public License Fallback. Should any part of the Waiver for any reason
	be judged legally invalid or ineffective under applicable law, then the
	Waiver shall be preserved to the maximum extent permitted taking into
	account Affirmer's express Statement of Purpose. In addition, to the
	extent the Waiver is so judged Affirmer hereby grants to each affected
	person a royalty-free, non transferable, non sublicensable, non exclusive,
	irrevocable and unconditional license to exercise Affirmer's Copyright and
	Related Rights in the Work (i) in all territories worldwide, (ii) for the
	maximum duration provided by applicable law or treaty (including future
	time extensions), (iii) in any current or future medium and for any number
	of copies, and (iv) for any purpose whatsoever, including without
	limitation commercial, advertising or promotional purposes (the
	"License"). The License shall be deemed effective as of the date CC0 was
	applied by Affirmer to the Work. Should any part of the License for any
	reason be judged legally invalid or ineffective under applicable law, such
	partial invalidity or ineffectiveness shall not invalidate the remainder
	of the License, and in such case Affirmer hereby affirms that he or she
	will not (i) exercise any of his or her remaining Copyright and Related
	Rights in the Work or (ii) assert any associated claims and causes of
	action with respect to the Work, in either case contrary to Affirmer's
	express Statement of Purpose.
	4. Limitations and Disclaimers.
	 a. No trademark or patent rights held by Affirmer are waived, abandoned,
		surrendered, licensed or otherwise affected by this document.
	 b. Affirmer offers the Work as-is and makes no representations or
		warranties of any kind concerning the Work, express, implied,
		statutory or otherwise, including without limitation warranties of
		title, merchantability, fitness for a particular purpose, non
		infringement, or the absence of latent or other defects, accuracy, or
		the present or absence of errors, whether or not discoverable, all to
		the greatest extent permissible under applicable law.
	 c. Affirmer disclaims responsibility for clearing rights of other persons
		that may apply to the Work or any use thereof, including without
		limitation any person's Copyright and Related Rights in the Work.
		Further, Affirmer disclaims responsibility for obtaining any necessary
		consents, permissions or other rights required for any use of the
		Work.
	 d. Affirmer understands and acknowledges that Creative Commons is not a
		party to this document and has no duty or obligation with respect to
		this CC0 or use of the Work.
	-------------------------------------------------------------------------------
									 Apache License
							   Version 2.0, January 2004
							http://www.apache.org/licenses/
	   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
	   1. Definitions.
		  "License" shall mean the terms and conditions for use, reproduction,
		  and distribution as defined by Sections 1 through 9 of this document.
		  "Licensor" shall mean the copyright owner or entity authorized by
		  the copyright owner that is granting the License.
		  "Legal Entity" shall mean the union of the acting entity and all
		  other entities that control, are controlled by, or are under common
		  control with that entity. For the purposes of this definition,
		  "control" means (i) the power, direct or indirect, to cause the
		  direction or management of such entity, whether by contract or
		  otherwise, or (ii) ownership of fifty percent (50%) or more of the
		  outstanding shares, or (iii) beneficial ownership of such entity.
		  "You" (or "Your") shall mean an individual or Legal Entity
		  exercising permissions granted by this License.
		  "Source" form shall mean the preferred form for making modifications,
		  including but not limited to software source code, documentation
		  source, and configuration files.
		  "Object" form shall mean any form resulting from mechanical
		  transformation or translation of a Source form, including but
		  not limited to compiled object code, generated documentation,
		  and conversions to other media types.
		  "Work" shall mean the work of authorship, whether in Source or
		  Object form, made available under the License, as indicated by a
		  copyright notice that is included in or attached to the work
		  (an example is provided in the Appendix below).
		  "Derivative Works" shall mean any work, whether in Source or Object
		  form, that is based on (or derived from) the Work and for which the
		  editorial revisions, annotations, elaborations, or other modifications
		  represent, as a whole, an original work of authorship. For the purposes
		  of this License, Derivative Works shall not include works that remain
		  separable from, or merely link (or bind by name) to the interfaces of,
		  the Work and Derivative Works thereof.
		  "Contribution" shall mean any work of authorship, including
		  the original version of the Work and any modifications or additions
		  to that Work or Derivative Works thereof, that is intentionally
		  submitted to Licensor for inclusion in the Work by the copyright owner
		  or by an individual or Legal Entity authorized to submit on behalf of
		  the copyright owner. For the purposes of this definition, "submitted"
		  means any form of electronic, verbal, or written communication sent
		  to the Licensor or its representatives, including but not limited to
		  communication on electronic mailing lists, source code control systems,
		  and issue tracking systems that are managed by, or on behalf of, the
		  Licensor for the purpose of discussing and improving the Work, but
		  excluding communication that is conspicuously marked or otherwise
		  designated in writing by the copyright owner as "Not a Contribution."
		  "Contributor" shall mean Licensor and any individual or Legal Entity
		  on behalf of whom a Contribution has been received by Licensor and
		  subsequently incorporated within the Work.
	   2. Grant of Copyright License. Subject to the terms and conditions of
		  this License, each Contributor hereby grants to You a perpetual,
		  worldwide, non-exclusive, no-charge, royalty-free, irrevocable
		  copyright license to reproduce, prepare Derivative Works of,
		  publicly display, publicly perform, sublicense, and distribute the
		  Work and such Derivative Works in Source or Object form.
	   3. Grant of Patent License. Subject to the terms and conditions of
		  this License, each Contributor hereby grants to You a perpetual,
		  worldwide, non-exclusive, no-charge, royalty-free, irrevocable
		  (except as stated in this section) patent license to make, have made,
		  use, offer to sell, sell, import, and otherwise transfer the Work,
		  where such license applies only to those patent claims licensable
		  by such Contributor that are necessarily infringed by their
		  Contribution(s) alone or by combination of their Contribution(s)
		  with the Work to which such Contribution(s) was submitted. If You
		  institute patent litigation against any entity (including a
		  cross-claim or counterclaim in a lawsuit) alleging that the Work
		  or a Contribution incorporated within the Work constitutes direct
		  or contributory patent infringement, then any patent licenses
		  granted to You under this License for that Work shall terminate
		  as of the date such litigation is filed.
	   4. Redistribution. You may reproduce and distribute copies of the
		  Work or Derivative Works thereof in any medium, with or without
		  modifications, and in Source or Object form, provided that You
		  meet the following conditions:
		  (a) You must give any other recipients of the Work or
			  Derivative Works a copy of this License; and
		  (b) You must cause any modified files to carry prominent notices
			  stating that You changed the files; and
		  (c) You must retain, in the Source form of any Derivative Works
			  that You distribute, all copyright, patent, trademark, and
			  attribution notices from the Source form of the Work,
			  excluding those notices that do not pertain to any part of
			  the Derivative Works; and
		  (d) If the Work includes a "NOTICE" text file as part of its
			  distribution, then any Derivative Works that You distribute must
			  include a readable copy of the attribution notices contained
			  within such NOTICE file, excluding those notices that do not
			  pertain to any part of the Derivative Works, in at least one
			  of the following places: within a NOTICE text file distributed
			  as part of the Derivative Works; within the Source form or
			  documentation, if provided along with the Derivative Works; or,
			  within a display generated by the Derivative Works, if and
			  wherever such third-party notices normally appear. The contents
			  of the NOTICE file are for informational purposes only and
			  do not modify the License. You may add Your own attribution
			  notices within Derivative Works that You distribute, alongside
			  or as an addendum to the NOTICE text from the Work, provided
			  that such additional attribution notices cannot be construed
			  as modifying the License.
		  You may add Your own copyright statement to Your modifications and
		  may provide additional or different license terms and conditions
		  for use, reproduction, or distribution of Your modifications, or
		  for any such Derivative Works as a whole, provided Your use,
		  reproduction, and distribution of the Work otherwise complies with
		  the conditions stated in this License.
	   5. Submission of Contributions. Unless You explicitly state otherwise,
		  any Contribution intentionally submitted for inclusion in the Work
		  by You to the Licensor shall be under the terms and conditions of
		  this License, without any additional terms or conditions.
		  Notwithstanding the above, nothing herein shall supersede or modify
		  the terms of any separate license agreement you may have executed
		  with Licensor regarding such Contributions.
	   6. Trademarks. This License does not grant permission to use the trade
		  names, trademarks, service marks, or product names of the Licensor,
		  except as required for reasonable and customary use in describing the
		  origin of the Work and reproducing the content of the NOTICE file.
	   7. Disclaimer of Warranty. Unless required by applicable law or
		  agreed to in writing, Licensor provides the Work (and each
		  Contributor provides its Contributions) on an "AS IS" BASIS,
		  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
		  implied, including, without limitation, any warranties or conditions
		  of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
		  PARTICULAR PURPOSE. You are solely responsible for determining the
		  appropriateness of using or redistributing the Work and assume any
		  risks associated with Your exercise of permissions under this License.
	   8. Limitation of Liability. In no event and under no legal theory,
		  whether in tort (including negligence), contract, or otherwise,
		  unless required by applicable law (such as deliberate and grossly
		  negligent acts) or agreed to in writing, shall any Contributor be
		  liable to You for damages, including any direct, indirect, special,
		  incidental, or consequential damages of any character arising as a
		  result of this License or out of the use or inability to use the
		  Work (including but not limited to damages for loss of goodwill,
		  work stoppage, computer failure or malfunction, or any and all
		  other commercial damages or losses), even if such Contributor
		  has been advised of the possibility of such damages.
	   9. Accepting Warranty or Additional Liability. While redistributing
		  the Work or Derivative Works thereof, You may choose to offer,
		  and charge a fee for, acceptance of support, warranty, indemnity,
		  or other liability obligations and/or rights consistent with this
		  License. However, in accepting such obligations, You may act only
		  on Your own behalf and on Your sole responsibility, not on behalf
		  of any other Contributor, and only if You agree to indemnify,
		  defend, and hold each Contributor harmless for any liability
		  incurred by, or claims asserted against, such Contributor by reason
		  of your accepting any such warranty or additional liability.
	   END OF TERMS AND CONDITIONS
	   APPENDIX: How to apply the Apache License to your work.
		  To apply the Apache License to your work, attach the following
		  boilerplate notice, with the fields enclosed by brackets "[]"
		  replaced with your own identifying information. (Don't include
		  the brackets!)  The text should be enclosed in the appropriate
		  comment syntax for the file format. We also recommend that a
		  file or class name and description of purpose be included on the
		  same "printed page" as the copyright notice for easier
		  identification within third-party archives.
	   Copyright 2019 Jack O'Connor and Samuel Neves
	   Licensed under the Apache License, Version 2.0 (the "License");
	   you may not use this file except in compliance with the License.
	   You may obtain a copy of the License at
		   http://www.apache.org/licenses/LICENSE-2.0
	   Unless required by applicable law or agreed to in writing, software
	   distributed under the License is distributed on an "AS IS" BASIS,
	   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	   See the License for the specific language governing permissions and
	   limitations under the License.

16 [Public domain]  Whirlpool by Paulo Barreto and Vincent Rijmen       https://web.archive.org/web/20171129084214/http://www.larc.usp.br/~pbarreto/WhirlpoolPage.html
 /// LICENSE_START.16
 /// LICENSE_END.16
	The reference implementations are in the public domain.
	But before you go and use it, please read the accompanying disclaimer:
	THIS SOFTWARE IS PROVIDED BY THE AUTHORS ''AS IS'' AND ANY EXPRESS
	OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
	ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHORS OR CONTRIBUTORS BE
	LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
	CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
	SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
	BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
	WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
	OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 

17 [almost-unrestricted]		  Twofish implementation,(c) 2002 by Niels Ferguson   https://github.com/wernerd/ZRTPCPP/blob/master/cryptcommon/twofish.c
	**** This is part of currently not released zpaqfranz (future zpaq-over-IP)
	* Fast, portable, and easy-to-use Twofish implementation,
	* Version 0.3.
	* Copyright (c) 2002 by Niels Ferguson.

	The author hereby grants a perpetual license to everybody to
	use this code for any purpose as long as the copyright message is included
	in the source code of this or any derived work.

	Yes, this means that you, your company, your club, and anyone else
	can use this code anywhere you want. You can change it and distribute it
	under the GPL, include it in your commercial product without releasing
	the source code, put it on the web, etc.
	The only thing you cannot do is remove my copyright message,
	or distribute any source code based on this implementation that does not
	include my copyright message.

	I appreciate a mention in the documentation or credits,
	but I understand if that is difficult to do.
	I also appreciate it if you tell me where and why you used my code.

18 [Apache License 2.0] HighWay64 hasher                                       https://github.com/google/highwayhash
 /// LICENSE_START.18
 /// LICENSE_END.18
      Apache License
                           Version 2.0, January 2004
                        http://www.apache.org/licenses/

   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
   1. Definitions.
      "License" shall mean the terms and conditions for use, reproduction,
      and distribution as defined by Sections 1 through 9 of this document.
      "Licensor" shall mean the copyright owner or entity authorized by
      the copyright owner that is granting the License.
      "Legal Entity" shall mean the union of the acting entity and all
      other entities that control, are controlled by, or are under common
      control with that entity. For the purposes of this definition,
      "control" means (i) the power, direct or indirect, to cause the
      direction or management of such entity, whether by contract or
      otherwise, or (ii) ownership of fifty percent (50%) or more of the
      outstanding shares, or (iii) beneficial ownership of such entity.
      "You" (or "Your") shall mean an individual or Legal Entity
      exercising permissions granted by this License.
      "Source" form shall mean the preferred form for making modifications,
      including but not limited to software source code, documentation
      source, and configuration files.
      "Object" form shall mean any form resulting from mechanical
      transformation or translation of a Source form, including but
      not limited to compiled object code, generated documentation,
      and conversions to other media types.
      "Work" shall mean the work of authorship, whether in Source or
      Object form, made available under the License, as indicated by a
      copyright notice that is included in or attached to the work
      (an example is provided in the Appendix below).
      "Derivative Works" shall mean any work, whether in Source or Object
      form, that is based on (or derived from) the Work and for which the
      editorial revisions, annotations, elaborations, or other modifications
      represent, as a whole, an original work of authorship. For the purposes
      of this License, Derivative Works shall not include works that remain
      separable from, or merely link (or bind by name) to the interfaces of,
      the Work and Derivative Works thereof.
      "Contribution" shall mean any work of authorship, including
      the original version of the Work and any modifications or additions
      to that Work or Derivative Works thereof, that is intentionally
      submitted to Licensor for inclusion in the Work by the copyright owner
      or by an individual or Legal Entity authorized to submit on behalf of
      the copyright owner. For the purposes of this definition, "submitted"
      means any form of electronic, verbal, or written communication sent
      to the Licensor or its representatives, including but not limited to
      communication on electronic mailing lists, source code control systems,
      and issue tracking systems that are managed by, or on behalf of, the
      Licensor for the purpose of discussing and improving the Work, but
      excluding communication that is conspicuously marked or otherwise
      designated in writing by the copyright owner as "Not a Contribution."
      "Contributor" shall mean Licensor and any individual or Legal Entity
      on behalf of whom a Contribution has been received by Licensor and
      subsequently incorporated within the Work.
   2. Grant of Copyright License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      copyright license to reproduce, prepare Derivative Works of,
      publicly display, publicly perform, sublicense, and distribute the
      Work and such Derivative Works in Source or Object form.
   3. Grant of Patent License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      (except as stated in this section) patent license to make, have made,
      use, offer to sell, sell, import, and otherwise transfer the Work,
      where such license applies only to those patent claims licensable
      by such Contributor that are necessarily infringed by their
      Contribution(s) alone or by combination of their Contribution(s)
      with the Work to which such Contribution(s) was submitted. If You
      institute patent litigation against any entity (including a
      cross-claim or counterclaim in a lawsuit) alleging that the Work
      or a Contribution incorporated within the Work constitutes direct
      or contributory patent infringement, then any patent licenses
      granted to You under this License for that Work shall terminate
      as of the date such litigation is filed.
   4. Redistribution. You may reproduce and distribute copies of the
      Work or Derivative Works thereof in any medium, with or without
      modifications, and in Source or Object form, provided that You
      meet the following conditions:
      (a) You must give any other recipients of the Work or
          Derivative Works a copy of this License; and
      (b) You must cause any modified files to carry prominent notices
          stating that You changed the files; and
      (c) You must retain, in the Source form of any Derivative Works
          that You distribute, all copyright, patent, trademark, and
          attribution notices from the Source form of the Work,
          excluding those notices that do not pertain to any part of
          the Derivative Works; and
      (d) If the Work includes a "NOTICE" text file as part of its
          distribution, then any Derivative Works that You distribute must
          include a readable copy of the attribution notices contained
          within such NOTICE file, excluding those notices that do not
          pertain to any part of the Derivative Works, in at least one
          of the following places: within a NOTICE text file distributed
          as part of the Derivative Works; within the Source form or
          documentation, if provided along with the Derivative Works; or,
          within a display generated by the Derivative Works, if and
          wherever such third-party notices normally appear. The contents
          of the NOTICE file are for informational purposes only and
          do not modify the License. You may add Your own attribution
          notices within Derivative Works that You distribute, alongside
          or as an addendum to the NOTICE text from the Work, provided
          that such additional attribution notices cannot be construed
          as modifying the License.
      You may add Your own copyright statement to Your modifications and
      may provide additional or different license terms and conditions
      for use, reproduction, or distribution of Your modifications, or
      for any such Derivative Works as a whole, provided Your use,
      reproduction, and distribution of the Work otherwise complies with
      the conditions stated in this License.
   5. Submission of Contributions. Unless You explicitly state otherwise,
      any Contribution intentionally submitted for inclusion in the Work
      by You to the Licensor shall be under the terms and conditions of
      this License, without any additional terms or conditions.
      Notwithstanding the above, nothing herein shall supersede or modify
      the terms of any separate license agreement you may have executed
      with Licensor regarding such Contributions.
   6. Trademarks. This License does not grant permission to use the trade
      names, trademarks, service marks, or product names of the Licensor,
      except as required for reasonable and customary use in describing the
      origin of the Work and reproducing the content of the NOTICE file.
   7. Disclaimer of Warranty. Unless required by applicable law or
      agreed to in writing, Licensor provides the Work (and each
      Contributor provides its Contributions) on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
      implied, including, without limitation, any warranties or conditions
      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
      PARTICULAR PURPOSE. You are solely responsible for determining the
      appropriateness of using or redistributing the Work and assume any
      risks associated with Your exercise of permissions under this License.
   8. Limitation of Liability. In no event and under no legal theory,
      whether in tort (including negligence), contract, or otherwise,
      unless required by applicable law (such as deliberate and grossly
      negligent acts) or agreed to in writing, shall any Contributor be
      liable to You for damages, including any direct, indirect, special,
      incidental, or consequential damages of any character arising as a
      result of this License or out of the use or inability to use the
      Work (including but not limited to damages for loss of goodwill,
      work stoppage, computer failure or malfunction, or any and all
      other commercial damages or losses), even if such Contributor
      has been advised of the possibility of such damages.
   9. Accepting Warranty or Additional Liability. While redistributing
      the Work or Derivative Works thereof, You may choose to offer,
      and charge a fee for, acceptance of support, warranty, indemnity,
      or other liability obligations and/or rights consistent with this
      License. However, in accepting such obligations, You may act only
      on Your own behalf and on Your sole responsibility, not on behalf
      of any other Contributor, and only if You agree to indemnify,
      defend, and hold each Contributor harmless for any liability
      incurred by, or claims asserted against, such Contributor by reason
      of your accepting any such warranty or additional liability.

19 [Public domain]                The files in this directory are released to the Public Domain.
   No more GUI
 /// LICENSE_START.19
 /// LICENSE_END.19

20 [Public domain]                CPU accelerated SHA code taken from SHA-Intrinsics
 /// LICENSE_START.20
 /// LICENSE_END.20
    github                        https://github.com/noloader/SHA-Intrinsics
	
    Copyright © 2022 Jeffrey Walton <noloader@gmail.com>
    sha1-x86.c - Intel SHA extensions using C intrinsics
    Written and place in public domain by Jeffrey Walton
    Based on code from Intel, and by Sean Gulley for
    the miTLS project.

21 [Public domain]                zpaqd v7.15 - ZPAQ compression development tool - Aug. 17, 2016.
 /// LICENSE_START.21
 /// LICENSE_END.21
	This software is provided as-is, with no warranty.
	I, Matt Mahoney, release this software into
	the public domain.   This applies worldwide.
	In some countries this may not be legally possible; if so:
	I grant anyone the right to use this software for any purpose,
	without any conditions, unless such conditions are required by law.

22 [BSD 2-Clause license]                LZ4 Copyright (C) 2011-2023, Yann Collet https://github.com/lz4/lz4
 /// LICENSE_START.22
 /// LICENSE_END.22

   BSD 2-Clause License (http://www.opensource.org/licenses/bsd-license.php)

   Redistribution and use in source and binary forms, with or without
   modification, are permitted provided that the following conditions are
   met:

       * Redistributions of source code must retain the above copyright
   notice, this list of conditions and the following disclaimer.
       * Redistributions in binary form must reproduce the above
   copyright notice, this list of conditions and the following disclaimer
   in the documentation and/or other materials provided with the
   distribution.

   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

23 [MIT License]                https://github.com/codewithnick/ascii-art
 /// LICENSE_START.23
 /// LICENSE_END.23

MIT License

Copyright (c) 2024 codewithnick

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

1. The above copyright notice and this permission notice shall be included in
   all copies or substantial portions of the Software.

2. THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
   SOFTWARE.

24 [MIT-like]           curl command line tool and library        https://curl.se/
 /// LICENSE_START.24
 /// LICENSE_END.24
COPYRIGHT AND PERMISSION NOTICE
Copyright (c) 1996 - 2025, Daniel Stenberg, daniel@haxx.se, and many contributors, see the THANKS file.
All rights reserved.
Permission to use, copy, modify, and distribute this software for any purpose with or without fee 
is hereby granted, provided that the above copyright notice and this permission notice appear in all copies.
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED 
TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT OF THIRD PARTY RIGHTS. 
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, 
WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE 
OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
Except as contained in this notice, the name of a copyright holder shall not be used in advertising or 
otherwise to promote the sale, use or other dealings in this Software without prior written 
authorization of the copyright holder.


   _____ _____  ______ ______ _______ _____ _   _  _____  _____ 
  / ____|  __ \|  ____|  ____|__   __|_   _| \ | |/ ____|/ ____|
 | |  __| |__) | |__  | |__     | |    | | |  \| | |  __| (___  
 | | |_ |  _  /|  __| |  __|    | |    | | | . ` | | |_ |\___ \ 
 | |__| | | \ \| |____| |____   | |   _| |_| |\  | |__| |____) |
  \_____|_|  \_\______|______|  |_|  |_____|_| \_|\_____|_____/ 
                                                                


 0 ****** It is worth mentioning that the initial developer, 
   ****** the one who has the most credit is
   ****** Dr. Matt Mahoney             http://mattmahoney.net
   ****** If you like zpaq technology, HE is the one to thank
 
 1 Thanks to JFLarvoire 								for usefun (yes, usefun) informations https://github.com/JFLarvoire/SysToolsLib/blob/master/C/MsvcLibX/src/readlink.c
 2 Thanks to Bulat Ziganshin 							for contribution on Slicing-by-16 for crc32
 3 Thanks to SeDD user of the encode.ru forum   		for SFX debugging
 4 Thanks to Aki  user of forums.debian.net     		for some Debian's packager help
 5 Thanks to https://github.com/dertuxmalwieder 		for testing on various Unixes and OpenBSD port
 6 Thanks to Felix Palmen <zirias@freebsd.org>  		for great help on FreeBSD "packaging"
 7 Thanks to https://github.com/omar-polo       		for a merged-unmerged-hardcoded NOJIT fix
 8 Thanks to https://github.com/Piqlet          		for non-x86 help
 9 Thanks to https://github.com/osmano807       		for non-x86 help
10 Thanks to Stephen Kitt <skitt@debian.org>    		for supporting Debian "packaging"
11 Thanks to Niels Ferguson                     		for the Twofish implementation
12 Thanks to Newcastle University						for some winsock related issues, Master Degree, Game Engineering
13 Thanks to https://github.com/akumiszcza      		for OneDrive issue
14 Thanks to https://github.com/ratay           		for help help fix, longpath
15 Thanks to https://github.com/graphixillusion 		for "lost" -vss
16 Thanks to https://discuss.haiku-os.org/u/PulkoMandy 	for Haiku help
17 Thanks to https://github.com/Bill-Gray/				for PDCursesMod
18 Thanks to https://github.com/justinormont            for the proposed Homebrew install formula for macOS and x64 Linux
19 Thanks to https://github.com/alebcay                 for coding the Homebrew install formula for macOS and x64 Linux
20 Thanks to https://github.com/ZhongRuoyu				for __linux__ instead of older #defines
21 Thanks to Coody user of encode.su					for unexistent folder bug
22 Thanks to https://github.com/ruptotus				for "hidden" overloaded fwrite() function bug, and -dryrun on robocopy fix
23 Thanks to Karl Wagner								for typo fixing and various suggestions
24 Thanks to https://github.com/Erol-2022               for Windows 7 console-bug fixing
25 Thanks to Martin Pluskal                             for OpenSUSE package
26 Thanks to Petr Pisar                                 for Fedora Package
27 Thanks to Davide Moretti                             for -home
28 Thanks to https://github.com/DetourNetworkUK         for Mac PowerPC strnlen bug
29 Thanks to Lone_Wolf (bbs.archlinux.org)              for reviewing PKGBUILD on arch
30 Thanks to Scimmia   (bbs.archlinux.org)              for reviewing PKGBUILD on arch
31 Thanks to Loqs      (bbs.archlinux.org)              for reviewing PKGBUILD on arch
32 Thanks to https://github.com/tansy                   for Slackware older compilers
33 Thanks to https://github.com/janko-js                for idea on quick collision-detector
34 Thanks to https://github.com/havocesp                for very useful ideas
35 Thanks to https://github.com/luckman212              for a refactoring-induced bug detection
36 Thanks to whiskytechfred user of the encode.su forum for truncate-touching
37 Thanks to Takayuki Matsuoka                          for LZ4 streaming API example : line-by-line logfile 
38 Thanks to whiskytechfred user of the encode.ru forum for vss filename fix
39 Thanks to https://github.com/sergeevabc              for suggestions on hash command
40 Thanks to https://github.com/gitboogey               for ideas on -test and -verify with vss
41 Thanks to https://github.com/bastiple                for -D_FORTIFY_SOURCE=3
42 Thanks to https://github.com/sheckandar              for Synology 7.1 issue
43 Thanks to https://github.com/adamantida              for improved similarity with zpaq for archives with only deletions
44 Thanks to https://github.com/kskarlatos              for giving me an idea to improve stdin support
45 Thanks to https://github.com/codewithnick            for change his license to a Fedora-friendly one
46 Thanks to https://github.com/mirogeorg               for various suggestions
47 Thanks to https://github.com/brad0                   for OpenBSD fix
48 Thanks to Carlo, Debian user                         for debugging support
49 Thanks to https://github.com/KnightAR                for -stdin bug from 60.7 to 60.8
50 Thanks to https://github.com/kskarlatos              for a very nasty bug on g++ with -tar
51 Thanks to https://github.com/forgottenbutnotgone     for a bug in crc32 blocks sorting
52 Thanks to https://github.com/197788                  for help fix
53 Thanks to https://github.com/cheebusjeebus           for "different" UTC fixes



  _____  ______          _      _  __     __   ____  _____  ______ _   _ 
 |  __ \|  ____|   /\   | |    | | \ \   / /  / __ \|  __ \|  ____| \ | |
 | |__) | |__     /  \  | |    | |  \ \_/ /  | |  | | |__) | |__  |  \| |
 |  _  /|  __|   / /\ \ | |    | |   \   /   | |  | |  ___/|  __| | . ` |
 | | \ \| |____ / ____ \| |____| |____| |    | |__| | |    | |____| |\  |
 |_|  \_\______/_/    \_\______|______|_|     \____/|_|    |______|_| \_|
                                                                         

`zpaqfranz` is **fully open source**. 
All its components (including binary SFX modules) 
are published on GitHub and can be rebuilt from source.

Here's the "spiegone"
https://github.com/fcorbelli/zpaqfranz/wiki/Security:-open-software


                _____ _   _  _____ _______       _      _
               |_   _| \ | |/ ____|__   __|/\   | |    | |
                 | | |  \| | (___    | |  /  \  | |    | |
                 | | | . ` |\___ \   | | / /\ \ | |    | |
                _| |_| |\  |____) |  | |/ ____ \| |____| |____
               |_____|_| \_|_____/   |_/_/    \_\______|______|


===============================================================================
[1] Fastest: 	binary packages (sometimes not the most updated)
OpenBSD: 		pkg_add zpaqfranz
FreeBSD: 		pkg install zpaqfranz
MacOS: 			brew install zpaqfranz  (same for Ubuntu 20 x64)
OpenSUSE:       sudo zypper install zpaqfranz
===============================================================================


===============================================================================
[2] Very fast: 	browse binary packages for various platform (almost the latest)
Sourceforge:	https://sourceforge.net/projects/zpaqfranz/files/
===============================================================================


===============================================================================
[3] Quick and dirty: download Makefile and source code from github
(pre-requisite: working C++ compiler like g++ or clang, make, wget)

```
wget https://github.com/fcorbelli/zpaqfranz/raw/main/zpaqfranz.cpp
wget https://github.com/fcorbelli/zpaqfranz/raw/main/NONWINDOWS/Makefile
make install clean
```

WARNING: the Makefile is almost "universal",
BUT
beware of path: sometimes you need to fix /usr/local/bin to /usr/bin
in the line BINDIR=, it is the prefix

```
wget http://www.francocorbelli.it/Makefile -O Makefile
```

Why cc for a C++ file? LSS ancient-backward-compatibility
This is therefore a "micro makefile" that you can try if you 
can't use the full one, but it essentially works only 
on modern versions of Linux, not on older ones.


CC?=            cc
INSTALL?=       install
RM?=            rm
PROG=           zpaqfranz
CFLAGS+=        -O3 -Dunix
LDADD=          -pthread -lstdc++ -lm
BINDIR=         /usr/local/bin
BSD_INSTALL_PROGRAM?=   install -m 0555

all:    build

build:  ${PROG}

install:        ${PROG}
	${BSD_INSTALL_PROGRAM} ${PROG} ${DESTDIR}${BINDIR}

${PROG}:        ${OBJECTS}
	${CC}  ${CFLAGS} zpaqfranz.cpp -o ${PROG} ${LDADD}
clean:
	${RM} -f ${PROG}

===============================================================================


===============================================================================
[4] The Makefile

A universal Makefile is impossible, especially with older systems. 
If you’re using reasonably modern operating systems, 
you can try the fairly complete Makefile I’ve provided here.

https://github.com/fcorbelli/zpaqfranz/blob/main/Makefile 
===============================================================================


===============================================================================
[5] Dirtiest (!), the "nightly build"
(pre-requisite: working C++ compiler like g++ or clang, wget, NO MAKE NEEDED)

*** WARNING This version is practically the n-1,
*** may contain experimental code, compilation incompatibilities etc.
*** Almost the bleeding edge
```
wget http://www.francocorbelli.it/zpaqfranz.cpp -O zpaqfranz.cpp
```

then... build (aka: compile)


  _    _  ______          __  _______ ____    ____  _    _ _____ _      _____
 | |  | |/ __ \ \        / / |__   __/ __ \  |  _ \| |  | |_   _| |    |  __ \
 | |__| | |  | \ \  /\  / /     | | | |  | | | |_) | |  | | | | | |    | |  | |
 |  __  | |  | |\ \/  \/ /      | | | |  | | |  _ <| |  | | | | | |    | |  | |
 | |  | | |__| | \  /\  /       | | | |__| | | |_) | |__| |_| |_| |____| |__| |
 |_|  |_|\____/   \/  \/        |_|  \____/  |____/ \____/|_____|______|_____/



My main development platforms are AMD Windows
(non-Intel Windows (arm) currently unsupported) 
and Intel FreeBSD.

I rarely use Linux or MacOS or whatever (for compiling),
so fixing may be needed.

As explained the program is single file, be careful to link the pthread library.
You need it for ESXi too, even if it doesn't work. Don't be afraid, zpaqfranz knows!

Library dependencies are minimal:   libc,libc++,libcxxrt,libm,libgcc_s,libthr

DEFINEs at compile-time: IT IS UP TO YOU NOT TO MIX LOGICAL INCOMPATIBLE DEFINITIONS!

(nothing)							// Compile for INTEL Windows
-DHWBLAKE3 blake3_windows_gnu.S		// On Win64 enable HW accelerated BLAKE3 (with assembly)
-DHWSHA1							// On Win64 enable HW SHA1 (-flaghw)
-DHWSHA2							// Enable HW SHA2 (without assembly code to be linked)
-Dunix 								// Compile on "something different from Windows" (obsolete)
-DSOLARIS        					// Solaris is similar, but not equal, to BSD Unix

-DNOJIT								// By default zpaqfranz works on Intel CPUs
									// (for simplicity I'll call them Intel, meaning x86-SSE2 and amd64)
									// On non-Intel a -NOJIT should runs fine on LITTLE ENDIANs
									// like Linux aarch64, Android aarch64 etc
									// On BIG ENDIAN or "strange things" like middle endian
									// (Honeywell 316) or little word (PDP-11)
									// the autotest command is for you :)
									// https://gcc.gnu.org/legacy-ml/gcc-help/2007-07/msg00343.html
									
									// From 60.9s if compiled without -DNOJIT there is a switch -nojit
									// Translation: even if you have an executable compiled with default
									// you can turn off the JIT

-DANCIENT							// Turn off some functions for compiling in very old systems
									// consuming less RAM (ex. PowerPC Mac, Synology 7.1), no auto C++

-DNAS								// Like ANCIENT, but a bit less stringent (ex. Synology 7.2)

-DBIG								// Turn on BIG ENDIAN at compile time

-DDEBUG								// Old 7.15, almost useless (turn on asserts). Use -debug(s) switches instead

-DESX								// Yes, zpaqfranz run (kind of) on ESXi too :-)

-DALIGNMALLOC 						// Force malloc to be aligned at something (sparc64). Use naive CRC-32
	
-DIPV6								// Do not force IPv4 (the current default)

#ifdef ZPAQFULL ///NOSFTPSTART
-DSFTP								// Enable SFTP support via curl (needs the library!)

-DOPEN								// Strips the executable of all non-immediately analyzable components, 
									// disables temporary file creation, restricts potentially dangerous functions 
									// such as library loading and file deletion

#endif ///NOSFTPEND

-DNOLM								// Turn off the lm library (experimental)

HIDDEN GEMS
If the (non Windows) executable is named "dir" act (just about)... like Windows' dir
Beware of collisions with other software "dir"

If the (non Windows) executable is named "robocopy" runs... some kind of robocopy-like.
ex robocopy /tmp/zp /tmp/backup1 /tmp/backup2
BEWARE: those are WET RUNS (-kill automagically enabled), with -space enabled!


WARNINGS
Some strange warnings with some compilers (too old, or too new), not MY fault

My very own reporting
https://gcc.gnu.org/bugzilla/show_bug.cgi?id=101558

Original bug
https://gcc.gnu.org/bugzilla/show_bug.cgi?id=96963


STRANGE THINGS (FAQ)

NOTE1: -, not -- (into switch)

NOTE2: switches ARE case sensitive.   -maxsize <> -MAXSIZE

THE JIT (just-in-time)
zpaqfranz translate (by default) ZPAQL opcodes into "real" Intel (amd64 or x86+SSE2) machine code.
On other systems a -DNOJIT (ARM/Apple CPUs for example) will enforce software interpretation.
I write it BIG, #1 FAQ with newer Macintosh (M1/M2) is forgetting -DNOJIT

  _   _  ___  _   _   ___ _   _ _____ _____ _           __          ____  _   _  ___      _ ___ _____ 
 | \ | |/ _ \| \ | | |_ _| \ | |_   _| ____| |      ____\ \        |  _ \| \ | |/ _ \    | |_ _|_   _|
 |  \| | | | |  \| |  | ||  \| | | | |  _| | |     |_____\ \  _____| | | |  \| | | | |_  | || |  | |  
 | |\  | |_| | |\  |  | || |\  | | | | |___| |___  |_____/ / |_____| |_| | |\  | |_| | |_| || |  | |  
 |_| \_|\___/|_| \_| |___|_| \_| |_| |_____|_____|      /_/        |____/|_| \_|\___/ \___/|___| |_|  
                                                                                                      
Starting from version 60.9, the same zpaqfranz code is used even if compiled **without** `-DNOJIT`. 
In this case, you can disable it with the `-nojit` switch. 
Remember that JIT availability does not affect or slow down **compression** but has 
a significant impact on **decompression**.

To summarize: If you’re sure your system does not support JIT (for example Apple silicon), 
compile with `-DNOJIT` as before.
Otherwise, compile: zpaqfranz will "automagically" turn on -nojit if CPU (or OS) is not OK. 
If, during extraction, the process fails because the JIT is kaputt,
add the `-nojit` switch (e.g., zpaqfranz x z:\pippo.zpaq -to z:\ugo -nojit).

Why this change? Because there are Intel platforms (which do support JIT) 
where executing code from allocated memory is not allowed for security reasons. 
Classic examples include certain BSD types (OpenBSD, NetBSD...). 
In such cases, even if the CPU is compatible, the operating system is not.
Not my fault :)


SHA-1 HARDWARE ACCELERATION
Some CPUs does have SHA instructions (typically AMD, not very widespread on Intel).
So you can use a piece of 7-zip by Igor Pavlov (I am sure you know 7z) that is
not really useful, but just for fun (faster BUT with higher latency).
For performances reason, no run-time CPU compatibility checks, must be turn on
via optional -hw switch
On AMD 5950X runs ~1.86 GB/s vs ~951 MB/s
The obj can be assembled from the fixed source code with asmc64
https://github.com/nidud/asmc
asmc64.exe sha1ugo.asm
Then link the .obj and compile with -DHWSHA1
Short version:  not worth the effort for the GA release
From build 58+ there is a new -DHWSHA2, without linking of asm, that accelerate SHA256 too.

STATIC LINKING
I like -static very much, there are a thousand arguments as to whether it is good or not.
There are strengths and weaknesses.
Normally I prefer it, you do as you prefer.

TO BE NATIVE OR NOT TO BE?
The -march=native  is a switch that asks the compiler to activate all possible
optimizations for the CPU on which zpaqfranz is being compiled.
This is to obtain the maximum possible performance,
while binding the executable to the processor.
It should not be used if you intend, for some reason,
to transfer the object program to a different system.
If you are compiling from source you can safely use it.
BTW on my PC native is faster in benchmark, but slower in real-world compression (!).

CLANG OR GCC?
It is hard to choose between these two compilers. 
I generally prefer gcc for better performance. 
However, this is not true all the time; it depends on a thousand things, including the CPU type. 
For example on Arch and AMD 7950, running inside VM,
clang 17.0.6 (4992) is much faster than gcc 14.1.1 (4584).
BUT with -march=native
gcc 14.1.1 (5595) is way faster clang 17.0.6 (5044)

Short version: test yourself. 
The b (benchmark) command is there for you.

-O2 or -O3
Who knows. Try yourself :)

OTHER COMPILERS
I do not know. Try yourself :)

*NIX AND DOUBLE QUOTES
Please, on non-Windows systems, DO NOT FORGET THE DOUBLE QUOTES, 
especially with multipart files.
"test_????.zpaq" is good
test_????.zpaq   is BAD


#ifdef ZPAQFULL ///NOSFTPSTART
SFTP AND LIBCURL
If you define -DSFTP during compilation, the program will dynamically use the 
libcurl library, if it is available. 
On Windows systems, this refers to the libcurl-x64.dll/libcurl.dll. 
This DLL can be downloaded from the author's website simply by running zpaqfranz sftp. 
For *nix systems, it is typically named libcurl.so (or something similar) and must be 
installed manually, for example, using pkg add libcurl (on FreeBSD) or equivalent commands. 
If it cannot be made to work, zpaqfranz will return an error.
On *nix systems, the location of libcurl.so might not be known: there are many different systems, 
and it can be found almost anywhere. 
Therefore, you need to ensure it is in the current path

Usually libcurl can be installed with something like

debian:         apt install libcurl
red hat/centos: yum install libcurl
fedora:         dnf install libcurl
suse:           zypper install libcurl4
FreeBSD:        pkg install curl
OpenBSD:        doas pkg_add curl
NetBSD:         pkgin install curl
MacOS:          brew install curl
Arch:           pacman -S curl
Gentoo:         emerge --ask net-misc/curl
Slackware:      slackpkg install curl
Void:           xbps-install -S curl
Alpine:         apk add curl
OpenIndiana:    pkg install library/curl
Solaris:        pkg install curl
Haiku:          pkgman install curl
Clear Linux:    swupd bundle-add curl

It's up to you

*** BUT REMEMBER: DO *NOT* USE -static WITH -DSFTP ON *NIX ***
*** BUT REMEMBER: DO *NOT* USE -static WITH -DSFTP ON *NIX ***
*** BUT REMEMBER: DO *NOT* USE -static WITH -DSFTP ON *NIX ***
#endif ///NOSFTPEND


	
NOTE: from 59_3 you need to link urlmon (with a -lurlmon) on Windows

TARGET EXAMPLES
```
Windows 64 (g++ 7.3.0)
g++ -O3  zpaqfranz.cpp -o zpaqfranz -lurlmon

Windows 64 (g++ 10.3.0) MSYS2
g++ -O3  zpaqfranz.cpp -o zpaqfranz -pthread -static -lurlmon

Windows 64 (g++, Hardware Blake3 implementation)
In this case, of course, linking the .S file is mandatory
g++ -O3 -DHWBLAKE3 blake3_windows_gnu.S zpaqfranz.cpp -o zpaqfranz -pthread -static -lurlmon

Windows 64 (g++, Hardware Blake3 implementation PLUS HW SHA1)
g++ -O3 -DHWBLAKE3 -DHWSHA1 blake3_windows_gnu.s zpaqfranz.cpp sha1ugo.obj -o zpaqfranzhw -pthread -static -lurlmon

Windows 64 (g++, Hardware Blake3 implementation PLUS HW SHA1/2)
g++ -O3 -DHWBLAKE3 -DHWSHA2 blake3_windows_gnu.s zpaqfranz.cpp -o zpaqfranzhw -pthread -static -lurlmon

Windows 64 (g++, Hardware Blake3 implementation PLUS HW SHA1/2)
g++ -O3 -DHWBLAKE3 -DHWSHA2 blake3_windows_gnu.s zpaqfranz.cpp -o zpaqfranzhw -pthread -static -s -lurlmon

Windows 32 (g++ 7.3.0 64 bit)
c:\mingw32\bin\g++ -m32 -O3 zpaqfranz.cpp -o zpaqfranz32 -pthread -static -lurlmon

Windows 64 (g++ 7.3.0), WITH cloud paq
g++ -O3 -DSERVER zpaqfranz.cpp -o zpaqfranz -lwsock32 -lws2_32 -lurlmon

#ifdef ZPAQFULL ///NOSFTPSTART
Windows 64 (g++ 7.3.0) WITH SFTP (everything)
g++ -O3 -DSFTP -DHWSHA2 zpaqfranz.cpp -o zpaqfranz -Wunused-parameter -Wall -Wextra -pedantic -lwsock32 -lws2_32 -lurlmon -IC:/zpaqfranz/libcurl/include 
#endif ///NOSFTPEND

FreeBSD (11.x) gcc 7
gcc7 -O3 -Dunix zpaqfranz.cpp -lstdc++ -pthread -o zpaqfranz -static -lm

FreeBSD (12.1) gcc 9.3.0
g++ -O3 -Dunix zpaqfranz.cpp  -pthread -o zpaqfranz -static-libstdc++ -static-libgcc

FreeBSD (11.4) gcc 10.2.0
g++ -O3 -Dunix zpaqfranz.cpp  -pthread -o zpaqfranz -static-libstdc++ -static-libgcc -Wno-stringop-overflow

FreeBSD (11.3) clang 6.0.0
clang++ -O3 -Dunix zpaqfranz.cpp  -pthread -o zpaqfranz -static

OpenBSD 6.6 clang++ 8.0.1
OpenBSD 7.1 clang++ 13.0.0
WARNING: with very old g++ compiler try -DANCIENT
****
Please note: you can get memory error, without -DNOJIT, on "strange" (non FreeBSD) machines
because mmap does not like PROT_EXEC. On newer zpaqfranz use -nojit switch
****
clang++ -Dunix -O3 zpaqfranz.cpp -o zpaqfranz -pthread -static

Arch Linux
I made a little AUR package (with some help), this one
https://aur.archlinux.org/packages/zpaqfranz-git
Should be good enough

For a fresh Manjaro 24.0.3 installation I suggest

sudo pacman -Sy
sudo pacman -S gcc (or sudo pacman -S clang)
sudo pacman -S fakeroot
sudo pacman -S yay
yay zpaqfranz

Answers to yay
Packages to install ==> 1
Packages to cleanBuild ==> A
Diffs to show? ==> N
Proceed with installation => y
(insert sudo password)

Debian Linux (10/11) gcc 8.3.0
ubuntu 21.04 desktop-amd64 gcc  10.3.0
manjaro 21.07 gcc 11.1.0
g++ -O3 -Dunix zpaqfranz.cpp  -pthread -o zpaqfranz -static

QNAP NAS TS-431P3 (Annapurna AL314) gcc 7.4.0
g++ -Dunix zpaqfranz.cpp  -pthread -o zpaqfranz -Wno-psabi

Fedora 34 gcc 11.2.1
Typically you will need some library (out of a fresh Fedora box)
sudo dnf install glibc-static libstdc++-static -y;
Then you can compile, via Makefile or "by hand"
(do not forget... sudo!)

CentoOS
Please note:
"Red Hat discourages the use of static linking for security reasons.
Use static linking only when necessary, especially against libraries provided by Red Hat. "
Therefore a -static linking is often a nightmare on CentOS => change the Makefile
g++ -O3 -Dunix zpaqfranz.cpp  -pthread -o zpaqfranz

Solaris 11.4 gcc 7.3.0
OmniOS r151042 gcc 7.5.0
Beware: -DSOLARIS and some different linking options
g++ -O3 -DSOLARIS zpaqfranz.cpp -o zpaqfranz  -pthread -static-libgcc -lkstat

MacOS 11.0 gcc (clang) 12.0.5, INTEL
MacOS 12.6 gcc (clang) 13.1.6, INTEL
MacOS 12.7 gcc (clang) 14.0.0, INTEL
Please note:
No -static here
"Apple does not support statically linked binaries on Mac OS X.
(...) Rather, we strive to ensure binary
compatibility in each dynamically linked system library and framework
(AHAHAHAHAHAH, note by me)
Warning: Shipping a statically linked binary entails a significant compatibility risk.
We strongly recommend that you not do this..."
Short version: Apple does not like -static
g++ -Dunix -O3 zpaqfranz.cpp -o zpaqfranz -pthread
If you want to enable all kind of warnings, turn on c++11.
Apple, by default, does NOT like "long long", at all.
As I have explained several times, I had to make compromises, such as the C++17 warnings.
g++ -Dunix -O3 zpaqfranz.cpp -o zpaqfranz -pthread -std=c++11 -Wall -Wpedantic

Mac PowerPC with gcc4.x
Look at -DBIG (for BIG ENDIAN) and -DANCIENT (old-compiler)
g++ -O3 -DBIG -DANCIENT -Dunix -DNOJIT zpaqfranz.cpp -o zpaqfranz -pthread

Apple Macintosh (M1/M2)
DO NOT FORGET THE -DNOJIT!!!!!
g++ -Dunix  -O3 -DNOJIT zpaqfranz.cpp -o zpaqfranz -pthread

ESXi (gcc 3.4.6)
Note: not fully developed ( extract() with minimum RAM need to be implemented )
g++ -O3 -DESX zpaqfranz.cpp -o zpaqfranz6  -pthread -static -s

sparc64 (not tested)
try
-DALIGNMALLOC (+ other switches)

Haiku R1/beta4, 64 bit (gcc 11.2.0), hrev56721
Not very tested
g++ -O3 -Dunix zpaqfranz.cpp -o zpaqfranz  -pthread -static

Slackware 12.0 (32 bit)
gcc 4.1.2
g++ -O3 -DANCIENT -Dunix zpaqfranz.cpp -o zpaqfranz -pthread

Slackware64 14.0
gcc 5.3.0
clang 3.8.0
g++ -O3 -Dunix zpaqfranz.cpp -o zpaqfranz -pthread -std=c++11
clang++ -O3 -Dunix zpaqfranz.cpp -o zpaqfranz -pthread -std=c++11

Slackware64 15.0
gcc 11.2.0
g++ -O3 -Dunix zpaqfranz.cpp -o zpaqfranz -pthread -lstdc++ -lm
clang 13.0.0
clang++ -O3 -Dunix zpaqfranz.cpp -o zpaqfranz -pthread

Debian 7 (wheezy) on PowerPC
gcc 4.9.1
g++ -O3 -Dunix -DBIG -DNOJIT zpaqfranz.cpp -o zpaqfranz -pthread -std=c++11

Debian 11 cross compiling to QNAP's arm
gcc 10.2.1
apt-get install gcc-arm-linux-gnueabihf
apt-get install g++-arm-linux-gnueabihf
arm-linux-gnueabihf-gcc
arm-linux-gnueabihf-g++

arm-linux-gnueabihf-g++ -O3 -DNOJIT -DANCIENT zpaqfranz.cpp -o zpaqqnapv8 -static -pthread -s -Wno-psabi


DragonFlyBSD 6.4.0
gcc 8.3
****
Please note: you can get memory error, without -DNOJIT, on "strange" (non FreeBSD) machines
****
g++ -Dunix -O3 zpaqfranz.cpp -o zpaqfranz -pthread -static

NetBSD 10
gcc 10.5.0
****
Please note: you can get memory error, without -DNOJIT, on "strange" (non FreeBSD) machines
****
g++ -DHWSHA2 -Dunix -O3 zpaqfranz.cpp -o zpaqfranz -pthread -static


HPPA gcc version 14.2.0 (Debian 14.2.0-8)
This type of CPU is quite particular, often requiring memory alignment, 
which is not very compatible with the CRC-32 calculation function using 16-byte slices. 
In this case, the "classic" algorithm is used, much slower but expected to work. 
I don't have access to hardware for thorough testing.
g++ -O3 -DBIG -DALIGNMALLOC zpaqfranz.cpp -o zpaqfranz -pthread

PowerPC (Debian gcc 4.9.1)
g++ -O3 -DBIG -DANCIENT zpaqfranz.cpp -o zpaqfranz -pthread -static -s

Alpine Linux
Sorry, cannot make pthread work
Just run with -t1 (aka: multithread is disabled)

Windows XP 
Newer zpaqfranz32.exe (>=60.10) more or less works on XP
Please do not use "strange" things (ADS & whatever)

Rockylinux 9
gcc 11.5.0
g++ -O3 zpaqfranz.cpp -o zpaqfranz -pthread

#ifdef ZPAQFULL ///NOSFTPSTART
Debian with SFTP and libcurl
This gets a DYNAMIC LOADING of curl library: you must have (somewhere) a libcurl.so!
g++ -O3 -DSFTP -DHWSHA2 zpaqfranz.cpp -o zpaqfranz  -pthread -s -ldl -Wall -Wpedantic
///NOSFTPEND

Beware of #definitions
g++ -dM -E - < /dev/null
sometimes __sun, sometimes not







///NOSFTPSTART

      _______ ______  _____ _______   ______ _____ _      ______ 
     |__   __|  ____|/ ____|__   __| |  ____|_   _| |    |  ____|
        | |  | |__  | (___    | |    | |__    | | | |    | |__   
        | |  |  __|  \___ \   | |    |  __|   | | | |    |  __|  
        | |  | |____ ____) |  | |    | |     _| |_| |____| |____ 
        |_|  |______|_____/   |_|    |_|    |_____|______|______|
                                                                                     

https://github.com/fcorbelli/zpaqfranz/tree/main/AUTOTEST

zpaqfranz has an internal self-testing mechanism, aimed at 'strange' systems, 
i.e. with CPUs operating differently from Intel, such as Apple M1, M2, 
PowerPC, sparc, ARM, BIG endians and so on.

The command autotest -to extracts a binary file, 
contained within the source, a (Windows-created) .zpaq archive 
for check whether the PAQL code (during extraction) is well processed.

It is essentially an interoperability test between Windows 
(taken as a known good-working model) and the "weird" host system.

It is packed with 256 "shuffled" pieces of the Iliade
https://www.rodoni.ch/busoni/bibliotechina/nuovifiles/iliade_h/testo.htm

Cantami, o Diva, del Pelide Achille
l'ira funesta che infiniti addusse
lutti agli Achei, molte anzi tempo all'Orco
generose travolse alme d'eroi...

From version 55.16, instead of using deduplicated pseudorandom files, 
I preferred plaintext, in order to dispel any doubts about the contents of 
the binary archive: the theoretical coverage is minor, but it does not matter.

The resulting archive (sha256.zpaq), compressed by -m5 on Windows,
with every filenames == SHA-256(content),
is mime64-encoded and "splitted" into 4 strings,
becoming (inside the source code)

char extract_test1[]={"N2tT...
char extract_test2[]={"W1hY...
char extract_test3[]={"+Au5...
char extract_test4[]={"sFPj...

It is quickly possible to double-check this way (just in case...)

zpaqfranz autotest -to somewhere
zpaqfranz x somewhere/sha256.zpaq -to extracted

The sha256.zpaq should be this one
SHA-256: D90223FAEE2878D7854B9438864B4856A3C1F920C34EFB8C136A8949B54E5400 [            158.239]     sha256.zpaq

With these files inside
SHA-256: 00D478184C1851145A712B8054D04789DA164CDEE61EDB2240F124E0AC3501AA [             37.000]     00D478184C1851145A712B8054D04789DA164CDEE61EDB2240F124E0AC3501AA
(...)
SHA-256: FCCE109C8360963EB18975B94BDBE434BE1A49D3F53BDD768A99093B3EB838D2 [             37.000]     FCCE109C8360963EB18975B94BDBE434BE1A49D3F53BDD768A99093B3EB838D2


From branch 63 you can strip everything, losing the autotest capabilities of course.

///NOSFTPEND

Fixer build
g++ -g -Wall -Wextra -Wpedantic -fsanitize=address,undefined -O3 zpaqfranz.cpp -o fixed  
*/

/*
	Here start the program.
	
	zpaqfranz can use a backwards compatible archive format, using various "packages"
	Each FRANZOFFSET occupies, for each archived file, a certain space,
	upto ~500 bytes, but they are still compressed, so there is less waste

	V1 (little overhead) is the default
	V2 (up to zpaqfranz 56) is for extended hashes, like sha-3
	V3 (from zpaqfranz 57+) is variable-sized in two
	"flavours": 190 bytes and 550.
	The shorter allows very long hashes (e.g. whirlpool),
	the bigger also contains a TAR-like format for storing
	symlinks (and other information)
*/

#define FRANZOFFSETV1 		50
#define FRANZOFFSETV2 		76
#define FRANZOFFSETV3 		550 // 190 + 360 posix
#define FRANZMAXPATH 		240

#define STRINGIFY(x) 			#x
#define TOSTRING(x)  			STRINGIFY(x)
/*
	FRANZO_SOMETHING can be used inside zpaq archive
	ALGO_SOMETHING   cannot (just for the sum command)
*/
#define FRANZO_NONE				0
#define FRANZO_CRC_32 			1
#define	FRANZO_XXHASH64			2 
#define FRANZO_SHA_1			3 
#define FRANZO_SHA_256			4 
#define	FRANZO_XXH3				5 
#define	FRANZO_BLAKE3			6 
#define FRANZO_SHA3				7 
#define FRANZO_MD5				8 
#define FRANZO_WINHASH64		9
#define FRANZO_WHIRLPOOL		10
#define FRANZO_HIGHWAY64		11
#define FRANZO_HIGHWAY128		12
#define FRANZO_HIGHWAY256		13

#define FRANZO_XXHASH64B		14
#define FRANZO_MD5B				15
#define FRANZO_BLAKE3B			16
#define FRANZO_SHA_256B			17
#define FRANZO_SHA3B			18
#define FRANZO_XXH3B			19
#define FRANZO_SHA_1B			20

#define ALGO_CRC32C			100
#define ALGO_WYHASH			101
#define ALGO_NILSIMSA		103
#define ALGO_ENTROPY		104
#define ALGO_QUICK			105
#define ALGO_ZETA			106
#define ALGO_ZETAENC		107


#define _FILE_OFFSET_BITS 64  // In Linux make sizeof(off_t) == 8. Define BEFORE including windows.h!!!
#ifndef UNICODE
	#define UNICODE  // For Windows
#endif // corresponds to #ifndef (#ifndef UNICODE)
#ifndef DEBUG
	#define NDEBUG 1
#endif // corresponds to #ifndef (#ifndef DEBUG)
#if defined(SOLARIS) || defined(__unix__) || (defined(__APPLE__) && defined(__MACH__))
	#ifndef unix
		#define unix 1
	#endif // corresponds to #ifndef (#ifndef unix)
#endif // corresponds to #if (#if defined(SOLARIS) || defined(__unix__) || (defined(__APPLE__) && defined(__MACH__)))

#ifdef IPV6
    #include <sys/types.h>
    #include <sys/socket.h>
    #include <netdb.h>
#endif // corresponds to #ifdef (#ifdef IPV6)


#ifdef UNIX
	#define unix 1
#endif // corresponds to #ifdef (#ifdef UNIX)

#ifdef unix
	#ifndef ANCIENT
		#include <array>
		#include <signal.h> /// alpine
	#endif // corresponds to #ifndef (#ifndef ANCIENT)
	#if defined(SOLARIS)
		#include <kstat.h>
	#endif // corresponds to #if (#if defined(SOLARIS))
	#if defined(__linux__) || defined(SOLARIS)
		#include <sys/statvfs.h>
	#endif // corresponds to #if (#if defined(__linux__) || defined(SOLARIS))
	#if defined(__linux__)
		#include <mntent.h>
	#endif // corresponds to #if (#if defined(__linux__))
	#include <algorithm>
	#include <assert.h>
	#include <cstddef>
	#include <cstdio>
	#include <dirent.h>
	#include <fcntl.h>
	#include <iostream>
	#include <map>
	#include <math.h>
	#include <memory>
	#include <pthread.h>
	#include <set>
	#include <stdarg.h>
	#include <stdexcept>
	#include <stdio.h>
	#include <stdint.h>
	#include <string.h>
	#include <string>
	#include <sys/ioctl.h>
	#include <sys/mman.h>

	#include <pwd.h>
	#include <grp.h>
	#include <utime.h>

	
#ifndef __HAIKU__
	#include <sys/mount.h>
#endif // corresponds to #ifndef (#ifndef __HAIKU__)
#ifdef __HAIKU__
	#include <OS.h>
#endif // corresponds to #ifdef (#ifdef __HAIKU__)
	#include <sys/param.h>
	#include <sys/stat.h>
	#include <sys/time.h>
	#include <sys/times.h>
	#include <sys/types.h>
	#include <sys/utsname.h>
	#include <termios.h>
	#include <time.h>
	#include <unistd.h>
	#include <utime.h>
	#include <vector>
	#ifdef BSD
		#include <sys/sysctl.h>
		#include <sys/mount.h>
	#endif // corresponds to #ifdef (#ifdef BSD)
	
	#include <netinet/in.h>
	#include <sys/socket.h>
	#include <netdb.h>
	#include <dlfcn.h>


#ifdef ZPAQFULL ///NOSFTPSTART
#ifdef SFTP
	#include <queue>
	#include <condition_variable>
#endif
#endif ///NOSFTPEND

#else  // Assume Windows
	#include <mutex>

	#include <assert.h>
	#include <time.h>
	#include <pthread.h>
	#include <math.h>
	#include <stdio.h>
	#include <stdint.h>
	#include <string.h>
	#include <unistd.h>
	#include <algorithm>
	#include <string>
	#include <vector>
	#include <map>
	#include <set>
	#include <stdexcept>
	#include <cstddef>
	#include <conio.h>
	#include <windows.h>
	#include <io.h>
	#include <sys/stat.h>
	#include <fcntl.h> // for setmode()
	#include <aclapi.h>
	#include <sddl.h>
	#include <cwctype> // For std::towlower
	#include <queue>

	using namespace std;
#endif // corresponds to #ifdef (#ifdef unix)

#ifdef ZPAQFULL ///NOSFTPSTART
///sed "/^[[:space:]]*$/d" 2.cpp > 3.cpp
/// LICENSE_START.24

#ifdef SFTP
/***************************************************************************
 *                                  _   _ ____  _
 *  Project                     ___| | | |  _ \| |
 *                             / __| | | | |_) | |
 *                            | (__| |_| |  _ <| |___
 *                             \___|\___/|_| \_\_____|
 *
 * Copyright (C) Daniel Stenberg, <daniel@haxx.se>, et al.
 *
 * This software is licensed as described in the file COPYING, which
 * you should have received as part of this distribution. The terms
 * are also available at https://curl.se/docs/copyright.html.
 *
 * You may opt to use, copy, modify, merge, publish, distribute and/or sell
 * copies of the Software, and permit persons to whom the Software is
 * furnished to do so, under the terms of the COPYING file.
 *
 * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
 * KIND, either express or implied.
 *
 * SPDX-License-Identifier: curl
 *
 ***************************************************************************/

/*
 * If you have libcurl problems, all docs and details are found here:
 *   https://curl.se/libcurl/
 */
 
/// This is a bit reworked header

#if (defined(__GNUC__) &&                                              \
  ((__GNUC__ > 12) || ((__GNUC__ == 12) && (__GNUC_MINOR__ >= 1))) ||  \
  (defined(__clang__) && __clang_major__ >= 3) ||                      \
  defined(__IAR_SYSTEMS_ICC__)) &&                                     \
  !defined(__INTEL_COMPILER) &&                                        \
  !defined(CURL_DISABLE_DEPRECATION) && !defined(BUILDING_LIBCURL)
#define CURL_DEPRECATED(version, message)                       \
  __attribute__((deprecated("since " # version ". " message)))
#if defined(__IAR_SYSTEMS_ICC__)
#define CURL_IGNORE_DEPRECATION(statements) \
      _Pragma("diag_suppress=Pe1444") \
      statements \
      _Pragma("diag_default=Pe1444")
#else
#define CURL_IGNORE_DEPRECATION(statements) \
      _Pragma("GCC diagnostic push") \
      _Pragma("GCC diagnostic ignored \"-Wdeprecated-declarations\"") \
      statements \
      _Pragma("GCC diagnostic pop")
#endif
#else
#define CURL_DEPRECATED(version, message)
#define CURL_IGNORE_DEPRECATION(statements)     statements
#endif
#ifndef CURLINC_SYSTEM_H
#define CURLINC_SYSTEM_H
#if defined(__DJGPP__) || defined(__GO32__)
#  if defined(__DJGPP__) && (__DJGPP__ > 1)
#    define CURL_TYPEOF_CURL_OFF_T     long long
#    define CURL_FORMAT_CURL_OFF_T     "lld"
#    define CURL_FORMAT_CURL_OFF_TU    "llu"
#    define CURL_SUFFIX_CURL_OFF_T     LL
#    define CURL_SUFFIX_CURL_OFF_TU    ULL
#  else
#    define CURL_TYPEOF_CURL_OFF_T     long
#    define CURL_FORMAT_CURL_OFF_T     "ld"
#    define CURL_FORMAT_CURL_OFF_TU    "lu"
#    define CURL_SUFFIX_CURL_OFF_T     L
#    define CURL_SUFFIX_CURL_OFF_TU    UL
#  endif
#  define CURL_TYPEOF_CURL_SOCKLEN_T int
#elif defined(__SALFORDC__)
#  define CURL_TYPEOF_CURL_OFF_T     long
#  define CURL_FORMAT_CURL_OFF_T     "ld"
#  define CURL_FORMAT_CURL_OFF_TU    "lu"
#  define CURL_SUFFIX_CURL_OFF_T     L
#  define CURL_SUFFIX_CURL_OFF_TU    UL
#  define CURL_TYPEOF_CURL_SOCKLEN_T int
#elif defined(__BORLANDC__)
#  if (__BORLANDC__ < 0x520)
#    define CURL_TYPEOF_CURL_OFF_T     long
#    define CURL_FORMAT_CURL_OFF_T     "ld"
#    define CURL_FORMAT_CURL_OFF_TU    "lu"
#    define CURL_SUFFIX_CURL_OFF_T     L
#    define CURL_SUFFIX_CURL_OFF_TU    UL
#  else
#    define CURL_TYPEOF_CURL_OFF_T     __int64
#    define CURL_FORMAT_CURL_OFF_T     "I64d"
#    define CURL_FORMAT_CURL_OFF_TU    "I64u"
#    define CURL_SUFFIX_CURL_OFF_T     i64
#    define CURL_SUFFIX_CURL_OFF_TU    ui64
#  endif
#  define CURL_TYPEOF_CURL_SOCKLEN_T int
#elif defined(__TURBOC__)
#  define CURL_TYPEOF_CURL_OFF_T     long
#  define CURL_FORMAT_CURL_OFF_T     "ld"
#  define CURL_FORMAT_CURL_OFF_TU    "lu"
#  define CURL_SUFFIX_CURL_OFF_T     L
#  define CURL_SUFFIX_CURL_OFF_TU    UL
#  define CURL_TYPEOF_CURL_SOCKLEN_T int
#elif defined(__POCC__)
#  if (__POCC__ < 280)
#    define CURL_TYPEOF_CURL_OFF_T     long
#    define CURL_FORMAT_CURL_OFF_T     "ld"
#    define CURL_FORMAT_CURL_OFF_TU    "lu"
#    define CURL_SUFFIX_CURL_OFF_T     L
#    define CURL_SUFFIX_CURL_OFF_TU    UL
#  elif defined(_MSC_VER)
#    define CURL_TYPEOF_CURL_OFF_T     __int64
#    define CURL_FORMAT_CURL_OFF_T     "I64d"
#    define CURL_FORMAT_CURL_OFF_TU    "I64u"
#    define CURL_SUFFIX_CURL_OFF_T     i64
#    define CURL_SUFFIX_CURL_OFF_TU    ui64
#  else
#    define CURL_TYPEOF_CURL_OFF_T     long long
#    define CURL_FORMAT_CURL_OFF_T     "lld"
#    define CURL_FORMAT_CURL_OFF_TU    "llu"
#    define CURL_SUFFIX_CURL_OFF_T     LL
#    define CURL_SUFFIX_CURL_OFF_TU    ULL
#  endif
#  define CURL_TYPEOF_CURL_SOCKLEN_T int
#elif defined(__LCC__)
#  if defined(__MCST__) 
#    define CURL_TYPEOF_CURL_OFF_T     long
#    define CURL_FORMAT_CURL_OFF_T     "ld"
#    define CURL_FORMAT_CURL_OFF_TU    "lu"
#    define CURL_SUFFIX_CURL_OFF_T     L
#    define CURL_SUFFIX_CURL_OFF_TU    UL
#    define CURL_TYPEOF_CURL_SOCKLEN_T socklen_t
#    define CURL_PULL_SYS_TYPES_H      1
#    define CURL_PULL_SYS_SOCKET_H     1
#  else                
#    define CURL_TYPEOF_CURL_OFF_T     long
#    define CURL_FORMAT_CURL_OFF_T     "ld"
#    define CURL_FORMAT_CURL_OFF_TU    "lu"
#    define CURL_SUFFIX_CURL_OFF_T     L
#    define CURL_SUFFIX_CURL_OFF_TU    UL
#    define CURL_TYPEOF_CURL_SOCKLEN_T int
#  endif
#elif defined(macintosh)
#  include <ConditionalMacros.h>
#  if TYPE_LONGLONG
#    define CURL_TYPEOF_CURL_OFF_T     long long
#    define CURL_FORMAT_CURL_OFF_T     "lld"
#    define CURL_FORMAT_CURL_OFF_TU    "llu"
#    define CURL_SUFFIX_CURL_OFF_T     LL
#    define CURL_SUFFIX_CURL_OFF_TU    ULL
#  else
#    define CURL_TYPEOF_CURL_OFF_T     long
#    define CURL_FORMAT_CURL_OFF_T     "ld"
#    define CURL_FORMAT_CURL_OFF_TU    "lu"
#    define CURL_SUFFIX_CURL_OFF_T     L
#    define CURL_SUFFIX_CURL_OFF_TU    UL
#  endif
#  define CURL_TYPEOF_CURL_SOCKLEN_T unsigned int
#elif defined(__TANDEM)
# if ! defined(__LP64)
#  define CURL_TYPEOF_CURL_OFF_T     long long
#  define CURL_FORMAT_CURL_OFF_T     "lld"
#  define CURL_FORMAT_CURL_OFF_TU    "llu"
#  define CURL_SUFFIX_CURL_OFF_T     LL
#  define CURL_SUFFIX_CURL_OFF_TU    ULL
#  define CURL_TYPEOF_CURL_SOCKLEN_T int
# endif
#elif defined(_WIN32_WCE)
#  define CURL_TYPEOF_CURL_OFF_T     __int64
#  define CURL_FORMAT_CURL_OFF_T     "I64d"
#  define CURL_FORMAT_CURL_OFF_TU    "I64u"
#  define CURL_SUFFIX_CURL_OFF_T     i64
#  define CURL_SUFFIX_CURL_OFF_TU    ui64
#  define CURL_TYPEOF_CURL_SOCKLEN_T int
#elif defined(__MINGW32__)
#  include <inttypes.h>
#  define CURL_TYPEOF_CURL_OFF_T     long long
#  define CURL_FORMAT_CURL_OFF_T     PRId64
#  define CURL_FORMAT_CURL_OFF_TU    PRIu64
#  define CURL_SUFFIX_CURL_OFF_T     LL
#  define CURL_SUFFIX_CURL_OFF_TU    ULL
#  define CURL_TYPEOF_CURL_SOCKLEN_T int
#  define CURL_PULL_SYS_TYPES_H      1
#elif defined(__VMS)
#  if defined(__VAX)
#    define CURL_TYPEOF_CURL_OFF_T     long
#    define CURL_FORMAT_CURL_OFF_T     "ld"
#    define CURL_FORMAT_CURL_OFF_TU    "lu"
#    define CURL_SUFFIX_CURL_OFF_T     L
#    define CURL_SUFFIX_CURL_OFF_TU    UL
#  else
#    define CURL_TYPEOF_CURL_OFF_T     long long
#    define CURL_FORMAT_CURL_OFF_T     "lld"
#    define CURL_FORMAT_CURL_OFF_TU    "llu"
#    define CURL_SUFFIX_CURL_OFF_T     LL
#    define CURL_SUFFIX_CURL_OFF_TU    ULL
#  endif
#  define CURL_TYPEOF_CURL_SOCKLEN_T unsigned int
#elif defined(__OS400__)
#  define CURL_TYPEOF_CURL_OFF_T     long long
#  define CURL_FORMAT_CURL_OFF_T     "lld"
#  define CURL_FORMAT_CURL_OFF_TU    "llu"
#  define CURL_SUFFIX_CURL_OFF_T     LL
#  define CURL_SUFFIX_CURL_OFF_TU    ULL
#  define CURL_TYPEOF_CURL_SOCKLEN_T socklen_t
#  define CURL_PULL_SYS_TYPES_H      1
#  define CURL_PULL_SYS_SOCKET_H     1
#elif defined(__MVS__)
#  if defined(_LONG_LONG)
#    define CURL_TYPEOF_CURL_OFF_T     long long
#    define CURL_FORMAT_CURL_OFF_T     "lld"
#    define CURL_FORMAT_CURL_OFF_TU    "llu"
#    define CURL_SUFFIX_CURL_OFF_T     LL
#    define CURL_SUFFIX_CURL_OFF_TU    ULL
#  elif defined(_LP64)
#    define CURL_TYPEOF_CURL_OFF_T     long
#    define CURL_FORMAT_CURL_OFF_T     "ld"
#    define CURL_FORMAT_CURL_OFF_TU    "lu"
#    define CURL_SUFFIX_CURL_OFF_T     L
#    define CURL_SUFFIX_CURL_OFF_TU    UL
#  else
#    define CURL_TYPEOF_CURL_OFF_T     long
#    define CURL_FORMAT_CURL_OFF_T     "ld"
#    define CURL_FORMAT_CURL_OFF_TU    "lu"
#    define CURL_SUFFIX_CURL_OFF_T     L
#    define CURL_SUFFIX_CURL_OFF_TU    UL
#  endif
#  define CURL_TYPEOF_CURL_SOCKLEN_T socklen_t
#  define CURL_PULL_SYS_TYPES_H      1
#  define CURL_PULL_SYS_SOCKET_H     1
#elif defined(__370__)
#  if defined(__IBMC__) || defined(__IBMCPP__)
#    if defined(_ILP32)
#    elif defined(_LP64)
#    endif
#    if defined(_LONG_LONG)
#      define CURL_TYPEOF_CURL_OFF_T     long long
#      define CURL_FORMAT_CURL_OFF_T     "lld"
#      define CURL_FORMAT_CURL_OFF_TU    "llu"
#      define CURL_SUFFIX_CURL_OFF_T     LL
#      define CURL_SUFFIX_CURL_OFF_TU    ULL
#    elif defined(_LP64)
#      define CURL_TYPEOF_CURL_OFF_T     long
#      define CURL_FORMAT_CURL_OFF_T     "ld"
#      define CURL_FORMAT_CURL_OFF_TU    "lu"
#      define CURL_SUFFIX_CURL_OFF_T     L
#      define CURL_SUFFIX_CURL_OFF_TU    UL
#    else
#      define CURL_TYPEOF_CURL_OFF_T     long
#      define CURL_FORMAT_CURL_OFF_T     "ld"
#      define CURL_FORMAT_CURL_OFF_TU    "lu"
#      define CURL_SUFFIX_CURL_OFF_T     L
#      define CURL_SUFFIX_CURL_OFF_TU    UL
#    endif
#    define CURL_TYPEOF_CURL_SOCKLEN_T socklen_t
#    define CURL_PULL_SYS_TYPES_H      1
#    define CURL_PULL_SYS_SOCKET_H     1
#  endif
#elif defined(TPF)
#  define CURL_TYPEOF_CURL_OFF_T     long
#  define CURL_FORMAT_CURL_OFF_T     "ld"
#  define CURL_FORMAT_CURL_OFF_TU    "lu"
#  define CURL_SUFFIX_CURL_OFF_T     L
#  define CURL_SUFFIX_CURL_OFF_TU    UL
#  define CURL_TYPEOF_CURL_SOCKLEN_T int
#elif defined(__TINYC__) 
#  define CURL_TYPEOF_CURL_OFF_T     long long
#  define CURL_FORMAT_CURL_OFF_T     "lld"
#  define CURL_FORMAT_CURL_OFF_TU    "llu"
#  define CURL_SUFFIX_CURL_OFF_T     LL
#  define CURL_SUFFIX_CURL_OFF_TU    ULL
#  define CURL_TYPEOF_CURL_SOCKLEN_T socklen_t
#  define CURL_PULL_SYS_TYPES_H      1
#  define CURL_PULL_SYS_SOCKET_H     1
#elif defined(__SUNPRO_C) || defined(__SUNPRO_CC) 
#  if !defined(__LP64) && (defined(__ILP32) ||                          \
                           defined(__i386) ||                           \
                           defined(__sparcv8) ||                        \
                           defined(__sparcv8plus))
#    define CURL_TYPEOF_CURL_OFF_T     long long
#    define CURL_FORMAT_CURL_OFF_T     "lld"
#    define CURL_FORMAT_CURL_OFF_TU    "llu"
#    define CURL_SUFFIX_CURL_OFF_T     LL
#    define CURL_SUFFIX_CURL_OFF_TU    ULL
#  elif defined(__LP64) || \
        defined(__amd64) || defined(__sparcv9)
#    define CURL_TYPEOF_CURL_OFF_T     long
#    define CURL_FORMAT_CURL_OFF_T     "ld"
#    define CURL_FORMAT_CURL_OFF_TU    "lu"
#    define CURL_SUFFIX_CURL_OFF_T     L
#    define CURL_SUFFIX_CURL_OFF_TU    UL
#  endif
#  define CURL_TYPEOF_CURL_SOCKLEN_T socklen_t
#  define CURL_PULL_SYS_TYPES_H      1
#  define CURL_PULL_SYS_SOCKET_H     1
#elif defined(__xlc__) 
#  if !defined(_LP64)
#    define CURL_TYPEOF_CURL_OFF_T     long long
#    define CURL_FORMAT_CURL_OFF_T     "lld"
#    define CURL_FORMAT_CURL_OFF_TU    "llu"
#    define CURL_SUFFIX_CURL_OFF_T     LL
#    define CURL_SUFFIX_CURL_OFF_TU    ULL
#  else
#    define CURL_TYPEOF_CURL_OFF_T     long
#    define CURL_FORMAT_CURL_OFF_T     "ld"
#    define CURL_FORMAT_CURL_OFF_TU    "lu"
#    define CURL_SUFFIX_CURL_OFF_T     L
#    define CURL_SUFFIX_CURL_OFF_TU    UL
#  endif
#  define CURL_TYPEOF_CURL_SOCKLEN_T socklen_t
#  define CURL_PULL_SYS_TYPES_H      1
#  define CURL_PULL_SYS_SOCKET_H     1
#elif defined(__hpux) 
#  if !defined(_LP64)
#    define CURL_TYPEOF_CURL_OFF_T     long long
#    define CURL_FORMAT_CURL_OFF_T     "lld"
#    define CURL_FORMAT_CURL_OFF_TU    "llu"
#    define CURL_SUFFIX_CURL_OFF_T     LL
#    define CURL_SUFFIX_CURL_OFF_TU    ULL
#  else
#    define CURL_TYPEOF_CURL_OFF_T     long
#    define CURL_FORMAT_CURL_OFF_T     "ld"
#    define CURL_FORMAT_CURL_OFF_TU    "lu"
#    define CURL_SUFFIX_CURL_OFF_T     L
#    define CURL_SUFFIX_CURL_OFF_TU    UL
#  endif
#  define CURL_TYPEOF_CURL_SOCKLEN_T socklen_t
#  define CURL_PULL_SYS_TYPES_H      1
#  define CURL_PULL_SYS_SOCKET_H     1
#elif defined(_MSC_VER)
#  if (_MSC_VER >= 1800)
#    include <inttypes.h>
#    define CURL_TYPEOF_CURL_OFF_T     __int64
#    define CURL_FORMAT_CURL_OFF_T     PRId64
#    define CURL_FORMAT_CURL_OFF_TU    PRIu64
#    define CURL_SUFFIX_CURL_OFF_T     i64
#    define CURL_SUFFIX_CURL_OFF_TU    ui64
#  elif (_MSC_VER >= 900) && (_INTEGRAL_MAX_BITS >= 64)
#    define CURL_TYPEOF_CURL_OFF_T     __int64
#    define CURL_FORMAT_CURL_OFF_T     "I64d"
#    define CURL_FORMAT_CURL_OFF_TU    "I64u"
#    define CURL_SUFFIX_CURL_OFF_T     i64
#    define CURL_SUFFIX_CURL_OFF_TU    ui64
#  else
#    define CURL_TYPEOF_CURL_OFF_T     long
#    define CURL_FORMAT_CURL_OFF_T     "ld"
#    define CURL_FORMAT_CURL_OFF_TU    "lu"
#    define CURL_SUFFIX_CURL_OFF_T     L
#    define CURL_SUFFIX_CURL_OFF_TU    UL
#  endif
#  define CURL_TYPEOF_CURL_SOCKLEN_T int
#elif defined(__GNUC__) && !defined(_SCO_DS)
#  if !defined(__LP64__) &&                                             \
  (defined(__ILP32__) || defined(__i386__) || defined(__hppa__) ||      \
   defined(__ppc__) || defined(__powerpc__) || defined(__arm__) ||      \
   defined(__sparc__) || defined(__mips__) || defined(__sh__) ||        \
   defined(__XTENSA__) ||                                               \
   (defined(__SIZEOF_LONG__) && __SIZEOF_LONG__ == 4)  ||               \
   (defined(__LONG_MAX__) && __LONG_MAX__ == 2147483647L))
#    define CURL_TYPEOF_CURL_OFF_T     long long
#    define CURL_FORMAT_CURL_OFF_T     "lld"
#    define CURL_FORMAT_CURL_OFF_TU    "llu"
#    define CURL_SUFFIX_CURL_OFF_T     LL
#    define CURL_SUFFIX_CURL_OFF_TU    ULL
#  elif defined(__LP64__) || \
        defined(__x86_64__) || defined(__ppc64__) || defined(__sparc64__) || \
        defined(__e2k__) || \
        (defined(__SIZEOF_LONG__) && __SIZEOF_LONG__ == 8) || \
        (defined(__LONG_MAX__) && __LONG_MAX__ == 9223372036854775807L)
#    define CURL_TYPEOF_CURL_OFF_T     long
#    define CURL_FORMAT_CURL_OFF_T     "ld"
#    define CURL_FORMAT_CURL_OFF_TU    "lu"
#    define CURL_SUFFIX_CURL_OFF_T     L
#    define CURL_SUFFIX_CURL_OFF_TU    UL
#  endif
#  define CURL_TYPEOF_CURL_SOCKLEN_T socklen_t
#  define CURL_PULL_SYS_TYPES_H      1
#  define CURL_PULL_SYS_SOCKET_H     1
#else
# define CURL_TYPEOF_CURL_OFF_T     long
# define CURL_FORMAT_CURL_OFF_T     "ld"
# define CURL_FORMAT_CURL_OFF_TU    "lu"
# define CURL_SUFFIX_CURL_OFF_T     L
# define CURL_SUFFIX_CURL_OFF_TU    UL
# define CURL_TYPEOF_CURL_SOCKLEN_T int
#endif
#ifdef _AIX
#define CURL_PULL_SYS_POLL_H
#endif
#ifdef CURL_PULL_SYS_TYPES_H
#  include <sys/types.h>
#endif
#ifdef CURL_PULL_SYS_SOCKET_H
#  include <sys/socket.h>
#endif
#ifdef CURL_PULL_SYS_POLL_H
#  include <sys/poll.h>
#endif
#ifdef CURL_TYPEOF_CURL_SOCKLEN_T
  typedef CURL_TYPEOF_CURL_SOCKLEN_T curl_socklen_t;
#endif
#ifdef CURL_TYPEOF_CURL_OFF_T
  typedef CURL_TYPEOF_CURL_OFF_T curl_off_t;
#endif
#if defined(__STDC__) || defined(_MSC_VER) || defined(__cplusplus) || \
  defined(__HP_aCC) || defined(__BORLANDC__) || defined(__LCC__) || \
  defined(__POCC__) || defined(__SALFORDC__) || defined(__HIGHC__) || \
  defined(__ILEC400__)
#define CURL_ISOCPP
#else
#undef CURL_ISOCPP
#endif
#if defined(__BORLANDC__) && (__BORLANDC__ == 0x0551)
#  define CURLINC_OFF_T_C_HLPR2(x) x
#  define CURLINC_OFF_T_C_HLPR1(x) CURLINC_OFF_T_C_HLPR2(x)
#  define CURL_OFF_T_C(Val)  CURLINC_OFF_T_C_HLPR1(Val) ## \
                             CURLINC_OFF_T_C_HLPR1(CURL_SUFFIX_CURL_OFF_T)
#  define CURL_OFF_TU_C(Val) CURLINC_OFF_T_C_HLPR1(Val) ## \
                             CURLINC_OFF_T_C_HLPR1(CURL_SUFFIX_CURL_OFF_TU)
#else
#  ifdef CURL_ISOCPP
#    define CURLINC_OFF_T_C_HLPR2(Val,Suffix) Val ## Suffix
#  else
#    define CURLINC_OFF_T_C_HLPR2(Val,Suffix) ValSuffix
#  endif
#  define CURLINC_OFF_T_C_HLPR1(Val,Suffix) CURLINC_OFF_T_C_HLPR2(Val,Suffix)
#  define CURL_OFF_T_C(Val)  CURLINC_OFF_T_C_HLPR1(Val,CURL_SUFFIX_CURL_OFF_T)
#  define CURL_OFF_TU_C(Val) CURLINC_OFF_T_C_HLPR1(Val,CURL_SUFFIX_CURL_OFF_TU)
#endif
#endif 
#include <stdio.h>
#include <limits.h>
#if defined(__FreeBSD__) || defined(__MidnightBSD__)
#include <sys/param.h>
#endif
#include <sys/types.h>
#include <time.h>
#if defined(_WIN32) && !defined(_WIN32_WCE) && !defined(__CYGWIN__)
#if !(defined(_WINSOCKAPI_) || defined(_WINSOCK_H) || \
      defined(__LWIP_OPT_H__) || defined(LWIP_HDR_OPT_H))
#include <winsock2.h>
#include <ws2tcpip.h>
#endif
#endif
#if defined(_AIX) || defined(__NOVELL_LIBC__) || defined(__NetBSD__) || \
    defined(__minix) || defined(__INTEGRITY) || \
    defined(ANDROID) || defined(__ANDROID__) || defined(__OpenBSD__) || \
    defined(__CYGWIN__) || defined(AMIGA) || defined(__NuttX__) || \
   (defined(__FreeBSD_version) && (__FreeBSD_version < 800000)) || \
   (defined(__MidnightBSD_version) && (__MidnightBSD_version < 100000)) || \
    defined(__sun__) || defined(__serenity__) || defined(__vxworks__)
#include <sys/select.h>
#endif
#if !defined(_WIN32) && !defined(_WIN32_WCE)
#include <sys/socket.h>
#endif
#if !defined(_WIN32)
#include <sys/time.h>
#endif
#ifndef __has_declspec_attribute
#  define __has_declspec_attribute(x) 0
#endif
typedef void CURL;
typedef void CURLSH;
#ifdef CURL_STATICLIB
#  define CURL_EXTERN
#elif defined(_WIN32) || \
     (__has_declspec_attribute(dllexport) && \
      __has_declspec_attribute(dllimport))
#  if defined(BUILDING_LIBCURL)
#    define CURL_EXTERN  __declspec(dllexport)
#  else
#    define CURL_EXTERN  __declspec(dllimport)
#  endif
#elif defined(BUILDING_LIBCURL) && defined(CURL_HIDDEN_SYMBOLS)
#  define CURL_EXTERN CURL_EXTERN_SYMBOL
#else
#  define CURL_EXTERN
#endif
#ifndef curl_socket_typedef
#if defined(_WIN32) && !defined(__LWIP_OPT_H__) && !defined(LWIP_HDR_OPT_H)
typedef SOCKET curl_socket_t;
#define CURL_SOCKET_BAD INVALID_SOCKET
#else
typedef int curl_socket_t;
#define CURL_SOCKET_BAD -1
#endif
#define curl_socket_typedef
#endif 
typedef enum {
  CURLSSLBACKEND_NONE = 0,
  CURLSSLBACKEND_OPENSSL = 1,
  CURLSSLBACKEND_GNUTLS = 2,
  CURLSSLBACKEND_NSS                    CURL_DEPRECATED(8.3.0, "") = 3,
  CURLSSLBACKEND_OBSOLETE4 = 4,  
  CURLSSLBACKEND_GSKIT                  CURL_DEPRECATED(8.3.0, "") = 5,
  CURLSSLBACKEND_POLARSSL               CURL_DEPRECATED(7.69.0, "") = 6,
  CURLSSLBACKEND_WOLFSSL = 7,
  CURLSSLBACKEND_SCHANNEL = 8,
  CURLSSLBACKEND_SECURETRANSPORT = 9,
  CURLSSLBACKEND_AXTLS                  CURL_DEPRECATED(7.61.0, "") = 10,
  CURLSSLBACKEND_MBEDTLS = 11,
  CURLSSLBACKEND_MESALINK               CURL_DEPRECATED(7.82.0, "") = 12,
  CURLSSLBACKEND_BEARSSL = 13,
  CURLSSLBACKEND_RUSTLS = 14
} curl_sslbackend;
struct curl_httppost {
  struct curl_httppost *next;       
  char *name;                       
  long namelength;                  
  char *contents;                   
  long contentslength;              
  char *buffer;                     
  long bufferlength;                
  char *contenttype;                
  struct curl_slist *contentheader; 
  struct curl_httppost *more;       
  long flags;                       
  char *showfilename;               
  void *userp;                      
  curl_off_t contentlen;            
};
typedef int (*curl_progress_callback)(void *clientp,
                                      double dltotal,
                                      double dlnow,
                                      double ultotal,
                                      double ulnow);
typedef int (*curl_xferinfo_callback)(void *clientp,
                                      curl_off_t dltotal,
                                      curl_off_t dlnow,
                                      curl_off_t ultotal,
                                      curl_off_t ulnow);
#ifndef CURL_MAX_READ_SIZE
#define CURL_MAX_READ_SIZE (10*1024*1024)
#endif
#ifndef CURL_MAX_WRITE_SIZE
#define CURL_MAX_WRITE_SIZE 16384
#endif
#ifndef CURL_MAX_HTTP_HEADER
#define CURL_MAX_HTTP_HEADER (100*1024)
#endif
typedef size_t (*curl_write_callback)(char *buffer,
                                      size_t size,
                                      size_t nitems,
                                      void *outstream);
typedef int (*curl_resolver_start_callback)(void *resolver_state,
                                            void *reserved, void *userdata);
typedef enum {
  CURLFILETYPE_FILE = 0,
  CURLFILETYPE_DIRECTORY,
  CURLFILETYPE_SYMLINK,
  CURLFILETYPE_DEVICE_BLOCK,
  CURLFILETYPE_DEVICE_CHAR,
  CURLFILETYPE_NAMEDPIPE,
  CURLFILETYPE_SOCKET,
  CURLFILETYPE_DOOR, 
  CURLFILETYPE_UNKNOWN 
} curlfiletype;
struct curl_fileinfo {
  char *filename;
  curlfiletype filetype;
  time_t time; 
  unsigned int perm;
  int uid;
  int gid;
  curl_off_t size;
  long int hardlinks;
  struct {
    char *time;
    char *perm;
    char *user;
    char *group;
    char *target; 
  } strings;
  unsigned int flags;
  char *b_data;
  size_t b_size;
  size_t b_used;
};
typedef long (*curl_chunk_bgn_callback)(const void *transfer_info,
                                        void *ptr,
                                        int remains);
typedef long (*curl_chunk_end_callback)(void *ptr);
typedef int (*curl_fnmatch_callback)(void *ptr,
                                     const char *pattern,
                                     const char *string);
typedef int (*curl_seek_callback)(void *instream,
                                  curl_off_t offset,
                                  int origin); 
typedef size_t (*curl_read_callback)(char *buffer,
                                      size_t size,
                                      size_t nitems,
                                      void *instream);
typedef int (*curl_trailer_callback)(struct curl_slist **list,
                                      void *userdata);
typedef enum {
  CURLSOCKTYPE_IPCXN,  
  CURLSOCKTYPE_ACCEPT, 
  CURLSOCKTYPE_LAST    
} curlsocktype;
#define CURL_SOCKOPT_OK 0
#define CURL_SOCKOPT_ERROR 1 
#define CURL_SOCKOPT_ALREADY_CONNECTED 2
typedef int (*curl_sockopt_callback)(void *clientp,
                                     curl_socket_t curlfd,
                                     curlsocktype purpose);
struct curl_sockaddr {
  int family;
  int socktype;
  int protocol;
  unsigned int addrlen; 
  struct sockaddr addr;
};
typedef curl_socket_t
(*curl_opensocket_callback)(void *clientp,
                            curlsocktype purpose,
                            struct curl_sockaddr *address);
typedef int
(*curl_closesocket_callback)(void *clientp, curl_socket_t item);
typedef enum {
  CURLIOE_OK,            
  CURLIOE_UNKNOWNCMD,    
  CURLIOE_FAILRESTART,   
  CURLIOE_LAST           
} curlioerr;
typedef enum {
  CURLIOCMD_NOP,         
  CURLIOCMD_RESTARTREAD, 
  CURLIOCMD_LAST         
} curliocmd;
typedef curlioerr (*curl_ioctl_callback)(CURL *handle,
                                         int cmd,
                                         void *clientp);
#ifndef CURL_DID_MEMORY_FUNC_TYPEDEFS
typedef void *(*curl_malloc_callback)(size_t size);
typedef void (*curl_free_callback)(void *ptr);
typedef void *(*curl_realloc_callback)(void *ptr, size_t size);
typedef char *(*curl_strdup_callback)(const char *str);
typedef void *(*curl_calloc_callback)(size_t nmemb, size_t size);
#define CURL_DID_MEMORY_FUNC_TYPEDEFS
#endif
typedef enum {
  CURLINFO_TEXT = 0,
  CURLINFO_HEADER_IN,    
  CURLINFO_HEADER_OUT,   
  CURLINFO_DATA_IN,      
  CURLINFO_DATA_OUT,     
  CURLINFO_SSL_DATA_IN,  
  CURLINFO_SSL_DATA_OUT, 
  CURLINFO_END
} curl_infotype;
typedef int (*curl_debug_callback)
       (CURL *handle,      
        curl_infotype type, 
        char *data,        
        size_t size,       
        void *userptr);    
typedef int (*curl_prereq_callback)(void *clientp,
                                    char *conn_primary_ip,
                                    char *conn_local_ip,
                                    int conn_primary_port,
                                    int conn_local_port);
typedef enum {
  CURLE_OK = 0,
  CURLE_UNSUPPORTED_PROTOCOL,    
  CURLE_FAILED_INIT,             
  CURLE_URL_MALFORMAT,           
  CURLE_NOT_BUILT_IN,            
  CURLE_COULDNT_RESOLVE_PROXY,   
  CURLE_COULDNT_RESOLVE_HOST,    
  CURLE_COULDNT_CONNECT,         
  CURLE_WEIRD_SERVER_REPLY,      
  CURLE_REMOTE_ACCESS_DENIED,    
  CURLE_FTP_ACCEPT_FAILED,       
  CURLE_FTP_WEIRD_PASS_REPLY,    
  CURLE_FTP_ACCEPT_TIMEOUT,      
  CURLE_FTP_WEIRD_PASV_REPLY,    
  CURLE_FTP_WEIRD_227_FORMAT,    
  CURLE_FTP_CANT_GET_HOST,       
  CURLE_HTTP2,                   
  CURLE_FTP_COULDNT_SET_TYPE,    
  CURLE_PARTIAL_FILE,            
  CURLE_FTP_COULDNT_RETR_FILE,   
  CURLE_OBSOLETE20,              
  CURLE_QUOTE_ERROR,             
  CURLE_HTTP_RETURNED_ERROR,     
  CURLE_WRITE_ERROR,             
  CURLE_OBSOLETE24,              
  CURLE_UPLOAD_FAILED,           
  CURLE_READ_ERROR,              
  CURLE_OUT_OF_MEMORY,           
  CURLE_OPERATION_TIMEDOUT,      
  CURLE_OBSOLETE29,              
  CURLE_FTP_PORT_FAILED,         
  CURLE_FTP_COULDNT_USE_REST,    
  CURLE_OBSOLETE32,              
  CURLE_RANGE_ERROR,             
  CURLE_OBSOLETE34,              
  CURLE_SSL_CONNECT_ERROR,       
  CURLE_BAD_DOWNLOAD_RESUME,     
  CURLE_FILE_COULDNT_READ_FILE,  
  CURLE_LDAP_CANNOT_BIND,        
  CURLE_LDAP_SEARCH_FAILED,      
  CURLE_OBSOLETE40,              
  CURLE_OBSOLETE41,              
  CURLE_ABORTED_BY_CALLBACK,     
  CURLE_BAD_FUNCTION_ARGUMENT,   
  CURLE_OBSOLETE44,              
  CURLE_INTERFACE_FAILED,        
  CURLE_OBSOLETE46,              
  CURLE_TOO_MANY_REDIRECTS,      
  CURLE_UNKNOWN_OPTION,          
  CURLE_SETOPT_OPTION_SYNTAX,    
  CURLE_OBSOLETE50,              
  CURLE_OBSOLETE51,              
  CURLE_GOT_NOTHING,             
  CURLE_SSL_ENGINE_NOTFOUND,     
  CURLE_SSL_ENGINE_SETFAILED,    
  CURLE_SEND_ERROR,              
  CURLE_RECV_ERROR,              
  CURLE_OBSOLETE57,              
  CURLE_SSL_CERTPROBLEM,         
  CURLE_SSL_CIPHER,              
  CURLE_PEER_FAILED_VERIFICATION, 
  CURLE_BAD_CONTENT_ENCODING,    
  CURLE_OBSOLETE62,              
  CURLE_FILESIZE_EXCEEDED,       
  CURLE_USE_SSL_FAILED,          
  CURLE_SEND_FAIL_REWIND,        
  CURLE_SSL_ENGINE_INITFAILED,   
  CURLE_LOGIN_DENIED,            
  CURLE_TFTP_NOTFOUND,           
  CURLE_TFTP_PERM,               
  CURLE_REMOTE_DISK_FULL,        
  CURLE_TFTP_ILLEGAL,            
  CURLE_TFTP_UNKNOWNID,          
  CURLE_REMOTE_FILE_EXISTS,      
  CURLE_TFTP_NOSUCHUSER,         
  CURLE_OBSOLETE75,              
  CURLE_OBSOLETE76,              
  CURLE_SSL_CACERT_BADFILE,      
  CURLE_REMOTE_FILE_NOT_FOUND,   
  CURLE_SSH,                     
  CURLE_SSL_SHUTDOWN_FAILED,     
  CURLE_AGAIN,                   
  CURLE_SSL_CRL_BADFILE,         
  CURLE_SSL_ISSUER_ERROR,        
  CURLE_FTP_PRET_FAILED,         
  CURLE_RTSP_CSEQ_ERROR,         
  CURLE_RTSP_SESSION_ERROR,      
  CURLE_FTP_BAD_FILE_LIST,       
  CURLE_CHUNK_FAILED,            
  CURLE_NO_CONNECTION_AVAILABLE, 
  CURLE_SSL_PINNEDPUBKEYNOTMATCH, 
  CURLE_SSL_INVALIDCERTSTATUS,   
  CURLE_HTTP2_STREAM,            
  CURLE_RECURSIVE_API_CALL,      
  CURLE_AUTH_ERROR,              
  CURLE_HTTP3,                   
  CURLE_QUIC_CONNECT_ERROR,      
  CURLE_PROXY,                   
  CURLE_SSL_CLIENTCERT,          
  CURLE_UNRECOVERABLE_POLL,      
  CURLE_TOO_LARGE,               
  CURLE_ECH_REQUIRED,            
  CURL_LAST 
} CURLcode;
typedef enum {
  CURLPX_OK,
  CURLPX_BAD_ADDRESS_TYPE,
  CURLPX_BAD_VERSION,
  CURLPX_CLOSED,
  CURLPX_GSSAPI,
  CURLPX_GSSAPI_PERMSG,
  CURLPX_GSSAPI_PROTECTION,
  CURLPX_IDENTD,
  CURLPX_IDENTD_DIFFER,
  CURLPX_LONG_HOSTNAME,
  CURLPX_LONG_PASSWD,
  CURLPX_LONG_USER,
  CURLPX_NO_AUTH,
  CURLPX_RECV_ADDRESS,
  CURLPX_RECV_AUTH,
  CURLPX_RECV_CONNECT,
  CURLPX_RECV_REQACK,
  CURLPX_REPLY_ADDRESS_TYPE_NOT_SUPPORTED,
  CURLPX_REPLY_COMMAND_NOT_SUPPORTED,
  CURLPX_REPLY_CONNECTION_REFUSED,
  CURLPX_REPLY_GENERAL_SERVER_FAILURE,
  CURLPX_REPLY_HOST_UNREACHABLE,
  CURLPX_REPLY_NETWORK_UNREACHABLE,
  CURLPX_REPLY_NOT_ALLOWED,
  CURLPX_REPLY_TTL_EXPIRED,
  CURLPX_REPLY_UNASSIGNED,
  CURLPX_REQUEST_FAILED,
  CURLPX_RESOLVE_HOST,
  CURLPX_SEND_AUTH,
  CURLPX_SEND_CONNECT,
  CURLPX_SEND_REQUEST,
  CURLPX_UNKNOWN_FAIL,
  CURLPX_UNKNOWN_MODE,
  CURLPX_USER_REJECTED,
  CURLPX_LAST 
} CURLproxycode;
typedef CURLcode (*curl_conv_callback)(char *buffer, size_t length);
typedef CURLcode (*curl_ssl_ctx_callback)(CURL *curl,    
                                          void *ssl_ctx, 
                                          void *userptr);
typedef enum {
  CURLPROXY_HTTP = 0,   
  CURLPROXY_HTTP_1_0 = 1,   
  CURLPROXY_HTTPS = 2,  
  CURLPROXY_HTTPS2 = 3, 
  CURLPROXY_SOCKS4 = 4, 
  CURLPROXY_SOCKS5 = 5, 
  CURLPROXY_SOCKS4A = 6, 
  CURLPROXY_SOCKS5_HOSTNAME = 7 
} curl_proxytype;  
#define CURLSSH_AUTH_ANY       ~0     
#define CURLSSH_AUTH_NONE      0      
#define CURLSSH_AUTH_PUBLICKEY (1<<0) 
#define CURLSSH_AUTH_PASSWORD  (1<<1) 
#define CURLSSH_AUTH_HOST      (1<<2) 
#define CURLSSH_AUTH_KEYBOARD  (1<<3) 
#define CURLSSH_AUTH_AGENT     (1<<4) 
#define CURLSSH_AUTH_GSSAPI    (1<<5) 
#define CURLSSH_AUTH_DEFAULT CURLSSH_AUTH_ANY
#define CURL_ERROR_SIZE 256
enum curl_khtype {
  CURLKHTYPE_UNKNOWN,
  CURLKHTYPE_RSA1,
  CURLKHTYPE_RSA,
  CURLKHTYPE_DSS,
  CURLKHTYPE_ECDSA,
  CURLKHTYPE_ED25519
};
struct curl_khkey {
  const char *key; 
  size_t len;
  enum curl_khtype keytype;
};
enum curl_khstat {
  CURLKHSTAT_FINE_ADD_TO_FILE,
  CURLKHSTAT_FINE,
  CURLKHSTAT_REJECT, 
  CURLKHSTAT_DEFER,  
  CURLKHSTAT_FINE_REPLACE, 
  CURLKHSTAT_LAST    
};
enum curl_khmatch {
  CURLKHMATCH_OK,       
  CURLKHMATCH_MISMATCH, 
  CURLKHMATCH_MISSING,  
  CURLKHMATCH_LAST      
};
typedef int
  (*curl_sshkeycallback) (CURL *easy,     
                          const struct curl_khkey *knownkey, 
                          const struct curl_khkey *foundkey, 
                          enum curl_khmatch, 
                          void *clientp); 
typedef int
  (*curl_sshhostkeycallback) (void *clientp,
                          int keytype, 
                          const char *key, 
                          size_t keylen); 
typedef enum {
  CURLUSESSL_NONE,    
  CURLUSESSL_TRY,     
  CURLUSESSL_CONTROL, 
  CURLUSESSL_ALL,     
  CURLUSESSL_LAST     
} curl_usessl;
typedef enum {
  CURLFTPSSL_CCC_NONE,    
  CURLFTPSSL_CCC_PASSIVE, 
  CURLFTPSSL_CCC_ACTIVE,  
  CURLFTPSSL_CCC_LAST     
} curl_ftpccc;
typedef enum {
  CURLFTPAUTH_DEFAULT, 
  CURLFTPAUTH_SSL,     
  CURLFTPAUTH_TLS,     
  CURLFTPAUTH_LAST 
} curl_ftpauth;
typedef enum {
  CURLFTP_CREATE_DIR_NONE,  
  CURLFTP_CREATE_DIR,       
  CURLFTP_CREATE_DIR_RETRY, 
  CURLFTP_CREATE_DIR_LAST   
} curl_ftpcreatedir;
typedef enum {
  CURLFTPMETHOD_DEFAULT,   
  CURLFTPMETHOD_MULTICWD,  
  CURLFTPMETHOD_NOCWD,     
  CURLFTPMETHOD_SINGLECWD, 
  CURLFTPMETHOD_LAST       
} curl_ftpmethod;
struct curl_hstsentry {
  char *name;
  size_t namelen;
  unsigned int includeSubDomains:1;
  char expire[18]; 
};
struct curl_index {
  size_t index; 
  size_t total; 
};
typedef enum {
  CURLSTS_OK,
  CURLSTS_DONE,
  CURLSTS_FAIL
} CURLSTScode;
typedef CURLSTScode (*curl_hstsread_callback)(CURL *easy,
                                              struct curl_hstsentry *e,
                                              void *userp);
typedef CURLSTScode (*curl_hstswrite_callback)(CURL *easy,
                                               struct curl_hstsentry *e,
                                               struct curl_index *i,
                                               void *userp);
#define CURLOPTTYPE_LONG          0
#define CURLOPTTYPE_OBJECTPOINT   10000
#define CURLOPTTYPE_FUNCTIONPOINT 20000
#define CURLOPTTYPE_OFF_T         30000
#define CURLOPTTYPE_BLOB          40000
#define CURLOPT(na,t,nu) na = t + nu
#define CURLOPTDEPRECATED(na,t,nu,v,m) na CURL_DEPRECATED(v,m) = t + nu
#define CURLOPTTYPE_STRINGPOINT CURLOPTTYPE_OBJECTPOINT
#define CURLOPTTYPE_SLISTPOINT  CURLOPTTYPE_OBJECTPOINT
#define CURLOPTTYPE_CBPOINT     CURLOPTTYPE_OBJECTPOINT
#define CURLOPTTYPE_VALUES      CURLOPTTYPE_LONG
typedef enum {
  CURLOPT(CURLOPT_WRITEDATA, CURLOPTTYPE_CBPOINT, 1),
  CURLOPT(CURLOPT_URL, CURLOPTTYPE_STRINGPOINT, 2),
  CURLOPT(CURLOPT_PORT, CURLOPTTYPE_LONG, 3),
  CURLOPT(CURLOPT_PROXY, CURLOPTTYPE_STRINGPOINT, 4),
  CURLOPT(CURLOPT_USERPWD, CURLOPTTYPE_STRINGPOINT, 5),
  CURLOPT(CURLOPT_PROXYUSERPWD, CURLOPTTYPE_STRINGPOINT, 6),
  CURLOPT(CURLOPT_RANGE, CURLOPTTYPE_STRINGPOINT, 7),
  CURLOPT(CURLOPT_READDATA, CURLOPTTYPE_CBPOINT, 9),
  CURLOPT(CURLOPT_ERRORBUFFER, CURLOPTTYPE_OBJECTPOINT, 10),
  CURLOPT(CURLOPT_WRITEFUNCTION, CURLOPTTYPE_FUNCTIONPOINT, 11),
  CURLOPT(CURLOPT_READFUNCTION, CURLOPTTYPE_FUNCTIONPOINT, 12),
  CURLOPT(CURLOPT_TIMEOUT, CURLOPTTYPE_LONG, 13),
  CURLOPT(CURLOPT_INFILESIZE, CURLOPTTYPE_LONG, 14),
  CURLOPT(CURLOPT_POSTFIELDS, CURLOPTTYPE_OBJECTPOINT, 15),
  CURLOPT(CURLOPT_REFERER, CURLOPTTYPE_STRINGPOINT, 16),
  CURLOPT(CURLOPT_FTPPORT, CURLOPTTYPE_STRINGPOINT, 17),
  CURLOPT(CURLOPT_USERAGENT, CURLOPTTYPE_STRINGPOINT, 18),
  CURLOPT(CURLOPT_LOW_SPEED_LIMIT, CURLOPTTYPE_LONG, 19),
  CURLOPT(CURLOPT_LOW_SPEED_TIME, CURLOPTTYPE_LONG, 20),
  CURLOPT(CURLOPT_RESUME_FROM, CURLOPTTYPE_LONG, 21),
  CURLOPT(CURLOPT_COOKIE, CURLOPTTYPE_STRINGPOINT, 22),
  CURLOPT(CURLOPT_HTTPHEADER, CURLOPTTYPE_SLISTPOINT, 23),
  CURLOPTDEPRECATED(CURLOPT_HTTPPOST, CURLOPTTYPE_OBJECTPOINT, 24,
                    7.56.0, "Use CURLOPT_MIMEPOST"),
  CURLOPT(CURLOPT_SSLCERT, CURLOPTTYPE_STRINGPOINT, 25),
  CURLOPT(CURLOPT_KEYPASSWD, CURLOPTTYPE_STRINGPOINT, 26),
  CURLOPT(CURLOPT_CRLF, CURLOPTTYPE_LONG, 27),
  CURLOPT(CURLOPT_QUOTE, CURLOPTTYPE_SLISTPOINT, 28),
  CURLOPT(CURLOPT_HEADERDATA, CURLOPTTYPE_CBPOINT, 29),
  CURLOPT(CURLOPT_COOKIEFILE, CURLOPTTYPE_STRINGPOINT, 31),
  CURLOPT(CURLOPT_SSLVERSION, CURLOPTTYPE_VALUES, 32),
  CURLOPT(CURLOPT_TIMECONDITION, CURLOPTTYPE_VALUES, 33),
  CURLOPT(CURLOPT_TIMEVALUE, CURLOPTTYPE_LONG, 34),
  CURLOPT(CURLOPT_CUSTOMREQUEST, CURLOPTTYPE_STRINGPOINT, 36),
  CURLOPT(CURLOPT_STDERR, CURLOPTTYPE_OBJECTPOINT, 37),
  CURLOPT(CURLOPT_POSTQUOTE, CURLOPTTYPE_SLISTPOINT, 39),
  CURLOPT(CURLOPT_VERBOSE, CURLOPTTYPE_LONG, 41),
  CURLOPT(CURLOPT_HEADER, CURLOPTTYPE_LONG, 42),
  CURLOPT(CURLOPT_NOPROGRESS, CURLOPTTYPE_LONG, 43),
  CURLOPT(CURLOPT_NOBODY, CURLOPTTYPE_LONG, 44),
  CURLOPT(CURLOPT_FAILONERROR, CURLOPTTYPE_LONG, 45),
  CURLOPT(CURLOPT_UPLOAD, CURLOPTTYPE_LONG, 46),
  CURLOPT(CURLOPT_POST, CURLOPTTYPE_LONG, 47),
  CURLOPT(CURLOPT_DIRLISTONLY, CURLOPTTYPE_LONG, 48),
  CURLOPT(CURLOPT_APPEND, CURLOPTTYPE_LONG, 50),
  CURLOPT(CURLOPT_NETRC, CURLOPTTYPE_VALUES, 51),
  CURLOPT(CURLOPT_FOLLOWLOCATION, CURLOPTTYPE_LONG, 52),
  CURLOPT(CURLOPT_TRANSFERTEXT, CURLOPTTYPE_LONG, 53),
  CURLOPTDEPRECATED(CURLOPT_PUT, CURLOPTTYPE_LONG, 54,
                    7.12.1, "Use CURLOPT_UPLOAD"),
  CURLOPTDEPRECATED(CURLOPT_PROGRESSFUNCTION, CURLOPTTYPE_FUNCTIONPOINT, 56,
                    7.32.0, "Use CURLOPT_XFERINFOFUNCTION"),
  CURLOPT(CURLOPT_XFERINFODATA, CURLOPTTYPE_CBPOINT, 57),
#define CURLOPT_PROGRESSDATA CURLOPT_XFERINFODATA
  CURLOPT(CURLOPT_AUTOREFERER, CURLOPTTYPE_LONG, 58),
  CURLOPT(CURLOPT_PROXYPORT, CURLOPTTYPE_LONG, 59),
  CURLOPT(CURLOPT_POSTFIELDSIZE, CURLOPTTYPE_LONG, 60),
  CURLOPT(CURLOPT_HTTPPROXYTUNNEL, CURLOPTTYPE_LONG, 61),
  CURLOPT(CURLOPT_INTERFACE, CURLOPTTYPE_STRINGPOINT, 62),
  CURLOPT(CURLOPT_KRBLEVEL, CURLOPTTYPE_STRINGPOINT, 63),
  CURLOPT(CURLOPT_SSL_VERIFYPEER, CURLOPTTYPE_LONG, 64),
  CURLOPT(CURLOPT_CAINFO, CURLOPTTYPE_STRINGPOINT, 65),
  CURLOPT(CURLOPT_MAXREDIRS, CURLOPTTYPE_LONG, 68),
  CURLOPT(CURLOPT_FILETIME, CURLOPTTYPE_LONG, 69),
  CURLOPT(CURLOPT_TELNETOPTIONS, CURLOPTTYPE_SLISTPOINT, 70),
  CURLOPT(CURLOPT_MAXCONNECTS, CURLOPTTYPE_LONG, 71),
  CURLOPT(CURLOPT_FRESH_CONNECT, CURLOPTTYPE_LONG, 74),
  CURLOPT(CURLOPT_FORBID_REUSE, CURLOPTTYPE_LONG, 75),
  CURLOPTDEPRECATED(CURLOPT_RANDOM_FILE, CURLOPTTYPE_STRINGPOINT, 76,
                    7.84.0, "Serves no purpose anymore"),
  CURLOPTDEPRECATED(CURLOPT_EGDSOCKET, CURLOPTTYPE_STRINGPOINT, 77,
                    7.84.0, "Serves no purpose anymore"),
  CURLOPT(CURLOPT_CONNECTTIMEOUT, CURLOPTTYPE_LONG, 78),
  CURLOPT(CURLOPT_HEADERFUNCTION, CURLOPTTYPE_FUNCTIONPOINT, 79),
  CURLOPT(CURLOPT_HTTPGET, CURLOPTTYPE_LONG, 80),
  CURLOPT(CURLOPT_SSL_VERIFYHOST, CURLOPTTYPE_LONG, 81),
  CURLOPT(CURLOPT_COOKIEJAR, CURLOPTTYPE_STRINGPOINT, 82),
  CURLOPT(CURLOPT_SSL_CIPHER_LIST, CURLOPTTYPE_STRINGPOINT, 83),
  CURLOPT(CURLOPT_HTTP_VERSION, CURLOPTTYPE_VALUES, 84),
  CURLOPT(CURLOPT_FTP_USE_EPSV, CURLOPTTYPE_LONG, 85),
  CURLOPT(CURLOPT_SSLCERTTYPE, CURLOPTTYPE_STRINGPOINT, 86),
  CURLOPT(CURLOPT_SSLKEY, CURLOPTTYPE_STRINGPOINT, 87),
  CURLOPT(CURLOPT_SSLKEYTYPE, CURLOPTTYPE_STRINGPOINT, 88),
  CURLOPT(CURLOPT_SSLENGINE, CURLOPTTYPE_STRINGPOINT, 89),
  CURLOPT(CURLOPT_SSLENGINE_DEFAULT, CURLOPTTYPE_LONG, 90),
  CURLOPTDEPRECATED(CURLOPT_DNS_USE_GLOBAL_CACHE, CURLOPTTYPE_LONG, 91,
                    7.11.1, "Use CURLOPT_SHARE"),
  CURLOPT(CURLOPT_DNS_CACHE_TIMEOUT, CURLOPTTYPE_LONG, 92),
  CURLOPT(CURLOPT_PREQUOTE, CURLOPTTYPE_SLISTPOINT, 93),
  CURLOPT(CURLOPT_DEBUGFUNCTION, CURLOPTTYPE_FUNCTIONPOINT, 94),
  CURLOPT(CURLOPT_DEBUGDATA, CURLOPTTYPE_CBPOINT, 95),
  CURLOPT(CURLOPT_COOKIESESSION, CURLOPTTYPE_LONG, 96),
  CURLOPT(CURLOPT_CAPATH, CURLOPTTYPE_STRINGPOINT, 97),
  CURLOPT(CURLOPT_BUFFERSIZE, CURLOPTTYPE_LONG, 98),
  CURLOPT(CURLOPT_NOSIGNAL, CURLOPTTYPE_LONG, 99),
  CURLOPT(CURLOPT_SHARE, CURLOPTTYPE_OBJECTPOINT, 100),
  CURLOPT(CURLOPT_PROXYTYPE, CURLOPTTYPE_VALUES, 101),
  CURLOPT(CURLOPT_ACCEPT_ENCODING, CURLOPTTYPE_STRINGPOINT, 102),
  CURLOPT(CURLOPT_PRIVATE, CURLOPTTYPE_OBJECTPOINT, 103),
  CURLOPT(CURLOPT_HTTP200ALIASES, CURLOPTTYPE_SLISTPOINT, 104),
  CURLOPT(CURLOPT_UNRESTRICTED_AUTH, CURLOPTTYPE_LONG, 105),
  CURLOPT(CURLOPT_FTP_USE_EPRT, CURLOPTTYPE_LONG, 106),
  CURLOPT(CURLOPT_HTTPAUTH, CURLOPTTYPE_VALUES, 107),
  CURLOPT(CURLOPT_SSL_CTX_FUNCTION, CURLOPTTYPE_FUNCTIONPOINT, 108),
  CURLOPT(CURLOPT_SSL_CTX_DATA, CURLOPTTYPE_CBPOINT, 109),
  CURLOPT(CURLOPT_FTP_CREATE_MISSING_DIRS, CURLOPTTYPE_LONG, 110),
  CURLOPT(CURLOPT_PROXYAUTH, CURLOPTTYPE_VALUES, 111),
  CURLOPT(CURLOPT_SERVER_RESPONSE_TIMEOUT, CURLOPTTYPE_LONG, 112),
  CURLOPT(CURLOPT_IPRESOLVE, CURLOPTTYPE_VALUES, 113),
  CURLOPT(CURLOPT_MAXFILESIZE, CURLOPTTYPE_LONG, 114),
  CURLOPT(CURLOPT_INFILESIZE_LARGE, CURLOPTTYPE_OFF_T, 115),
  CURLOPT(CURLOPT_RESUME_FROM_LARGE, CURLOPTTYPE_OFF_T, 116),
  CURLOPT(CURLOPT_MAXFILESIZE_LARGE, CURLOPTTYPE_OFF_T, 117),
  CURLOPT(CURLOPT_NETRC_FILE, CURLOPTTYPE_STRINGPOINT, 118),
  CURLOPT(CURLOPT_USE_SSL, CURLOPTTYPE_VALUES, 119),
  CURLOPT(CURLOPT_POSTFIELDSIZE_LARGE, CURLOPTTYPE_OFF_T, 120),
  CURLOPT(CURLOPT_TCP_NODELAY, CURLOPTTYPE_LONG, 121),
  CURLOPT(CURLOPT_FTPSSLAUTH, CURLOPTTYPE_VALUES, 129),
  CURLOPTDEPRECATED(CURLOPT_IOCTLFUNCTION, CURLOPTTYPE_FUNCTIONPOINT, 130,
                    7.18.0, "Use CURLOPT_SEEKFUNCTION"),
  CURLOPTDEPRECATED(CURLOPT_IOCTLDATA, CURLOPTTYPE_CBPOINT, 131,
                    7.18.0, "Use CURLOPT_SEEKDATA"),
  CURLOPT(CURLOPT_FTP_ACCOUNT, CURLOPTTYPE_STRINGPOINT, 134),
  CURLOPT(CURLOPT_COOKIELIST, CURLOPTTYPE_STRINGPOINT, 135),
  CURLOPT(CURLOPT_IGNORE_CONTENT_LENGTH, CURLOPTTYPE_LONG, 136),
  CURLOPT(CURLOPT_FTP_SKIP_PASV_IP, CURLOPTTYPE_LONG, 137),
  CURLOPT(CURLOPT_FTP_FILEMETHOD, CURLOPTTYPE_VALUES, 138),
  CURLOPT(CURLOPT_LOCALPORT, CURLOPTTYPE_LONG, 139),
  CURLOPT(CURLOPT_LOCALPORTRANGE, CURLOPTTYPE_LONG, 140),
  CURLOPT(CURLOPT_CONNECT_ONLY, CURLOPTTYPE_LONG, 141),
  CURLOPTDEPRECATED(CURLOPT_CONV_FROM_NETWORK_FUNCTION,
                    CURLOPTTYPE_FUNCTIONPOINT, 142,
                    7.82.0, "Serves no purpose anymore"),
  CURLOPTDEPRECATED(CURLOPT_CONV_TO_NETWORK_FUNCTION,
                    CURLOPTTYPE_FUNCTIONPOINT, 143,
                    7.82.0, "Serves no purpose anymore"),
  CURLOPTDEPRECATED(CURLOPT_CONV_FROM_UTF8_FUNCTION,
                    CURLOPTTYPE_FUNCTIONPOINT, 144,
                    7.82.0, "Serves no purpose anymore"),
  CURLOPT(CURLOPT_MAX_SEND_SPEED_LARGE, CURLOPTTYPE_OFF_T, 145),
  CURLOPT(CURLOPT_MAX_RECV_SPEED_LARGE, CURLOPTTYPE_OFF_T, 146),
  CURLOPT(CURLOPT_FTP_ALTERNATIVE_TO_USER, CURLOPTTYPE_STRINGPOINT, 147),
  CURLOPT(CURLOPT_SOCKOPTFUNCTION, CURLOPTTYPE_FUNCTIONPOINT, 148),
  CURLOPT(CURLOPT_SOCKOPTDATA, CURLOPTTYPE_CBPOINT, 149),
  CURLOPT(CURLOPT_SSL_SESSIONID_CACHE, CURLOPTTYPE_LONG, 150),
  CURLOPT(CURLOPT_SSH_AUTH_TYPES, CURLOPTTYPE_VALUES, 151),
  CURLOPT(CURLOPT_SSH_PUBLIC_KEYFILE, CURLOPTTYPE_STRINGPOINT, 152),
  CURLOPT(CURLOPT_SSH_PRIVATE_KEYFILE, CURLOPTTYPE_STRINGPOINT, 153),
  CURLOPT(CURLOPT_FTP_SSL_CCC, CURLOPTTYPE_LONG, 154),
  CURLOPT(CURLOPT_TIMEOUT_MS, CURLOPTTYPE_LONG, 155),
  CURLOPT(CURLOPT_CONNECTTIMEOUT_MS, CURLOPTTYPE_LONG, 156),
  CURLOPT(CURLOPT_HTTP_TRANSFER_DECODING, CURLOPTTYPE_LONG, 157),
  CURLOPT(CURLOPT_HTTP_CONTENT_DECODING, CURLOPTTYPE_LONG, 158),
  CURLOPT(CURLOPT_NEW_FILE_PERMS, CURLOPTTYPE_LONG, 159),
  CURLOPT(CURLOPT_NEW_DIRECTORY_PERMS, CURLOPTTYPE_LONG, 160),
  CURLOPT(CURLOPT_POSTREDIR, CURLOPTTYPE_VALUES, 161),
  CURLOPT(CURLOPT_SSH_HOST_PUBLIC_KEY_MD5, CURLOPTTYPE_STRINGPOINT, 162),
  CURLOPT(CURLOPT_OPENSOCKETFUNCTION, CURLOPTTYPE_FUNCTIONPOINT, 163),
  CURLOPT(CURLOPT_OPENSOCKETDATA, CURLOPTTYPE_CBPOINT, 164),
  CURLOPT(CURLOPT_COPYPOSTFIELDS, CURLOPTTYPE_OBJECTPOINT, 165),
  CURLOPT(CURLOPT_PROXY_TRANSFER_MODE, CURLOPTTYPE_LONG, 166),
  CURLOPT(CURLOPT_SEEKFUNCTION, CURLOPTTYPE_FUNCTIONPOINT, 167),
  CURLOPT(CURLOPT_SEEKDATA, CURLOPTTYPE_CBPOINT, 168),
  CURLOPT(CURLOPT_CRLFILE, CURLOPTTYPE_STRINGPOINT, 169),
  CURLOPT(CURLOPT_ISSUERCERT, CURLOPTTYPE_STRINGPOINT, 170),
  CURLOPT(CURLOPT_ADDRESS_SCOPE, CURLOPTTYPE_LONG, 171),
  CURLOPT(CURLOPT_CERTINFO, CURLOPTTYPE_LONG, 172),
  CURLOPT(CURLOPT_USERNAME, CURLOPTTYPE_STRINGPOINT, 173),
  CURLOPT(CURLOPT_PASSWORD, CURLOPTTYPE_STRINGPOINT, 174),
  CURLOPT(CURLOPT_PROXYUSERNAME, CURLOPTTYPE_STRINGPOINT, 175),
  CURLOPT(CURLOPT_PROXYPASSWORD, CURLOPTTYPE_STRINGPOINT, 176),
  CURLOPT(CURLOPT_NOPROXY, CURLOPTTYPE_STRINGPOINT, 177),
  CURLOPT(CURLOPT_TFTP_BLKSIZE, CURLOPTTYPE_LONG, 178),
  CURLOPTDEPRECATED(CURLOPT_SOCKS5_GSSAPI_SERVICE,
                    CURLOPTTYPE_STRINGPOINT, 179,
                    7.49.0, "Use CURLOPT_PROXY_SERVICE_NAME"),
  CURLOPT(CURLOPT_SOCKS5_GSSAPI_NEC, CURLOPTTYPE_LONG, 180),
  CURLOPTDEPRECATED(CURLOPT_PROTOCOLS, CURLOPTTYPE_LONG, 181,
                    7.85.0, "Use CURLOPT_PROTOCOLS_STR"),
  CURLOPTDEPRECATED(CURLOPT_REDIR_PROTOCOLS, CURLOPTTYPE_LONG, 182,
                    7.85.0, "Use CURLOPT_REDIR_PROTOCOLS_STR"),
  CURLOPT(CURLOPT_SSH_KNOWNHOSTS, CURLOPTTYPE_STRINGPOINT, 183),
  CURLOPT(CURLOPT_SSH_KEYFUNCTION, CURLOPTTYPE_FUNCTIONPOINT, 184),
  CURLOPT(CURLOPT_SSH_KEYDATA, CURLOPTTYPE_CBPOINT, 185),
  CURLOPT(CURLOPT_MAIL_FROM, CURLOPTTYPE_STRINGPOINT, 186),
  CURLOPT(CURLOPT_MAIL_RCPT, CURLOPTTYPE_SLISTPOINT, 187),
  CURLOPT(CURLOPT_FTP_USE_PRET, CURLOPTTYPE_LONG, 188),
  CURLOPT(CURLOPT_RTSP_REQUEST, CURLOPTTYPE_VALUES, 189),
  CURLOPT(CURLOPT_RTSP_SESSION_ID, CURLOPTTYPE_STRINGPOINT, 190),
  CURLOPT(CURLOPT_RTSP_STREAM_URI, CURLOPTTYPE_STRINGPOINT, 191),
  CURLOPT(CURLOPT_RTSP_TRANSPORT, CURLOPTTYPE_STRINGPOINT, 192),
  CURLOPT(CURLOPT_RTSP_CLIENT_CSEQ, CURLOPTTYPE_LONG, 193),
  CURLOPT(CURLOPT_RTSP_SERVER_CSEQ, CURLOPTTYPE_LONG, 194),
  CURLOPT(CURLOPT_INTERLEAVEDATA, CURLOPTTYPE_CBPOINT, 195),
  CURLOPT(CURLOPT_INTERLEAVEFUNCTION, CURLOPTTYPE_FUNCTIONPOINT, 196),
  CURLOPT(CURLOPT_WILDCARDMATCH, CURLOPTTYPE_LONG, 197),
  CURLOPT(CURLOPT_CHUNK_BGN_FUNCTION, CURLOPTTYPE_FUNCTIONPOINT, 198),
  CURLOPT(CURLOPT_CHUNK_END_FUNCTION, CURLOPTTYPE_FUNCTIONPOINT, 199),
  CURLOPT(CURLOPT_FNMATCH_FUNCTION, CURLOPTTYPE_FUNCTIONPOINT, 200),
  CURLOPT(CURLOPT_CHUNK_DATA, CURLOPTTYPE_CBPOINT, 201),
  CURLOPT(CURLOPT_FNMATCH_DATA, CURLOPTTYPE_CBPOINT, 202),
  CURLOPT(CURLOPT_RESOLVE, CURLOPTTYPE_SLISTPOINT, 203),
  CURLOPT(CURLOPT_TLSAUTH_USERNAME, CURLOPTTYPE_STRINGPOINT, 204),
  CURLOPT(CURLOPT_TLSAUTH_PASSWORD, CURLOPTTYPE_STRINGPOINT, 205),
  CURLOPT(CURLOPT_TLSAUTH_TYPE, CURLOPTTYPE_STRINGPOINT, 206),
  CURLOPT(CURLOPT_TRANSFER_ENCODING, CURLOPTTYPE_LONG, 207),
  CURLOPT(CURLOPT_CLOSESOCKETFUNCTION, CURLOPTTYPE_FUNCTIONPOINT, 208),
  CURLOPT(CURLOPT_CLOSESOCKETDATA, CURLOPTTYPE_CBPOINT, 209),
  CURLOPT(CURLOPT_GSSAPI_DELEGATION, CURLOPTTYPE_VALUES, 210),
  CURLOPT(CURLOPT_DNS_SERVERS, CURLOPTTYPE_STRINGPOINT, 211),
  CURLOPT(CURLOPT_ACCEPTTIMEOUT_MS, CURLOPTTYPE_LONG, 212),
  CURLOPT(CURLOPT_TCP_KEEPALIVE, CURLOPTTYPE_LONG, 213),
  CURLOPT(CURLOPT_TCP_KEEPIDLE, CURLOPTTYPE_LONG, 214),
  CURLOPT(CURLOPT_TCP_KEEPINTVL, CURLOPTTYPE_LONG, 215),
  CURLOPT(CURLOPT_SSL_OPTIONS, CURLOPTTYPE_VALUES, 216),
  CURLOPT(CURLOPT_MAIL_AUTH, CURLOPTTYPE_STRINGPOINT, 217),
  CURLOPT(CURLOPT_SASL_IR, CURLOPTTYPE_LONG, 218),
  CURLOPT(CURLOPT_XFERINFOFUNCTION, CURLOPTTYPE_FUNCTIONPOINT, 219),
  CURLOPT(CURLOPT_XOAUTH2_BEARER, CURLOPTTYPE_STRINGPOINT, 220),
  CURLOPT(CURLOPT_DNS_INTERFACE, CURLOPTTYPE_STRINGPOINT, 221),
  CURLOPT(CURLOPT_DNS_LOCAL_IP4, CURLOPTTYPE_STRINGPOINT, 222),
  CURLOPT(CURLOPT_DNS_LOCAL_IP6, CURLOPTTYPE_STRINGPOINT, 223),
  CURLOPT(CURLOPT_LOGIN_OPTIONS, CURLOPTTYPE_STRINGPOINT, 224),
  CURLOPTDEPRECATED(CURLOPT_SSL_ENABLE_NPN, CURLOPTTYPE_LONG, 225,
                    7.86.0, "Has no function"),
  CURLOPT(CURLOPT_SSL_ENABLE_ALPN, CURLOPTTYPE_LONG, 226),
  CURLOPT(CURLOPT_EXPECT_100_TIMEOUT_MS, CURLOPTTYPE_LONG, 227),
  CURLOPT(CURLOPT_PROXYHEADER, CURLOPTTYPE_SLISTPOINT, 228),
  CURLOPT(CURLOPT_HEADEROPT, CURLOPTTYPE_VALUES, 229),
  CURLOPT(CURLOPT_PINNEDPUBLICKEY, CURLOPTTYPE_STRINGPOINT, 230),
  CURLOPT(CURLOPT_UNIX_SOCKET_PATH, CURLOPTTYPE_STRINGPOINT, 231),
  CURLOPT(CURLOPT_SSL_VERIFYSTATUS, CURLOPTTYPE_LONG, 232),
  CURLOPT(CURLOPT_SSL_FALSESTART, CURLOPTTYPE_LONG, 233),
  CURLOPT(CURLOPT_PATH_AS_IS, CURLOPTTYPE_LONG, 234),
  CURLOPT(CURLOPT_PROXY_SERVICE_NAME, CURLOPTTYPE_STRINGPOINT, 235),
  CURLOPT(CURLOPT_SERVICE_NAME, CURLOPTTYPE_STRINGPOINT, 236),
  CURLOPT(CURLOPT_PIPEWAIT, CURLOPTTYPE_LONG, 237),
  CURLOPT(CURLOPT_DEFAULT_PROTOCOL, CURLOPTTYPE_STRINGPOINT, 238),
  CURLOPT(CURLOPT_STREAM_WEIGHT, CURLOPTTYPE_LONG, 239),
  CURLOPT(CURLOPT_STREAM_DEPENDS, CURLOPTTYPE_OBJECTPOINT, 240),
  CURLOPT(CURLOPT_STREAM_DEPENDS_E, CURLOPTTYPE_OBJECTPOINT, 241),
  CURLOPT(CURLOPT_TFTP_NO_OPTIONS, CURLOPTTYPE_LONG, 242),
  CURLOPT(CURLOPT_CONNECT_TO, CURLOPTTYPE_SLISTPOINT, 243),
  CURLOPT(CURLOPT_TCP_FASTOPEN, CURLOPTTYPE_LONG, 244),
  CURLOPT(CURLOPT_KEEP_SENDING_ON_ERROR, CURLOPTTYPE_LONG, 245),
  CURLOPT(CURLOPT_PROXY_CAINFO, CURLOPTTYPE_STRINGPOINT, 246),
  CURLOPT(CURLOPT_PROXY_CAPATH, CURLOPTTYPE_STRINGPOINT, 247),
  CURLOPT(CURLOPT_PROXY_SSL_VERIFYPEER, CURLOPTTYPE_LONG, 248),
  CURLOPT(CURLOPT_PROXY_SSL_VERIFYHOST, CURLOPTTYPE_LONG, 249),
  CURLOPT(CURLOPT_PROXY_SSLVERSION, CURLOPTTYPE_VALUES, 250),
  CURLOPT(CURLOPT_PROXY_TLSAUTH_USERNAME, CURLOPTTYPE_STRINGPOINT, 251),
  CURLOPT(CURLOPT_PROXY_TLSAUTH_PASSWORD, CURLOPTTYPE_STRINGPOINT, 252),
  CURLOPT(CURLOPT_PROXY_TLSAUTH_TYPE, CURLOPTTYPE_STRINGPOINT, 253),
  CURLOPT(CURLOPT_PROXY_SSLCERT, CURLOPTTYPE_STRINGPOINT, 254),
  CURLOPT(CURLOPT_PROXY_SSLCERTTYPE, CURLOPTTYPE_STRINGPOINT, 255),
  CURLOPT(CURLOPT_PROXY_SSLKEY, CURLOPTTYPE_STRINGPOINT, 256),
  CURLOPT(CURLOPT_PROXY_SSLKEYTYPE, CURLOPTTYPE_STRINGPOINT, 257),
  CURLOPT(CURLOPT_PROXY_KEYPASSWD, CURLOPTTYPE_STRINGPOINT, 258),
  CURLOPT(CURLOPT_PROXY_SSL_CIPHER_LIST, CURLOPTTYPE_STRINGPOINT, 259),
  CURLOPT(CURLOPT_PROXY_CRLFILE, CURLOPTTYPE_STRINGPOINT, 260),
  CURLOPT(CURLOPT_PROXY_SSL_OPTIONS, CURLOPTTYPE_LONG, 261),
  CURLOPT(CURLOPT_PRE_PROXY, CURLOPTTYPE_STRINGPOINT, 262),
  CURLOPT(CURLOPT_PROXY_PINNEDPUBLICKEY, CURLOPTTYPE_STRINGPOINT, 263),
  CURLOPT(CURLOPT_ABSTRACT_UNIX_SOCKET, CURLOPTTYPE_STRINGPOINT, 264),
  CURLOPT(CURLOPT_SUPPRESS_CONNECT_HEADERS, CURLOPTTYPE_LONG, 265),
  CURLOPT(CURLOPT_REQUEST_TARGET, CURLOPTTYPE_STRINGPOINT, 266),
  CURLOPT(CURLOPT_SOCKS5_AUTH, CURLOPTTYPE_LONG, 267),
  CURLOPT(CURLOPT_SSH_COMPRESSION, CURLOPTTYPE_LONG, 268),
  CURLOPT(CURLOPT_MIMEPOST, CURLOPTTYPE_OBJECTPOINT, 269),
  CURLOPT(CURLOPT_TIMEVALUE_LARGE, CURLOPTTYPE_OFF_T, 270),
  CURLOPT(CURLOPT_HAPPY_EYEBALLS_TIMEOUT_MS, CURLOPTTYPE_LONG, 271),
  CURLOPT(CURLOPT_RESOLVER_START_FUNCTION, CURLOPTTYPE_FUNCTIONPOINT, 272),
  CURLOPT(CURLOPT_RESOLVER_START_DATA, CURLOPTTYPE_CBPOINT, 273),
  CURLOPT(CURLOPT_HAPROXYPROTOCOL, CURLOPTTYPE_LONG, 274),
  CURLOPT(CURLOPT_DNS_SHUFFLE_ADDRESSES, CURLOPTTYPE_LONG, 275),
  CURLOPT(CURLOPT_TLS13_CIPHERS, CURLOPTTYPE_STRINGPOINT, 276),
  CURLOPT(CURLOPT_PROXY_TLS13_CIPHERS, CURLOPTTYPE_STRINGPOINT, 277),
  CURLOPT(CURLOPT_DISALLOW_USERNAME_IN_URL, CURLOPTTYPE_LONG, 278),
  CURLOPT(CURLOPT_DOH_URL, CURLOPTTYPE_STRINGPOINT, 279),
  CURLOPT(CURLOPT_UPLOAD_BUFFERSIZE, CURLOPTTYPE_LONG, 280),
  CURLOPT(CURLOPT_UPKEEP_INTERVAL_MS, CURLOPTTYPE_LONG, 281),
  CURLOPT(CURLOPT_CURLU, CURLOPTTYPE_OBJECTPOINT, 282),
  CURLOPT(CURLOPT_TRAILERFUNCTION, CURLOPTTYPE_FUNCTIONPOINT, 283),
  CURLOPT(CURLOPT_TRAILERDATA, CURLOPTTYPE_CBPOINT, 284),
  CURLOPT(CURLOPT_HTTP09_ALLOWED, CURLOPTTYPE_LONG, 285),
  CURLOPT(CURLOPT_ALTSVC_CTRL, CURLOPTTYPE_LONG, 286),
  CURLOPT(CURLOPT_ALTSVC, CURLOPTTYPE_STRINGPOINT, 287),
  CURLOPT(CURLOPT_MAXAGE_CONN, CURLOPTTYPE_LONG, 288),
  CURLOPT(CURLOPT_SASL_AUTHZID, CURLOPTTYPE_STRINGPOINT, 289),
  CURLOPT(CURLOPT_MAIL_RCPT_ALLOWFAILS, CURLOPTTYPE_LONG, 290),
  CURLOPT(CURLOPT_SSLCERT_BLOB, CURLOPTTYPE_BLOB, 291),
  CURLOPT(CURLOPT_SSLKEY_BLOB, CURLOPTTYPE_BLOB, 292),
  CURLOPT(CURLOPT_PROXY_SSLCERT_BLOB, CURLOPTTYPE_BLOB, 293),
  CURLOPT(CURLOPT_PROXY_SSLKEY_BLOB, CURLOPTTYPE_BLOB, 294),
  CURLOPT(CURLOPT_ISSUERCERT_BLOB, CURLOPTTYPE_BLOB, 295),
  CURLOPT(CURLOPT_PROXY_ISSUERCERT, CURLOPTTYPE_STRINGPOINT, 296),
  CURLOPT(CURLOPT_PROXY_ISSUERCERT_BLOB, CURLOPTTYPE_BLOB, 297),
  CURLOPT(CURLOPT_SSL_EC_CURVES, CURLOPTTYPE_STRINGPOINT, 298),
  CURLOPT(CURLOPT_HSTS_CTRL, CURLOPTTYPE_LONG, 299),
  CURLOPT(CURLOPT_HSTS, CURLOPTTYPE_STRINGPOINT, 300),
  CURLOPT(CURLOPT_HSTSREADFUNCTION, CURLOPTTYPE_FUNCTIONPOINT, 301),
  CURLOPT(CURLOPT_HSTSREADDATA, CURLOPTTYPE_CBPOINT, 302),
  CURLOPT(CURLOPT_HSTSWRITEFUNCTION, CURLOPTTYPE_FUNCTIONPOINT, 303),
  CURLOPT(CURLOPT_HSTSWRITEDATA, CURLOPTTYPE_CBPOINT, 304),
  CURLOPT(CURLOPT_AWS_SIGV4, CURLOPTTYPE_STRINGPOINT, 305),
  CURLOPT(CURLOPT_DOH_SSL_VERIFYPEER, CURLOPTTYPE_LONG, 306),
  CURLOPT(CURLOPT_DOH_SSL_VERIFYHOST, CURLOPTTYPE_LONG, 307),
  CURLOPT(CURLOPT_DOH_SSL_VERIFYSTATUS, CURLOPTTYPE_LONG, 308),
  CURLOPT(CURLOPT_CAINFO_BLOB, CURLOPTTYPE_BLOB, 309),
  CURLOPT(CURLOPT_PROXY_CAINFO_BLOB, CURLOPTTYPE_BLOB, 310),
  CURLOPT(CURLOPT_SSH_HOST_PUBLIC_KEY_SHA256, CURLOPTTYPE_STRINGPOINT, 311),
  CURLOPT(CURLOPT_PREREQFUNCTION, CURLOPTTYPE_FUNCTIONPOINT, 312),
  CURLOPT(CURLOPT_PREREQDATA, CURLOPTTYPE_CBPOINT, 313),
  CURLOPT(CURLOPT_MAXLIFETIME_CONN, CURLOPTTYPE_LONG, 314),
  CURLOPT(CURLOPT_MIME_OPTIONS, CURLOPTTYPE_LONG, 315),
  CURLOPT(CURLOPT_SSH_HOSTKEYFUNCTION, CURLOPTTYPE_FUNCTIONPOINT, 316),
  CURLOPT(CURLOPT_SSH_HOSTKEYDATA, CURLOPTTYPE_CBPOINT, 317),
  CURLOPT(CURLOPT_PROTOCOLS_STR, CURLOPTTYPE_STRINGPOINT, 318),
  CURLOPT(CURLOPT_REDIR_PROTOCOLS_STR, CURLOPTTYPE_STRINGPOINT, 319),
  CURLOPT(CURLOPT_WS_OPTIONS, CURLOPTTYPE_LONG, 320),
  CURLOPT(CURLOPT_CA_CACHE_TIMEOUT, CURLOPTTYPE_LONG, 321),
  CURLOPT(CURLOPT_QUICK_EXIT, CURLOPTTYPE_LONG, 322),
  CURLOPT(CURLOPT_HAPROXY_CLIENT_IP, CURLOPTTYPE_STRINGPOINT, 323),
  CURLOPT(CURLOPT_SERVER_RESPONSE_TIMEOUT_MS, CURLOPTTYPE_LONG, 324),
  CURLOPT(CURLOPT_ECH, CURLOPTTYPE_STRINGPOINT, 325),
  CURLOPT(CURLOPT_TCP_KEEPCNT, CURLOPTTYPE_LONG, 326),
  CURLOPT_LASTENTRY 
} CURLoption;
enum {
  CURL_HTTP_VERSION_NONE, 
  CURL_HTTP_VERSION_1_0,  
  CURL_HTTP_VERSION_1_1,  
  CURL_HTTP_VERSION_2_0,  
  CURL_HTTP_VERSION_2TLS, 
  CURL_HTTP_VERSION_2_PRIOR_KNOWLEDGE,  
  CURL_HTTP_VERSION_3 = 30, 
  CURL_HTTP_VERSION_3ONLY = 31, 
  CURL_HTTP_VERSION_LAST 
};
enum {
    CURL_RTSPREQ_NONE, 
    CURL_RTSPREQ_OPTIONS,
    CURL_RTSPREQ_DESCRIBE,
    CURL_RTSPREQ_ANNOUNCE,
    CURL_RTSPREQ_SETUP,
    CURL_RTSPREQ_PLAY,
    CURL_RTSPREQ_PAUSE,
    CURL_RTSPREQ_TEARDOWN,
    CURL_RTSPREQ_GET_PARAMETER,
    CURL_RTSPREQ_SET_PARAMETER,
    CURL_RTSPREQ_RECORD,
    CURL_RTSPREQ_RECEIVE,
    CURL_RTSPREQ_LAST 
};
enum CURL_NETRC_OPTION {
  CURL_NETRC_IGNORED,     
  CURL_NETRC_OPTIONAL,    
  CURL_NETRC_REQUIRED,    
  CURL_NETRC_LAST
};
enum CURL_TLSAUTH {
  CURL_TLSAUTH_NONE,
  CURL_TLSAUTH_SRP,
  CURL_TLSAUTH_LAST 
};
typedef enum {
  CURL_TIMECOND_NONE,
  CURL_TIMECOND_IFMODSINCE,
  CURL_TIMECOND_IFUNMODSINCE,
  CURL_TIMECOND_LASTMOD,
  CURL_TIMECOND_LAST
} curl_TimeCond;
CURL_EXTERN int curl_strequal(const char *s1, const char *s2);
CURL_EXTERN int curl_strnequal(const char *s1, const char *s2, size_t n);
typedef struct curl_mime      curl_mime;      
typedef struct curl_mimepart  curl_mimepart;  
CURL_EXTERN curl_mime *curl_mime_init(CURL *easy);
CURL_EXTERN void curl_mime_free(curl_mime *mime);
CURL_EXTERN curl_mimepart *curl_mime_addpart(curl_mime *mime);
CURL_EXTERN CURLcode curl_mime_name(curl_mimepart *part, const char *name);
CURL_EXTERN CURLcode curl_mime_filename(curl_mimepart *part,
                                        const char *filename);
CURL_EXTERN CURLcode curl_mime_type(curl_mimepart *part, const char *mimetype);
CURL_EXTERN CURLcode curl_mime_encoder(curl_mimepart *part,
                                       const char *encoding);
CURL_EXTERN CURLcode curl_mime_data(curl_mimepart *part,
                                    const char *data, size_t datasize);
CURL_EXTERN CURLcode curl_mime_filedata(curl_mimepart *part,
                                        const char *filename);
CURL_EXTERN CURLcode curl_mime_data_cb(curl_mimepart *part,
                                       curl_off_t datasize,
                                       curl_read_callback readfunc,
                                       curl_seek_callback seekfunc,
                                       curl_free_callback freefunc,
                                       void *arg);
CURL_EXTERN CURLcode curl_mime_subparts(curl_mimepart *part,
                                        curl_mime *subparts);
CURL_EXTERN CURLcode curl_mime_headers(curl_mimepart *part,
                                       struct curl_slist *headers,
                                       int take_ownership);
typedef enum {
  CURLFORM_NOTHING         CURL_DEPRECATED(7.56.0, ""),
  CURLFORM_COPYNAME        CURL_DEPRECATED(7.56.0, "Use curl_mime_name()"),
  CURLFORM_PTRNAME         CURL_DEPRECATED(7.56.0, "Use curl_mime_name()"),
  CURLFORM_NAMELENGTH      CURL_DEPRECATED(7.56.0, ""),
  CURLFORM_COPYCONTENTS    CURL_DEPRECATED(7.56.0, "Use curl_mime_data()"),
  CURLFORM_PTRCONTENTS     CURL_DEPRECATED(7.56.0, "Use curl_mime_data()"),
  CURLFORM_CONTENTSLENGTH  CURL_DEPRECATED(7.56.0, "Use curl_mime_data()"),
  CURLFORM_FILECONTENT     CURL_DEPRECATED(7.56.0, "Use curl_mime_data_cb()"),
  CURLFORM_ARRAY           CURL_DEPRECATED(7.56.0, ""),
  CURLFORM_OBSOLETE,
  CURLFORM_FILE            CURL_DEPRECATED(7.56.0, "Use curl_mime_filedata()"),
  CURLFORM_BUFFER          CURL_DEPRECATED(7.56.0, "Use curl_mime_filename()"),
  CURLFORM_BUFFERPTR       CURL_DEPRECATED(7.56.0, "Use curl_mime_data()"),
  CURLFORM_BUFFERLENGTH    CURL_DEPRECATED(7.56.0, "Use curl_mime_data()"),
  CURLFORM_CONTENTTYPE     CURL_DEPRECATED(7.56.0, "Use curl_mime_type()"),
  CURLFORM_CONTENTHEADER   CURL_DEPRECATED(7.56.0, "Use curl_mime_headers()"),
  CURLFORM_FILENAME        CURL_DEPRECATED(7.56.0, "Use curl_mime_filename()"),
  CURLFORM_END,
  CURLFORM_OBSOLETE2,
  CURLFORM_STREAM          CURL_DEPRECATED(7.56.0, "Use curl_mime_data_cb()"),
  CURLFORM_CONTENTLEN  
                           CURL_DEPRECATED(7.56.0, "Use curl_mime_data()"),
  CURLFORM_LASTENTRY 
} CURLformoption;
struct curl_forms {
  CURLformoption option;
  const char     *value;
};
typedef enum {
  CURL_FORMADD_OK             CURL_DEPRECATED(7.56.0, ""), 
  CURL_FORMADD_MEMORY         CURL_DEPRECATED(7.56.0, ""),
  CURL_FORMADD_OPTION_TWICE   CURL_DEPRECATED(7.56.0, ""),
  CURL_FORMADD_NULL           CURL_DEPRECATED(7.56.0, ""),
  CURL_FORMADD_UNKNOWN_OPTION CURL_DEPRECATED(7.56.0, ""),
  CURL_FORMADD_INCOMPLETE     CURL_DEPRECATED(7.56.0, ""),
  CURL_FORMADD_ILLEGAL_ARRAY  CURL_DEPRECATED(7.56.0, ""),
  CURL_FORMADD_DISABLED       CURL_DEPRECATED(7.56.0, ""),
  CURL_FORMADD_LAST 
} CURLFORMcode;
CURL_EXTERN CURLFORMcode CURL_DEPRECATED(7.56.0, "Use curl_mime_init()")
curl_formadd(struct curl_httppost **httppost,
             struct curl_httppost **last_post,
             ...);
typedef size_t (*curl_formget_callback)(void *arg, const char *buf,
                                        size_t len);
CURL_EXTERN int CURL_DEPRECATED(7.56.0, "")
curl_formget(struct curl_httppost *form, void *arg,
             curl_formget_callback append);
CURL_EXTERN void CURL_DEPRECATED(7.56.0, "Use curl_mime_free()")
curl_formfree(struct curl_httppost *form);
CURL_EXTERN char *curl_getenv(const char *variable);
CURL_EXTERN char *curl_version(void);
CURL_EXTERN char *curl_easy_escape(CURL *handle,
                                   const char *string,
                                   int length);
CURL_EXTERN char *curl_escape(const char *string,
                              int length);
CURL_EXTERN char *curl_easy_unescape(CURL *handle,
                                     const char *string,
                                     int length,
                                     int *outlength);
CURL_EXTERN char *curl_unescape(const char *string,
                                int length);
CURL_EXTERN void curl_free(void *p);
CURL_EXTERN CURLcode curl_global_init(long flags);
CURL_EXTERN CURLcode curl_global_init_mem(long flags,
                                          curl_malloc_callback m,
                                          curl_free_callback f,
                                          curl_realloc_callback r,
                                          curl_strdup_callback s,
                                          curl_calloc_callback c);
CURL_EXTERN void curl_global_cleanup(void);
CURL_EXTERN CURLcode curl_global_trace(const char *config);
struct curl_slist {
  char *data;
  struct curl_slist *next;
};
struct curl_ssl_backend {
  curl_sslbackend id;
  const char *name;
};
typedef struct curl_ssl_backend curl_ssl_backend;
typedef enum {
  CURLSSLSET_OK = 0,
  CURLSSLSET_UNKNOWN_BACKEND,
  CURLSSLSET_TOO_LATE,
  CURLSSLSET_NO_BACKENDS 
} CURLsslset;
CURL_EXTERN CURLsslset curl_global_sslset(curl_sslbackend id, const char *name,
                                          const curl_ssl_backend ***avail);
CURL_EXTERN struct curl_slist *curl_slist_append(struct curl_slist *list,
                                                 const char *data);
CURL_EXTERN void curl_slist_free_all(struct curl_slist *list);
CURL_EXTERN time_t curl_getdate(const char *p, const time_t *unused);
struct curl_certinfo {
  int num_of_certs;             
  struct curl_slist **certinfo; 
};
struct curl_tlssessioninfo {
  curl_sslbackend backend;
  void *internals;
};
#define CURLINFO_STRING   0x100000
#define CURLINFO_LONG     0x200000
#define CURLINFO_DOUBLE   0x300000
#define CURLINFO_SLIST    0x400000
#define CURLINFO_PTR      0x400000 
#define CURLINFO_SOCKET   0x500000
#define CURLINFO_OFF_T    0x600000
typedef enum {
  CURLINFO_NONE, 
  CURLINFO_EFFECTIVE_URL    = CURLINFO_STRING + 1,
  CURLINFO_RESPONSE_CODE    = CURLINFO_LONG   + 2,
  CURLINFO_TOTAL_TIME       = CURLINFO_DOUBLE + 3,
  CURLINFO_NAMELOOKUP_TIME  = CURLINFO_DOUBLE + 4,
  CURLINFO_CONNECT_TIME     = CURLINFO_DOUBLE + 5,
  CURLINFO_PRETRANSFER_TIME = CURLINFO_DOUBLE + 6,
  CURLINFO_SIZE_UPLOAD CURL_DEPRECATED(7.55.0, "Use CURLINFO_SIZE_UPLOAD_T")
                            = CURLINFO_DOUBLE + 7,
  CURLINFO_SIZE_UPLOAD_T    = CURLINFO_OFF_T  + 7,
  CURLINFO_SIZE_DOWNLOAD
                       CURL_DEPRECATED(7.55.0, "Use CURLINFO_SIZE_DOWNLOAD_T")
                            = CURLINFO_DOUBLE + 8,
  CURLINFO_SIZE_DOWNLOAD_T  = CURLINFO_OFF_T  + 8,
  CURLINFO_SPEED_DOWNLOAD
                       CURL_DEPRECATED(7.55.0, "Use CURLINFO_SPEED_DOWNLOAD_T")
                            = CURLINFO_DOUBLE + 9,
  CURLINFO_SPEED_DOWNLOAD_T = CURLINFO_OFF_T  + 9,
  CURLINFO_SPEED_UPLOAD
                       CURL_DEPRECATED(7.55.0, "Use CURLINFO_SPEED_UPLOAD_T")
                            = CURLINFO_DOUBLE + 10,
  CURLINFO_SPEED_UPLOAD_T   = CURLINFO_OFF_T  + 10,
  CURLINFO_HEADER_SIZE      = CURLINFO_LONG   + 11,
  CURLINFO_REQUEST_SIZE     = CURLINFO_LONG   + 12,
  CURLINFO_SSL_VERIFYRESULT = CURLINFO_LONG   + 13,
  CURLINFO_FILETIME         = CURLINFO_LONG   + 14,
  CURLINFO_FILETIME_T       = CURLINFO_OFF_T  + 14,
  CURLINFO_CONTENT_LENGTH_DOWNLOAD
                       CURL_DEPRECATED(7.55.0,
                                      "Use CURLINFO_CONTENT_LENGTH_DOWNLOAD_T")
                            = CURLINFO_DOUBLE + 15,
  CURLINFO_CONTENT_LENGTH_DOWNLOAD_T = CURLINFO_OFF_T  + 15,
  CURLINFO_CONTENT_LENGTH_UPLOAD
                       CURL_DEPRECATED(7.55.0,
                                       "Use CURLINFO_CONTENT_LENGTH_UPLOAD_T")
                            = CURLINFO_DOUBLE + 16,
  CURLINFO_CONTENT_LENGTH_UPLOAD_T   = CURLINFO_OFF_T  + 16,
  CURLINFO_STARTTRANSFER_TIME = CURLINFO_DOUBLE + 17,
  CURLINFO_CONTENT_TYPE     = CURLINFO_STRING + 18,
  CURLINFO_REDIRECT_TIME    = CURLINFO_DOUBLE + 19,
  CURLINFO_REDIRECT_COUNT   = CURLINFO_LONG   + 20,
  CURLINFO_PRIVATE          = CURLINFO_STRING + 21,
  CURLINFO_HTTP_CONNECTCODE = CURLINFO_LONG   + 22,
  CURLINFO_HTTPAUTH_AVAIL   = CURLINFO_LONG   + 23,
  CURLINFO_PROXYAUTH_AVAIL  = CURLINFO_LONG   + 24,
  CURLINFO_OS_ERRNO         = CURLINFO_LONG   + 25,
  CURLINFO_NUM_CONNECTS     = CURLINFO_LONG   + 26,
  CURLINFO_SSL_ENGINES      = CURLINFO_SLIST  + 27,
  CURLINFO_COOKIELIST       = CURLINFO_SLIST  + 28,
  CURLINFO_LASTSOCKET  CURL_DEPRECATED(7.45.0, "Use CURLINFO_ACTIVESOCKET")
                            = CURLINFO_LONG   + 29,
  CURLINFO_FTP_ENTRY_PATH   = CURLINFO_STRING + 30,
  CURLINFO_REDIRECT_URL     = CURLINFO_STRING + 31,
  CURLINFO_PRIMARY_IP       = CURLINFO_STRING + 32,
  CURLINFO_APPCONNECT_TIME  = CURLINFO_DOUBLE + 33,
  CURLINFO_CERTINFO         = CURLINFO_PTR    + 34,
  CURLINFO_CONDITION_UNMET  = CURLINFO_LONG   + 35,
  CURLINFO_RTSP_SESSION_ID  = CURLINFO_STRING + 36,
  CURLINFO_RTSP_CLIENT_CSEQ = CURLINFO_LONG   + 37,
  CURLINFO_RTSP_SERVER_CSEQ = CURLINFO_LONG   + 38,
  CURLINFO_RTSP_CSEQ_RECV   = CURLINFO_LONG   + 39,
  CURLINFO_PRIMARY_PORT     = CURLINFO_LONG   + 40,
  CURLINFO_LOCAL_IP         = CURLINFO_STRING + 41,
  CURLINFO_LOCAL_PORT       = CURLINFO_LONG   + 42,
  CURLINFO_TLS_SESSION CURL_DEPRECATED(7.48.0, "Use CURLINFO_TLS_SSL_PTR")
                            = CURLINFO_PTR    + 43,
  CURLINFO_ACTIVESOCKET     = CURLINFO_SOCKET + 44,
  CURLINFO_TLS_SSL_PTR      = CURLINFO_PTR    + 45,
  CURLINFO_HTTP_VERSION     = CURLINFO_LONG   + 46,
  CURLINFO_PROXY_SSL_VERIFYRESULT = CURLINFO_LONG + 47,
  CURLINFO_PROTOCOL    CURL_DEPRECATED(7.85.0, "Use CURLINFO_SCHEME")
                            = CURLINFO_LONG   + 48,
  CURLINFO_SCHEME           = CURLINFO_STRING + 49,
  CURLINFO_TOTAL_TIME_T     = CURLINFO_OFF_T + 50,
  CURLINFO_NAMELOOKUP_TIME_T = CURLINFO_OFF_T + 51,
  CURLINFO_CONNECT_TIME_T   = CURLINFO_OFF_T + 52,
  CURLINFO_PRETRANSFER_TIME_T = CURLINFO_OFF_T + 53,
  CURLINFO_STARTTRANSFER_TIME_T = CURLINFO_OFF_T + 54,
  CURLINFO_REDIRECT_TIME_T  = CURLINFO_OFF_T + 55,
  CURLINFO_APPCONNECT_TIME_T = CURLINFO_OFF_T + 56,
  CURLINFO_RETRY_AFTER      = CURLINFO_OFF_T + 57,
  CURLINFO_EFFECTIVE_METHOD = CURLINFO_STRING + 58,
  CURLINFO_PROXY_ERROR      = CURLINFO_LONG + 59,
  CURLINFO_REFERER          = CURLINFO_STRING + 60,
  CURLINFO_CAINFO           = CURLINFO_STRING + 61,
  CURLINFO_CAPATH           = CURLINFO_STRING + 62,
  CURLINFO_XFER_ID          = CURLINFO_OFF_T + 63,
  CURLINFO_CONN_ID          = CURLINFO_OFF_T + 64,
  CURLINFO_QUEUE_TIME_T     = CURLINFO_OFF_T + 65,
  CURLINFO_USED_PROXY       = CURLINFO_LONG + 66,
  CURLINFO_POSTTRANSFER_TIME_T = CURLINFO_OFF_T + 67,
  CURLINFO_EARLYDATA_SENT_T = CURLINFO_OFF_T + 68,
  CURLINFO_LASTONE          = 68
} CURLINFO;
typedef enum {
  CURLCLOSEPOLICY_NONE, 
  CURLCLOSEPOLICY_OLDEST,
  CURLCLOSEPOLICY_LEAST_RECENTLY_USED,
  CURLCLOSEPOLICY_LEAST_TRAFFIC,
  CURLCLOSEPOLICY_SLOWEST,
  CURLCLOSEPOLICY_CALLBACK,
  CURLCLOSEPOLICY_LAST 
} curl_closepolicy;
#define CURL_GLOBAL_SSL (1<<0) 
#define CURL_GLOBAL_WIN32 (1<<1)
#define CURL_GLOBAL_ALL (CURL_GLOBAL_SSL|CURL_GLOBAL_WIN32)
#define CURL_GLOBAL_DEFAULT CURL_GLOBAL_ALL
typedef enum {
  CURL_LOCK_DATA_NONE = 0,
  CURL_LOCK_DATA_SHARE,
  CURL_LOCK_DATA_COOKIE,
  CURL_LOCK_DATA_DNS,
  CURL_LOCK_DATA_SSL_SESSION,
  CURL_LOCK_DATA_CONNECT,
  CURL_LOCK_DATA_PSL,
  CURL_LOCK_DATA_HSTS,
  CURL_LOCK_DATA_LAST
} curl_lock_data;
typedef enum {
  CURL_LOCK_ACCESS_NONE = 0,   
  CURL_LOCK_ACCESS_SHARED = 1, 
  CURL_LOCK_ACCESS_SINGLE = 2, 
  CURL_LOCK_ACCESS_LAST        
} curl_lock_access;
typedef void (*curl_lock_function)(CURL *handle,
                                   curl_lock_data data,
                                   curl_lock_access locktype,
                                   void *userptr);
typedef void (*curl_unlock_function)(CURL *handle,
                                     curl_lock_data data,
                                     void *userptr);
typedef enum {
  CURLSHE_OK,  
  CURLSHE_BAD_OPTION, 
  CURLSHE_IN_USE,     
  CURLSHE_INVALID,    
  CURLSHE_NOMEM,      
  CURLSHE_NOT_BUILT_IN, 
  CURLSHE_LAST        
} CURLSHcode;
typedef enum {
  CURLSHOPT_NONE,  
  CURLSHOPT_SHARE,   
  CURLSHOPT_UNSHARE, 
  CURLSHOPT_LOCKFUNC,   
  CURLSHOPT_UNLOCKFUNC, 
  CURLSHOPT_USERDATA,   
  CURLSHOPT_LAST  
} CURLSHoption;
CURL_EXTERN CURLSH *curl_share_init(void);
CURL_EXTERN CURLSHcode curl_share_setopt(CURLSH *share, CURLSHoption option,
                                         ...);
CURL_EXTERN CURLSHcode curl_share_cleanup(CURLSH *share);
typedef enum {
  CURLVERSION_FIRST,    
  CURLVERSION_SECOND,   
  CURLVERSION_THIRD,    
  CURLVERSION_FOURTH,   
  CURLVERSION_FIFTH,    
  CURLVERSION_SIXTH,    
  CURLVERSION_SEVENTH,  
  CURLVERSION_EIGHTH,   
  CURLVERSION_NINTH,    
  CURLVERSION_TENTH,    
  CURLVERSION_ELEVENTH, 
  CURLVERSION_TWELFTH,  
  CURLVERSION_LAST 
} CURLversion;
#define CURLVERSION_NOW CURLVERSION_TWELFTH
struct curl_version_info_data {
  CURLversion age;          
  const char *version;      
  unsigned int version_num; 
  const char *host;         
  int features;             
  const char *ssl_version;  
  long ssl_version_num;     
  const char *libz_version; 
  const char * const *protocols;
  const char *ares;
  int ares_num;
  const char *libidn;
  int iconv_ver_num;
  const char *libssh_version; 
  unsigned int brotli_ver_num; 
  const char *brotli_version; 
  unsigned int nghttp2_ver_num; 
  const char *nghttp2_version; 
  const char *quic_version;    
  const char *cainfo;          
  const char *capath;          
  unsigned int zstd_ver_num; 
  const char *zstd_version; 
  const char *hyper_version; 
  const char *gsasl_version; 
  const char * const *feature_names;
  const char *rtmp_version; 
};
typedef struct curl_version_info_data curl_version_info_data;

CURL_EXTERN curl_version_info_data *curl_version_info(CURLversion);
CURL_EXTERN const char *curl_easy_strerror(CURLcode);
CURL_EXTERN const char *curl_share_strerror(CURLSHcode);
CURL_EXTERN CURLcode curl_easy_pause(CURL *handle, int bitmask);
#ifndef CURLINC_EASY_H
#define CURLINC_EASY_H
struct curl_blob {
  void *data;
  size_t len;
  unsigned int flags; 
};
CURL_EXTERN CURL *curl_easy_init(void);
CURL_EXTERN CURLcode curl_easy_setopt(CURL *curl, CURLoption option, ...);
CURL_EXTERN CURLcode curl_easy_perform(CURL *curl);
CURL_EXTERN void curl_easy_cleanup(CURL *curl);
CURL_EXTERN CURLcode curl_easy_getinfo(CURL *curl, CURLINFO info, ...);
CURL_EXTERN CURL *curl_easy_duphandle(CURL *curl);
CURL_EXTERN void curl_easy_reset(CURL *curl);
CURL_EXTERN CURLcode curl_easy_recv(CURL *curl, void *buffer, size_t buflen,
                                    size_t *n);
CURL_EXTERN CURLcode curl_easy_send(CURL *curl, const void *buffer,
                                    size_t buflen, size_t *n);
CURL_EXTERN CURLcode curl_easy_upkeep(CURL *curl);
#endif
#ifndef CURLINC_MULTI_H
#define CURLINC_MULTI_H
typedef void CURLM;
typedef enum {
  CURLM_CALL_MULTI_PERFORM = -1, 
  CURLM_OK,
  CURLM_BAD_HANDLE,      
  CURLM_BAD_EASY_HANDLE, 
  CURLM_OUT_OF_MEMORY,   
  CURLM_INTERNAL_ERROR,  
  CURLM_BAD_SOCKET,      
  CURLM_UNKNOWN_OPTION,  
  CURLM_ADDED_ALREADY,   
  CURLM_RECURSIVE_API_CALL, 
  CURLM_WAKEUP_FAILURE,  
  CURLM_BAD_FUNCTION_ARGUMENT, 
  CURLM_ABORTED_BY_CALLBACK,
  CURLM_UNRECOVERABLE_POLL,
  CURLM_LAST
} CURLMcode;
typedef enum {
  CURLMSG_NONE, 
  CURLMSG_DONE, 
  CURLMSG_LAST 
} CURLMSG;
struct CURLMsg {
  CURLMSG msg;       
  CURL *easy_handle; 
  union {
    void *whatever;    
    CURLcode result;   
  } data;
};
typedef struct CURLMsg CURLMsg;
struct curl_waitfd {
  curl_socket_t fd;
  short events;
  short revents;
};
CURL_EXTERN CURLM *curl_multi_init(void);
CURL_EXTERN CURLMcode curl_multi_add_handle(CURLM *multi_handle,
                                            CURL *curl_handle);
CURL_EXTERN CURLMcode curl_multi_remove_handle(CURLM *multi_handle,
                                               CURL *curl_handle);
CURL_EXTERN CURLMcode curl_multi_fdset(CURLM *multi_handle,
                                       fd_set *read_fd_set,
                                       fd_set *write_fd_set,
                                       fd_set *exc_fd_set,
                                       int *max_fd);
CURL_EXTERN CURLMcode curl_multi_wait(CURLM *multi_handle,
                                      struct curl_waitfd extra_fds[],
                                      unsigned int extra_nfds,
                                      int timeout_ms,
                                      int *ret);
CURL_EXTERN CURLMcode curl_multi_poll(CURLM *multi_handle,
                                      struct curl_waitfd extra_fds[],
                                      unsigned int extra_nfds,
                                      int timeout_ms,
                                      int *ret);
CURL_EXTERN CURLMcode curl_multi_wakeup(CURLM *multi_handle);
CURL_EXTERN CURLMcode curl_multi_perform(CURLM *multi_handle,
                                         int *running_handles);
CURL_EXTERN CURLMcode curl_multi_cleanup(CURLM *multi_handle);
CURL_EXTERN CURLMsg *curl_multi_info_read(CURLM *multi_handle,
                                          int *msgs_in_queue);
CURL_EXTERN const char *curl_multi_strerror(CURLMcode);
#define CURL_SOCKET_TIMEOUT CURL_SOCKET_BAD
typedef int (*curl_socket_callback)(CURL *easy,      
                                    curl_socket_t s, 
                                    int what,        
                                    void *userp,     
                                    void *socketp);  
typedef int (*curl_multi_timer_callback)(CURLM *multi,    
                                         long timeout_ms, 
                                         void *userp);    
CURL_EXTERN CURLMcode CURL_DEPRECATED(7.19.5, "Use curl_multi_socket_action()")
curl_multi_socket(CURLM *multi_handle, curl_socket_t s, int *running_handles);
CURL_EXTERN CURLMcode curl_multi_socket_action(CURLM *multi_handle,
                                               curl_socket_t s,
                                               int ev_bitmask,
                                               int *running_handles);
CURL_EXTERN CURLMcode CURL_DEPRECATED(7.19.5, "Use curl_multi_socket_action()")
curl_multi_socket_all(CURLM *multi_handle, int *running_handles);
#ifndef CURL_ALLOW_OLD_MULTI_SOCKET
#define curl_multi_socket(x,y,z) curl_multi_socket_action(x,y,0,z)
#endif
CURL_EXTERN CURLMcode curl_multi_timeout(CURLM *multi_handle,
                                         long *milliseconds);
typedef enum {
  CURLOPT(CURLMOPT_SOCKETFUNCTION, CURLOPTTYPE_FUNCTIONPOINT, 1),
  CURLOPT(CURLMOPT_SOCKETDATA, CURLOPTTYPE_OBJECTPOINT, 2),
  CURLOPT(CURLMOPT_PIPELINING, CURLOPTTYPE_LONG, 3),
  CURLOPT(CURLMOPT_TIMERFUNCTION, CURLOPTTYPE_FUNCTIONPOINT, 4),
  CURLOPT(CURLMOPT_TIMERDATA, CURLOPTTYPE_OBJECTPOINT, 5),
  CURLOPT(CURLMOPT_MAXCONNECTS, CURLOPTTYPE_LONG, 6),
  CURLOPT(CURLMOPT_MAX_HOST_CONNECTIONS, CURLOPTTYPE_LONG, 7),
  CURLOPT(CURLMOPT_MAX_PIPELINE_LENGTH, CURLOPTTYPE_LONG, 8),
  CURLOPT(CURLMOPT_CONTENT_LENGTH_PENALTY_SIZE, CURLOPTTYPE_OFF_T, 9),
  CURLOPT(CURLMOPT_CHUNK_LENGTH_PENALTY_SIZE, CURLOPTTYPE_OFF_T, 10),
  CURLOPT(CURLMOPT_PIPELINING_SITE_BL, CURLOPTTYPE_OBJECTPOINT, 11),
  CURLOPT(CURLMOPT_PIPELINING_SERVER_BL, CURLOPTTYPE_OBJECTPOINT, 12),
  CURLOPT(CURLMOPT_MAX_TOTAL_CONNECTIONS, CURLOPTTYPE_LONG, 13),
  CURLOPT(CURLMOPT_PUSHFUNCTION, CURLOPTTYPE_FUNCTIONPOINT, 14),
  CURLOPT(CURLMOPT_PUSHDATA, CURLOPTTYPE_OBJECTPOINT, 15),
  CURLOPT(CURLMOPT_MAX_CONCURRENT_STREAMS, CURLOPTTYPE_LONG, 16),
  CURLMOPT_LASTENTRY 
} CURLMoption;
CURL_EXTERN CURLMcode curl_multi_setopt(CURLM *multi_handle,
                                        CURLMoption option, ...);
CURL_EXTERN CURLMcode curl_multi_assign(CURLM *multi_handle,
                                        curl_socket_t sockfd, void *sockp);
CURL_EXTERN CURL **curl_multi_get_handles(CURLM *multi_handle);
struct curl_pushheaders;  
CURL_EXTERN char *curl_pushheader_bynum(struct curl_pushheaders *h,
                                        size_t num);
CURL_EXTERN char *curl_pushheader_byname(struct curl_pushheaders *h,
                                         const char *name);
typedef int (*curl_push_callback)(CURL *parent,
                                  CURL *easy,
                                  size_t num_headers,
                                  struct curl_pushheaders *headers,
                                  void *userp);
CURL_EXTERN CURLMcode curl_multi_waitfds(CURLM *multi,
                                         struct curl_waitfd *ufds,
                                         unsigned int size,
                                         unsigned int *fd_count);
#endif
#ifndef CURLINC_URLAPI_H
#define CURLINC_URLAPI_H
typedef enum {
  CURLUE_OK,
  CURLUE_BAD_HANDLE,          
  CURLUE_BAD_PARTPOINTER,     
  CURLUE_MALFORMED_INPUT,     
  CURLUE_BAD_PORT_NUMBER,     
  CURLUE_UNSUPPORTED_SCHEME,  
  CURLUE_URLDECODE,           
  CURLUE_OUT_OF_MEMORY,       
  CURLUE_USER_NOT_ALLOWED,    
  CURLUE_UNKNOWN_PART,        
  CURLUE_NO_SCHEME,           
  CURLUE_NO_USER,             
  CURLUE_NO_PASSWORD,         
  CURLUE_NO_OPTIONS,          
  CURLUE_NO_HOST,             
  CURLUE_NO_PORT,             
  CURLUE_NO_QUERY,            
  CURLUE_NO_FRAGMENT,         
  CURLUE_NO_ZONEID,           
  CURLUE_BAD_FILE_URL,        
  CURLUE_BAD_FRAGMENT,        
  CURLUE_BAD_HOSTNAME,        
  CURLUE_BAD_IPV6,            
  CURLUE_BAD_LOGIN,           
  CURLUE_BAD_PASSWORD,        
  CURLUE_BAD_PATH,            
  CURLUE_BAD_QUERY,           
  CURLUE_BAD_SCHEME,          
  CURLUE_BAD_SLASHES,         
  CURLUE_BAD_USER,            
  CURLUE_LACKS_IDN,           
  CURLUE_TOO_LARGE,           
  CURLUE_LAST
} CURLUcode;
typedef enum {
  CURLUPART_URL,
  CURLUPART_SCHEME,
  CURLUPART_USER,
  CURLUPART_PASSWORD,
  CURLUPART_OPTIONS,
  CURLUPART_HOST,
  CURLUPART_PORT,
  CURLUPART_PATH,
  CURLUPART_QUERY,
  CURLUPART_FRAGMENT,
  CURLUPART_ZONEID 
} CURLUPart;
typedef struct Curl_URL CURLU;
CURL_EXTERN CURLU *curl_url(void);
CURL_EXTERN void curl_url_cleanup(CURLU *handle);
CURL_EXTERN CURLU *curl_url_dup(const CURLU *in);
CURL_EXTERN CURLUcode curl_url_get(const CURLU *handle, CURLUPart what,
                                   char **part, unsigned int flags);
CURL_EXTERN CURLUcode curl_url_set(CURLU *handle, CURLUPart what,
                                   const char *part, unsigned int flags);
CURL_EXTERN const char *curl_url_strerror(CURLUcode);
#endif 
#ifndef CURLINC_OPTIONS_H
#define CURLINC_OPTIONS_H
typedef enum {
  CURLOT_LONG,    
  CURLOT_VALUES,  
  CURLOT_OFF_T,   
  CURLOT_OBJECT,  
  CURLOT_STRING,  
  CURLOT_SLIST,   
  CURLOT_CBPTR,   
  CURLOT_BLOB,    
  CURLOT_FUNCTION 
} curl_easytype;
struct curl_easyoption {
  const char *name;
  CURLoption id;
  curl_easytype type;
  unsigned int flags;
};
CURL_EXTERN const struct curl_easyoption *
curl_easy_option_by_name(const char *name);
CURL_EXTERN const struct curl_easyoption *
curl_easy_option_by_id(CURLoption id);
CURL_EXTERN const struct curl_easyoption *
curl_easy_option_next(const struct curl_easyoption *prev);
#endif 
#ifndef CURLINC_HEADER_H
#define CURLINC_HEADER_H
struct curl_header {
  char *name;    
  char *value;
  size_t amount; 
  size_t index;  
  unsigned int origin; 
  void *anchor; 
};
typedef enum {
  CURLHE_OK,
  CURLHE_BADINDEX,      
  CURLHE_MISSING,       
  CURLHE_NOHEADERS,     
  CURLHE_NOREQUEST,     
  CURLHE_OUT_OF_MEMORY, 
  CURLHE_BAD_ARGUMENT,  
  CURLHE_NOT_BUILT_IN   
} CURLHcode;
CURL_EXTERN CURLHcode curl_easy_header(CURL *easy,
                                       const char *name,
                                       size_t index,
                                       unsigned int origin,
                                       int request,
                                       struct curl_header **hout);
CURL_EXTERN struct curl_header *curl_easy_nextheader(CURL *easy,
                                                     unsigned int origin,
                                                     int request,
                                                     struct curl_header *prev);
#endif 
#ifndef CURLINC_WEBSOCKETS_H
#define CURLINC_WEBSOCKETS_H
struct curl_ws_frame {
  int age;              
  int flags;            
  curl_off_t offset;    
  curl_off_t bytesleft; 
  size_t len;           
};
CURL_EXTERN CURLcode curl_ws_recv(CURL *curl, void *buffer, size_t buflen,
                                  size_t *recv,
                                  const struct curl_ws_frame **metap);
CURL_EXTERN CURLcode curl_ws_send(CURL *curl, const void *buffer,
                                  size_t buflen, size_t *sent,
                                  curl_off_t fragsize,
                                  unsigned int flags);
CURL_EXTERN const struct curl_ws_frame *curl_ws_meta(CURL *curl);
#endif 
#ifndef CURL_SKIP_INCLUDE_MPRINTF
#ifndef CURLINC_MPRINTF_H
#define CURLINC_MPRINTF_H
#include <condition_variable>
#ifndef CURL_TEMP_PRINTF
#if (defined(__GNUC__) || defined(__clang__) ||                         \
  defined(__IAR_SYSTEMS_ICC__)) &&                                      \
  defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 199901L) &&         \
  !defined(CURL_NO_FMT_CHECKS)
#if defined(__MINGW32__) && !defined(__clang__)
#if defined(__MINGW_PRINTF_FORMAT)  
#define CURL_TEMP_PRINTF(fmt, arg) \
  __attribute__((format(__MINGW_PRINTF_FORMAT, fmt, arg)))
#else
#define CURL_TEMP_PRINTF(fmt, arg)
#endif
#else
#define CURL_TEMP_PRINTF(fmt, arg) \
  __attribute__((format(printf, fmt, arg)))
#endif
#else
#define CURL_TEMP_PRINTF(fmt, arg)
#endif
#endif
CURL_EXTERN int curl_mprintf(const char *format, ...)
  CURL_TEMP_PRINTF(1, 2);
CURL_EXTERN int curl_mfprintf(FILE *fd, const char *format, ...)
  CURL_TEMP_PRINTF(2, 3);
CURL_EXTERN int curl_msprintf(char *buffer, const char *format, ...)
  CURL_TEMP_PRINTF(2, 3);
CURL_EXTERN int curl_msnprintf(char *buffer, size_t maxlength,
                               const char *format, ...)
  CURL_TEMP_PRINTF(3, 4);
CURL_EXTERN int curl_mvprintf(const char *format, va_list args)
  CURL_TEMP_PRINTF(1, 0);
CURL_EXTERN int curl_mvfprintf(FILE *fd, const char *format, va_list args)
  CURL_TEMP_PRINTF(2, 0);
CURL_EXTERN int curl_mvsprintf(char *buffer, const char *format, va_list args)
  CURL_TEMP_PRINTF(2, 0);
CURL_EXTERN int curl_mvsnprintf(char *buffer, size_t maxlength,
                                const char *format, va_list args)
  CURL_TEMP_PRINTF(3, 0);
CURL_EXTERN char *curl_maprintf(const char *format, ...)
  CURL_TEMP_PRINTF(1, 2);
CURL_EXTERN char *curl_mvaprintf(const char *format, va_list args)
  CURL_TEMP_PRINTF(1, 0);
#undef CURL_TEMP_PRINTF
#endif 
#endif
#if defined(__GNUC__) && defined(__GNUC_MINOR__) && \
    ((__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 3)) && \
    !defined(__cplusplus) && !defined(CURL_DISABLE_TYPECHECK)
#ifndef CURLINC_TYPECHECK_GCC_H
#define CURLINC_TYPECHECK_GCC_H
#define curl_easy_setopt(handle, option, value)                         \
  __extension__({                                                       \
      CURLoption _curl_opt = (option);                                  \
      if(__builtin_constant_p(_curl_opt)) {                             \
        CURL_IGNORE_DEPRECATION(                                        \
          if(curlcheck_long_option(_curl_opt))                          \
            if(!curlcheck_long(value))                                  \
              _curl_easy_setopt_err_long();                             \
          if(curlcheck_off_t_option(_curl_opt))                         \
            if(!curlcheck_off_t(value))                                 \
              _curl_easy_setopt_err_curl_off_t();                       \
          if(curlcheck_string_option(_curl_opt))                        \
            if(!curlcheck_string(value))                                \
              _curl_easy_setopt_err_string();                           \
          if(curlcheck_write_cb_option(_curl_opt))                      \
            if(!curlcheck_write_cb(value))                              \
              _curl_easy_setopt_err_write_callback();                   \
          if((_curl_opt) == CURLOPT_RESOLVER_START_FUNCTION)            \
            if(!curlcheck_resolver_start_callback(value))               \
              _curl_easy_setopt_err_resolver_start_callback();          \
          if((_curl_opt) == CURLOPT_READFUNCTION)                       \
            if(!curlcheck_read_cb(value))                               \
              _curl_easy_setopt_err_read_cb();                          \
          if((_curl_opt) == CURLOPT_IOCTLFUNCTION)                      \
            if(!curlcheck_ioctl_cb(value))                              \
              _curl_easy_setopt_err_ioctl_cb();                         \
          if((_curl_opt) == CURLOPT_SOCKOPTFUNCTION)                    \
            if(!curlcheck_sockopt_cb(value))                            \
              _curl_easy_setopt_err_sockopt_cb();                       \
          if((_curl_opt) == CURLOPT_OPENSOCKETFUNCTION)                 \
            if(!curlcheck_opensocket_cb(value))                         \
              _curl_easy_setopt_err_opensocket_cb();                    \
          if((_curl_opt) == CURLOPT_PROGRESSFUNCTION)                   \
            if(!curlcheck_progress_cb(value))                           \
              _curl_easy_setopt_err_progress_cb();                      \
          if((_curl_opt) == CURLOPT_DEBUGFUNCTION)                      \
            if(!curlcheck_debug_cb(value))                              \
              _curl_easy_setopt_err_debug_cb();                         \
          if((_curl_opt) == CURLOPT_SSL_CTX_FUNCTION)                   \
            if(!curlcheck_ssl_ctx_cb(value))                            \
              _curl_easy_setopt_err_ssl_ctx_cb();                       \
          if(curlcheck_conv_cb_option(_curl_opt))                       \
            if(!curlcheck_conv_cb(value))                               \
              _curl_easy_setopt_err_conv_cb();                          \
          if((_curl_opt) == CURLOPT_SEEKFUNCTION)                       \
            if(!curlcheck_seek_cb(value))                               \
              _curl_easy_setopt_err_seek_cb();                          \
          if(curlcheck_cb_data_option(_curl_opt))                       \
            if(!curlcheck_cb_data(value))                               \
              _curl_easy_setopt_err_cb_data();                          \
          if((_curl_opt) == CURLOPT_ERRORBUFFER)                        \
            if(!curlcheck_error_buffer(value))                          \
              _curl_easy_setopt_err_error_buffer();                     \
          if((_curl_opt) == CURLOPT_STDERR)                             \
            if(!curlcheck_FILE(value))                                  \
              _curl_easy_setopt_err_FILE();                             \
          if(curlcheck_postfields_option(_curl_opt))                    \
            if(!curlcheck_postfields(value))                            \
              _curl_easy_setopt_err_postfields();                       \
          if((_curl_opt) == CURLOPT_HTTPPOST)                           \
            if(!curlcheck_arr((value), struct curl_httppost))           \
              _curl_easy_setopt_err_curl_httpost();                     \
          if((_curl_opt) == CURLOPT_MIMEPOST)                           \
            if(!curlcheck_ptr((value), curl_mime))                      \
              _curl_easy_setopt_err_curl_mimepost();                    \
          if(curlcheck_slist_option(_curl_opt))                         \
            if(!curlcheck_arr((value), struct curl_slist))              \
              _curl_easy_setopt_err_curl_slist();                       \
          if((_curl_opt) == CURLOPT_SHARE)                              \
            if(!curlcheck_ptr((value), CURLSH))                         \
              _curl_easy_setopt_err_CURLSH();                           \
        )                                                               \
      }                                                                 \
      curl_easy_setopt(handle, _curl_opt, value);                       \
    })
#define curl_easy_getinfo(handle, info, arg)                            \
  __extension__({                                                       \
      CURLINFO _curl_info = (info);                                     \
      if(__builtin_constant_p(_curl_info)) {                            \
        CURL_IGNORE_DEPRECATION(                                        \
          if(curlcheck_string_info(_curl_info))                         \
            if(!curlcheck_arr((arg), char *))                           \
              _curl_easy_getinfo_err_string();                          \
          if(curlcheck_long_info(_curl_info))                           \
            if(!curlcheck_arr((arg), long))                             \
              _curl_easy_getinfo_err_long();                            \
          if(curlcheck_double_info(_curl_info))                         \
            if(!curlcheck_arr((arg), double))                           \
              _curl_easy_getinfo_err_double();                          \
          if(curlcheck_slist_info(_curl_info))                          \
            if(!curlcheck_arr((arg), struct curl_slist *))              \
              _curl_easy_getinfo_err_curl_slist();                      \
          if(curlcheck_tlssessioninfo_info(_curl_info))                 \
            if(!curlcheck_arr((arg), struct curl_tlssessioninfo *))     \
              _curl_easy_getinfo_err_curl_tlssesssioninfo();            \
          if(curlcheck_certinfo_info(_curl_info))                       \
            if(!curlcheck_arr((arg), struct curl_certinfo *))           \
              _curl_easy_getinfo_err_curl_certinfo();                   \
          if(curlcheck_socket_info(_curl_info))                         \
            if(!curlcheck_arr((arg), curl_socket_t))                    \
              _curl_easy_getinfo_err_curl_socket();                     \
          if(curlcheck_off_t_info(_curl_info))                          \
            if(!curlcheck_arr((arg), curl_off_t))                       \
              _curl_easy_getinfo_err_curl_off_t();                      \
        )                                                               \
      }                                                                 \
      curl_easy_getinfo(handle, _curl_info, arg);                       \
    })
#define curl_share_setopt(share,opt,param) curl_share_setopt(share,opt,param)
#define curl_multi_setopt(handle,opt,param) curl_multi_setopt(handle,opt,param)
#define CURLWARNING(id, message)                                        \
  static void __attribute__((__warning__(message)))                     \
  __attribute__((__unused__)) __attribute__((__noinline__))             \
  id(void) { __asm__(""); }
CURLWARNING(_curl_easy_setopt_err_long,
  "curl_easy_setopt expects a long argument for this option")
CURLWARNING(_curl_easy_setopt_err_curl_off_t,
  "curl_easy_setopt expects a curl_off_t argument for this option")
CURLWARNING(_curl_easy_setopt_err_string,
              "curl_easy_setopt expects a "
              "string ('char *' or char[]) argument for this option"
  )
CURLWARNING(_curl_easy_setopt_err_write_callback,
  "curl_easy_setopt expects a curl_write_callback argument for this option")
CURLWARNING(_curl_easy_setopt_err_resolver_start_callback,
              "curl_easy_setopt expects a "
              "curl_resolver_start_callback argument for this option"
  )
CURLWARNING(_curl_easy_setopt_err_read_cb,
  "curl_easy_setopt expects a curl_read_callback argument for this option")
CURLWARNING(_curl_easy_setopt_err_ioctl_cb,
  "curl_easy_setopt expects a curl_ioctl_callback argument for this option")
CURLWARNING(_curl_easy_setopt_err_sockopt_cb,
  "curl_easy_setopt expects a curl_sockopt_callback argument for this option")
CURLWARNING(_curl_easy_setopt_err_opensocket_cb,
              "curl_easy_setopt expects a "
              "curl_opensocket_callback argument for this option"
  )
CURLWARNING(_curl_easy_setopt_err_progress_cb,
  "curl_easy_setopt expects a curl_progress_callback argument for this option")
CURLWARNING(_curl_easy_setopt_err_debug_cb,
  "curl_easy_setopt expects a curl_debug_callback argument for this option")
CURLWARNING(_curl_easy_setopt_err_ssl_ctx_cb,
  "curl_easy_setopt expects a curl_ssl_ctx_callback argument for this option")
CURLWARNING(_curl_easy_setopt_err_conv_cb,
  "curl_easy_setopt expects a curl_conv_callback argument for this option")
CURLWARNING(_curl_easy_setopt_err_seek_cb,
  "curl_easy_setopt expects a curl_seek_callback argument for this option")
CURLWARNING(_curl_easy_setopt_err_cb_data,
              "curl_easy_setopt expects a "
              "private data pointer as argument for this option")
CURLWARNING(_curl_easy_setopt_err_error_buffer,
              "curl_easy_setopt expects a "
              "char buffer of CURL_ERROR_SIZE as argument for this option")
CURLWARNING(_curl_easy_setopt_err_FILE,
  "curl_easy_setopt expects a 'FILE *' argument for this option")
CURLWARNING(_curl_easy_setopt_err_postfields,
  "curl_easy_setopt expects a 'void *' or 'char *' argument for this option")
CURLWARNING(_curl_easy_setopt_err_curl_httpost,
              "curl_easy_setopt expects a 'struct curl_httppost *' "
              "argument for this option")
CURLWARNING(_curl_easy_setopt_err_curl_mimepost,
              "curl_easy_setopt expects a 'curl_mime *' "
              "argument for this option")
CURLWARNING(_curl_easy_setopt_err_curl_slist,
  "curl_easy_setopt expects a 'struct curl_slist *' argument for this option")
CURLWARNING(_curl_easy_setopt_err_CURLSH,
  "curl_easy_setopt expects a CURLSH* argument for this option")
CURLWARNING(_curl_easy_getinfo_err_string,
  "curl_easy_getinfo expects a pointer to 'char *' for this info")
CURLWARNING(_curl_easy_getinfo_err_long,
  "curl_easy_getinfo expects a pointer to long for this info")
CURLWARNING(_curl_easy_getinfo_err_double,
  "curl_easy_getinfo expects a pointer to double for this info")
CURLWARNING(_curl_easy_getinfo_err_curl_slist,
  "curl_easy_getinfo expects a pointer to 'struct curl_slist *' for this info")
CURLWARNING(_curl_easy_getinfo_err_curl_tlssesssioninfo,
              "curl_easy_getinfo expects a pointer to "
              "'struct curl_tlssessioninfo *' for this info")
CURLWARNING(_curl_easy_getinfo_err_curl_certinfo,
              "curl_easy_getinfo expects a pointer to "
              "'struct curl_certinfo *' for this info")
CURLWARNING(_curl_easy_getinfo_err_curl_socket,
  "curl_easy_getinfo expects a pointer to curl_socket_t for this info")
CURLWARNING(_curl_easy_getinfo_err_curl_off_t,
  "curl_easy_getinfo expects a pointer to curl_off_t for this info")
#define curlcheck_long_option(option)                   \
  (0 < (option) && (option) < CURLOPTTYPE_OBJECTPOINT)
#define curlcheck_off_t_option(option)          \
  (((option) > CURLOPTTYPE_OFF_T) && ((option) < CURLOPTTYPE_BLOB))
#define curlcheck_string_option(option)                                       \
  ((option) == CURLOPT_ABSTRACT_UNIX_SOCKET ||                                \
   (option) == CURLOPT_ACCEPT_ENCODING ||                                     \
   (option) == CURLOPT_ALTSVC ||                                              \
   (option) == CURLOPT_CAINFO ||                                              \
   (option) == CURLOPT_CAPATH ||                                              \
   (option) == CURLOPT_COOKIE ||                                              \
   (option) == CURLOPT_COOKIEFILE ||                                          \
   (option) == CURLOPT_COOKIEJAR ||                                           \
   (option) == CURLOPT_COOKIELIST ||                                          \
   (option) == CURLOPT_CRLFILE ||                                             \
   (option) == CURLOPT_CUSTOMREQUEST ||                                       \
   (option) == CURLOPT_DEFAULT_PROTOCOL ||                                    \
   (option) == CURLOPT_DNS_INTERFACE ||                                       \
   (option) == CURLOPT_DNS_LOCAL_IP4 ||                                       \
   (option) == CURLOPT_DNS_LOCAL_IP6 ||                                       \
   (option) == CURLOPT_DNS_SERVERS ||                                         \
   (option) == CURLOPT_DOH_URL ||                                             \
   (option) == CURLOPT_ECH        ||                                          \
   (option) == CURLOPT_EGDSOCKET ||                                           \
   (option) == CURLOPT_FTP_ACCOUNT ||                                         \
   (option) == CURLOPT_FTP_ALTERNATIVE_TO_USER ||                             \
   (option) == CURLOPT_FTPPORT ||                                             \
   (option) == CURLOPT_HSTS ||                                                \
   (option) == CURLOPT_HAPROXY_CLIENT_IP ||                                   \
   (option) == CURLOPT_INTERFACE ||                                           \
   (option) == CURLOPT_ISSUERCERT ||                                          \
   (option) == CURLOPT_KEYPASSWD ||                                           \
   (option) == CURLOPT_KRBLEVEL ||                                            \
   (option) == CURLOPT_LOGIN_OPTIONS ||                                       \
   (option) == CURLOPT_MAIL_AUTH ||                                           \
   (option) == CURLOPT_MAIL_FROM ||                                           \
   (option) == CURLOPT_NETRC_FILE ||                                          \
   (option) == CURLOPT_NOPROXY ||                                             \
   (option) == CURLOPT_PASSWORD ||                                            \
   (option) == CURLOPT_PINNEDPUBLICKEY ||                                     \
   (option) == CURLOPT_PRE_PROXY ||                                           \
   (option) == CURLOPT_PROTOCOLS_STR ||                                       \
   (option) == CURLOPT_PROXY ||                                               \
   (option) == CURLOPT_PROXY_CAINFO ||                                        \
   (option) == CURLOPT_PROXY_CAPATH ||                                        \
   (option) == CURLOPT_PROXY_CRLFILE ||                                       \
   (option) == CURLOPT_PROXY_ISSUERCERT ||                                    \
   (option) == CURLOPT_PROXY_KEYPASSWD ||                                     \
   (option) == CURLOPT_PROXY_PINNEDPUBLICKEY ||                               \
   (option) == CURLOPT_PROXY_SERVICE_NAME ||                                  \
   (option) == CURLOPT_PROXY_SSL_CIPHER_LIST ||                               \
   (option) == CURLOPT_PROXY_SSLCERT ||                                       \
   (option) == CURLOPT_PROXY_SSLCERTTYPE ||                                   \
   (option) == CURLOPT_PROXY_SSLKEY ||                                        \
   (option) == CURLOPT_PROXY_SSLKEYTYPE ||                                    \
   (option) == CURLOPT_PROXY_TLS13_CIPHERS ||                                 \
   (option) == CURLOPT_PROXY_TLSAUTH_PASSWORD ||                              \
   (option) == CURLOPT_PROXY_TLSAUTH_TYPE ||                                  \
   (option) == CURLOPT_PROXY_TLSAUTH_USERNAME ||                              \
   (option) == CURLOPT_PROXYPASSWORD ||                                       \
   (option) == CURLOPT_PROXYUSERNAME ||                                       \
   (option) == CURLOPT_PROXYUSERPWD ||                                        \
   (option) == CURLOPT_RANDOM_FILE ||                                         \
   (option) == CURLOPT_RANGE ||                                               \
   (option) == CURLOPT_REDIR_PROTOCOLS_STR ||                                 \
   (option) == CURLOPT_REFERER ||                                             \
   (option) == CURLOPT_REQUEST_TARGET ||                                      \
   (option) == CURLOPT_RTSP_SESSION_ID ||                                     \
   (option) == CURLOPT_RTSP_STREAM_URI ||                                     \
   (option) == CURLOPT_RTSP_TRANSPORT ||                                      \
   (option) == CURLOPT_SASL_AUTHZID ||                                        \
   (option) == CURLOPT_SERVICE_NAME ||                                        \
   (option) == CURLOPT_SOCKS5_GSSAPI_SERVICE ||                               \
   (option) == CURLOPT_SSH_HOST_PUBLIC_KEY_MD5 ||                             \
   (option) == CURLOPT_SSH_HOST_PUBLIC_KEY_SHA256 ||                          \
   (option) == CURLOPT_SSH_KNOWNHOSTS ||                                      \
   (option) == CURLOPT_SSH_PRIVATE_KEYFILE ||                                 \
   (option) == CURLOPT_SSH_PUBLIC_KEYFILE ||                                  \
   (option) == CURLOPT_SSLCERT ||                                             \
   (option) == CURLOPT_SSLCERTTYPE ||                                         \
   (option) == CURLOPT_SSLENGINE ||                                           \
   (option) == CURLOPT_SSLKEY ||                                              \
   (option) == CURLOPT_SSLKEYTYPE ||                                          \
   (option) == CURLOPT_SSL_CIPHER_LIST ||                                     \
   (option) == CURLOPT_TLS13_CIPHERS ||                                       \
   (option) == CURLOPT_TLSAUTH_PASSWORD ||                                    \
   (option) == CURLOPT_TLSAUTH_TYPE ||                                        \
   (option) == CURLOPT_TLSAUTH_USERNAME ||                                    \
   (option) == CURLOPT_UNIX_SOCKET_PATH ||                                    \
   (option) == CURLOPT_URL ||                                                 \
   (option) == CURLOPT_USERAGENT ||                                           \
   (option) == CURLOPT_USERNAME ||                                            \
   (option) == CURLOPT_AWS_SIGV4 ||                                           \
   (option) == CURLOPT_USERPWD ||                                             \
   (option) == CURLOPT_XOAUTH2_BEARER ||                                      \
   (option) == CURLOPT_SSL_EC_CURVES ||                                       \
   0)
#define curlcheck_write_cb_option(option)                               \
  ((option) == CURLOPT_HEADERFUNCTION ||                                \
   (option) == CURLOPT_WRITEFUNCTION)
#define curlcheck_conv_cb_option(option)                                \
  ((option) == CURLOPT_CONV_TO_NETWORK_FUNCTION ||                      \
   (option) == CURLOPT_CONV_FROM_NETWORK_FUNCTION ||                    \
   (option) == CURLOPT_CONV_FROM_UTF8_FUNCTION)
#define curlcheck_cb_data_option(option)                                      \
  ((option) == CURLOPT_CHUNK_DATA ||                                          \
   (option) == CURLOPT_CLOSESOCKETDATA ||                                     \
   (option) == CURLOPT_DEBUGDATA ||                                           \
   (option) == CURLOPT_FNMATCH_DATA ||                                        \
   (option) == CURLOPT_HEADERDATA ||                                          \
   (option) == CURLOPT_HSTSREADDATA ||                                        \
   (option) == CURLOPT_HSTSWRITEDATA ||                                       \
   (option) == CURLOPT_INTERLEAVEDATA ||                                      \
   (option) == CURLOPT_IOCTLDATA ||                                           \
   (option) == CURLOPT_OPENSOCKETDATA ||                                      \
   (option) == CURLOPT_PREREQDATA ||                                          \
   (option) == CURLOPT_PROGRESSDATA ||                                        \
   (option) == CURLOPT_READDATA ||                                            \
   (option) == CURLOPT_SEEKDATA ||                                            \
   (option) == CURLOPT_SOCKOPTDATA ||                                         \
   (option) == CURLOPT_SSH_KEYDATA ||                                         \
   (option) == CURLOPT_SSL_CTX_DATA ||                                        \
   (option) == CURLOPT_WRITEDATA ||                                           \
   (option) == CURLOPT_RESOLVER_START_DATA ||                                 \
   (option) == CURLOPT_TRAILERDATA ||                                         \
   (option) == CURLOPT_SSH_HOSTKEYDATA ||                                     \
   0)
#define curlcheck_postfields_option(option)                                   \
  ((option) == CURLOPT_POSTFIELDS ||                                          \
   (option) == CURLOPT_COPYPOSTFIELDS ||                                      \
   0)
#define curlcheck_slist_option(option)                                        \
  ((option) == CURLOPT_HTTP200ALIASES ||                                      \
   (option) == CURLOPT_HTTPHEADER ||                                          \
   (option) == CURLOPT_MAIL_RCPT ||                                           \
   (option) == CURLOPT_POSTQUOTE ||                                           \
   (option) == CURLOPT_PREQUOTE ||                                            \
   (option) == CURLOPT_PROXYHEADER ||                                         \
   (option) == CURLOPT_QUOTE ||                                               \
   (option) == CURLOPT_RESOLVE ||                                             \
   (option) == CURLOPT_TELNETOPTIONS ||                                       \
   (option) == CURLOPT_CONNECT_TO ||                                          \
   0)
#define curlcheck_string_info(info)                             \
  (CURLINFO_STRING < (info) && (info) < CURLINFO_LONG &&        \
   (info) != CURLINFO_PRIVATE)
#define curlcheck_long_info(info)                       \
  (CURLINFO_LONG < (info) && (info) < CURLINFO_DOUBLE)
#define curlcheck_double_info(info)                     \
  (CURLINFO_DOUBLE < (info) && (info) < CURLINFO_SLIST)
#define curlcheck_slist_info(info)                                      \
  (((info) == CURLINFO_SSL_ENGINES) || ((info) == CURLINFO_COOKIELIST))
#define curlcheck_tlssessioninfo_info(info)                              \
  (((info) == CURLINFO_TLS_SSL_PTR) || ((info) == CURLINFO_TLS_SESSION))
#define curlcheck_certinfo_info(info) ((info) == CURLINFO_CERTINFO)
#define curlcheck_socket_info(info)                     \
  (CURLINFO_SOCKET < (info) && (info) < CURLINFO_OFF_T)
#define curlcheck_off_t_info(info)              \
  (CURLINFO_OFF_T < (info))
#define curlcheck_any_ptr(expr)                 \
  (sizeof(expr) == sizeof(void *))
#define curlcheck_NULL(expr)                                            \
  (__builtin_types_compatible_p(__typeof__(expr), __typeof__(NULL)))
#define curlcheck_ptr(expr, type)                                       \
  (curlcheck_NULL(expr) ||                                              \
   __builtin_types_compatible_p(__typeof__(expr), type *) ||            \
   __builtin_types_compatible_p(__typeof__(expr), const type *))
#define curlcheck_arr(expr, type)                                       \
  (curlcheck_ptr((expr), type) ||                                       \
   __builtin_types_compatible_p(__typeof__(expr), type []))
#define curlcheck_string(expr)                                          \
  (curlcheck_arr((expr), char) ||                                       \
   curlcheck_arr((expr), signed char) ||                                \
   curlcheck_arr((expr), unsigned char))
#define curlcheck_long(expr)                                                  \
  (__builtin_types_compatible_p(__typeof__(expr), long) ||                    \
   __builtin_types_compatible_p(__typeof__(expr), signed long) ||             \
   __builtin_types_compatible_p(__typeof__(expr), unsigned long) ||           \
   __builtin_types_compatible_p(__typeof__(expr), int) ||                     \
   __builtin_types_compatible_p(__typeof__(expr), signed int) ||              \
   __builtin_types_compatible_p(__typeof__(expr), unsigned int) ||            \
   __builtin_types_compatible_p(__typeof__(expr), short) ||                   \
   __builtin_types_compatible_p(__typeof__(expr), signed short) ||            \
   __builtin_types_compatible_p(__typeof__(expr), unsigned short) ||          \
   __builtin_types_compatible_p(__typeof__(expr), char) ||                    \
   __builtin_types_compatible_p(__typeof__(expr), signed char) ||             \
   __builtin_types_compatible_p(__typeof__(expr), unsigned char))
#define curlcheck_off_t(expr)                                   \
  (__builtin_types_compatible_p(__typeof__(expr), curl_off_t))
#define curlcheck_error_buffer(expr)                                    \
  (curlcheck_NULL(expr) ||                                              \
   __builtin_types_compatible_p(__typeof__(expr), char *) ||            \
   __builtin_types_compatible_p(__typeof__(expr), char[]))
#if 0
#define curlcheck_cb_data(expr)                                         \
  (curlcheck_ptr((expr), void) ||                                       \
   curlcheck_ptr((expr), FILE))
#else 
#define curlcheck_cb_data(expr)                 \
  curlcheck_any_ptr(expr)
#endif
#define curlcheck_FILE(expr)                                            \
  (curlcheck_NULL(expr) ||                                              \
   (__builtin_types_compatible_p(__typeof__(expr), FILE *)))
#define curlcheck_postfields(expr)                                      \
  (curlcheck_ptr((expr), void) ||                                       \
   curlcheck_arr((expr), char) ||                                       \
   curlcheck_arr((expr), unsigned char))
#define curlcheck_cb_compatible(func, type)                             \
  (__builtin_types_compatible_p(__typeof__(func), type) ||              \
   __builtin_types_compatible_p(__typeof__(func) *, type))
#define curlcheck_resolver_start_callback(expr)       \
  (curlcheck_NULL(expr) || \
   curlcheck_cb_compatible((expr), curl_resolver_start_callback))
#define curlcheck_read_cb(expr)                                         \
  (curlcheck_NULL(expr) ||                                              \
   curlcheck_cb_compatible((expr), __typeof__(fread) *) ||              \
   curlcheck_cb_compatible((expr), curl_read_callback) ||               \
   curlcheck_cb_compatible((expr), _curl_read_callback1) ||             \
   curlcheck_cb_compatible((expr), _curl_read_callback2) ||             \
   curlcheck_cb_compatible((expr), _curl_read_callback3) ||             \
   curlcheck_cb_compatible((expr), _curl_read_callback4) ||             \
   curlcheck_cb_compatible((expr), _curl_read_callback5) ||             \
   curlcheck_cb_compatible((expr), _curl_read_callback6))
typedef size_t (*_curl_read_callback1)(char *, size_t, size_t, void *);
typedef size_t (*_curl_read_callback2)(char *, size_t, size_t, const void *);
typedef size_t (*_curl_read_callback3)(char *, size_t, size_t, FILE *);
typedef size_t (*_curl_read_callback4)(void *, size_t, size_t, void *);
typedef size_t (*_curl_read_callback5)(void *, size_t, size_t, const void *);
typedef size_t (*_curl_read_callback6)(void *, size_t, size_t, FILE *);
#define curlcheck_write_cb(expr)                                        \
  (curlcheck_read_cb(expr) ||                                           \
   curlcheck_cb_compatible((expr), __typeof__(fwrite) *) ||             \
   curlcheck_cb_compatible((expr), curl_write_callback) ||              \
   curlcheck_cb_compatible((expr), _curl_write_callback1) ||            \
   curlcheck_cb_compatible((expr), _curl_write_callback2) ||            \
   curlcheck_cb_compatible((expr), _curl_write_callback3) ||            \
   curlcheck_cb_compatible((expr), _curl_write_callback4) ||            \
   curlcheck_cb_compatible((expr), _curl_write_callback5) ||            \
   curlcheck_cb_compatible((expr), _curl_write_callback6))
typedef size_t (*_curl_write_callback1)(const char *, size_t, size_t, void *);
typedef size_t (*_curl_write_callback2)(const char *, size_t, size_t,
                                       const void *);
typedef size_t (*_curl_write_callback3)(const char *, size_t, size_t, FILE *);
typedef size_t (*_curl_write_callback4)(const void *, size_t, size_t, void *);
typedef size_t (*_curl_write_callback5)(const void *, size_t, size_t,
                                       const void *);
typedef size_t (*_curl_write_callback6)(const void *, size_t, size_t, FILE *);
#define curlcheck_ioctl_cb(expr)                                        \
  (curlcheck_NULL(expr) ||                                              \
   curlcheck_cb_compatible((expr), curl_ioctl_callback) ||              \
   curlcheck_cb_compatible((expr), _curl_ioctl_callback1) ||            \
   curlcheck_cb_compatible((expr), _curl_ioctl_callback2) ||            \
   curlcheck_cb_compatible((expr), _curl_ioctl_callback3) ||            \
   curlcheck_cb_compatible((expr), _curl_ioctl_callback4))
typedef curlioerr (*_curl_ioctl_callback1)(CURL *, int, void *);
typedef curlioerr (*_curl_ioctl_callback2)(CURL *, int, const void *);
typedef curlioerr (*_curl_ioctl_callback3)(CURL *, curliocmd, void *);
typedef curlioerr (*_curl_ioctl_callback4)(CURL *, curliocmd, const void *);
#define curlcheck_sockopt_cb(expr)                                      \
  (curlcheck_NULL(expr) ||                                              \
   curlcheck_cb_compatible((expr), curl_sockopt_callback) ||            \
   curlcheck_cb_compatible((expr), _curl_sockopt_callback1) ||          \
   curlcheck_cb_compatible((expr), _curl_sockopt_callback2))
typedef int (*_curl_sockopt_callback1)(void *, curl_socket_t, curlsocktype);
typedef int (*_curl_sockopt_callback2)(const void *, curl_socket_t,
                                      curlsocktype);
#define curlcheck_opensocket_cb(expr)                                   \
  (curlcheck_NULL(expr) ||                                              \
   curlcheck_cb_compatible((expr), curl_opensocket_callback) ||         \
   curlcheck_cb_compatible((expr), _curl_opensocket_callback1) ||       \
   curlcheck_cb_compatible((expr), _curl_opensocket_callback2) ||       \
   curlcheck_cb_compatible((expr), _curl_opensocket_callback3) ||       \
   curlcheck_cb_compatible((expr), _curl_opensocket_callback4))
typedef curl_socket_t (*_curl_opensocket_callback1)
  (void *, curlsocktype, struct curl_sockaddr *);
typedef curl_socket_t (*_curl_opensocket_callback2)
  (void *, curlsocktype, const struct curl_sockaddr *);
typedef curl_socket_t (*_curl_opensocket_callback3)
  (const void *, curlsocktype, struct curl_sockaddr *);
typedef curl_socket_t (*_curl_opensocket_callback4)
  (const void *, curlsocktype, const struct curl_sockaddr *);
#define curlcheck_progress_cb(expr)                                     \
  (curlcheck_NULL(expr) ||                                              \
   curlcheck_cb_compatible((expr), curl_progress_callback) ||           \
   curlcheck_cb_compatible((expr), _curl_progress_callback1) ||         \
   curlcheck_cb_compatible((expr), _curl_progress_callback2))
typedef int (*_curl_progress_callback1)(void *,
    double, double, double, double);
typedef int (*_curl_progress_callback2)(const void *,
    double, double, double, double);
#define curlcheck_debug_cb(expr)                                        \
  (curlcheck_NULL(expr) ||                                              \
   curlcheck_cb_compatible((expr), curl_debug_callback) ||              \
   curlcheck_cb_compatible((expr), _curl_debug_callback1) ||            \
   curlcheck_cb_compatible((expr), _curl_debug_callback2) ||            \
   curlcheck_cb_compatible((expr), _curl_debug_callback3) ||            \
   curlcheck_cb_compatible((expr), _curl_debug_callback4) ||            \
   curlcheck_cb_compatible((expr), _curl_debug_callback5) ||            \
   curlcheck_cb_compatible((expr), _curl_debug_callback6) ||            \
   curlcheck_cb_compatible((expr), _curl_debug_callback7) ||            \
   curlcheck_cb_compatible((expr), _curl_debug_callback8))
typedef int (*_curl_debug_callback1) (CURL *,
    curl_infotype, char *, size_t, void *);
typedef int (*_curl_debug_callback2) (CURL *,
    curl_infotype, char *, size_t, const void *);
typedef int (*_curl_debug_callback3) (CURL *,
    curl_infotype, const char *, size_t, void *);
typedef int (*_curl_debug_callback4) (CURL *,
    curl_infotype, const char *, size_t, const void *);
typedef int (*_curl_debug_callback5) (CURL *,
    curl_infotype, unsigned char *, size_t, void *);
typedef int (*_curl_debug_callback6) (CURL *,
    curl_infotype, unsigned char *, size_t, const void *);
typedef int (*_curl_debug_callback7) (CURL *,
    curl_infotype, const unsigned char *, size_t, void *);
typedef int (*_curl_debug_callback8) (CURL *,
    curl_infotype, const unsigned char *, size_t, const void *);
#define curlcheck_ssl_ctx_cb(expr)                                      \
  (curlcheck_NULL(expr) ||                                              \
   curlcheck_cb_compatible((expr), curl_ssl_ctx_callback) ||            \
   curlcheck_cb_compatible((expr), _curl_ssl_ctx_callback1) ||          \
   curlcheck_cb_compatible((expr), _curl_ssl_ctx_callback2) ||          \
   curlcheck_cb_compatible((expr), _curl_ssl_ctx_callback3) ||          \
   curlcheck_cb_compatible((expr), _curl_ssl_ctx_callback4) ||          \
   curlcheck_cb_compatible((expr), _curl_ssl_ctx_callback5) ||          \
   curlcheck_cb_compatible((expr), _curl_ssl_ctx_callback6) ||          \
   curlcheck_cb_compatible((expr), _curl_ssl_ctx_callback7) ||          \
   curlcheck_cb_compatible((expr), _curl_ssl_ctx_callback8))
typedef CURLcode (*_curl_ssl_ctx_callback1)(CURL *, void *, void *);
typedef CURLcode (*_curl_ssl_ctx_callback2)(CURL *, void *, const void *);
typedef CURLcode (*_curl_ssl_ctx_callback3)(CURL *, const void *, void *);
typedef CURLcode (*_curl_ssl_ctx_callback4)(CURL *, const void *,
                                            const void *);
#ifdef HEADER_SSL_H
typedef CURLcode (*_curl_ssl_ctx_callback5)(CURL *, SSL_CTX *, void *);
typedef CURLcode (*_curl_ssl_ctx_callback6)(CURL *, SSL_CTX *, const void *);
typedef CURLcode (*_curl_ssl_ctx_callback7)(CURL *, const SSL_CTX *, void *);
typedef CURLcode (*_curl_ssl_ctx_callback8)(CURL *, const SSL_CTX *,
                                            const void *);
#else
typedef _curl_ssl_ctx_callback1 _curl_ssl_ctx_callback5;
typedef _curl_ssl_ctx_callback1 _curl_ssl_ctx_callback6;
typedef _curl_ssl_ctx_callback1 _curl_ssl_ctx_callback7;
typedef _curl_ssl_ctx_callback1 _curl_ssl_ctx_callback8;
#endif
#define curlcheck_conv_cb(expr)                                         \
  (curlcheck_NULL(expr) ||                                              \
   curlcheck_cb_compatible((expr), curl_conv_callback) ||               \
   curlcheck_cb_compatible((expr), _curl_conv_callback1) ||             \
   curlcheck_cb_compatible((expr), _curl_conv_callback2) ||             \
   curlcheck_cb_compatible((expr), _curl_conv_callback3) ||             \
   curlcheck_cb_compatible((expr), _curl_conv_callback4))
typedef CURLcode (*_curl_conv_callback1)(char *, size_t length);
typedef CURLcode (*_curl_conv_callback2)(const char *, size_t length);
typedef CURLcode (*_curl_conv_callback3)(void *, size_t length);
typedef CURLcode (*_curl_conv_callback4)(const void *, size_t length);
#define curlcheck_seek_cb(expr)                                         \
  (curlcheck_NULL(expr) ||                                              \
   curlcheck_cb_compatible((expr), curl_seek_callback) ||               \
   curlcheck_cb_compatible((expr), _curl_seek_callback1) ||             \
   curlcheck_cb_compatible((expr), _curl_seek_callback2))
typedef CURLcode (*_curl_seek_callback1)(void *, curl_off_t, int);
typedef CURLcode (*_curl_seek_callback2)(const void *, curl_off_t, int);
#endif 
#else
#if defined(__STDC__) && (__STDC__ >= 1)
#define curl_easy_setopt(handle,opt,param) curl_easy_setopt(handle,opt,param)
#define curl_easy_getinfo(handle,info,arg) curl_easy_getinfo(handle,info,arg)
#define curl_share_setopt(share,opt,param) curl_share_setopt(share,opt,param)
#define curl_multi_setopt(handle,opt,param) curl_multi_setopt(handle,opt,param)
#endif 
#endif 
#endif 


/// LICENSE_END.24
#endif ///NOSFTPEND

//ugo

std::string	g_franzen;
int64_t 	g_dt_ram;
int64_t 	g_debug_sequence		=0;
bool 		g_write_on_first		=false;
int64_t 	g_write_on_seek			=0;

int64_t 	g_allocatedram			=0;
int64_t 	g_arrayram				=0;

bool		g_control_c				=false;
int 		g_incomplete_version	=0;
    
int64_t		g_starting_zpaqdate		=0;
int64_t 	g_starting_zpaqsize		=0;
int64_t 	g_starting_indexsize	=0;
int64_t 	g_starting_zpaqattr		=0;	

std::string g_thememfileblock	="";
std::string g_thememfileblock_h	="";

int64_t 	g_thememfilestart		=0;
int64_t 	g_thememfilestart_h		=0;
int64_t 	g_thememfilelength		=0;

int 		g_thememfilefragstart	=0;
int 		g_thememfilefragend		=0;

FILE* 		g_output_handle;
FILE* 		g_error_handle;
bool 		flagignore;
bool 		flagappendoutput;
bool 		flagwriteonconsole;
bool 		flagnotrim;
bool 		flagonedrive;
bool 		flaghw;	// this slow down vs HWSHA1
bool 		flagdebug;
bool 		flagdebug2;
bool 		flagdebug3;
bool 		flagdebug4;
bool 		flagdebug5;
bool 		flagdebug6;
std::string	g_processorname="";
bool 		flagnojit;

char* 		g_password;     				// points to password_string or NULL
char 		g_password_string[32]; 			// hash of -key argument
	
bool		g_flagcreating;
char 		command;
std::string g_mysql_host;
std::string g_mysql_user;
std::string g_mysql_password;
int			g_mysql_port;

#ifdef ZPAQFULL ///NOSFTPSTART
#ifdef SFTP
std::string g_sftp_host;
std::string g_sftp_user;
std::string g_sftp_remote;
std::string g_sftp_mailfull;
std::string g_sftp_mailprivacy;
std::string g_sftp_maila;
std::string g_sftp_customer;

std::string g_sftp_password;
std::string g_sftp_key;
int			g_sftp_port;
#endif // corresponds to #ifdef (#ifdef SFTP)
#endif ///NOSFTPEND

int			g_sftp_bandwidth;
int 		g_device_fd;
int64_t 	g_device_size;

std::string	g_franzsnap;
std::string g_vss_shadow;
std::string	g_replaceme;
std::string g_copy;
std::string g_freeze;
std::string g_exec_error;
std::string	g_exec_warn;
std::string g_exec_ok;
std::string g_exec_text;
std::string g_exec;
int 		g_255;
std::string g_output;
std::string g_keyfile;
std::string g_keyfilehash;
std::string g_error;
std::string g_ifexist;
std::string g_script;
#ifdef ZPAQFULL ///NOSFTPSTART
std::string g_sfx;
std::string g_sfxto;
std::string g_sfxnot;
std::string g_sfxonly;
std::string g_sfxuntil;
#endif ///NOSFTPEND
std::string g_deleteinto;
#ifdef ZPAQFULL ///NOSFTPSTART
bool 		g_sfxflagall;
bool  		g_sfxflagforce;
#endif ///NOSFTPEND
bool		g_sse42;
bool		g_flagmultipart;
std::string g_archive;
std::string	g_indexname;
std::string	g_externalname;
std::string	g_input;
std::string	g_destination;
std::string	g_csvstring;
std::string	g_csvhf;
std::string	g_bin;
std::string	g_pidname;
bool		flagnopid;
FILE* 		g_pid_handle=0;
std::string	g_backupposition;
int64_t 	g_robocopy_check_sorgente;
int64_t 	g_robocopy_check_destinazione;
int64_t 	g_robocopy_makepath;
int64_t 	g_robocopy_makepath2;
int64_t 	g_robocopy_isequal;
int64_t 	g_robocopy_close;
int64_t 	g_robocopy_close2;
int64_t 	g_robocopy_touch;
int64_t 	g_robocopy_delete;
int64_t		g_robocopy_readopen;
int64_t		g_robocopy_openoutfile;
int64_t 	g_robocopy_fclose;
int64_t 	g_robocopy_fread;
int64_t 	g_robocopy_fwrite;

bool		g_testifselected;
uint64_t 	g_chunk_size	=0;
int64_t 	g_start			=0;
int64_t 	g_dimensione	=0;
int64_t 	g_scritti		=0;
int64_t 	g_maxposition	=0;
int64_t 	g_zerotime		=0;
int64_t 	g_bytescanned	=0;
int64_t 	g_filescanned	=0;
int64_t 	g_worked		=0;
int64_t 	g_fwritten		=0;
int64_t 	g_fexpected		=0;
int64_t 	g_fwrittencrc32	=0;

int64_t 	g_header_pos	=0;
bool		g_crc_getheader	=false; ///0 =  header; 1= 4; 2=body
bool		g_veryfirst		=true;
uint32_t 	g_crc_header	=0;
uint32_t 	g_crc_jidac		=0;
uint32_t 	g_crc_body		=0;

int64_t 	g_ramdisksize	=0;
int64_t 	g_rd			=0;
int64_t 	g_rd_expected	=0;
int64_t 	g_startrd		=0;
int64_t 	g_startdownload	=0;
int 		g_rd_ultimotempo=0;
int64_t 	g_cdatasize		=0;
unsigned 	g_htsize		=0;
bool		g_fakewrite		=false;	// in add() disable write (ransomware)
uint64_t 	minsize;
uint64_t 	maxsize;
uint64_t	g_remotespeed	=0;
bool		flaghuge		=false;
#ifdef _WIN32
bool		flagsparse		=false;
#endif
uint64_t	g_ramsize;
bool		flagramsize		=false;
uint64_t	g_checksize		=0;
int64_t 	g_touch			=0;
int64_t		g_datefrom		=0;
int64_t 	g_dateto		=0;
std::string	g_until;
int			g_rangefrom		=0;
int			g_rangeto		=0;
int			g_rangelast		=0;

#ifdef unix
std::string g_tempsnapshot;
std::string g_basesnapshot;
std::string g_dataset;
#endif // corresponds to #ifdef (#ifdef unix)
bool		flagsha1deep;
bool		flagmd5deep;
bool		flagsha256deep;
bool		flagrange;
bool		flagnosymlink;
bool		flagnochecksum;
bool		flagcrc32;
bool		flagxxhash64;
bool		flagxxhash64b;
bool		flagsha1;
bool		flagsha256;
bool		flagsha256b;
bool		flagxxh3;
bool		flagmd5;
bool		flagmd5b;
bool		flagsha1b;
bool		flagxxh3b;
bool		flagblake3;
bool		flagblake3b;
bool		flagsha3;
bool		flagsha3b;
bool		flagwhirlpool;
bool		flaghighway64;
bool		flaghighway128;
bool		flaghighway256;
bool		flagcrc32c;
bool		flagwyhash;
bool		flagnilsimsa;
bool		flagentropy;
bool		flagwindate;
bool		flagtmp;
bool		flagbackupxxh3;
bool		flagbackupzeta;
bool		flag715;
bool		flagappend;
bool		flagbig;
bool		flagchecksum;
bool		flagchecktxt;
#ifdef ZPAQFULL ///NOSFTPSTART
bool		flagsfx;
#endif ///NOSFTPEND
bool		flagfasttxt;
bool		flagcomment;
bool		flagdesc;
bool		flagdonotforcexls;
bool		flagfilelist;
bool		flagexternal;
bool		flaginput;
bool		flagdestination;
bool		flagads;
bool		flagfast;
bool		flagfix255;
bool		flagfixeml;
bool		flagflat;
bool		flagforce;
bool		flagforcewindows;
bool		flagforcezfs;
bool		flagfrugal;
bool		flagfranzhash;
bool		flaghashdeep;
bool		flagkill;
bool		flaght;
bool		flagnocaptcha;
bool		flagmm;
bool		flagattr;
bool		flagthunderbird;
bool		flagnoattributes;
bool		flagnodir;
bool		flagnodedup;
bool		flagnoeta;
bool		flagnopath;
bool		flagnoqnap;
bool		flagnomac;
bool		flagnosynology;
bool		flagnorecursion;
bool		flagnosort;
bool		flaglast;
bool		flagpakka;
bool		flagdistinct;
bool		flagparanoid;
bool		flagpaq;
bool		flagcollision;
bool		flagramdisk;
bool		flagrename;
bool		flagsilent;
bool		flagslow;
bool		flagshutdown;
#ifdef _WIN32
bool 		flagmonitoroff;
#endif
bool		flagnoconsole;
bool		flagnocolor;
bool		flagnodelete;
bool		flagskipzfs;
bool		flagspace;
bool		flagssd;
bool		flagonlyupload;
bool		flagnomore;
bool		flagsalt;
bool		flaghdd;
bool		flagquick;
bool		flagzeta;
bool		flagzetaenc;
bool		flagquiet;
bool		flagstat;
bool		flagstdin;
bool		flagterse;
bool		flagnodel;
bool		flagcsv;
bool		flagstdout;
bool		flagstore;
bool		flagtar;
bool		flagtest;
bool		flagtouch;
bool		flagutc;
bool		flagdate;
bool		flagutf;
bool		flagpause;
bool		flagverbose;
bool		flagverify;
bool		flagvss;
bool		flagzero;
bool		flaghome;
bool		flagfixcase;

bool 		flagimage;
#ifdef _WIN32
bool		flagfindzpaq;
bool		flagfixreserved;
bool		flagntfs;
bool		flaglongpath;
bool		flagopen;
int			g_ConsoleCP;
int 		g_ConsoleOutputCP;
#endif // corresponds to #ifdef (#ifdef _WIN32)

bool		flagbarraod;
bool		flagbarraon;
bool		flagbarraos;
std::vector<std::string>	g_addedchunklist;
int 		g_franzotype;
int			g_franzotypelen;
std::string g_optional;
std::string orderby;
std::vector<std::string> g_theorderby;
int 		g_ioBUFSIZE=1048576;
int			g_thechosenhash;
std::string	g_thechosenhash_str;


typedef std::string (*voidhelpfunction)(bool i_usage,bool i_example);
struct HelpInfo 
{
    std::string 		category;
    voidhelpfunction 	function;
    int					sortposition;
    HelpInfo(const std::string& cat, voidhelpfunction func,int i_pos) 
        : category(cat), function(func), sortposition(i_pos) {}
};

typedef std::map<std::string, HelpInfo> MAPPAHELP;
///typedef std::map<std::string, voidhelpfunction> MAPPAHELP;
typedef std::map<int, 	std::string> 			MAPPACOMMENTI;
typedef std::map<std::string, std::string> 		MAPPAFILEHASH;
typedef std::map<std::string, std::string> 		MAPPASTRINGASTRINGA;
typedef std::map<int64_t,std::string> 			MAPPAINT64STRING;
typedef std::map<std::string,int> 				MAPPASTRINGINTEGER;
typedef std::map	<int,int> 					MAPPAINTINT;
struct	hash_check
{
	int		algotype;
	int		checkedok;
	int		checkedfailed;
	int		checkednotfound;
	int64_t checksize;
	hash_check(): algotype(0), checkedok(0),checkedfailed(0),checkednotfound(0),checksize(0) {};
};
typedef std::map<std::string, hash_check> MAPPACHECK;
struct	hash_autocheck
{
	std::string	ok;
	std::string	calculated;
	std::string ok5;
	///hash_autocheck() {ok="";calculated="";};
};
typedef std::map<std::string, hash_autocheck> MAPPAAUTOCHECK;
struct s_crc32block 
{
    uint64_t crc32start;
    uint64_t crc32size;
    uint32_t crc32;
    std::string filename;
    s_crc32block() : crc32start(0), crc32size(0), crc32(0) {}
	 s_crc32block(uint32_t c, uint64_t start, uint64_t size)
        : crc32start(start), crc32size(size), crc32(c)  {}
};
/*
struct s_crc32block
{
	std::string	filename;
	uint64_t 	crc32start;
	uint64_t 	crc32size;
	uint32_t 	crc32;
	s_crc32block(): crc32start(0),crc32size(0),crc32(0) {}
};
*/
struct s_error
{
	int					counter;
	std::string			text;
	std::vector<std::string>	filenames;
	std::vector<int32_t>		attrs;
	s_error(): counter(0) {}
};

typedef std::map<int,s_error> MAPPAERRORS;

/// not in  for pthread that does not like class and methods
pthread_mutex_t g_mylock = PTHREAD_MUTEX_INITIALIZER;
std::vector<s_crc32block> 	g_crc32;
std::vector<uint64_t> 		g_arraybytescanned;
std::vector<uint64_t> 		g_arrayfilescanned;
MAPPAERRORS 			g_errors;


#ifdef _WIN32
#define MYFOREGROUND_BLUE		0x0001
#define MYFOREGROUND_GREEN		0x0002
#define MYFOREGROUND_RED		0x0004
#define MYFOREGROUND_INTENSITY	0x0008

#else
/// *nix colors
#define TEXT_RESET				"\x1b[0m"


#define TEXT_RED_BRIGHT     	"\x1b[1;31m"
#define TEXT_GREEN_BRIGHT   	"\x1b[1;32m"
#define TEXT_YELLOW_BRIGHT  	"\x1b[1;33m"
#define TEXT_CYAN_BRIGHT		"\x1b[1;36m"


#endif // corresponds to #ifdef (#ifdef _WIN32)

int g_console_attributes=-1;
/*
bool iswindowsxp()
{
#ifdef _WIN32
    OSVERSIONINFO osvi;
    ZeroMemory(&osvi, sizeof(OSVERSIONINFO));  // Pulisce la struttura
    osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    
    if (GetVersionEx(&osvi))  // Controlla il successo
    {
        return (osvi.dwMajorVersion == 5) && (osvi.dwMinorVersion == 1);
    }
    return false;  // Fallback se GetVersionEx fallisce
#else
    return false;
#endif
}
*/
bool iswindowsxp()
{
#ifdef _WIN32
    // Metodo veloce: se GetTickCount64 non esiste, è XP/2003
    HMODULE hKernel = GetModuleHandleW(L"kernel32.dll");
    return (hKernel && GetProcAddress(hKernel, "GetTickCount64") == NULL);
#else
    return false;
#endif
}

/*
bool iswindowsxp()
{
#ifdef _WIN32
    OSVERSIONINFO osvi;
    osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    GetVersionEx(&osvi);
    return (osvi.dwMajorVersion == 5)  && (osvi.dwMinorVersion == 1);
#endif // corresponds to #ifdef (#ifdef _WIN32)
	return false;
}
*/

#ifdef _WIN32


// Function to decode a hexadecimal string
std::string decodehex(const std::string& hexInput) 
{
    if (hexInput.length() % 2 != 0) 
        return ""; // Hex string must have an even length
    
    std::string result;
    result.reserve(hexInput.length() / 2);
    
    for (size_t i = 0; i < hexInput.length(); i += 2) 
	{
        char high = hexInput[i];
        char low = hexInput[i + 1];
        
        // Convert hex character to numeric value
        auto hexToInt = [](char c) -> int {
            if (c >= '0' && c <= '9') return c - '0';
            if (c >= 'A' && c <= 'F') return c - 'A' + 10;
            if (c >= 'a' && c <= 'f') return c - 'a' + 10;
            return -1; // Invalid character
        };
        
        int highVal = hexToInt(high);
        int lowVal = hexToInt(low);
        
        if (highVal == -1 || lowVal == -1) 
		    return ""; // Invalid hex character
        
        result += static_cast<char>((highVal << 4) | lowVal);
    }
    
    return result;
}

std::string windowspowerme()
{
	// Fix Kaspersky false positive on power*hell. Sigh
	std::string runme;
#ifdef _WIN32
///    string runme = "c:\\Windows\\system32\\WindowsPowerShell\\v1.0\\powershell.exe";
	runme="633A5C57696E646F77735C73797374656D33325C57696E646F7773506F7765725368656C6C5C76312E305C706F7765727368656C6C2E657865";
#ifdef _WIN64
///    runme = "c:\\Windows\\SysWOW64\\WindowsPowerShell\\v1.0\\powershell.exe";
	runme="633A5C57696E646F77735C537973574F5736345C57696E646F7773506F7765725368656C6C5C76312E305C706F7765727368656C6C2E657865";
#endif
	if (flagdebug)
		printf("88883: encoded runme |%s|\n",runme.c_str());
	
	runme=decodehex(runme);
	if (flagdebug)
		printf("88883: decoded runme |%s|\n",runme.c_str());
	return runme;
}

#endif






void color_save()
{
	if (flagnocolor)
		return;
	HANDLE hconsole=GetStdHandle(STD_OUTPUT_HANDLE);
	if (hconsole==INVALID_HANDLE_VALUE)
		return;
	CONSOLE_SCREEN_BUFFER_INFO csbiInfo;
	GetConsoleScreenBufferInfo(hconsole,&csbiInfo);
	if ((csbiInfo.wAttributes & MYFOREGROUND_BLUE) &&
	 (csbiInfo.wAttributes & MYFOREGROUND_GREEN) &&
	 (csbiInfo.wAttributes & MYFOREGROUND_RED))
		g_console_attributes=csbiInfo.wAttributes;
}
#endif // corresponds to #ifdef (#ifdef _WIN32)
void resetconsolecolor() 
{
#ifdef _WIN32
    // Windows: Ripristina il colore predefinito della console
    HANDLE hConsole = GetStdHandle(STD_OUTPUT_HANDLE);
    CONSOLE_SCREEN_BUFFER_INFO csbi;
    GetConsoleScreenBufferInfo(hConsole, &csbi); // Get current information
    SetConsoleTextAttribute(hConsole, csbi.wAttributes & 0x00FF); // Restore the foreground/background color
#else
    // Linux/macOS: Usa la sequenza ANSI per resettare il colore
	printf(TEXT_RESET);
#endif
}
void color_restore()
{
	if (flagnocolor)
		return;
#ifdef _WIN32
	if (g_console_attributes<0)
		return;
	HANDLE hconsole=GetStdHandle(STD_OUTPUT_HANDLE);
	if (hconsole==INVALID_HANDLE_VALUE)
		return;
	SetConsoleTextAttribute(hconsole,g_console_attributes);
#else
	printf(TEXT_RESET);
#endif // corresponds to #ifdef (#ifdef _WIN32)
}
#ifdef _WIN32
void color_something(int i_color)
{
	if (flagnocolor)
		return;
	if (g_console_attributes<0)
		return;
	HANDLE hconsole=GetStdHandle(STD_OUTPUT_HANDLE);
	if (hconsole==INVALID_HANDLE_VALUE)
		return;
	SetConsoleTextAttribute(hconsole,i_color);
	return;
}
#endif // corresponds to #ifdef (#ifdef _WIN32)
void color_red()
{
	if (flagnocolor)
		return;
#ifdef _WIN32
	color_something(4);
#else
	printf(TEXT_RED_BRIGHT);
#endif // corresponds to #ifdef (#ifdef _WIN32)
}
void color_green()
{
	if (flagnocolor)
		return;
#ifdef _WIN32
	color_something(MYFOREGROUND_GREEN+MYFOREGROUND_INTENSITY);
#else
	printf(TEXT_GREEN_BRIGHT);
#endif // corresponds to #ifdef (#ifdef _WIN32)
}
void color_cyan()
{
	if (flagnocolor)
		return;
#ifdef _WIN32
	color_something(11);
#else
	printf(TEXT_CYAN_BRIGHT);
#endif // corresponds to #ifdef (#ifdef _WIN32)
}
void color_yellow()
{
	if (flagnocolor)
		return;
#ifdef _WIN32
		color_something(14);
#else
	printf(TEXT_YELLOW_BRIGHT);
#endif // corresponds to #ifdef (#ifdef _WIN32)
}
void color_blackongreen()
{
	if (flagnocolor)
		return;
#ifdef _WIN32
	color_something(160);
#else
	
#if (defined(__APPLE__) && defined(__MACH__)) || defined(__HAIKU__)
	color_green();
#else
	printf("\x1b[30m" "\x1b[102m");
#endif // corresponds to #if (#if (defined(__APPLE__) && defined(__MACH__)) || defined(__HAIKU__))
#endif // corresponds to #ifdef (#ifdef _WIN32)
}


static const int64_t LIST_HT_BAD=   -0x7FFFFFFFFFFFFFFALL;  // no such frag

std::string print_datetime(bool i_flagout=true);

#ifdef _WIN32
// In Windows, convert UTF-8 string to wide string ignoring
// invalid UTF-8. Convert "/" to slash (default "\").
// Now supports 4-byte UTF-8 sequences (emojis, etc.) using surrogate pairs
std::wstring utow(const char* ss, char slash = '\\') {
  assert(sizeof(wchar_t) == 2);
  assert((wchar_t)(-1) == 65535);
  std::wstring r;
  if (!ss) return r;
  const unsigned char* s = (const unsigned char*)ss;
  
  while (*s) {
    if (*s == '/') {
      r += slash;
      ++s;
    }
    else if (*s < 128) {
      // ASCII (1 byte)
      r += *s;
      ++s;
    }
    else if (*s >= 192 && *s < 224 && s[1] >= 128 && s[1] < 192) {
      // 2-byte UTF-8 sequence
      r += ((*s & 0x1F) << 6) | (s[1] & 0x3F);
      s += 2;
    }
    else if (*s >= 224 && *s < 240 && s[1] >= 128 && s[1] < 192 && s[2] >= 128 && s[2] < 192) {
      // 3-byte UTF-8 sequence
      r += ((*s & 0x0F) << 12) | ((s[1] & 0x3F) << 6) | (s[2] & 0x3F);
      s += 3;
    }
    else if (*s >= 240 && *s < 248 && 
             s[1] >= 128 && s[1] < 192 && 
             s[2] >= 128 && s[2] < 192 && 
             s[3] >= 128 && s[3] < 192) {
      // 4-byte UTF-8 sequence - necessita surrogate pairs per UTF-16
      uint32_t codepoint = ((*s & 0x07) << 18) | 
                          ((s[1] & 0x3F) << 12) | 
                          ((s[2] & 0x3F) << 6) | 
                          (s[3] & 0x3F);
      
      if (codepoint >= 0x10000 && codepoint <= 0x10FFFF) {
        // Convert to surrogate pair for UTF-16
        codepoint -= 0x10000;
        wchar_t high_surrogate = 0xD800 + ((codepoint >> 10) & 0x3FF);
        wchar_t low_surrogate = 0xDC00 + (codepoint & 0x3FF);
        r += high_surrogate;
        r += low_surrogate;
      } else {
        // Invalid codepoint
        r += L'?';
      }
      s += 4;
    }
    else {
      // Invalid or unrecognized UTF-8 sequence
      r += L'?';
      ++s;
    }
  }
  return r;
}

#endif // corresponds to #ifdef (#ifdef _WIN32)

int mypos(const std::string& i_substring,const std::string& i_string)
{
    size_t start_pos = i_string.find(i_substring);
    if (start_pos==std::string::npos) return -1;
	return (int)start_pos;
}


bool fileexists(const std::string& i_filename)
{
#ifdef unix
// true even for dirs no S_ISDIR
  struct stat buffer;
  return (stat(i_filename.c_str(),&buffer)==0);
#endif // corresponds to #ifdef (#ifdef unix)
#ifdef _WIN32

	if (flagads)
		if (mypos(":",i_filename)!=-1)
		{
			if (flagdebug3)
				printf("00109: flagads ON and : in i_filename\n");
			HANDLE hFile = CreateFileW((utow(i_filename.c_str()).c_str()), GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
			if (hFile!=INVALID_HANDLE_VALUE)
			{
				if (flagdebug3)
					printf("00110: ADS FOUNDED!\n");
				CloseHandle(hFile);
				return true;
			}
			return false;
	}

	HANDLE	myhandle;
	WIN32_FIND_DATA findfiledata;
	std::wstring wpattern=utow(i_filename.c_str());
	myhandle=FindFirstFile(wpattern.c_str(),&findfiledata);
	if (myhandle!=INVALID_HANDLE_VALUE)
	{
		FindClose(myhandle);
		return true;
	}
	return false;
#endif // corresponds to #ifdef (#ifdef _WIN32)
	return false;
}

// Delete a file, return true if successful
bool delete_file(const char* filename) {
#ifdef unix
	return remove(filename)==0;
#else
	if (!fileexists(filename))
		return true;
	SetFileAttributes(utow(filename).c_str(),FILE_ATTRIBUTE_NORMAL);
	return DeleteFile(utow(filename).c_str());
#endif // corresponds to #ifdef (#ifdef unix)
}




void printUTF8(const char* s, FILE* f=stdout)
{
	assert(f);
	assert(s);
	if (g_output_handle!=0)
		fprintf(g_output_handle,"%s",s);
	if (flagsilent)
		return;
#ifdef unix
  fprintf(f, "%s", s);
#else
  const HANDLE h=(HANDLE)_get_osfhandle(_fileno(f));
  DWORD ft=GetFileType(h);
  if (ft==FILE_TYPE_CHAR) {
    fflush(f);
    std::wstring w=utow(s, '/');
    DWORD n=0;
    WriteConsole(h, w.c_str(), w.size(), &n, 0);
  }
  else
    fprintf(f, "%s", s);
#endif // corresponds to #ifdef (#ifdef unix)
}

////////////////////////////////
////////////////////////////////
////////////////////////////////
////////////////////////////////
////////////////////////////////
////////////////////////////////
////////////////////////////////
////////////////////////////////
////////////////////////////////
////////////////////////////////
////////////////////////////////






void decode_print_flag_refactored(const char* i_buffer, bool* o_flagcolon, bool* o_flagerror, bool* o_flagwarning)
{
    if (i_buffer == NULL)
    {
        if (flagdebug) 
			printf("02734: i_buffer NULL!\n");
        return;
    }

    if (o_flagcolon) *o_flagcolon = false;
    if (o_flagerror) *o_flagerror = false;
    if (o_flagwarning) *o_flagwarning = false;

    size_t len = strlen(i_buffer);
    if (len > 6 && isdigit((unsigned char)i_buffer[0]) && isdigit((unsigned char)i_buffer[1]) && isdigit((unsigned char)i_buffer[2]) &&
        isdigit((unsigned char)i_buffer[3]) && isdigit((unsigned char)i_buffer[4]) && i_buffer[6] == ' ')
    {
        char flag_char = i_buffer[5];
        if (flag_char == '!') *o_flagerror = true;
        else if (flag_char == '$') *o_flagwarning = true;
        else if (flag_char == ':') *o_flagcolon = true;
        else if (flagdebug)
            printf("02735: Invalid symbol: %c\n", flag_char);
    }
    else if (len > 6 && isdigit((unsigned char)i_buffer[0]) && flagdebug)
    {
        printf("02736: Invalid format  i_buffer: %.6s\n", i_buffer);
    }
}

bool prepare_error_log(void)
{
    if (g_error.empty())
        return false;

    if (!g_error_handle)
    {
        if (flagverbose)
            printf("02747: OPENING ERROR FILE %s\n", g_error.c_str());
        g_error_handle = fopen(g_error.c_str(), "w");
        if (!g_error_handle)
            return false;
    }

    return true;
}

void my_print_on_error(const char* format, ...)
{
    if (!format || !prepare_error_log())
        return;

    va_list args;
    va_start(args, format);
    vfprintf(g_error_handle, format, args);
    va_end(args);
    fflush(g_error_handle);
}

static void apply_padding(char* buffer, size_t buffer_size, const char* content, int width,  bool left_align)
{
    if (!buffer || !content || buffer_size == 0)
    {
        if (flagdebug) printf("02737: Invalid apply_padding\n");
        return;
    }

    size_t content_len = strlen(content);
    if (width <= (int)content_len)
    {
        snprintf(buffer, buffer_size, "%s", content);
        return;
    }

    // Force space fill — tests expect only space padding

    // Use snprintf with width to handle truncation safely
    if (left_align)
        snprintf(buffer, buffer_size, "%-*s", width, content);
    else
        snprintf(buffer, buffer_size, "%*s", width, content);
}

char* format_int64_t_refactored(int64_t value, char* buffer, size_t buffer_size, int width, bool left_align)
{
    if (!buffer || buffer_size == 0)
    {
        if (flagdebug) printf("02739: Buffer not good in format_int64_t_refactored\n");
        return NULL;
    }

    char temp_num_str[64];
    snprintf(temp_num_str, sizeof(temp_num_str), "%lld", (long long)value);

    char* src_ptr = temp_num_str;
    bool is_negative = false;
    if (*src_ptr == '-')
    {
        is_negative = true;
        src_ptr++;
    }

    int len = (int)strlen(src_ptr);

    char formatted_str[128];
    char* dst_ptr = formatted_str;
    size_t remaining = sizeof(formatted_str);

    if (is_negative && remaining > 1)
    {
        *dst_ptr++ = '-';
        remaining--;
    }

    int first_group_len = len % 3;
    if (first_group_len == 0 && len > 0)
    {
        first_group_len = 3;
    }

    if (remaining > (size_t)first_group_len)
    {
        memcpy(dst_ptr, src_ptr, first_group_len);
        dst_ptr += first_group_len;
        src_ptr += first_group_len;
        remaining -= first_group_len;
    }

    while (*src_ptr && remaining > 4)
    {
        *dst_ptr++ = '.';
        memcpy(dst_ptr, src_ptr, 3);
        dst_ptr += 3;
        src_ptr += 3;
        remaining -= 4;
    }
    *dst_ptr = '\0';

    if (*src_ptr && flagdebug)
        printf("02740: Truncating buffer in format_int64_t_refactored\n");

    // Always use spaces for padding
    apply_padding(buffer, buffer_size, formatted_str, width,  left_align);
    return buffer;
}

char* mytohuman2_refactored(int64_t i_bytes, char* buffer, size_t buffer_size, int width,  bool left_align)
{
    if (!buffer || buffer_size == 0)
    {
        if (flagdebug) printf("02741: Buffer invalid mytohuman2_refactored\n");
        return NULL;
    }

    char content[64];
    if (i_bytes < 0)
    {
        snprintf(content, sizeof(content), "neg");
    }
    else
    {
        const char* units[] = {" B", " KB", " MB", " GB", " TB", " PB"};
        double bytes = (double)i_bytes;
        int unit_index = 0;
        while (bytes >= 1024.0 && unit_index < 5)
        {
            bytes /= 1024.0;
            unit_index++;
        }
        snprintf(content, sizeof(content), "%.2f%s", bytes, units[unit_index]);
    }

    // Always space-fill
    apply_padding(buffer, buffer_size, content, width, left_align);
    return buffer;
}

bool should_skip_print(const char* format)
{
    if (!format)
        return true;

    if (strncmp(format, "DEBUG", 5) == 0)
    {
        size_t len = strlen(format);
        if (len > 5 && format[5] == ':' && !flagdebug)
            return true;
        if (len > 6 && format[6] == ':')
        {
            switch (format[5])
            {
                case '2': return !flagdebug2;
                case '3': return !flagdebug3;
                case '4': return !flagdebug4;
                case '5': return !flagdebug5;
                case '6': return !flagdebug6;
                default: break;
            }
        }
    }
    else if (strncmp(format, "VERBOSE:", 8) == 0 && !flagverbose)
        return true;

    return false;
}

void handle_silent_mode(const char* format, va_list args)
{
    char buffer[8192];
    int ret = vsnprintf(buffer, sizeof(buffer), format, args);
    if (ret >= (int)sizeof(buffer))
    {
        buffer[sizeof(buffer)-1] = '\0';
        if (flagdebug)
            printf("02742: Truncating handle_silent_mode\n");
    }

    bool flagcolon = false, flagerror = false, flagwarning = false;
    decode_print_flag_refactored(buffer, &flagcolon, &flagerror, &flagwarning);

    if (g_output_handle)
    {
        fprintf(g_output_handle, "%s", buffer);
        fflush(g_output_handle);
    }

    if (flagerror)
        my_print_on_error("%s", buffer);
}

void print_char_to_all(char c, bool is_error)
{
    putchar(c);
    if (g_output_handle)
    {
        fputc(c, g_output_handle);
        fflush(g_output_handle);
    }
    if (is_error && prepare_error_log())
    {
        fputc(c, g_error_handle);
        fflush(g_error_handle);
    }
}

void print_string_to_all_refactored(const char* str, bool is_error)
{
    if (!str)
        str = "(null)";
    fputs(str, stdout);
    if (g_output_handle)
    {
        fputs(str, g_output_handle);
        fflush(g_output_handle);
    }
    if (is_error && prepare_error_log())
    {
        fputs(str, g_error_handle);
        fflush(g_error_handle);
    }
}

typedef enum {
    ARG_TYPE_INT,
    ARG_TYPE_LONG_LONG,
    ARG_TYPE_DOUBLE,
    ARG_TYPE_POINTER,
    ARG_TYPE_CUSTOM
} arg_type_t;

static arg_type_t get_arg_type(const char* fmt_spec, char final_specifier)
{
    if (strchr("KHZ", final_specifier))
        return ARG_TYPE_CUSTOM;

    if (strchr("fegEGaA", final_specifier))
        return ARG_TYPE_DOUBLE;

    if (strchr("scp", final_specifier))
        return ARG_TYPE_POINTER;

    if (strchr("diuoxX", final_specifier))
    {
        if (strstr(fmt_spec, "ll") || strstr(fmt_spec, "L"))
            return ARG_TYPE_LONG_LONG;
        if (strstr(fmt_spec, "hh"))
            return ARG_TYPE_INT;
        if (strstr(fmt_spec, "j") || strstr(fmt_spec, "z"))
            return ARG_TYPE_LONG_LONG;
        return ARG_TYPE_INT;
    }

    if (final_specifier == 'n')
        return ARG_TYPE_POINTER;

    if (flagdebug)
        printf("02743: Specifier unknown: %s\n", fmt_spec);
    return ARG_TYPE_POINTER;
}


void my_vprintf_refactored(const char* format, va_list args)
{
    if (!format)
    {
        if (flagdebug)
            printf("02744: my_vprintf_refactored format NULL\n");
        return;
    }

    if (should_skip_print(format))
        return;

    if (flagsilent)
    {
        handle_silent_mode(format, args);
        return;
    }

    bool flagcolon = false, flagerror = false, flagwarning = false;
    decode_print_flag_refactored(format, &flagcolon, &flagerror, &flagwarning);

    if (flagerror)
        color_red();
    else if (flagwarning)
        color_yellow();

    // Only strip prefix when it's a colon type; leave '!' and '$' prefixes intact
    if (flagcolon)
    {
        if (flagdebug)
        {
            color_green();
            printf("%.5s: ", format);
            color_restore();
        }
        const char* temp = format;
        while (*temp && *temp != ' ')
            temp++;
        if (*temp == ' ')
            temp++;
        format = temp; // strip the leading "12345: "
    }

    const char* p = format;
    while (*p)
    {
        if (*p != '%')
        {
            print_char_to_all(*p, flagerror);
            p++;
            continue;
        }

        p++;
        if (*p == '%')
        {
            print_char_to_all('%', flagerror);
            p++;
            continue;
        }

        char fmt_specifier_str[64] = {'\0'};
        char* q = fmt_specifier_str;
        *q++ = '%';

        while (*p && strchr("-+0 #.0123456789hlLjz", *p))
        {
            *q++ = *p++;
        }

        char final_specifier = *p;
        *q++ = final_specifier;
        *q = '\0';

        char buffer[8192];
        int ret = 0;

        switch (final_specifier)
        {
            case 'K':
            case 'H':
            {
                int64_t val = va_arg(args, long long);

                // Extract width properly: skip flags then read consecutive digits before any '.'
                const char* s = fmt_specifier_str + 1;
                // skip flags
                while (*s && strchr("-+0 #", *s)) s++;
                // read width digits (stop at non-digit)
                int width = 0;
                while (*s >= '0' && *s <= '9') { width = width * 10 + (*s - '0'); s++; }
                bool left_align = strchr(fmt_specifier_str, '-') != NULL;

                if (strchr(fmt_specifier_str, '.'))
                {
                    if (flagdebug)
                        printf("02751: Ignored precision  %%%c\n", final_specifier);
                }

                if (final_specifier == 'K')
                    format_int64_t_refactored(val, buffer, sizeof(buffer), width,  left_align);
                else
                    mytohuman2_refactored(val, buffer, sizeof(buffer), width, left_align);

                print_string_to_all_refactored(buffer, flagerror);
                break;
            }
            case 'Z':
            {
                const char* val = va_arg(args, const char*);
                if (!val)
                    val = "(null)";

                // Extract width similarly (stop at precision)
                const char* s = fmt_specifier_str + 1;
                while (*s && strchr("-+0 #", *s)) s++;
                int width = 0;
                while (*s >= '0' && *s <= '9') { width = width * 10 + (*s - '0'); s++; }
                bool left_align = strchr(fmt_specifier_str, '-') != NULL;

                apply_padding(buffer, sizeof(buffer), val, width, left_align);
                print_string_to_all_refactored(buffer, flagerror);
                break;
            }
            case 'n':
            {
                (void)va_arg(args, void*);
                if (flagdebug)
                    printf("02745: spec %%n ignored\n");
                break;
            }
            default:
            {
                arg_type_t arg_type = get_arg_type(fmt_specifier_str, final_specifier);

                switch (arg_type)
                {
                    case ARG_TYPE_INT:
                    {
                        int v = va_arg(args, int);
                        ret = snprintf(buffer, sizeof(buffer), fmt_specifier_str, v);
                        break;
                    }
                    case ARG_TYPE_LONG_LONG:
                    {
                        long long v = va_arg(args, long long);
                        ret = snprintf(buffer, sizeof(buffer), fmt_specifier_str, v);
                        break;
                    }
                    case ARG_TYPE_DOUBLE:
                    {
                        double v = va_arg(args, double);
                        ret = snprintf(buffer, sizeof(buffer), fmt_specifier_str, v);
                        break;
                    }
                    case ARG_TYPE_POINTER:
                    {
                        void* v = va_arg(args, void*);
                        ret = snprintf(buffer, sizeof(buffer), fmt_specifier_str, v);
                        break;
                    }
                    case ARG_TYPE_CUSTOM:
                        buffer[0] = '\0';
                        break;
                }

                if (ret >= (int)sizeof(buffer) && flagdebug)
                    printf("02746: Truncate buffer my_vprintf_refactored\n");

                print_string_to_all_refactored(buffer, flagerror);
                break;
            }
        }
        p++; // move past final specifier
    }

    if (flagerror || flagwarning)
        color_restore();
    fflush(stdout);
    if (g_output_handle)
        fflush(g_output_handle);
    if (flagerror && g_error_handle)
        fflush(g_error_handle);
}

void myprintf(const char* format, ...)
{
    if (!format)
    {
        if (flagdebug)
            printf("02750: myprintf format NULL\n");
        return;
    }

    va_list args;
    va_start(args, format);
    my_vprintf_refactored(format, args);
    va_end(args);
}

void myprintf_autotest(void)
{
    printf("**** myprintf (TEST01-TEST40)\n");

    // TEST01: Specificatori standard
    printf("TEST01: Specificatori standard\n");
    myprintf("Int: %d, Unsigned: %u, Octal: %o, Hex: %x, HEX: %X\n", -123, 123, 123, 123, 123);
    myprintf("Float: %f, Scientific: %e, General: %g\n", 123.456, 123.456, 123.456);
    myprintf("Char: %c, String: %s, Pointer: %p\n", 'A', "Test string", (void*)&g_error);

    // TEST02: Specificatori con modificatori di lunghezza
    printf("TEST02: Modificatori di lunghezza\n");
    myprintf("Long long: %lld, Long long hex: %llx\n", (long long)INT64_MAX, (long long)INT64_MAX);
    myprintf("Short int: %hd\n", (short)123);
    myprintf("Size_t: %zu, Intmax_t: %jd\n", (size_t)123, (intmax_t)123);

    // TEST03: Specificatore %K
    printf("TEST03: Specificatore %%K\n");
    myprintf("Int64: %K\n", (int64_t)123456789);
    myprintf("Int64 negative: %K\n", (int64_t)-123456789);
    myprintf("Int64 max: %K\n", INT64_MAX);
    myprintf("Int64 min: %K\n", INT64_MIN);
    myprintf("Int64 with width: %10K\n", (int64_t)123456);
    myprintf("Int64 left-align: %-10K\n", (int64_t)123456);

    // TEST04: Specificatore %H
    printf("TEST04: Specificatore %%H\n");
    myprintf("Bytes: %H\n", (int64_t)123456789);
    myprintf("Negative bytes: %H\n", (int64_t)-123);
    myprintf("Large bytes: %H\n", (int64_t)(1024 * 1024 * 1024 * 5LL));
    myprintf("Bytes with width: %10H\n", (int64_t)123456);
    myprintf("Bytes left-align: %-10H\n", (int64_t)123456);

    // TEST05: Specificatore %Z
    printf("TEST05: Specificatore %%Z\n");
    myprintf("String: %Z\n", "Test UTF8 string");
    myprintf("Null string: %Z\n", (char*)NULL);
    myprintf("String with width: %10Z\n", "Test");
    myprintf("String left-align: %-10Z\n", "Test");

    // TEST06: Prefissi per flagcolon, flagerror, flagwarning
    printf("TEST06: Prefissi flagcolon, flagerror, flagwarning\n");
    myprintf("12345: Test colon\n");
    myprintf("12345! Test error\n");
    myprintf("12345$ Test warning\n");
    myprintf("12345: Test %d\n", 123);

    // TEST07: Modalità debug
    printf("TEST07: Modalità debug\n");
    bool old_flagdebug = flagdebug;
    flagdebug = true;
    myprintf("DEBUG: Debug message\n");
    myprintf("DEBUG2: Debug level 2\n");
    myprintf("DEBUG3: Debug level 3\n");
    flagdebug = old_flagdebug;

    // TEST08: Modalità verbose
    printf("TEST08: Modalità verbose\n");
    bool old_flagverbose = flagverbose;
    flagverbose = true;
    myprintf("VERBOSE: Verbose message\n");
    flagverbose = old_flagverbose;

    // TEST09: Modalità silenziosa
    printf("TEST09: Modalità silenziosa\n");
    bool old_flagsilent = flagsilent;
    flagsilent = true;
    myprintf("Test in silent mode: %d\n", 123);
    myprintf("12345! Test error in silent mode\n");
    flagsilent = old_flagsilent;

    // TEST10: Formati con troncamento
    printf("TEST10: Troncamento buffer\n");
    flagdebug = true;
    char long_str[7000];
    memset(long_str, 'A', 6999);
    long_str[6999] = '\0';
    myprintf("Long string: %s\n", long_str);
    flagdebug = old_flagdebug;

    // TEST11: Formati con parametri nulli
    printf("TEST11: Parametri nulli\n");
    myprintf("Null format: %s\n", (char*)NULL);
    myprintf(NULL);

    // TEST12: Specificatori con precisione e flag
    printf("TEST12: Precisione e flag\n");
    myprintf("Padded int: %010d\n", 123);
    myprintf("Precision float: %.2f\n", 123.456789);
    myprintf("Signed int: %+d\n", 123);
    myprintf("Space int: % d\n", 123);

    // TEST13: Specificatore %n
    printf("TEST13: Specificatore %%n\n");
    flagdebug = true;
    int n;
    myprintf("Store count: %n\n", &n);
    flagdebug = old_flagdebug;

    // TEST14: Stringhe vuote e spazi
    printf("TEST14: Stringhe vuote e spazi\n");
    myprintf("Empty string: %s\n", "");
    myprintf("Spaces: %s\n", "   ");

    // TEST15: Combinazioni complesse
    printf("TEST15: Combinazioni complesse\n");
    myprintf("12345: Complex: %K %H %Z %d %.2f\n", (int64_t)123456, (int64_t)1048576, "Test", 123, 123.456);
    myprintf("12345! Error complex: %K %H %Z\n", (int64_t)-123456, (int64_t)1024, (char*)NULL);

    // TEST16: Padding con caratteri diversi
    printf("TEST16: Padding con caratteri diversi\n");
    char buffer[32];
    format_int64_t_refactored(123456, buffer, sizeof(buffer), 10,  false);
    myprintf("Padded %K: %s\n", (int64_t)123456, buffer);
    mytohuman2_refactored(123456, buffer, sizeof(buffer), 10, true);
    myprintf("Padded %H: %s\n", (int64_t)123456, buffer);

    // TEST17: Formati non validi
    printf("TEST17: Formati non validi\n");
    flagdebug = true;
    myprintf("12345X Invalid format\n");
    myprintf("1234: Short prefix\n");
    flagdebug = old_flagdebug;

    // TEST18: Specificatori con modificatori complessi
    printf("TEST18: Modificatori complessi\n");
    myprintf("Zero-padded: %08d\n", 123);
    myprintf("Precision string: %.5s\n", "HelloWorld");
    myprintf("Complex float: %10.3f\n", 123.456789);

    // TEST19: Più specificatori
    printf("TEST19: Più specificatori\n");
    myprintf("Mixed: %d %s %K %H\n", 123, "Test", (int64_t)123456, (int64_t)1048576);

    // TEST20: Specificatori non riconosciuti
    printf("TEST20: Specificatori non riconosciuti\n");
    flagdebug = true;
    myprintf("Unknown: %q\n", 123);
    flagdebug = old_flagdebug;

    // TEST21: Combinazioni di flag
    printf("TEST21: Combinazioni di flag\n");
    myprintf("Signed padded: %+10d\n", 123);
    myprintf("Zero padded float: %010.3f\n", 123.456);
    myprintf("Space padded: % 10d\n", 123);

    // TEST22: Precisione non supportata per %K e %H
    printf("TEST22: Precisione non supportata per %%K e %%H\n");
    flagdebug = true;
    myprintf("Precision %K: %.2K\n", (int64_t)123456);
    myprintf("Precision %H: %.2H\n", (int64_t)123456);
    flagdebug = old_flagdebug;

    // TEST23: Stringhe UTF-8
    printf("TEST23: Stringhe UTF-8\n");
    myprintf("UTF-8 string: %Z\n", "Café München");
    myprintf("UTF-8 with width: %15Z\n", "Café");

    printf("===== Fine Test myprintf =====\n");
}

////////////////////////////////
////////////////////////////////
////////////////////////////////
////////////////////////////////
////////////////////////////////
////////////////////////////////
////////////////////////////////
////////////////////////////////
////////////////////////////////
////////////////////////////////






/*
void myprintf(const char *format, ...) 
{
    // Early exit if format is null
    if (!format) 
        return;
	 // Early exit if string starts with "DEBUG:" and flagdebug is false
	 
	  if (format[0] == 'D' && format[1] == 'E' && format[2] == 'B' && 
        format[3] == 'U' && format[4] == 'G') 
	{
        
        if (format[5] == ':' && !flagdebug) {
            return;
        }
        else if (format[5] >= '2' && format[5] <= '6' && format[6] == ':') {
            switch(format[5]) {
                case '2': if (!flagdebug2) return; break;
                case '3': if (!flagdebug3) return; break;
                case '4': if (!flagdebug4) return; break;
                case '5': if (!flagdebug5) return; break;
                case '6': if (!flagdebug6) return; break;
            }
        }
    }
    else if (format[0] == 'V' && format[1] == 'E' && format[2] == 'R' && 
             format[3] == 'B' && format[4] == 'O' && format[5] == 'S' && 
             format[6] == 'E' && format[7] == ':' && !flagverbose) {
        return;
    }
	
    bool flagerror = false;
    bool flagwarning = false;
    bool flagcolon = false;
    char buffer[4096]; // Buffer temporaneo per formati complessi

    if (flagsilent) 
	{
        char fixata[4096];
        replacezwiths(format, fixata);

        va_list args2;
        va_start(args2, format);
        vsnprintf(buffer, sizeof(buffer), fixata, args2);
        va_end(args2);
        
        decode_print_flag(buffer, flagcolon, flagerror, flagwarning);
        if (g_output_handle != 0)
            fprintf(g_output_handle, "%s", buffer);
    
        if (flagerror)
            my_print_on_error_z(buffer);

        return;
    }

    va_list args;
    va_start(args, format);

    decode_print_flag(format, flagcolon, flagerror, flagwarning);
    
    if (flagcolon || flagwarning) {
        if (flagdebug) {
            color_green();
            printf("%c%c%c%c%c: ", format[0], format[1], format[2], format[3], format[4]);
            color_restore();
        }
        format += 7;
    }
        
    if (flagerror)
        color_red();
    else if (flagwarning)
        color_yellow();

    const char *p = format;
    while (*p) {
        if (*p == '%') {
            p++; // Passa al carattere successivo dopo '%'

            if (*p == '%') {
                putchar('%');
                if (g_output_handle != 0)
                    fputc('%', g_output_handle);
                if (flagerror && prepare_error_log())
                    fputc('%', g_error_handle);
                p++;
                continue;
            }

            char fmt_buffer[32];
            char* b = fmt_buffer;
            *b++ = '%';

            // Gestisci flag
            int left_align = 0;
            char fill_char = ' ';
            while (*p && (strchr("-+0 ", *p) != NULL)) {
                if (*p == '-') left_align = 1;
                if (*p == '0') fill_char = '0';
                *b++ = *p++;
            }

            // Gestisci larghezza
            int width = 0;
            while (*p && (*p >= '0' && *p <= '9')) {
                width = width * 10 + (*p - '0');
                *b++ = *p++;
            }

            // Gestisci precisione (ignorata per %K e %H)
            if (*p == '.') {
                *b++ = *p++;
                while (*p && (*p >= '0' && *p <= '9')) {
                    *b++ = *p++;
                }
            }

            // Gestisci specificatore
            if (*p && strchr("diouxXfscZKH", *p) != NULL) {
                *b++ = *p;
                *b = '\0';

                if (*p == 'K') {
                    int64_t value = va_arg(args, int64_t);
					std::string formatted=format_int64_t(value, width, fill_char, left_align);
                    printf("%s", formatted.c_str());
                    if (g_output_handle != 0)
                        fprintf(g_output_handle, "%s", formatted.c_str());
                    if (flagerror && prepare_error_log())
                        fprintf(g_error_handle, "%s", formatted.c_str());
                } else if (*p == 'H') {
                    int64_t value = va_arg(args, int64_t);
                    std::string formatted=mytohuman2(value,width, fill_char, left_align);
                    printf("%s", formatted.c_str());
                    if (g_output_handle != 0)
                        fprintf(g_output_handle, "%s", formatted.c_str());
                    if (flagerror && prepare_error_log())
                        fprintf(g_error_handle, "%s", formatted.c_str());
                } else if (*p == 'd' || *p == 'i') {
                    int i = va_arg(args, int);
                    printf(fmt_buffer, i);
                    if (g_output_handle != 0)
                        fprintf(g_output_handle, fmt_buffer, i);
                    if (flagerror)
                        my_print_on_error_i(fmt_buffer, i);
                } else if (*p == 'u' || *p == 'x' || *p == 'X') {
                    unsigned int x = va_arg(args, unsigned int);
                    printf(fmt_buffer, x);
                    if (g_output_handle != 0)
                        fprintf(g_output_handle, fmt_buffer, x);
                    if (flagerror)
                        my_print_on_error_u(fmt_buffer, x);
                } else if (*p == 'f') {
                    double f = va_arg(args, double);
                    printf(fmt_buffer, f);
                    if (g_output_handle != 0)
                        fprintf(g_output_handle, fmt_buffer, f);
                    if (flagerror)
                        my_print_on_error_d(fmt_buffer, f);
                } else if (*p == 's') {
                    if (strchr(fmt_buffer, '*') != NULL) {
                        int width = va_arg(args, int);
                        const char *s = va_arg(args, char *);
                        printf(fmt_buffer, width, s);
                        if (g_output_handle != 0)
                            fprintf(g_output_handle, fmt_buffer, width, s);
                        if (flagerror)
                            my_print_on_error_s(fmt_buffer, s);
                    } else {
                        const char *s = va_arg(args, char *);
                        printf(fmt_buffer, s);
                        if (g_output_handle != 0)
                            fprintf(g_output_handle, fmt_buffer, s);
                        if (flagerror)
                            my_print_on_error_s(fmt_buffer, s);
                    }
                } else if (*p == 'c') {
                    int c = va_arg(args, int);
                    printf(fmt_buffer, c);
                    if (g_output_handle != 0)
                        fprintf(g_output_handle, fmt_buffer, c);
                    if (flagerror)
                        my_print_on_error_i(fmt_buffer, c);
                } else if (*p == 'Z') {
                    const char *s = va_arg(args, char *);
                    printUTF8(s);
                    if (flagerror)
                        my_print_on_error_z(s);
                }
            } else {
                putchar(*p);
                if (g_output_handle != 0)
                    fputc(*p, g_output_handle);
                if (flagerror && prepare_error_log())
                    fputc(*p, g_error_handle);
            }
            p++;
        } else {
            putchar(*p);
            if (g_output_handle != 0)
                fputc(*p, g_output_handle);
            if (flagerror && prepare_error_log())
                fputc(*p, g_error_handle);
            p++;
        }
    }
    va_end(args);
#ifndef _WIN32
    fflush(stdout);
#endif
    if (flagerror || flagwarning)
        color_restore();
}
*/


/// LICENSE_START.23

//  This is a reworked https://github.com/codewithnick/ascii-art
//  Just one font, different output char, no streams

class Fonts
{
    unsigned int def_rows;
    unsigned int def_cols;
    unsigned int char_rows;
    unsigned int char_cols;
    unsigned int curr_col;
    std::vector<std::vector<char> > letters;
/*

zpaqfranz.cpp:2930:25: note: the layout of aggregates containing vectors with 8-byte alignment has changed in GCC 5
 2930 |         this->char_rows = rows ? rows : def_rows;
 */
protected:
    char **getCharGrid(unsigned int rows = 0, unsigned int cols = 0)
    {
        this->char_rows = rows ? rows : def_rows;
        this->char_cols = cols ? cols : def_cols;

        char **char_grid = new char *[char_rows];
        for (unsigned int i = 0; i < char_rows; i++)
        {
            char_grid[i] = new char[char_cols];
            for (unsigned int j = 0; j < char_cols; j++)
                char_grid[i][j] = ' ';
        }
        return char_grid;
    }
	void destroyspace()
    {
        letters.clear();
    }

public:
    Fonts(int def_rows, int def_cols)
    {
        this->def_rows = def_rows;
        this->def_cols = def_cols;

        letters.reserve(def_rows);
        for (int i = 0; i < def_rows; i++)
            letters.push_back(std::vector<char>(100, ' ')); // Create rows with 100 spaces each
        curr_col = 0;
    }

    void pushChar(char **character)
    {
        if (!character)
            return;

        while (letters.size() < char_rows)
            letters.push_back(std::vector<char>(100, ' ')); // Create rows with 100 spaces each

		for (unsigned int i = 0; i < char_rows; i++)
        {
            for (unsigned int j = 0; j < char_cols; j++)
            {
                letters[i][j + curr_col] = character[i][j];
            }
        }
        curr_col += (char_cols + 2);
    }

/*
    std::vector<std::vector<char> > getletters()
    {
        return letters;
    }
*/
    void printvector()
    {
        for (unsigned int i = 0; i < letters.size(); i++)
        {
			unsigned int lastspace=letters[0].size();
            for (unsigned int j=letters[0].size()-1; j>0; j--)
				if (letters[i][j]!=' ')
				{
					lastspace=j;
					break;
				}
            ///for (unsigned int j = 0; j < letters[0].size(); j++)
			for (unsigned int j = 0; j < lastspace; j++)
				myprintf("%c",letters[i][j]);
    		myprintf("\n");
        }
    }

    /********************************adding virtual functions********************************/
    // Virtual functions for space
    virtual char **space()
    {
        return 0;
    }

    // Virtual functions for lowercase letters
    virtual char **a()
    {
        return 0;
    }
    virtual char **b()
    {
        return 0;
    }
    virtual char **c()
    {
        return 0;
    }
    virtual char **d()
    {
        return 0;
    }
    virtual char **e()
    {
        return 0;
    }
    virtual char **f()
    {
        return 0;
    }
    virtual char **g()
    {
        return 0;
    }
    virtual char **h()
    {
        return 0;
    }
    virtual char **i()
    {
        return 0;
    }
    virtual char **j()
    {
        return 0;
    }
    virtual char **k()
    {
        return 0;
    }
    virtual char **l()
    {

        return 0;
    }
    virtual char **m()
    {
 
        return 0;
    }
    virtual char **n()
    {
        return 0;
    }
    virtual char **o()
    {
        return 0;
    }
    virtual char **p()
    {
        return 0;
    }
    virtual char **q()
    {
        return 0;
    }
    virtual char **r()
    {
        return 0;
    }
    virtual char **s()
    {
        return 0;
    }
    virtual char **t()
    {
        return 0;
    }
    virtual char **u()
    {
        return 0;
    }
    virtual char **v()
    {
        return 0;
    }
    virtual char **w()
    {
        return 0;
    }
    virtual char **x()
    {
        return 0;
    }
    virtual char **y()
    {
        return 0;
    }
    virtual char **z()
    {
        return 0;
    }

    // Virtual functions for uppercase letters
    virtual char **A()
    {
        return 0;
    }
    virtual char **B()
    {
        return 0;
    }
    virtual char **C()
    {
        return 0;
    }
    virtual char **D()
    {
        return 0;
    }
    virtual char **E()
    {
        return 0;
    }
    virtual char **F()
    {
        return 0;
    }
    virtual char **G()
    {
        return 0;
    }
    virtual char **H()
    {
        return 0;
    }
    virtual char **I()
    {
        return 0;
    }
    virtual char **J()
    {
        return 0;
    }
    virtual char **K()
    {
        return 0;
    }
    virtual char **L()
    {
        return 0;
    }
    virtual char **M()
    {
        return 0;
    }
    virtual char **N()
    {
        return 0;
    }
    virtual char **O()
    {
        return 0;
    }
    virtual char **P()
    {
        return 0;
    }
    virtual char **Q()
    {
        return 0;
    }
    virtual char **R()
    {
        return 0;
    }
    virtual char **S()
    {
        return 0;
    }
    virtual char **T()
    {
        return 0;
    }
    virtual char **U()
    {
        return 0;
    }
    virtual char **V()
    {
        return 0;
    }
    virtual char **W()
    {
        return 0;
    }
    virtual char **X()
    {
        return 0;
    }
    virtual char **Y()
    {
        return 0;
    }
    virtual char **Z()
    {
        return 0;
    }
    virtual char **zero()
    {
        return 0;
    }
    virtual char **one()
    {
        return 0;
    }
    virtual char **two()
    {
        return 0;
    }
    virtual char **three()
    {
        return 0;
    }
    virtual char **four()
    {
        return 0;
    }
    virtual char **five()
    {
        return 0;
    }
    virtual char **six()
    {
        return 0;
    }
    virtual char **seven()
    {
        return 0;
    }
    virtual char **eight()
    {
        return 0;
    }
    virtual char **nine()
    {
        return 0;
    }

    /********************************done adding virtual functions********************************/
	virtual ~Fonts()
    {
        destroyspace();
    }
/*
    ~Fonts()
    {
        destroyspace();
    }
	*/
};

class SevenStar : public Fonts
{
	static const int rows = 7;
	static const int cols = 7;

public:
	SevenStar() : Fonts(rows, cols) {}

	char **A()
	{
		char **character = getCharGrid();

		for (int i = 0; i < 7; i++)
		{
			for (int j = 0; j < 7; j++)
			{
				if (i == 0)
				{
					if (j == 2 || j == 3 || j == 4)
						character[i][j] = 'A';
					else
						character[i][j] = ' ';
				}

				if (i == 1)
				{
					if (j % 3 == 0)
					{
						character[i][j] = ' ';
					}
					else
						character[i][j] = 'A';
				}

				if (i == 2 || i == 3 || i == 5 || i == 6)
				{
					if (j == 0 || j == 1 || j == 5 || j == 6)
					{
						character[i][j] = 'A';
					}
					else
					{
						character[i][j] = ' ';
					}
				}

				if (i == 4)
				{

					character[i][j] = 'A';
				}
			}
		}

		return character;
	}
	char **B()
	{
		char **character = getCharGrid();
		for (int i = 0; i < 7; i++)
		{
			for (int j = 0; j < 7; j++)
			{
				if (i == 0 || i == 6)
				{
					if (j == 5 || j == 6)
						character[i][j] = ' ';
					else
						character[i][j] = 'B';
				}

				if (i >= 1 && i <= 5 && i != 3)
				{
					if (j == 2 || j == 3 || j == 4)
						character[i][j] = ' ';
					else
						character[i][j] = 'B';
				}

				if (i == 3)
				{
					if (j == 6)
						character[i][j] = ' ';
					else
						character[i][j] = 'B';
				}
			}
		}
		return character;
	}
	char **C()
	{
		char **character = getCharGrid();
		for (int i = 0; i < 7; i++)
		{
			for (int j = 0; j < 7; j++)
			{
				// first aur last line
				if (i == 0 || i == 6)
				{
					if ((j % 7) % 3 != 0)
					{
						character[i][j] = 'C';
					}
					else
					{
						character[i][j] = ' ';
					}
				}

				// second nd second last line

				if (i == 1 || i == 5)
				{
					if (((j) % 7) < 2 || ((j) % 7) > 4)
					{
						character[i][j] = 'C';
					}
					else
					{
						character[i][j] = ' ';
					}
				}

				// rest

				if (i == 2 || i == 4 || i == 3)
				{
					if (((j) % 7) < 2)
					{
						character[i][j] = 'C';
					}
					else
					{
						character[i][j] = ' ';
					}
				}
			}
		}
		return character;
	}
	char **D()
	{
		char **character = getCharGrid();
		for (int i = 0; i < 7; i++)
		{
			for (int j = 0; j < 7; j++)
			{
				if (i == 0 || i == 6)
				{
					if (((j) % 7) != 0 && ((j) % 7) % 3 == 0)
						character[i][j] = ' ';
					else
						character[i][j] = 'D';
				}
				else
				{
					if (((j) % 7) == 1 || ((j) % 7) == 2 || ((j) % 7) == 5 || ((j) % 7) == 6)
						character[i][j] = 'D';
					else
						character[i][j] = ' ';
				}
			}
		}
		return character;
	}
	char **E()
	{
		char **character = getCharGrid();
		for (int i = 0; i < 7; i++)
		{
			for (int j = 0; j < 7; j++)
			{
				if (i == 0 || i == 6)
				{
					character[i][j] = 'E';
				}

				if (i == 1 || i == 5)
				{
					if (j == 0 || j == 1 || j == 5 || j == 6)
						character[i][j] = 'E';
					else
						character[i][j] = ' ';
				}

				if (i == 2 || i == 4)
				{
					if (j == 0 || j == 1)
						character[i][j] = 'E';
					else
						character[i][j] = ' ';
				}

				if (i == 3)
				{
					if (j == 6)
						character[i][j] = ' ';
					else
						character[i][j] = 'E';
				}
			}
		}
		return character;
	}

	char **F()
	{
		char **character = getCharGrid();
		for (int i = 0; i < 7; i++)
		{
			for (int j = 0; j < 7; j++)
			{
				if (i == 0)
				{
					character[i][j] = 'F';
				}

				if (i == 2 || i == 5 || i == 6 || i == 1 || i == 4)
				{
					if (j == 0 || j == 1)
						character[i][j] = 'F';
					else
						character[i][j] = ' ';
				}

				if (i == 3)
				{
					if (j == 6)
						character[i][j] = ' ';
					else
						character[i][j] = 'F';
				}
			}

			// cout<<endl;
		}
		return character;
	}

	char **G()
	{
		char **character = getCharGrid();
		for (int i = 0; i < 7; i++)
		{
			for (int j = 0; j < 7; j++)
			{
				if (i == 0 || i == 6)
				{
					if (j == 0 || j == 6)
						character[i][j] = ' ';
					else
						character[i][j] = 'G';
				}

				if (i == 1 || i == 5 || i == 4)
				{
					if (j == 0 || j == 1 || j == 5 || j == 6)
						character[i][j] = 'G';
					else
						character[i][j] = ' ';
				}

				if (i == 3)
				{
					if (j == 2 || j == 3)
						character[i][j] = ' ';
					else
						character[i][j] = 'G';
				}

				if (i == 2)
				{
					if (j == 0 || j == 1)
						character[i][j] = 'G';
					else
						character[i][j] = ' ';
				}
			}
		}
		return character;
	}

	char **H()
	{
		char **character = getCharGrid();
		for (int i = 0; i < 7; i++)
		{
			for (int j = 0; j < 7; j++)
			{
				if (i >= 0 && i <= 6)
				{
					if (j == 0 || j == 1 || j == 5 || j == 6)
						character[i][j] = 'H';
					else
						character[i][j] = ' ';
				}

				if (i == 3)
				{
					if (j > 1 && j < 5)
						character[i][j] = 'H';
				}
			}
		}
		return character;
	}

	char **I()
	{
		char **character = getCharGrid();
		for (int i = 0; i < 7; i++)
		{
			for (int j = 0; j < 7; j++)
			{
				if (i == 0 || i == 6)
				{
					character[i][j] = 'I';
				}
				else
				{
					if (j == 2 || j == 3 || j == 4)
					{
						character[i][j] = 'I';
					}
					else
						character[i][j] = ' ';
				}
			}
		}
		return character;
	}
	char **J()
	{
		char **character = getCharGrid();
		for (int i = 0; i < 7; i++)
		{
			for (int j = 0; j < 7; j++)
			{
				if (i == 0)
				{
					if (j < 3)
						character[i][j] = ' ';
					else
						character[i][j] = 'J';
				}

				if (i == 1 || i == 2 || i == 3)
				{
					if (j == 4 || j == 5)
						character[i][j] = 'J';
					else
						character[i][j] = ' ';
				}

				if (i == 4 || i == 5)
				{
					if (j == 2 || j == 3 || j == 6)
						character[i][j] = ' ';
					else
						character[i][j] = 'J';
				}

				if (i == 6)
				{
					if (j == 0 || j == 5 || j == 6)
						character[i][j] = ' ';
					else
						character[i][j] = 'J';
				}
			}
		}
		return character;
	}

	char **K()
	{
		char **character = getCharGrid();
		for (int i = 0; i < 7; i++)
		{
			for (int j = 0; j < 7; j++)
			{
				if (i == 0 || i == 6)
				{
					if (j == 2 || j == 3 || j == 4)
						character[i][j] = ' ';
					else
						character[i][j] = 'K';
				}

				if (i == 1 || i == 5)
				{
					if (j == 2 || j == 3 || j == 6)
						character[i][j] = ' ';
					else
						character[i][j] = 'K';
				}

				if (i == 3)
				{
					if (j == 4 || j == 5 || j == 6)
						character[i][j] = ' ';
					else
						character[i][j] = 'K';
				}

				if (i == 2 || i == 4)
				{
					if (j == 2 || j == 5 || j == 6)
						character[i][j] = ' ';
					else
						character[i][j] = 'K';
				}
			}
		}
		return character;
	}

	char **L()
	{
		char **character = getCharGrid();
		for (int i = 0; i < 7; i++)
		{
			for (int j = 0; j < 7; j++)
			{
				if (i < 6)
				{
					if (j == 0 || j == 1)
						character[i][j] = 'L';
					else
						character[i][j] = ' ';
				}
				else
					character[i][j] = 'L';
			}
		}
		return character;
	}

	char **M()
	{
		char **character = getCharGrid();
		for (int i = 0; i < 7; i++)
		{
			for (int j = 0; j < 7; j++)
			{
				if (i == 0)
				{
					if (j == 2 || j == 3 || j == 4)
						character[i][j] = ' ';
					else
						character[i][j] = 'M';
				}

				if (i == 1)
				{
					if (j == 3)
					{
						character[i][j] = ' ';
					}
					else
						character[i][j] = 'M';
				}

				if (i == 2)
				{
					character[i][j] = 'M';
				}

				if (i == 3)
				{
					if (j == 2 || j == 4)
						character[i][j] = ' ';
					else
						character[i][j] = 'M';
				}

				if (i >= 4 && i <= 6)
				{
					if (j == 2 || j == 3 || j == 4)
						character[i][j] = ' ';
					else
						character[i][j] = 'M';
				}
			}
		}
		return character;
	}

	char **N()
	{
		char **character = getCharGrid();
		for (int i = 0; i < 7; i++)
		{
			for (int j = 0; j < 7; j++)
			{
				if (i == 0 || i == 6)
				{
					if (j == 2 || j == 3 || j == 4)
						character[i][j] = ' ';
					else
						character[i][j] = 'N';
				}

				if (i == 2 || i == 1)
				{
					if (j == 3 || j == 4)
					{
						character[i][j] = ' ';
					}
					else
						character[i][j] = 'N';
				}

				if (i == 3)
				{
					if (j == 2 || j == 4)
					{
						character[i][j] = ' ';
					}
					else
					{
						character[i][j] = 'N';
					}
				}

				if (i == 4 || i == 5)
				{
					if (j == 2 || j == 3)
						character[i][j] = ' ';
					else
						character[i][j] = 'N';
				}
			}
		}
		return character;
	}
	char **O()
	{
		char **character = getCharGrid();
		for (int i = 0; i < 7; i++)
		{
			for (int j = 0; j < 7; j++)
			{
				if (i == 6 || i == 0)
				{
					if (j == 0 || j == 6)
						character[i][j] = ' ';
					else
						character[i][j] = 'O';
				}
				else
				{
					if (j == 2 || j == 3 || j == 4)
						character[i][j] = ' ';
					else
						character[i][j] = 'O';
				}
			}

			//	cout<<endl;
		}
		return character;
	}

	char **P()
	{
		char **character = getCharGrid();
		for (int i = 0; i < 7; i++)
		{
			for (int j = 0; j < 7; j++)
			{
				if (i == 0 || i == 3)
				{
					if (j == 6)
						character[i][j] = ' ';
					else
						character[i][j] = 'P';
				}

				if (i == 1 || i == 2)
				{
					if (j == 2 || j == 3 || j == 4)
					{
						character[i][j] = ' ';
					}
					else
						character[i][j] = 'P';
				}

				if (i >= 4 && i <= 6)
				{
					if (j == 0 || j == 1)
					{
						character[i][j] = 'P';
					}
					else
					{
						character[i][j] = ' ';
					}
				}
			}
		}
		return character;
	}

	char **Q()
	{
		char **character = getCharGrid();
		for (int i = 0; i < 7; i++)
		{
			for (int j = 0; j < 7; j++)
			{
				if (i == 0)
				{
					if (j % 3 == 0)
						character[i][j] = ' ';
					else
						character[i][j] = 'Q';
				}

				if (i >= 1 && i <= 4)
				{
					if (j == 2 || j == 3 || j == 4)
						character[i][j] = ' ';
					else
						character[i][j] = 'Q';
				}

				if (i == 5)
				{
					if (j == 2 || j == 3 || j == 6)
						character[i][j] = ' ';
					else
						character[i][j] = 'Q';
				}
				if (i == 6)
				{
					if (j == 0 || j == 3 || j == 4)
						character[i][j] = ' ';
					else
						character[i][j] = 'Q';
				}
			}

			// cout<<endl;
		}
		return character;
	}

	char **R()
	{
		char **character = getCharGrid();
		for (int i = 0; i < 7; i++)
		{
			for (int j = 0; j < 7; j++)
			{
				if (i == 0 || i == 3)
				{
					if (j == 6)
						character[i][j] = ' ';
					else
						character[i][j] = 'R';
				}

				if (i == 1 || i == 2 || i == 5 || i == 6)
				{
					if (j == 2 || j == 3 || j == 4)
						character[i][j] = ' ';
					else
						character[i][j] = 'R';
				}

				if (i == 4)
				{
					if (j == 2 || j == 3 || j == 6)
						character[i][j] = ' ';
					else
						character[i][j] = 'R';
				}
			}
			// cout<<endl;
		}
		return character;
	}

	char **S()
	{
		char **character = getCharGrid();
		for (int i = 0; i < 7; i++)
		{
			for (int j = 0; j < 7; j++)
			{
				if (i == 0 || i == 6)
				{
					if (j == 0 || j == 6)
						character[i][j] = ' ';
					else
						character[i][j] = 'S';
				}

				if (i == 1 || i == 5)
				{
					if (j == 3 || j == 2 || j == 4)
					{
						character[i][j] = ' ';
					}
					else
						character[i][j] = 'S';
				}

				if (i == 2)
				{
					if (j == 4 || j == 5 || j == 6)
					{
						character[i][j] = ' ';
					}
					else
					{
						character[i][j] = 'S';
					}
				}

				if (i == 3)
				{

					if (j == 0 || j == 6)
						character[i][j] = ' ';
					else
						character[i][j] = 'S';
				}

				if (i == 4)
				{
					if (j == 4 || j == 5 || j == 6)
						character[i][j] = 'S';
					else
						character[i][j] = ' ';
				}
			}
		}
		return character;
	}

	char **T()
	{
		char **character = getCharGrid();
		for (int i = 0; i < 7; i++)
		{
			for (int j = 0; j < 7; j++)
			{
				if (i == 0)
				{
					character[i][j] = 'T';
				}

				if (i >= 1 && i <= 6)
				{
					if (j == 3 || j == 2)
						character[i][j] = 'T';
					else
						character[i][j] = ' ';
				}
			}

			// cout<<endl;
		}
		return character;
	}

	char **U()
	{
		char **character = getCharGrid();
		for (int i = 0; i < 7; i++)
		{
			for (int j = 0; j < 7; j++)
			{
				if (i <= 5)
				{
					if (j == 2 || j == 3 || j == 4)
						character[i][j] = ' ';
					else
						character[i][j] = 'U';
				}
				else
				{
					if (j == 0 || j == 6)
					{
						character[i][j] = ' ';
					}
					else
						character[i][j] = 'U';
				}
			}
		}
		return character;
	}

	char **V()
	{
		char **character = getCharGrid();
		for (int i = 0; i < 7; i++)
		{
			for (int j = 0; j < 7; j++)
			{
				if (i == 6)
				{
					if (j == 2 || j == 3 || j == 4)
						character[i][j] = 'V';
					else
						character[i][j] = ' ';
				}

				if (i == 5)
				{
					if (j % 3 == 0)
					{
						character[i][j] = ' ';
					}
					else
						character[i][j] = 'V';
				}
				if (i < 5)
				{
					if (j == 0 || j == 1 || j == 5 || j == 6)
					{
						character[i][j] = 'V';
					}
					else
					{
						character[i][j] = ' ';
					}
				}
			}
		}
		return character;
	}

	char **W()
	{
		char **character = getCharGrid();
		for (int i = 0; i < 7; i++)
		{
			for (int j = 0; j < 7; j++)
			{
				if (i == 0 || i == 1 || i == 2 || i == 6)
				{
					if (j == 2 || j == 3 || j == 4)
						character[i][j] = ' ';
					else
						character[i][j] = 'W';
				}

				if (i == 3)
				{
					if (j == 2 || j == 4)
						character[i][j] = ' ';
					else
						character[i][j] = 'W';
				}

				if (i == 4)
				{
					character[i][j] = 'W';
				}

				if (i == 5)
				{
					if (j == 3)
						character[i][j] = ' ';
					else
						character[i][j] = 'W';
				}
			}

			// cout<<endl;
		}
		return character;
	}

	char **X()
	{
		char **character = getCharGrid();
		for (int i = 0; i < 7; i++)
		{
			for (int j = 0; j < 7; j++)
			{
				if (i == 0 || i == 1 || i == 5 || i == 6)
				{
					if (j == 2 || j == 3 || j == 6)
						character[i][j] = ' ';
					else
						character[i][j] = 'X';
				}

				if (i == 2 || i == 4)
				{
					if (j == 0 || j == 5 || j == 6)
						character[i][j] = ' ';
					else
						character[i][j] = 'X';
				}

				if (i == 3)
				{
					if (j == 3 || j == 2)
						character[i][j] = 'X';
					else
						character[i][j] = ' ';
				}
			}
		}
		return character;
	}
	char **Y()
	{
		char **character = getCharGrid();
		for (int i = 0; i < 7; i++)
		{

			for (int j = 0; j < 7; j++)
			{

				if (i == 0 || i == 1 || i == 2)
				{
					if (j == 2 || j == 3 || j == 6)
						character[i][j] = ' ';
					else
						character[i][j] = 'Y';
				}

				if (i == 3)
				{
					if (j == 0 || j == 5 || j == 6)
						character[i][j] = ' ';
					else
						character[i][j] = 'Y';
				}

				if (i > 3)
				{
					if (j == 2 || j == 3)
						character[i][j] = 'Y';
					else
						character[i][j] = ' ';
				}
			}
		}
		return character;
	}

	char **Z()
	{
		char **character = getCharGrid();
		for (int i = 0; i < 7; i++)
		{
			for (int j = 0; j < 7; j++)
			{
				if (i == 0 || i == 6)
				{
					if (j > 0)
						character[i][j] = 'Z';
					else
						character[i][j] = ' ';
				}

				if (i == 1)
				{
					if (j == 5 || j == 6)
						character[i][j] = 'Z';
					else
						character[i][j] = ' ';
				}

				if (i == 2)
				{
					if (j == 4 || j == 5)
						character[i][j] = 'Z';
					else
						character[i][j] = ' ';
				}
				if (i == 3)
				{
					if (j == 3 || j == 4)
						character[i][j] = 'Z';
					else
						character[i][j] = ' ';
				}
				if (i == 4)
				{
					if (j == 3 || j == 2)
						character[i][j] = 'Z';
					else
						character[i][j] = ' ';
				}
				if (i == 5)
				{
					if (j == 1 || j == 2)
						character[i][j] = 'Z';
					else
						character[i][j] = ' ';
				}
			}

			// cout<<endl;
		}
		return character;
	}
	// small letter
	char **a()
	{
		char **character = getCharGrid();
		for (int i = 0; i < 7; i++)
		{
			for (int j = 0; j < 7; j++)
			{
				if (i == 0)
				{
					if (j == 2 || j == 3 || j == 4)
						character[i][j] = '%';
					else
						character[i][j] = ' ';
				}

				if (i == 1)
				{
					if (j % 3 == 0)
					{
						character[i][j] = ' ';
					}
					else
						character[i][j] = '%';
				}

				if (i == 2 || i == 3 || i == 5 || i == 6)
				{
					if (j == 0 || j == 1 || j == 5 || j == 6)
					{
						character[i][j] = '%';
					}
					else
					{
						character[i][j] = ' ';
					}
				}

				if (i == 4)
				{

					character[i][j] = '%';
				}
			}
		}
		return character;
	}

	char **b()
	{
		char **character = getCharGrid();
		for (int i = 0; i < 7; i++)
		{
			for (int j = 0; j < 7; j++)
			{
				if (i == 0 || i == 6)
				{
					if (j == 5 || j == 6)
						character[i][j] = ' ';
					else
						character[i][j] = '%';
				}

				if (i >= 1 && i <= 5 && i != 3)
				{
					if (j == 2 || j == 3 || j == 4)
						character[i][j] = ' ';
					else
						character[i][j] = '%';
				}

				if (i == 3)
				{
					if (j == 6)
						character[i][j] = ' ';
					else
						character[i][j] = '%';
				}
			}
		}
		return character;
	}
	char **c()
	{
		char **character = getCharGrid();
		for (int i = 0; i < 7; i++)
		{
			for (int j = 0; j < 7; j++)
			{
				// first aur last line
				if (i == 0 || i == 6)
				{
					if ((j % 7) % 3 != 0)
					{
						character[i][j] = '%';
					}
					else
					{
						character[i][j] = ' ';
					}
				}

				// second nd second last line

				if (i == 1 || i == 5)
				{
					if (((j) % 7) < 2 || ((j) % 7) > 4)
					{
						character[i][j] = '%';
					}
					else
					{
						character[i][j] = ' ';
					}
				}

				// rest

				if (i == 2 || i == 4 || i == 3)
				{
					if (((j) % 7) < 2)
					{
						character[i][j] = '%';
					}
					else
					{
						character[i][j] = ' ';
					}
				}
			}
		}
		return character;
	}
	char **d()
	{
		char **character = getCharGrid();
		for (int i = 0; i < 7; i++)
		{
			for (int j = 0; j < 7; j++)
			{
				if (i == 0 || i == 6)
				{
					if (((j) % 7) != 0 && ((j) % 7) % 3 == 0)
						character[i][j] = ' ';
					else
						character[i][j] = '%';
				}
				else
				{
					if (((j) % 7) == 1 || ((j) % 7) == 2 || ((j) % 7) == 5 || ((j) % 7) == 6)
						character[i][j] = '%';
					else
						character[i][j] = ' ';
				}
			}
		}
		return character;
	}
	char **e()
	{
		char **character = getCharGrid();
		for (int i = 0; i < 7; i++)
		{
			for (int j = 0; j < 7; j++)
			{
				if (i == 0 || i == 6)
				{
					character[i][j] = '%';
				}

				if (i == 1 || i == 5)
				{
					if (j == 0 || j == 1 || j == 5 || j == 6)
						character[i][j] = '%';
					else
						character[i][j] = ' ';
				}

				if (i == 2 || i == 4)
				{
					if (j == 0 || j == 1)
						character[i][j] = '%';
					else
						character[i][j] = ' ';
				}

				if (i == 3)
				{
					if (j == 6)
						character[i][j] = ' ';
					else
						character[i][j] = '%';
				}
			}
		}
		return character;
	}

	char **f()
	{
		char **character = getCharGrid();
		for (int i = 0; i < 7; i++)
		{
			for (int j = 0; j < 7; j++)
			{
				if (i == 0)
				{
					character[i][j] = '%';
				}

				if (i == 2 || i == 5 || i == 6 || i == 1 || i == 4)
				{
					if (j == 0 || j == 1)
						character[i][j] = '%';
					else
						character[i][j] = ' ';
				}

				if (i == 3)
				{
					if (j == 6)
						character[i][j] = ' ';
					else
						character[i][j] = '%';
				}
			}

			// cout<<endl;
		}
		return character;
	}

	char **g()
	{
		char **character = getCharGrid();
		for (int i = 0; i < 7; i++)
		{
			for (int j = 0; j < 7; j++)
			{
				if (i == 0 || i == 6)
				{
					if (j == 0 || j == 6)
						character[i][j] = ' ';
					else
						character[i][j] = '%';
				}

				if (i == 1 || i == 5 || i == 4)
				{
					if (j == 0 || j == 1 || j == 5 || j == 6)
						character[i][j] = '%';
					else
						character[i][j] = ' ';
				}

				if (i == 3)
				{
					if (j == 2 || j == 3)
						character[i][j] = ' ';
					else
						character[i][j] = '%';
				}

				if (i == 2)
				{
					if (j == 0 || j == 1)
						character[i][j] = '%';
					else
						character[i][j] = ' ';
				}
			}
		}
		return character;
	}

	char **h()
	{
		char **character = getCharGrid();
		for (int i = 0; i < 7; i++)
		{
			for (int j = 0; j < 7; j++)
			{
				if (i >= 0 && i <= 6)
				{
					if (j == 0 || j == 1 || j == 5 || j == 6)
						character[i][j] = '%';
					else
						character[i][j] = ' ';
				}

				if (i == 3)
				{
					if (j > 1 && j < 5)
						character[i][j] = '%';
				}
			}
		}
		return character;
	}

	char **i()
	{
		char **character = getCharGrid();
		for (int i = 0; i < 7; i++)
		{
			for (int j = 0; j < 7; j++)
			{
				if (i == 0 || i == 6)
				{
					character[i][j] = '%';
				}
				else
				{
					if (j == 2 || j == 3 || j == 4)
					{
						character[i][j] = '%';
					}
					else
						character[i][j] = ' ';
				}
			}
		}
		return character;
	}
	char **j()
	{
		char **character = getCharGrid();
		for (int i = 0; i < 7; i++)
		{
			for (int j = 0; j < 7; j++)
			{
				if (i == 0)
				{
					if (j < 3)
						character[i][j] = ' ';
					else
						character[i][j] = '%';
				}

				if (i == 1 || i == 2 || i == 3)
				{
					if (j == 4 || j == 5)
						character[i][j] = '%';
					else
						character[i][j] = ' ';
				}

				if (i == 4 || i == 5)
				{
					if (j == 2 || j == 3 || j == 6)
						character[i][j] = ' ';
					else
						character[i][j] = '%';
				}

				if (i == 6)
				{
					if (j == 0 || j == 5 || j == 6)
						character[i][j] = ' ';
					else
						character[i][j] = '%';
				}
			}
		}
		return character;
	}

	char **k()
	{
		char **character = getCharGrid();
		for (int i = 0; i < 7; i++)
		{
			for (int j = 0; j < 7; j++)
			{
				if (i == 0 || i == 6)
				{
					if (j == 2 || j == 3 || j == 4)
						character[i][j] = ' ';
					else
						character[i][j] = '%';
				}

				if (i == 1 || i == 5)
				{
					if (j == 2 || j == 3 || j == 6)
						character[i][j] = ' ';
					else
						character[i][j] = '%';
				}

				if (i == 3)
				{
					if (j == 4 || j == 5 || j == 6)
						character[i][j] = ' ';
					else
						character[i][j] = '%';
				}

				if (i == 2 || i == 4)
				{
					if (j == 2 || j == 5 || j == 6)
						character[i][j] = ' ';
					else
						character[i][j] = '%';
				}
			}
		}
		return character;
	}

	char **l()
	{
		char **character = getCharGrid();
		for (int i = 0; i < 7; i++)
		{
			for (int j = 0; j < 7; j++)
			{
				if (i < 6)
				{
					if (j == 0 || j == 1)
						character[i][j] = '%';
					else
						character[i][j] = ' ';
				}
				else
					character[i][j] = '%';
			}
		}
		return character;
	}

	char **m()
	{
		char **character = getCharGrid();
		for (int i = 0; i < 7; i++)
		{
			for (int j = 0; j < 7; j++)
			{
				if (i == 0)
				{
					if (j == 2 || j == 3 || j == 4)
						character[i][j] = ' ';
					else
						character[i][j] = '%';
				}

				if (i == 1)
				{
					if (j == 3)
					{
						character[i][j] = ' ';
					}
					else
						character[i][j] = '%';
				}

				if (i == 2)
				{
					character[i][j] = '%';
				}

				if (i == 3)
				{
					if (j == 2 || j == 4)
						character[i][j] = ' ';
					else
						character[i][j] = '%';
				}

				if (i >= 4 && i <= 6)
				{
					if (j == 2 || j == 3 || j == 4)
						character[i][j] = ' ';
					else
						character[i][j] = '%';
				}
			}
		}
		return character;
	}

	char **n()
	{
		char **character = getCharGrid();
		for (int i = 0; i < 7; i++)
		{
			for (int j = 0; j < 7; j++)
			{
				if (i == 0 || i == 6)
				{
					if (j == 2 || j == 3 || j == 4)
						character[i][j] = ' ';
					else
						character[i][j] = '%';
				}

				if (i == 2 || i == 1)
				{
					if (j == 3 || j == 4)
					{
						character[i][j] = ' ';
					}
					else
						character[i][j] = '%';
				}

				if (i == 3)
				{
					if (j == 2 || j == 4)
					{
						character[i][j] = ' ';
					}
					else
					{
						character[i][j] = '%';
					}
				}

				if (i == 4 || i == 5)
				{
					if (j == 2 || j == 3)
						character[i][j] = ' ';
					else
						character[i][j] = '%';
				}
			}
		}
		return character;
	}
	char **o()
	{
		char **character = getCharGrid();
		for (int i = 0; i < 7; i++)
		{
			for (int j = 0; j < 7; j++)
			{
				if (i == 6 || i == 0)
				{
					if (j == 0 || j == 6)
						character[i][j] = ' ';
					else
						character[i][j] = '%';
				}
				else
				{
					if (j == 2 || j == 3 || j == 4)
						character[i][j] = ' ';
					else
						character[i][j] = '%';
				}
			}

			//	cout<<endl;
		}
		return character;
	}

	char **p()
	{
		char **character = getCharGrid();
		for (int i = 0; i < 7; i++)
		{
			for (int j = 0; j < 7; j++)
			{
				if (i == 0 || i == 3)
				{
					if (j == 6)
						character[i][j] = ' ';
					else
						character[i][j] = '%';
				}

				if (i == 1 || i == 2)
				{
					if (j == 2 || j == 3 || j == 4)
					{
						character[i][j] = ' ';
					}
					else
						character[i][j] = '%';
				}

				if (i >= 4 && i <= 6)
				{
					if (j == 0 || j == 1)
					{
						character[i][j] = '%';
					}
					else
					{
						character[i][j] = ' ';
					}
				}
			}
		}
		return character;
	}

	char **q()
	{
		char **character = getCharGrid();
		for (int i = 0; i < 7; i++)
		{
			for (int j = 0; j < 7; j++)
			{
				if (i == 0)
				{
					if (j % 3 == 0)
						character[i][j] = ' ';
					else
						character[i][j] = '%';
				}

				if (i >= 1 && i <= 4)
				{
					if (j == 2 || j == 3 || j == 4)
						character[i][j] = ' ';
					else
						character[i][j] = '%';
				}

				if (i == 5)
				{
					if (j == 2 || j == 3 || j == 6)
						character[i][j] = ' ';
					else
						character[i][j] = '%';
				}
				if (i == 6)
				{
					if (j == 0 || j == 3 || j == 4)
						character[i][j] = ' ';
					else
						character[i][j] = '%';
				}
			}

			// cout<<endl;
		}
		return character;
	}

	char **r()
	{
		char **character = getCharGrid();
		for (int i = 0; i < 7; i++)
		{
			for (int j = 0; j < 7; j++)
			{
				if (i == 0 || i == 3)
				{
					if (j == 6)
						character[i][j] = ' ';
					else
						character[i][j] = '%';
				}

				if (i == 1 || i == 2 || i == 5 || i == 6)
				{
					if (j == 2 || j == 3 || j == 4)
						character[i][j] = ' ';
					else
						character[i][j] = '%';
				}

				if (i == 4)
				{
					if (j == 2 || j == 3 || j == 6)
						character[i][j] = ' ';
					else
						character[i][j] = '%';
				}
			}
			// cout<<endl;
		}
		return character;
	}

	char **s()
	{
		char **character = getCharGrid();
		for (int i = 0; i < 7; i++)
		{
			for (int j = 0; j < 7; j++)
			{
				if (i == 0 || i == 6)
				{
					if (j == 0 || j == 6)
						character[i][j] = ' ';
					else
						character[i][j] = '%';
				}

				if (i == 1 || i == 5)
				{
					if (j == 3 || j == 2 || j == 4)
					{
						character[i][j] = ' ';
					}
					else
						character[i][j] = '%';
				}

				if (i == 2)
				{
					if (j == 4 || j == 5 || j == 6)
					{
						character[i][j] = ' ';
					}
					else
					{
						character[i][j] = '%';
					}
				}

				if (i == 3)
				{

					if (j == 0 || j == 6)
						character[i][j] = ' ';
					else
						character[i][j] = '%';
				}

				if (i == 4)
				{
					if (j == 4 || j == 5 || j == 6)
						character[i][j] = '%';
					else
						character[i][j] = ' ';
				}
			}
		}
		return character;
	}

	char **t()
	{
		char **character = getCharGrid();
		for (int i = 0; i < 7; i++)
		{
			for (int j = 0; j < 7; j++)
			{
				if (i == 0)
				{
					character[i][j] = '%';
				}

				if (i >= 1 && i <= 6)
				{
					if (j == 3 || j == 2)
						character[i][j] = '%';
					else
						character[i][j] = ' ';
				}
			}

			// cout<<endl;
		}
		return character;
	}

	char **u()
	{
		char **character = getCharGrid();
		for (int i = 0; i < 7; i++)
		{
			for (int j = 0; j < 7; j++)
			{
				if (i <= 5)
				{
					if (j == 2 || j == 3 || j == 4)
						character[i][j] = ' ';
					else
						character[i][j] = '%';
				}
				else
				{
					if (j == 0 || j == 6)
					{
						character[i][j] = ' ';
					}
					else
						character[i][j] = '%';
				}
			}
		}
		return character;
	}

	char **v()
	{
		char **character = getCharGrid();
		for (int i = 0; i < 7; i++)
		{
			for (int j = 0; j < 7; j++)
			{
				if (i == 6)
				{
					if (j == 2 || j == 3 || j == 4)
						character[i][j] = '%';
					else
						character[i][j] = ' ';
				}

				if (i == 5)
				{
					if (j % 3 == 0)
					{
						character[i][j] = ' ';
					}
					else
						character[i][j] = '%';
				}
				if (i < 5)
				{
					if (j == 0 || j == 1 || j == 5 || j == 6)
					{
						character[i][j] = '%';
					}
					else
					{
						character[i][j] = ' ';
					}
				}
			}
		}
		return character;
	}

	char **w()
	{
		char **character = getCharGrid();
		for (int i = 0; i < 7; i++)
		{
			for (int j = 0; j < 7; j++)
			{
				if (i == 0 || i == 1 || i == 2 || i == 6)
				{
					if (j == 2 || j == 3 || j == 4)
						character[i][j] = ' ';
					else
						character[i][j] = '%';
				}

				if (i == 3)
				{
					if (j == 2 || j == 4)
						character[i][j] = ' ';
					else
						character[i][j] = '%';
				}

				if (i == 4)
				{
					character[i][j] = '%';
				}

				if (i == 5)
				{
					if (j == 3)
						character[i][j] = ' ';
					else
						character[i][j] = '%';
				}
			}

			// cout<<endl;
		}
		return character;
	}

	char **x()
	{
		char **character = getCharGrid();
		for (int i = 0; i < 7; i++)
		{
			for (int j = 0; j < 7; j++)
			{
				if (i == 0 || i == 1 || i == 5 || i == 6)
				{
					if (j == 2 || j == 3 || j == 6)
						character[i][j] = ' ';
					else
						character[i][j] = '%';
				}

				if (i == 2 || i == 4)
				{
					if (j == 0 || j == 5 || j == 6)
						character[i][j] = ' ';
					else
						character[i][j] = '%';
				}

				if (i == 3)
				{
					if (j == 3 || j == 2)
						character[i][j] = '%';
					else
						character[i][j] = ' ';
				}
			}
		}
		return character;
	}
	char **y()
	{
		char **character = getCharGrid();
		for (int i = 0; i < 7; i++)
		{

			for (int j = 0; j < 7; j++)
			{

				if (i == 0 || i == 1 || i == 2)
				{
					if (j == 2 || j == 3 || j == 6)
						character[i][j] = ' ';
					else
						character[i][j] = '%';
				}

				if (i == 3)
				{
					if (j == 0 || j == 5 || j == 6)
						character[i][j] = ' ';
					else
						character[i][j] = '%';
				}

				if (i > 3)
				{
					if (j == 2 || j == 3)
						character[i][j] = '%';
					else
						character[i][j] = ' ';
				}
			}
		}
		return character;
	}

	char **z()
	{
		char **character = getCharGrid();
		for (int i = 0; i < 7; i++)
		{
			for (int j = 0; j < 7; j++)
			{
				if (i == 0 || i == 6)
				{
					if (j > 0)
						character[i][j] = '%';
					else
						character[i][j] = ' ';
				}

				if (i == 1)
				{
					if (j == 5 || j == 6)
						character[i][j] = '%';
					else
						character[i][j] = ' ';
				}

				if (i == 2)
				{
					if (j == 4 || j == 5)
						character[i][j] = '%';
					else
						character[i][j] = ' ';
				}
				if (i == 3)
				{
					if (j == 3 || j == 4)
						character[i][j] = '%';
					else
						character[i][j] = ' ';
				}
				if (i == 4)
				{
					if (j == 3 || j == 2)
						character[i][j] = '%';
					else
						character[i][j] = ' ';
				}
				if (i == 5)
				{
					if (j == 1 || j == 2)
						character[i][j] = '%';
					else
						character[i][j] = ' ';
				}
			}

			// cout<<endl;
		}
		return character;
	}

	// digits
	char **zero()
	{
		char code='#';
		char **character = getCharGrid();
		for (int i = 0; i < 7; i++)
		{
			for (int j = 0; j < 7; j++)
			{
				if (i == 0 || i == 6)
				{
					if (j == 1 || j == 2 || j == 4 || j == 5)
						character[i][j] = code;
					else
						character[i][j] = ' ';
				}
				if (i == 1 || i == 5)
				{
					if (j == 0 || j == 1 || j == 5 || j == 6)
						character[i][j] = code;
					else
						character[i][j] = ' ';
				}
				if (i == 2)
				{
					if (j == 0 || j == 1 || j == 4 || j == 5 || j == 6)
						character[i][j] = code;
					else
						character[i][j] = ' ';
				}
				if (i == 3)
				{
					if (j == 0 || j == 1 || j == 3 || j == 5 || j == 6)
						character[i][j] = code;
					else
						character[i][j] = ' ';
				}
				if (i == 4)
				{
					if (j == 0 || j == 1 || j == 2 || j == 5 || j == 6)
						character[i][j] = code;
					else
						character[i][j] = ' ';
				}
			}
		}
		return character;
	}

	char **one()
	{
		char code='#';//'1';
		char **character = getCharGrid();
		for (int i = 0; i < 7; i++)
		{
			for (int j = 0; j < 7; j++)
			{
				if (i == 0 || i == 2 || i == 3 || i == 4 || i == 5)
				{
					if (j == 2 || j == 3)
						character[i][j] = code;
					else
						character[i][j] = ' ';
				}
				if (i == 1)
				{
					if (j == 1 || j == 2 || j == 3)
						character[i][j] = code;
					else
						character[i][j] = ' ';
				}
				if (i == 6)
				{
					if (j == 1 || j == 2 || j == 3 || j == 4)
						character[i][j] = code;
					else
						character[i][j] = ' ';
				}
			}
		}
		return character;
	}
	char **two()
	{
		char code='#';//'2';
		char **character = getCharGrid();
		for (int i = 0; i < 7; i++)
		{
			for (int j = 0; j < 7; j++)
			{
				if (i == 0)
				{
					if (j == 0 || j == 1 || j == 3 || j == 4)
						character[i][j] = code;
					else
						character[i][j] = ' ';
				}
				if (i == 1)
				{
					if (j == 0 || j == 1 || j == 4 || j == 5)
						character[i][j] = code;
					else
						character[i][j] = ' ';
				}
				if (i == 2)
				{
					if (j == 4 || j == 5)
						character[i][j] = code;
					else
						character[i][j] = ' ';
				}
				if (i == 3)
				{
					if (j == 3 || j == 4)
						character[i][j] = code;
					else
						character[i][j] = ' ';
				}
				if (i == 4)
				{
					if (j == 2 || j == 3)
						character[i][j] = code;
					else
						character[i][j] = ' ';
				}
				if (i == 5)
				{
					if (j == 1 || j == 5 || j == 6)
						character[i][j] = code;
					else
						character[i][j] = ' ';
				}
				if (i == 6)
				{
					if (j == 0 || j == 1 || j == 2 || j == 3 || j == 4 || j == 5)
						character[i][j] = code;
					else
						character[i][j] = ' ';
				}
			}
		}
		return character;
	}

	char **three()
	{
		char code='#';//'3';
		char **character = getCharGrid();
		for (int i = 0; i < 7; i++)
		{
			for (int j = 0; j < 7; j++)
			{
				if (i == 0 || i == 6)
				{
					if (j == 1 || j == 2 || j == 4 || j == 5)
						character[i][j] = code;
					else
						character[i][j] = ' ';
				}
				if (i == 1 || i == 5)
				{
					if (j == 0 || j == 1 || j == 5 || j == 6)
						character[i][j] = code;
					else
						character[i][j] = ' ';
				}
				if (i == 2 || i == 4)
				{
					if (j == 5 || j == 6)
						character[i][j] = code;
					else
						character[i][j] = ' ';
				}
				if (i == 3)
				{
					if (j == 3 || j == 4 || j == 5)
						character[i][j] = code;
					else
						character[i][j] = ' ';
				}
			}
		}
		return character;
	}

	char **four()
	{
		char code='#';//'4';
		char **character = getCharGrid();
		for (int i = 0; i < 7; i++)
		{
			for (int j = 0; j < 7; j++)
			{
				if (i == 0 || i == 5 || i == 6)
				{
					if (j == 4 || j == 5)
						character[i][j] = code;
					else
						character[i][j] = ' ';
				}
				if (i == 1)
				{
					if (j == 2 || j == 4 || j == 5)
						character[i][j] = code;
					else
						character[i][j] = ' ';
				}
				if (i == 2)
				{
					if (j == 1 || j == 2 || j == 4 || j == 5)
						character[i][j] = code;
					else
						character[i][j] = ' ';
				}
				if (i == 3)
				{
					if (j == 0 || j == 1 || j == 4 || j == 5)
						character[i][j] = code;
					else
						character[i][j] = ' ';
				}
				if (i == 4)
				{
					if (j == 0 || j == 1 || j == 2 || j == 4 || j == 5 || j == 6)
						character[i][j] = code;
					else
						character[i][j] = ' ';
				}
			}
		}
		return character;
	}

	char **five()
	{
		char code='#';//'5';
		char **character = getCharGrid();
		for (int i = 0; i < 7; i++)
		{
			for (int j = 0; j < 7; j++)
			{
				if (i == 0)
				{
					if (j == 0 || j == 1 || j == 2 || j == 3 || j == 4 || j == 5)
						character[i][j] = code;
					else
						character[i][j] = ' ';
				}
				if (i == 1)
				{
					if (j == 0 || j == 1)
						character[i][j] = code;
					else
						character[i][j] = ' ';
				}
				if (i == 2)
				{
					if (j == 0 || j == 1 || j == 3 || j == 4)
						character[i][j] = code;
					else
						character[i][j] = ' ';
				}
				if (i == 3)
				{
					if (j == 4 || j == 5)
						character[i][j] = code;
					else
						character[i][j] = ' ';
				}
				if (i == 4 || i == 5)
				{
					if (j == 0 || j == 1 || j == 4 || j == 5)
						character[i][j] = code;
					else
						character[i][j] = ' ';
				}
				if (i == 6)
				{
					if (j == 2 || j == 3 || j == 4)
						character[i][j] = code;
					else
						character[i][j] = ' ';
				}
			}
		}
		return character;
	}

	char **six()
	{
		char code='#';//'6';//'6';
		char **character = getCharGrid();
		for (int i = 0; i < 7; i++)
		{
			for (int j = 0; j < 7; j++)
			{
				if (i == 0)
				{
					if (j == 1 || j == 2 || j == 4 || j == 5 || j == 6)
						character[i][j] = code;
					else
						character[i][j] = ' ';
				}
				if (i == 1 || i == 4 || i == 5)
				{
					if (j == 0 || j == 1 || j == 5 || j == 6)
						character[i][j] = code;
					else
						character[i][j] = ' ';
				}
				if (i == 2)
				{
					if (j == 0 || j == 1)
						character[i][j] = code;
					else
						character[i][j] = ' ';
				}
				if (i == 3)
				{
					if (j == 0 || j == 1 || j == 3 || j == 4 || j == 5)
						character[i][j] = code;
					else
						character[i][j] = ' ';
				}
				if (i == 6)
				{
					if (j == 1 || j == 2 || j == 4 || j == 5)
						character[i][j] = code;
					else
						character[i][j] = ' ';
				}
			}
		}
		return character;
	}

	char **seven()
	{
		char code='#';//'7';
		char **character = getCharGrid();
		for (int i = 0; i < 7; i++)
		{
			for (int j = 0; j < 7; j++)
			{
				if (i == 0)
				{
					if (j == 0 || j == 1 || j == 2 || j == 3 || j == 4 || j == 5)
						character[i][j] = code;
					else
						character[i][j] = ' ';
				}
				if (i == 1)
				{
					if (j == 0 || j == 1 || j == 5)
						character[i][j] = code;
					else
						character[i][j] = ' ';
				}
				if (i == 2)
				{
					if (j == 3 || j == 4)
						character[i][j] = code;
					else
						character[i][j] = ' ';
				}
				if (i == 3 || i == 4 || i == 5 || i == 6)
				{
					if (j == 2 || j == 3)
						character[i][j] = code;
					else
						character[i][j] = ' ';
				}
			}
		}
		return character;
	}

	char **eight()
	{
		char code='#';//'8';
		char **character = getCharGrid();
		for (int i = 0; i < 7; i++)
		{
			for (int j = 0; j < 7; j++)
			{
				if (i == 0 || i == 3 || i == 6)
				{
					if (j == 1 || j == 2 || j == 4 || j == 5)
						character[i][j] = code;
					else
						character[i][j] = ' ';
				}
				if (i == 1 || i == 2 || i == 4 || i == 5)
				{
					if (j == 0 || j == 1 || j == 5 || j == 6)
						character[i][j] = code;
					else
						character[i][j] = ' ';
				}
			}
		}
		return character;
	}

	char **nine()
	{
		char code='#';//'9';
		char **character = getCharGrid();
		for (int i = 0; i < 7; i++)
		{
			for (int j = 0; j < 7; j++)
			{
				if (i == 0 || i == 6)
				{
					if (j == 1 || j == 2 || j == 4 || j == 5)
						character[i][j] = code;
					else
						character[i][j] = ' ';
				}
				if (i == 1)
				{
					if (j == 1 || j == 5 || j == 6)
						character[i][j] = code;
					else
						character[i][j] = ' ';
				}
				if (i == 2)
				{
					if (j == 0 || j == 1 || j == 5 || j == 6)
						character[i][j] = code;
					else
						character[i][j] = ' ';
				}
				if (i == 3)
				{
					if (j == 1 || j == 2 || j == 4 || j == 5 || j == 6)
						character[i][j] = code;
					else
						character[i][j] = ' ';
				}
				if (i == 4)
				{
					if (j == 5 || j == 6)
						character[i][j] = code;
					else
						character[i][j] = ' ';
				}
				if (i == 5)
				{
					if (j == 0 || j == 1 || j == 5 || j == 6)
						character[i][j] = code;
					else
						character[i][j] = ' ';
				}
			}
		}
		return character;
	}

	 // for space
     char **space()
    {
        char **character = getCharGrid(1,1);

        character[0][0] = ' ';

        return character;
    }
};


namespace ascii
{

    class Ascii
    {

    public:
        Fonts *font;
        Ascii()
        {
            this->font = new SevenStar();
        }
        void print(const std::string &text)
        {

            char **character = 0;

            for (size_t i = 0; i < text.size(); i++)
            {
                char c = text[i];

                // Uppercase alphabets
                if (c == 'A')
                    character = font->A();
                else if (c == 'B')
                    character = font->B();
                else if (c == 'C')
                    character = font->C();
                else if (c == 'D')
                    character = font->D();
                else if (c == 'E')
                    character = font->E();
                else if (c == 'F')
                    character = font->F();
                else if (c == 'G')
                    character = font->G();
                else if (c == 'H')
                    character = font->H();
                else if (c == 'I')
                    character = font->I();
                else if (c == 'J')
                    character = font->J();
                else if (c == 'K')
                    character = font->K();
                else if (c == 'L')
                    character = font->L();
                else if (c == 'M')
                    character = font->M();
                else if (c == 'N')
                    character = font->N();
                else if (c == 'O')
                    character = font->O();
                else if (c == 'P')
                    character = font->P();
                else if (c == 'Q')
                    character = font->Q();
                else if (c == 'R')
                    character = font->R();
                else if (c == 'S')
                    character = font->S();
                else if (c == 'T')
                    character = font->T();
                else if (c == 'U')
                    character = font->U();
                else if (c == 'V')
                    character = font->V();
                else if (c == 'W')
                    character = font->W();
                else if (c == 'X')
                    character = font->X();
                else if (c == 'Y')
                    character = font->Y();
                else if (c == 'Z')
                    character = font->Z();

                // Lowercase alphabets
                else if (c == 'a')
                    character = font->a();
                else if (c == 'b')
                    character = font->b();
                else if (c == 'c')
                    character = font->c();
                else if (c == 'd')
                    character = font->d();
                else if (c == 'e')
                    character = font->e();
                else if (c == 'f')
                    character = font->f();
                else if (c == 'g')
                    character = font->g();
                else if (c == 'h')
                    character = font->h();
                else if (c == 'i')
                    character = font->i();
                else if (c == 'j')
                    character = font->j();
                else if (c == 'k')
                    character = font->k();
                else if (c == 'l')
                    character = font->l();
                else if (c == 'm')
                    character = font->m();
                else if (c == 'n')
                    character = font->n();
                else if (c == 'o')
                    character = font->o();
                else if (c == 'p')
                    character = font->p();
                else if (c == 'q')
                    character = font->q();
                else if (c == 'r')
                    character = font->r();
                else if (c == 's')
                    character = font->s();
                else if (c == 't')
                    character = font->t();
                else if (c == 'u')
                    character = font->u();
                else if (c == 'v')
                    character = font->v();
                else if (c == 'w')
                    character = font->w();
                else if (c == 'x')
                    character = font->x();
                else if (c == 'y')
                    character = font->y();
                else if (c == 'z')
                    character = font->z();

                // Numbers
                else if (c == '0')
                    character = font->zero();
                else if (c == '1')
                    character = font->one();
                else if (c == '2')
                    character = font->two();
                else if (c == '3')
                    character = font->three();
                else if (c == '4')
                    character = font->four();
                else if (c == '5')
                    character = font->five();
                else if (c == '6')
                    character = font->six();
                else if (c == '7')
                    character = font->seven();
                else if (c == '8')
                    character = font->eight();
                else if (c == '9')
                    character = font->nine();

                // for space
                else if (c == ' ')
                    character = font->space();

                font->pushChar(character);
            }
            font->printvector();
            // font->destroyspace();
        }
    };
} // namespace ascii

/// LICENSE_END.23


char* mymigliaia(int64_t i_bytes,char* i_buffer,int i_buffersize)
{
	if (i_buffer==NULL)
	{
		printf("02096: guru i_buffer null\n");
		exit(0);
	}
	if (i_buffersize<10)
	{
		printf("02106: guru buffer too small\n");
		exit(0);
	}
		if (i_bytes<0)
	{
		snprintf(i_buffer,10,"negative");
		return i_buffer;
	}

	char *p=&i_buffer[i_buffersize-1];
	unsigned int i=0;
	*p='\0';
	do
	{
		if ((i%3==0) && (i!=0))
			*--p='.';
		*--p='0'+i_bytes%10;
		i_bytes/=10;
		i++;
	} while(i_bytes!=0);
	return p;
}

/// very quick and very dirty output
inline char* migliaia(int64_t n)
{
	static char retbuf[30];
	return mymigliaia(n,retbuf,30);
}
inline char* migliaia2(int64_t n)
{
	static char retbuf[30];
	return mymigliaia(n,retbuf,30);
}
inline char* migliaia3(int64_t n)
{
	static char retbuf[30];
	return mymigliaia(n,retbuf,30);
}
inline char* migliaia4(int64_t n)
{
	static char retbuf[30];
	return mymigliaia(n,retbuf,30);
}
inline char* migliaia5(int64_t n)
{
	static char retbuf[30];
	return mymigliaia(n,retbuf,30);
}
inline char* migliaia6(int64_t n)
{
	static char retbuf[30];
	return mymigliaia(n,retbuf,30);
}

/// LICENSE_START.7
/// OK we need a fix for 64-byte-align problem on some Linux compiler
/*
https://github.com/embeddedartistry/embedded-resources/blob/master/examples/c/malloc_aligned.c
*/
#ifndef align_up
#define align_up(num, align) \
	(((num) + ((align) - 1)) & ~((align) - 1))
#endif // corresponds to #ifndef (#ifndef align_up)
//Convenience macro for memalign, the linux API
///#define memalign(align, size) aligned_malloc(align, size)
//Number of bytes we're using for storing the aligned pointer offset
typedef uint16_t myoffset_t;
#define PTR_OFFSET_SZ sizeof(myoffset_t)
/**
* aligned_malloc takes in the requested alignment and size
*	We will call malloc with extra bytes for our header and the offset
*	required to guarantee the desired alignment.
*   Some fix by me (better error handling)
*/
void * aligned_malloc(size_t align, size_t size)
{
	void * ptr = NULL;
	//We want it to be a power of two since align_up operates on powers of two
///	assert((align & (align - 1)) == 0);
	if ((align & (align - 1)) != 0 || align < sizeof(void*)) 
        return NULL;
	
	if(align && size)
	{
		/*
		 * We know we have to fit an offset value
		 * We also allocate extra bytes to ensure we can meet the alignment
		 */
		uint32_t hdr_size = PTR_OFFSET_SZ + (align - 1);
		void * p = malloc(size + hdr_size);
		if(p)
		{
			/*
			 * Add the offset size to malloc's pointer (we will always store that)
			 * Then align the resulting value to the arget alignment
			 */
			ptr = (void *) align_up(((uintptr_t)p + PTR_OFFSET_SZ), align);

			//Calculate the offset and store it behind our aligned pointer
			///*((myoffset_t *)ptr - 1) = (myoffset_t)((uintptr_t)ptr - (uintptr_t)p);
			
			if (ptr)
            {
                // Calculate the offset and store it
                *((myoffset_t *)ptr - 1) = (myoffset_t)((uintptr_t)ptr - (uintptr_t)p);
            }
            else
            {
                // If the pointer calculation fails, free the memory
                free(p);
                return NULL;
            }
			
		} // else NULL, could not malloc
		else
		{
			return NULL;
		}
	} //else NULL, invalid arguments
	return ptr;
}
/**
* aligned_free works like free(), but we work backwards from the returned
* pointer to find the correct offset and pointer location to return to free()
* Note that it is VERY BAD to call free() on an aligned_malloc() pointer.
*/
void aligned_free(void * ptr)
{
	///return;
	if (flagdebug5)
		myprintf("72252: aligned_free [1]\n");
	
	if (!ptr) return;
	if (flagdebug5)
		myprintf("72254: aligned_free [2]\n");
	
	//assert(ptr);
	/*
	* Walk backwards from the passed-in pointer to get the pointer offset
	* We convert to an offset_t pointer and rely on pointer math to get the data
	*/
	myoffset_t offset = *((myoffset_t *)ptr - 1);
	if (flagdebug5)
		myprintf("72255: aligned_free [3]\n");
	/*
	* Once we have the offset, we can get our original pointer and call free
	*/
	void * p = (void *)((uint8_t *)ptr - offset);
#ifndef ESX
	if (flagdebug5)
		myprintf("72256: aligned_free [4] ptr %s  offset %s voidp %s\n",migliaia(int64_t(ptr)),migliaia2(int64_t(offset)),migliaia3(int64_t(p)));
#endif
	free(p);
	if (flagdebug5)
		myprintf("72257: aligned_free [5]\n");
}
/// LICENSE_END.7


/*
	Let's try to force align everywhere, on some kind of "choosy" CPUs
	I do not have such kind of iron, just a try...
*/
static void* franz_malloc(size_t i_size)
{
	if  (i_size==0)
	{
		myprintf("06112: franz_malloc i_size zero!\n");
		exit(0);
	}
	 void* ptr;
#ifdef MALLOC_ALIGN
    ptr = aligned_malloc(MALLOC_ALIGN, i_size);
#else
    ptr = malloc(i_size);
#endif
    if (ptr) 
        g_allocatedram += i_size; // Increment only if the allocation was successful
    return ptr;
}

static void franz_free(void* i_mem)
{
	if (i_mem==NULL)
		return;
#ifdef MALLOC_ALIGN
	aligned_free(i_mem);
#else
	free(i_mem);
#endif // corresponds to #ifdef (#ifdef MALLOC_ALIGN)
}

static void* franz_extend(void* i_mem,size_t i_size,size_t i_oldsize)
{
#ifdef MALLOC_ALIGN
    void *new_mem;
	if (i_size==0)
	{
		printf("01200: realloc i_size == 0\n");
		franz_free(i_mem);
		return NULL;
	}
    if (!i_mem)
	{
		printf("01205: realloc from empty, allocating %08d\n",(int)i_size);
        return franz_malloc(i_size);
	}
	if (i_oldsize<i_size)
	{
		if (flagdebug)
			myprintf("01211: realloc from %08d to %08d\n",(int)i_oldsize,(int)i_size);
        new_mem=franz_malloc(i_size);
        if (new_mem==NULL)
			return NULL;
		memcpy(new_mem,i_mem,i_oldsize);
		franz_free(i_mem);
		g_allocatedram-=i_oldsize;
		return new_mem;
	}
	printf("01219: realloc smaller, do nothing\n");
	return i_mem;
#else
	if (i_oldsize>0)
		i_oldsize++; /// compiler be quiet!
	g_allocatedram+=i_size;
	g_allocatedram-=i_oldsize;
	return realloc(i_mem,i_size);
#endif // corresponds to #ifdef (#ifdef MALLOC_ALIGN)
}

#ifdef ANCIENT
std::string my_tostring(uint64_t value) 
{
    char buffer[32]; // Sufficiente per uint64_t (max 20 cifre + null)
    snprintf(buffer, sizeof(buffer), "%llu", (unsigned long long)value);
    return std::string(buffer);
}
#endif

std::string myulltoa(uint64_t value, int i_len) 
{
    if (i_len > 19) 
	    i_len = 19;
#ifdef ANCIENT
    std::string result = my_tostring(value);
#else
    std::string result = std::to_string(value);
#endif
    if (i_len > 0 && result.size() < static_cast<size_t>(i_len)) 
	    result = std::string(i_len - result.size(), '0') + result;
    return result;
}

std::string bin2hex_32(uint32_t i_thenumber)
{
    static const char dec2hex[16+1] = "0123456789ABCDEF";
	char buf[16+1]; ///yep, a bit large
	uint8_t numerino;
	for (int j=3;j>=0;j--)
	{
		numerino=i_thenumber&255;
		buf[j*2+1]	=dec2hex[numerino&15];
		buf[j*2]	=dec2hex[(numerino>>4)&15];
		i_thenumber>>=8;
	}
	buf[8]=0;
	return buf;
}

std::string bin2hex_64(uint64_t i_thenumber)
{
    static const char dec2hex[16+1] = "0123456789ABCDEF";
	char buf[16+1];
	uint8_t numerino;
	for (int j=7;j>=0;j--)
	{
		numerino=i_thenumber&255;
		buf[j*2+1]	=dec2hex[numerino&15];
		buf[j*2]	=dec2hex[(numerino>>4)&15];
		i_thenumber>>=8;
	}
	buf[16]=0;
	return buf;
}

std::string bin2hex_128(uint64_t i_high,uint64_t i_low)
{
	std::string shigh=bin2hex_64(i_high);
	std::string slow	=bin2hex_64(i_low);
	return shigh+slow;
}






#ifdef _WIN32
/// LICENSE_START.22

/// A "stripped" LZ4 

#define LZ4_ACCELERATION_DEFAULT 1
#define LZ4_ACCELERATION_MAX 65537
#define LZ4_MEMORY_USAGE_DEFAULT 14 /// 16KB
#define LZ4_MEMORY_USAGE LZ4_MEMORY_USAGE_DEFAULT
#define LZ4_MAX_INPUT_SIZE        0x7E000000   /* 2 113 929 216 bytes */
#define LZ4_COMPRESSBOUND(isize)  ((unsigned)(isize) > (unsigned)LZ4_MAX_INPUT_SIZE ? 0 : (isize) + ((isize)/255) + 16)
#define LZ4_DECODER_RING_BUFFER_SIZE(maxBlockSize) (65536 + 14 + (maxBlockSize))  /* for static allocation; maxBlockSize presumed valid */
#define LZ4_DECOMPRESS_INPLACE_MARGIN(compressedSize)          (((compressedSize) >> 8) + 32)
#define LZ4_DECOMPRESS_INPLACE_BUFFER_SIZE(decompressedSize)   ((decompressedSize) + LZ4_DECOMPRESS_INPLACE_MARGIN(decompressedSize))  /**< note: presumes that compressedSize < decompressedSize. note2: margin is overestimated a bit, since it could use compressedSize instead */
#define LZ4_DISTANCE_MAX 65535   /* set to maximum value by default */
#define LZ4_COMPRESS_INPLACE_MARGIN                           (LZ4_DISTANCE_MAX + 32)   /* LZ4_DISTANCE_MAX can be safely replaced by srcSize when it's smaller */
#define LZ4_COMPRESS_INPLACE_BUFFER_SIZE(maxCompressedSize)   ((maxCompressedSize) + LZ4_COMPRESS_INPLACE_MARGIN)  /**< maxCompressedSize is generally LZ4_COMPRESSBOUND(inputSize), but can be set to any lower value, with the risk that compression can fail (return code 0(zero)) */
#define LZ4_HASHLOG   (LZ4_MEMORY_USAGE-2)
#define LZ4_HASH_SIZE_U32 (1 << LZ4_HASHLOG)       /* required as macro for static allocation */
#define LZ4_FORCE_O2
#define LZ4_ALIGN_TEST 1
#define LZ4_STREAMDECODE_MINSIZE 32
#define LZ4_STREAM_MINSIZE  ((1UL << (LZ4_MEMORY_USAGE)) + 32)  /* static size, for inter-version compatibility */

#define MINMATCH 4
#define WILDCOPYLENGTH 8
#define LASTLITERALS   5   /* see ../doc/lz4_Block_format.md#parsing-restrictions */
#define MFLIMIT       12   /* see ../doc/lz4_Block_format.md#parsing-restrictions */
#define MATCH_SAFEGUARD_DISTANCE  ((2*WILDCOPYLENGTH) - MINMATCH)   /* ensure it's possible to write 2 x wildcopyLength without overflowing output buffer */
#define FASTLOOP_SAFE_DISTANCE 64
static const int LZ4_minLength = (MFLIMIT+1);

#define KB *(1 <<10)
#define MB *(1 <<20)
#define GB *(1U<<30)

#define LZ4_DISTANCE_ABSOLUTE_MAX 65535

#define ML_BITS  4
#define ML_MASK  ((1U<<ML_BITS)-1)
#define RUN_BITS (8-ML_BITS)
#define RUN_MASK ((1U<<RUN_BITS)-1)

#define LZ4_STATIC_ASSERT(c)   { enum { LZ4_static_assert = 1/(int)(!!(c)) }; }   /* use after variable declarations */
#define DEBUGLOG(l, ...) {}    /* disabled */


typedef union LZ4_stream_u LZ4_stream_t;  /* incomplete type (defined later) */
typedef union LZ4_streamDecode_u LZ4_streamDecode_t;   /* tracking context */
typedef  int8_t  LZ4_i8;
typedef uint8_t  LZ4_byte;
typedef uint16_t LZ4_u16;
typedef uint32_t LZ4_u32;

int LZ4_compress_fast (const char* src, char* dst, int srcSize, int dstCapacity, int acceleration);
int LZ4_compress_fast_continue (LZ4_stream_t* streamPtr, const char* src, char* dst, int srcSize, int dstCapacity, int acceleration);
int LZ4_decompress_safe (const char* src, char* dst, int compressedSize, int dstCapacity);
int LZ4_decompress_safe_continue (LZ4_streamDecode_t* LZ4_streamDecode,
                        const char* src, char* dst,
                        int srcSize, int dstCapacity);


typedef struct LZ4_stream_t_internal LZ4_stream_t_internal;
struct LZ4_stream_t_internal {
    LZ4_u32 hashTable[LZ4_HASH_SIZE_U32];
    const LZ4_byte* dictionary;
    const LZ4_stream_t_internal* dictCtx;
    LZ4_u32 currentOffset;
    LZ4_u32 tableType;
    LZ4_u32 dictSize;
    /* Implicit padding to ensure structure is aligned */
};

union LZ4_stream_u {
    char minStateSize[LZ4_STREAM_MINSIZE];
    LZ4_stream_t_internal internal_donotuse;
}; /* previously typedef'd to LZ4_stream_t */

LZ4_stream_t* LZ4_initStream (void* buffer, size_t size);

typedef struct {
    const LZ4_byte* externalDict;
    const LZ4_byte* prefixEnd;
    size_t extDictSize;
    size_t prefixSize;
} LZ4_streamDecode_t_internal;


union LZ4_streamDecode_u {
    char minStateSize[LZ4_STREAMDECODE_MINSIZE];
    LZ4_streamDecode_t_internal internal_donotuse;
} ;   /* previously typedef'd to LZ4_streamDecode_t */


#ifndef LZ4_FORCE_INLINE
#  ifdef _MSC_VER    /* Visual Studio */
#    define LZ4_FORCE_INLINE static __forceinline
#  else
#    if defined (__cplusplus) || defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L   /* C99 */
#      ifdef __GNUC__
#        define LZ4_FORCE_INLINE static inline __attribute__((always_inline))
#      else
#        define LZ4_FORCE_INLINE static inline
#      endif
#    else
#      define LZ4_FORCE_INLINE static
#    endif /* __STDC_VERSION__ */
#  endif  /* _MSC_VER */
#endif /* LZ4_FORCE_INLINE */ // corresponds to #ifndef (#ifndef LZ4_FORCE_INLINE)


#if (defined(__GNUC__) && (__GNUC__ >= 3)) || (defined(__INTEL_COMPILER) && (__INTEL_COMPILER >= 800)) || defined(__clang__)
#  define expect(expr,value)    (__builtin_expect ((expr),(value)) )
#else
#  define expect(expr,value)    (expr)
#endif // corresponds to #if (#if (defined(__GNUC__) && (__GNUC__ >= 3)) || (defined(__INTEL_COMPILER) && (__INTEL_COMPILER >= 800)) || defined(__clang__))

#ifndef likely
#define likely(expr)     expect((expr) != 0, 1)
#endif // corresponds to #ifndef (#ifndef likely)
#ifndef unlikely
#define unlikely(expr)   expect((expr) != 0, 0)
#endif // corresponds to #ifndef (#ifndef unlikely)

#define ALLOC(s)          malloc(s)
#define ALLOC_AND_ZERO(s) calloc(1,s)
#define FREEMEM(p)        free(p)
#define LZ4_memset(p,v,s) memset((p),(v),(s))
#define MEM_INIT(p,v,s)   LZ4_memset((p),(v),(s))


static int LZ4_isAligned(const void* ptr, size_t alignment)
{
    return ((size_t)ptr & (alignment -1)) == 0;
}

typedef  uint8_t BYTE;
typedef uint16_t U16;
typedef uint32_t U32;
typedef  int32_t S32;
typedef uint64_t U64;
typedef uintptr_t uptrval;

#if defined(__x86_64__)
  typedef U64    reg_t;   /* 64-bits in x32 mode */
#else
  typedef size_t reg_t;   /* 32-bits in x32 mode */
#endif // corresponds to #if (#if defined(__x86_64__))

typedef enum {
    notLimited = 0,
    limitedOutput = 1,
    fillOutput = 2
} limitedOutput_directive;


#if !defined(LZ4_memcpy)
#  if defined(__GNUC__) && (__GNUC__ >= 4)
#    define LZ4_memcpy(dst, src, size) __builtin_memcpy(dst, src, size)
#  else
#    define LZ4_memcpy(dst, src, size) memcpy(dst, src, size)
#  endif
#endif // corresponds to #if (#if !defined(LZ4_memcpy))

#if !defined(LZ4_memmove)
#  if defined(__GNUC__) && (__GNUC__ >= 4)
#    define LZ4_memmove __builtin_memmove
#  else
#    define LZ4_memmove memmove
#  endif
#endif // corresponds to #if (#if !defined(LZ4_memmove))

static unsigned LZ4_isLittleEndian(void)
{
	return 1;
	
    ///const union { U32 u; BYTE c[4]; } one = { 1 };   /* don't use static : performance detrimental */
    ///return one.c[0];
}

#if defined(__GNUC__) || defined(__INTEL_COMPILER)
#define LZ4_PACK( __Declaration__ ) __Declaration__ __attribute__((__packed__))
#elif defined(_MSC_VER)
#define LZ4_PACK( __Declaration__ ) __pragma( pack(push, 1) ) __Declaration__ __pragma( pack(pop))
#endif // corresponds to #if (#if defined(__GNUC__) || defined(__INTEL_COMPILER))

LZ4_PACK(typedef struct { U16 u16; }) LZ4_unalign16;
LZ4_PACK(typedef struct { U32 u32; }) LZ4_unalign32;
LZ4_PACK(typedef struct { reg_t uArch; }) LZ4_unalignST;

static U16 LZ4_read16(const void* ptr) { return ((const LZ4_unalign16*)ptr)->u16; }
static U32 LZ4_read32(const void* ptr) { return ((const LZ4_unalign32*)ptr)->u32; }
static reg_t LZ4_read_ARCH(const void* ptr) { return ((const LZ4_unalignST*)ptr)->uArch; }

static void LZ4_write16(void* memPtr, U16 value) { ((LZ4_unalign16*)memPtr)->u16 = value; }
static void LZ4_write32(void* memPtr, U32 value) { ((LZ4_unalign32*)memPtr)->u32 = value; }



static U16 LZ4_readLE16(const void* memPtr)
{
    if (LZ4_isLittleEndian()) {
        return LZ4_read16(memPtr);
    } else {
        const BYTE* p = (const BYTE*)memPtr;
        return (U16)((U16)p[0] + (p[1]<<8));
    }
}

static void LZ4_writeLE16(void* memPtr, U16 value)
{
    if (LZ4_isLittleEndian()) {
        LZ4_write16(memPtr, value);
    } else {
        BYTE* p = (BYTE*)memPtr;
        p[0] = (BYTE) value;
        p[1] = (BYTE)(value>>8);
    }
}

/* customized variant of memcpy, which can overwrite up to 8 bytes beyond dstEnd */
LZ4_FORCE_INLINE
void LZ4_wildCopy8(void* dstPtr, const void* srcPtr, void* dstEnd)
{
    BYTE* d = (BYTE*)dstPtr;
    const BYTE* s = (const BYTE*)srcPtr;
    BYTE* const e = (BYTE*)dstEnd;

    do { LZ4_memcpy(d,s,8); d+=8; s+=8; } while (d<e);
}

static const unsigned inc32table[8] = {0, 1, 2,  1,  0,  4, 4, 4};
static const int      dec64table[8] = {0, 0, 0, -1, -4,  1, 2, 3};


#ifndef LZ4_FAST_DEC_LOOP
#  if defined __i386__ || defined _M_IX86 || defined __x86_64__ || defined _M_X64
#    define LZ4_FAST_DEC_LOOP 1
#  elif defined(__aarch64__) && defined(__APPLE__)
#    define LZ4_FAST_DEC_LOOP 1
#  elif defined(__aarch64__) && !defined(__clang__)
     /* On non-Apple aarch64, we disable this optimization for clang because
      * on certain mobile chipsets, performance is reduced with clang. For
      * more information refer to https://github.com/lz4/lz4/pull/707 */
#    define LZ4_FAST_DEC_LOOP 1
#  else
#    define LZ4_FAST_DEC_LOOP 0
#  endif
#endif // corresponds to #ifndef (#ifndef LZ4_FAST_DEC_LOOP)

#if LZ4_FAST_DEC_LOOP

LZ4_FORCE_INLINE void
LZ4_memcpy_using_offset_base(BYTE* dstPtr, const BYTE* srcPtr, BYTE* dstEnd, const size_t offset)
{
    assert(srcPtr + offset == dstPtr);
    if (offset < 8) {
        LZ4_write32(dstPtr, 0);   /* silence an msan warning when offset==0 */
        dstPtr[0] = srcPtr[0];
        dstPtr[1] = srcPtr[1];
        dstPtr[2] = srcPtr[2];
        dstPtr[3] = srcPtr[3];
		
        srcPtr += inc32table[offset];
        LZ4_memcpy(dstPtr+4, srcPtr, 4);
        srcPtr -= dec64table[offset];
        dstPtr += 8;
    } else {
        LZ4_memcpy(dstPtr, srcPtr, 8);
        dstPtr += 8;
        srcPtr += 8;
    }

    LZ4_wildCopy8(dstPtr, srcPtr, dstEnd);
}

/* customized variant of memcpy, which can overwrite up to 32 bytes beyond dstEnd
 * this version copies two times 16 bytes (instead of one time 32 bytes)
 * because it must be compatible with offsets >= 16. */
LZ4_FORCE_INLINE void
LZ4_wildCopy32(void* dstPtr, const void* srcPtr, void* dstEnd)
{
    BYTE* d = (BYTE*)dstPtr;
    const BYTE* s = (const BYTE*)srcPtr;
    BYTE* const e = (BYTE*)dstEnd;

    do { LZ4_memcpy(d,s,16); LZ4_memcpy(d+16,s+16,16); d+=32; s+=32; } while (d<e);
}

/* LZ4_memcpy_using_offset()  presumes :
 * - dstEnd >= dstPtr + MINMATCH
 * - there is at least 8 bytes available to write after dstEnd */
LZ4_FORCE_INLINE void
LZ4_memcpy_using_offset(BYTE* dstPtr, const BYTE* srcPtr, BYTE* dstEnd, const size_t offset)
{
    BYTE v[8];

    assert(dstEnd >= dstPtr + MINMATCH);

    switch(offset) {
    case 1:
        MEM_INIT(v, *srcPtr, 8);
        break;
    case 2:
        LZ4_memcpy(v, srcPtr, 2);
        LZ4_memcpy(&v[2], srcPtr, 2);
#if defined(_MSC_VER) && (_MSC_VER <= 1937) /* MSVC 2022 ver 17.7 or earlier */
#  pragma warning(push)
#  pragma warning(disable : 6385) /* warning C6385: Reading invalid data from 'v'. */
#endif // corresponds to #if (#if defined(_MSC_VER) && (_MSC_VER <= 1937) /* MSVC 2022 ver 17.7 or earlier */)
        LZ4_memcpy(&v[4], v, 4);
#if defined(_MSC_VER) && (_MSC_VER <= 1937) /* MSVC 2022 ver 17.7 or earlier */
#  pragma warning(pop)
#endif // corresponds to #if (#if defined(_MSC_VER) && (_MSC_VER <= 1937) /* MSVC 2022 ver 17.7 or earlier */)
        break;
    case 4:
        LZ4_memcpy(v, srcPtr, 4);
        LZ4_memcpy(&v[4], srcPtr, 4);
        break;
    default:
        LZ4_memcpy_using_offset_base(dstPtr, srcPtr, dstEnd, offset);
        return;
    }

    LZ4_memcpy(dstPtr, v, 8);
    dstPtr += 8;
    while (dstPtr < dstEnd) {
        LZ4_memcpy(dstPtr, v, 8);
        dstPtr += 8;
    }
}
#endif // corresponds to #if (#if LZ4_FAST_DEC_LOOP)


/*-************************************
*  Common functions
**************************************/
static unsigned LZ4_NbCommonBytes (reg_t val)
{
    assert(val != 0);
    if (LZ4_isLittleEndian()) {
        if (sizeof(val) == 8) {
#       if defined(_MSC_VER) && (_MSC_VER >= 1800) && (defined(_M_AMD64) && !defined(_M_ARM64EC)) && !defined(LZ4_FORCE_SW_BITCOUNT)
/*-*************************************************************************************************
* ARM64EC is a Microsoft-designed ARM64 ABI compatible with AMD64 applications on ARM64 Windows 11.
* The ARM64EC ABI does not support AVX/AVX2/AVX512 instructions, nor their relevant intrinsics
* including _tzcnt_u64. Therefore, we need to neuter the _tzcnt_u64 code path for ARM64EC.
****************************************************************************************************/
#         if defined(__clang__) && (__clang_major__ < 10)
            /* Avoid undefined clang-cl intrinsics issue.
             * See https://github.com/lz4/lz4/pull/1017 for details. */
            return (unsigned)__builtin_ia32_tzcnt_u64(val) >> 3;
#         else
            /* x64 CPUS without BMI support interpret `TZCNT` as `REP BSF` */
            return (unsigned)_tzcnt_u64(val) >> 3;
#         endif
#       elif defined(_MSC_VER) && defined(_WIN64) && !defined(LZ4_FORCE_SW_BITCOUNT)
            unsigned long r = 0;
            _BitScanForward64(&r, (U64)val);
            return (unsigned)r >> 3;
#       elif (defined(__clang__) || (defined(__GNUC__) && ((__GNUC__ > 3) || \
                            ((__GNUC__ == 3) && (__GNUC_MINOR__ >= 4))))) && \
                                        !defined(LZ4_FORCE_SW_BITCOUNT)
            return (unsigned)__builtin_ctzll((U64)val) >> 3;
#       else
            const U64 m = 0x0101010101010101ULL;
            val ^= val - 1;
            return (unsigned)(((U64)((val & (m - 1)) * m)) >> 56);
#       endif
        } else /* 32 bits */ {
#       if defined(_MSC_VER) && (_MSC_VER >= 1400) && !defined(LZ4_FORCE_SW_BITCOUNT)
            unsigned long r;
            _BitScanForward(&r, (U32)val);
            return (unsigned)r >> 3;
#       elif (defined(__clang__) || (defined(__GNUC__) && ((__GNUC__ > 3) || \
                            ((__GNUC__ == 3) && (__GNUC_MINOR__ >= 4))))) && \
                        !defined(__TINYC__) && !defined(LZ4_FORCE_SW_BITCOUNT)
            return (unsigned)__builtin_ctz((U32)val) >> 3;
#       else
            const U32 m = 0x01010101;
            return (unsigned)((((val - 1) ^ val) & (m - 1)) * m) >> 24;
#       endif
        }
    } else   /* Big Endian CPU */ {
        if (sizeof(val)==8) {
#       if (defined(__clang__) || (defined(__GNUC__) && ((__GNUC__ > 3) || \
                            ((__GNUC__ == 3) && (__GNUC_MINOR__ >= 4))))) && \
                        !defined(__TINYC__) && !defined(LZ4_FORCE_SW_BITCOUNT)
            return (unsigned)__builtin_clzll((U64)val) >> 3;
#       else
#if 1
            /* this method is probably faster,
             * but adds a 128 bytes lookup table */
            static const unsigned char ctz7_tab[128] = {
                7, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
                4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
                5, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
                4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
                6, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
                4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
                5, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
                4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
            };
            U64 const mask = 0x0101010101010101ULL;
            U64 const t = (((val >> 8) - mask) | val) & mask;
            return ctz7_tab[(t * 0x0080402010080402ULL) >> 57];
#else
            /* this method doesn't consume memory space like the previous one,
             * but it contains several branches,
             * that may end up slowing execution */
            static const U32 by32 = sizeof(val)*4;  /* 32 on 64 bits (goal), 16 on 32 bits.
            Just to avoid some static analyzer complaining about shift by 32 on 32-bits target.
            Note that this code path is never triggered in 32-bits mode. */
            unsigned r;
            if (!(val>>by32)) { r=4; } else { r=0; val>>=by32; }
            if (!(val>>16)) { r+=2; val>>=8; } else { val>>=24; }
            r += (!val);
            return r;
#endif // corresponds to #if (#if 1)
#       endif
        } else /* 32 bits */ {
#       if (defined(__clang__) || (defined(__GNUC__) && ((__GNUC__ > 3) || \
                            ((__GNUC__ == 3) && (__GNUC_MINOR__ >= 4))))) && \
                                        !defined(LZ4_FORCE_SW_BITCOUNT)
            return (unsigned)__builtin_clz((U32)val) >> 3;
#       else
            val >>= 8;
            val = ((((val + 0x00FFFF00) | 0x00FFFFFF) + val) |
              (val + 0x00FF0000)) >> 24;
            return (unsigned)val ^ 3;
#       endif
        }
    }
}


#define STEPSIZE sizeof(reg_t)
LZ4_FORCE_INLINE
unsigned LZ4_count(const BYTE* pIn, const BYTE* pMatch, const BYTE* pInLimit)
{
    const BYTE* const pStart = pIn;

    if (likely(pIn < pInLimit-(STEPSIZE-1))) {
        reg_t const diff = LZ4_read_ARCH(pMatch) ^ LZ4_read_ARCH(pIn);
        if (!diff) {
            pIn+=STEPSIZE; pMatch+=STEPSIZE;
        } else {
            return LZ4_NbCommonBytes(diff);
    }   }

    while (likely(pIn < pInLimit-(STEPSIZE-1))) {
        reg_t const diff = LZ4_read_ARCH(pMatch) ^ LZ4_read_ARCH(pIn);
        if (!diff) { pIn+=STEPSIZE; pMatch+=STEPSIZE; continue; }
        pIn += LZ4_NbCommonBytes(diff);
        return (unsigned)(pIn - pStart);
    }

    if ((STEPSIZE==8) && (pIn<(pInLimit-3)) && (LZ4_read32(pMatch) == LZ4_read32(pIn))) { pIn+=4; pMatch+=4; }
    if ((pIn<(pInLimit-1)) && (LZ4_read16(pMatch) == LZ4_read16(pIn))) { pIn+=2; pMatch+=2; }
    if ((pIn<pInLimit) && (*pMatch == *pIn)) pIn++;
    return (unsigned)(pIn - pStart);
}


static const int LZ4_64Klimit = ((64 KB) + (MFLIMIT-1));
static const U32 LZ4_skipTrigger = 6;  /* Increase this value ==> compression run slower on incompressible data */

typedef enum { clearedTable = 0, byPtr, byU32, byU16 } tableType_t;
typedef enum { noDict = 0, withPrefix64k, usingExtDict, usingDictCtx } dict_directive;
typedef enum { noDictIssue = 0, dictSmall } dictIssue_directive;


int LZ4_decompress_safe_forceExtDict(const char* source, char* dest,
                                     int compressedSize, int maxOutputSize,
                                     const void* dictStart, size_t dictSize);
int LZ4_decompress_safe_partial_forceExtDict(const char* source, char* dest,
                                     int compressedSize, int targetOutputSize, int dstCapacity,
                                     const void* dictStart, size_t dictSize);

LZ4_FORCE_INLINE U32 LZ4_hash4(U32 sequence, tableType_t const tableType)
{
    if (tableType == byU16)
        return ((sequence * 2654435761U) >> ((MINMATCH*8)-(LZ4_HASHLOG+1)));
    else
        return ((sequence * 2654435761U) >> ((MINMATCH*8)-LZ4_HASHLOG));
}

LZ4_FORCE_INLINE U32 LZ4_hash5(U64 sequence, tableType_t const tableType)
{
    const U32 hashLog = (tableType == byU16) ? LZ4_HASHLOG+1 : LZ4_HASHLOG;
    if (LZ4_isLittleEndian()) {
        const U64 prime5bytes = 889523592379ULL;
        return (U32)(((sequence << 24) * prime5bytes) >> (64 - hashLog));
    } else {
        const U64 prime8bytes = 11400714785074694791ULL;
        return (U32)(((sequence >> 24) * prime8bytes) >> (64 - hashLog));
    }
}

LZ4_FORCE_INLINE U32 LZ4_hashPosition(const void* const p, tableType_t const tableType)
{
    if ((sizeof(reg_t)==8) && (tableType != byU16)) return LZ4_hash5(LZ4_read_ARCH(p), tableType);
    return LZ4_hash4(LZ4_read32(p), tableType);
}

LZ4_FORCE_INLINE void LZ4_clearHash(U32 h, void* tableBase, tableType_t const tableType)
{
    switch (tableType)
    {
    default: /* fallthrough */
    case clearedTable: { /* illegal! */ assert(0); return; }
    case byPtr: { const BYTE** hashTable = (const BYTE**)tableBase; hashTable[h] = NULL; return; }
    case byU32: { U32* hashTable = (U32*) tableBase; hashTable[h] = 0; return; }
    case byU16: { U16* hashTable = (U16*) tableBase; hashTable[h] = 0; return; }
    }
}

LZ4_FORCE_INLINE void LZ4_putIndexOnHash(U32 idx, U32 h, void* tableBase, tableType_t const tableType)
{
    switch (tableType)
    {
    default: /* fallthrough */
    case clearedTable: /* fallthrough */
    case byPtr: { /* illegal! */ assert(0); return; }
    case byU32: { U32* hashTable = (U32*) tableBase; hashTable[h] = idx; return; }
    case byU16: { U16* hashTable = (U16*) tableBase; assert(idx < 65536); hashTable[h] = (U16)idx; return; }
    }
}

/* LZ4_putPosition*() : only used in byPtr mode */
LZ4_FORCE_INLINE void LZ4_putPositionOnHash(const BYTE* p, U32 h,
                                  void* tableBase, tableType_t const tableType)
{
    const BYTE** const hashTable = (const BYTE**)tableBase;
    assert(tableType == byPtr); (void)tableType;
    hashTable[h] = p;
}

LZ4_FORCE_INLINE void LZ4_putPosition(const BYTE* p, void* tableBase, tableType_t tableType)
{
    U32 const h = LZ4_hashPosition(p, tableType);
    LZ4_putPositionOnHash(p, h, tableBase, tableType);
}

/* LZ4_getIndexOnHash() :
 * Index of match position registered in hash table.
 * hash position must be calculated by using base+index, or dictBase+index.
 * Assumption 1 : only valid if tableType == byU32 or byU16.
 * Assumption 2 : h is presumed valid (within limits of hash table)
 */
LZ4_FORCE_INLINE U32 LZ4_getIndexOnHash(U32 h, const void* tableBase, tableType_t tableType)
{
    LZ4_STATIC_ASSERT(LZ4_MEMORY_USAGE > 2);
    if (tableType == byU32) {
        const U32* const hashTable = (const U32*) tableBase;
        assert(h < (1U << (LZ4_MEMORY_USAGE-2)));
        return hashTable[h];
    }
    if (tableType == byU16) {
        const U16* const hashTable = (const U16*) tableBase;
        assert(h < (1U << (LZ4_MEMORY_USAGE-1)));
        return hashTable[h];
    }
    assert(0); return 0;  /* forbidden case */
}

static const BYTE* LZ4_getPositionOnHash(U32 h, const void* tableBase, tableType_t tableType)
{
    assert(tableType == byPtr); (void)tableType;
    { const BYTE* const* hashTable = (const BYTE* const*) tableBase; return hashTable[h]; }
}

LZ4_FORCE_INLINE const BYTE*
LZ4_getPosition(const BYTE* p,
                const void* tableBase, tableType_t tableType)
{
    U32 const h = LZ4_hashPosition(p, tableType);
    return LZ4_getPositionOnHash(h, tableBase, tableType);
}


/** LZ4_compress_generic_validated() :
 *  inlined, to ensure branches are decided at compilation time.
 *  The following conditions are presumed already validated:
 *  - source != NULL
 *  - inputSize > 0
 */
LZ4_FORCE_INLINE int LZ4_compress_generic_validated(
                 LZ4_stream_t_internal* const cctx,
                 const char* const source,
                 char* const dest,
                 const int inputSize,
                 int*  inputConsumed, /* only written when outputDirective == fillOutput */
                 const int maxOutputSize,
                 const limitedOutput_directive outputDirective,
                 const tableType_t tableType,
                 const dict_directive dictDirective,
                 const dictIssue_directive dictIssue,
                 const int acceleration)
{
    int result;
    const BYTE* ip = (const BYTE*)source;

    U32 const startIndex = cctx->currentOffset;
    const BYTE* base = (const BYTE*)source - startIndex;
    const BYTE* lowLimit;

    const LZ4_stream_t_internal* dictCtx = (const LZ4_stream_t_internal*) cctx->dictCtx;
    const BYTE* const dictionary =
        dictDirective == usingDictCtx ? dictCtx->dictionary : cctx->dictionary;
    const U32 dictSize =
        dictDirective == usingDictCtx ? dictCtx->dictSize : cctx->dictSize;
    const U32 dictDelta =
        (dictDirective == usingDictCtx) ? startIndex - dictCtx->currentOffset : 0;   /* make indexes in dictCtx comparable with indexes in current context */

    int const maybe_extMem = (dictDirective == usingExtDict) || (dictDirective == usingDictCtx);
    U32 const prefixIdxLimit = startIndex - dictSize;   /* used when dictDirective == dictSmall */
    const BYTE* const dictEnd = dictionary ? dictionary + dictSize : dictionary;
    const BYTE* anchor = (const BYTE*) source;
    const BYTE* const iend = ip + inputSize;
    const BYTE* const mflimitPlusOne = iend - MFLIMIT + 1;
    const BYTE* const matchlimit = iend - LASTLITERALS;

    /* the dictCtx currentOffset is indexed on the start of the dictionary,
     * while a dictionary in the current context precedes the currentOffset */
    const BYTE* dictBase = (dictionary == NULL) ? NULL :
                           (dictDirective == usingDictCtx) ?
                            dictionary + dictSize - dictCtx->currentOffset :
                            dictionary + dictSize - startIndex;

    BYTE* op = (BYTE*) dest;
    BYTE* const olimit = op + maxOutputSize;

    U32 offset = 0;
    U32 forwardH;

    DEBUGLOG(5, "LZ4_compress_generic_validated: srcSize=%i, tableType=%u", inputSize, tableType);
    assert(ip != NULL);
    if (tableType == byU16) assert(inputSize<LZ4_64Klimit);  /* Size too large (not within 64K limit) */
    if (tableType == byPtr) assert(dictDirective==noDict);   /* only supported use case with byPtr */
    /* If init conditions are not met, we don't have to mark stream
     * as having dirty context, since no action was taken yet */
    if (outputDirective == fillOutput && maxOutputSize < 1) { return 0; } /* Impossible to store anything */
    assert(acceleration >= 1);

    lowLimit = (const BYTE*)source - (dictDirective == withPrefix64k ? dictSize : 0);

    /* Update context state */
    if (dictDirective == usingDictCtx) {
        /* Subsequent linked blocks can't use the dictionary. */
        /* Instead, they use the block we just compressed. */
        cctx->dictCtx = NULL;
        cctx->dictSize = (U32)inputSize;
    } else {
        cctx->dictSize += (U32)inputSize;
    }
    cctx->currentOffset += (U32)inputSize;
    cctx->tableType = (U32)tableType;

    if (inputSize<LZ4_minLength) goto _last_literals;        /* Input too small, no compression (all literals) */

    /* First Byte */
    {   U32 const h = LZ4_hashPosition(ip, tableType);
        if (tableType == byPtr) {
            LZ4_putPositionOnHash(ip, h, cctx->hashTable, byPtr);
        } else {
            LZ4_putIndexOnHash(startIndex, h, cctx->hashTable, tableType);
    }   }
    ip++; forwardH = LZ4_hashPosition(ip, tableType);

    /* Main Loop */
    for ( ; ; ) {
        const BYTE* match;
        BYTE* token;
        const BYTE* filledIp;

        /* Find a match */
        if (tableType == byPtr) {
            const BYTE* forwardIp = ip;
            int step = 1;
            int searchMatchNb = acceleration << LZ4_skipTrigger;
            do {
                U32 const h = forwardH;
                ip = forwardIp;
                forwardIp += step;
                step = (searchMatchNb++ >> LZ4_skipTrigger);

                if (unlikely(forwardIp > mflimitPlusOne)) goto _last_literals;
                assert(ip < mflimitPlusOne);

                match = LZ4_getPositionOnHash(h, cctx->hashTable, tableType);
                forwardH = LZ4_hashPosition(forwardIp, tableType);
                LZ4_putPositionOnHash(ip, h, cctx->hashTable, tableType);

            } while ( (match+LZ4_DISTANCE_MAX < ip)
                   || (LZ4_read32(match) != LZ4_read32(ip)) );

        } else {   /* byU32, byU16 */

            const BYTE* forwardIp = ip;
            int step = 1;
            int searchMatchNb = acceleration << LZ4_skipTrigger;
            do {
                U32 const h = forwardH;
                U32 const current = (U32)(forwardIp - base);
                U32 matchIndex = LZ4_getIndexOnHash(h, cctx->hashTable, tableType);
                assert(matchIndex <= current);
                assert(forwardIp - base < (ptrdiff_t)(2 GB - 1));
                ip = forwardIp;
                forwardIp += step;
                step = (searchMatchNb++ >> LZ4_skipTrigger);

                if (unlikely(forwardIp > mflimitPlusOne)) goto _last_literals;
                assert(ip < mflimitPlusOne);

                if (dictDirective == usingDictCtx) {
                    if (matchIndex < startIndex) {
                        /* there was no match, try the dictionary */
                        assert(tableType == byU32);
                        matchIndex = LZ4_getIndexOnHash(h, dictCtx->hashTable, byU32);
                        match = dictBase + matchIndex;
                        matchIndex += dictDelta;   /* make dictCtx index comparable with current context */
                        lowLimit = dictionary;
                    } else {
                        match = base + matchIndex;
                        lowLimit = (const BYTE*)source;
                    }
                } else if (dictDirective == usingExtDict) {
                    if (matchIndex < startIndex) {
                        DEBUGLOG(7, "extDict candidate: matchIndex=%5u  <  startIndex=%5u", matchIndex, startIndex);
                        assert(startIndex - matchIndex >= MINMATCH);
                        assert(dictBase);
                        match = dictBase + matchIndex;
                        lowLimit = dictionary;
                    } else {
                        match = base + matchIndex;
                        lowLimit = (const BYTE*)source;
                    }
                } else {   /* single continuous memory segment */
                    match = base + matchIndex;
                }
                forwardH = LZ4_hashPosition(forwardIp, tableType);
                LZ4_putIndexOnHash(current, h, cctx->hashTable, tableType);

                DEBUGLOG(7, "candidate at pos=%u  (offset=%u \n", matchIndex, current - matchIndex);
                if ((dictIssue == dictSmall) && (matchIndex < prefixIdxLimit)) { continue; }    /* match outside of valid area */
                assert(matchIndex < current);
                if ( ((tableType != byU16) || (LZ4_DISTANCE_MAX < LZ4_DISTANCE_ABSOLUTE_MAX))
                  && (matchIndex+LZ4_DISTANCE_MAX < current)) {
                    continue;
                } /* too far */
                assert((current - matchIndex) <= LZ4_DISTANCE_MAX);  /* match now expected within distance */

                if (LZ4_read32(match) == LZ4_read32(ip)) {
                    if (maybe_extMem) offset = current - matchIndex;
                    break;   /* match found */
                }

            } while(1);
        }

        /* Catch up */
        filledIp = ip;
        assert(ip > anchor); /* this is always true as ip has been advanced before entering the main loop */
        if ((match > lowLimit) && unlikely(ip[-1] == match[-1])) {
            do { ip--; match--; } while (((ip > anchor) & (match > lowLimit)) && (unlikely(ip[-1] == match[-1])));
        }

        /* Encode Literals */
        {   unsigned const litLength = (unsigned)(ip - anchor);
            token = op++;
            if ((outputDirective == limitedOutput) &&  /* Check output buffer overflow */
                (unlikely(op + litLength + (2 + 1 + LASTLITERALS) + (litLength/255) > olimit)) ) {
                return 0;   /* cannot compress within `dst` budget. Stored indexes in hash table are nonetheless fine */
            }
            if ((outputDirective == fillOutput) &&
                (unlikely(op + (litLength+240)/255 /* litlen */ + litLength /* literals */ + 2 /* offset */ + 1 /* token */ + MFLIMIT - MINMATCH /* min last literals so last match is <= end - MFLIMIT */ > olimit))) {
                op--;
                goto _last_literals;
            }
            if (litLength >= RUN_MASK) {
                int len = (int)(litLength - RUN_MASK);
                *token = (RUN_MASK<<ML_BITS);
                for(; len >= 255 ; len-=255) *op++ = 255;
                *op++ = (BYTE)len;
            }
            else *token = (BYTE)(litLength<<ML_BITS);

            /* Copy Literals */
            LZ4_wildCopy8(op, anchor, op+litLength);
            op+=litLength;
            DEBUGLOG(6, "seq.start:%i, literals=%u, match.start:%i",
                        (int)(anchor-(const BYTE*)source), litLength, (int)(ip-(const BYTE*)source));
        }

_next_match:
        /* at this stage, the following variables must be correctly set :
         * - ip : at start of LZ operation
         * - match : at start of previous pattern occurrence; can be within current prefix, or within extDict
         * - offset : if maybe_ext_memSegment==1 (constant)
         * - lowLimit : must be == dictionary to mean "match is within extDict"; must be == source otherwise
         * - token and *token : position to write 4-bits for match length; higher 4-bits for literal length supposed already written
         */

        if ((outputDirective == fillOutput) &&
            (op + 2 /* offset */ + 1 /* token */ + MFLIMIT - MINMATCH /* min last literals so last match is <= end - MFLIMIT */ > olimit)) {
            /* the match was too close to the end, rewind and go to last literals */
            op = token;
            goto _last_literals;
        }

        /* Encode Offset */
        if (maybe_extMem) {   /* static test */
            DEBUGLOG(6, "             with offset=%u  (ext if > %i)", offset, (int)(ip - (const BYTE*)source));
            assert(offset <= LZ4_DISTANCE_MAX && offset > 0);
            LZ4_writeLE16(op, (U16)offset); op+=2;
        } else  {
            DEBUGLOG(6, "             with offset=%u  (same segment)", (U32)(ip - match));
            assert(ip-match <= LZ4_DISTANCE_MAX);
            LZ4_writeLE16(op, (U16)(ip - match)); op+=2;
        }

        /* Encode MatchLength */
        {   unsigned matchCode;

            if ( (dictDirective==usingExtDict || dictDirective==usingDictCtx)
              && (lowLimit==dictionary) /* match within extDict */ ) {
                const BYTE* limit = ip + (dictEnd-match);
                assert(dictEnd > match);
                if (limit > matchlimit) limit = matchlimit;
                matchCode = LZ4_count(ip+MINMATCH, match+MINMATCH, limit);
                ip += (size_t)matchCode + MINMATCH;
                if (ip==limit) {
                    unsigned const more = LZ4_count(limit, (const BYTE*)source, matchlimit);
                    matchCode += more;
                    ip += more;
                }
                DEBUGLOG(6, "             with matchLength=%d starting in extDict", matchCode+MINMATCH);
            } else {
                matchCode = LZ4_count(ip+MINMATCH, match+MINMATCH, matchlimit);
                ip += (size_t)matchCode + MINMATCH;
                DEBUGLOG(6, "             with matchLength=%d", matchCode+MINMATCH);
            }

            if ((outputDirective) &&    /* Check output buffer overflow */
                (unlikely(op + (1 + LASTLITERALS) + (matchCode+240)/255 > olimit)) ) {
                if (outputDirective == fillOutput) {
                    /* Match description too long : reduce it */
                    U32 newMatchCode = 15 /* in token */ - 1 /* to avoid needing a zero byte */ + ((U32)(olimit - op) - 1 - LASTLITERALS) * 255;
                    ip -= matchCode - newMatchCode;
                    assert(newMatchCode < matchCode);
                    matchCode = newMatchCode;
                    if (unlikely(ip <= filledIp)) {
                        /* We have already filled up to filledIp so if ip ends up less than filledIp
                         * we have positions in the hash table beyond the current position. This is
                         * a problem if we reuse the hash table. So we have to remove these positions
                         * from the hash table.
                         */
                        const BYTE* ptr;
                        DEBUGLOG(5, "Clearing %u positions", (U32)(filledIp - ip));
                        for (ptr = ip; ptr <= filledIp; ++ptr) {
                            U32 const h = LZ4_hashPosition(ptr, tableType);
                            LZ4_clearHash(h, cctx->hashTable, tableType);
                        }
                    }
                } else {
                    assert(outputDirective == limitedOutput);
                    return 0;   /* cannot compress within `dst` budget. Stored indexes in hash table are nonetheless fine */
                }
            }
            if (matchCode >= ML_MASK) {
                *token += ML_MASK;
                matchCode -= ML_MASK;
                LZ4_write32(op, 0xFFFFFFFF);
                while (matchCode >= 4*255) {
                    op+=4;
                    LZ4_write32(op, 0xFFFFFFFF);
                    matchCode -= 4*255;
                }
                op += matchCode / 255;
                *op++ = (BYTE)(matchCode % 255);
            } else
                *token += (BYTE)(matchCode);
        }
        /* Ensure we have enough space for the last literals. */
        assert(!(outputDirective == fillOutput && op + 1 + LASTLITERALS > olimit));

        anchor = ip;

        /* Test end of chunk */
        if (ip >= mflimitPlusOne) break;

        /* Fill table */
        {   U32 const h = LZ4_hashPosition(ip-2, tableType);
            if (tableType == byPtr) {
                LZ4_putPositionOnHash(ip-2, h, cctx->hashTable, byPtr);
            } else {
                U32 const idx = (U32)((ip-2) - base);
                LZ4_putIndexOnHash(idx, h, cctx->hashTable, tableType);
        }   }

        /* Test next position */
        if (tableType == byPtr) {

            match = LZ4_getPosition(ip, cctx->hashTable, tableType);
            LZ4_putPosition(ip, cctx->hashTable, tableType);
            if ( (match+LZ4_DISTANCE_MAX >= ip)
              && (LZ4_read32(match) == LZ4_read32(ip)) )
            { token=op++; *token=0; goto _next_match; }

        } else {   /* byU32, byU16 */

            U32 const h = LZ4_hashPosition(ip, tableType);
            U32 const current = (U32)(ip-base);
            U32 matchIndex = LZ4_getIndexOnHash(h, cctx->hashTable, tableType);
            assert(matchIndex < current);
            if (dictDirective == usingDictCtx) {
                if (matchIndex < startIndex) {
                    /* there was no match, try the dictionary */
                    assert(tableType == byU32);
                    matchIndex = LZ4_getIndexOnHash(h, dictCtx->hashTable, byU32);
                    match = dictBase + matchIndex;
                    lowLimit = dictionary;   /* required for match length counter */
                    matchIndex += dictDelta;
                } else {
                    match = base + matchIndex;
                    lowLimit = (const BYTE*)source;  /* required for match length counter */
                }
            } else if (dictDirective==usingExtDict) {
                if (matchIndex < startIndex) {
                    assert(dictBase);
                    match = dictBase + matchIndex;
                    lowLimit = dictionary;   /* required for match length counter */
                } else {
                    match = base + matchIndex;
                    lowLimit = (const BYTE*)source;   /* required for match length counter */
                }
            } else {   /* single memory segment */
                match = base + matchIndex;
            }
            LZ4_putIndexOnHash(current, h, cctx->hashTable, tableType);
            assert(matchIndex < current);
            if ( ((dictIssue==dictSmall) ? (matchIndex >= prefixIdxLimit) : 1)
              && (((tableType==byU16) && (LZ4_DISTANCE_MAX == LZ4_DISTANCE_ABSOLUTE_MAX)) ? 1 : (matchIndex+LZ4_DISTANCE_MAX >= current))
              && (LZ4_read32(match) == LZ4_read32(ip)) ) {
                token=op++;
                *token=0;
                if (maybe_extMem) offset = current - matchIndex;
                DEBUGLOG(6, "seq.start:%i, literals=%u, match.start:%i",
                            (int)(anchor-(const BYTE*)source), 0, (int)(ip-(const BYTE*)source));
                goto _next_match;
            }
        }

        /* Prepare next loop */
        forwardH = LZ4_hashPosition(++ip, tableType);

    }

_last_literals:
    /* Encode Last Literals */
    {   size_t lastRun = (size_t)(iend - anchor);
        if ( (outputDirective) &&  /* Check output buffer overflow */
            (op + lastRun + 1 + ((lastRun+255-RUN_MASK)/255) > olimit)) {
            if (outputDirective == fillOutput) {
                /* adapt lastRun to fill 'dst' */
                assert(olimit >= op);
                lastRun  = (size_t)(olimit-op) - 1/*token*/;
                lastRun -= (lastRun + 256 - RUN_MASK) / 256;  /*additional length tokens*/
            } else {
                assert(outputDirective == limitedOutput);
                return 0;   /* cannot compress within `dst` budget. Stored indexes in hash table are nonetheless fine */
            }
        }
        DEBUGLOG(6, "Final literal run : %i literals", (int)lastRun);
        if (lastRun >= RUN_MASK) {
            size_t accumulator = lastRun - RUN_MASK;
            *op++ = RUN_MASK << ML_BITS;
            for(; accumulator >= 255 ; accumulator-=255) *op++ = 255;
            *op++ = (BYTE) accumulator;
        } else {
            *op++ = (BYTE)(lastRun<<ML_BITS);
        }
        LZ4_memcpy(op, anchor, lastRun);
        ip = anchor + lastRun;
        op += lastRun;
    }

    if (outputDirective == fillOutput) {
        *inputConsumed = (int) (((const char*)ip)-source);
    }
    result = (int)(((char*)op) - dest);
    assert(result > 0);
    DEBUGLOG(5, "LZ4_compress_generic: compressed %i bytes into %i bytes", inputSize, result);
    return result;
}

/** LZ4_compress_generic() :
 *  inlined, to ensure branches are decided at compilation time;
 *  takes care of src == (NULL, 0)
 *  and forward the rest to LZ4_compress_generic_validated */
LZ4_FORCE_INLINE int LZ4_compress_generic(
                 LZ4_stream_t_internal* const cctx,
                 const char* const src,
                 char* const dst,
                 const int srcSize,
                 int *inputConsumed, /* only written when outputDirective == fillOutput */
                 const int dstCapacity,
                 const limitedOutput_directive outputDirective,
                 const tableType_t tableType,
                 const dict_directive dictDirective,
                 const dictIssue_directive dictIssue,
                 const int acceleration)
{
    DEBUGLOG(5, "LZ4_compress_generic: srcSize=%i, dstCapacity=%i",
                srcSize, dstCapacity);

    if ((U32)srcSize > (U32)LZ4_MAX_INPUT_SIZE) { return 0; }  /* Unsupported srcSize, too large (or negative) */
    if (srcSize == 0) {   /* src == NULL supported if srcSize == 0 */
        if (outputDirective != notLimited && dstCapacity <= 0) return 0;  /* no output, can't write anything */
        DEBUGLOG(5, "Generating an empty block");
        assert(outputDirective == notLimited || dstCapacity >= 1);
        assert(dst != NULL);
        dst[0] = 0;
        if (outputDirective == fillOutput) {
            assert (inputConsumed != NULL);
            *inputConsumed = 0;
        }
        return 1;
    }
    assert(src != NULL);

    return LZ4_compress_generic_validated(cctx, src, dst, srcSize,
                inputConsumed, /* only written into if outputDirective == fillOutput */
                dstCapacity, outputDirective,
                tableType, dictDirective, dictIssue, acceleration);
}


LZ4_stream_t* LZ4_createStream(void)
{
    LZ4_stream_t* const lz4s = (LZ4_stream_t*)ALLOC(sizeof(LZ4_stream_t));
	g_allocatedram+=sizeof(LZ4_stream_t);
    LZ4_STATIC_ASSERT(sizeof(LZ4_stream_t) >= sizeof(LZ4_stream_t_internal));
    DEBUGLOG(4, "LZ4_createStream %p", lz4s);
    if (lz4s == NULL) return NULL;
    LZ4_initStream(lz4s, sizeof(*lz4s));
    return lz4s;
}

static size_t LZ4_stream_t_alignment(void)
{
#if LZ4_ALIGN_TEST
    typedef struct { char c; LZ4_stream_t t; } t_a;
    return sizeof(t_a) - sizeof(LZ4_stream_t);
#else
    return 1;  /* effectively disabled */
#endif // corresponds to #if (#if LZ4_ALIGN_TEST)
}

LZ4_stream_t* LZ4_initStream (void* buffer, size_t size)
{
    DEBUGLOG(5, "LZ4_initStream");
    if (buffer == NULL) { return NULL; }
    if (size < sizeof(LZ4_stream_t)) { return NULL; }
    if (!LZ4_isAligned(buffer, LZ4_stream_t_alignment())) return NULL;
    MEM_INIT(buffer, 0, sizeof(LZ4_stream_t_internal));
    return (LZ4_stream_t*)buffer;
}

int LZ4_freeStream (LZ4_stream_t* LZ4_stream)
{
    if (!LZ4_stream) return 0;   /* support free on NULL */
    DEBUGLOG(5, "LZ4_freeStream %p", LZ4_stream);
    FREEMEM(LZ4_stream);
    return (0);
}




static void LZ4_renormDictT(LZ4_stream_t_internal* LZ4_dict, int nextSize)
{
    assert(nextSize >= 0);
    if (LZ4_dict->currentOffset + (unsigned)nextSize > 0x80000000) {   /* potential ptrdiff_t overflow (32-bits mode) */
        /* rescale hash table */
        U32 const delta = LZ4_dict->currentOffset - 64 KB;
        const BYTE* dictEnd = LZ4_dict->dictionary + LZ4_dict->dictSize;
        int i;
        DEBUGLOG(4, "LZ4_renormDictT");
        for (i=0; i<LZ4_HASH_SIZE_U32; i++) {
            if (LZ4_dict->hashTable[i] < delta) LZ4_dict->hashTable[i]=0;
            else LZ4_dict->hashTable[i] -= delta;
        }
        LZ4_dict->currentOffset = 64 KB;
        if (LZ4_dict->dictSize > 64 KB) LZ4_dict->dictSize = 64 KB;
        LZ4_dict->dictionary = dictEnd - LZ4_dict->dictSize;
    }
}


int LZ4_compress_fast_continue (LZ4_stream_t* LZ4_stream,
                                const char* source, char* dest,
                                int inputSize, int maxOutputSize,
                                int acceleration)
{
    const tableType_t tableType = byU32;
    LZ4_stream_t_internal* const streamPtr = &LZ4_stream->internal_donotuse;
    const char* dictEnd = streamPtr->dictSize ? (const char*)streamPtr->dictionary + streamPtr->dictSize : NULL;

    DEBUGLOG(5, "LZ4_compress_fast_continue (inputSize=%i, dictSize=%u)", inputSize, streamPtr->dictSize);

    LZ4_renormDictT(streamPtr, inputSize);   /* fix index overflow */
    if (acceleration < 1) acceleration = LZ4_ACCELERATION_DEFAULT;
    if (acceleration > LZ4_ACCELERATION_MAX) acceleration = LZ4_ACCELERATION_MAX;

    /* invalidate tiny dictionaries */
    if ( (streamPtr->dictSize < 4)     /* tiny dictionary : not enough for a hash */
      && (dictEnd != source)           /* prefix mode */
      && (inputSize > 0)               /* tolerance : don't lose history, in case next invocation would use prefix mode */
      && (streamPtr->dictCtx == NULL)  /* usingDictCtx */
      ) {
        DEBUGLOG(5, "LZ4_compress_fast_continue: dictSize(%u) at addr:%p is too small", streamPtr->dictSize, streamPtr->dictionary);
        /* remove dictionary existence from history, to employ faster prefix mode */
        streamPtr->dictSize = 0;
        streamPtr->dictionary = (const BYTE*)source;
        dictEnd = source;
    }

    /* Check overlapping input/dictionary space */
    {   const char* const sourceEnd = source + inputSize;
        if ((sourceEnd > (const char*)streamPtr->dictionary) && (sourceEnd < dictEnd)) {
            streamPtr->dictSize = (U32)(dictEnd - sourceEnd);
            if (streamPtr->dictSize > 64 KB) streamPtr->dictSize = 64 KB;
            if (streamPtr->dictSize < 4) streamPtr->dictSize = 0;
            streamPtr->dictionary = (const BYTE*)dictEnd - streamPtr->dictSize;
        }
    }

    /* prefix mode : source data follows dictionary */
    if (dictEnd == source) {
        if ((streamPtr->dictSize < 64 KB) && (streamPtr->dictSize < streamPtr->currentOffset))
            return LZ4_compress_generic(streamPtr, source, dest, inputSize, NULL, maxOutputSize, limitedOutput, tableType, withPrefix64k, dictSmall, acceleration);
        else
            return LZ4_compress_generic(streamPtr, source, dest, inputSize, NULL, maxOutputSize, limitedOutput, tableType, withPrefix64k, noDictIssue, acceleration);
    }

    /* external dictionary mode */
    {   int result;
        if (streamPtr->dictCtx) {
            /* We depend here on the fact that dictCtx'es (produced by
             * LZ4_loadDict) guarantee that their tables contain no references
             * to offsets between dictCtx->currentOffset - 64 KB and
             * dictCtx->currentOffset - dictCtx->dictSize. This makes it safe
             * to use noDictIssue even when the dict isn't a full 64 KB.
             */
            if (inputSize > 4 KB) {
                /* For compressing large blobs, it is faster to pay the setup
                 * cost to copy the dictionary's tables into the active context,
                 * so that the compression loop is only looking into one table.
                 */
                LZ4_memcpy(streamPtr, streamPtr->dictCtx, sizeof(*streamPtr));
                result = LZ4_compress_generic(streamPtr, source, dest, inputSize, NULL, maxOutputSize, limitedOutput, tableType, usingExtDict, noDictIssue, acceleration);
            } else {
                result = LZ4_compress_generic(streamPtr, source, dest, inputSize, NULL, maxOutputSize, limitedOutput, tableType, usingDictCtx, noDictIssue, acceleration);
            }
        } else {  /* small data <= 4 KB */
            if ((streamPtr->dictSize < 64 KB) && (streamPtr->dictSize < streamPtr->currentOffset)) {
                result = LZ4_compress_generic(streamPtr, source, dest, inputSize, NULL, maxOutputSize, limitedOutput, tableType, usingExtDict, dictSmall, acceleration);
            } else {
                result = LZ4_compress_generic(streamPtr, source, dest, inputSize, NULL, maxOutputSize, limitedOutput, tableType, usingExtDict, noDictIssue, acceleration);
            }
        }
        streamPtr->dictionary = (const BYTE*)source;
        streamPtr->dictSize = (U32)inputSize;
        return result;
    }
}

typedef enum { decode_full_block = 0, partial_decode = 1 } earlyEnd_directive;

#undef MIN
#define MIN(a,b)    ( (a) < (b) ? (a) : (b) )



/* Read the variable-length literal or match length.
 *
 * @ip : input pointer
 * @ilimit : position after which if length is not decoded, the input is necessarily corrupted.
 * @initial_check - check ip >= ipmax before start of loop.  Returns initial_error if so.
 * @error (output) - error code.  Must be set to 0 before call.
**/
typedef size_t Rvl_t;
static const Rvl_t rvl_error = (Rvl_t)(-1);
LZ4_FORCE_INLINE Rvl_t
read_variable_length(const BYTE** ip, const BYTE* ilimit,
                     int initial_check)
{
    Rvl_t s, length = 0;
    assert(ip != NULL);
    assert(*ip !=  NULL);
    assert(ilimit != NULL);
    if (initial_check && unlikely((*ip) >= ilimit)) {    /* read limit reached */
        return rvl_error;
    }
    s = **ip;
    (*ip)++;
    length += s;
    if (unlikely((*ip) > ilimit)) {    /* read limit reached */
        return rvl_error;
    }
    /* accumulator overflow detection (32-bit mode only) */
    if ((sizeof(length) < 8) && unlikely(length > ((Rvl_t)(-1)/2)) ) {
        return rvl_error;
    }
    if (likely(s != 255)) return length;
    do {
        s = **ip;
        (*ip)++;
        length += s;
        if (unlikely((*ip) > ilimit)) {    /* read limit reached */
            return rvl_error;
        }
        /* accumulator overflow detection (32-bit mode only) */
        if ((sizeof(length) < 8) && unlikely(length > ((Rvl_t)(-1)/2)) ) {
            return rvl_error;
        }
    } while (s == 255);

    return length;
}

/*! LZ4_decompress_generic() :
 *  This generic decompression function covers all use cases.
 *  It shall be instantiated several times, using different sets of directives.
 *  Note that it is important for performance that this function really get inlined,
 *  in order to remove useless branches during compilation optimization.
 */
LZ4_FORCE_INLINE int
LZ4_decompress_generic(
                 const char* const src,
                 char* const dst,
                 int srcSize,
                 int outputSize,         /* If endOnInput==endOnInputSize, this value is `dstCapacity` */

                 earlyEnd_directive partialDecoding,  /* full, partial */
                 dict_directive dict,                 /* noDict, withPrefix64k, usingExtDict */
                 const BYTE* const lowPrefix,  /* always <= dst, == dst when no prefix */
                 const BYTE* const dictStart,  /* only if dict==usingExtDict */
                 const size_t dictSize         /* note : = 0 if noDict */
                 )
{
    if ((src == NULL) || (outputSize < 0)) { return -1; }

    {   const BYTE* ip = (const BYTE*) src;
        const BYTE* const iend = ip + srcSize;

        BYTE* op = (BYTE*) dst;
        BYTE* const oend = op + outputSize;
        BYTE* cpy;

        const BYTE* const dictEnd = (dictStart == NULL) ? NULL : dictStart + dictSize;

        const int checkOffset = (dictSize < (int)(64 KB));


        /* Set up the "end" pointers for the shortcut. */
        const BYTE* const shortiend = iend - 14 /*maxLL*/ - 2 /*offset*/;
        const BYTE* const shortoend = oend - 14 /*maxLL*/ - 18 /*maxML*/;

        const BYTE* match;
        size_t offset;
        unsigned token;
        size_t length;


        DEBUGLOG(5, "LZ4_decompress_generic (srcSize:%i, dstSize:%i)", srcSize, outputSize);

        /* Special cases */
        assert(lowPrefix <= op);
        if (unlikely(outputSize==0)) {
            /* Empty output buffer */
            if (partialDecoding) return 0;
            return ((srcSize==1) && (*ip==0)) ? 0 : -1;
        }
        if (unlikely(srcSize==0)) { return -1; }

    /* LZ4_FAST_DEC_LOOP:
     * designed for modern OoO performance cpus,
     * where copying reliably 32-bytes is preferable to an unpredictable branch.
     * note : fast loop may show a regression for some client arm chips. */
#if LZ4_FAST_DEC_LOOP
        if ((oend - op) < FASTLOOP_SAFE_DISTANCE) {
            DEBUGLOG(6, "skip fast decode loop");
            goto safe_decode;
        }

        /* Fast loop : decode sequences as long as output < oend-FASTLOOP_SAFE_DISTANCE */
        DEBUGLOG(6, "using fast decode loop");
        while (1) {
            /* Main fastloop assertion: We can always wildcopy FASTLOOP_SAFE_DISTANCE */
            assert(oend - op >= FASTLOOP_SAFE_DISTANCE);
            assert(ip < iend);
            token = *ip++;
            length = token >> ML_BITS;  /* literal length */

            /* decode literal length */
            if (length == RUN_MASK) {
                size_t const addl = read_variable_length(&ip, iend-RUN_MASK, 1);
                if (addl == rvl_error) {
                    DEBUGLOG(6, "error reading long literal length");
                    goto _output_error;
                }
                length += addl;
                if (unlikely((uptrval)(op)+length<(uptrval)(op))) { goto _output_error; } /* overflow detection */
                if (unlikely((uptrval)(ip)+length<(uptrval)(ip))) { goto _output_error; } /* overflow detection */

                /* copy literals */
                LZ4_STATIC_ASSERT(MFLIMIT >= WILDCOPYLENGTH);
                if ((op+length>oend-32) || (ip+length>iend-32)) { goto safe_literal_copy; }
                LZ4_wildCopy32(op, ip, op+length);
                ip += length; op += length;
            } else if (ip <= iend-(16 + 1/*max lit + offset + nextToken*/)) {
                /* We don't need to check oend, since we check it once for each loop below */
                DEBUGLOG(7, "copy %u bytes in a 16-bytes stripe", (unsigned)length);
                /* Literals can only be <= 14, but hope compilers optimize better when copy by a register size */
                LZ4_memcpy(op, ip, 16);
                ip += length; op += length;
            } else {
                goto safe_literal_copy;
            }

            /* get offset */
            offset = LZ4_readLE16(ip); ip+=2;
            DEBUGLOG(6, " offset = %zu", offset);
            match = op - offset;
            assert(match <= op);  /* overflow check */

            /* get matchlength */
            length = token & ML_MASK;

            if (length == ML_MASK) {
                size_t const addl = read_variable_length(&ip, iend - LASTLITERALS + 1, 0);
                if (addl == rvl_error) {
                    DEBUGLOG(6, "error reading long match length");
                    goto _output_error;
                }
                length += addl;
                length += MINMATCH;
                if (unlikely((uptrval)(op)+length<(uptrval)op)) { goto _output_error; } /* overflow detection */
                if (op + length >= oend - FASTLOOP_SAFE_DISTANCE) {
                    goto safe_match_copy;
                }
            } else {
                length += MINMATCH;
                if (op + length >= oend - FASTLOOP_SAFE_DISTANCE) {
                    goto safe_match_copy;
                }

                /* Fastpath check: skip LZ4_wildCopy32 when true */
                if ((dict == withPrefix64k) || (match >= lowPrefix)) {
                    if (offset >= 8) {
                        assert(match >= lowPrefix);
                        assert(match <= op);
                        assert(op + 18 <= oend);

                        LZ4_memcpy(op, match, 8);
                        LZ4_memcpy(op+8, match+8, 8);
                        LZ4_memcpy(op+16, match+16, 2);
                        op += length;
                        continue;
            }   }   }

            if ( checkOffset && (unlikely(match + dictSize < lowPrefix)) ) {
                DEBUGLOG(6, "Error : pos=%zi, offset=%zi => outside buffers", op-lowPrefix, op-match);
                goto _output_error;
            }
            /* match starting within external dictionary */
            if ((dict==usingExtDict) && (match < lowPrefix)) {
                assert(dictEnd != NULL);
                if (unlikely(op+length > oend-LASTLITERALS)) {
                    if (partialDecoding) {
                        DEBUGLOG(7, "partialDecoding: dictionary match, close to dstEnd");
                        length = MIN(length, (size_t)(oend-op));
                    } else {
                        DEBUGLOG(6, "end-of-block condition violated")
                        goto _output_error;
                }   }

                if (length <= (size_t)(lowPrefix-match)) {
                    /* match fits entirely within external dictionary : just copy */
                    LZ4_memmove(op, dictEnd - (lowPrefix-match), length);
                    op += length;
                } else {
                    /* match stretches into both external dictionary and current block */
                    size_t const copySize = (size_t)(lowPrefix - match);
                    size_t const restSize = length - copySize;
                    LZ4_memcpy(op, dictEnd - copySize, copySize);
                    op += copySize;
                    if (restSize > (size_t)(op - lowPrefix)) {  /* overlap copy */
                        BYTE* const endOfMatch = op + restSize;
                        const BYTE* copyFrom = lowPrefix;
                        while (op < endOfMatch) { *op++ = *copyFrom++; }
                    } else {
                        LZ4_memcpy(op, lowPrefix, restSize);
                        op += restSize;
                }   }
                continue;
            }

            /* copy match within block */
            cpy = op + length;

            assert((op <= oend) && (oend-op >= 32));
            if (unlikely(offset<16)) {
                LZ4_memcpy_using_offset(op, match, cpy, offset);
            } else {
                LZ4_wildCopy32(op, match, cpy);
            }

            op = cpy;   /* wildcopy correction */
        }
    safe_decode:
#endif // corresponds to #if (#if LZ4_FAST_DEC_LOOP)

        /* Main Loop : decode remaining sequences where output < FASTLOOP_SAFE_DISTANCE */
        DEBUGLOG(6, "using safe decode loop");
        while (1) {
            assert(ip < iend);
            token = *ip++;
            length = token >> ML_BITS;  /* literal length */

            /* A two-stage shortcut for the most common case:
             * 1) If the literal length is 0..14, and there is enough space,
             * enter the shortcut and copy 16 bytes on behalf of the literals
             * (in the fast mode, only 8 bytes can be safely copied this way).
             * 2) Further if the match length is 4..18, copy 18 bytes in a similar
             * manner; but we ensure that there's enough space in the output for
             * those 18 bytes earlier, upon entering the shortcut (in other words,
             * there is a combined check for both stages).
             */
            if ( (length != RUN_MASK)
                /* strictly "less than" on input, to re-enter the loop with at least one byte */
              && likely((ip < shortiend) & (op <= shortoend)) ) {
                /* Copy the literals */
                LZ4_memcpy(op, ip, 16);
                op += length; ip += length;

                /* The second stage: prepare for match copying, decode full info.
                 * If it doesn't work out, the info won't be wasted. */
                length = token & ML_MASK; /* match length */
                offset = LZ4_readLE16(ip); ip += 2;
                match = op - offset;
                assert(match <= op); /* check overflow */

                /* Do not deal with overlapping matches. */
                if ( (length != ML_MASK)
                  && (offset >= 8)
                  && (dict==withPrefix64k || match >= lowPrefix) ) {
                    /* Copy the match. */
                    LZ4_memcpy(op + 0, match + 0, 8);
                    LZ4_memcpy(op + 8, match + 8, 8);
                    LZ4_memcpy(op +16, match +16, 2);
                    op += length + MINMATCH;
                    /* Both stages worked, load the next token. */
                    continue;
                }

                /* The second stage didn't work out, but the info is ready.
                 * Propel it right to the point of match copying. */
                goto _copy_match;
            }

            /* decode literal length */
            if (length == RUN_MASK) {
                size_t const addl = read_variable_length(&ip, iend-RUN_MASK, 1);
                if (addl == rvl_error) { goto _output_error; }
                length += addl;
                if (unlikely((uptrval)(op)+length<(uptrval)(op))) { goto _output_error; } /* overflow detection */
                if (unlikely((uptrval)(ip)+length<(uptrval)(ip))) { goto _output_error; } /* overflow detection */
            }

#if LZ4_FAST_DEC_LOOP
        safe_literal_copy:
#endif // corresponds to #if (#if LZ4_FAST_DEC_LOOP)
            /* copy literals */
            cpy = op+length;

            LZ4_STATIC_ASSERT(MFLIMIT >= WILDCOPYLENGTH);
            if ((cpy>oend-MFLIMIT) || (ip+length>iend-(2+1+LASTLITERALS))) {
                /* We've either hit the input parsing restriction or the output parsing restriction.
                 * In the normal scenario, decoding a full block, it must be the last sequence,
                 * otherwise it's an error (invalid input or dimensions).
                 * In partialDecoding scenario, it's necessary to ensure there is no buffer overflow.
                 */
                if (partialDecoding) {
                    /* Since we are partial decoding we may be in this block because of the output parsing
                     * restriction, which is not valid since the output buffer is allowed to be undersized.
                     */
                    DEBUGLOG(7, "partialDecoding: copying literals, close to input or output end")
                    DEBUGLOG(7, "partialDecoding: literal length = %u", (unsigned)length);
                    DEBUGLOG(7, "partialDecoding: remaining space in dstBuffer : %i", (int)(oend - op));
                    DEBUGLOG(7, "partialDecoding: remaining space in srcBuffer : %i", (int)(iend - ip));
                    /* Finishing in the middle of a literals segment,
                     * due to lack of input.
                     */
                    if (ip+length > iend) {
                        length = (size_t)(iend-ip);
                        cpy = op + length;
                    }
                    /* Finishing in the middle of a literals segment,
                     * due to lack of output space.
                     */
                    if (cpy > oend) {
                        cpy = oend;
                        assert(op<=oend);
                        length = (size_t)(oend-op);
                    }
                } else {
                     /* We must be on the last sequence (or invalid) because of the parsing limitations
                      * so check that we exactly consume the input and don't overrun the output buffer.
                      */
                    if ((ip+length != iend) || (cpy > oend)) {
                        DEBUGLOG(6, "should have been last run of literals")
                        DEBUGLOG(6, "ip(%p) + length(%i) = %p != iend (%p)", ip, (int)length, ip+length, iend);
                        DEBUGLOG(6, "or cpy(%p) > oend(%p)", cpy, oend);
                        goto _output_error;
                    }
                }
                LZ4_memmove(op, ip, length);  /* supports overlapping memory regions, for in-place decompression scenarios */
                ip += length;
                op += length;
                /* Necessarily EOF when !partialDecoding.
                 * When partialDecoding, it is EOF if we've either
                 * filled the output buffer or
                 * can't proceed with reading an offset for following match.
                 */
                if (!partialDecoding || (cpy == oend) || (ip >= (iend-2))) {
                    break;
                }
            } else {
                LZ4_wildCopy8(op, ip, cpy);   /* can overwrite up to 8 bytes beyond cpy */
                ip += length; op = cpy;
            }

            /* get offset */
            offset = LZ4_readLE16(ip); ip+=2;
            match = op - offset;

            /* get matchlength */
            length = token & ML_MASK;

    _copy_match:
            if (length == ML_MASK) {
                size_t const addl = read_variable_length(&ip, iend - LASTLITERALS + 1, 0);
                if (addl == rvl_error) { goto _output_error; }
                length += addl;
                if (unlikely((uptrval)(op)+length<(uptrval)op)) goto _output_error;   /* overflow detection */
            }
            length += MINMATCH;

#if LZ4_FAST_DEC_LOOP
        safe_match_copy:
#endif // corresponds to #if (#if LZ4_FAST_DEC_LOOP)
            if ((checkOffset) && (unlikely(match + dictSize < lowPrefix))) goto _output_error;   /* Error : offset outside buffers */
            /* match starting within external dictionary */
            if ((dict==usingExtDict) && (match < lowPrefix)) {
                assert(dictEnd != NULL);
                if (unlikely(op+length > oend-LASTLITERALS)) {
                    if (partialDecoding) length = MIN(length, (size_t)(oend-op));
                    else goto _output_error;   /* doesn't respect parsing restriction */
                }

                if (length <= (size_t)(lowPrefix-match)) {
                    /* match fits entirely within external dictionary : just copy */
                    LZ4_memmove(op, dictEnd - (lowPrefix-match), length);
                    op += length;
                } else {
                    /* match stretches into both external dictionary and current block */
                    size_t const copySize = (size_t)(lowPrefix - match);
                    size_t const restSize = length - copySize;
                    LZ4_memcpy(op, dictEnd - copySize, copySize);
                    op += copySize;
                    if (restSize > (size_t)(op - lowPrefix)) {  /* overlap copy */
                        BYTE* const endOfMatch = op + restSize;
                        const BYTE* copyFrom = lowPrefix;
                        while (op < endOfMatch) *op++ = *copyFrom++;
                    } else {
                        LZ4_memcpy(op, lowPrefix, restSize);
                        op += restSize;
                }   }
                continue;
            }
            assert(match >= lowPrefix);

            /* copy match within block */
            cpy = op + length;

            /* partialDecoding : may end anywhere within the block */
            assert(op<=oend);
            if (partialDecoding && (cpy > oend-MATCH_SAFEGUARD_DISTANCE)) {
                size_t const mlen = MIN(length, (size_t)(oend-op));
                const BYTE* const matchEnd = match + mlen;
                BYTE* const copyEnd = op + mlen;
                if (matchEnd > op) {   /* overlap copy */
                    while (op < copyEnd) { *op++ = *match++; }
                } else {
                    LZ4_memcpy(op, match, mlen);
                }
                op = copyEnd;
                if (op == oend) { break; }
                continue;
            }

            if (unlikely(offset<8)) {
                LZ4_write32(op, 0);   /* silence msan warning when offset==0 */
                op[0] = match[0];
                op[1] = match[1];
                op[2] = match[2];
                op[3] = match[3];
                match += inc32table[offset];
                LZ4_memcpy(op+4, match, 4);
                match -= dec64table[offset];
            } else {
                LZ4_memcpy(op, match, 8);
                match += 8;
            }
            op += 8;

            if (unlikely(cpy > oend-MATCH_SAFEGUARD_DISTANCE)) {
                BYTE* const oCopyLimit = oend - (WILDCOPYLENGTH-1);
                if (cpy > oend-LASTLITERALS) { goto _output_error; } /* Error : last LASTLITERALS bytes must be literals (uncompressed) */
                if (op < oCopyLimit) {
                    LZ4_wildCopy8(op, match, oCopyLimit);
                    match += oCopyLimit - op;
                    op = oCopyLimit;
                }
                while (op < cpy) { *op++ = *match++; }
            } else {
                LZ4_memcpy(op, match, 8);
                if (length > 16)  { LZ4_wildCopy8(op+8, match+8, cpy); }
            }
            op = cpy;   /* wildcopy correction */
        }

        /* end of decoding */
        DEBUGLOG(5, "decoded %i bytes", (int) (((char*)op)-dst));
        return (int) (((char*)op)-dst);     /* Nb of output bytes decoded */

        /* Overflow error detected */
    _output_error:
        return (int) (-(((const char*)ip)-src))-1;
    }
}

LZ4_FORCE_O2
int LZ4_decompress_safe(const char* source, char* dest, int compressedSize, int maxDecompressedSize)
{
    return LZ4_decompress_generic(source, dest, compressedSize, maxDecompressedSize,
                                  decode_full_block, noDict,
                                  (BYTE*)dest, NULL, 0);
}

LZ4_FORCE_O2 /* Exported, an obsolete API function. */
int LZ4_decompress_safe_withPrefix64k(const char* source, char* dest, int compressedSize, int maxOutputSize)
{
    return LZ4_decompress_generic(source, dest, compressedSize, maxOutputSize,
                                  decode_full_block, withPrefix64k,
                                  (BYTE*)dest - 64 KB, NULL, 0);
}



LZ4_FORCE_O2
static int LZ4_decompress_safe_withSmallPrefix(const char* source, char* dest, int compressedSize, int maxOutputSize,
                                               size_t prefixSize)
{
    return LZ4_decompress_generic(source, dest, compressedSize, maxOutputSize,
                                  decode_full_block, noDict,
                                  (BYTE*)dest-prefixSize, NULL, 0);
}


LZ4_FORCE_O2
int LZ4_decompress_safe_forceExtDict(const char* source, char* dest,
                                     int compressedSize, int maxOutputSize,
                                     const void* dictStart, size_t dictSize)
{
    DEBUGLOG(5, "LZ4_decompress_safe_forceExtDict");
    return LZ4_decompress_generic(source, dest, compressedSize, maxOutputSize,
                                  decode_full_block, usingExtDict,
                                  (BYTE*)dest, (const BYTE*)dictStart, dictSize);
}



/* The "double dictionary" mode, for use with e.g. ring buffers: the first part
 * of the dictionary is passed as prefix, and the second via dictStart + dictSize.
 * These routines are used only once, in LZ4_decompress_*_continue().
 */
LZ4_FORCE_INLINE
int LZ4_decompress_safe_doubleDict(const char* source, char* dest, int compressedSize, int maxOutputSize,
                                   size_t prefixSize, const void* dictStart, size_t dictSize)
{
    return LZ4_decompress_generic(source, dest, compressedSize, maxOutputSize,
                                  decode_full_block, usingExtDict,
                                  (BYTE*)dest-prefixSize, (const BYTE*)dictStart, dictSize);
}

/*===== streaming decompression functions =====*/

LZ4_streamDecode_t* LZ4_createStreamDecode(void)
{
    LZ4_STATIC_ASSERT(sizeof(LZ4_streamDecode_t) >= sizeof(LZ4_streamDecode_t_internal));
	g_allocatedram+=sizeof(LZ4_streamDecode_t);
    return (LZ4_streamDecode_t*) ALLOC_AND_ZERO(sizeof(LZ4_streamDecode_t));
}

int LZ4_freeStreamDecode (LZ4_streamDecode_t* LZ4_stream)
{
    if (LZ4_stream == NULL) { return 0; }  /* support free on NULL */
    FREEMEM(LZ4_stream);
    return 0;
}


/*
*_continue() :
    These decoding functions allow decompression of multiple blocks in "streaming" mode.
    Previously decoded blocks must still be available at the memory position where they were decoded.
    If it's not possible, save the relevant part of decoded data into a safe buffer,
    and indicate where it stands using LZ4_setStreamDecode()
*/
LZ4_FORCE_O2
int LZ4_decompress_safe_continue (LZ4_streamDecode_t* LZ4_streamDecode, const char* source, char* dest, int compressedSize, int maxOutputSize)
{
    LZ4_streamDecode_t_internal* lz4sd = &LZ4_streamDecode->internal_donotuse;
    int result;

    if (lz4sd->prefixSize == 0) {
        /* The first call, no dictionary yet. */
        assert(lz4sd->extDictSize == 0);
        result = LZ4_decompress_safe(source, dest, compressedSize, maxOutputSize);
        if (result <= 0) return result;
        lz4sd->prefixSize = (size_t)result;
        lz4sd->prefixEnd = (BYTE*)dest + result;
    } else if (lz4sd->prefixEnd == (BYTE*)dest) {
        /* They're rolling the current segment. */
        if (lz4sd->prefixSize >= 64 KB - 1)
            result = LZ4_decompress_safe_withPrefix64k(source, dest, compressedSize, maxOutputSize);
        else if (lz4sd->extDictSize == 0)
            result = LZ4_decompress_safe_withSmallPrefix(source, dest, compressedSize, maxOutputSize,
                                                         lz4sd->prefixSize);
        else
            result = LZ4_decompress_safe_doubleDict(source, dest, compressedSize, maxOutputSize,
                                                    lz4sd->prefixSize, lz4sd->externalDict, lz4sd->extDictSize);
        if (result <= 0) return result;
        lz4sd->prefixSize += (size_t)result;
        lz4sd->prefixEnd  += result;
    } else {
        /* The buffer wraps around, or they're switching to another buffer. */
        lz4sd->extDictSize = lz4sd->prefixSize;
        lz4sd->externalDict = lz4sd->prefixEnd - lz4sd->extDictSize;
        result = LZ4_decompress_safe_forceExtDict(source, dest, compressedSize, maxOutputSize,
                                                  lz4sd->externalDict, lz4sd->extDictSize);
        if (result <= 0) return result;
        lz4sd->prefixSize = (size_t)result;
        lz4sd->prefixEnd  = (BYTE*)dest + result;
    }

    return result;
}

/// LICENSE_END.22
#endif // corresponds to #ifdef (#ifdef _WIN32)




///https://patorjk.com/software/taag/#p=display&f=Graffiti&t=Type%20Something%20
///banner font
void bigguru()
{
	myprintf("\n\n");
	myprintf(" #####  #     # ######  #     #\n");
	myprintf("#     # #     # #     # #     #\n");
	myprintf("#       #     # #     # #     #\n");
	myprintf("#  #### #     # ######  #     #\n");
	myprintf("#     # #     # #   #   #     #\n");
	myprintf("#     # #     # #    #  #     #\n");
	myprintf(" #####   #####  #     #  ##### \n");
	myprintf("\n\n");
}

void bigok()
{
	myprintf("\n\n");
	myprintf("####### #    #\n");
	myprintf("#     # #   #\n");
	myprintf("#     # #  #\n");
	myprintf("#     # ###!\n");
	myprintf("#     # #  #\n");
	myprintf("#     # #   #\n");
	myprintf("####### #    #\n");
	myprintf("\n\n");
}
void bigerror()
{
	myprintf("\n\n");
	myprintf("####### ######  ######  ####### ######  ###\n");
	myprintf("#       #     # #     # #     # #     # ###\n");
	myprintf("#       #     # #     # #     # #     # ###\n");
	myprintf("#####   ######  ######  #     # ######   #\n");
	myprintf("#       #   #   #   #   #     # #   #\n");
	myprintf("#       #    #  #    #  #     # #    #  ###\n");
	myprintf("####### #     # #     # ####### #     # ###\n");
	myprintf("\n\n");
}
void bigwarning()
{
	myprintf("\n\n");
	myprintf("#     #    #    ######  #     # ### #     #  #####\n");
	myprintf("#  #  #   # #   #     # ##    #  #  ##    # #     #\n");
	myprintf("#  #  #  #   #  #     # # #   #  #  # #   # #\n");
	myprintf("#  #  # #     # ######  #  #  #  #  #  #  # #  ####\n");
	myprintf("#  #  # ####### #   #   #   # #  #  #   # # #     #\n");
	myprintf("#  #  # #     # #    #  #    ##  #  #    ## #     #\n");
	myprintf(" ## ##  #     # #     # #     # ### #     #  #####\n");
	myprintf("\n\n");
}

#ifdef HWSHA2
void getcpuid(uint32_t eax, uint32_t ecx, uint32_t& o_a,uint32_t& o_b,uint32_t& o_c,uint32_t& o_d)
{
    uint32_t ebx=0;
	uint32_t edx=0;
	// on some kind of ancient HW ebx need to be saved. Not sure if and why, readed here and there
	// It is unpredictable what exactly the compiler will do
	// https://sites.uclouvain.be/SystInfo/usr/include/cpuid.h.html
#if defined(__i386__) && defined(__PIC__)
   __asm__ __volatile__ (	"movl %%ebx, %%edi;"
							"cpuid;"
							"xchgl %%ebx, %%edi;"
							: "=D"(ebx), "+a"(eax), "+c"(ecx), "=d"(edx));
#else
	__asm__("cpuid;" : "+b"(ebx), "+a"(eax), "+c"(ecx), "=d"(edx));
#endif // corresponds to #if (#if defined(__i386__) && defined(__PIC__))
	o_a=eax; // cpuid silently change the input parameter, so we have to store back
    o_b=ebx;
    o_c=ecx;
    o_d=edx;
}
#else
void getcpuid(uint32_t eax, uint32_t ecx, uint32_t& o_a,uint32_t& o_b,uint32_t& o_c,uint32_t& o_d)
{
    o_a=0;
	o_b=0;
	o_c=ecx-ecx; // compiler be quiet
	o_d=eax-eax;
}
#endif // corresponds to #ifdef (#ifdef HWSHA2)


#ifdef HWSHA2

/// LICENSE_START.20
/*
	This is a reworked
	CPU accelerated SHA code taken from SHA-Intrinsics - Public Domain
	(https://github.com/noloader/SHA-Intrinsics)
*/

#define ALIGNED(m) __attribute__ ((__aligned__(m)))
#define bswap_uint64 __builtin_bswap64
#define bswap_uint32 __builtin_bswap32
#define bswap_uint16 __builtin_bswap16
#define read_swap32(p) bswap_uint32(*(const uint32_t*)(const uint8_t*)(p))
#define read_swap64(p) bswap_uint64(*(const uint64_t*)(const uint8_t*)(p))
#define PREFETCH64(m) do { __builtin_prefetch(m, 0, 0); __builtin_prefetch(m+32, 0, 0); } while(0)
#define write_swap16(p,v) (*(uint16_t*)(void*)(p)) = bswap_uint16(v)
#define write_swap32(p,v) (*(uint32_t*)(void*)(p)) = bswap_uint32(v)
#define write_swap64(p,v) (*(uint64_t*)(void*)(p)) = bswap_uint64(v)
#define safe_strlen(str) ((((char*)(str))==NULL)?0:strlen(str))

/* Includes for SHA-1 and SHA-256 intrinsics */
#include <x86intrin.h>
#define MY_ENABLE_GCC_ARCH(arch) __attribute__ ((target (arch)))


/* Blocksize for each algorithm - Must be a power of 2 */
#define SHA1_BLOCKSIZE      64
#define SHA256_BLOCKSIZE    64
#define MAX_BLOCKSIZE       SHA256_BLOCKSIZE


/*
 * Rotate 32 or 64 bit integers by n bytes.
 * Don't bother trying to hand-optimize those, as the
 * compiler usually does a pretty good job at that.
 */
#define ROL32(a,b) (((a) << (b)) | ((a) >> (32-(b))))
#define ROR32(a,b) (((a) >> (b)) | ((a) << (32-(b))))
#define ROL64(a,b) (((a) << (b)) | ((a) >> (64-(b))))
#define ROR64(a,b) (((a) >> (b)) | ((a) << (64-(b))))

/*
 * SHA-256 common macros (use Wikipedia SHA-2 names for clarity)
 */
#define Ch(x,y,z) ((z) ^ ((x) & ((y) ^ (z))))
#define Ma(x,y,z) (((x) & (y)) | ((z) & ((x) | (y))))

/* SHA-256 constants */
static const uint32_t K256[64] = {
	0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
	0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
	0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
	0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
	0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
	0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
	0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
	0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2
};


/*
 * For convenience, we use a common context for all the checksum algorithms,
 * which means some elements may be unused...
 Please note the ALIGNED that makes a lot of trouble...
 */
typedef struct ALIGNED(64) {
	uint8_t buf[MAX_BLOCKSIZE];
	uint64_t state[8];
	uint64_t bytecount;
} SUM_CONTEXT;


static void sha1_init(SUM_CONTEXT *ctx)
{
	memset(ctx, 0, sizeof(*ctx));
	ctx->state[0] = 0x67452301;
	ctx->state[1] = 0xefcdab89;
	ctx->state[2] = 0x98badcfe;
	ctx->state[3] = 0x10325476;
	ctx->state[4] = 0xc3d2e1f0;
}

static void sha256_init(SUM_CONTEXT *ctx)
{
	memset(ctx, 0, sizeof(*ctx));
	ctx->state[0] = 0x6a09e667;
	ctx->state[1] = 0xbb67ae85;
	ctx->state[2] = 0x3c6ef372;
	ctx->state[3] = 0xa54ff53a;
	ctx->state[4] = 0x510e527f;
	ctx->state[5] = 0x9b05688c;
	ctx->state[6] = 0x1f83d9ab;
	ctx->state[7] = 0x5be0cd19;
}

/* Transform the message X which consists of 16 32-bit-words (SHA-1) */
static void sha1_transform_cc(SUM_CONTEXT *ctx, const uint8_t *data)
{
	uint32_t a, b, c, d, e, tm, x[16];

	/* get values from the chaining vars */
	a = (uint32_t)ctx->state[0];
	b = (uint32_t)ctx->state[1];
	c = (uint32_t)ctx->state[2];
	d = (uint32_t)ctx->state[3];
	e = (uint32_t)ctx->state[4];

#ifdef BIG
	memcpy(x, data, sizeof(x));
#else
	{

		unsigned k;
		for (k = 0; k < 16; k += 4) {
			const uint8_t *p2 = data + k * 4;
			x[k] = read_swap32(p2);
			x[k + 1] = read_swap32(p2 + 4);
			x[k + 2] = read_swap32(p2 + 8);
			x[k + 3] = read_swap32(p2 + 12);
		}
	}
#endif // corresponds to #ifdef (#ifdef BIG)

#define K1  0x5a827999L
#define K2  0x6ed9eba1L
#define K3  0x8f1bbcdcL
#define K4  0xca62c1d6L
#define F1(x,y,z)   ( z ^ ( x & ( y ^ z ) ) )
#define F2(x,y,z)   ( x ^ y ^ z )
#define F3(x,y,z)   ( ( x & y ) | ( z & ( x | y ) ) )
#define F4(x,y,z)   ( x ^ y ^ z )

#define M(i) ( tm = x[i&0x0f] ^ x[(i-14)&0x0f] ^ x[(i-8)&0x0f] ^ x[(i-3)&0x0f], (x[i&0x0f] = ROL32(tm,1)) )

#define SHA1STEP(a, b, c, d, e, f, k, m) do { e += ROL32(a, 5) + f(b, c, d) + k + m; \
                                              b = ROL32(b, 30); } while(0)
	SHA1STEP(a, b, c, d, e, F1, K1, x[0]);
	SHA1STEP(e, a, b, c, d, F1, K1, x[1]);
	SHA1STEP(d, e, a, b, c, F1, K1, x[2]);
	SHA1STEP(c, d, e, a, b, F1, K1, x[3]);
	SHA1STEP(b, c, d, e, a, F1, K1, x[4]);
	SHA1STEP(a, b, c, d, e, F1, K1, x[5]);
	SHA1STEP(e, a, b, c, d, F1, K1, x[6]);
	SHA1STEP(d, e, a, b, c, F1, K1, x[7]);
	SHA1STEP(c, d, e, a, b, F1, K1, x[8]);
	SHA1STEP(b, c, d, e, a, F1, K1, x[9]);
	SHA1STEP(a, b, c, d, e, F1, K1, x[10]);
	SHA1STEP(e, a, b, c, d, F1, K1, x[11]);
	SHA1STEP(d, e, a, b, c, F1, K1, x[12]);
	SHA1STEP(c, d, e, a, b, F1, K1, x[13]);
	SHA1STEP(b, c, d, e, a, F1, K1, x[14]);
	SHA1STEP(a, b, c, d, e, F1, K1, x[15]);
	SHA1STEP(e, a, b, c, d, F1, K1, M(16));
	SHA1STEP(d, e, a, b, c, F1, K1, M(17));
	SHA1STEP(c, d, e, a, b, F1, K1, M(18));
	SHA1STEP(b, c, d, e, a, F1, K1, M(19));
	SHA1STEP(a, b, c, d, e, F2, K2, M(20));
	SHA1STEP(e, a, b, c, d, F2, K2, M(21));
	SHA1STEP(d, e, a, b, c, F2, K2, M(22));
	SHA1STEP(c, d, e, a, b, F2, K2, M(23));
	SHA1STEP(b, c, d, e, a, F2, K2, M(24));
	SHA1STEP(a, b, c, d, e, F2, K2, M(25));
	SHA1STEP(e, a, b, c, d, F2, K2, M(26));
	SHA1STEP(d, e, a, b, c, F2, K2, M(27));
	SHA1STEP(c, d, e, a, b, F2, K2, M(28));
	SHA1STEP(b, c, d, e, a, F2, K2, M(29));
	SHA1STEP(a, b, c, d, e, F2, K2, M(30));
	SHA1STEP(e, a, b, c, d, F2, K2, M(31));
	SHA1STEP(d, e, a, b, c, F2, K2, M(32));
	SHA1STEP(c, d, e, a, b, F2, K2, M(33));
	SHA1STEP(b, c, d, e, a, F2, K2, M(34));
	SHA1STEP(a, b, c, d, e, F2, K2, M(35));
	SHA1STEP(e, a, b, c, d, F2, K2, M(36));
	SHA1STEP(d, e, a, b, c, F2, K2, M(37));
	SHA1STEP(c, d, e, a, b, F2, K2, M(38));
	SHA1STEP(b, c, d, e, a, F2, K2, M(39));
	SHA1STEP(a, b, c, d, e, F3, K3, M(40));
	SHA1STEP(e, a, b, c, d, F3, K3, M(41));
	SHA1STEP(d, e, a, b, c, F3, K3, M(42));
	SHA1STEP(c, d, e, a, b, F3, K3, M(43));
	SHA1STEP(b, c, d, e, a, F3, K3, M(44));
	SHA1STEP(a, b, c, d, e, F3, K3, M(45));
	SHA1STEP(e, a, b, c, d, F3, K3, M(46));
	SHA1STEP(d, e, a, b, c, F3, K3, M(47));
	SHA1STEP(c, d, e, a, b, F3, K3, M(48));
	SHA1STEP(b, c, d, e, a, F3, K3, M(49));
	SHA1STEP(a, b, c, d, e, F3, K3, M(50));
	SHA1STEP(e, a, b, c, d, F3, K3, M(51));
	SHA1STEP(d, e, a, b, c, F3, K3, M(52));
	SHA1STEP(c, d, e, a, b, F3, K3, M(53));
	SHA1STEP(b, c, d, e, a, F3, K3, M(54));
	SHA1STEP(a, b, c, d, e, F3, K3, M(55));
	SHA1STEP(e, a, b, c, d, F3, K3, M(56));
	SHA1STEP(d, e, a, b, c, F3, K3, M(57));
	SHA1STEP(c, d, e, a, b, F3, K3, M(58));
	SHA1STEP(b, c, d, e, a, F3, K3, M(59));
	SHA1STEP(a, b, c, d, e, F4, K4, M(60));
	SHA1STEP(e, a, b, c, d, F4, K4, M(61));
	SHA1STEP(d, e, a, b, c, F4, K4, M(62));
	SHA1STEP(c, d, e, a, b, F4, K4, M(63));
	SHA1STEP(b, c, d, e, a, F4, K4, M(64));
	SHA1STEP(a, b, c, d, e, F4, K4, M(65));
	SHA1STEP(e, a, b, c, d, F4, K4, M(66));
	SHA1STEP(d, e, a, b, c, F4, K4, M(67));
	SHA1STEP(c, d, e, a, b, F4, K4, M(68));
	SHA1STEP(b, c, d, e, a, F4, K4, M(69));
	SHA1STEP(a, b, c, d, e, F4, K4, M(70));
	SHA1STEP(e, a, b, c, d, F4, K4, M(71));
	SHA1STEP(d, e, a, b, c, F4, K4, M(72));
	SHA1STEP(c, d, e, a, b, F4, K4, M(73));
	SHA1STEP(b, c, d, e, a, F4, K4, M(74));
	SHA1STEP(a, b, c, d, e, F4, K4, M(75));
	SHA1STEP(e, a, b, c, d, F4, K4, M(76));
	SHA1STEP(d, e, a, b, c, F4, K4, M(77));
	SHA1STEP(c, d, e, a, b, F4, K4, M(78));
	SHA1STEP(b, c, d, e, a, F4, K4, M(79));

#undef F1
#undef F2
#undef F3
#undef F4

	/* Update chaining vars */
	ctx->state[0] += a;
	ctx->state[1] += b;
	ctx->state[2] += c;
	ctx->state[3] += d;
	ctx->state[4] += e;
}

/*
 * Transform the message X which consists of 16 32-bit-words (SHA-1)
 * The code is public domain taken from https://github.com/noloader/SHA-Intrinsics.
 */
MY_ENABLE_GCC_ARCH("ssse3,sse4.1,sha")
static void sha1_transform_x86(uint64_t state64[5], const uint8_t *data, size_t length)
{
	__m128i ABCD, E0, E1;
	__m128i MSG0, MSG1, MSG2, MSG3;

	const __m128i MYMASK = _mm_set_epi64x(0x0001020304050607ULL, 0x08090a0b0c0d0e0fULL);

	uint32_t state[5] = {
		(uint32_t)state64[0],
		(uint32_t)state64[1],
		(uint32_t)state64[2],
		(uint32_t)state64[3],
		(uint32_t)state64[4]
	};

	/* Load initial values */
	ABCD = _mm_loadu_si128((const __m128i*) state);
	E0 = _mm_set_epi32(state[4], 0, 0, 0);
	ABCD = _mm_shuffle_epi32(ABCD, 0x1B);

	while (length >= SHA1_BLOCKSIZE)
	{
		/* Save current state  */
		const __m128i ABCD_SAVE = ABCD;
		const __m128i E0_SAVE = E0;

		/* Rounds 0-3 */
		MSG0 = _mm_loadu_si128((const __m128i*)(data + 0));
		MSG0 = _mm_shuffle_epi8(MSG0, MYMASK);
		E0 = _mm_add_epi32(E0, MSG0);
		E1 = ABCD;
		ABCD = _mm_sha1rnds4_epu32(ABCD, E0, 0);

		/* Rounds 4-7 */
		MSG1 = _mm_loadu_si128((const __m128i*)(data + 16));
		MSG1 = _mm_shuffle_epi8(MSG1, MYMASK);
		E1 = _mm_sha1nexte_epu32(E1, MSG1);
		E0 = ABCD;
		ABCD = _mm_sha1rnds4_epu32(ABCD, E1, 0);
		MSG0 = _mm_sha1msg1_epu32(MSG0, MSG1);

		/* Rounds 8-11 */
		MSG2 = _mm_loadu_si128((const __m128i*)(data + 32));
		MSG2 = _mm_shuffle_epi8(MSG2, MYMASK);
		E0 = _mm_sha1nexte_epu32(E0, MSG2);
		E1 = ABCD;
		ABCD = _mm_sha1rnds4_epu32(ABCD, E0, 0);
		MSG1 = _mm_sha1msg1_epu32(MSG1, MSG2);
		MSG0 = _mm_xor_si128(MSG0, MSG2);

		/* Rounds 12-15 */
		MSG3 = _mm_loadu_si128((const __m128i*)(data + 48));
		MSG3 = _mm_shuffle_epi8(MSG3, MYMASK);
		E1 = _mm_sha1nexte_epu32(E1, MSG3);
		E0 = ABCD;
		MSG0 = _mm_sha1msg2_epu32(MSG0, MSG3);
		ABCD = _mm_sha1rnds4_epu32(ABCD, E1, 0);
		MSG2 = _mm_sha1msg1_epu32(MSG2, MSG3);
		MSG1 = _mm_xor_si128(MSG1, MSG3);

		/* Rounds 16-19 */
		E0 = _mm_sha1nexte_epu32(E0, MSG0);
		E1 = ABCD;
		MSG1 = _mm_sha1msg2_epu32(MSG1, MSG0);
		ABCD = _mm_sha1rnds4_epu32(ABCD, E0, 0);
		MSG3 = _mm_sha1msg1_epu32(MSG3, MSG0);
		MSG2 = _mm_xor_si128(MSG2, MSG0);

		/* Rounds 20-23 */
		E1 = _mm_sha1nexte_epu32(E1, MSG1);
		E0 = ABCD;
		MSG2 = _mm_sha1msg2_epu32(MSG2, MSG1);
		ABCD = _mm_sha1rnds4_epu32(ABCD, E1, 1);
		MSG0 = _mm_sha1msg1_epu32(MSG0, MSG1);
		MSG3 = _mm_xor_si128(MSG3, MSG1);

		/* Rounds 24-27 */
		E0 = _mm_sha1nexte_epu32(E0, MSG2);
		E1 = ABCD;
		MSG3 = _mm_sha1msg2_epu32(MSG3, MSG2);
		ABCD = _mm_sha1rnds4_epu32(ABCD, E0, 1);
		MSG1 = _mm_sha1msg1_epu32(MSG1, MSG2);
		MSG0 = _mm_xor_si128(MSG0, MSG2);

		/* Rounds 28-31 */
		E1 = _mm_sha1nexte_epu32(E1, MSG3);
		E0 = ABCD;
		MSG0 = _mm_sha1msg2_epu32(MSG0, MSG3);
		ABCD = _mm_sha1rnds4_epu32(ABCD, E1, 1);
		MSG2 = _mm_sha1msg1_epu32(MSG2, MSG3);
		MSG1 = _mm_xor_si128(MSG1, MSG3);

		/* Rounds 32-35 */
		E0 = _mm_sha1nexte_epu32(E0, MSG0);
		E1 = ABCD;
		MSG1 = _mm_sha1msg2_epu32(MSG1, MSG0);
		ABCD = _mm_sha1rnds4_epu32(ABCD, E0, 1);
		MSG3 = _mm_sha1msg1_epu32(MSG3, MSG0);
		MSG2 = _mm_xor_si128(MSG2, MSG0);

		/* Rounds 36-39 */
		E1 = _mm_sha1nexte_epu32(E1, MSG1);
		E0 = ABCD;
		MSG2 = _mm_sha1msg2_epu32(MSG2, MSG1);
		ABCD = _mm_sha1rnds4_epu32(ABCD, E1, 1);
		MSG0 = _mm_sha1msg1_epu32(MSG0, MSG1);
		MSG3 = _mm_xor_si128(MSG3, MSG1);

		/* Rounds 40-43 */
		E0 = _mm_sha1nexte_epu32(E0, MSG2);
		E1 = ABCD;
		MSG3 = _mm_sha1msg2_epu32(MSG3, MSG2);
		ABCD = _mm_sha1rnds4_epu32(ABCD, E0, 2);
		MSG1 = _mm_sha1msg1_epu32(MSG1, MSG2);
		MSG0 = _mm_xor_si128(MSG0, MSG2);

		/* Rounds 44-47 */
		E1 = _mm_sha1nexte_epu32(E1, MSG3);
		E0 = ABCD;
		MSG0 = _mm_sha1msg2_epu32(MSG0, MSG3);
		ABCD = _mm_sha1rnds4_epu32(ABCD, E1, 2);
		MSG2 = _mm_sha1msg1_epu32(MSG2, MSG3);
		MSG1 = _mm_xor_si128(MSG1, MSG3);

		/* Rounds 48-51 */
		E0 = _mm_sha1nexte_epu32(E0, MSG0);
		E1 = ABCD;
		MSG1 = _mm_sha1msg2_epu32(MSG1, MSG0);
		ABCD = _mm_sha1rnds4_epu32(ABCD, E0, 2);
		MSG3 = _mm_sha1msg1_epu32(MSG3, MSG0);
		MSG2 = _mm_xor_si128(MSG2, MSG0);

		/* Rounds 52-55 */
		E1 = _mm_sha1nexte_epu32(E1, MSG1);
		E0 = ABCD;
		MSG2 = _mm_sha1msg2_epu32(MSG2, MSG1);
		ABCD = _mm_sha1rnds4_epu32(ABCD, E1, 2);
		MSG0 = _mm_sha1msg1_epu32(MSG0, MSG1);
		MSG3 = _mm_xor_si128(MSG3, MSG1);

		/* Rounds 56-59 */
		E0 = _mm_sha1nexte_epu32(E0, MSG2);
		E1 = ABCD;
		MSG3 = _mm_sha1msg2_epu32(MSG3, MSG2);
		ABCD = _mm_sha1rnds4_epu32(ABCD, E0, 2);
		MSG1 = _mm_sha1msg1_epu32(MSG1, MSG2);
		MSG0 = _mm_xor_si128(MSG0, MSG2);

		/* Rounds 60-63 */
		E1 = _mm_sha1nexte_epu32(E1, MSG3);
		E0 = ABCD;
		MSG0 = _mm_sha1msg2_epu32(MSG0, MSG3);
		ABCD = _mm_sha1rnds4_epu32(ABCD, E1, 3);
		MSG2 = _mm_sha1msg1_epu32(MSG2, MSG3);
		MSG1 = _mm_xor_si128(MSG1, MSG3);

		/* Rounds 64-67 */
		E0 = _mm_sha1nexte_epu32(E0, MSG0);
		E1 = ABCD;
		MSG1 = _mm_sha1msg2_epu32(MSG1, MSG0);
		ABCD = _mm_sha1rnds4_epu32(ABCD, E0, 3);
		MSG3 = _mm_sha1msg1_epu32(MSG3, MSG0);
		MSG2 = _mm_xor_si128(MSG2, MSG0);

		/* Rounds 68-71 */
		E1 = _mm_sha1nexte_epu32(E1, MSG1);
		E0 = ABCD;
		MSG2 = _mm_sha1msg2_epu32(MSG2, MSG1);
		ABCD = _mm_sha1rnds4_epu32(ABCD, E1, 3);
		MSG3 = _mm_xor_si128(MSG3, MSG1);

		/* Rounds 72-75 */
		E0 = _mm_sha1nexte_epu32(E0, MSG2);
		E1 = ABCD;
		MSG3 = _mm_sha1msg2_epu32(MSG3, MSG2);
		ABCD = _mm_sha1rnds4_epu32(ABCD, E0, 3);

		/* Rounds 76-79 */
		E1 = _mm_sha1nexte_epu32(E1, MSG3);
		E0 = ABCD;
		ABCD = _mm_sha1rnds4_epu32(ABCD, E1, 3);

		/* Combine state */
		E0 = _mm_sha1nexte_epu32(E0, E0_SAVE);
		ABCD = _mm_add_epi32(ABCD, ABCD_SAVE);

		data += 64;
		length -= 64;
	}

	/* Save state */
	ABCD = _mm_shuffle_epi32(ABCD, 0x1B);
	_mm_storeu_si128((__m128i*) state, ABCD);
	state[4] = _mm_extract_epi32(E0, 3);

	/* Repack into uint64_t. */
	state64[0] = state[0];
	state64[1] = state[1];
	state64[2] = state[2];
	state64[3] = state[3];
	state64[4] = state[4];
}

/* Transform the message X which consists of 16 32-bit-words (SHA-1) */
static void sha1_transform(SUM_CONTEXT *ctx, const uint8_t *data)
{
	if (flaghw)
		sha1_transform_x86(ctx->state, data, SHA1_BLOCKSIZE);
	else
		sha1_transform_cc(ctx, data);
}

/* Transform the message X which consists of 16 32-bit-words (SHA-256) */
static __inline void sha256_transform_cc(SUM_CONTEXT *ctx, const uint8_t *data)
{
	uint32_t a, b, c, d, e, f, g, h, j, x[16];

	a = (uint32_t)ctx->state[0];
	b = (uint32_t)ctx->state[1];
	c = (uint32_t)ctx->state[2];
	d = (uint32_t)ctx->state[3];
	e = (uint32_t)ctx->state[4];
	f = (uint32_t)ctx->state[5];
	g = (uint32_t)ctx->state[6];
	h = (uint32_t)ctx->state[7];

// Nesting the ROR allows for single register compiler optimizations
#define S0(x) (ROR32(ROR32(ROR32(x,9)^(x),11)^(x),2))	// Σ0 (Sigma 0)
#define S1(x) (ROR32(ROR32(ROR32(x,14)^(x),5)^(x),6))	// Σ1 (Sigma 1)
#define s0(x) (ROR32(ROR32(x,11)^(x),7)^((x)>>3))		// σ0 (sigma 0)
#define s1(x) (ROR32(ROR32(x,2)^(x),17)^((x)>>10))		// σ1 (sigma 1)
#define BLK0(i) (x[i])
#define BLK2(i) (x[i] += s1(x[((i)-2)&15]) + x[((i)-7)&15] + s0(x[((i)-15)&15]))
#define R(a, b, c, d, e, f, g, h, i) \
	h += S1(e) + Ch(e,f,g) + K256[(i)+(j)] + (j ? BLK2(i) : BLK0(i)); \
	d += h; \
	h += S0(a) + Ma(a, b, c)
#define RX_8(i) \
	R(a, b, c, d, e, f, g, h, i);   \
	R(h, a, b, c, d, e, f, g, i+1); \
	R(g, h, a, b, c, d, e, f, i+2); \
	R(f, g, h, a, b, c, d, e, i+3); \
	R(e, f, g, h, a, b, c, d, i+4); \
	R(d, e, f, g, h, a, b, c, i+5); \
	R(c, d, e, f, g, h, a, b, i+6); \
	R(b, c, d, e, f, g, h, a, i+7)

#ifdef BIG
	memcpy(x, data, sizeof(x));
#else
	{
		uint32_t k;
		for (k = 0; k < 16; k += 4) {
			const uint8_t* p2 = data + k * 4;
			x[k] = read_swap32(p2);
			x[k + 1] = read_swap32(p2 + 4);
			x[k + 2] = read_swap32(p2 + 8);
			x[k + 3] = read_swap32(p2 + 12);
		}
	}
#endif // corresponds to #ifdef (#ifdef BIG)

	for (j = 0; j < 64; j += 16) {
		RX_8(0);
		RX_8(8);
	}

#undef S0
#undef S1
#undef s0
#undef s1
#undef BLK0
#undef BLK2
#undef R
#undef RX_8

	ctx->state[0] += a;
	ctx->state[1] += b;
	ctx->state[2] += c;
	ctx->state[3] += d;
	ctx->state[4] += e;
	ctx->state[5] += f;
	ctx->state[6] += g;
	ctx->state[7] += h;
}

/*
 * Transform the message X which consists of 16 32-bit-words (SHA-256)
 * The code is public domain taken from https://github.com/noloader/SHA-Intrinsics.
 */
MY_ENABLE_GCC_ARCH("ssse3,sse4.1,sha")
static __inline void sha256_transform_x86(uint64_t state64[8], const uint8_t *data, size_t length)
{
	__m128i STATE0, STATE1;
	__m128i MSG, TMP;
	__m128i MSG0, MSG1, MSG2, MSG3;
	const __m128i MYMASK = _mm_set_epi64x(0x0c0d0e0f08090a0bULL, 0x0405060700010203ULL);

	uint32_t state[8] = {
		(uint32_t)state64[0],
		(uint32_t)state64[1],
		(uint32_t)state64[2],
		(uint32_t)state64[3],
		(uint32_t)state64[4],
		(uint32_t)state64[5],
		(uint32_t)state64[6],
		(uint32_t)state64[7]
	};

	/* Load initial values */
	TMP = _mm_loadu_si128((const __m128i*) (state+0));
	STATE1 = _mm_loadu_si128((const __m128i*) (state+4));

	TMP = _mm_shuffle_epi32(TMP, 0xB1);          /* CDAB */
	STATE1 = _mm_shuffle_epi32(STATE1, 0x1B);    /* EFGH */
	STATE0 = _mm_alignr_epi8(TMP, STATE1, 8);    /* ABEF */
	STATE1 = _mm_blend_epi16(STATE1, TMP, 0xF0); /* CDGH */

	while (length >= SHA256_BLOCKSIZE)
	{
		/* Save current state */
		const __m128i ABEF_SAVE = STATE0;
		const __m128i CDGH_SAVE = STATE1;

		/* Rounds 0-3 */
		MSG = _mm_loadu_si128((const __m128i*) (data+0));
		MSG0 = _mm_shuffle_epi8(MSG, MYMASK);
		MSG = _mm_add_epi32(MSG0, _mm_set_epi64x(0xE9B5DBA5B5C0FBCFULL, 0x71374491428A2F98ULL));
		STATE1 = _mm_sha256rnds2_epu32(STATE1, STATE0, MSG);
		MSG = _mm_shuffle_epi32(MSG, 0x0E);
		STATE0 = _mm_sha256rnds2_epu32(STATE0, STATE1, MSG);

		/* Rounds 4-7 */
		MSG1 = _mm_loadu_si128((const __m128i*) (data+16));
		MSG1 = _mm_shuffle_epi8(MSG1, MYMASK);
		MSG = _mm_add_epi32(MSG1, _mm_set_epi64x(0xAB1C5ED5923F82A4ULL, 0x59F111F13956C25BULL));
		STATE1 = _mm_sha256rnds2_epu32(STATE1, STATE0, MSG);
		MSG = _mm_shuffle_epi32(MSG, 0x0E);
		STATE0 = _mm_sha256rnds2_epu32(STATE0, STATE1, MSG);
		MSG0 = _mm_sha256msg1_epu32(MSG0, MSG1);

		/* Rounds 8-11 */
		MSG2 = _mm_loadu_si128((const __m128i*) (data+32));
		MSG2 = _mm_shuffle_epi8(MSG2, MYMASK);
		MSG = _mm_add_epi32(MSG2, _mm_set_epi64x(0x550C7DC3243185BEULL, 0x12835B01D807AA98ULL));
		STATE1 = _mm_sha256rnds2_epu32(STATE1, STATE0, MSG);
		MSG = _mm_shuffle_epi32(MSG, 0x0E);
		STATE0 = _mm_sha256rnds2_epu32(STATE0, STATE1, MSG);
		MSG1 = _mm_sha256msg1_epu32(MSG1, MSG2);

		/* Rounds 12-15 */
		MSG3 = _mm_loadu_si128((const __m128i*) (data+48));
		MSG3 = _mm_shuffle_epi8(MSG3, MYMASK);
		MSG = _mm_add_epi32(MSG3, _mm_set_epi64x(0xC19BF1749BDC06A7ULL, 0x80DEB1FE72BE5D74ULL));
		STATE1 = _mm_sha256rnds2_epu32(STATE1, STATE0, MSG);
		TMP = _mm_alignr_epi8(MSG3, MSG2, 4);
		MSG0 = _mm_add_epi32(MSG0, TMP);
		MSG0 = _mm_sha256msg2_epu32(MSG0, MSG3);
		MSG = _mm_shuffle_epi32(MSG, 0x0E);
		STATE0 = _mm_sha256rnds2_epu32(STATE0, STATE1, MSG);
		MSG2 = _mm_sha256msg1_epu32(MSG2, MSG3);

		/* Rounds 16-19 */
		MSG = _mm_add_epi32(MSG0, _mm_set_epi64x(0x240CA1CC0FC19DC6ULL, 0xEFBE4786E49B69C1ULL));
		STATE1 = _mm_sha256rnds2_epu32(STATE1, STATE0, MSG);
		TMP = _mm_alignr_epi8(MSG0, MSG3, 4);
		MSG1 = _mm_add_epi32(MSG1, TMP);
		MSG1 = _mm_sha256msg2_epu32(MSG1, MSG0);
		MSG = _mm_shuffle_epi32(MSG, 0x0E);
		STATE0 = _mm_sha256rnds2_epu32(STATE0, STATE1, MSG);
		MSG3 = _mm_sha256msg1_epu32(MSG3, MSG0);

		/* Rounds 20-23 */
		MSG = _mm_add_epi32(MSG1, _mm_set_epi64x(0x76F988DA5CB0A9DCULL, 0x4A7484AA2DE92C6FULL));
		STATE1 = _mm_sha256rnds2_epu32(STATE1, STATE0, MSG);
		TMP = _mm_alignr_epi8(MSG1, MSG0, 4);
		MSG2 = _mm_add_epi32(MSG2, TMP);
		MSG2 = _mm_sha256msg2_epu32(MSG2, MSG1);
		MSG = _mm_shuffle_epi32(MSG, 0x0E);
		STATE0 = _mm_sha256rnds2_epu32(STATE0, STATE1, MSG);
		MSG0 = _mm_sha256msg1_epu32(MSG0, MSG1);

		/* Rounds 24-27 */
		MSG = _mm_add_epi32(MSG2, _mm_set_epi64x(0xBF597FC7B00327C8ULL, 0xA831C66D983E5152ULL));
		STATE1 = _mm_sha256rnds2_epu32(STATE1, STATE0, MSG);
		TMP = _mm_alignr_epi8(MSG2, MSG1, 4);
		MSG3 = _mm_add_epi32(MSG3, TMP);
		MSG3 = _mm_sha256msg2_epu32(MSG3, MSG2);
		MSG = _mm_shuffle_epi32(MSG, 0x0E);
		STATE0 = _mm_sha256rnds2_epu32(STATE0, STATE1, MSG);
		MSG1 = _mm_sha256msg1_epu32(MSG1, MSG2);

		/* Rounds 28-31 */
		MSG = _mm_add_epi32(MSG3, _mm_set_epi64x(0x1429296706CA6351ULL,  0xD5A79147C6E00BF3ULL));
		STATE1 = _mm_sha256rnds2_epu32(STATE1, STATE0, MSG);
		TMP = _mm_alignr_epi8(MSG3, MSG2, 4);
		MSG0 = _mm_add_epi32(MSG0, TMP);
		MSG0 = _mm_sha256msg2_epu32(MSG0, MSG3);
		MSG = _mm_shuffle_epi32(MSG, 0x0E);
		STATE0 = _mm_sha256rnds2_epu32(STATE0, STATE1, MSG);
		MSG2 = _mm_sha256msg1_epu32(MSG2, MSG3);

		/* Rounds 32-35 */
		MSG = _mm_add_epi32(MSG0, _mm_set_epi64x(0x53380D134D2C6DFCULL, 0x2E1B213827B70A85ULL));
		STATE1 = _mm_sha256rnds2_epu32(STATE1, STATE0, MSG);
		TMP = _mm_alignr_epi8(MSG0, MSG3, 4);
		MSG1 = _mm_add_epi32(MSG1, TMP);
		MSG1 = _mm_sha256msg2_epu32(MSG1, MSG0);
		MSG = _mm_shuffle_epi32(MSG, 0x0E);
		STATE0 = _mm_sha256rnds2_epu32(STATE0, STATE1, MSG);
		MSG3 = _mm_sha256msg1_epu32(MSG3, MSG0);

		/* Rounds 36-39 */
		MSG = _mm_add_epi32(MSG1, _mm_set_epi64x(0x92722C8581C2C92EULL, 0x766A0ABB650A7354ULL));
		STATE1 = _mm_sha256rnds2_epu32(STATE1, STATE0, MSG);
		TMP = _mm_alignr_epi8(MSG1, MSG0, 4);
		MSG2 = _mm_add_epi32(MSG2, TMP);
		MSG2 = _mm_sha256msg2_epu32(MSG2, MSG1);
		MSG = _mm_shuffle_epi32(MSG, 0x0E);
		STATE0 = _mm_sha256rnds2_epu32(STATE0, STATE1, MSG);
		MSG0 = _mm_sha256msg1_epu32(MSG0, MSG1);

		/* Rounds 40-43 */
		MSG = _mm_add_epi32(MSG2, _mm_set_epi64x(0xC76C51A3C24B8B70ULL, 0xA81A664BA2BFE8A1ULL));
		STATE1 = _mm_sha256rnds2_epu32(STATE1, STATE0, MSG);
		TMP = _mm_alignr_epi8(MSG2, MSG1, 4);
		MSG3 = _mm_add_epi32(MSG3, TMP);
		MSG3 = _mm_sha256msg2_epu32(MSG3, MSG2);
		MSG = _mm_shuffle_epi32(MSG, 0x0E);
		STATE0 = _mm_sha256rnds2_epu32(STATE0, STATE1, MSG);
		MSG1 = _mm_sha256msg1_epu32(MSG1, MSG2);

		/* Rounds 44-47 */
		MSG = _mm_add_epi32(MSG3, _mm_set_epi64x(0x106AA070F40E3585ULL, 0xD6990624D192E819ULL));
		STATE1 = _mm_sha256rnds2_epu32(STATE1, STATE0, MSG);
		TMP = _mm_alignr_epi8(MSG3, MSG2, 4);
		MSG0 = _mm_add_epi32(MSG0, TMP);
		MSG0 = _mm_sha256msg2_epu32(MSG0, MSG3);
		MSG = _mm_shuffle_epi32(MSG, 0x0E);
		STATE0 = _mm_sha256rnds2_epu32(STATE0, STATE1, MSG);
		MSG2 = _mm_sha256msg1_epu32(MSG2, MSG3);

		/* Rounds 48-51 */
		MSG = _mm_add_epi32(MSG0, _mm_set_epi64x(0x34B0BCB52748774CULL, 0x1E376C0819A4C116ULL));
		STATE1 = _mm_sha256rnds2_epu32(STATE1, STATE0, MSG);
		TMP = _mm_alignr_epi8(MSG0, MSG3, 4);
		MSG1 = _mm_add_epi32(MSG1, TMP);
		MSG1 = _mm_sha256msg2_epu32(MSG1, MSG0);
		MSG = _mm_shuffle_epi32(MSG, 0x0E);
		STATE0 = _mm_sha256rnds2_epu32(STATE0, STATE1, MSG);
		MSG3 = _mm_sha256msg1_epu32(MSG3, MSG0);

		/* Rounds 52-55 */
		MSG = _mm_add_epi32(MSG1, _mm_set_epi64x(0x682E6FF35B9CCA4FULL, 0x4ED8AA4A391C0CB3ULL));
		STATE1 = _mm_sha256rnds2_epu32(STATE1, STATE0, MSG);
		TMP = _mm_alignr_epi8(MSG1, MSG0, 4);
		MSG2 = _mm_add_epi32(MSG2, TMP);
		MSG2 = _mm_sha256msg2_epu32(MSG2, MSG1);
		MSG = _mm_shuffle_epi32(MSG, 0x0E);
		STATE0 = _mm_sha256rnds2_epu32(STATE0, STATE1, MSG);

		/* Rounds 56-59 */
		MSG = _mm_add_epi32(MSG2, _mm_set_epi64x(0x8CC7020884C87814ULL, 0x78A5636F748F82EEULL));
		STATE1 = _mm_sha256rnds2_epu32(STATE1, STATE0, MSG);
		TMP = _mm_alignr_epi8(MSG2, MSG1, 4);
		MSG3 = _mm_add_epi32(MSG3, TMP);
		MSG3 = _mm_sha256msg2_epu32(MSG3, MSG2);
		MSG = _mm_shuffle_epi32(MSG, 0x0E);
		STATE0 = _mm_sha256rnds2_epu32(STATE0, STATE1, MSG);

		/* Rounds 60-63 */
		MSG = _mm_add_epi32(MSG3, _mm_set_epi64x(0xC67178F2BEF9A3F7ULL, 0xA4506CEB90BEFFFAULL));
		STATE1 = _mm_sha256rnds2_epu32(STATE1, STATE0, MSG);
		MSG = _mm_shuffle_epi32(MSG, 0x0E);
		STATE0 = _mm_sha256rnds2_epu32(STATE0, STATE1, MSG);

		/* Combine state  */
		STATE0 = _mm_add_epi32(STATE0, ABEF_SAVE);
		STATE1 = _mm_add_epi32(STATE1, CDGH_SAVE);

		data += 64;
		length -= 64;
	}

	TMP = _mm_shuffle_epi32(STATE0, 0x1B);       /* FEBA */
	STATE1 = _mm_shuffle_epi32(STATE1, 0xB1);    /* DCHG */
	STATE0 = _mm_blend_epi16(TMP, STATE1, 0xF0); /* DCBA */
	STATE1 = _mm_alignr_epi8(STATE1, TMP, 8);    /* ABEF */

	/* Save state */
	_mm_storeu_si128((__m128i*) (state+0), STATE0);
	_mm_storeu_si128((__m128i*) (state+4), STATE1);

	/* Repack into uint64_t. */
	state64[0] = state[0];
	state64[1] = state[1];
	state64[2] = state[2];
	state64[3] = state[3];
	state64[4] = state[4];
	state64[5] = state[5];
	state64[6] = state[6];
	state64[7] = state[7];
}

static __inline void sha256_transform(SUM_CONTEXT *ctx, const uint8_t *data)
{
	if (flaghw)
		sha256_transform_x86(ctx->state, data, SHA256_BLOCKSIZE);
	else
		sha256_transform_cc(ctx, data);
}



/* Update the message digest with the contents of the buffer (SHA-1) */
static void sha1_write(SUM_CONTEXT *ctx, const uint8_t *buf, size_t len)
{
	size_t num = ctx->bytecount & (SHA1_BLOCKSIZE - 1);

	/* Update bytecount */
	ctx->bytecount += len;

	/* Handle any leading odd-sized chunks */
	if (num) {
		uint8_t *p = ctx->buf + num;

		num = SHA1_BLOCKSIZE - num;
		if (len < num) {
			memcpy(p, buf, len);
			return;
		}
		memcpy(p, buf, num);
		sha1_transform(ctx, ctx->buf);
		buf += num;
		len -= num;
	}

	if (flaghw)
	{
		/* Process all full blocks at once */
		if (len >= SHA1_BLOCKSIZE) {
			/* Calculate full blocks, in bytes */
			num = (len / SHA1_BLOCKSIZE) * SHA1_BLOCKSIZE;
			/* SHA-1 acceleration using intrinsics */
			sha1_transform_x86(ctx->state, buf, num);
			buf += num;
			len -= num;
		}
	}
	else
	{
		/* Process data in blocksize chunks */
		while (len >= SHA1_BLOCKSIZE) {
			PREFETCH64(buf + SHA1_BLOCKSIZE);
			sha1_transform(ctx, buf);
			buf += SHA1_BLOCKSIZE;
			len -= SHA1_BLOCKSIZE;
		}
	}

	/* Handle any remaining bytes of data. */
	memcpy(ctx->buf, buf, len);
}

/* Update the message digest with the contents of the buffer (SHA-256) */
static void sha256_write(SUM_CONTEXT *ctx, const uint8_t *buf, size_t len)
{
	size_t num = ctx->bytecount & (SHA256_BLOCKSIZE - 1);

	/* Update bytecount */
	ctx->bytecount += len;

	/* Handle any leading odd-sized chunks */
	if (num) {
		uint8_t *p = ctx->buf + num;

		num = SHA256_BLOCKSIZE - num;
		if (len < num) {
			memcpy(p, buf, len);
			return;
		}
		memcpy(p, buf, num);
		sha256_transform(ctx, ctx->buf);
		buf += num;
		len -= num;
	}

	if (flaghw)
	{
		/* Process all full blocks at once */
		if (len >= SHA256_BLOCKSIZE) {
			/* Calculate full blocks, in bytes */
			num = (len / SHA256_BLOCKSIZE) * SHA256_BLOCKSIZE;
			/* SHA-256 acceleration using intrinsics */
			sha256_transform_x86(ctx->state, buf, num);
			buf += num;
			len -= num;
		}
	}
	else
	{
		/* Process data in blocksize chunks */
		while (len >= SHA256_BLOCKSIZE) {
			PREFETCH64(buf + SHA256_BLOCKSIZE);
			sha256_transform(ctx, buf);
			buf += SHA256_BLOCKSIZE;
			len -= SHA256_BLOCKSIZE;
		}
	}

	/* Handle any remaining bytes of data. */
	memcpy(ctx->buf, buf, len);
}

/* Finalize the computation and write the digest in ctx->state[] (SHA-1) */
static void sha1_final(SUM_CONTEXT *ctx)
{
	size_t pos = ((size_t)ctx->bytecount) & (SHA1_BLOCKSIZE - 1);
	uint64_t bitcount = ctx->bytecount << 3;
	uint8_t *p;

	ctx->buf[pos++] = 0x80;

	/* Pad whatever data is left in the buffer */
	while (pos != (SHA1_BLOCKSIZE - sizeof(uint64_t))) {
		pos &= (SHA1_BLOCKSIZE - 1);
		if (pos == 0)
			sha1_transform(ctx, ctx->buf);
		ctx->buf[pos++] = 0;
	}

	/* Append to the padding the total message's length in bits and transform */
	ctx->buf[SHA1_BLOCKSIZE - 1] = (uint8_t) bitcount;
	ctx->buf[SHA1_BLOCKSIZE - 2] = (uint8_t) (bitcount >> 8);
	ctx->buf[SHA1_BLOCKSIZE - 3] = (uint8_t) (bitcount >> 16);
	ctx->buf[SHA1_BLOCKSIZE - 4] = (uint8_t) (bitcount >> 24);
	ctx->buf[SHA1_BLOCKSIZE - 5] = (uint8_t) (bitcount >> 32);
	ctx->buf[SHA1_BLOCKSIZE - 6] = (uint8_t) (bitcount >> 40);
	ctx->buf[SHA1_BLOCKSIZE - 7] = (uint8_t) (bitcount >> 48);
	ctx->buf[SHA1_BLOCKSIZE - 8] = (uint8_t) (bitcount >> 56);

	sha1_transform(ctx, ctx->buf);

	p = ctx->buf;
#ifdef BIG
#define X(a) do { *(uint32_t*)p = (uint32_t)ctx->state[a]; p += 4; } while(0)
#else
#define X(a) do { write_swap32(p, (uint32_t)ctx->state[a]); p += 4; } while(0);
#endif // corresponds to #ifdef (#ifdef BIG)
	X(0);
	X(1);
	X(2);
	X(3);
	X(4);
#undef X
}

/* Finalize the computation and write the digest in ctx->state[] (SHA-256) */
static void sha256_final(SUM_CONTEXT *ctx)
{
	size_t pos = ((size_t)ctx->bytecount) & (SHA256_BLOCKSIZE - 1);
	uint64_t bitcount = ctx->bytecount << 3;
	uint8_t *p;

	ctx->buf[pos++] = 0x80;

	/* Pad whatever data is left in the buffer */
	while (pos != (SHA256_BLOCKSIZE - sizeof(uint64_t))) {
		pos &= (SHA256_BLOCKSIZE - 1);
		if (pos == 0)
			sha256_transform(ctx, ctx->buf);
		ctx->buf[pos++] = 0;
	}

	/* Append to the padding the total message's length in bits and transform */
	ctx->buf[SHA256_BLOCKSIZE - 1] = (uint8_t) bitcount;
	ctx->buf[SHA256_BLOCKSIZE - 2] = (uint8_t) (bitcount >> 8);
	ctx->buf[SHA256_BLOCKSIZE - 3] = (uint8_t) (bitcount >> 16);
	ctx->buf[SHA256_BLOCKSIZE - 4] = (uint8_t) (bitcount >> 24);
	ctx->buf[SHA256_BLOCKSIZE - 5] = (uint8_t) (bitcount >> 32);
	ctx->buf[SHA256_BLOCKSIZE - 6] = (uint8_t) (bitcount >> 40);
	ctx->buf[SHA256_BLOCKSIZE - 7] = (uint8_t) (bitcount >> 48);
	ctx->buf[SHA256_BLOCKSIZE - 8] = (uint8_t) (bitcount >> 56);

	sha256_transform(ctx, ctx->buf);

	p = ctx->buf;
#ifdef BIG
#define X(a) do { *(uint32_t*)p = (uint32_t)ctx->state[a]; p += 4; } while(0)
#else
#define X(a) do { write_swap32(p, (uint32_t)ctx->state[a]); p += 4; } while(0);
#endif // corresponds to #ifdef (#ifdef BIG)
	X(0);
	X(1);
	X(2);
	X(3);
	X(4);
	X(5);
	X(6);
	X(7);
#undef X
}
#endif // corresponds to #ifdef (#ifdef HWSHA2)

/// LICENSE_END.20




/// LICENSE_START.5
#ifdef HWSHA1
/*
	This is SHA1 via linked asm (Windows only)
*/
#define MY_ALIGN(n) __attribute__ ((aligned(n)))
#define MY_NO_INLINE __attribute__((noinline))
#define MY_FAST_CALL
typedef unsigned char 			Byte;
typedef short 					Int16;
typedef int 					Int32;
typedef long long int 			Int64;
typedef unsigned short 			UInt16;
typedef unsigned int 			UInt32;
typedef unsigned long long int 	UInt64;
typedef int 					BoolInt;
#define SHA1_NUM_BLOCK_WORDS  16
#define SHA1_NUM_DIGEST_WORDS  5
#define SHA1_BLOCK_SIZE   (SHA1_NUM_BLOCK_WORDS * 4)
typedef void (MY_FAST_CALL *SHA1_FUNC_UPDATE_BLOCKS)(UInt32 state[5], const Byte *data, size_t numBlocks);

typedef struct
{
  SHA1_FUNC_UPDATE_BLOCKS func_UpdateBlocks;
  UInt64 count;
  UInt64 __pad_2[2];
  UInt32 state[SHA1_NUM_DIGEST_WORDS];
  UInt32 __pad_3[3];
  Byte buffer[SHA1_BLOCK_SIZE];
} CSha1;

void Sha1Prepare(bool i_flaghardware=false);
void Sha1_InitState(CSha1 *p);
void Sha1_Init(CSha1 *p);
void Sha1_Update(CSha1 *p, const Byte *data, size_t size);
void Sha1_Final			(CSha1 *p, Byte *digest);
void Sha1_PrepareBlock(const CSha1 *p, Byte *block, unsigned size);
void Sha1_GetBlockDigest(const CSha1 *p, const Byte *data, Byte *destDigest);
void MY_FAST_CALL Sha1_UpdateBlocks(UInt32 state[5], const Byte *data, size_t numBlocks);
extern "C" void MY_FAST_CALL Sha1_UpdateBlocks_HW(UInt32 state[5], const Byte *data, size_t numBlocks);
static SHA1_FUNC_UPDATE_BLOCKS g_FUNC_UPDATE_BLOCKS = Sha1_UpdateBlocks;
static SHA1_FUNC_UPDATE_BLOCKS g_FUNC_UPDATE_BLOCKS_HW;

#define rotlFixed(x, n) (((x) << (n)) | ((x) >> (32 - (n))))
#define rotrFixed(x, n) (((x) >> (n)) | ((x) << (32 - (n))))

#define STEP_PRE  20
#define STEP_MAIN 20
#define kNumW 16
#define w(i) W[(i)&15]

#define w0(i) (W[i] = GetBe32(data + (size_t)(i) * 4))
#define w1(i) (w(i) = rotlFixed(w((size_t)(i)-3) ^ w((size_t)(i)-8) ^ w((size_t)(i)-14) ^ w((size_t)(i)-16), 1))

#define sha1_f0(x,y,z)  ( 0x5a827999 + (z^(x&(y^z))) )
#define sha1_f1(x,y,z)  ( 0x6ed9eba1 + (x^y^z) )
#define sha1_f2(x,y,z)  ( 0x8f1bbcdc + ((x&y)|(z&(x|y))) )
#define sha1_f3(x,y,z)  ( 0xca62c1d6 + (x^y^z) )

#define T5(a,b,c,d,e, fx, ww) \
    e += fx(b,c,d) + ww + rotlFixed(a, 5); \
    b = rotlFixed(b, 30); \

#define M5(i, fx, wx0, wx1) \
    T5 ( a,b,c,d,e, fx, wx0((i)  ) ); \
    T5 ( e,a,b,c,d, fx, wx1((i)+1) ); \
    T5 ( d,e,a,b,c, fx, wx1((i)+2) ); \
    T5 ( c,d,e,a,b, fx, wx1((i)+3) ); \
    T5 ( b,c,d,e,a, fx, wx1((i)+4) ); \

#define R5(i, fx, wx) \
    M5 ( i, fx, wx, wx) \


#if STEP_PRE > 5

  #define R20_START \
    R5 (  0, sha1_f0, w0); \
    R5 (  5, sha1_f0, w0); \
    R5 ( 10, sha1_f0, w0); \
    M5 ( 15, sha1_f0, w0, w1); \

  #elif STEP_PRE == 5

  #define R20_START \
    { size_t i; for (i = 0; i < 15; i += STEP_PRE) \
      { R5(i, sha1_f0, w0); } } \
    M5 ( 15, sha1_f0, w0, w1); \

#else

  #if STEP_PRE == 1
    #define R_PRE R1
  #elif STEP_PRE == 2
    #define R_PRE R2
  #elif STEP_PRE == 4
    #define R_PRE R4
  #endif // corresponds to #if (#if STEP_PRE == 1)

  #define R20_START \
    { size_t i; for (i = 0; i < 16; i += STEP_PRE) \
      { R_PRE(i, sha1_f0, w0); } } \
    R4 ( 16, sha1_f0, w1); \

#endif // corresponds to #if (#if STEP_PRE > 5)

#if STEP_MAIN > 5

  #define R20(ii, fx) \
    R5 ( (ii)     , fx, w1); \
    R5 ( (ii) + 5 , fx, w1); \
    R5 ( (ii) + 10, fx, w1); \
    R5 ( (ii) + 15, fx, w1); \

#else

  #if STEP_MAIN == 1
    #define R_MAIN R1
  #elif STEP_MAIN == 2
    #define R_MAIN R2
  #elif STEP_MAIN == 4
    #define R_MAIN R4
  #elif STEP_MAIN == 5
    #define R_MAIN R5
  #endif // corresponds to #if (#if STEP_MAIN == 1)

  #define R20(ii, fx)  \
    { size_t i; for (i = (ii); i < (ii) + 20; i += STEP_MAIN) \
      { R_MAIN(i, fx, w1); } } \

#endif // corresponds to #if (#if STEP_MAIN > 5)


#define SetUi32(p, v) { *(UInt32 *)(void *)(p) = (v); }
#define GetBe32(p) ( \
    ((UInt32)((const Byte *)(p))[0] << 24) | \
    ((UInt32)((const Byte *)(p))[1] << 16) | \
    ((UInt32)((const Byte *)(p))[2] <<  8) | \
             ((const Byte *)(p))[3] )
#define SetBe32(p, v) { Byte *_ppp_ = (Byte *)(p); UInt32 _vvv_ = (v); \
    _ppp_[0] = (Byte)(_vvv_ >> 24); \
    _ppp_[1] = (Byte)(_vvv_ >> 16); \
    _ppp_[2] = (Byte)(_vvv_ >> 8); \
    _ppp_[3] = (Byte)_vvv_; }


void Sha1_InitState(CSha1 *p)
{
	p->count = 0;
	p->state[0] = 0x67452301;
	p->state[1] = 0xEFCDAB89;
	p->state[2] = 0x98BADCFE;
	p->state[3] = 0x10325476;
	p->state[4] = 0xC3D2E1F0;
}

void Sha1_Init(CSha1 *p)
{
	p->func_UpdateBlocks =     g_FUNC_UPDATE_BLOCKS;
	Sha1_InitState(p);
}
MY_NO_INLINE
void MY_FAST_CALL Sha1_UpdateBlocks(UInt32 state[5], const Byte *data, size_t numBlocks)
{
	UInt32 a, b, c, d, e;
	UInt32 W[kNumW];
	if (numBlocks==0)
		return;
	a = state[0];
	b = state[1];
	c = state[2];
	d = state[3];
	e = state[4];
	do
	{
		#if STEP_PRE < 5 || STEP_MAIN < 5
		UInt32 tmp;
		#endif // corresponds to #if (#if STEP_PRE < 5 || STEP_MAIN < 5)
		R20_START
		R20(20, sha1_f1);
		R20(40, sha1_f2);
		R20(60, sha1_f3);
		a += state[0];
		b += state[1];
		c += state[2];
		d += state[3];
		e += state[4];
		state[0] = a;
		state[1] = b;
		state[2] = c;
		state[3] = d;
		state[4] = e;
		data += 64;
	}
	while (--numBlocks);
}
void Sha1_Update(CSha1 *p, const Byte *data, size_t size)
{
	if (size==0)
		return;
	unsigned pos = (unsigned)p->count & 0x3F;
	unsigned num;
	p->count += size;
	num=64-pos;
	if (num > size)
	{
		memcpy(p->buffer + pos, data, size);
		return;
	}
	if (pos != 0)
	{
		size -= num;
		memcpy(p->buffer + pos, data, num);
		data += num;
		p->func_UpdateBlocks(p->state, p->buffer, 1);
	}
	size_t numBlocks = size >> 6;
	p->func_UpdateBlocks(p->state, data, numBlocks);
	size &= 0x3F;
	if (size==0)
	  return;
	data += (numBlocks << 6);
	memcpy(p->buffer, data, size);
}
void Sha1_Final(CSha1 *p, Byte *digest)
{
	unsigned pos = (unsigned)p->count & 0x3F;
	p->buffer[pos++] = 0x80;
	if (pos > (64 - 8))
	{
		while (pos != 64)
			p->buffer[pos++]=0;
		p->func_UpdateBlocks(p->state, p->buffer, 1);
		pos = 0;
	}
	memset(&p->buffer[pos], 0, (64 - 8) - pos);
	UInt64 numBits = (p->count << 3);
    SetBe32(p->buffer + 64 - 8, (UInt32)(numBits >> 32));
    SetBe32(p->buffer + 64 - 4, (UInt32)(numBits));
	p->func_UpdateBlocks(p->state, p->buffer, 1);
	SetBe32(digest,      p->state[0]);
	SetBe32(digest + 4,  p->state[1]);
	SetBe32(digest + 8,  p->state[2]);
	SetBe32(digest + 12, p->state[3]);
	SetBe32(digest + 16, p->state[4]);
	Sha1_InitState(p);
}
void Sha1_PrepareBlock(const CSha1 *p, Byte *block, unsigned size)
{
	const UInt64 numBits = (p->count + size) << 3;
	SetBe32(&((UInt32 *)(void *)block)[SHA1_NUM_BLOCK_WORDS - 2], (UInt32)(numBits >> 32));
	SetBe32(&((UInt32 *)(void *)block)[SHA1_NUM_BLOCK_WORDS - 1], (UInt32)(numBits));
	SetUi32((UInt32 *)(void *)(block + size), 0x80);
	size += 4;
	while (size != (SHA1_NUM_BLOCK_WORDS - 2) * 4)
	{
		*((UInt32 *)(void *)(block + size)) = 0;
		size += 4;
	}
}
void Sha1_GetBlockDigest(const CSha1 *p, const Byte *data, Byte *destDigest)
{
	MY_ALIGN (16)
	UInt32 st[SHA1_NUM_DIGEST_WORDS];
	st[0] = p->state[0];
	st[1] = p->state[1];
	st[2] = p->state[2];
	st[3] = p->state[3];
	st[4] = p->state[4];
	p->func_UpdateBlocks(st, data, 1);
	SetBe32(destDigest + 0    , st[0]);
	SetBe32(destDigest + 1 * 4, st[1]);
	SetBe32(destDigest + 2 * 4, st[2]);
	SetBe32(destDigest + 3 * 4, st[3]);
	SetBe32(destDigest + 4 * 4, st[4]);
}
void Sha1Prepare(bool i_flaghardware)
{
	SHA1_FUNC_UPDATE_BLOCKS f, f_hw;
	f = Sha1_UpdateBlocks;
	if (i_flaghardware)
		f = f_hw = Sha1_UpdateBlocks_HW;
	g_FUNC_UPDATE_BLOCKS    = f;
	g_FUNC_UPDATE_BLOCKS_HW = f_hw;
}
#endif  // HWSHA1 // corresponds to #ifdef (#ifdef HWSHA1)
/// LICENSE_END.5

/*
	Section: libzpaq
*/

// 1, 2, 4, 8 byte unsigned integers
typedef uint8_t U8;
typedef uint16_t U16;
typedef uint32_t U32;
typedef uint64_t U64;

namespace libzpaq {
// Tables for parsing ZPAQL source code
extern const char* compname[256];    // list of ZPAQL component types
extern const int compsize[256];      // number of bytes to encode a component
extern const char* opcodelist[272];  // list of ZPAQL instructions
// Callback for error handling
extern void error(const char* msg);
// Virtual base classes for input and output
// get() and put() must be overridden to read or write 1 byte.
// read() and write() may be overridden to read or write n bytes more
// efficiently than calling get() or put() n times.
class Reader {
public:
  virtual int get() = 0;  // should return 0..255, or -1 at EOF
  virtual int read(char* buf, int n); // read to buf[n], return no. read
  virtual ~Reader() {}
};
class Writer {
public:
  virtual void put(int c) = 0;  // should output low 8 bits of c
  virtual void write(const char* buf, int n);  // write buf[n]
  virtual ~Writer() {}
};
// Read 16 bit little-endian number
int toU16(const char* p);
// An Array of T is cleared and aligned on a 64 byte address
//   with no constructors called. No copy or assignment.
// Array<T> a(n, ex=0);  - creates n<<ex elements of type T
// a[i] - index
// a(i) - index mod n, n must be a power of 2
// a.size() - gets n
template <typename T>
class Array {
  T *data;     // user location of [0] on a 64 byte boundary
  size_t n;    // user size
  int offset;  // distance back in bytes to start of actual allocation
  void operator=(const Array&);  // no assignment
  Array(const Array&);  // no copy
public:
  Array(size_t sz=0, int ex=0): data(0), n(0), offset(0) {
    resize(sz, ex);} // [0..sz-1] = 0
  void resize(size_t sz, int ex=0); // change size, erase content to zeros
  ~Array() {resize(0);}  // free memory
  size_t size() const {return n;}  // get size
  int isize() const {return int(n);}  // get size as an int
  T& operator[](size_t i) {assert(n>0 && i<n); if (!(n>0 && i<n))
	  {
		    error("09386: operator[] kaputt");
	  }		  
  return data[i];}
  T& operator()(size_t i) {assert(n>0 && (n&(n-1))==0); return data[i&(n-1)];}
};
// Change size to sz<<ex elements of 0
template<typename T>
void Array<T>::resize(size_t sz, int ex) {
  assert(size_t(-1)>0);  // unsigned type?
  while (ex>0) {
    if (sz>sz*2) error("Array too big");
    sz*=2, --ex;
  }
  if (n>0) {
    assert(offset>0 && offset<=64);
    assert((char*)data-offset);
    ::free((char*)data-offset);
	 g_arrayram-=n;
 
  }
  n=0;
  offset=0;
  if (sz==0) return;
  n=sz;
  const size_t nb=128+n*sizeof(T);  // test for overflow
  if (nb<=128 || (nb-128)/sizeof(T)!=n) n=0, error("Array too big");
  data=(T*)::calloc(nb, 1);
  g_arrayram+=nb;
  if (!data) n=0, error("Out of memory");
  offset=64-(((char*)data-(char*)0)&63);
  assert(offset>0 && offset<=64);
  data=(T*)((char*)data+offset);
}
//////////////////////////// SHA1 ////////////////////////////
// SHA1 code, see http://en.wikipedia.org/wiki/SHA-1
#define SHA1CHUNK 64
class SHA1
{
public:
	void put(int c);
	void write(const char* buf, int64_t n);
	uint64_t usize() const {return len/8;}
	const char* result();
	SHA1() {init();}
private:
#ifdef HWSHA1
	int				bufpos;				// 7-Zip SHA1 is rather different from
	CSha1			myhasher;			// the original 7.15. So I put an input buffer
	unsigned char 	w_hw[SHA1CHUNK];	// Slower, in fact, but it works

#else
	#ifdef HWSHA2
		int				bufpos;				// 7-Zip SHA1 is rather different from
		SUM_CONTEXT sum_ctx;
		unsigned char 	w_hw[SHA1CHUNK];	// Slower, in fact, but it works
	#else		// no HW
		U32 w[16];       ///puoi togliere
		U32 h[5];        ///puoi togliere
	#endif // corresponds to #ifdef (#ifdef HWSHA2)
#endif // corresponds to #ifdef (#ifdef HWSHA1)

	U64 len;
	char hbuf[20];
	void process();
	void init();
};
#ifdef HWSHA2

/// This "thing" seems weird, and not very optimized, must be a "plug in" replacment
void SHA1::init()
{
	len=0;
	bufpos=0;
	memset(&sum_ctx,0,sizeof(sum_ctx));
	sha1_init(&sum_ctx);
}
void SHA1::put(int c)
{
	///sha1_write(&sum_ctx,(const uint8_t*)&c,1);

	w_hw[bufpos++]=c;
	if (bufpos==SHA1CHUNK)
	{
		sha1_write(&sum_ctx,w_hw,SHA1CHUNK);
		bufpos=0;
	}
	len+=8;
}
const char* SHA1::result()
{
	sha1_write(&sum_ctx,w_hw,bufpos);
	sha1_final(&sum_ctx);
	memcpy(hbuf, sum_ctx.buf,20);
	init();
	return hbuf;
}
void SHA1::write(const char* buf, int64_t n)
{
	sha1_write(&sum_ctx,(const uint8_t*)buf,n);
	len+=n*8;
}
void SHA1::process()
{
}

#else



#ifdef HWSHA1
/// This "thing" seems weird, and not very optimized, must be a "plug in" replacment
void SHA1::init()
{
	len=0;
	bufpos=0;
	Sha1_Init(&myhasher);
}
void SHA1::put(int c)
{
	w_hw[bufpos++]=c;
	if (bufpos==SHA1CHUNK)
	{
		Sha1_Update(&myhasher,(const Byte*)w_hw,SHA1CHUNK);
		bufpos=0;
	}
	len+=8;
}
const char* SHA1::result()
{
	Sha1_Update(&myhasher,(const Byte*)w_hw,bufpos);
	Sha1_Final(&myhasher,(Byte*)hbuf);
	init();
	return hbuf;
}
void SHA1::write(const char* buf, int64_t n)
{
	Sha1_Update(&myhasher,(const Byte*)buf,n);
	len+=n*8;
}
void SHA1::process()
{
}
#else
///	zpaq 7.15 use a very, very, very good implementation of SHA1, but full of very dirty tricks
void SHA1::init()
{
	len=0;
	memset(w, 0, sizeof(w));
	h[0]=0x67452301;
	h[1]=0xEFCDAB89;
	h[2]=0x98BADCFE;
	h[3]=0x10325476;
	h[4]=0xC3D2E1F0;
}
void SHA1::put(int c)
{
	U32& r=w[U32(len)>>5&15];
	r=(r<<8)|(c&255);
    len+=8;
	if ((U32(len)&511)==0)
		process();
}
const char* SHA1::result()
{
	const U64 s=len;
	put(0x80);
	while ((len&511)!=448)
		put(0);
	put(s>>56);
	put(s>>48);
	put(s>>40);
	put(s>>32);
	put(s>>24);
	put(s>>16);
	put(s>>8);
	put(s);
	for (unsigned int i=0; i<5; ++i)
	{
		hbuf[4*i]=h[i]>>24;
		hbuf[4*i+1]=h[i]>>16;
		hbuf[4*i+2]=h[i]>>8;
		hbuf[4*i+3]=h[i];
	}
	init();
	return hbuf;
}
void SHA1::write(const char* buf, int64_t n)
{
  const unsigned char* p=(const unsigned char*) buf;
  for (; n>0 && (U32(len)&511)!=0; --n) put(*p++);
  for (; n>=64; n-=64) {
    for (unsigned int i=0; i<16; ++i)
      w[i]=p[0]<<24|p[1]<<16|p[2]<<8|p[3], p+=4;
    len+=512;
	process();
  }
  for (; n>0; --n) put(*p++);
}
void SHA1::process()
{
  U32 a=h[0], b=h[1], c=h[2], d=h[3], e=h[4];
  static const U32 k[4]={0x5A827999, 0x6ED9EBA1, 0x8F1BBCDC, 0xCA62C1D6};
  #define f(a,b,c,d,e,i) \
    if (i>=16) \
      w[(i)&15]^=w[(i-3)&15]^w[(i-8)&15]^w[(i-14)&15], \
      w[(i)&15]=w[(i)&15]<<1|w[(i)&15]>>31; \
    e+=(a<<5|a>>27)+k[(i)/20]+w[(i)&15] \
      +((i)%40>=20 ? b^c^d : i>=40 ? (b&c)|(d&(b|c)) : d^(b&(c^d))); \
    b=b<<30|b>>2;
  #define r(i) f(a,b,c,d,e,i) f(e,a,b,c,d,i+1) f(d,e,a,b,c,i+2) \
               f(c,d,e,a,b,i+3) f(b,c,d,e,a,i+4)
  r(0)  r(5)  r(10) r(15) r(20) r(25) r(30) r(35)
  r(40) r(45) r(50) r(55) r(60) r(65) r(70) r(75)
  #undef f
  #undef r
  h[0]+=a; h[1]+=b; h[2]+=c; h[3]+=d; h[4]+=e;
}
#endif // corresponds to #ifdef (#ifdef HWSHA1)
#endif // corresponds to #ifdef (#ifdef HWSHA2)

//////////////////////////// SHA256 //////////////////////////
// For computing SHA-256 checksums
// http://en.wikipedia.org/wiki/SHA-2


#define SHA2CHUNK 64

class SHA256 {
public:
  void put(int c);
  void write(const char* buf, int64_t n);
  const char* result();
  SHA256() {init();}

private:
  void init();
#ifndef HWSHA2
  unsigned len0, len1; /// puoi togliere?
  unsigned s[8];      ///puoi togliere
  unsigned w[16];     ///puoitogliere
#endif // corresponds to #ifndef (#ifndef HWSHA2)
  char hbuf[32];
  void process();
#ifdef HWSHA2
	int				bufpos;
	SUM_CONTEXT 	sum_ctx;
	unsigned char 	w_hw[SHA2CHUNK];
#endif // corresponds to #ifdef (#ifdef HWSHA2)

};
#ifdef HWSHA2
//////////////////////////// SHA256 //////////////////////////
void SHA256::init()
{
	bufpos=0;
	memset(&sum_ctx,0,sizeof(sum_ctx));
	sha256_init(&sum_ctx);
}

void SHA256::put(int c)
{
	w_hw[bufpos++]=c;
	if (bufpos==SHA2CHUNK)
	{
		sha256_write(&sum_ctx,w_hw,SHA2CHUNK);
		bufpos=0;
	}
}
const char* SHA256::result()
{
	sha256_write(&sum_ctx,w_hw,bufpos);
	sha256_final(&sum_ctx);
	memcpy(hbuf, sum_ctx.buf,32);
	init();
	return hbuf;
}
void SHA256::write(const char* buf, int64_t n)
{
	sha256_write(&sum_ctx,(const uint8_t*)buf,n);
}
void SHA256::process()
{
}

#else

//////////////////////////// SHA256 //////////////////////////
void SHA256::put(int c)
{  // hash 1 byte
    unsigned& r=w[len0>>5&15];
    r=(r<<8)|(c&255);
    if (!(len0+=8)) ++len1;
    if ((len0&511)==0) process();
}

void SHA256::init() {
  len0=len1=0;
  s[0]=0x6a09e667;
  s[1]=0xbb67ae85;
  s[2]=0x3c6ef372;
  s[3]=0xa54ff53a;
  s[4]=0x510e527f;
  s[5]=0x9b05688c;
  s[6]=0x1f83d9ab;
  s[7]=0x5be0cd19;
  memset(w, 0, sizeof(w));
}
void SHA256::process() {
  #define ror(a,b) ((a)>>(b)|(a<<(32-(b))))
  #define m(i) \
     w[(i)&15]+=w[(i-7)&15] \
       +(ror(w[(i-15)&15],7)^ror(w[(i-15)&15],18)^(w[(i-15)&15]>>3)) \
       +(ror(w[(i-2)&15],17)^ror(w[(i-2)&15],19)^(w[(i-2)&15]>>10))
  #define r(a,b,c,d,e,f,g,h,i) { \
    unsigned t1=ror(e,14)^e; \
    t1=ror(t1,5)^e; \
    h+=ror(t1,6)+((e&f)^(~e&g))+k[i]+w[(i)&15]; } \
    d+=h; \
    {unsigned t1=ror(a,9)^a; \
    t1=ror(t1,11)^a; \
    h+=ror(t1,2)+((a&b)^(c&(a^b))); }
  #define mr(a,b,c,d,e,f,g,h,i) m(i); r(a,b,c,d,e,f,g,h,i);
  #define r8(i) \
    r(a,b,c,d,e,f,g,h,i);   \
    r(h,a,b,c,d,e,f,g,i+1); \
    r(g,h,a,b,c,d,e,f,i+2); \
    r(f,g,h,a,b,c,d,e,i+3); \
    r(e,f,g,h,a,b,c,d,i+4); \
    r(d,e,f,g,h,a,b,c,i+5); \
    r(c,d,e,f,g,h,a,b,i+6); \
    r(b,c,d,e,f,g,h,a,i+7);
  #define mr8(i) \
    mr(a,b,c,d,e,f,g,h,i);   \
    mr(h,a,b,c,d,e,f,g,i+1); \
    mr(g,h,a,b,c,d,e,f,i+2); \
    mr(f,g,h,a,b,c,d,e,i+3); \
    mr(e,f,g,h,a,b,c,d,i+4); \
    mr(d,e,f,g,h,a,b,c,i+5); \
    mr(c,d,e,f,g,h,a,b,i+6); \
    mr(b,c,d,e,f,g,h,a,i+7);
  static const unsigned k[64]={
    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5,
    0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
    0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3,
    0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
    0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc,
    0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
    0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7,
    0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
    0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13,
    0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
    0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3,
    0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
    0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5,
    0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
    0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,
    0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2};
  unsigned a=s[0];
  unsigned b=s[1];
  unsigned c=s[2];
  unsigned d=s[3];
  unsigned e=s[4];
  unsigned f=s[5];
  unsigned g=s[6];
  unsigned h=s[7];
  r8(0);
  r8(8);
  mr8(16);
  mr8(24);
  mr8(32);
  mr8(40);
  mr8(48);
  mr8(56);
  s[0]+=a;
  s[1]+=b;
  s[2]+=c;
  s[3]+=d;
  s[4]+=e;
  s[5]+=f;
  s[6]+=g;
  s[7]+=h;
  #undef mr8
  #undef r8
  #undef mr
  #undef r
  #undef m
  #undef ror
}
const char* SHA256::result() {
  const unsigned s1=len1, s0=len0;
  put(0x80);
  while ((len0&511)!=448) put(0);
  put(s1>>24);
  put(s1>>16);
  put(s1>>8);
  put(s1);
  put(s0>>24);
  put(s0>>16);
  put(s0>>8);
  put(s0);
  for (unsigned int i=0; i<8; ++i) {
    hbuf[4*i]=s[i]>>24;
    hbuf[4*i+1]=s[i]>>16;
    hbuf[4*i+2]=s[i]>>8;
    hbuf[4*i+3]=s[i];
  }
  init();
  return hbuf;
}
void SHA256::write(const char* buf, int64_t n)
{
	for (int64_t i=0;i<n;i++)
		put(*(buf+i));
}
#endif // corresponds to #ifdef (#ifdef HWSHA2)
//////////////////////////// AES /////////////////////////////
// For encrypting with AES in CTR mode.
// The i'th 16 byte block is encrypted by XOR with AES(i)
// (i is big endian or MSB first, starting with 0).
class AES_CTR {
  U32 Te0[256], Te1[256], Te2[256], Te3[256], Te4[256]; // encryption tables
  U32 ek[60];  // round key
  int Nr;  // number of rounds (10, 12, 14 for AES 128, 192, 256)
  U32 iv0, iv1;  // first 8 bytes in CTR mode
public:
  AES_CTR(const char* key, int keylen, const char* iv=0);
    // Schedule: keylen is 16, 24, or 32, iv is 8 bytes or NULL
  void encrypt(U32 s0, U32 s1, U32 s2, U32 s3, unsigned char* ct);
  void encrypt(char* buf, int n, U64 offset);  // encrypt n bytes of buf
};//////////////////////////// stretchKey //////////////////////
// Strengthen password pw[0..pwlen-1] and salt[0..saltlen-1]
// to produce key buf[0..buflen-1]. Uses O(n*r*p) time and 128*r*n bytes
// of memory. n must be a power of 2 and r <= 8.
void scrypt(const char* pw, int pwlen,
            const char* salt, int saltlen,
            int n, int r, int p, char* buf, int buflen);
// Generate a strong key out[0..31] key[0..31] and salt[0..31].
// Calls scrypt(key, 32, salt, 32, 16384, 8, 1, out, 32);
void stretchKey(char* out, const char* key, const char* salt);
//////////////////////////// random //////////////////////////
// Fill buf[0..n-1] with n cryptographic random bytes. The first
// byte is never '7' or 'z'.
void random(char* buf, int n);
//////////////////////////// ZPAQL ///////////////////////////
// Symbolic constants, instruction size, and names
typedef enum {NONE,CONS,CM,ICM,MATCH,AVG,MIX2,MIX,ISSE,SSE} CompType;
extern const int compsize[256];
class Decoder;  // forward
// A ZPAQL machine COMP+HCOMP or PCOMP.
class ZPAQL {
public:
  ZPAQL();
  ~ZPAQL();
  void clear();           // Free memory, erase program, reset machine state
  void inith();           // Initialize as HCOMP to run
  void initp();           // Initialize as PCOMP to run
  double memory();        // Return memory requirement in bytes
  void run(U32 input);    // Execute with input
  int read(Reader* in2);  // Read header
  bool write(Writer* out2, bool pp); // If pp write PCOMP else HCOMP header
  int step(U32 input, int mode);  // Trace execution (defined externally)
  Writer* output;         // Destination for OUT instruction, or 0 to suppress
  SHA1* sha1;             // Points to checksum computer
  U32 H(int i) {return h(i);}  // get element of h
  void flush();           // write outbuf[0..bufptr-1] to output and sha1
  void outc(int ch) {     // output byte ch (0..255) or -1 at EOS
    if (ch<0 || (outbuf[bufptr]=ch, ++bufptr==outbuf.isize())) flush();
  }
  // ZPAQ1 block header
  Array<U8> header;   // hsize[2] hh hm ph pm n COMP (guard) HCOMP (guard)
  int cend;           // COMP in header[7...cend-1]
  int hbegin, hend;   // HCOMP/PCOMP in header[hbegin...hend-1]
private:
  // Machine state for executing HCOMP
  Array<U8> m;        // memory array M for HCOMP
  Array<U32> h;       // hash array H for HCOMP
  Array<U32> r;       // 256 element register array
  Array<char> outbuf; // output buffer
  int bufptr;         // number of bytes in outbuf
  U32 a, b, c, d;     // machine registers
  int f;              // condition flag
  int pc;             // program counter
  int rcode_size;     // length of rcode
  U8* rcode;          // JIT code for run()
  // Support code
  int assemble();  // put JIT code in rcode
  void init(int hbits, int mbits);  // initialize H and M sizes
  int execute();  // interpret 1 instruction, return 0 after HALT, else 1
  void run0(U32 input);  // default run() if not JIT
  void zdiv(U32 x) {if (x) a/=x; else a=0;}
  void mod(U32 x) {if (x) a%=x; else a=0;}
  void swap(U32& x) {a^=x; x^=a; a^=x;}
  void swap(U8& x)  {a^=x; x^=a; a^=x;}
  void err();  // exit with run time error
};
///////////////////////// Component //////////////////////////
// A Component is a context model, indirect context model, match model,
// fixed weight mixer, adaptive 2 input mixer without or with current
// partial byte as context, adaptive m input mixer (without or with),
// or SSE (without or with).
struct Component {
  size_t limit;   // max count for cm
  size_t cxt;     // saved context
  size_t a, b, c; // multi-purpose variables
  Array<U32> cm;  // cm[cxt] -> p in bits 31..10, n in 9..0; MATCH index
  Array<U8> ht;   // ICM/ISSE hash table[0..size1][0..15] and MATCH buf
  Array<U16> a16; // MIX weights
  void init();    // initialize to all 0
  Component() {init();}
};
////////////////////////// StateTable ////////////////////////
// Next state table
class StateTable {
public:
  U8 ns[1024]; // state*4 -> next state if 0, if 1, n0, n1
  int next(int state, int y) {  // next state for bit y
    assert(state>=0 && state<256);
    assert(y>=0 && y<4);
    return ns[state*4+y];
  }
  int cminit(int state) {  // initial probability of 1 * 2^23
    assert(state>=0 && state<256);
    return ((ns[state*4+3]*2+1)<<22)/(ns[state*4+2]+ns[state*4+3]+1);
  }
  StateTable();
};
///////////////////////// Predictor //////////////////////////
// A predictor guesses the next bit
class Predictor {
public:
  Predictor(ZPAQL&);
  ~Predictor();
  void init();          // build model
  int predict();        // probability that next bit is a 1 (0..4095)
  void update(int y);   // train on bit y (0..1)
  int stat(int);        // Defined externally
  bool isModeled() {    // n>0 components?
    assert(z.header.isize()>6);
    return z.header[6]!=0;
  }
private:
  // Predictor state
  int c8;               // last 0...7 bits.
  int hmap4;            // c8 split into nibbles
  int p[256];           // predictions
  U32 h[256];           // unrolled copy of z.h
  ZPAQL& z;             // VM to compute context hashes, includes H, n
  Component comp[256];  // the model, includes P
  bool initTables;      // are tables initialized?
  // Modeling support functions
  int predict0();       // default
  void update0(int y);  // default
  int dt2k[256];        // division table for match: dt2k[i] = 2^12/i
  int dt[1024];         // division table for cm: dt[i] = 2^16/(i+1.5)
  U16 squasht[4096];    // squash() lookup table
  short stretcht[32768];// stretch() lookup table
  StateTable st;        // next, cminit functions
  U8* pcode;            // JIT code for predict() and update()
  int pcode_size;       // length of pcode
  // reduce prediction error in cr.cm
  void train(Component& cr, int y) {
    assert(y==0 || y==1);
    U32& pn=cr.cm(cr.cxt);
    U32 count=pn&0x3ff;
    int error=y*32767-(cr.cm(cr.cxt)>>17);
    pn+=(error*dt[count]&-1024)+(count<cr.limit);
  }
  // x -> floor(32768/(1+exp(-x/64)))
  int squash(int x) {
    assert(initTables);
    assert(x>=-2048 && x<=2047);
    return squasht[x+2048];
  }
  // x -> round(64*log((x+0.5)/(32767.5-x))), approx inverse of squash
  int stretch(int x) {
    assert(initTables);
    assert(x>=0 && x<=32767);
    return stretcht[x];
  }
  // bound x to a 12 bit signed int
  int clamp2k(int x) {
    if (x<-2048) return -2048;
    else if (x>2047) return 2047;
    else return x;
  }
  // bound x to a 20 bit signed int
  int clamp512k(int x) {
    if (x<-(1<<19)) return -(1<<19);
    else if (x>=(1<<19)) return (1<<19)-1;
    else return x;
  }
  // Get cxt in ht, creating a new row if needed
  size_t find(Array<U8>& ht, int sizebits, U32 cxt);
  // Put JIT code in pcode
  int assemble_p();
};
//////////////////////////// Decoder /////////////////////////
// Decoder decompresses using an arithmetic code
class Decoder: public Reader {
public:
  Reader* in;        // destination
  Decoder(ZPAQL& z);
  int decompress();  // return a byte or EOF
  int skip();        // skip to the end of the segment, return next byte
  void init();       // initialize at start of block
  int stat(int x) {return pr.stat(x);}
  int get() {        // return 1 byte of buffered input or EOF
    if (rpos==wpos) {
      rpos=0;
      wpos=in ? in->read(&buf[0], BUFSIZE) : 0;
      assert(wpos<=BUFSIZE);
    }
    return rpos<wpos ? U8(buf[rpos++]) : -1;
  }
  int buffered() {return wpos-rpos;}  // how far read ahead?
private:
  U32 low, high;     // range
  U32 curr;          // last 4 bytes of archive or remaining bytes in subblock
  U32 rpos, wpos;    // read, write position in buf
  Predictor pr;      // to get p
  enum {BUFSIZE=1<<16};
  Array<char> buf;   // input buffer of size BUFSIZE bytes
  int decode(int p); // return decoded bit (0..1) with prob. p (0..65535)
};
/////////////////////////// PostProcessor ////////////////////
class PostProcessor {
  int state;   // input parse state: 0=INIT, 1=PASS, 2..4=loading, 5=POST
  int hsize;   // header size
  int ph, pm;  // sizes of H and M in z
public:
  ZPAQL z;     // holds PCOMP
  PostProcessor(): state(0), hsize(0), ph(0), pm(0) {}
  void init(int h, int m);  // ph, pm sizes of H and M
  int write(int c);  // Input a byte, return state
  int getState() const {return state;}
  void setOutput(Writer* out) {z.output=out;}
  void setSHA1(SHA1* sha1ptr) {z.sha1=sha1ptr;}
};
//////////////////////// Decompresser ////////////////////////
// For decompression and listing archive contents
class Decompresser {
public:
  Decompresser(): z(), dec(z), pp(), state(BLOCK), decode_state(FIRSTSEG) {}
  void setInput(Reader* in) {dec.in=in;}
  bool findBlock(double* memptr = 0);
  void hcomp(Writer* out2) {z.write(out2, false);}
  bool findFilename(Writer* = 0);
  void readComment(Writer* = 0);
  void setOutput(Writer* out) {pp.setOutput(out);}
  void setSHA1(SHA1* sha1ptr) {pp.setSHA1(sha1ptr);}
  bool decompress(int n = -1);  // n bytes, -1=all, return true until done
  bool pcomp(Writer* out2) {return pp.z.write(out2, true);}
  void readSegmentEnd(char* sha1string = 0);
  int stat(int x) {return dec.stat(x);}
  int buffered() {return dec.buffered();}
private:
  ZPAQL z;
  Decoder dec;
  PostProcessor pp;
  enum {BLOCK, FILENAME, COMMENT, DATA, SEGEND} state;  // expected next
  enum {FIRSTSEG, SEG, SKIP} decode_state;  // which segment in block?
};
/////////////////////////// decompress() /////////////////////
void decompress(Reader* in, Writer* out);
//////////////////////////// Encoder /////////////////////////
// Encoder compresses using an arithmetic code
class Encoder {
public:
  Encoder(ZPAQL& z):
    out(0), low(1), high(0xFFFFFFFF), pr(z) {}
  void init();
  void compress(int c);  // c is 0..255 or EOF
  int stat(int x) {return pr.stat(x);}
  Writer* out;  // destination
private:
  U32 low, high; // range
  Predictor pr;  // to get p
  Array<char> buf; // unmodeled input
  void encode(int y, int p); // encode bit y (0..1) with prob. p (0..65535)
};
//////////////////////////// Compiler ////////////////////////
// Input ZPAQL source code with args and store the compiled code
// in hz and pz and write pcomp_cmd to out2.
class Compiler {
public:
  Compiler(const char* in, int* args, ZPAQL& hz, ZPAQL& pz, Writer* out2);
private:
  const char* in;  // ZPAQL source code
  int* args;       // Array of up to 9 args, default NULL = all 0
  ZPAQL& hz;       // Output of COMP and HCOMP sections
  ZPAQL& pz;       // Output of PCOMP section
  Writer* out2;    // Output ... of "PCOMP ... ;"
  int line;        // Input line number for reporting errors
  int state;       // parse state: 0=space -1=word >0 (nest level)
  // Symbolic constants
  typedef enum {NONE,CONS,CM,ICM,MATCH,AVG,MIX2,MIX,ISSE,SSE,
    JT=39,JF=47,JMP=63,LJ=255,
    POST=256,PCOMP,END,IF,IFNOT,ELSE,ENDIF,DO,
    WHILE,UNTIL,FOREVER,IFL,IFNOTL,ELSEL,SEMICOLON} CompType;
  void syntaxError(const char* msg, const char* expected=0); // error()
  void next();                     // advance in to next token
  bool matchToken(const char* tok);// in==token?
  int rtoken(int low, int high);   // return token which must be in range
  int rtoken(const char* list[]);  // return token by position in list
  void rtoken(const char* s);      // return token which must be s
  int compile_comp(ZPAQL& z);      // compile either HCOMP or PCOMP
  // Stack of n elements
  class Stack {
    libzpaq::Array<U16> s;
    size_t top;
  public:
    Stack(int n): s(n), top(0) {}
    void push(const U16& x) {
      if (top>=s.size()) error("IF or DO nested too deep");
      s[top++]=x;
    }
    U16 pop() {
      if (top<=0) error("unmatched IF or DO");
      return s[--top];
    }
  };
  Stack if_stack, do_stack;
};
//////////////////////// Compressor //////////////////////////
class Compressor {
public:
  Compressor(): enc(z), in(0), state(INIT), verify(false) {}
  void setOutput(Writer* out) {enc.out=out;}
  void writeTag();
  void startBlock(int level);  // level=1,2,3
  void startBlock(const char* hcomp);     // ZPAQL byte code
  void startBlock(const char* config,     // ZPAQL source code
                  int* args,              // NULL or int[9] arguments
                  Writer* pcomp_cmd = 0); // retrieve preprocessor command
#ifdef DEBUG
  void setVerify(bool v) {verify = v;}    // check postprocessing?
#endif // corresponds to #ifdef (#ifdef DEBUG)
  void hcomp(Writer* out2) {z.write(out2, false);}
  bool pcomp(Writer* out2) {return pz.write(out2, true);}
  void startSegment(const char* filename = 0, const char* comment = 0);
  void setInput(Reader* i) {in=i;}
  void postProcess(const char* pcomp = 0, int len = 0);  // byte code
  bool compress(int n = -1);  // n bytes, -1=all, return true until done
  void endSegment(const char* sha1string = 0);
#ifdef DEBUG
  char* endSegmentChecksum(int64_t* size = 0, bool dosha1=true);
#endif // corresponds to #ifdef (#ifdef DEBUG)
  void endBlock();
  int stat(int x) {return enc.stat(x);}
private:
  ZPAQL z, pz;  // model and test postprocessor
  Encoder enc;  // arithmetic encoder containing predictor
  Reader* in;   // input source
  SHA1 sha1;    // to test pz output
///  char sha1result[20];  // sha1 output
  enum {INIT, BLOCK1, SEG1, BLOCK2, SEG2} state;
  bool verify;  // if true then test by postprocessing
};
/////////////////////////// StringBuffer /////////////////////
// For (de)compressing to/from a string. Writing appends bytes
// which can be later read.
class StringBuffer: public libzpaq::Reader, public libzpaq::Writer {
  unsigned char* p;  // allocated memory, not NUL terminated, may be NULL
  size_t al;         // number of bytes allocated, 0 iff p is NULL
  size_t wpos;       // index of next byte to write, wpos <= al
  size_t rpos;       // index of next byte to read, rpos < wpos or return EOF.
  size_t limit;      // max size, default = -1
  const size_t init; // initial size on first use after reset
  // Increase capacity to a without changing size
  void reserve(size_t a) {
    assert(!al==!p);
    if (a<=al) return;
	///g_allocatedram+=a;
    unsigned char* q=0;
    if (a>0) q=(unsigned char*)(p ? franz_extend(p,a,al) : franz_malloc(a));
    if (a>0 && !q) error("Out of memory");
    p=q;
    al=a;
  }
  // Enlarge al to make room to write at least n bytes.
  void lengthen(size_t n) {
    assert(wpos<=al);
    if (wpos+n>limit || wpos+n<wpos) error("StringBuffer overflow");
    if (wpos+n<=al) return;
    size_t a=al;
    while (wpos+n>=a) a=a*2+init;
    reserve(a);
  }
  // No assignment or copy
  void operator=(const StringBuffer&);
  StringBuffer(const StringBuffer&);
public:
  // Direct access to data
  unsigned char* data() {assert(p || wpos==0); return p;}
  // Allocate no memory initially
  StringBuffer(size_t n=0):
      p(0), al(0), wpos(0), rpos(0), limit(size_t(-1)), init(n>128?n:128) {}
  // Set output limit
  void setLimit(size_t n) {limit=n;}
  // Free memory
  ~StringBuffer() {if (p) {franz_free(p);g_allocatedram-=al;}}
  // Return number of bytes written.
  size_t size() const {return wpos;}
  // Return number of bytes left to read
  ///size_t remaining() const {return wpos-rpos;}
  // Reset size to 0 and free memory.
  void reset() {
	  
    if (p) 
	{franz_free(p);
	g_allocatedram-=al;
	}
    p=0;
    al=rpos=wpos=0;
  }
  // Write a single byte.
  void put(int c) {  // write 1 byte
    lengthen(1);
    assert(p);
    assert(wpos<al);
    p[wpos++]=c;
    assert(wpos<=al);
  }
  // Write buf[0..n-1]. If buf is NULL then advance write pointer only.
  void write(const char* buf, int n) {
    if (n<1) return;
    lengthen(n);
    assert(p);
    assert(wpos+n<=al);
    if (buf) memcpy(p+wpos, buf, n);
    wpos+=n;
  }
  // Read a single byte. Return EOF (-1) at end.
  int get() {
    assert(rpos<=wpos);
    assert(rpos==wpos || p);
    return rpos<wpos ? p[rpos++] : -1;
  }
  // Read up to n bytes into buf[0..] or fewer if EOF is first.
  // Return the number of bytes actually read.
  // If buf is NULL then advance read pointer without reading.
  int read(char* buf, int n) {
    assert(rpos<=wpos);
    assert(wpos<=al);
    assert(!al==!p);
    if (rpos+n>wpos) n=wpos-rpos;
    if (n>0 && buf) memcpy(buf, p+rpos, n);
    rpos+=n;
    return n;
  }
  // Return the entire string as a read-only array.
  const char* c_str() const {return (const char*)p;}
  // Truncate the string to size i.
  void resize(size_t i) {
    wpos=i;
    if (rpos>wpos) rpos=wpos;
  }
  // Swap efficiently (init is not swapped)
  void swap(StringBuffer& s) {
    std::swap(p, s.p);
    std::swap(al, s.al);
    std::swap(wpos, s.wpos);
    std::swap(rpos, s.rpos);
    std::swap(limit, s.limit);
  }
};


/////////////////////////// compress() ///////////////////////
// Compress in to out in multiple blocks. Default method is "14,128,0"
// Default filename is "". Comment is appended to input size.
// dosha1 means save the SHA-1 checksum.
void compress(Reader* in, Writer* out, const char* method,
     const char* filename=0, const char* comment=0, bool dosha1=true);
// Same as compress() but output is 1 block, ignoring block size parameter.
void compressBlock(StringBuffer* in, Writer* out, const char* method,
     const char* filename=0, const char* comment=0, bool dosha1=true);
// Read 16 bit little-endian number
int toU16(const char* p) {
  return (p[0]&255)+256*(p[1]&255);
}
// Default read() and write()
int Reader::read(char* buf, int n) {
  int i=0, c;
  while (i<n && (c=get())>=0)
    buf[i++]=c;
  return i;
}
void Writer::write(const char* buf, int n) {
  for (int i=0; i<n; ++i)
    put(U8(buf[i]));
}


///////////////////////// allocx //////////////////////
// Allocate newsize > 0 bytes of executable memory and update
// p to point to it and newsize = n. Free any previously
// allocated memory first. If newsize is 0 then free only.
// Call error in case of failure. If NOJIT, ignore newsize
// and set p=0, n=0 without allocating memory.
void allocx(U8* &p, int &n, int newsize) {
	if (flagnojit)
	{
		p=0;
		n=0;
	}
	else
	{

  if (p || n) {
    if (p)
#ifdef unix
      munmap(p, n);
#else // Windows
      VirtualFree(p, 0, MEM_RELEASE);
#endif // corresponds to #ifdef (#ifdef unix)
	g_allocatedram-=n;
    p=0;
    n=0;
  }
  if (newsize>0) 
  {
#ifdef unix
	///myprintf("BEFORE mmap of newsize %s\n",migliaia(newsize));
	/// PROT_EXEC can be stopped
    p=(U8*)mmap(0, newsize, PROT_READ|PROT_WRITE|PROT_EXEC,MAP_PRIVATE|MAP_ANON, -1, 0);
	////myprintf("AFTER mmap\n");

    if ((void*)p==MAP_FAILED) 
	{
		if (flagdebug3)
			myprintf("10253$ MAP FAILED!\n");
		p=0;
	}
#else
    p=(U8*)VirtualAlloc(0, newsize, MEM_RESERVE|MEM_COMMIT,PAGE_EXECUTE_READWRITE);
#endif // corresponds to #ifdef (#ifdef unix)

    if (p)
	{
	  g_allocatedram+=newsize;
      n=newsize;
	}
    else 
	{
		n=0;
		myprintf("\n\n");
		myprintf("02249! allocx KO for %s (maybe non-Intel CPU? Unsupported OS?)\n",migliaia(newsize));
		myprintf("02250! try to run with -nojit or compile using -DNOJIT\n\n");
		color_restore();
		exit(0);
    }
  }
	}
}

/// LICENSE_START.1
//////////////////////////// AES /////////////////////////////
// Some AES code is derived from libtomcrypt 1.17 (public domain).
#define Te4_0 0x000000FF & Te4
#define Te4_1 0x0000FF00 & Te4
#define Te4_2 0x00FF0000 & Te4
#define Te4_3 0xFF000000 & Te4
// Extract byte n of x
static inline unsigned byte(unsigned x, unsigned n) {return (x>>(8*n))&255;}
// x = y[0..3] MSB first
static inline void LOAD32H(U32& x, const char* y) {
  const unsigned char* u=(const unsigned char*)y;
  x=u[0]<<24|u[1]<<16|u[2]<<8|u[3];
}
// y[0..3] = x MSB first
static inline void STORE32H(U32& x, unsigned char* y) {
  y[0]=x>>24;
  y[1]=x>>16;
  y[2]=x>>8;
  y[3]=x;
}
#define setup_mix(temp) \
  ((Te4_3[byte(temp, 2)]) ^ (Te4_2[byte(temp, 1)]) ^ \
   (Te4_1[byte(temp, 0)]) ^ (Te4_0[byte(temp, 3)]))
// Initialize encryption tables and round key. keylen is 16, 24, or 32.
AES_CTR::AES_CTR(const char* key, int keylen, const char* iv) {
  assert(key  != NULL);
  assert(keylen==16 || keylen==24 || keylen==32);
  // Initialize IV (default 0)
  iv0=iv1=0;
  if (iv) {
    LOAD32H(iv0, iv);
    LOAD32H(iv1, iv+4);
  }
  // Initialize encryption tables
  for (unsigned int i=0; i<256; ++i) {
    unsigned s1=
    "\x63\x7c\x77\x7b\xf2\x6b\x6f\xc5\x30\x01\x67\x2b\xfe\xd7\xab\x76"
    "\xca\x82\xc9\x7d\xfa\x59\x47\xf0\xad\xd4\xa2\xaf\x9c\xa4\x72\xc0"
    "\xb7\xfd\x93\x26\x36\x3f\xf7\xcc\x34\xa5\xe5\xf1\x71\xd8\x31\x15"
    "\x04\xc7\x23\xc3\x18\x96\x05\x9a\x07\x12\x80\xe2\xeb\x27\xb2\x75"
    "\x09\x83\x2c\x1a\x1b\x6e\x5a\xa0\x52\x3b\xd6\xb3\x29\xe3\x2f\x84"
    "\x53\xd1\x00\xed\x20\xfc\xb1\x5b\x6a\xcb\xbe\x39\x4a\x4c\x58\xcf"
    "\xd0\xef\xaa\xfb\x43\x4d\x33\x85\x45\xf9\x02\x7f\x50\x3c\x9f\xa8"
    "\x51\xa3\x40\x8f\x92\x9d\x38\xf5\xbc\xb6\xda\x21\x10\xff\xf3\xd2"
    "\xcd\x0c\x13\xec\x5f\x97\x44\x17\xc4\xa7\x7e\x3d\x64\x5d\x19\x73"
    "\x60\x81\x4f\xdc\x22\x2a\x90\x88\x46\xee\xb8\x14\xde\x5e\x0b\xdb"
    "\xe0\x32\x3a\x0a\x49\x06\x24\x5c\xc2\xd3\xac\x62\x91\x95\xe4\x79"
    "\xe7\xc8\x37\x6d\x8d\xd5\x4e\xa9\x6c\x56\xf4\xea\x65\x7a\xae\x08"
    "\xba\x78\x25\x2e\x1c\xa6\xb4\xc6\xe8\xdd\x74\x1f\x4b\xbd\x8b\x8a"
    "\x70\x3e\xb5\x66\x48\x03\xf6\x0e\x61\x35\x57\xb9\x86\xc1\x1d\x9e"
    "\xe1\xf8\x98\x11\x69\xd9\x8e\x94\x9b\x1e\x87\xe9\xce\x55\x28\xdf"
    "\x8c\xa1\x89\x0d\xbf\xe6\x42\x68\x41\x99\x2d\x0f\xb0\x54\xbb\x16"
    [i]&255;
    unsigned s2=s1<<1;
    if (s2>=0x100) s2^=0x11b;
    unsigned s3=s1^s2;
    Te0[i]=s2<<24|s1<<16|s1<<8|s3;
    Te1[i]=s3<<24|s2<<16|s1<<8|s1;
    Te2[i]=s1<<24|s3<<16|s2<<8|s1;
    Te3[i]=s1<<24|s1<<16|s3<<8|s2;
    Te4[i]=s1<<24|s1<<16|s1<<8|s1;
  }
  // setup the forward key
  Nr = 10 + ((keylen/8)-2)*2;  // 10, 12, or 14 rounds
  int i = 0;
  U32* rk = &ek[0];
  U32 temp;
  static const U32 rcon[10] = {
    0x01000000UL, 0x02000000UL, 0x04000000UL, 0x08000000UL,
    0x10000000UL, 0x20000000UL, 0x40000000UL, 0x80000000UL,
    0x1B000000UL, 0x36000000UL};  // round constants
  LOAD32H(rk[0], key   );
  LOAD32H(rk[1], key +  4);
  LOAD32H(rk[2], key +  8);
  LOAD32H(rk[3], key + 12);
  if (keylen == 16) {
    for (;;) {
      temp  = rk[3];
      rk[4] = rk[0] ^ setup_mix(temp) ^ rcon[i];
      rk[5] = rk[1] ^ rk[4];
      rk[6] = rk[2] ^ rk[5];
      rk[7] = rk[3] ^ rk[6];
      if (++i == 10) {
         break;
      }
      rk += 4;
    }
  }
  else if (keylen == 24) {
    LOAD32H(rk[4], key + 16);
    LOAD32H(rk[5], key + 20);
    for (;;) {
      temp = rk[5];
      rk[ 6] = rk[ 0] ^ setup_mix(temp) ^ rcon[i];
      rk[ 7] = rk[ 1] ^ rk[ 6];
      rk[ 8] = rk[ 2] ^ rk[ 7];
      rk[ 9] = rk[ 3] ^ rk[ 8];
      if (++i == 8) {
        break;
      }
      rk[10] = rk[ 4] ^ rk[ 9];
      rk[11] = rk[ 5] ^ rk[10];
      rk += 6;
    }
  }
  else if (keylen == 32) {
    LOAD32H(rk[4], key + 16);
    LOAD32H(rk[5], key + 20);
    LOAD32H(rk[6], key + 24);
    LOAD32H(rk[7], key + 28);
    for (;;) {
      temp = rk[7];
      rk[ 8] = rk[ 0] ^ setup_mix(temp) ^ rcon[i];
      rk[ 9] = rk[ 1] ^ rk[ 8];
      rk[10] = rk[ 2] ^ rk[ 9];
      rk[11] = rk[ 3] ^ rk[10];
      if (++i == 7) {
        break;
      }
      temp = rk[11];
      rk[12] = rk[ 4] ^ setup_mix(temp<<24|temp>>8);
      rk[13] = rk[ 5] ^ rk[12];
      rk[14] = rk[ 6] ^ rk[13];
      rk[15] = rk[ 7] ^ rk[14];
      rk += 8;
    }
  }
}
// Encrypt to ct[16]
void AES_CTR::encrypt(U32 s0, U32 s1, U32 s2, U32 s3, unsigned char* ct) {
  int r = Nr >> 1;
  U32 *rk = &ek[0];
  U32 t0=0, t1=0, t2=0, t3=0;
  s0 ^= rk[0];
  s1 ^= rk[1];
  s2 ^= rk[2];
  s3 ^= rk[3];
  for (;;) {
    t0 =
      Te0[byte(s0, 3)] ^
      Te1[byte(s1, 2)] ^
      Te2[byte(s2, 1)] ^
      Te3[byte(s3, 0)] ^
      rk[4];
    t1 =
      Te0[byte(s1, 3)] ^
      Te1[byte(s2, 2)] ^
      Te2[byte(s3, 1)] ^
      Te3[byte(s0, 0)] ^
      rk[5];
    t2 =
      Te0[byte(s2, 3)] ^
      Te1[byte(s3, 2)] ^
      Te2[byte(s0, 1)] ^
      Te3[byte(s1, 0)] ^
      rk[6];
    t3 =
      Te0[byte(s3, 3)] ^
      Te1[byte(s0, 2)] ^
      Te2[byte(s1, 1)] ^
      Te3[byte(s2, 0)] ^
      rk[7];
    rk += 8;
    if (--r == 0) {
      break;
    }
    s0 =
      Te0[byte(t0, 3)] ^
      Te1[byte(t1, 2)] ^
      Te2[byte(t2, 1)] ^
      Te3[byte(t3, 0)] ^
      rk[0];
    s1 =
      Te0[byte(t1, 3)] ^
      Te1[byte(t2, 2)] ^
      Te2[byte(t3, 1)] ^
      Te3[byte(t0, 0)] ^
      rk[1];
    s2 =
      Te0[byte(t2, 3)] ^
      Te1[byte(t3, 2)] ^
      Te2[byte(t0, 1)] ^
      Te3[byte(t1, 0)] ^
      rk[2];
    s3 =
      Te0[byte(t3, 3)] ^
      Te1[byte(t0, 2)] ^
      Te2[byte(t1, 1)] ^
      Te3[byte(t2, 0)] ^
      rk[3];
  }
  // apply last round and map cipher state to byte array block:
  s0 =
    (Te4_3[byte(t0, 3)]) ^
    (Te4_2[byte(t1, 2)]) ^
    (Te4_1[byte(t2, 1)]) ^
    (Te4_0[byte(t3, 0)]) ^
    rk[0];
  STORE32H(s0, ct);
  s1 =
    (Te4_3[byte(t1, 3)]) ^
    (Te4_2[byte(t2, 2)]) ^
    (Te4_1[byte(t3, 1)]) ^
    (Te4_0[byte(t0, 0)]) ^
    rk[1];
  STORE32H(s1, ct+4);
  s2 =
    (Te4_3[byte(t2, 3)]) ^
    (Te4_2[byte(t3, 2)]) ^
    (Te4_1[byte(t0, 1)]) ^
    (Te4_0[byte(t1, 0)]) ^
    rk[2];
  STORE32H(s2, ct+8);
  s3 =
    (Te4_3[byte(t3, 3)]) ^
    (Te4_2[byte(t0, 2)]) ^
    (Te4_1[byte(t1, 1)]) ^
    (Te4_0[byte(t2, 0)]) ^
    rk[3];
  STORE32H(s3, ct+12);
}
// Encrypt or decrypt slice buf[0..n-1] at offset by XOR with AES(i) where
// i is the 128 bit big-endian distance from the start in 16 byte blocks.
void AES_CTR::encrypt(char* buf, int n, U64 offset) {
  for (U64 i=offset/16; i<=(offset+n)/16; ++i) {
    unsigned char ct[16];
    encrypt(iv0, iv1, i>>32, i, ct);
    for (int j=0; j<16; ++j) {
      const int k=(i*16-offset)+j;
      if (k>=0 && k<n)
        buf[k]^=ct[j];
    }
  }
}
#undef setup_mix
#undef Te4_3
#undef Te4_2
#undef Te4_1
#undef Te4_0
//////////////////////////// stretchKey //////////////////////
// PBKDF2(pw[0..pwlen], salt[0..saltlen], c) to buf[0..dkLen-1]
// using HMAC-SHA256, for the special case of c = 1 iterations
// output size dkLen a multiple of 32, and pwLen <= 64.
static void pbkdf2(const char* pw, int pwLen, const char* salt, int saltLen,
                    char* buf, int dkLen) {
  assert(dkLen%32==0);
  assert(pwLen<=64);
  libzpaq::SHA256 sha256;
  char b[32];
  for (int i=1; i*32<=dkLen; ++i) {
    for (int j=0; j<pwLen; ++j) sha256.put(pw[j]^0x36);
    for (int j=pwLen; j<64; ++j) sha256.put(0x36);
    for (int j=0; j<saltLen; ++j) sha256.put(salt[j]);
    for (int j=24; j>=0; j-=8) sha256.put(i>>j);
    memcpy(b, sha256.result(), 32);
    for (int j=0; j<pwLen; ++j) sha256.put(pw[j]^0x5c);
    for (int j=pwLen; j<64; ++j) sha256.put(0x5c);
    for (int j=0; j<32; ++j) sha256.put(b[j]);
    memcpy(buf+i*32-32, sha256.result(), 32);
  }
}
/// LICENSE_END.1

/// LICENSE_START.2
// Hash b[0..15] using 8 rounds of salsa20
// Modified from http://cr.yp.to/salsa20.html (public domain) to 8 rounds
static void salsa8(U32* b) {
  unsigned x[16]={0};
  memcpy(x, b, 64);
  for (unsigned int i=0; i<4; ++i) {
    #define R(a,b) (((a)<<(b))+((a)>>(32-b)))
    x[ 4] ^= R(x[ 0]+x[12], 7);  x[ 8] ^= R(x[ 4]+x[ 0], 9);
    x[12] ^= R(x[ 8]+x[ 4],13);  x[ 0] ^= R(x[12]+x[ 8],18);
    x[ 9] ^= R(x[ 5]+x[ 1], 7);  x[13] ^= R(x[ 9]+x[ 5], 9);
    x[ 1] ^= R(x[13]+x[ 9],13);  x[ 5] ^= R(x[ 1]+x[13],18);
    x[14] ^= R(x[10]+x[ 6], 7);  x[ 2] ^= R(x[14]+x[10], 9);
    x[ 6] ^= R(x[ 2]+x[14],13);  x[10] ^= R(x[ 6]+x[ 2],18);
    x[ 3] ^= R(x[15]+x[11], 7);  x[ 7] ^= R(x[ 3]+x[15], 9);
    x[11] ^= R(x[ 7]+x[ 3],13);  x[15] ^= R(x[11]+x[ 7],18);
    x[ 1] ^= R(x[ 0]+x[ 3], 7);  x[ 2] ^= R(x[ 1]+x[ 0], 9);
    x[ 3] ^= R(x[ 2]+x[ 1],13);  x[ 0] ^= R(x[ 3]+x[ 2],18);
    x[ 6] ^= R(x[ 5]+x[ 4], 7);  x[ 7] ^= R(x[ 6]+x[ 5], 9);
    x[ 4] ^= R(x[ 7]+x[ 6],13);  x[ 5] ^= R(x[ 4]+x[ 7],18);
    x[11] ^= R(x[10]+x[ 9], 7);  x[ 8] ^= R(x[11]+x[10], 9);
    x[ 9] ^= R(x[ 8]+x[11],13);  x[10] ^= R(x[ 9]+x[ 8],18);
    x[12] ^= R(x[15]+x[14], 7);  x[13] ^= R(x[12]+x[15], 9);
    x[14] ^= R(x[13]+x[12],13);  x[15] ^= R(x[14]+x[13],18);
    #undef R
  }
  for (unsigned int i=0; i<16; ++i) b[i]+=x[i];
}
// BlockMix_{Salsa20/8, r} on b[0..128*r-1]
static void blockmix(U32* b, int r) {
  assert(r<=8);
  U32 x[16];
  U32 y[256];
  memcpy(x, b+32*r-16, 64);
  for (int i=0; i<2*r; ++i) {
    for (int j=0; j<16; ++j) x[j]^=b[i*16+j];
    salsa8(x);
    memcpy(&y[i*16], x, 64);
  }
  for (int i=0; i<r; ++i) memcpy(b+i*16, &y[i*32], 64);
  for (int i=0; i<r; ++i) memcpy(b+(i+r)*16, &y[i*32+16], 64);
}
// Mix b[0..128*r-1]. Uses 128*r*n bytes of memory and O(r*n) time
static void smix(char* b, int r, int n) {
  libzpaq::Array<U32> x(32*r), v(32*r*n);
  for (int i=0; i<r*128; ++i) x[i/4]+=(b[i]&255)<<i%4*8;
  for (int i=0; i<n; ++i) {
    memcpy(&v[i*r*32], &x[0], r*128);
    blockmix(&x[0], r);
  }
  for (int i=0; i<n; ++i) {
    U32 j=x[(2*r-1)*16]&(n-1);
    for (int k=0; k<r*32; ++k) x[k]^=v[j*r*32+k];
    blockmix(&x[0], r);
  }
  for (int i=0; i<r*128; ++i) b[i]=x[i/4]>>(i%4*8);
}
// Strengthen password pw[0..pwlen-1] and salt[0..saltlen-1]
// to produce key buf[0..buflen-1]. Uses O(n*r*p) time and 128*r*n bytes
// of memory. n must be a power of 2 and r <= 8.
void scrypt(const char* pw, int pwlen,
            const char* salt, int saltlen,
            int n, int r, int p, char* buf, int buflen) {
  assert(r<=8);
  assert(n>0 && (n&(n-1))==0);  // power of 2?
  libzpaq::Array<char> b(p*r*128);
  pbkdf2(pw, pwlen, salt, saltlen,  &b[0], p*r*128);
  for (int i=0; i<p; ++i) smix(&b[i*r*128], r, n);
  pbkdf2(pw, pwlen, &b[0], p*r*128,  buf, buflen);
}
// Stretch key in[0..31], assumed to be SHA256(password), with
// NUL terminate salt to produce new key out[0..31]
void stretchKey(char* out, const char* in, const char* salt) {
  scrypt(in, 32, salt, 32, 1<<14, 8, 1, out, 32);
}
/// LICENSE_END.2



//////////////////////////// random //////////////////////////
// Put n cryptographic random bytes in buf[0..n-1].
// The first byte will not be 'z' or '7' (start of a ZPAQ archive).
// For a pure random number, discard the first byte.
// In VC++, must link to advapi32.lib.
void random(char* buf, int n) {
#ifdef unix
  FILE* in=fopen("/dev/urandom", "rb");
  if (in && int(fread(buf, 1, n, in))==n)
    fclose(in);
  else {
    error("key generation failed");
  }
#else
  HCRYPTPROV h;
  if (CryptAcquireContext(&h, NULL, NULL, PROV_RSA_FULL,
      CRYPT_VERIFYCONTEXT) && CryptGenRandom(h, n, (BYTE*)buf))
    CryptReleaseContext(h, 0);
  else {
    printf("CryptGenRandom: error %d\n", int(GetLastError()));
    error("key generation failed");
  }
#endif // corresponds to #ifdef (#ifdef unix)
	if (flagsalt)
	{
		color_yellow();
		bigwarning();
		myprintf("10528! ENFORCING ZERO SALT!\n");
		memset(buf,0,n);
	}
  if (n>=1 && (buf[0]=='z' || buf[0]=='7'))
    buf[0]^=0x80;
}
//////////////////////////// Component ///////////////////////
// A Component is a context model, indirect context model, match model,
// fixed weight mixer, adaptive 2 input mixer without or with current
// partial byte as context, adaptive m input mixer (without or with),
// or SSE (without or with).
const int compsize[256]={0,2,3,2,3,4,6,6,3,5};
void Component::init() {
  limit=cxt=a=b=c=0;
  cm.resize(0);
  ht.resize(0);
  a16.resize(0);
}
////////////////////////// StateTable ////////////////////////
// sns[i*4] -> next state if 0, next state if 1, n0, n1
static const U8 sns[1024]={
     1,     2,     0,     0,     3,     5,     1,     0,
     4,     6,     0,     1,     7,     9,     2,     0,
     8,    11,     1,     1,     8,    11,     1,     1,
    10,    12,     0,     2,    13,    15,     3,     0,
    14,    17,     2,     1,    14,    17,     2,     1,
    16,    19,     1,     2,    16,    19,     1,     2,
    18,    20,     0,     3,    21,    23,     4,     0,
    22,    25,     3,     1,    22,    25,     3,     1,
    24,    27,     2,     2,    24,    27,     2,     2,
    26,    29,     1,     3,    26,    29,     1,     3,
    28,    30,     0,     4,    31,    33,     5,     0,
    32,    35,     4,     1,    32,    35,     4,     1,
    34,    37,     3,     2,    34,    37,     3,     2,
    36,    39,     2,     3,    36,    39,     2,     3,
    38,    41,     1,     4,    38,    41,     1,     4,
    40,    42,     0,     5,    43,    33,     6,     0,
    44,    47,     5,     1,    44,    47,     5,     1,
    46,    49,     4,     2,    46,    49,     4,     2,
    48,    51,     3,     3,    48,    51,     3,     3,
    50,    53,     2,     4,    50,    53,     2,     4,
    52,    55,     1,     5,    52,    55,     1,     5,
    40,    56,     0,     6,    57,    45,     7,     0,
    58,    47,     6,     1,    58,    47,     6,     1,
    60,    63,     5,     2,    60,    63,     5,     2,
    62,    65,     4,     3,    62,    65,     4,     3,
    64,    67,     3,     4,    64,    67,     3,     4,
    66,    69,     2,     5,    66,    69,     2,     5,
    52,    71,     1,     6,    52,    71,     1,     6,
    54,    72,     0,     7,    73,    59,     8,     0,
    74,    61,     7,     1,    74,    61,     7,     1,
    76,    63,     6,     2,    76,    63,     6,     2,
    78,    81,     5,     3,    78,    81,     5,     3,
    80,    83,     4,     4,    80,    83,     4,     4,
    82,    85,     3,     5,    82,    85,     3,     5,
    66,    87,     2,     6,    66,    87,     2,     6,
    68,    89,     1,     7,    68,    89,     1,     7,
    70,    90,     0,     8,    91,    59,     9,     0,
    92,    77,     8,     1,    92,    77,     8,     1,
    94,    79,     7,     2,    94,    79,     7,     2,
    96,    81,     6,     3,    96,    81,     6,     3,
    98,   101,     5,     4,    98,   101,     5,     4,
   100,   103,     4,     5,   100,   103,     4,     5,
    82,   105,     3,     6,    82,   105,     3,     6,
    84,   107,     2,     7,    84,   107,     2,     7,
    86,   109,     1,     8,    86,   109,     1,     8,
    70,   110,     0,     9,   111,    59,    10,     0,
   112,    77,     9,     1,   112,    77,     9,     1,
   114,    97,     8,     2,   114,    97,     8,     2,
   116,    99,     7,     3,   116,    99,     7,     3,
    62,   101,     6,     4,    62,   101,     6,     4,
    80,    83,     5,     5,    80,    83,     5,     5,
   100,    67,     4,     6,   100,    67,     4,     6,
   102,   119,     3,     7,   102,   119,     3,     7,
   104,   121,     2,     8,   104,   121,     2,     8,
    86,   123,     1,     9,    86,   123,     1,     9,
    70,   124,     0,    10,   125,    59,    11,     0,
   126,    77,    10,     1,   126,    77,    10,     1,
   128,    97,     9,     2,   128,    97,     9,     2,
    60,    63,     8,     3,    60,    63,     8,     3,
    66,    69,     3,     8,    66,    69,     3,     8,
   104,   131,     2,     9,   104,   131,     2,     9,
    86,   133,     1,    10,    86,   133,     1,    10,
    70,   134,     0,    11,   135,    59,    12,     0,
   136,    77,    11,     1,   136,    77,    11,     1,
   138,    97,    10,     2,   138,    97,    10,     2,
   104,   141,     2,    10,   104,   141,     2,    10,
    86,   143,     1,    11,    86,   143,     1,    11,
    70,   144,     0,    12,   145,    59,    13,     0,
   146,    77,    12,     1,   146,    77,    12,     1,
   148,    97,    11,     2,   148,    97,    11,     2,
   104,   151,     2,    11,   104,   151,     2,    11,
    86,   153,     1,    12,    86,   153,     1,    12,
    70,   154,     0,    13,   155,    59,    14,     0,
   156,    77,    13,     1,   156,    77,    13,     1,
   158,    97,    12,     2,   158,    97,    12,     2,
   104,   161,     2,    12,   104,   161,     2,    12,
    86,   163,     1,    13,    86,   163,     1,    13,
    70,   164,     0,    14,   165,    59,    15,     0,
   166,    77,    14,     1,   166,    77,    14,     1,
   168,    97,    13,     2,   168,    97,    13,     2,
   104,   171,     2,    13,   104,   171,     2,    13,
    86,   173,     1,    14,    86,   173,     1,    14,
    70,   174,     0,    15,   175,    59,    16,     0,
   176,    77,    15,     1,   176,    77,    15,     1,
   178,    97,    14,     2,   178,    97,    14,     2,
   104,   181,     2,    14,   104,   181,     2,    14,
    86,   183,     1,    15,    86,   183,     1,    15,
    70,   184,     0,    16,   185,    59,    17,     0,
   186,    77,    16,     1,   186,    77,    16,     1,
    74,    97,    15,     2,    74,    97,    15,     2,
   104,    89,     2,    15,   104,    89,     2,    15,
    86,   187,     1,    16,    86,   187,     1,    16,
    70,   188,     0,    17,   189,    59,    18,     0,
   190,    77,    17,     1,    86,   191,     1,    17,
    70,   192,     0,    18,   193,    59,    19,     0,
   194,    77,    18,     1,    86,   195,     1,    18,
    70,   196,     0,    19,   193,    59,    20,     0,
   197,    77,    19,     1,    86,   198,     1,    19,
    70,   196,     0,    20,   199,    77,    20,     1,
    86,   200,     1,    20,   201,    77,    21,     1,
    86,   202,     1,    21,   203,    77,    22,     1,
    86,   204,     1,    22,   205,    77,    23,     1,
    86,   206,     1,    23,   207,    77,    24,     1,
    86,   208,     1,    24,   209,    77,    25,     1,
    86,   210,     1,    25,   211,    77,    26,     1,
    86,   212,     1,    26,   213,    77,    27,     1,
    86,   214,     1,    27,   215,    77,    28,     1,
    86,   216,     1,    28,   217,    77,    29,     1,
    86,   218,     1,    29,   219,    77,    30,     1,
    86,   220,     1,    30,   221,    77,    31,     1,
    86,   222,     1,    31,   223,    77,    32,     1,
    86,   224,     1,    32,   225,    77,    33,     1,
    86,   226,     1,    33,   227,    77,    34,     1,
    86,   228,     1,    34,   229,    77,    35,     1,
    86,   230,     1,    35,   231,    77,    36,     1,
    86,   232,     1,    36,   233,    77,    37,     1,
    86,   234,     1,    37,   235,    77,    38,     1,
    86,   236,     1,    38,   237,    77,    39,     1,
    86,   238,     1,    39,   239,    77,    40,     1,
    86,   240,     1,    40,   241,    77,    41,     1,
    86,   242,     1,    41,   243,    77,    42,     1,
    86,   244,     1,    42,   245,    77,    43,     1,
    86,   246,     1,    43,   247,    77,    44,     1,
    86,   248,     1,    44,   249,    77,    45,     1,
    86,   250,     1,    45,   251,    77,    46,     1,
    86,   252,     1,    46,   253,    77,    47,     1,
    86,   254,     1,    47,   253,    77,    48,     1,
    86,   254,     1,    48,     0,     0,     0,     0
};
// Initialize next state table ns[state*4] -> next if 0, next if 1, n0, n1
StateTable::StateTable() {
  memcpy(ns, sns, sizeof(ns));
}
/////////////////////////// ZPAQL //////////////////////////
// Write header to out2, return true if HCOMP/PCOMP section is present.
// If pp is true, then write only the postprocessor code.
bool ZPAQL::write(Writer* out2, bool pp) {
  if (header.size()<=6) return false;
  assert(header[0]+256*header[1]==(cend-2)+hend-hbegin);
  assert(cend>=7);
  assert(hbegin>=cend);
  assert(hend>=hbegin);
  assert(out2);
  if (!pp) {  // if not a postprocessor then write COMP
    for (int i=0; i<cend; ++i)
      out2->put(header[i]);
  }
  else {  // write PCOMP size only
    out2->put((hend-hbegin)&255);
    out2->put((hend-hbegin)>>8);
  }
  for (int i=hbegin; i<hend; ++i)
    out2->put(header[i]);
  return true;
}
// Read header from in2
int ZPAQL::read(Reader* in2) {
  // Get header size and allocate
  int hsize=in2->get();
  hsize+=in2->get()*256;
  header.resize(hsize+300);
  cend=hbegin=hend=0;
  header[cend++]=hsize&255;
  header[cend++]=hsize>>8;
  while (cend<7) header[cend++]=in2->get(); // hh hm ph pm n
  // Read COMP
  int n=header[cend-1];
  for (int i=0; i<n; ++i) {
    int type=in2->get();  // component type
    if (type<0 || type>255) error("unexpected end of file");
    header[cend++]=type;  // component type
    int size=compsize[type];
    if (size<1) error("Invalid component type");
    if (cend+size>hsize) error("COMP overflows header");
    for (int j=1; j<size; ++j)
      header[cend++]=in2->get();
  }
  if ((header[cend++]=in2->get())!=0) error("missing COMP END");
  // Insert a guard gap and read HCOMP
  hbegin=hend=cend+128;
  if (hend>hsize+129) error("missing HCOMP");
  while (hend<hsize+129) {
    assert(hend<header.isize()-8);
    int op=in2->get();
    if (op==-1) error("unexpected end of file");
    header[hend++]=op;
  }
  if ((header[hend++]=in2->get())!=0) error("missing HCOMP END");
  assert(cend>=7 && cend<header.isize());
  assert(hbegin==cend+128 && hbegin<header.isize());
  assert(hend>hbegin && hend<header.isize());
  assert(hsize==header[0]+256*header[1]);
  assert(hsize==cend-2+hend-hbegin);
  allocx(rcode, rcode_size, 0);  // clear JIT code
  return cend+hend-hbegin;
}
// Free memory, but preserve output, sha1 pointers
void ZPAQL::clear() {
  cend=hbegin=hend=0;  // COMP and HCOMP locations
  a=b=c=d=f=pc=0;      // machine state
  header.resize(0);
  h.resize(0);
  m.resize(0);
  r.resize(0);
  allocx(rcode, rcode_size, 0);
}
// Constructor
ZPAQL::ZPAQL() {
  output=0;
  sha1=0;
  rcode=0;
  rcode_size=0;
  clear();
  outbuf.resize(1<<14);
  bufptr=0;
}
ZPAQL::~ZPAQL() {
  allocx(rcode, rcode_size, 0);
}
// Initialize machine state as HCOMP
void ZPAQL::inith() {
  assert(header.isize()>6);
  assert(output==0);
  assert(sha1==0);
  init(header[2], header[3]); // hh, hm
}
// Initialize machine state as PCOMP
void ZPAQL::initp() {
  assert(header.isize()>6);
  init(header[4], header[5]); // ph, pm
}
// Flush pending output
void ZPAQL::flush() {
  if (output) output->write(&outbuf[0], bufptr);
  if (sha1) sha1->write(&outbuf[0], bufptr);
  bufptr=0;
}
// pow(2, x)
static double pow2(int x) {
  double r=1;
  for (; x>0; x--) r+=r;
  return r;
}
// Return memory requirement in bytes
double ZPAQL::memory() {
  double mem=pow2(header[2]+2)+pow2(header[3])  // hh hm
            +pow2(header[4]+2)+pow2(header[5])  // ph pm
            +header.size();
  int cp=7;  // start of comp list
  for (unsigned int i=0; i<header[6]; ++i) {  // n
    assert(cp<cend);
    double size=pow2(header[cp+1]); // sizebits
    switch(header[cp]) {
      case CM: mem+=4*size; break;
      case ICM: mem+=64*size+1024; break;
      case MATCH: mem+=4*size+pow2(header[cp+2]); break; // bufbits
      case MIX2: mem+=2*size; break;
      case MIX: mem+=4*size*header[cp+3]; break; // m
      case ISSE: mem+=64*size+2048; break;
      case SSE: mem+=128*size; break;
    }
    cp+=compsize[header[cp]];
  }
  return mem;
}
// Initialize machine state to run a program.
void ZPAQL::init(int hbits, int mbits) {
  assert(header.isize()>0);
  assert(cend>=7);
  assert(hbegin>=cend+128);
  assert(hend>=hbegin);
  assert(hend<header.isize()-130);
  assert(header[0]+256*header[1]==(cend-2)+hend-hbegin);
  assert(bufptr==0);
  assert(outbuf.isize()>0);
  if (hbits>32) error("H too big");
  if (mbits>32) error("M too big");
  h.resize(1, hbits);
  m.resize(1, mbits);
  r.resize(256);
  a=b=c=d=pc=f=0;
}

// Run program on input by interpreting header
void ZPAQL::run0(U32 input) {
  assert(cend>6);
  assert(hbegin>=cend+128);
  assert(hend>=hbegin);
  assert(hend<header.isize()-130);
  assert(m.size()>0);
  assert(h.size()>0);
  assert(header[0]+256*header[1]==cend+hend-hbegin-2);
  pc=hbegin;
  a=input;
  while (execute()) ;
}

// Execute one instruction, return 0 after HALT else 1
int ZPAQL::execute() {
  switch(header[pc++]) {
    case 0: err(); break; // ERROR
    case 1: ++a; break; // A++
    case 2: --a; break; // A--
    case 3: a = ~a; break; // A!
    case 4: a = 0; break; // A=0
    case 7: a = r[header[pc++]]; break; // A=R N
    case 8: swap(b); break; // B<>A
    case 9: ++b; break; // B++
    case 10: --b; break; // B--
    case 11: b = ~b; break; // B!
    case 12: b = 0; break; // B=0
    case 15: b = r[header[pc++]]; break; // B=R N
    case 16: swap(c); break; // C<>A
    case 17: ++c; break; // C++
    case 18: --c; break; // C--
    case 19: c = ~c; break; // C!
    case 20: c = 0; break; // C=0
    case 23: c = r[header[pc++]]; break; // C=R N
    case 24: swap(d); break; // D<>A
    case 25: ++d; break; // D++
    case 26: --d; break; // D--
    case 27: d = ~d; break; // D!
    case 28: d = 0; break; // D=0
    case 31: d = r[header[pc++]]; break; // D=R N
    case 32: swap(m(b)); break; // *B<>A
    case 33: ++m(b); break; // *B++
    case 34: --m(b); break; // *B--
    case 35: m(b) = ~m(b); break; // *B!
    case 36: m(b) = 0; break; // *B=0
    case 39: if (f) pc+=((header[pc]+128)&255)-127; else ++pc; break; // JT N
    case 40: swap(m(c)); break; // *C<>A
    case 41: ++m(c); break; // *C++
    case 42: --m(c); break; // *C--
    case 43: m(c) = ~m(c); break; // *C!
    case 44: m(c) = 0; break; // *C=0
    case 47: if (!f) pc+=((header[pc]+128)&255)-127; else ++pc; break; // JF N
    case 48: swap(h(d)); break; // *D<>A
    case 49: ++h(d); break; // *D++
    case 50: --h(d); break; // *D--
    case 51: h(d) = ~h(d); break; // *D!
    case 52: h(d) = 0; break; // *D=0
    case 55: r[header[pc++]] = a; break; // R=A N
    case 56: return 0  ; // HALT
    case 57: outc(a&255); break; // OUT
    case 59: a = (a+m(b)+512)*773; break; // HASH
    case 60: h(d) = (h(d)+a+512)*773; break; // HASHD
    case 63: pc+=((header[pc]+128)&255)-127; break; // JMP N
    case 64: break; // A=A
    case 65: a = b; break; // A=B
    case 66: a = c; break; // A=C
    case 67: a = d; break; // A=D
    case 68: a = m(b); break; // A=*B
    case 69: a = m(c); break; // A=*C
    case 70: a = h(d); break; // A=*D
    case 71: a = header[pc++]; break; // A= N
    case 72: b = a; break; // B=A
    case 73: break; // B=B
    case 74: b = c; break; // B=C
    case 75: b = d; break; // B=D
    case 76: b = m(b); break; // B=*B
    case 77: b = m(c); break; // B=*C
    case 78: b = h(d); break; // B=*D
    case 79: b = header[pc++]; break; // B= N
    case 80: c = a; break; // C=A
    case 81: c = b; break; // C=B
    case 82: break; // C=C
    case 83: c = d; break; // C=D
    case 84: c = m(b); break; // C=*B
    case 85: c = m(c); break; // C=*C
    case 86: c = h(d); break; // C=*D
    case 87: c = header[pc++]; break; // C= N
    case 88: d = a; break; // D=A
    case 89: d = b; break; // D=B
    case 90: d = c; break; // D=C
    case 91: break; // D=D
    case 92: d = m(b); break; // D=*B
    case 93: d = m(c); break; // D=*C
    case 94: d = h(d); break; // D=*D
    case 95: d = header[pc++]; break; // D= N
    case 96: m(b) = a; break; // *B=A
    case 97: m(b) = b; break; // *B=B
    case 98: m(b) = c; break; // *B=C
    case 99: m(b) = d; break; // *B=D
    case 100: break; // *B=*B
    case 101: m(b) = m(c); break; // *B=*C
    case 102: m(b) = h(d); break; // *B=*D
    case 103: m(b) = header[pc++]; break; // *B= N
    case 104: m(c) = a; break; // *C=A
    case 105: m(c) = b; break; // *C=B
    case 106: m(c) = c; break; // *C=C
    case 107: m(c) = d; break; // *C=D
    case 108: m(c) = m(b); break; // *C=*B
    case 109: break; // *C=*C
    case 110: m(c) = h(d); break; // *C=*D
    case 111: m(c) = header[pc++]; break; // *C= N
    case 112: h(d) = a; break; // *D=A
    case 113: h(d) = b; break; // *D=B
    case 114: h(d) = c; break; // *D=C
    case 115: h(d) = d; break; // *D=D
    case 116: h(d) = m(b); break; // *D=*B
    case 117: h(d) = m(c); break; // *D=*C
    case 118: break; // *D=*D
    case 119: h(d) = header[pc++]; break; // *D= N
    case 128: a += a; break; // A+=A
    case 129: a += b; break; // A+=B
    case 130: a += c; break; // A+=C
    case 131: a += d; break; // A+=D
    case 132: a += m(b); break; // A+=*B
    case 133: a += m(c); break; // A+=*C
    case 134: a += h(d); break; // A+=*D
    case 135: a += header[pc++]; break; // A+= N
    case 136: a -= a; break; // A-=A
    case 137: a -= b; break; // A-=B
    case 138: a -= c; break; // A-=C
    case 139: a -= d; break; // A-=D
    case 140: a -= m(b); break; // A-=*B
    case 141: a -= m(c); break; // A-=*C
    case 142: a -= h(d); break; // A-=*D
    case 143: a -= header[pc++]; break; // A-= N
    case 144: a *= a; break; // A*=A
    case 145: a *= b; break; // A*=B
    case 146: a *= c; break; // A*=C
    case 147: a *= d; break; // A*=D
    case 148: a *= m(b); break; // A*=*B
    case 149: a *= m(c); break; // A*=*C
    case 150: a *= h(d); break; // A*=*D
    case 151: a *= header[pc++]; break; // A*= N
    case 152: zdiv(a); break; // A/=A
    case 153: zdiv(b); break; // A/=B
    case 154: zdiv(c); break; // A/=C
    case 155: zdiv(d); break; // A/=D
    case 156: zdiv(m(b)); break; // A/=*B
    case 157: zdiv(m(c)); break; // A/=*C
    case 158: zdiv(h(d)); break; // A/=*D
    case 159: zdiv(header[pc++]); break; // A/= N
    case 160: mod(a); break; // A%=A
    case 161: mod(b); break; // A%=B
    case 162: mod(c); break; // A%=C
    case 163: mod(d); break; // A%=D
    case 164: mod(m(b)); break; // A%=*B
    case 165: mod(m(c)); break; // A%=*C
    case 166: mod(h(d)); break; // A%=*D
    case 167: mod(header[pc++]); break; // A%= N
    case 168: a &= a; break; // A&=A
    case 169: a &= b; break; // A&=B
    case 170: a &= c; break; // A&=C
    case 171: a &= d; break; // A&=D
    case 172: a &= m(b); break; // A&=*B
    case 173: a &= m(c); break; // A&=*C
    case 174: a &= h(d); break; // A&=*D
    case 175: a &= header[pc++]; break; // A&= N
    case 176: a &= ~ a; break; // A&~A
    case 177: a &= ~ b; break; // A&~B
    case 178: a &= ~ c; break; // A&~C
    case 179: a &= ~ d; break; // A&~D
    case 180: a &= ~ m(b); break; // A&~*B
    case 181: a &= ~ m(c); break; // A&~*C
    case 182: a &= ~ h(d); break; // A&~*D
    case 183: a &= ~ header[pc++]; break; // A&~ N
    case 184: a |= a; break; // A|=A
    case 185: a |= b; break; // A|=B
    case 186: a |= c; break; // A|=C
    case 187: a |= d; break; // A|=D
    case 188: a |= m(b); break; // A|=*B
    case 189: a |= m(c); break; // A|=*C
    case 190: a |= h(d); break; // A|=*D
    case 191: a |= header[pc++]; break; // A|= N
    case 192: a ^= a; break; // A^=A
    case 193: a ^= b; break; // A^=B
    case 194: a ^= c; break; // A^=C
    case 195: a ^= d; break; // A^=D
    case 196: a ^= m(b); break; // A^=*B
    case 197: a ^= m(c); break; // A^=*C
    case 198: a ^= h(d); break; // A^=*D
    case 199: a ^= header[pc++]; break; // A^= N
    case 200: a <<= (a&31); break; // A<<=A
    case 201: a <<= (b&31); break; // A<<=B
    case 202: a <<= (c&31); break; // A<<=C
    case 203: a <<= (d&31); break; // A<<=D
    case 204: a <<= (m(b)&31); break; // A<<=*B
    case 205: a <<= (m(c)&31); break; // A<<=*C
    case 206: a <<= (h(d)&31); break; // A<<=*D
    case 207: a <<= (header[pc++]&31); break; // A<<= N
    case 208: a >>= (a&31); break; // A>>=A
    case 209: a >>= (b&31); break; // A>>=B
    case 210: a >>= (c&31); break; // A>>=C
    case 211: a >>= (d&31); break; // A>>=D
    case 212: a >>= (m(b)&31); break; // A>>=*B
    case 213: a >>= (m(c)&31); break; // A>>=*C
    case 214: a >>= (h(d)&31); break; // A>>=*D
    case 215: a >>= (header[pc++]&31); break; // A>>= N
    case 216: f = 1; break; // A==A
    case 217: f = (a == b); break; // A==B
    case 218: f = (a == c); break; // A==C
    case 219: f = (a == d); break; // A==D
    case 220: f = (a == U32(m(b))); break; // A==*B
    case 221: f = (a == U32(m(c))); break; // A==*C
    case 222: f = (a == h(d)); break; // A==*D
    case 223: f = (a == U32(header[pc++])); break; // A== N
    case 224: f = 0; break; // A<A
    case 225: f = (a < b); break; // A<B
    case 226: f = (a < c); break; // A<C
    case 227: f = (a < d); break; // A<D
    case 228: f = (a < U32(m(b))); break; // A<*B
    case 229: f = (a < U32(m(c))); break; // A<*C
    case 230: f = (a < h(d)); break; // A<*D
    case 231: f = (a < U32(header[pc++])); break; // A< N
    case 232: f = 0; break; // A>A
    case 233: f = (a > b); break; // A>B
    case 234: f = (a > c); break; // A>C
    case 235: f = (a > d); break; // A>D
    case 236: f = (a > U32(m(b))); break; // A>*B
    case 237: f = (a > U32(m(c))); break; // A>*C
    case 238: f = (a > h(d)); break; // A>*D
    case 239: f = (a > U32(header[pc++])); break; // A> N
    case 255: if((pc=hbegin+header[pc]+256*header[pc+1])>=hend)err();break;//LJ
    default: err();
  }
  return 1;
}
// Print illegal instruction error message and exit
void ZPAQL::err() {
  error("ZPAQL execution error");
}
///////////////////////// Predictor /////////////////////////
// sdt2k[i]=2048/i;
static const int sdt2k[256]={
     0,  2048,  1024,   682,   512,   409,   341,   292,
   256,   227,   204,   186,   170,   157,   146,   136,
   128,   120,   113,   107,   102,    97,    93,    89,
    85,    81,    78,    75,    73,    70,    68,    66,
    64,    62,    60,    58,    56,    55,    53,    52,
    51,    49,    48,    47,    46,    45,    44,    43,
    42,    41,    40,    40,    39,    38,    37,    37,
    36,    35,    35,    34,    34,    33,    33,    32,
    32,    31,    31,    30,    30,    29,    29,    28,
    28,    28,    27,    27,    26,    26,    26,    25,
    25,    25,    24,    24,    24,    24,    23,    23,
    23,    23,    22,    22,    22,    22,    21,    21,
    21,    21,    20,    20,    20,    20,    20,    19,
    19,    19,    19,    19,    18,    18,    18,    18,
    18,    18,    17,    17,    17,    17,    17,    17,
    17,    16,    16,    16,    16,    16,    16,    16,
    16,    15,    15,    15,    15,    15,    15,    15,
    15,    14,    14,    14,    14,    14,    14,    14,
    14,    14,    14,    13,    13,    13,    13,    13,
    13,    13,    13,    13,    13,    13,    12,    12,
    12,    12,    12,    12,    12,    12,    12,    12,
    12,    12,    12,    11,    11,    11,    11,    11,
    11,    11,    11,    11,    11,    11,    11,    11,
    11,    11,    11,    10,    10,    10,    10,    10,
    10,    10,    10,    10,    10,    10,    10,    10,
    10,    10,    10,    10,    10,     9,     9,     9,
     9,     9,     9,     9,     9,     9,     9,     9,
     9,     9,     9,     9,     9,     9,     9,     9,
     9,     9,     9,     9,     8,     8,     8,     8,
     8,     8,     8,     8,     8,     8,     8,     8,
     8,     8,     8,     8,     8,     8,     8,     8,
     8,     8,     8,     8,     8,     8,     8,     8
};
// sdt[i]=(1<<17)/(i*2+3)*2;
static const int sdt[1024]={
 87380, 52428, 37448, 29126, 23830, 20164, 17476, 15420,
 13796, 12482, 11396, 10484,  9708,  9038,  8456,  7942,
  7488,  7084,  6720,  6392,  6096,  5824,  5576,  5348,
  5140,  4946,  4766,  4598,  4442,  4296,  4160,  4032,
  3912,  3798,  3692,  3590,  3494,  3404,  3318,  3236,
  3158,  3084,  3012,  2944,  2880,  2818,  2758,  2702,
  2646,  2594,  2544,  2496,  2448,  2404,  2360,  2318,
  2278,  2240,  2202,  2166,  2130,  2096,  2064,  2032,
  2000,  1970,  1940,  1912,  1884,  1858,  1832,  1806,
  1782,  1758,  1736,  1712,  1690,  1668,  1648,  1628,
  1608,  1588,  1568,  1550,  1532,  1514,  1496,  1480,
  1464,  1448,  1432,  1416,  1400,  1386,  1372,  1358,
  1344,  1330,  1316,  1304,  1290,  1278,  1266,  1254,
  1242,  1230,  1218,  1208,  1196,  1186,  1174,  1164,
  1154,  1144,  1134,  1124,  1114,  1106,  1096,  1086,
  1078,  1068,  1060,  1052,  1044,  1036,  1028,  1020,
  1012,  1004,   996,   988,   980,   974,   966,   960,
   952,   946,   938,   932,   926,   918,   912,   906,
   900,   894,   888,   882,   876,   870,   864,   858,
   852,   848,   842,   836,   832,   826,   820,   816,
   810,   806,   800,   796,   790,   786,   782,   776,
   772,   768,   764,   758,   754,   750,   746,   742,
   738,   734,   730,   726,   722,   718,   714,   710,
   706,   702,   698,   694,   690,   688,   684,   680,
   676,   672,   670,   666,   662,   660,   656,   652,
   650,   646,   644,   640,   636,   634,   630,   628,
   624,   622,   618,   616,   612,   610,   608,   604,
   602,   598,   596,   594,   590,   588,   586,   582,
   580,   578,   576,   572,   570,   568,   566,   562,
   560,   558,   556,   554,   550,   548,   546,   544,
   542,   540,   538,   536,   532,   530,   528,   526,
   524,   522,   520,   518,   516,   514,   512,   510,
   508,   506,   504,   502,   500,   498,   496,   494,
   492,   490,   488,   488,   486,   484,   482,   480,
   478,   476,   474,   474,   472,   470,   468,   466,
   464,   462,   462,   460,   458,   456,   454,   454,
   452,   450,   448,   448,   446,   444,   442,   442,
   440,   438,   436,   436,   434,   432,   430,   430,
   428,   426,   426,   424,   422,   422,   420,   418,
   418,   416,   414,   414,   412,   410,   410,   408,
   406,   406,   404,   402,   402,   400,   400,   398,
   396,   396,   394,   394,   392,   390,   390,   388,
   388,   386,   386,   384,   382,   382,   380,   380,
   378,   378,   376,   376,   374,   372,   372,   370,
   370,   368,   368,   366,   366,   364,   364,   362,
   362,   360,   360,   358,   358,   356,   356,   354,
   354,   352,   352,   350,   350,   348,   348,   348,
   346,   346,   344,   344,   342,   342,   340,   340,
   340,   338,   338,   336,   336,   334,   334,   332,
   332,   332,   330,   330,   328,   328,   328,   326,
   326,   324,   324,   324,   322,   322,   320,   320,
   320,   318,   318,   316,   316,   316,   314,   314,
   312,   312,   312,   310,   310,   310,   308,   308,
   308,   306,   306,   304,   304,   304,   302,   302,
   302,   300,   300,   300,   298,   298,   298,   296,
   296,   296,   294,   294,   294,   292,   292,   292,
   290,   290,   290,   288,   288,   288,   286,   286,
   286,   284,   284,   284,   284,   282,   282,   282,
   280,   280,   280,   278,   278,   278,   276,   276,
   276,   276,   274,   274,   274,   272,   272,   272,
   272,   270,   270,   270,   268,   268,   268,   268,
   266,   266,   266,   266,   264,   264,   264,   262,
   262,   262,   262,   260,   260,   260,   260,   258,
   258,   258,   258,   256,   256,   256,   256,   254,
   254,   254,   254,   252,   252,   252,   252,   250,
   250,   250,   250,   248,   248,   248,   248,   248,
   246,   246,   246,   246,   244,   244,   244,   244,
   242,   242,   242,   242,   242,   240,   240,   240,
   240,   238,   238,   238,   238,   238,   236,   236,
   236,   236,   234,   234,   234,   234,   234,   232,
   232,   232,   232,   232,   230,   230,   230,   230,
   230,   228,   228,   228,   228,   228,   226,   226,
   226,   226,   226,   224,   224,   224,   224,   224,
   222,   222,   222,   222,   222,   220,   220,   220,
   220,   220,   220,   218,   218,   218,   218,   218,
   216,   216,   216,   216,   216,   216,   214,   214,
   214,   214,   214,   212,   212,   212,   212,   212,
   212,   210,   210,   210,   210,   210,   210,   208,
   208,   208,   208,   208,   208,   206,   206,   206,
   206,   206,   206,   204,   204,   204,   204,   204,
   204,   204,   202,   202,   202,   202,   202,   202,
   200,   200,   200,   200,   200,   200,   198,   198,
   198,   198,   198,   198,   198,   196,   196,   196,
   196,   196,   196,   196,   194,   194,   194,   194,
   194,   194,   194,   192,   192,   192,   192,   192,
   192,   192,   190,   190,   190,   190,   190,   190,
   190,   188,   188,   188,   188,   188,   188,   188,
   186,   186,   186,   186,   186,   186,   186,   186,
   184,   184,   184,   184,   184,   184,   184,   182,
   182,   182,   182,   182,   182,   182,   182,   180,
   180,   180,   180,   180,   180,   180,   180,   178,
   178,   178,   178,   178,   178,   178,   178,   176,
   176,   176,   176,   176,   176,   176,   176,   176,
   174,   174,   174,   174,   174,   174,   174,   174,
   172,   172,   172,   172,   172,   172,   172,   172,
   172,   170,   170,   170,   170,   170,   170,   170,
   170,   170,   168,   168,   168,   168,   168,   168,
   168,   168,   168,   166,   166,   166,   166,   166,
   166,   166,   166,   166,   166,   164,   164,   164,
   164,   164,   164,   164,   164,   164,   162,   162,
   162,   162,   162,   162,   162,   162,   162,   162,
   160,   160,   160,   160,   160,   160,   160,   160,
   160,   160,   158,   158,   158,   158,   158,   158,
   158,   158,   158,   158,   158,   156,   156,   156,
   156,   156,   156,   156,   156,   156,   156,   154,
   154,   154,   154,   154,   154,   154,   154,   154,
   154,   154,   152,   152,   152,   152,   152,   152,
   152,   152,   152,   152,   152,   150,   150,   150,
   150,   150,   150,   150,   150,   150,   150,   150,
   150,   148,   148,   148,   148,   148,   148,   148,
   148,   148,   148,   148,   148,   146,   146,   146,
   146,   146,   146,   146,   146,   146,   146,   146,
   146,   144,   144,   144,   144,   144,   144,   144,
   144,   144,   144,   144,   144,   142,   142,   142,
   142,   142,   142,   142,   142,   142,   142,   142,
   142,   142,   140,   140,   140,   140,   140,   140,
   140,   140,   140,   140,   140,   140,   140,   138,
   138,   138,   138,   138,   138,   138,   138,   138,
   138,   138,   138,   138,   138,   136,   136,   136,
   136,   136,   136,   136,   136,   136,   136,   136,
   136,   136,   136,   134,   134,   134,   134,   134,
   134,   134,   134,   134,   134,   134,   134,   134,
   134,   132,   132,   132,   132,   132,   132,   132,
   132,   132,   132,   132,   132,   132,   132,   132,
   130,   130,   130,   130,   130,   130,   130,   130,
   130,   130,   130,   130,   130,   130,   130,   128,
   128,   128,   128,   128,   128,   128,   128,   128,
   128,   128,   128,   128,   128,   128,   128,   126
};
// ssquasht[i]=int(32768.0/(1+exp((i-2048)*(-1.0/64))));
// Middle 1344 of 4096 entries only.
static const U16 ssquasht[1344]={
     0,     0,     0,     0,     0,     0,     0,     1,
     1,     1,     1,     1,     1,     1,     1,     1,
     1,     1,     1,     1,     1,     1,     1,     1,
     1,     1,     1,     1,     1,     1,     1,     1,
     1,     1,     1,     1,     1,     1,     1,     1,
     1,     1,     1,     1,     1,     1,     1,     1,
     1,     1,     1,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     3,     3,     3,
     3,     3,     3,     3,     3,     3,     3,     3,
     3,     3,     3,     3,     3,     3,     3,     3,
     4,     4,     4,     4,     4,     4,     4,     4,
     4,     4,     4,     4,     4,     4,     5,     5,
     5,     5,     5,     5,     5,     5,     5,     5,
     5,     5,     6,     6,     6,     6,     6,     6,
     6,     6,     6,     6,     7,     7,     7,     7,
     7,     7,     7,     7,     8,     8,     8,     8,
     8,     8,     8,     8,     9,     9,     9,     9,
     9,     9,    10,    10,    10,    10,    10,    10,
    10,    11,    11,    11,    11,    11,    12,    12,
    12,    12,    12,    13,    13,    13,    13,    13,
    14,    14,    14,    14,    15,    15,    15,    15,
    15,    16,    16,    16,    17,    17,    17,    17,
    18,    18,    18,    18,    19,    19,    19,    20,
    20,    20,    21,    21,    21,    22,    22,    22,
    23,    23,    23,    24,    24,    25,    25,    25,
    26,    26,    27,    27,    28,    28,    28,    29,
    29,    30,    30,    31,    31,    32,    32,    33,
    33,    34,    34,    35,    36,    36,    37,    37,
    38,    38,    39,    40,    40,    41,    42,    42,
    43,    44,    44,    45,    46,    46,    47,    48,
    49,    49,    50,    51,    52,    53,    54,    54,
    55,    56,    57,    58,    59,    60,    61,    62,
    63,    64,    65,    66,    67,    68,    69,    70,
    71,    72,    73,    74,    76,    77,    78,    79,
    81,    82,    83,    84,    86,    87,    88,    90,
    91,    93,    94,    96,    97,    99,   100,   102,
   103,   105,   107,   108,   110,   112,   114,   115,
   117,   119,   121,   123,   125,   127,   129,   131,
   133,   135,   137,   139,   141,   144,   146,   148,
   151,   153,   155,   158,   160,   163,   165,   168,
   171,   173,   176,   179,   182,   184,   187,   190,
   193,   196,   199,   202,   206,   209,   212,   215,
   219,   222,   226,   229,   233,   237,   240,   244,
   248,   252,   256,   260,   264,   268,   272,   276,
   281,   285,   289,   294,   299,   303,   308,   313,
   318,   323,   328,   333,   338,   343,   349,   354,
   360,   365,   371,   377,   382,   388,   394,   401,
   407,   413,   420,   426,   433,   440,   446,   453,
   460,   467,   475,   482,   490,   497,   505,   513,
   521,   529,   537,   545,   554,   562,   571,   580,
   589,   598,   607,   617,   626,   636,   646,   656,
   666,   676,   686,   697,   708,   719,   730,   741,
   752,   764,   776,   788,   800,   812,   825,   837,
   850,   863,   876,   890,   903,   917,   931,   946,
   960,   975,   990,  1005,  1020,  1036,  1051,  1067,
  1084,  1100,  1117,  1134,  1151,  1169,  1186,  1204,
  1223,  1241,  1260,  1279,  1298,  1318,  1338,  1358,
  1379,  1399,  1421,  1442,  1464,  1486,  1508,  1531,
  1554,  1577,  1600,  1624,  1649,  1673,  1698,  1724,
  1749,  1775,  1802,  1829,  1856,  1883,  1911,  1940,
  1968,  1998,  2027,  2057,  2087,  2118,  2149,  2181,
  2213,  2245,  2278,  2312,  2345,  2380,  2414,  2450,
  2485,  2521,  2558,  2595,  2633,  2671,  2709,  2748,
  2788,  2828,  2869,  2910,  2952,  2994,  3037,  3080,
  3124,  3168,  3213,  3259,  3305,  3352,  3399,  3447,
  3496,  3545,  3594,  3645,  3696,  3747,  3799,  3852,
  3906,  3960,  4014,  4070,  4126,  4182,  4240,  4298,
  4356,  4416,  4476,  4537,  4598,  4660,  4723,  4786,
  4851,  4916,  4981,  5048,  5115,  5183,  5251,  5320,
  5390,  5461,  5533,  5605,  5678,  5752,  5826,  5901,
  5977,  6054,  6131,  6210,  6289,  6369,  6449,  6530,
  6613,  6695,  6779,  6863,  6949,  7035,  7121,  7209,
  7297,  7386,  7476,  7566,  7658,  7750,  7842,  7936,
  8030,  8126,  8221,  8318,  8415,  8513,  8612,  8712,
  8812,  8913,  9015,  9117,  9221,  9324,  9429,  9534,
  9640,  9747,  9854,  9962, 10071, 10180, 10290, 10401,
 10512, 10624, 10737, 10850, 10963, 11078, 11192, 11308,
 11424, 11540, 11658, 11775, 11893, 12012, 12131, 12251,
 12371, 12491, 12612, 12734, 12856, 12978, 13101, 13224,
 13347, 13471, 13595, 13719, 13844, 13969, 14095, 14220,
 14346, 14472, 14599, 14725, 14852, 14979, 15106, 15233,
 15361, 15488, 15616, 15744, 15872, 16000, 16128, 16256,
 16384, 16511, 16639, 16767, 16895, 17023, 17151, 17279,
 17406, 17534, 17661, 17788, 17915, 18042, 18168, 18295,
 18421, 18547, 18672, 18798, 18923, 19048, 19172, 19296,
 19420, 19543, 19666, 19789, 19911, 20033, 20155, 20276,
 20396, 20516, 20636, 20755, 20874, 20992, 21109, 21227,
 21343, 21459, 21575, 21689, 21804, 21917, 22030, 22143,
 22255, 22366, 22477, 22587, 22696, 22805, 22913, 23020,
 23127, 23233, 23338, 23443, 23546, 23650, 23752, 23854,
 23955, 24055, 24155, 24254, 24352, 24449, 24546, 24641,
 24737, 24831, 24925, 25017, 25109, 25201, 25291, 25381,
 25470, 25558, 25646, 25732, 25818, 25904, 25988, 26072,
 26154, 26237, 26318, 26398, 26478, 26557, 26636, 26713,
 26790, 26866, 26941, 27015, 27089, 27162, 27234, 27306,
 27377, 27447, 27516, 27584, 27652, 27719, 27786, 27851,
 27916, 27981, 28044, 28107, 28169, 28230, 28291, 28351,
 28411, 28469, 28527, 28585, 28641, 28697, 28753, 28807,
 28861, 28915, 28968, 29020, 29071, 29122, 29173, 29222,
 29271, 29320, 29368, 29415, 29462, 29508, 29554, 29599,
 29643, 29687, 29730, 29773, 29815, 29857, 29898, 29939,
 29979, 30019, 30058, 30096, 30134, 30172, 30209, 30246,
 30282, 30317, 30353, 30387, 30422, 30455, 30489, 30522,
 30554, 30586, 30618, 30649, 30680, 30710, 30740, 30769,
 30799, 30827, 30856, 30884, 30911, 30938, 30965, 30992,
 31018, 31043, 31069, 31094, 31118, 31143, 31167, 31190,
 31213, 31236, 31259, 31281, 31303, 31325, 31346, 31368,
 31388, 31409, 31429, 31449, 31469, 31488, 31507, 31526,
 31544, 31563, 31581, 31598, 31616, 31633, 31650, 31667,
 31683, 31700, 31716, 31731, 31747, 31762, 31777, 31792,
 31807, 31821, 31836, 31850, 31864, 31877, 31891, 31904,
 31917, 31930, 31942, 31955, 31967, 31979, 31991, 32003,
 32015, 32026, 32037, 32048, 32059, 32070, 32081, 32091,
 32101, 32111, 32121, 32131, 32141, 32150, 32160, 32169,
 32178, 32187, 32196, 32205, 32213, 32222, 32230, 32238,
 32246, 32254, 32262, 32270, 32277, 32285, 32292, 32300,
 32307, 32314, 32321, 32327, 32334, 32341, 32347, 32354,
 32360, 32366, 32373, 32379, 32385, 32390, 32396, 32402,
 32407, 32413, 32418, 32424, 32429, 32434, 32439, 32444,
 32449, 32454, 32459, 32464, 32468, 32473, 32478, 32482,
 32486, 32491, 32495, 32499, 32503, 32507, 32511, 32515,
 32519, 32523, 32527, 32530, 32534, 32538, 32541, 32545,
 32548, 32552, 32555, 32558, 32561, 32565, 32568, 32571,
 32574, 32577, 32580, 32583, 32585, 32588, 32591, 32594,
 32596, 32599, 32602, 32604, 32607, 32609, 32612, 32614,
 32616, 32619, 32621, 32623, 32626, 32628, 32630, 32632,
 32634, 32636, 32638, 32640, 32642, 32644, 32646, 32648,
 32650, 32652, 32653, 32655, 32657, 32659, 32660, 32662,
 32664, 32665, 32667, 32668, 32670, 32671, 32673, 32674,
 32676, 32677, 32679, 32680, 32681, 32683, 32684, 32685,
 32686, 32688, 32689, 32690, 32691, 32693, 32694, 32695,
 32696, 32697, 32698, 32699, 32700, 32701, 32702, 32703,
 32704, 32705, 32706, 32707, 32708, 32709, 32710, 32711,
 32712, 32713, 32713, 32714, 32715, 32716, 32717, 32718,
 32718, 32719, 32720, 32721, 32721, 32722, 32723, 32723,
 32724, 32725, 32725, 32726, 32727, 32727, 32728, 32729,
 32729, 32730, 32730, 32731, 32731, 32732, 32733, 32733,
 32734, 32734, 32735, 32735, 32736, 32736, 32737, 32737,
 32738, 32738, 32739, 32739, 32739, 32740, 32740, 32741,
 32741, 32742, 32742, 32742, 32743, 32743, 32744, 32744,
 32744, 32745, 32745, 32745, 32746, 32746, 32746, 32747,
 32747, 32747, 32748, 32748, 32748, 32749, 32749, 32749,
 32749, 32750, 32750, 32750, 32750, 32751, 32751, 32751,
 32752, 32752, 32752, 32752, 32752, 32753, 32753, 32753,
 32753, 32754, 32754, 32754, 32754, 32754, 32755, 32755,
 32755, 32755, 32755, 32756, 32756, 32756, 32756, 32756,
 32757, 32757, 32757, 32757, 32757, 32757, 32757, 32758,
 32758, 32758, 32758, 32758, 32758, 32759, 32759, 32759,
 32759, 32759, 32759, 32759, 32759, 32760, 32760, 32760,
 32760, 32760, 32760, 32760, 32760, 32761, 32761, 32761,
 32761, 32761, 32761, 32761, 32761, 32761, 32761, 32762,
 32762, 32762, 32762, 32762, 32762, 32762, 32762, 32762,
 32762, 32762, 32762, 32763, 32763, 32763, 32763, 32763,
 32763, 32763, 32763, 32763, 32763, 32763, 32763, 32763,
 32763, 32764, 32764, 32764, 32764, 32764, 32764, 32764,
 32764, 32764, 32764, 32764, 32764, 32764, 32764, 32764,
 32764, 32764, 32764, 32764, 32765, 32765, 32765, 32765,
 32765, 32765, 32765, 32765, 32765, 32765, 32765, 32765,
 32765, 32765, 32765, 32765, 32765, 32765, 32765, 32765,
 32765, 32765, 32765, 32765, 32765, 32765, 32766, 32766,
 32766, 32766, 32766, 32766, 32766, 32766, 32766, 32766,
 32766, 32766, 32766, 32766, 32766, 32766, 32766, 32766,
 32766, 32766, 32766, 32766, 32766, 32766, 32766, 32766,
 32766, 32766, 32766, 32766, 32766, 32766, 32766, 32766,
 32766, 32766, 32766, 32766, 32766, 32766, 32766, 32766,
 32766, 32766, 32767, 32767, 32767, 32767, 32767, 32767
};
// stdt[i]=count of -i or i in botton or top of stretcht[]
static const U8 stdt[712]={
    64,   128,   128,   128,   128,   128,   127,   128,
   127,   128,   127,   127,   127,   127,   126,   126,
   126,   126,   126,   125,   125,   124,   125,   124,
   123,   123,   123,   123,   122,   122,   121,   121,
   120,   120,   119,   119,   118,   118,   118,   116,
   117,   115,   116,   114,   114,   113,   113,   112,
   112,   111,   110,   110,   109,   108,   108,   107,
   106,   106,   105,   104,   104,   102,   103,   101,
   101,   100,    99,    98,    98,    97,    96,    96,
    94,    94,    94,    92,    92,    91,    90,    89,
    89,    88,    87,    86,    86,    84,    84,    84,
    82,    82,    81,    80,    79,    79,    78,    77,
    76,    76,    75,    74,    73,    73,    72,    71,
    70,    70,    69,    68,    67,    67,    66,    65,
    65,    64,    63,    62,    62,    61,    61,    59,
    59,    59,    57,    58,    56,    56,    55,    54,
    54,    53,    52,    52,    51,    51,    50,    49,
    49,    48,    48,    47,    47,    45,    46,    44,
    45,    43,    43,    43,    42,    41,    41,    40,
    40,    40,    39,    38,    38,    37,    37,    36,
    36,    36,    35,    34,    34,    34,    33,    32,
    33,    32,    31,    31,    30,    31,    29,    30,
    28,    29,    28,    28,    27,    27,    27,    26,
    26,    25,    26,    24,    25,    24,    24,    23,
    23,    23,    23,    22,    22,    21,    22,    21,
    20,    21,    20,    19,    20,    19,    19,    19,
    18,    18,    18,    18,    17,    17,    17,    17,
    16,    16,    16,    16,    15,    15,    15,    15,
    15,    14,    14,    14,    14,    13,    14,    13,
    13,    13,    12,    13,    12,    12,    12,    11,
    12,    11,    11,    11,    11,    11,    10,    11,
    10,    10,    10,    10,     9,    10,     9,     9,
     9,     9,     9,     8,     9,     8,     9,     8,
     8,     8,     7,     8,     8,     7,     7,     8,
     7,     7,     7,     6,     7,     7,     6,     6,
     7,     6,     6,     6,     6,     6,     6,     5,
     6,     5,     6,     5,     5,     5,     5,     5,
     5,     5,     5,     5,     4,     5,     4,     5,
     4,     4,     5,     4,     4,     4,     4,     4,
     4,     3,     4,     4,     3,     4,     4,     3,
     3,     4,     3,     3,     3,     4,     3,     3,
     3,     3,     3,     3,     2,     3,     3,     3,
     2,     3,     2,     3,     3,     2,     2,     3,
     2,     2,     3,     2,     2,     2,     2,     3,
     2,     2,     2,     2,     2,     2,     1,     2,
     2,     2,     2,     1,     2,     2,     2,     1,
     2,     1,     2,     2,     1,     2,     1,     2,
     1,     1,     2,     1,     1,     2,     1,     1,
     2,     1,     1,     1,     1,     2,     1,     1,
     1,     1,     1,     1,     1,     1,     1,     1,
     1,     1,     1,     1,     1,     1,     1,     1,
     1,     1,     0,     1,     1,     1,     1,     0,
     1,     1,     1,     0,     1,     1,     1,     0,
     1,     1,     0,     1,     1,     0,     1,     0,
     1,     1,     0,     1,     0,     1,     0,     1,
     0,     1,     0,     1,     0,     1,     0,     1,
     0,     1,     0,     1,     0,     1,     0,     0,
     1,     0,     1,     0,     0,     1,     0,     1,
     0,     0,     1,     0,     0,     1,     0,     0,
     1,     0,     0,     1,     0,     0,     0,     1,
     0,     0,     1,     0,     0,     0,     1,     0,
     0,     0,     1,     0,     0,     0,     1,     0,
     0,     0,     0,     1,     0,     0,     0,     0,
     1,     0,     0,     0,     0,     1,     0,     0,
     0,     0,     0,     1,     0,     0,     0,     0,
     0,     1,     0,     0,     0,     0,     0,     0,
     1,     0,     0,     0,     0,     0,     0,     0,
     1,     0,     0,     0,     0,     0,     0,     0,
     0,     0,     1,     0,     0,     0,     0,     0,
     0,     0,     0,     0,     1,     0,     0,     0,
     0,     0,     0,     0,     0,     0,     0,     0,
     0,     1,     0,     0,     0,     0,     0,     0,
     0,     0,     0,     0,     0,     0,     0,     0,
     0,     1,     0,     0,     0,     0,     0,     0,
     0,     0,     0,     0,     0,     0,     0,     0,
     0,     0,     0,     0,     0,     0,     0,     1,
     0,     0,     0,     0,     0,     0,     0,     0,
     0,     0,     0,     0,     0,     0,     0,     0,
     0,     0,     0,     0,     0,     0,     0,     0,
     0,     0,     0,     0,     0,     0,     0,     1,
     0,     0,     0,     0,     0,     0,     0,     0,
     0,     0,     0,     0,     0,     0,     0,     0,
     0,     0,     0,     0,     0,     0,     0,     0,
     0,     0,     0,     0,     0,     0,     0,     0,
     0,     0,     0,     0,     0,     0,     0,     0,
     0,     0,     0,     0,     0,     0,     0,     0,
     0,     0,     0,     0,     0,     0,     0,     0,
     0,     0,     0,     0,     0,     0,     0,     0,
     0,     0,     0,     0,     0,     0,     1,     0
};
Predictor::Predictor(ZPAQL& zr):
    c8(1), hmap4(1), z(zr) {
  assert(sizeof(U8)==1);
  assert(sizeof(U16)==2);
  assert(sizeof(U32)==4);
  assert(sizeof(U64)==8);
  assert(sizeof(short)==2);
  assert(sizeof(int)==4);
  pcode=0;
  pcode_size=0;
  initTables=false;
}
Predictor::~Predictor() {
  allocx(pcode, pcode_size, 0);  // free executable memory
}
// Initialize the predictor with a new model in z
void Predictor::init() {
  // Clear old JIT code if any
  allocx(pcode, pcode_size, 0);
  // Initialize context hash function
  z.inith();
  // Initialize model independent tables
  if (!initTables && isModeled()) {
    initTables=true;
    memcpy(dt2k, sdt2k, sizeof(dt2k));
    memcpy(dt, sdt, sizeof(dt));
    // ssquasht[i]=int(32768.0/(1+exp((i-2048)*(-1.0/64))));
    // Copy middle 1344 of 4096 entries.
    memset(squasht, 0, 1376*2);
    memcpy(squasht+1376, ssquasht, 1344*2);
    for (int i=2720; i<4096; ++i) squasht[i]=32767;
    // sstretcht[i]=int(log((i+0.5)/(32767.5-i))*64+0.5+100000)-100000;
    int k=16384;
    for (unsigned int i=0; i<712; ++i)
      for (int j=stdt[i]; j>0; --j)
        stretcht[k++]=i;
    assert(k==32768);
    for (unsigned int i=0; i<16384; ++i)
      stretcht[i]=-stretcht[32767-i];
#ifndef NDEBUG
    // Verify floating point math for squash() and stretch()
    U32 sqsum=0, stsum=0;
    for (int i=32767; i>=0; --i)
      stsum=stsum*3+stretch(i);
    for (int i=4095; i>=0; --i)
      sqsum=sqsum*3+squash(i-2048);
    assert(stsum==3887533746u);
    assert(sqsum==2278286169u);
#endif // corresponds to #ifndef (#ifndef NDEBUG)
  }
  // Initialize predictions
  for (unsigned int i=0; i<256; ++i) h[i]=p[i]=0;
  // Initialize components
  for (unsigned int i=0; i<256; ++i)  // clear old model
    comp[i].init();
  int n=z.header[6]; // hsize[0..1] hh hm ph pm n (comp)[n] END 0[128] (hcomp) END
  const U8* cp=&z.header[7];  // start of component list
  for (int i=0; i<n; ++i) {
    assert(cp<&z.header[z.cend]);
    assert(cp>&z.header[0] && cp<&z.header[z.header.isize()-8]);
    Component& cr=comp[i];
    switch(cp[0]) {
      case CONS:  // c
        p[i]=(cp[1]-128)*4;
        break;
      case CM: // sizebits limit
        if (cp[1]>32) error("max size for CM is 32");
        cr.cm.resize(1, cp[1]);  // packed CM (22 bits) + CMCOUNT (10 bits)
        cr.limit=cp[2]*4;
        for (size_t j=0; j<cr.cm.size(); ++j)
          cr.cm[j]=0x80000000;
        break;
      case ICM: // sizebits
        if (cp[1]>26) error("max size for ICM is 26");
        cr.limit=1023;
        cr.cm.resize(256);
        cr.ht.resize(64, cp[1]);
        for (size_t j=0; j<cr.cm.size(); ++j)
          cr.cm[j]=st.cminit(j);
        break;
      case MATCH:  // sizebits
        if (cp[1]>32 || cp[2]>32) error("max size for MATCH is 32 32");
        cr.cm.resize(1, cp[1]);  // index
        cr.ht.resize(1, cp[2]);  // buf
        cr.ht(0)=1;
        break;
      case AVG: // j k wt
        if (cp[1]>=i) error("AVG j >= i");
        if (cp[2]>=i) error("AVG k >= i");
        break;
      case MIX2:  // sizebits j k rate mask
        if (cp[1]>32) error("max size for MIX2 is 32");
        if (cp[3]>=i) error("MIX2 k >= i");
        if (cp[2]>=i) error("MIX2 j >= i");
        cr.c=(size_t(1)<<cp[1]); // size (number of contexts)
        cr.a16.resize(1, cp[1]);  // wt[size][m]
        for (size_t j=0; j<cr.a16.size(); ++j)
          cr.a16[j]=32768;
        break;
      case MIX: {  // sizebits j m rate mask
        if (cp[1]>32) error("max size for MIX is 32");
        if (cp[2]>=i) error("MIX j >= i");
        if (cp[3]<1 || cp[3]>i-cp[2]) error("MIX m not in 1..i-j");
        int m=cp[3];  // number of inputs
        assert(m>=1);
        cr.c=(size_t(1)<<cp[1]); // size (number of contexts)
        cr.cm.resize(m, cp[1]);  // wt[size][m]
        for (size_t j=0; j<cr.cm.size(); ++j)
          cr.cm[j]=65536/m;
        break;
      }
      case ISSE:  // sizebits j
        if (cp[1]>32) error("max size for ISSE is 32");
        if (cp[2]>=i) error("ISSE j >= i");
        cr.ht.resize(64, cp[1]);
        cr.cm.resize(512);
        for (int j=0; j<256; ++j) {
          cr.cm[j*2]=1<<15;
          cr.cm[j*2+1]=clamp512k(stretch(st.cminit(j)>>8)*1024);
        }
        break;
      case SSE: // sizebits j start limit
        if (cp[1]>32) error("max size for SSE is 32");
        if (cp[2]>=i) error("SSE j >= i");
        if (cp[3]>cp[4]*4) error("SSE start > limit*4");
        cr.cm.resize(32, cp[1]);
        cr.limit=cp[4]*4;
        for (size_t j=0; j<cr.cm.size(); ++j)
          cr.cm[j]=squash((j&31)*64-992)<<17|cp[3];
        break;
      default: error("unknown component type");
    }
    assert(compsize[*cp]>0);
    cp+=compsize[*cp];
    assert(cp>=&z.header[7] && cp<&z.header[z.cend]);
  }
}
// Return next bit prediction using interpreted COMP code
int Predictor::predict0() {
  assert(initTables);
  assert(c8>=1 && c8<=255);
  // Predict next bit
  int n=z.header[6];
  assert(n>0 && n<=255);
  const U8* cp=&z.header[7];
  ///assert(cp[-1]==n);
  for (int i=0; i<n; ++i) {
    assert(cp>&z.header[0] && cp<&z.header[z.header.isize()-8]);
    Component& cr=comp[i];
    switch(cp[0]) {
      case CONS:  // c
        break;
      case CM:  // sizebits limit
        cr.cxt=h[i]^hmap4;
        p[i]=stretch(cr.cm(cr.cxt)>>17);
        break;
      case ICM: // sizebits
        assert((hmap4&15)>0);
        if (c8==1 || (c8&0xf0)==16) cr.c=find(cr.ht, cp[1]+2, h[i]+16*c8);
        cr.cxt=cr.ht[cr.c+(hmap4&15)];
        p[i]=stretch(cr.cm(cr.cxt)>>8);
        break;
      case MATCH: // sizebits bufbits: a=len, b=offset, c=bit, cxt=bitpos,
                  //                   ht=buf, limit=pos
        assert(cr.cm.size()==(size_t(1)<<cp[1]));
        assert(cr.ht.size()==(size_t(1)<<cp[2]));
        assert(cr.a<=255);
        assert(cr.c==0 || cr.c==1);
        assert(cr.cxt<8);
        assert(cr.limit<cr.ht.size());
        if (cr.a==0) p[i]=0;
        else {
          cr.c=(cr.ht(cr.limit-cr.b)>>(7-cr.cxt))&1; // predicted bit
          p[i]=stretch(dt2k[cr.a]*(cr.c*-2+1)&32767);
        }
        break;
      case AVG: // j k wt
        p[i]=(p[cp[1]]*cp[3]+p[cp[2]]*(256-cp[3]))>>8;
        break;
      case MIX2: { // sizebits j k rate mask
                   // c=size cm=wt[size] cxt=input
        cr.cxt=((h[i]+(c8&cp[5]))&(cr.c-1));
        assert(cr.cxt<cr.a16.size());
        int w=cr.a16[cr.cxt];
        assert(w>=0 && w<65536);
        p[i]=(w*p[cp[2]]+(65536-w)*p[cp[3]])>>16;
        assert(p[i]>=-2048 && p[i]<2048);
      }
        break;
      case MIX: {  // sizebits j m rate mask
                   // c=size cm=wt[size][m] cxt=index of wt in cm
        int m=cp[3];
        assert(m>=1 && m<=i);
        cr.cxt=h[i]+(c8&cp[5]);
        cr.cxt=(cr.cxt&(cr.c-1))*m; // pointer to row of weights
        assert(cr.cxt<=cr.cm.size()-m);
        int* wt=(int*)&cr.cm[cr.cxt];
        p[i]=0;
        for (int j=0; j<m; ++j)
          p[i]+=(wt[j]>>8)*p[cp[2]+j];
        p[i]=clamp2k(p[i]>>8);
      }
        break;
      case ISSE: { // sizebits j -- c=hi, cxt=bh
        assert((hmap4&15)>0);
        if (c8==1 || (c8&0xf0)==16)
          cr.c=find(cr.ht, cp[1]+2, h[i]+16*c8);
        cr.cxt=cr.ht[cr.c+(hmap4&15)];  // bit history
        int *wt=(int*)&cr.cm[cr.cxt*2];
        p[i]=clamp2k((wt[0]*p[cp[2]]+wt[1]*64)>>16);
      }
        break;
      case SSE: { // sizebits j start limit
        cr.cxt=(h[i]+c8)*32;
        int pq=p[cp[2]]+992;
        if (pq<0) pq=0;
        if (pq>1983) pq=1983;
        int wt=pq&63;
        pq>>=6;
        assert(pq>=0 && pq<=30);
        cr.cxt+=pq;
        p[i]=stretch(((cr.cm(cr.cxt)>>10)*(64-wt)+(cr.cm(cr.cxt+1)>>10)*wt)>>13);
        cr.cxt+=wt>>5;
      }
        break;
      default:
        error("component predict not implemented");
    }
    cp+=compsize[cp[0]];
    assert(cp<&z.header[z.cend]);
    assert(p[i]>=-2048 && p[i]<2048);
  }
  assert(cp[0]==NONE);
  return squash(p[n-1]);
}
// Update model with decoded bit y (0...1)
void Predictor::update0(int y) {
  assert(initTables);
  assert(y==0 || y==1);
  assert(c8>=1 && c8<=255);
  assert(hmap4>=1 && hmap4<=511);
  // Update components
  const U8* cp=&z.header[7];
  int n=z.header[6];
  assert(n>=1 && n<=255);
  ///assert(cp[-1]==n);
  for (int i=0; i<n; ++i) {
    Component& cr=comp[i];
    switch(cp[0]) {
      case CONS:  // c
        break;
      case CM:  // sizebits limit
        train(cr, y);
        break;
      case ICM: { // sizebits: cxt=ht[b]=bh, ht[c][0..15]=bh row, cxt=bh
        cr.ht[cr.c+(hmap4&15)]=st.next(cr.ht[cr.c+(hmap4&15)], y);
        U32& pn=cr.cm(cr.cxt);
        pn+=int(y*32767-(pn>>8))>>2;
      }
        break;
      case MATCH: // sizebits bufbits:
                  //   a=len, b=offset, c=bit, cm=index, cxt=bitpos
                  //   ht=buf, limit=pos
      {
        assert(cr.a<=255);
        assert(cr.c==0 || cr.c==1);
        assert(cr.cxt<8);
        assert(cr.cm.size()==(size_t(1)<<cp[1]));
        assert(cr.ht.size()==(size_t(1)<<cp[2]));
        assert(cr.limit<cr.ht.size());
        if (int(cr.c)!=y) cr.a=0;  // mismatch?
        cr.ht(cr.limit)+=cr.ht(cr.limit)+y;
        if (++cr.cxt==8) {
          cr.cxt=0;
          ++cr.limit;
          cr.limit&=(1<<cp[2])-1;
          if (cr.a==0) {  // look for a match
            cr.b=cr.limit-cr.cm(h[i]);
            if (cr.b&(cr.ht.size()-1))
              while (cr.a<255
                     && cr.ht(cr.limit-cr.a-1)==cr.ht(cr.limit-cr.a-cr.b-1))
                ++cr.a;
          }
          else cr.a+=cr.a<255;
          cr.cm(h[i])=cr.limit;
        }
      }
        break;
      case AVG:  // j k wt
        break;
      case MIX2: { // sizebits j k rate mask
                   // cm=wt[size], cxt=input
        assert(cr.a16.size()==cr.c);
        assert(cr.cxt<cr.a16.size());
        int err=(y*32767-squash(p[i]))*cp[4]>>5;
        int w=cr.a16[cr.cxt];
        w+=(err*(p[cp[2]]-p[cp[3]])+(1<<12))>>13;
        if (w<0) w=0;
        if (w>65535) w=65535;
        cr.a16[cr.cxt]=w;
      }
        break;
      case MIX: {   // sizebits j m rate mask
                    // cm=wt[size][m], cxt=input
        int m=cp[3];
        assert(m>0 && m<=i);
        assert(cr.cm.size()==m*cr.c);
        assert(cr.cxt+m<=cr.cm.size());
        int err=(y*32767-squash(p[i]))*cp[4]>>4;
        int* wt=(int*)&cr.cm[cr.cxt];
        for (int j=0; j<m; ++j)
          wt[j]=clamp512k(wt[j]+((err*p[cp[2]+j]+(1<<12))>>13));
      }
        break;
      case ISSE: { // sizebits j  -- c=hi, cxt=bh
        assert(cr.cxt==cr.ht[cr.c+(hmap4&15)]);
        int err=y*32767-squash(p[i]);
        int *wt=(int*)&cr.cm[cr.cxt*2];
        wt[0]=clamp512k(wt[0]+((err*p[cp[2]]+(1<<12))>>13));
        wt[1]=clamp512k(wt[1]+((err+16)>>5));
        cr.ht[cr.c+(hmap4&15)]=st.next(cr.cxt, y);
      }
        break;
      case SSE:  // sizebits j start limit
        train(cr, y);
        break;
      default:
        assert(0);
    }
    cp+=compsize[cp[0]];
    assert(cp>=&z.header[7] && cp<&z.header[z.cend]
           && cp<&z.header[z.header.isize()-8]);
  }
  assert(cp[0]==NONE);
  // Save bit y in c8, hmap4
  c8+=c8+y;
  if (c8>=256) {
    z.run(c8-256);
    hmap4=1;
    c8=1;
    for (int i=0; i<n; ++i) h[i]=z.H(i);
  }
  else if (c8>=16 && c8<32)
    hmap4=(hmap4&0xf)<<5|y<<4|1;
  else
    hmap4=(hmap4&0x1f0)|(((hmap4&0xf)*2+y)&0xf);
}
// Find cxt row in hash table ht. ht has rows of 16 indexed by the
// low sizebits of cxt with element 0 having the next higher 8 bits for
// collision detection. If not found after 3 adjacent tries, replace the
// row with lowest element 1 as priority. Return index of row.
size_t Predictor::find(Array<U8>& ht, int sizebits, U32 cxt) {
  assert(initTables);
  assert(ht.size()==size_t(16)<<sizebits);
  int chk=cxt>>sizebits&255;
  size_t h0=(cxt*16)&(ht.size()-16);
  if (ht[h0]==chk) return h0;
  size_t h1=h0^16;
  if (ht[h1]==chk) return h1;
  size_t h2=h0^32;
  if (ht[h2]==chk) return h2;
  if (ht[h0+1]<=ht[h1+1] && ht[h0+1]<=ht[h2+1])
    return memset(&ht[h0], 0, 16), ht[h0]=chk, h0;
  else if (ht[h1+1]<ht[h2+1])
    return memset(&ht[h1], 0, 16), ht[h1]=chk, h1;
  else
    return memset(&ht[h2], 0, 16), ht[h2]=chk, h2;
}
/////////////////////// Decoder ///////////////////////
Decoder::Decoder(ZPAQL& z):
    in(0), low(1), high(0xFFFFFFFF), curr(0), rpos(0), wpos(0),
    pr(z), buf(BUFSIZE) {
}
void Decoder::init() {
  pr.init();
  if (pr.isModeled()) low=1, high=0xFFFFFFFF, curr=0;
  else low=high=curr=0;
}
// Return next bit of decoded input, which has 16 bit probability p of being 1
int Decoder::decode(int p) {
 /// assert(pr.isModeled());
  assert(p>=0 && p<65536);
  assert(high>low && low>0);
  if (curr<low || curr>high) error("archive corrupted");
  assert(curr>=low && curr<=high);
  U32 mid=low+U32(((high-low)*U64(U32(p)))>>16);  // split range
  assert(high>mid && mid>=low);
  int y;
  if (curr<=mid) y=1, high=mid;  // pick half
  else y=0, low=mid+1;
  while ((high^low)<0x1000000) { // shift out identical leading bytes
    high=high<<8|255;
    low=low<<8;
    low+=(low==0);
    int c=get();
    if (c<0) error("unexpected end of file");
    curr=curr<<8|c;
  }
  return y;
}
// Decompress 1 byte or -1 at end of input
int Decoder::decompress() {
  if (pr.isModeled()) {  // n>0 components?
    if (curr==0) {  // segment initialization
      for (int i=0; i<4; ++i)
        curr=curr<<8|get();
    }
    if (decode(0)) {
      if (curr!=0) error("decoding end of stream");
      return -1;
    }
    else {
      int c=1;
      while (c<256) {  // get 8 bits
        int p=pr.predict()*2+1;
        c+=c+decode(p);
        pr.update(c&1);
      }
      return c-256;
    }
  }
  else {
    if (curr==0) {
      for (int i=0; i<4; ++i) curr=curr<<8|get();
      if (curr==0) return -1;
    }
    --curr;
    return get();
  }
}
// Find end of compressed data and return next byte
int Decoder::skip() {
  int c=-1;
  if (pr.isModeled()) {
    while (curr==0)  // at start?
      curr=get();
    while (curr && (c=get())>=0)  // find 4 zeros
      curr=curr<<8|c;
    while ((c=get())==0) ;  // might be more than 4
    return c;
  }
  else {
    if (curr==0)  // at start?
      for (int i=0; i<4 && (c=get())>=0; ++i) curr=curr<<8|c;
    while (curr>0) {
      while (curr>0) {
        --curr;
        if (get()<0) return error("skipped to EOF"), -1;
      }
      for (int i=0; i<4 && (c=get())>=0; ++i) curr=curr<<8|c;
    }
    if (c>=0) c=get();
    return c;
  }
}
////////////////////// PostProcessor //////////////////////
// Copy ph, pm from block header
void PostProcessor::init(int h, int m) {
  state=hsize=0;
  ph=h;
  pm=m;
  z.clear();
}
// (PASS=0 | PROG=1 psize[0..1] pcomp[0..psize-1]) data... EOB=-1
// Return state: 1=PASS, 2..4=loading PROG, 5=PROG loaded
int PostProcessor::write(int c) {
  assert(c>=-1 && c<=255);
  switch (state) {
    case 0:  // initial state
      if (c<0) error("Unexpected EOS");
      state=c+1;  // 1=PASS, 2=PROG
      if (state>2) error("unknown post processing type");
      if (state==1) z.clear();
      break;
    case 1:  // PASS
      z.outc(c);
      break;
    case 2: // PROG
      if (c<0) error("Unexpected EOS");
      hsize=c;  // low byte of size
      state=3;
      break;
    case 3:  // PROG psize[0]
      if (c<0) error("Unexpected EOS");
      hsize+=c*256;  // high byte of psize
      if (hsize<1) error("Empty PCOMP");
      z.header.resize(hsize+300);
      z.cend=8;
      z.hbegin=z.hend=z.cend+128;
      z.header[4]=ph;
      z.header[5]=pm;
      state=4;
      break;
    case 4:  // PROG psize[0..1] pcomp[0...]
      if (c<0) error("Unexpected EOS");
      assert(z.hend<z.header.isize());
      z.header[z.hend++]=c;  // one byte of pcomp
      if (z.hend-z.hbegin==hsize) {  // last byte of pcomp?
        hsize=(z.cend-2)+z.hend-z.hbegin;
        z.header[0]=hsize&255;  // header size with empty COMP
        z.header[1]=hsize>>8;
        z.initp();
        state=5;
      }
      break;
    case 5:  // PROG ... data
      z.run(c);
      if (c<0) z.flush();
      break;
  }
  return state;
}
/////////////////////// Decompresser /////////////////////
// Find the start of a block and return true if found. Set memptr
// to memory used.
bool Decompresser::findBlock(double* memptr) {
  assert(state==BLOCK);
  // Find start of block
  U32 h1=0x3D49B113, h2=0x29EB7F93, h3=0x2614BE13, h4=0x3828EB13;
  // Rolling hashes initialized to hash of first 13 bytes
  int c;
  while ((c=dec.get())!=-1) {
    h1=h1*12+c;
    h2=h2*20+c;
    h3=h3*28+c;
    h4=h4*44+c;
    if (h1==0xB16B88F1 && h2==0xFF5376F1 && h3==0x72AC5BF1 && h4==0x2F909AF1)
      break;  // hash of 16 byte string
  }
  if (c==-1) return false;
  // Read header
  if ((c=dec.get())!=1 && c!=2) error("unsupported ZPAQ level");
  if (dec.get()!=1) error("unsupported ZPAQL type");
  z.read(&dec);
  if (c==1 && z.header.isize()>6 && z.header[6]==0)
    error("ZPAQ level 1 requires at least 1 component");
  if (memptr) *memptr=z.memory();
  state=FILENAME;
  decode_state=FIRSTSEG;
  return true;
}
// Read the start of a segment (1) or end of block code (255).
// If a segment is found, write the filename and return true, else false.
bool Decompresser::findFilename(Writer* filename) {
  assert(state==FILENAME);
  int c=dec.get();
  if (c==1) {  // segment found
    while (true) {
      c=dec.get();
      if (c==-1) error("unexpected EOF");
      if (c==0) {
        state=COMMENT;
        return true;
      }
      if (filename) filename->put(c);
    }
  }
  else if (c==255) {  // end of block found
    state=BLOCK;
    return false;
  }
  else
    error("missing segment or end of block");
  return false;
}
// Read the comment from the segment header
void Decompresser::readComment(Writer* comment) {
  assert(state==COMMENT);
  state=DATA;
  while (true) {
    int c=dec.get();
    if (c==-1) error("unexpected EOF");
    if (c==0) break;
    if (comment) comment->put(c);
  }
  if (dec.get()!=0) error("missing reserved byte");
}
// Decompress n bytes, or all if n < 0. Return false if done
bool Decompresser::decompress(int n) {
  assert(state==DATA);
  if (decode_state==SKIP) error("decompression after skipped segment");
  assert(decode_state!=SKIP);
  // Initialize models to start decompressing block
  if (decode_state==FIRSTSEG) {
    dec.init();
    assert(z.header.size()>5);
    pp.init(z.header[4], z.header[5]);
    decode_state=SEG;
  }
  // Decompress and load PCOMP into postprocessor
  while ((pp.getState()&3)!=1)
    pp.write(dec.decompress());
  // Decompress n bytes, or all if n < 0
  while (n) {
    int c=dec.decompress();
    pp.write(c);
    if (c==-1) {
      state=SEGEND;
      return false;
    }
    if (n>0) --n;
  }
  return true;
}
// Read end of block. If a SHA1 checksum is present, write 1 and the
// 20 byte checksum into sha1string, else write 0 in first byte.
// If sha1string is 0 then discard it.
void Decompresser::readSegmentEnd(char* sha1string) {
  assert(state==DATA || state==SEGEND);
  // Skip remaining data if any and get next byte
  int c=0;
  if (state==DATA) {
    c=dec.skip();
    decode_state=SKIP;
  }
  else if (state==SEGEND)
    c=dec.get();
  state=FILENAME;
  // Read checksum
  if (c==254) {
    if (sha1string) sha1string[0]=0;  // no checksum
  }
  else if (c==253) {
    if (sha1string) sha1string[0]=1;
    for (int i=1; i<=20; ++i) {
      c=dec.get();
      if (sha1string) sha1string[i]=c;
    }
  }
  else
    error("missing end of segment marker");
}
/////////////////////////// decompress() //////////////////////
void decompress(Reader* in, Writer* out) {
  Decompresser d;
  d.setInput(in);
  d.setOutput(out);
  while (d.findBlock()) {       // don't calculate memory
    while (d.findFilename()) {  // discard filename
      d.readComment();          // discard comment
      d.decompress();           // to end of segment
      d.readSegmentEnd();       // discard sha1string
    }
  }
}
/////////////////////////// Encoder ///////////////////////////
// Initialize for start of block
void Encoder::init() {
  low=1;
  high=0xFFFFFFFF;
  pr.init();
  if (!pr.isModeled()) low=0, buf.resize(1<<16);
}
// compress bit y having probability p/64K
void Encoder::encode(int y, int p) {
  assert(out);
  assert(p>=0 && p<65536);
  assert(y==0 || y==1);
  assert(high>low && low>0);
  U32 mid=low+U32(((high-low)*U64(U32(p)))>>16);  // split range
  assert(high>mid && mid>=low);
  if (y) high=mid; else low=mid+1; // pick half
  while ((high^low)<0x1000000) { // write identical leading bytes
    out->put(high>>24);  // same as low>>24
    high=high<<8|255;
    low=low<<8;
    low+=(low==0); // so we don't code 4 0 bytes in a row
  }
}
// compress byte c (0..255 or -1=EOS)
void Encoder::compress(int c) {
  assert(out);
  if (pr.isModeled()) {
    if (c==-1)
      encode(1, 0);
    else {
      assert(c>=0 && c<=255);
      encode(0, 0);
      for (int i=7; i>=0; --i) {
        int p=pr.predict()*2+1;
        assert(p>0 && p<65536);
        int y=c>>i&1;
        encode(y, p);
        pr.update(y);
      }
    }
  }
  else {
    if (low && (c<0 || low==buf.size())) {
      out->put((low>>24)&255);
      out->put((low>>16)&255);
      out->put((low>>8)&255);
      out->put(low&255);
      out->write(&buf[0], low);
      low=0;
    }
    if (c>=0) buf[low++]=c;
  }
}
//////////////////////////// Compiler /////////////////////////
// Component names
const char* compname[256]=
  {"","const","cm","icm","match","avg","mix2","mix","isse","sse",0};
// Opcodes
const char* opcodelist[272]={
"error","a++",  "a--",  "a!",   "a=0",  "",     "",     "a=r",
"b<>a", "b++",  "b--",  "b!",   "b=0",  "",     "",     "b=r",
"c<>a", "c++",  "c--",  "c!",   "c=0",  "",     "",     "c=r",
"d<>a", "d++",  "d--",  "d!",   "d=0",  "",     "",     "d=r",
"*b<>a","*b++", "*b--", "*b!",  "*b=0", "",     "",     "jt",
"*c<>a","*c++", "*c--", "*c!",  "*c=0", "",     "",     "jf",
"*d<>a","*d++", "*d--", "*d!",  "*d=0", "",     "",     "r=a",
"halt", "out",  "",     "hash", "hashd","",     "",     "jmp",
"a=a",  "a=b",  "a=c",  "a=d",  "a=*b", "a=*c", "a=*d", "a=",
"b=a",  "b=b",  "b=c",  "b=d",  "b=*b", "b=*c", "b=*d", "b=",
"c=a",  "c=b",  "c=c",  "c=d",  "c=*b", "c=*c", "c=*d", "c=",
"d=a",  "d=b",  "d=c",  "d=d",  "d=*b", "d=*c", "d=*d", "d=",
"*b=a", "*b=b", "*b=c", "*b=d", "*b=*b","*b=*c","*b=*d","*b=",
"*c=a", "*c=b", "*c=c", "*c=d", "*c=*b","*c=*c","*c=*d","*c=",
"*d=a", "*d=b", "*d=c", "*d=d", "*d=*b","*d=*c","*d=*d","*d=",
"",     "",     "",     "",     "",     "",     "",     "",
"a+=a", "a+=b", "a+=c", "a+=d", "a+=*b","a+=*c","a+=*d","a+=",
"a-=a", "a-=b", "a-=c", "a-=d", "a-=*b","a-=*c","a-=*d","a-=",
"a*=a", "a*=b", "a*=c", "a*=d", "a*=*b","a*=*c","a*=*d","a*=",
"a/=a", "a/=b", "a/=c", "a/=d", "a/=*b","a/=*c","a/=*d","a/=",
"a%=a", "a%=b", "a%=c", "a%=d", "a%=*b","a%=*c","a%=*d","a%=",
"a&=a", "a&=b", "a&=c", "a&=d", "a&=*b","a&=*c","a&=*d","a&=",
"a&~a", "a&~b", "a&~c", "a&~d", "a&~*b","a&~*c","a&~*d","a&~",
"a|=a", "a|=b", "a|=c", "a|=d", "a|=*b","a|=*c","a|=*d","a|=",
"a^=a", "a^=b", "a^=c", "a^=d", "a^=*b","a^=*c","a^=*d","a^=",
"a<<=a","a<<=b","a<<=c","a<<=d","a<<=*b","a<<=*c","a<<=*d","a<<=",
"a>>=a","a>>=b","a>>=c","a>>=d","a>>=*b","a>>=*c","a>>=*d","a>>=",
"a==a", "a==b", "a==c", "a==d", "a==*b","a==*c","a==*d","a==",
"a<a",  "a<b",  "a<c",  "a<d",  "a<*b", "a<*c", "a<*d", "a<",
"a>a",  "a>b",  "a>c",  "a>d",  "a>*b", "a>*c", "a>*d", "a>",
"",     "",     "",     "",     "",     "",     "",     "",
"",     "",     "",     "",     "",     "",     "",     "lj",
"post", "pcomp","end",  "if",   "ifnot","else", "endif","do",
"while","until","forever","ifl","ifnotl","elsel",";",    0};
// Advance in to start of next token. Tokens are delimited by white
// space. Comments inclosed in ((nested) parenthsis) are skipped.
void Compiler::next() {
  assert(in);
  for (; *in; ++in) {
    if (*in=='\n') ++line;
    if (*in=='(') state+=1+(state<0);
    else if (state>0 && *in==')') --state;
    else if (state<0 && *in<=' ') state=0;
    else if (state==0 && *in>' ') {state=-1; break;}
  }
  if (!*in) error("unexpected end of config");
}
// convert to lower case
int tolower(int c) {return (c>='A' && c<='Z') ? c+'a'-'A' : c;}
// return true if in==word up to white space or '(', case insensitive
bool Compiler::matchToken(const char* word) {
  const char* a=in;
  for (; (*a>' ' && *a!='(' && *word); ++a, ++word)
    if (tolower(*a)!=tolower(*word)) return false;
  return !*word && (*a<=' ' || *a=='(');
}
// Print error message and exit

#if defined(__OpenBSD__)

void Compiler::syntaxError(const char* msg, const char* expected) {
    Array<char> sbuf(128); // Buffer for the error message
    char* s = &sbuf[0];
    s[0] = '\0'; // Initialize the empty buffer

    // Concatenate "Config line "
    if (strlcat(s, "Config line ", sizeof(sbuf)) >= sizeof(sbuf)) {
        error("Buffer overflow in syntaxError");
        return;
    }

    // Add the line number
    char line_buf[16];
    snprintf(line_buf, sizeof(line_buf), "%d", line);
    if (strlcat(s, line_buf, sizeof(sbuf)) >= sizeof(sbuf)) {
        error("Buffer overflow in syntaxError");
        return;
    }

    // Concatenate " at "
    if (strlcat(s, " at ", sizeof(sbuf)) >= sizeof(sbuf)) {
        error("Buffer overflow in syntaxError");
        return;
    }

    // Add the found token (limited to 40 characters)
    size_t len = strlen(s);
    size_t i;
    for (i = 0; i < 40 && len + i < sizeof(sbuf) - 1 && *in > ' '; ++i) {
        s[len + i] = *in++;
    }
    s[len + i] = '\0'; // Terminate the string

    // Concatenate ": "
    if (strlcat(s, ": ", sizeof(sbuf)) >= sizeof(sbuf)) {
        error("Buffer overflow in syntaxError");
        return;
    }

    // Add the message (limited to 40 characters)
    if (strlcat(s, msg, sizeof(sbuf)) >= sizeof(sbuf)) {
        error("Buffer overflow in syntaxError");
        return;
    }

    // Add the expected, if present
    if (expected) {
        if (strlcat(s, ", expected: ", sizeof(sbuf)) >= sizeof(sbuf)) {
            error("Buffer overflow in syntaxError");
            return;
        }
        if (strlcat(s, expected, sizeof(sbuf)) >= sizeof(sbuf)) {
            error("Buffer overflow in syntaxError");
            return;
        }
    }

    error(s);
}
#else
	
void Compiler::syntaxError(const char* msg, const char* expected) {
  Array<char> sbuf(128);  // error message to report
  char* s=&sbuf[0];
  strcat(s, "Config line ");
  for (int i=strlen(s), r=1000000; r; r/=10)  // append line number
    if (line/r) s[i++]='0'+line/r%10;
  strcat(s, " at ");
  for (int i=strlen(s); i<40 && *in>' '; ++i)  // append token found
    s[i]=*in++;
  strcat(s, ": ");
  strncat(s, msg, 40);  // append message
  if (expected) {
    strcat(s, ", expected: ");
    strncat(s, expected, 20);  // append expected token if any
  }
  error(s);
}
#endif
// Read a token, which must be in the NULL terminated list or else
// exit with an error. If found, return its index.
int Compiler::rtoken(const char* list[]) {
  assert(in);
  assert(list);
  next();
  for (int i=0; list[i]; ++i)
    if (matchToken(list[i]))
      return i;
  syntaxError("unexpected");
  assert(0);
  return -1; // not reached
}
// Read a token which must be the specified value s
void Compiler::rtoken(const char* s) {
  assert(s);
  next();
  if (!matchToken(s)) syntaxError("expected", s);
}
// Read a number in (low...high) or exit with an error
// For numbers like $N+M, return arg[N-1]+M
int Compiler::rtoken(int low, int high) {
  next();
  int r=0;
  if (in[0]=='$' && in[1]>='1' && in[1]<='9') {
    if (in[2]=='+') r=atoi(in+3);
    if (args) r+=args[in[1]-'1'];
  }
  else if (in[0]=='-' || (in[0]>='0' && in[0]<='9')) r=atoi(in);
  else syntaxError("expected a number");
  if (r<low) syntaxError("number too low");
  if (r>high) syntaxError("number too high");
  return r;
}
// Compile HCOMP or PCOMP code. Exit on error. Return
// code for end token (POST, PCOMP, END)
int Compiler::compile_comp(ZPAQL& z) {
  int op=0;
  const int comp_begin=z.hend;
  while (true) {
    op=rtoken(opcodelist);
    if (op==POST || op==PCOMP || op==END) break;
    int operand=-1; // 0...255 if 2 bytes
    int operand2=-1;  // 0...255 if 3 bytes
    if (op==IF) {
      op=JF;
      operand=0; // set later
      if_stack.push(z.hend+1); // save jump target location
    }
    else if (op==IFNOT) {
      op=JT;
      operand=0;
      if_stack.push(z.hend+1); // save jump target location
    }
    else if (op==IFL || op==IFNOTL) {  // long if
      if (op==IFL) z.header[z.hend++]=(JT);
      if (op==IFNOTL) z.header[z.hend++]=(JF);
      z.header[z.hend++]=(3);
      op=LJ;
      operand=operand2=0;
      if_stack.push(z.hend+1);
    }
    else if (op==ELSE || op==ELSEL) {
      if (op==ELSE) op=JMP, operand=0;
      if (op==ELSEL) op=LJ, operand=operand2=0;
      int a=if_stack.pop();  // conditional jump target location
      assert(a>comp_begin && a<int(z.hend));
      if (z.header[a-1]!=LJ) {  // IF, IFNOT
        assert(z.header[a-1]==JT || z.header[a-1]==JF || z.header[a-1]==JMP);
        int j=(z.hend-a)+1+(op==LJ); // offset at IF
        assert(j>=0);
        if (j>127) syntaxError("IF too big, try IFL, IFNOTL");
        z.header[a]=j;
      }
      else {  // IFL, IFNOTL
        int j=z.hend-comp_begin+2+(op==LJ);
        assert(j>=0);
        z.header[a]=j&255;
        z.header[a+1]=(j>>8)&255;
      }
      if_stack.push(z.hend+1);  // save JMP target location
    }
    else if (op==ENDIF) {
      int a=if_stack.pop();  // jump target address
      assert(a>comp_begin && a<int(z.hend));
      int j=z.hend-a-1;  // jump offset
      assert(j>=0);
      if (z.header[a-1]!=LJ) {
        assert(z.header[a-1]==JT || z.header[a-1]==JF || z.header[a-1]==JMP);
        if (j>127) syntaxError("IF too big, try IFL, IFNOTL, ELSEL\n");
        z.header[a]=j;
      }
      else {
        assert(a+1<int(z.hend));
        j=z.hend-comp_begin;
        z.header[a]=j&255;
        z.header[a+1]=(j>>8)&255;
      }
    }
    else if (op==DO) {
      do_stack.push(z.hend);
    }
    else if (op==WHILE || op==UNTIL || op==FOREVER) {
      int a=do_stack.pop();
      assert(a>=comp_begin && a<int(z.hend));
      int j=a-z.hend-2;
      assert(j<=-2);
      if (j>=-127) {  // backward short jump
        if (op==WHILE) op=JT;
        if (op==UNTIL) op=JF;
        if (op==FOREVER) op=JMP;
        operand=j&255;
      }
      else {  // backward long jump
        j=a-comp_begin;
        assert(j>=0 && j<int(z.hend)-comp_begin);
        if (op==WHILE) {
          z.header[z.hend++]=(JF);
          z.header[z.hend++]=(3);
        }
        if (op==UNTIL) {
          z.header[z.hend++]=(JT);
          z.header[z.hend++]=(3);
        }
        op=LJ;
        operand=j&255;
        operand2=j>>8;
      }
    }
    else if ((op&7)==7) { // 2 byte operand, read N
      if (op==LJ) {
        operand=rtoken(0, 65535);
        operand2=operand>>8;
        operand&=255;
      }
      else if (op==JT || op==JF || op==JMP) {
        operand=rtoken(-128, 127);
        operand&=255;
      }
      else
        operand=rtoken(0, 255);
    }
    if (op>=0 && op<=255)
      z.header[z.hend++]=(op);
    if (operand>=0)
      z.header[z.hend++]=(operand);
    if (operand2>=0)
      z.header[z.hend++]=(operand2);
    if (z.hend>=z.header.isize()-130 || z.hend-z.hbegin+z.cend-2>65535)
      syntaxError("program too big");
  }
  z.header[z.hend++]=(0); // END
  return op;
}
// Compile a configuration file. Store COMP/HCOMP section in hcomp.
// If there is a PCOMP section, store it in pcomp and store the PCOMP
// command in pcomp_cmd. Replace "$1..$9+n" with args[0..8]+n
Compiler::Compiler(const char* in_, int* args_, ZPAQL& hz_, ZPAQL& pz_,
                   Writer* out2_): in(in_), args(args_), hz(hz_), pz(pz_),
                   out2(out2_), if_stack(1000), do_stack(1000) {
  line=1;
  state=0;
  hz.clear();
  pz.clear();
  hz.header.resize(68000);
  // Compile the COMP section of header
  rtoken("comp");
  hz.header[2]=rtoken(0, 255);  // hh
  hz.header[3]=rtoken(0, 255);  // hm
  hz.header[4]=rtoken(0, 255);  // ph
  hz.header[5]=rtoken(0, 255);  // pm
  const int n=hz.header[6]=rtoken(0, 255);  // n
  hz.cend=7;
  for (int i=0; i<n; ++i) {
    rtoken(i, i);
    CompType type=CompType(rtoken(compname));
    hz.header[hz.cend++]=type;
    int clen=libzpaq::compsize[type&255];
    if (clen<1 || clen>10) syntaxError("invalid component");
    for (int j=1; j<clen; ++j)
      hz.header[hz.cend++]=rtoken(0, 255);  // component arguments
  }
  hz.header[hz.cend++];  // end
  hz.hbegin=hz.hend=hz.cend+128;
  // Compile HCOMP
  rtoken("hcomp");
  int op=compile_comp(hz);
  // Compute header size
  int hsize=(hz.cend-2)+hz.hend-hz.hbegin;
  hz.header[0]=hsize&255;
  hz.header[1]=hsize>>8;
  // Compile POST 0 END
  if (op==POST) {
    rtoken(0, 0);
    rtoken("end");
  }
  // Compile PCOMP pcomp_cmd ; program... END
  else if (op==PCOMP) {
    pz.header.resize(68000);
    pz.header[4]=hz.header[4];  // ph
    pz.header[5]=hz.header[5];  // pm
    pz.cend=8;
    pz.hbegin=pz.hend=pz.cend+128;
    // get pcomp_cmd ending with ";" (case sensitive)
    next();
    while (*in && *in!=';') {
      if (out2)
        out2->put(*in);
      ++in;
    }
    if (*in) ++in;
    // Compile PCOMP
    op=compile_comp(pz);
    int len=(pz.cend-2)+pz.hend-pz.hbegin;  // insert header size
    assert(len>=0);
    pz.header[0]=len&255;
    pz.header[1]=len>>8;
    if (op!=END)
      syntaxError("expected END");
  }
  else if (op!=END)
    syntaxError("expected END or POST 0 END or PCOMP cmd ; ... END");
}
///////////////////// Compressor //////////////////////
// Write 13 byte start tag
// "\x37\x6B\x53\x74\xA0\x31\x83\xD3\x8C\xB2\x28\xB0\xD3"
void Compressor::writeTag() {
  assert(state==INIT);
  enc.out->put(0x37);
  enc.out->put(0x6b);
  enc.out->put(0x53);
  enc.out->put(0x74);
  enc.out->put(0xa0);
  enc.out->put(0x31);
  enc.out->put(0x83);
  enc.out->put(0xd3);
  enc.out->put(0x8c);
  enc.out->put(0xb2);
  enc.out->put(0x28);
  enc.out->put(0xb0);
  enc.out->put(0xd3);
}
void Compressor::startBlock(int level) {
  // Model 1 - min.cfg
  static const char models[]={
  26,0,1,2,0,0,2,3,16,8,19,0,0,96,4,28,
  59,10,59,112,25,10,59,10,59,112,56,0,
  // Model 2 - mid.cfg
  69,0,3,3,0,0,8,3,5,8,13,0,8,17,1,8,
  18,2,8,18,3,8,19,4,4,22,24,7,16,0,7,24,
  (char)-1,0,17,104,74,4,95,1,59,112,10,25,59,112,10,25,
  59,112,10,25,59,112,10,25,59,112,10,25,59,10,59,112,
  25,69,(char)-49,8,112,56,0,
  // Model 3 - max.cfg
  (char)-60,0,5,9,0,0,22,1,(char)-96,3,5,8,13,1,8,16,
  2,8,18,3,8,19,4,8,19,5,8,20,6,4,22,24,
  3,17,8,19,9,3,13,3,13,3,13,3,14,7,16,0,
  15,24,(char)-1,7,8,0,16,10,(char)-1,6,0,15,16,24,0,9,
  8,17,32,(char)-1,6,8,17,18,16,(char)-1,9,16,19,32,(char)-1,6,
  0,19,20,16,0,0,17,104,74,4,95,2,59,112,10,25,
  59,112,10,25,59,112,10,25,59,112,10,25,59,112,10,25,
  59,10,59,112,10,25,59,112,10,25,69,(char)-73,32,(char)-17,64,47,
  14,(char)-25,91,47,10,25,60,26,48,(char)-122,(char)-105,20,112,63,9,70,
  (char)-33,0,39,3,25,112,26,52,25,25,74,10,4,59,112,25,
  10,4,59,112,25,10,4,59,112,25,65,(char)-113,(char)-44,72,4,59,
  112,8,(char)-113,(char)-40,8,68,(char)-81,60,60,25,69,(char)-49,9,112,25,25,
  25,25,25,112,56,0,
  0,0}; // 0,0 = end of list
  if (level<1) error("compression level must be at least 1");
  const char* p=models;
  int i;
  for (i=1; i<level && toU16(p); ++i)
    p+=toU16(p)+2;
  if (toU16(p)<1) error("compression level too high");
  startBlock(p);
}
// Memory reader
class MemoryReader: public Reader {
  const char* p;
public:
  MemoryReader(const char* p_): p(p_) {}
  int get() {return *p++&255;}
};
void Compressor::startBlock(const char* hcomp) {
  assert(state==INIT);
  MemoryReader m(hcomp);
  z.read(&m);
  pz.sha1=&sha1;
  assert(z.header.isize()>6);
  enc.out->put('z');
  enc.out->put('P');
  enc.out->put('Q');
  enc.out->put(1+(z.header[6]==0));  // level 1 or 2
  enc.out->put(1);
  z.write(enc.out, false);
  state=BLOCK1;
}
void Compressor::startBlock(const char* config, int* args, Writer* pcomp_cmd) {
  assert(state==INIT);
  Compiler(config, args, z, pz, pcomp_cmd);
  pz.sha1=&sha1;
  assert(z.header.isize()>6);
  enc.out->put('z');
  enc.out->put('P');
  enc.out->put('Q');
  enc.out->put(1+(z.header[6]==0));  // level 1 or 2
  enc.out->put(1);
  z.write(enc.out, false);
  state=BLOCK1;
}
// Write a segment header
void Compressor::startSegment(const char* filename, const char* comment) {
  assert(state==BLOCK1 || state==BLOCK2);
  enc.out->put(1);
  while (filename && *filename)
    enc.out->put(*filename++);
  enc.out->put(0);
  while (comment && *comment)
    enc.out->put(*comment++);
  enc.out->put(0);
  enc.out->put(0);
  if (state==BLOCK1) state=SEG1;
  if (state==BLOCK2) state=SEG2;
}
// Initialize encoding and write pcomp to first segment
// If len is 0 then length is encoded in pcomp[0..1]
// if pcomp is 0 then get pcomp from pz.header
void Compressor::postProcess(const char* pcomp, int len) {
  if (state==SEG2) return;
  assert(state==SEG1);
  enc.init();
  if (!pcomp) {
    len=pz.hend-pz.hbegin;
    if (len>0) {
      assert(pz.header.isize()>pz.hend);
      assert(pz.hbegin>=0);
      pcomp=(const char*)&pz.header[pz.hbegin];
    }
    assert(len>=0);
  }
  else if (len==0) {
    len=toU16(pcomp);
    pcomp+=2;
  }
  if (len>0) {
    enc.compress(1);
    enc.compress(len&255);
    enc.compress((len>>8)&255);
    for (int i=0; i<len; ++i)
      enc.compress(pcomp[i]&255);
    if (verify)
      pz.initp();
  }
  else
    enc.compress(0);
  state=SEG2;
}
// Compress n bytes, or to EOF if n < 0
bool Compressor::compress(int n) {
  if (state==SEG1)
    postProcess();
  assert(state==SEG2);
  const int BUFSIZE=1<<14;
  char buf[BUFSIZE*2];  // input buffer alpine BUFSIZE*2
  while (n) {
    int nbuf=BUFSIZE;  // bytes read into buf
    if (n>=0 && n<nbuf) nbuf=n;
    int nr=in->read(buf, nbuf);
    if (nr<0 || nr>BUFSIZE || nr>nbuf) error("invalid read size");
    if (nr<=0) return false;
    if (n>=0) n-=nr;
    for (int i=0; i<nr; ++i) {
      int ch=U8(buf[i]);
      enc.compress(ch);
      if (verify) {
        if (pz.hend) pz.run(ch);
        else sha1.put(ch);
      }
    }
  }
  return true;
}
// End segment, write sha1string if present
void Compressor::endSegment(const char* sha1string) {
  if (state==SEG1)
    postProcess();
  assert(state==SEG2);
  enc.compress(-1);
  if (verify && pz.hend) {
    pz.run(-1);
    pz.flush();
  }
  enc.out->put(0);
  enc.out->put(0);
  enc.out->put(0);
  enc.out->put(0);
  if (sha1string) {
    enc.out->put(253);
    for (int i=0; i<20; ++i)
      enc.out->put(sha1string[i]);
  }
  else
    enc.out->put(254);
  state=BLOCK2;
}
#ifdef DEBUG
// End segment, write checksum and size is verify is true
char* Compressor::endSegmentChecksum(int64_t* size, bool dosha1) {
  if (state==SEG1)
    postProcess();
  assert(state==SEG2);
  enc.compress(-1);
  if (verify && pz.hend) {
    pz.run(-1);
    pz.flush();
  }
  enc.out->put(0);
  enc.out->put(0);
  enc.out->put(0);
  enc.out->put(0);
  if (verify) {
    if (size) *size=sha1.usize();
    memcpy(sha1result, sha1.result(), 20);
  }
  if (verify && dosha1) {
    enc.out->put(253);
    for (int i=0; i<20; ++i)
      enc.out->put(sha1result[i]);
  }
  else
    enc.out->put(254);
  state=BLOCK2;
  return verify ? sha1result : 0;
}
#endif // corresponds to #ifdef (#ifdef DEBUG)
// End block
void Compressor::endBlock() {
  assert(state==BLOCK2);
  enc.out->put(255);
  state=INIT;
}
//////////////////////// ZPAQL::assemble() ////////////////////
/*
assemble();
Assembles the ZPAQL code in hcomp[0..hlen-1] and stores x86-32 or x86-64
code in rcode[0..rcode_size-1]. Execution begins at rcode[0]. It will not
write beyond the end of rcode, but in any case it returns the number of
bytes that would have been written. It returns 0 in case of error.
The assembled code implements int run() and returns 0 if successful,
1 if the ZPAQL code executes an invalid instruction or jumps out of
bounds, or 2 if OUT throws bad_alloc, or 3 for other OUT exceptions.
A ZPAQL virtual machine has the following state. All values are
unsigned and initially 0:
  a, b, c, d: 32 bit registers (pointed to by their respective parameters)
  f: 1 bit flag register (pointed to)
  r[0..255]: 32 bit registers
  m[0..msize-1]: 8 bit registers, where msize is a power of 2
  h[0..hsize-1]: 32 bit registers, where hsize is a power of 2
  out: pointer to a Writer
  sha1: pointer to a SHA1
Generally a ZPAQL machine is used to compute contexts which are
placed in h. A second machine might post-process, and write its
output to out and sha1. In either case, a machine is called with
its input in a, representing a single byte (0..255) or
(for a postprocessor) EOF (0xffffffff). Execution returs after a
ZPAQL halt instruction.
ZPAQL instructions are 1 byte unless the last 3 bits are 1.
In this case, a second operand byte follows. Opcode 255 is
the only 3 byte instruction. They are organized:
  00dddxxx = unary opcode xxx on destination ddd (ddd < 111)
  00111xxx = special instruction xxx
  01dddsss = assignment: ddd = sss (ddd < 111)
  1xxxxsss = operation xxxx from sss to a
The meaning of sss and ddd are as follows:
  000 = a   (accumulator)
  001 = b
  010 = c
  011 = d
  100 = *b  (means m[b mod msize])
  101 = *c  (means m[c mod msize])
  110 = *d  (means h[d mod hsize])
  111 = n   (constant 0..255 in second byte of instruction)
For example, 01001110 assigns *d to b. The other instructions xxx
are as follows:
Group 00dddxxx where ddd < 111 and xxx is:
  000 = ddd<>a, swap with a (except 00000000 is an error, and swap
        with *b or *c leaves the high bits of a unchanged)
  001 = ddd++, increment
  010 = ddd--, decrement
  011 = ddd!, not (invert all bits)
  100 = ddd=0, clear (set all bits of ddd to 0)
  101 = not used (error)
  110 = not used
  111 = ddd=r n, assign from r[n] to ddd, n=0..255 in next opcode byte
Except:
  00100111 = jt n, jump if f is true (n = -128..127, relative to next opcode)
  00101111 = jf n, jump if f is false (n = -128..127)
  00110111 = r=a n, assign r[n] = a (n = 0..255)
Group 00111xxx where xxx is:
  000 = halt (return)
  001 = output a
  010 = not used
  011 = hash: a = (a + *b + 512) * 773
  100 = hashd: *d = (*d + a + 512) * 773
  101 = not used
  110 = not used
  111 = unconditional jump (n = -128 to 127, relative to next opcode)
Group 1xxxxsss where xxxx is:
  0000 = a += sss (add, subtract, multiply, divide sss to a)
  0001 = a -= sss
  0010 = a *= sss
  0011 = a /= sss (unsigned, except set a = 0 if sss is 0)
  0100 = a %= sss (remainder, except set a = 0 if sss is 0)
  0101 = a &= sss (bitwise AND)
  0110 = a &= ~sss (bitwise AND with complement of sss)
  0111 = a |= sss (bitwise OR)
  1000 = a ^= sss (bitwise XOR)
  1001 = a <<= (sss % 32) (left shift by low 5 bits of sss)
  1010 = a >>= (sss % 32) (unsigned, zero bits shifted in)
  1011 = a == sss (compare, set f = true if equal or false otherwise)
  1100 = a < sss (unsigned compare, result in f)
  1101 = a > sss (unsigned compare)
  1110 = not used
  1111 = not used except 11111111 is a 3 byte jump to the absolute address
         in the next 2 bytes in little-endian (LSB first) order.
assemble() translates ZPAQL to 32 bit x86 code to be executed by run().
Registers are mapped as follows:
  eax = source sss from *b, *c, *d or sometimes n
  ecx = pointer to destination *b, *c, *d, or spare
  edx = a
  ebx = f (1 for true, 0 for false)
  esp = stack pointer
  ebp = d
  esi = b
  edi = c
run() saves non-volatile registers (ebp, esi, edi, ebx) on the stack,
loads a, b, c, d, f, and executes the translated instructions.
A halt instruction saves a, b, c, d, f, pops the saved registers
and returns. Invalid instructions or jumps outside of the range
of the ZPAQL code call libzpaq::error().
In 64 bit mode, the following additional registers are used:
  r12 = h
  r14 = r
  r15 = m
*/
// Called by out
static int flush1(ZPAQL* z) {
  try {
    z->flush();
    return 0;
  }
  catch(std::bad_alloc& x) {
    return 2;
  }
  catch(...) {
    return 3;
  }
}
// return true if op is an undefined ZPAQL instruction
static bool iserr(int op) {
  return op==0 || (op>=120 && op<=127) || (op>=240 && op<=254)
    || op==58 || (op<64 && (op%8==5 || op%8==6));
}
// Return length of ZPAQL instruction at hcomp[0]. Assume 0 padding at end.
// A run of identical ++ or -- is counted as 1 instruction.
static int oplen(const U8* hcomp) {
  if (*hcomp==255) return 3;
  if (*hcomp%8==7) return 2;
  if (*hcomp<51 && (*hcomp%8-1)/2==0) {  // ++ or -- opcode
    int i;
    for (i=1; i<127 && hcomp[i]==hcomp[0]; ++i);
    return i;
  }
  return 1;
}
// Write k bytes of x to rcode[o++] MSB first
static void put(U8* rcode, int n, int& o, U32 x, int k) {
  while (k-->0) {
    if (o<n) rcode[o]=(x>>(k*8))&255;
    ++o;
  }
}
// Write 4 bytes of x to rcode[o++] LSB first
static void put4lsb(U8* rcode, int n, int& o, U32 x) {
  for (int k=0; k<4; ++k) {
    if (o<n) rcode[o]=(x>>(k*8))&255;
    ++o;
  }
}
// Write a 1-4 byte x86 opcode without or with an 4 byte operand
// to rcode[o...]
#define put1(x) put(rcode, rcode_size, o, (x), 1)
#define put2(x) put(rcode, rcode_size, o, (x), 2)
#define put3(x) put(rcode, rcode_size, o, (x), 3)
#define put4(x) put(rcode, rcode_size, o, (x), 4)
#define put5(x,y) put4(x), put1(y)
#define put6(x,y) put4(x), put2(y)
#define put4r(x) put4lsb(rcode, rcode_size, o, x)
#define puta(x) t=U32(size_t(x)), put4r(t)
#define put1a(x,y) put1(x), puta(y)
#define put2a(x,y) put2(x), puta(y)
#define put3a(x,y) put3(x), puta(y)
#define put4a(x,y) put4(x), puta(y)
///#define put5a(x,y,z) put4(x), put1(y), puta(z)
#define put2l(x,y) put2(x), t=U32(size_t(y)), put4r(t), \
  t=U32(size_t(y)>>(S*4)), put4r(t)
// Assemble ZPAQL in in the HCOMP section of header to rcode,
// but do not write beyond rcode_size. Return the number of
// bytes output or that would have been output.
// Execution starts at rcode[0] and returns 1 if successful or 0
// in case of a ZPAQL execution error.
int ZPAQL::assemble() {
  // x86? (not foolproof)
  const int S=sizeof(char*);      // 4 = x86, 8 = x86-64
  U32 t=0x12345678;
  if (*(char*)&t!=0x78 || (S!=4 && S!=8))
    error("JIT supported only for x86-32 and x86-64");
  const U8* hcomp=&header[hbegin];
  const int hlen=(hend-hbegin)+2;
  const int msize=m.size();
  const int hsize=h.size();
  static const int regcode[8]={2,6,7,5}; // a,b,c,d.. -> edx,esi,edi,ebp,eax..
  Array<int> it(hlen);            // hcomp -> rcode locations
  int done=0;  // number of instructions assembled (0..hlen)
  int o=5;  // rcode output index, reserve space for jmp
  // Code for the halt instruction (restore registers and return)
  const int halt=o;
  if (S==8) {
    put2l(0x48b9, &a);        // mov rcx, a
    put2(0x8911);             // mov [rcx], edx
    put2l(0x48b9, &b);        // mov rcx, b
    put2(0x8931);             // mov [rcx], esi
    put2l(0x48b9, &c);        // mov rcx, c
    put2(0x8939);             // mov [rcx], edi
    put2l(0x48b9, &d);        // mov rcx, d
    put2(0x8929);             // mov [rcx], ebp
    put2l(0x48b9, &f);        // mov rcx, f
    put2(0x8919);             // mov [rcx], ebx
    put4(0x4883c408);         // add rsp, 8
    put2(0x415f);             // pop r15
    put2(0x415e);             // pop r14
    put2(0x415d);             // pop r13
    put2(0x415c);             // pop r12
  }
  else {
    put2a(0x8915, &a);        // mov [a], edx
    put2a(0x8935, &b);        // mov [b], esi
    put2a(0x893d, &c);        // mov [c], edi
    put2a(0x892d, &d);        // mov [d], ebp
    put2a(0x891d, &f);        // mov [f], ebx
    put3(0x83c40c);           // add esp, 12
  }
  put1(0x5b);                 // pop ebx
  put1(0x5f);                 // pop edi
  put1(0x5e);                 // pop esi
  put1(0x5d);                 // pop ebp
  put1(0xc3);                 // ret
  // Code for the out instruction.
  // Store a=edx at outbuf[bufptr++]. If full, call flush1().
  const int outlabel=o;
  if (S==8) {
    put2l(0x48b8, &outbuf[0]);// mov rax, outbuf.p
    put2l(0x49ba, &bufptr);   // mov r10, &bufptr
    put3(0x418b0a);           // mov rcx, [r10]
    put3(0x881408);           // mov [rax+rcx], dl
    put2(0xffc1);             // inc rcx
    put3(0x41890a);           // mov [r10], ecx
    put2a(0x81f9, outbuf.size());  // cmp rcx, outbuf.size()
    put2(0x7403);             // jz L1
    put2(0x31c0);             // xor eax, eax
    put1(0xc3);               // ret
    put1(0x55);               // L1: push rbp ; call flush1(this)
    put1(0x57);               // push rdi
    put1(0x56);               // push rsi
    put1(0x52);               // push rdx
    put1(0x51);               // push rcx
    put3(0x4889e5);           // mov rbp, rsp
    put4(0x4883c570);         // add rbp, 112
#if defined(unix) && !defined(__CYGWIN__)
    put2l(0x48bf, this);      // mov rdi, this
#else  // Windows
    put2l(0x48b9, this);      // mov rcx, this
#endif // corresponds to #if (#if defined(unix) && !defined(__CYGWIN__))
    put2l(0x49bb, &flush1);   // mov r11, &flush1
    put3(0x41ffd3);           // call r11
    put1(0x59);               // pop rcx
    put1(0x5a);               // pop rdx
    put1(0x5e);               // pop rsi
    put1(0x5f);               // pop rdi
    put1(0x5d);               // pop rbp
  }
  else {
    put1a(0xb8, &outbuf[0]);  // mov eax, outbuf.p
    put2a(0x8b0d, &bufptr);   // mov ecx, [bufptr]
    put3(0x881408);           // mov [eax+ecx], dl
    put2(0xffc1);             // inc ecx
    put2a(0x890d, &bufptr);   // mov [bufptr], ecx
    put2a(0x81f9, outbuf.size());  // cmp ecx, outbuf.size()
    put2(0x7403);             // jz L1
    put2(0x31c0);             // xor eax, eax
    put1(0xc3);               // ret
    put3(0x83ec0c);           // L1: sub esp, 12
    put4(0x89542404);         // mov [esp+4], edx
    put3a(0xc70424, this);    // mov [esp], this
    put1a(0xb8, &flush1);     // mov eax, &flush1
    put2(0xffd0);             // call eax
    put4(0x8b542404);         // mov edx, [esp+4]
    put3(0x83c40c);           // add esp, 12
  }
  put1(0xc3);               // ret
  // Set it[i]=1 for each ZPAQL instruction reachable from the previous
  // instruction + 2 if reachable by a jump (or 3 if both).
  it[0]=2;
  assert(hlen>0 && hcomp[hlen-1]==0);  // ends with error
  do {
    done=0;
    const int NONE=0x80000000;
    for (int i=0; i<hlen; ++i) {
      int op=hcomp[i];
      if (it[i]) {
        int next1=i+oplen(hcomp+i), next2=NONE; // next and jump targets
        if (iserr(op)) next1=NONE;  // error
        if (op==56) next1=NONE, next2=0;  // halt
        if (op==255) next1=NONE, next2=hcomp[i+1]+256*hcomp[i+2]; // lj
        if (op==39||op==47||op==63)next2=i+2+(hcomp[i+1]<<24>>24);// jt,jf,jmp
        if (op==63) next1=NONE;  // jmp
        if ((next2<0 || next2>=hlen) && next2!=NONE) next2=hlen-1; // error
        if (next1>=0 && next1<hlen && !(it[next1]&1)) it[next1]|=1, ++done;
        if (next2>=0 && next2<hlen && !(it[next2]&2)) it[next2]|=2, ++done;
      }
    }
  } while (done>0);
  // Set it[i] bits 2-3 to 4, 8, or 12 if a comparison
  //  (==, <, > respectively) does not need to save the result in f,
  // or if a conditional jump (jt, jf) does not need to read f.
  // This is true if a comparison is followed directly by a jt/jf,
  // the jt/jf is not a jump target, the byte before is not a jump
  // target (for a 2 byte comparison), and for the comparison instruction
  // if both paths after the jt/jf lead to another comparison or error
  // before another jt/jf. At most hlen steps are traced because after
  // that it must be an infinite loop.
  for (int i=0; i<hlen; ++i) {
    const int op1=hcomp[i]; // 216..239 = comparison
    const int i2=i+1+(op1%8==7);  // address of next instruction
    const int op2=hcomp[i2];  // 39,47 = jt,jf
    if (it[i] && op1>=216 && op1<240 && (op2==39 || op2==47)
        && it[i2]==1 && (i2==i+1 || it[i+1]==0)) {
      int code=(op1-208)/8*4; // 4,8,12 is ==,<,>
      it[i2]+=code;  // OK to test CF, ZF instead of f
      for (int j=0; j<2 && code; ++j) {  // trace each path from i2
        int k=i2+2; // branch not taken
        if (j==1) k=i2+2+(hcomp[i2+1]<<24>>24);  // branch taken
        for (int l=0; l<hlen && code; ++l) {  // trace at most hlen steps
          if (k<0 || k>=hlen) break;  // out of bounds, pass
          const int op=hcomp[k];
          if (op==39 || op==47) code=0;  // jt,jf, fail
          else if (op>=216 && op<240) break;  // ==,<,>, pass
          else if (iserr(op)) break;  // error, pass
          else if (op==255) k=hcomp[k+1]+256*hcomp[k+2]; // lj
          else if (op==63) k=k+2+(hcomp[k+1]<<24>>24);  // jmp
          else if (op==56) k=0;  // halt
          else k=k+1+(op%8==7);  // ordinary instruction
        }
      }
      it[i]+=code;  // if > 0 then OK to not save flags in f (bl)
    }
  }
  // Start of run(): Save x86 and load ZPAQL registers
  const int start=o;
  assert(start>=16);
  put1(0x55);          // push ebp/rbp
  put1(0x56);          // push esi/rsi
  put1(0x57);          // push edi/rdi
  put1(0x53);          // push ebx/rbx
  if (S==8) {
    put2(0x4154);      // push r12
    put2(0x4155);      // push r13
    put2(0x4156);      // push r14
    put2(0x4157);      // push r15
    put4(0x4883ec08);  // sub rsp, 8
    put2l(0x48b8, &a); // mov rax, a
    put2(0x8b10);      // mov edx, [rax]
    put2l(0x48b8, &b); // mov rax, b
    put2(0x8b30);      // mov esi, [rax]
    put2l(0x48b8, &c); // mov rax, c
    put2(0x8b38);      // mov edi, [rax]
    put2l(0x48b8, &d); // mov rax, d
    put2(0x8b28);      // mov ebp, [rax]
    put2l(0x48b8, &f); // mov rax, f
    put2(0x8b18);      // mov ebx, [rax]
    put2l(0x49bc, &h[0]);   // mov r12, h
    put2l(0x49bd, &outbuf[0]); // mov r13, outbuf.p
    put2l(0x49be, &r[0]);   // mov r14, r
    put2l(0x49bf, &m[0]);   // mov r15, m
  }
  else {
    put3(0x83ec0c);    // sub esp, 12
    put2a(0x8b15, &a); // mov edx, [a]
    put2a(0x8b35, &b); // mov esi, [b]
    put2a(0x8b3d, &c); // mov edi, [c]
    put2a(0x8b2d, &d); // mov ebp, [d]
    put2a(0x8b1d, &f); // mov ebx, [f]
  }
  // Assemble in multiple passes until every byte of hcomp has a translation
  for (int istart=0; istart<hlen; ++istart) {
    int inc=0;
    for (int i=istart; i<hlen && it[i]; i+=inc) {
      const int code=it[i];
      inc=oplen(hcomp+i);
      // If already assembled, then assemble a jump to it
      U32 t;
      assert(it.isize()>i);
      assert(i>=0 && i<hlen);
      if (code>=16) {
        if (i>istart) {
          int a=code-o;
          if (a>-120 && a<120)
            put2(0xeb00+((a-2)&255)); // jmp short o
          else
            put1a(0xe9, a-5);  // jmp near o
        }
        break;
      }
      // Else assemble the instruction at hcomp[i] to rcode[o]
      else {
        assert(i>=0 && i<it.isize());
        assert(it[i]>0 && it[i]<16);
        assert(o>=16);
        it[i]=o;
        ++done;
        const int op=hcomp[i];
        const int arg=hcomp[i+1]+((op==255)?256*hcomp[i+2]:0);
        const int ddd=op/8%8;
        const int sss=op%8;
        // error instruction: return 1
        if (iserr(op)) {
          put1a(0xb8, 1);         // mov eax, 1
          put1a(0xe9, halt-o-4);  // jmp near halt
          continue;
        }
        // Load source *b, *c, *d, or hash (*b) into eax except:
        // {a,b,c,d}=*d, a{+,-,*,&,|,^,=,==,>,>}=*d: load address to eax
        // {a,b,c,d}={*b,*c}: load source into ddd
        if (op==59 || (op>=64 && op<240 && op%8>=4 && op%8<7)) {
          put2(0x89c0+8*regcode[sss-3+(op==59)]);  // mov eax, {esi,edi,ebp}
          const int sz=(sss==6?hsize:msize)-1;
          if (sz>=128) put1a(0x25, sz);            // and eax, dword msize-1
          else put3(0x83e000+sz);                  // and eax, byte msize-1
          const int move=(op>=64 && op<112); // = or else ddd is eax
          if (sss<6) { // ddd={a,b,c,d,*b,*c}
            if (S==8) put5(0x410fb604+8*move*regcode[ddd],0x07);
                                                   // movzx ddd, byte [r15+rax]
            else put3a(0x0fb680+8*move*regcode[ddd], &m[0]);
                                                   // movzx ddd, byte [m+eax]
          }
          else if ((0x06587000>>(op/8))&1) {// {*b,*c,*d,a/,a%,a&~,a<<,a>>}=*d
            if (S==8) put4(0x418b0484);            // mov eax, [r12+rax*4]
            else put3a(0x8b0485, &h[0]);           // mov eax, [h+eax*4]
          }
        }
        // Load destination address *b, *c, *d or hashd (*d) into ecx
        if ((op>=32 && op<56 && op%8<5) || (op>=96 && op<120) || op==60) {
          put2(0x89c1+8*regcode[op/8%8-3-(op==60)]);// mov ecx,{esi,edi,ebp}
          const int sz=(ddd==6||op==60?hsize:msize)-1;
          if (sz>=128) put2a(0x81e1, sz);   // and ecx, dword sz
          else put3(0x83e100+sz);           // and ecx, byte sz
          if (op/8%8==6 || op==60) { // *d
            if (S==8) put4(0x498d0c8c);     // lea rcx, [r12+rcx*4]
            else put3a(0x8d0c8d, &h[0]);    // lea ecx, [ecx*4+h]
          }
          else { // *b, *c
            if (S==8) put4(0x498d0c0f);     // lea rcx, [r15+rcx]
            else put2a(0x8d89, &m[0]);      // lea ecx, [ecx+h]
          }
        }
        // Translate by opcode
        switch((op/8)&31) {
          case 0:  // ddd = a
          case 1:  // ddd = b
          case 2:  // ddd = c
          case 3:  // ddd = d
            switch(sss) {
              case 0:  // ddd<>a (swap)
                put2(0x87d0+regcode[ddd]);   // xchg edx, ddd
                break;
              case 1:  // ddd++
                put3(0x83c000+256*regcode[ddd]+inc); // add ddd, inc
                break;
              case 2:  // ddd--
                put3(0x83e800+256*regcode[ddd]+inc); // sub ddd, inc
                break;
              case 3:  // ddd!
                put2(0xf7d0+regcode[ddd]);   // not ddd
                break;
              case 4:  // ddd=0
                put2(0x31c0+9*regcode[ddd]); // xor ddd,ddd
                break;
              case 7:  // ddd=r n
                if (S==8)
                  put3a(0x418b86+8*regcode[ddd], arg*4); // mov ddd, [r14+n*4]
                else
                  put2a(0x8b05+8*regcode[ddd], (&r[arg]));//mov ddd, [r+n]
                break;
            }
            break;
          case 4:  // ddd = *b
          case 5:  // ddd = *c
            switch(sss) {
              case 0:  // ddd<>a (swap)
                put2(0x8611);                // xchg dl, [ecx]
                break;
              case 1:  // ddd++
                put3(0x800100+inc);          // add byte [ecx], inc
                break;
              case 2:  // ddd--
                put3(0x802900+inc);          // sub byte [ecx], inc
                break;
              case 3:  // ddd!
                put2(0xf611);                // not byte [ecx]
                break;
              case 4:  // ddd=0
                put2(0x31c0);                // xor eax, eax
                put2(0x8801);                // mov [ecx], al
                break;
              case 7:  // jt, jf
              {
                assert(code>=0 && code<16);
                static const unsigned char jtab[2][4]={{5,4,2,7},{4,5,3,6}};
                               // jnz,je,jb,ja, jz,jne,jae,jbe
                if (code<4) put2(0x84db);    // test bl, bl
                if (arg>=128 && arg-257-i>=0 && o-it[arg-257-i]<120)
                  put2(0x7000+256*jtab[op==47][code/4]); // jx short 0
                else
                  put2a(0x0f80+jtab[op==47][code/4], 0); // jx near 0
                break;
              }
            }
            break;
          case 6:  // ddd = *d
            switch(sss) {
              case 0:  // ddd<>a (swap)
                put2(0x8711);             // xchg edx, [ecx]
                break;
              case 1:  // ddd++
                put3(0x830100+inc);       // add dword [ecx], inc
                break;
              case 2:  // ddd--
                put3(0x832900+inc);       // sub dword [ecx], inc
                break;
              case 3:  // ddd!
                put2(0xf711);             // not dword [ecx]
                break;
              case 4:  // ddd=0
                put2(0x31c0);             // xor eax, eax
                put2(0x8901);             // mov [ecx], eax
                break;
              case 7:  // ddd=r n
                if (S==8)
                  put3a(0x418996, arg*4); // mov [r14+n*4], edx
                else
                  put2a(0x8915, &r[arg]); // mov [r+n], edx
                break;
            }
            break;
          case 7:  // special
            switch(op) {
              case 56: // halt
                put2(0x31c0);             // xor eax, eax  ; return 0
                put1a(0xe9, halt-o-4);    // jmp near halt
                break;
              case 57:  // out
                put1a(0xe8, outlabel-o-4);// call outlabel
                put3(0x83f800);           // cmp eax, 0  ; returned error code
                put2(0x7405);             // je L1:
                put1a(0xe9, halt-o-4);    // jmp near halt ; L1:
                break;
              case 59:  // hash: a = (a + *b + 512) * 773
                put3a(0x8d8410, 512);     // lea edx, [eax+edx+512]
                put2a(0x69d0, 773);       // imul edx, eax, 773
                break;
              case 60:  // hashd: *d = (*d + a + 512) * 773
                put2(0x8b01);             // mov eax, [ecx]
                put3a(0x8d8410, 512);     // lea eax, [eax+edx+512]
                put2a(0x69c0, 773);       // imul eax, eax, 773
                put2(0x8901);             // mov [ecx], eax
                break;
              case 63:  // jmp
                put1a(0xe9, 0);           // jmp near 0 (fill in target later)
                break;
            }
            break;
          case 8:   // a=
          case 9:   // b=
          case 10:  // c=
          case 11:  // d=
            if (sss==7)  // n
              put1a(0xb8+regcode[ddd], arg);         // mov ddd, n
            else if (sss==6) { // *d
              if (S==8)
                put4(0x418b0484+(regcode[ddd]<<11)); // mov ddd, [r12+rax*4]
              else
                put3a(0x8b0485+(regcode[ddd]<<11),&h[0]);// mov ddd, [h+eax*4]
            }
            else if (sss<4) // a, b, c, d
              put2(0x89c0+regcode[ddd]+8*regcode[sss]);// mov ddd,sss
            break;
          case 12:  // *b=
          case 13:  // *c=
            if (sss==7) put3(0xc60100+arg);          // mov byte [ecx], n
            else if (sss==0) put2(0x8811);           // mov byte [ecx], dl
            else {
              if (sss<4) put2(0x89c0+8*regcode[sss]);// mov eax, sss
              put2(0x8801);                          // mov byte [ecx], al
            }
            break;
          case 14:  // *d=
            if (sss<7) put2(0x8901+8*regcode[sss]);  // mov [ecx], sss
            else put2a(0xc701, arg);                 // mov dword [ecx], n
            break;
          case 15: break; // not used
          case 16:  // a+=
            if (sss==6) {
              if (S==8) put4(0x41031484);            // add edx, [r12+rax*4]
              else put3a(0x031485, &h[0]);           // add edx, [h+eax*4]
            }
            else if (sss<7) put2(0x01c2+8*regcode[sss]);// add edx, sss
            else if (arg>=128) put2a(0x81c2, arg);   // add edx, n
            else put3(0x83c200+arg);                 // add edx, byte n
            break;
          case 17:  // a-=
            if (sss==6) {
              if (S==8) put4(0x412b1484);            // sub edx, [r12+rax*4]
              else put3a(0x2b1485, &h[0]);           // sub edx, [h+eax*4]
            }
            else if (sss<7) put2(0x29c2+8*regcode[sss]);// sub edx, sss
            else if (arg>=128) put2a(0x81ea, arg);   // sub edx, n
            else put3(0x83ea00+arg);                 // sub edx, byte n
            break;
          case 18:  // a*=
            if (sss==6) {
              if (S==8) put5(0x410faf14,0x84);       // imul edx, [r12+rax*4]
              else put4a(0x0faf1485, &h[0]);         // imul edx, [h+eax*4]
            }
            else if (sss<7) put3(0x0fafd0+regcode[sss]);// imul edx, sss
            else if (arg>=128) put2a(0x69d2, arg);   // imul edx, n
            else put3(0x6bd200+arg);                 // imul edx, byte n
            break;
          case 19:  // a/=
          case 20:  // a%=
            if (sss<7) put2(0x89c1+8*regcode[sss]);  // mov ecx, sss
            else put1a(0xb9, arg);                   // mov ecx, n
            put2(0x85c9);                            // test ecx, ecx
            put3(0x0f44d1);                          // cmovz edx, ecx
            put2(0x7408-2*(op/8==20));               // jz (over rest)
            put2(0x89d0);                            // mov eax, edx
            put2(0x31d2);                            // xor edx, edx
            put2(0xf7f1);                            // div ecx
            if (op/8==19) put2(0x89c2);              // mov edx, eax
            break;
          case 21:  // a&=
            if (sss==6) {
              if (S==8) put4(0x41231484);            // and edx, [r12+rax*4]
              else put3a(0x231485, &h[0]);           // and edx, [h+eax*4]
            }
            else if (sss<7) put2(0x21c2+8*regcode[sss]);// and edx, sss
            else if (arg>=128) put2a(0x81e2, arg);   // and edx, n
            else put3(0x83e200+arg);                 // and edx, byte n
            break;
          case 22:  // a&~
            if (sss==7) {
              if (arg<128) put3(0x83e200+(~arg&255));// and edx, byte ~n
              else put2a(0x81e2, ~arg);              // and edx, ~n
            }
            else {
              if (sss<4) put2(0x89c0+8*regcode[sss]);// mov eax, sss
              put2(0xf7d0);                          // not eax
              put2(0x21c2);                          // and edx, eax
            }
            break;
          case 23:  // a|=
            if (sss==6) {
              if (S==8) put4(0x410b1484);            // or edx, [r12+rax*4]
              else put3a(0x0b1485, &h[0]);           // or edx, [h+eax*4]
            }
            else if (sss<7) put2(0x09c2+8*regcode[sss]);// or edx, sss
            else if (arg>=128) put2a(0x81ca, arg);   // or edx, n
            else put3(0x83ca00+arg);                 // or edx, byte n
            break;
          case 24:  // a^=
            if (sss==6) {
              if (S==8) put4(0x41331484);            // xor edx, [r12+rax*4]
              else put3a(0x331485, &h[0]);           // xor edx, [h+eax*4]
            }
            else if (sss<7) put2(0x31c2+8*regcode[sss]);// xor edx, sss
            else if (arg>=128) put2a(0x81f2, arg);   // xor edx, byte n
            else put3(0x83f200+arg);                 // xor edx, n
            break;
          case 25:  // a<<=
          case 26:  // a>>=
            if (sss==7)  // sss = n
              put3(0xc1e200+8*256*(op/8==26)+arg);   // shl/shr n
            else {
              put2(0x89c1+8*regcode[sss]);           // mov ecx, sss
              put2(0xd3e2+8*(op/8==26));             // shl/shr edx, cl
            }
            break;
          case 27:  // a==
          case 28:  // a<
          case 29:  // a>
            if (sss==6) {
              if (S==8) put4(0x413b1484);            // cmp edx, [r12+rax*4]
              else put3a(0x3b1485, &h[0]);           // cmp edx, [h+eax*4]
            }
            else if (sss==7)  // sss = n
              put2a(0x81fa, arg);                    // cmp edx, dword n
            else
              put2(0x39c2+8*regcode[sss]);           // cmp edx, sss
            if (code<4) {
              if (op/8==27) put3(0x0f94c3);          // setz bl
              if (op/8==28) put3(0x0f92c3);          // setc bl
              if (op/8==29) put3(0x0f97c3);          // seta bl
            }
            break;
          case 30:  // not used
          case 31:  // 255 = lj
            if (op==255) put1a(0xe9, 0);             // jmp near
            break;
        }
      }
    }
  }
  // Finish first pass
  const int rsize=o;
  if (o>rcode_size) return rsize;
  // Fill in jump addresses (second pass)
  for (int i=0; i<hlen; ++i) {
    if (it[i]<16) continue;
    int op=hcomp[i];
    if (op==39 || op==47 || op==63 || op==255) {  // jt, jf, jmp, lj
      int target=hcomp[i+1];
      if (op==255) target+=hcomp[i+2]*256;  // lj
      else {
        if (target>=128) target-=256;
        target+=i+2;
      }
      if (target<0 || target>=hlen) target=hlen-1;  // runtime ZPAQL error
      o=it[i];
      assert(o>=16 && o<rcode_size);
      if ((op==39 || op==47) && rcode[o]==0x84) o+=2;  // jt, jf -> skip test
      assert(o>=16 && o<rcode_size);
      if (rcode[o]==0x0f) ++o;  // first byte of jz near, jnz near
      assert(o<rcode_size);
      op=rcode[o++];  // x86 opcode
      target=it[target]-o;
      if ((op>=0x72 && op<0x78) || op==0xeb) {  // jx, jmp short
        --target;
        if (target<-128 || target>127)
          error("Cannot code x86 short jump");
        assert(o<rcode_size);
        rcode[o]=target&255;
      }
      else if ((op>=0x82 && op<0x88) || op==0xe9) // jx, jmp near
      {
        target-=4;
        puta(target);
      }
      else assert(false);  // not a x86 jump
    }
  }
  // Jump to start
  o=0;
  put1a(0xe9, start-5);  // jmp near start
  return rsize;
}
//////////////////////// Predictor::assemble_p() /////////////////////
// Assemble the ZPAQL code in the HCOMP section of z.header to pcomp and
// return the number of bytes of x86 or x86-64 code written, or that would
// be written if pcomp were large enough. The code for predict() begins
// at pr.pcomp[0] and update() at pr.pcomp[5], both as jmp instructions.
// The assembled code is equivalent to int predict(Predictor*)
// and void update(Predictor*, int y); The Preditor address is placed in
// edi/rdi. The update bit y is placed in ebp/rbp.
int Predictor::assemble_p() {
  Predictor& pr=*this;
  U8* rcode=pr.pcode;         // x86 output array
  int rcode_size=pcode_size;  // output size
  int o=0;                    // output index in pcode
  const int S=sizeof(char*);  // 4 or 8
  U8* hcomp=&pr.z.header[0];  // The code to translate
#define off(x)  ((char*)&(pr.x)-(char*)&pr)
#define offc(x) ((char*)&(pr.comp[i].x)-(char*)&pr)
  // test for little-endian (probably x86)
  U32 t=0x12345678;
  if (*(char*)&t!=0x78 || (S!=4 && S!=8))
    error("JIT supported only for x86-32 and x86-64");
  // Initialize for predict(). Put predictor address in edi/rdi
  put1a(0xe9, 5);             // jmp predict
  put1a(0, 0x90909000);       // reserve space for jmp update
  put1(0x53);                 // push ebx/rbx
  put1(0x55);                 // push ebp/rbp
  put1(0x56);                 // push esi/rsi
  put1(0x57);                 // push edi/rdi
  if (S==4)
    put4(0x8b7c2414);         // mov edi,[esp+0x14] ; pr
  else {
#if !defined(unix) || defined(__CYGWIN__)
    put3(0x4889cf);           // mov rdi, rcx (1st arg in Win64)
#endif // corresponds to #if (#if !defined(unix) || defined(__CYGWIN__))
  }
  // Code predict() for each component
  const int n=hcomp[6];  // number of components
  U8* cp=hcomp+7;
  for (int i=0; i<n; ++i, cp+=compsize[cp[0]]) {
    if (cp-hcomp>=pr.z.cend) error("comp too big");
    if (cp[0]<1 || cp[0]>9) error("invalid component");
    assert(compsize[cp[0]]>0 && compsize[cp[0]]<8);
    switch (cp[0]) {
      case CONS:  // c
        break;
      case CM:  // sizebits limit
        // Component& cr=comp[i];
        // cr.cxt=h[i]^hmap4;
        // p[i]=stretch(cr.cm(cr.cxt)>>17);
        put2a(0x8b87, off(h[i]));              // mov eax, [edi+&h[i]]
        put2a(0x3387, off(hmap4));             // xor eax, [edi+&hmap4]
        put1a(0x25, (1<<cp[1])-1);             // and eax, size-1
        put2a(0x8987, offc(cxt));              // mov [edi+cxt], eax
        if (S==8) put1(0x48);                  // rex.w (esi->rsi)
        put2a(0x8bb7, offc(cm));               // mov esi, [edi+&cm]
        put3(0x8b0486);                        // mov eax, [esi+eax*4]
        put3(0xc1e811);                        // shr eax, 17
        put4a(0x0fbf8447, off(stretcht));      // movsx eax,word[edi+eax*2+..]
        put2a(0x8987, off(p[i]));              // mov [edi+&p[i]], eax
        break;
      case ISSE:  // sizebits j -- c=hi, cxt=bh
        // assert((hmap4&15)>0);
        // if (c8==1 || (c8&0xf0)==16)
        //   cr.c=find(cr.ht, cp[1]+2, h[i]+16*c8);
        // cr.cxt=cr.ht[cr.c+(hmap4&15)];  // bit history
        // int *wt=(int*)&cr.cm[cr.cxt*2];
        // p[i]=clamp2k((wt[0]*p[cp[2]]+wt[1]*64)>>16);
      case ICM: // sizebits
        // assert((hmap4&15)>0);
        // if (c8==1 || (c8&0xf0)==16) cr.c=find(cr.ht, cp[1]+2, h[i]+16*c8);
        // cr.cxt=cr.ht[cr.c+(hmap4&15)];
        // p[i]=stretch(cr.cm(cr.cxt)>>8);
        //
        // Find cxt row in hash table ht. ht has rows of 16 indexed by the low
        // sizebits of cxt with element 0 having the next higher 8 bits for
        // collision detection. If not found after 3 adjacent tries, replace
        // row with lowest element 1 as priority. Return index of row.
        //
        // size_t Predictor::find(Array<U8>& ht, int sizebits, U32 cxt) {
        //  assert(ht.size()==size_t(16)<<sizebits);
        //  int chk=cxt>>sizebits&255;
        //  size_t h0=(cxt*16)&(ht.size()-16);
        //  if (ht[h0]==chk) return h0;
        //  size_t h1=h0^16;
        //  if (ht[h1]==chk) return h1;
        //  size_t h2=h0^32;
        //  if (ht[h2]==chk) return h2;
        //  if (ht[h0+1]<=ht[h1+1] && ht[h0+1]<=ht[h2+1])
        //    return memset(&ht[h0], 0, 16), ht[h0]=chk, h0;
        //  else if (ht[h1+1]<ht[h2+1])
        //    return memset(&ht[h1], 0, 16), ht[h1]=chk, h1;
        //  else
        //    return memset(&ht[h2], 0, 16), ht[h2]=chk, h2;
        // }
        if (S==8) put1(0x48);                  // rex.w
        put2a(0x8bb7, offc(ht));               // mov esi, [edi+&ht]
        put2(0x8b07);                          // mov eax, edi ; c8
        put2(0x89c1);                          // mov ecx, eax ; c8
        put3(0x83f801);                        // cmp eax, 1
        put2(0x740a);                          // je L1
        put1a(0x25, 240);                      // and eax, 0xf0
        put3(0x83f810);                        // cmp eax, 16
        put2(0x7576);                          // jne L2 ; skip find()
           // L1: ; find cxt in ht, return index in eax
        put3(0xc1e104);                        // shl ecx, 4
        put2a(0x038f, off(h[i]));              // add [edi+&h[i]]
        put2(0x89c8);                          // mov eax, ecx ; cxt
        put3(0xc1e902+cp[1]);                  // shr ecx, sizebits+2
        put2a(0x81e1, 255);                    // and eax, 255 ; chk
        put3(0xc1e004);                        // shl eax, 4
        put1a(0x25, (64<<cp[1])-16);           // and eax, ht.size()-16 = h0
        put3(0x3a0c06);                        // cmp cl, [esi+eax] ; ht[h0]
        put2(0x744d);                          // je L3 ; match h0
        put3(0x83f010);                        // xor eax, 16 ; h1
        put3(0x3a0c06);                        // cmp cl, [esi+eax]
        put2(0x7445);                          // je L3 ; match h1
        put3(0x83f030);                        // xor eax, 48 ; h2
        put3(0x3a0c06);                        // cmp cl, [esi+eax]
        put2(0x743d);                          // je L3 ; match h2
          // No checksum match, so replace the lowest priority among h0,h1,h2
        put3(0x83f021);                        // xor eax, 33 ; h0+1
        put3(0x8a1c06);                        // mov bl, [esi+eax] ; ht[h0+1]
        put2(0x89c2);                          // mov edx, eax ; h0+1
        put3(0x83f220);                        // xor edx, 32  ; h2+1
        put3(0x3a1c16);                        // cmp bl, [esi+edx]
        put2(0x7708);                          // ja L4 ; test h1 vs h2
        put3(0x83f230);                        // xor edx, 48  ; h1+1
        put3(0x3a1c16);                        // cmp bl, [esi+edx]
        put2(0x7611);                          // jbe L7 ; replace h0
          // L4: ; h0 is not lowest, so replace h1 or h2
        put3(0x83f010);                        // xor eax, 16 ; h1+1
        put3(0x8a1c06);                        // mov bl, [esi+eax]
        put3(0x83f030);                        // xor eax, 48 ; h2+1
        put3(0x3a1c06);                        // cmp bl, [esi+eax]
        put2(0x7303);                          // jae L7
        put3(0x83f030);                        // xor eax, 48 ; h1+1
          // L7: ; replace row pointed to by eax = h0,h1,h2
        put3(0x83f001);                        // xor eax, 1
        put3(0x890c06);                        // mov [esi+eax], ecx ; chk
        put2(0x31c9);                          // xor ecx, ecx
        put4(0x894c0604);                      // mov [esi+eax+4], ecx
        put4(0x894c0608);                      // mov [esi+eax+8], ecx
        put4(0x894c060c);                      // mov [esi+eax+12], ecx
          // L3: ; save nibble context (in eax) in c
        put2a(0x8987, offc(c));                // mov [edi+c], eax
        put2(0xeb06);                          // jmp L8
          // L2: ; get nibble context
        put2a(0x8b87, offc(c));                // mov eax, [edi+c]
          // L8: ; nibble context is in eax
        put2a(0x8b97, off(hmap4));             // mov edx, [edi+&hmap4]
        put3(0x83e20f);                        // and edx, 15  ; hmap4
        put2(0x01d0);                          // add eax, edx ; c+(hmap4&15)
        put4(0x0fb61406);                      // movzx edx, byte [esi+eax]
        put2a(0x8997, offc(cxt));              // mov [edi+&cxt], edx ; cxt=bh
        if (S==8) put1(0x48);                  // rex.w
        put2a(0x8bb7, offc(cm));               // mov esi, [edi+&cm] ; cm
        // esi points to cm[256] (ICM) or cm[512] (ISSE) with 23 bit
        // prediction (ICM) or a pair of 20 bit signed weights (ISSE).
        // cxt = bit history bh (0..255) is in edx.
        if (cp[0]==ICM) {
          put3(0x8b0496);                      // mov eax, [esi+edx*4];cm[bh]
          put3(0xc1e808);                      // shr eax, 8
          put4a(0x0fbf8447, off(stretcht));    // movsx eax,word[edi+eax*2+..]
        }
        else {  // ISSE
          put2a(0x8b87, off(p[cp[2]]));        // mov eax, [edi+&p[j]]
          put4(0x0faf04d6);                    // imul eax, [esi+edx*8] ;wt[0]
          put4(0x8b4cd604);                    // mov ecx, [esi+edx*8+4];wt[1]
          put3(0xc1e106);                      // shl ecx, 6
          put2(0x01c8);                        // add eax, ecx
          put3(0xc1f810);                      // sar eax, 16
          put1a(0xb9, 2047);                   // mov ecx, 2047
          put2(0x39c8);                        // cmp eax, ecx
          put3(0x0f4fc1);                      // cmovg eax, ecx
          put1a(0xb9, -2048);                  // mov ecx, -2048
          put2(0x39c8);                        // cmp eax, ecx
          put3(0x0f4cc1);                      // cmovl eax, ecx
        }
        put2a(0x8987, off(p[i]));              // mov [edi+&p[i]], eax
        break;
      case MATCH: // sizebits bufbits: a=len, b=offset, c=bit, cxt=bitpos,
                  //                   ht=buf, limit=pos
        // assert(cr.cm.size()==(size_t(1)<<cp[1]));
        // assert(cr.ht.size()==(size_t(1)<<cp[2]));
        // assert(cr.a<=255);
        // assert(cr.c==0 || cr.c==1);
        // assert(cr.cxt<8);
        // assert(cr.limit<cr.ht.size());
        // if (cr.a==0) p[i]=0;
        // else {
        //   cr.c=(cr.ht(cr.limit-cr.b)>>(7-cr.cxt))&1; // predicted bit
        //   p[i]=stretch(dt2k[cr.a]*(cr.c*-2+1)&32767);
        // }
        if (S==8) put1(0x48);          // rex.w
        put2a(0x8bb7, offc(ht));       // mov esi, [edi+&ht]
        // If match length (a) is 0 then p[i]=0
        put2a(0x8b87, offc(a));        // mov eax, [edi+&a]
        put2(0x85c0);                  // test eax, eax
        put2(0x7449);                  // jz L2 ; p[i]=0
        // Else put predicted bit in c
        put1a(0xb9, 7);                // mov ecx, 7
        put2a(0x2b8f, offc(cxt));      // sub ecx, [edi+&cxt]
        put2a(0x8b87, offc(limit));    // mov eax, [edi+&limit]
        put2a(0x2b87, offc(b));        // sub eax, [edi+&b]
        put1a(0x25, (1<<cp[2])-1);     // and eax, ht.size()-1
        put4(0x0fb60406);              // movzx eax, byte [esi+eax]
        put2(0xd3e8);                  // shr eax, cl
        put3(0x83e001);                // and eax, 1  ; predicted bit
        put2a(0x8987, offc(c));        // mov [edi+&c], eax ; c
        // p[i]=stretch(dt2k[cr.a]*(cr.c*-2+1)&32767);
        put2a(0x8b87, offc(a));        // mov eax, [edi+&a]
        put3a(0x8b8487, off(dt2k));    // mov eax, [edi+eax*4+&dt2k] ; weight
        put2(0x7402);                  // jz L1 ; z if c==0
        put2(0xf7d8);                  // neg eax
        put1a(0x25, 0x7fff);           // L1: and eax, 32767
        put4a(0x0fbf8447, off(stretcht)); //movsx eax, word [edi+eax*2+...]
        put2a(0x8987, off(p[i]));      // L2: mov [edi+&p[i]], eax
        break;
      case AVG: // j k wt
        // p[i]=(p[cp[1]]*cp[3]+p[cp[2]]*(256-cp[3]))>>8;
        put2a(0x8b87, off(p[cp[1]]));  // mov eax, [edi+&p[j]]
        put2a(0x2b87, off(p[cp[2]]));  // sub eax, [edi+&p[k]]
        put2a(0x69c0, cp[3]);          // imul eax, wt
        put3(0xc1f808);                // sar eax, 8
        put2a(0x0387, off(p[cp[2]]));  // add eax, [edi+&p[k]]
        put2a(0x8987, off(p[i]));      // mov [edi+&p[i]], eax
        break;
      case MIX2:   // sizebits j k rate mask
                   // c=size cm=wt[size] cxt=input
        // cr.cxt=((h[i]+(c8&cp[5]))&(cr.c-1));
        // assert(cr.cxt<cr.a16.size());
        // int w=cr.a16[cr.cxt];
        // assert(w>=0 && w<65536);
        // p[i]=(w*p[cp[2]]+(65536-w)*p[cp[3]])>>16;
        // assert(p[i]>=-2048 && p[i]<2048);
        put2(0x8b07);                  // mov eax, [edi] ; c8
        put1a(0x25, cp[5]);            // and eax, mask
        put2a(0x0387, off(h[i]));      // add eax, [edi+&h[i]]
        put1a(0x25, (1<<cp[1])-1);     // and eax, size-1
        put2a(0x8987, offc(cxt));      // mov [edi+&cxt], eax ; cxt
        if (S==8) put1(0x48);          // rex.w
        put2a(0x8bb7, offc(a16));      // mov esi, [edi+&a16]
        put4(0x0fb70446);              // movzx eax, word [edi+eax*2] ; w
        put2a(0x8b8f, off(p[cp[2]]));  // mov ecx, [edi+&p[j]]
        put2a(0x8b97, off(p[cp[3]]));  // mov edx, [edi+&p[k]]
        put2(0x29d1);                  // sub ecx, edx
        put3(0x0fafc8);                // imul ecx, eax
        put3(0xc1e210);                // shl edx, 16
        put2(0x01d1);                  // add ecx, edx
        put3(0xc1f910);                // sar ecx, 16
        put2a(0x898f, off(p[i]));      // mov [edi+&p[i]]
        break;
      case MIX:    // sizebits j m rate mask
                   // c=size cm=wt[size][m] cxt=index of wt in cm
        // int m=cp[3];
        // assert(m>=1 && m<=i);
        // cr.cxt=h[i]+(c8&cp[5]);
        // cr.cxt=(cr.cxt&(cr.c-1))*m; // pointer to row of weights
        // assert(cr.cxt<=cr.cm.size()-m);
        // int* wt=(int*)&cr.cm[cr.cxt];
        // p[i]=0;
        // for (int j=0; j<m; ++j)
        //   p[i]+=(wt[j]>>8)*p[cp[2]+j];
        // p[i]=clamp2k(p[i]>>8);
        put2(0x8b07);                          // mov eax, [edi] ; c8
        put1a(0x25, cp[5]);                    // and eax, mask
        put2a(0x0387, off(h[i]));              // add eax, [edi+&h[i]]
        put1a(0x25, (1<<cp[1])-1);             // and eax, size-1
        put2a(0x69c0, cp[3]);                  // imul eax, m
        put2a(0x8987, offc(cxt));              // mov [edi+&cxt], eax ; cxt
        if (S==8) put1(0x48);                  // rex.w
        put2a(0x8bb7, offc(cm));               // mov esi, [edi+&cm]
        if (S==8) put1(0x48);                  // rex.w
        put3(0x8d3486);                        // lea esi, [esi+eax*4] ; wt
        // Unroll summation loop: esi=wt[0..m-1]
        for (int k=0; k<cp[3]; k+=8) {
          const int tail=cp[3]-k;  // number of elements remaining
          // pack 8 elements of wt in xmm1, 8 elements of p in xmm3
          put4a(0xf30f6f8e, k*4);              // movdqu xmm1, [esi+k*4]
          if (tail>3) put4a(0xf30f6f96, k*4+16);//movdqu xmm2, [esi+k*4+16]
          put5(0x660f72e1,0x08);               // psrad xmm1, 8
          if (tail>3) put5(0x660f72e2,0x08);   // psrad xmm2, 8
          put4(0x660f6bca);                    // packssdw xmm1, xmm2
          put4a(0xf30f6f9f, off(p[cp[2]+k]));  // movdqu xmm3, [edi+&p[j+k]]
          if (tail>3)
            put4a(0xf30f6fa7,off(p[cp[2]+k+4]));//movdqu xmm4, [edi+&p[j+k+4]]
          put4(0x660f6bdc);                    // packssdw, xmm3, xmm4
          if (tail>0 && tail<8) {  // last loop, mask extra weights
            put4(0x660f76ed);                  // pcmpeqd xmm5, xmm5 ; -1
            put5(0x660f73dd, 16-tail*2);       // psrldq xmm5, 16-tail*2
            put4(0x660fdbcd);                  // pand xmm1, xmm5
          }
          if (k==0) {  // first loop, initialize sum in xmm0
            put4(0xf30f6fc1);                  // movdqu xmm0, xmm1
            put4(0x660ff5c3);                  // pmaddwd xmm0, xmm3
          }
          else {  // accumulate sum in xmm0
            put4(0x660ff5cb);                  // pmaddwd xmm1, xmm3
            put4(0x660ffec1);                  // paddd xmm0, xmm1
          }
        }
        // Add up the 4 elements of xmm0 = p[i] in the first element
        put4(0xf30f6fc8);                      // movdqu xmm1, xmm0
        put5(0x660f73d9,0x08);                 // psrldq xmm1, 8
        put4(0x660ffec1);                      // paddd xmm0, xmm1
        put4(0xf30f6fc8);                      // movdqu xmm1, xmm0
        put5(0x660f73d9,0x04);                 // psrldq xmm1, 4
        put4(0x660ffec1);                      // paddd xmm0, xmm1
        put4(0x660f7ec0);                      // movd eax, xmm0 ; p[i]
        put3(0xc1f808);                        // sar eax, 8
        put1a(0x3d, 2047);                     // cmp eax, 2047
        put2(0x7e05);                          // jle L1
        put1a(0xb8, 2047);                     // mov eax, 2047
        put1a(0x3d, -2048);                    // L1: cmp eax, -2048
        put2(0x7d05);                          // jge, L2
        put1a(0xb8, -2048);                    // mov eax, -2048
        put2a(0x8987, off(p[i]));              // L2: mov [edi+&p[i]], eax
        break;
      case SSE:  // sizebits j start limit
        // cr.cxt=(h[i]+c8)*32;
        // int pq=p[cp[2]]+992;
        // if (pq<0) pq=0;
        // if (pq>1983) pq=1983;
        // int wt=pq&63;
        // pq>>=6;
        // assert(pq>=0 && pq<=30);
        // cr.cxt+=pq;
        // p[i]=stretch(((cr.cm(cr.cxt)>>10)*(64-wt)       // p0
        //               +(cr.cm(cr.cxt+1)>>10)*wt)>>13);  // p1
        // // p = p0*(64-wt)+p1*wt = (p1-p0)*wt + p0*64
        // cr.cxt+=wt>>5;
        put2a(0x8b8f, off(h[i]));      // mov ecx, [edi+&h[i]]
        put2(0x030f);                  // add ecx, [edi]  ; c0
        put2a(0x81e1, (1<<cp[1])-1);   // and ecx, size-1
        put3(0xc1e105);                // shl ecx, 5  ; cxt in 0..size*32-32
        put2a(0x8b87, off(p[cp[2]]));  // mov eax, [edi+&p[j]] ; pq
        put1a(0x05, 992);              // add eax, 992
        put2(0x31d2);                  // xor edx, edx ; 0
        put2(0x39d0);                  // cmp eax, edx
        put3(0x0f4cc2);                // cmovl eax, edx
        put1a(0xba, 1983);             // mov edx, 1983
        put2(0x39d0);                  // cmp eax, edx
        put3(0x0f4fc2);                // cmovg eax, edx ; pq in 0..1983
        put2(0x89c2);                  // mov edx, eax
        put3(0x83e23f);                // and edx, 63  ; wt in 0..63
        put3(0xc1e806);                // shr eax, 6   ; pq in 0..30
        put2(0x01c1);                  // add ecx, eax ; cxt in 0..size*32-2
        if (S==8) put1(0x48);          // rex.w
        put2a(0x8bb7, offc(cm));       // mov esi, [edi+cm]
        put3(0x8b048e);                // mov eax, [esi+ecx*4] ; cm[cxt]
        put4(0x8b5c8e04);              // mov ebx, [esi+ecx*4+4] ; cm[cxt+1]
        put3(0x83fa20);                // cmp edx, 32  ; wt
        put3(0x83d9ff);                // sbb ecx, -1  ; cxt+=wt>>5
        put2a(0x898f, offc(cxt));      // mov [edi+cxt], ecx  ; cxt saved
        put3(0xc1e80a);                // shr eax, 10 ; p0 = cm[cxt]>>10
        put3(0xc1eb0a);                // shr ebx, 10 ; p1 = cm[cxt+1]>>10
        put2(0x29c3);                  // sub ebx, eax, ; p1-p0
        put3(0x0fafda);                // imul ebx, edx ; (p1-p0)*wt
        put3(0xc1e006);                // shr eax, 6
        put2(0x01d8);                  // add eax, ebx ; p in 0..2^28-1
        put3(0xc1e80d);                // shr eax, 13  ; p in 0..32767
        put4a(0x0fbf8447, off(stretcht));  // movsx eax, word [edi+eax*2+...]
        put2a(0x8987, off(p[i]));      // mov [edi+&p[i]], eax
        break;
      default:
        error("invalid ZPAQ component");
    }
  }
  // return squash(p[n-1])
  put2a(0x8b87, off(p[n-1]));          // mov eax, [edi+...]
  put1a(0x05, 0x800);                  // add eax, 2048
  put4a(0x0fbf8447, off(squasht[0]));  // movsx eax, word [edi+eax*2+...]
  put1(0x5f);                          // pop edi
  put1(0x5e);                          // pop esi
  put1(0x5d);                          // pop ebp
  put1(0x5b);                          // pop ebx
  put1(0xc3);                          // ret
  // Initialize for update() Put predictor address in edi/rdi
  // and bit y=0..1 in ebp
  int save_o=o;
  o=5;
  put1a(0xe9, save_o-10);      // jmp update
  o=save_o;
  put1(0x53);                  // push ebx/rbx
  put1(0x55);                  // push ebp/rbp
  put1(0x56);                  // push esi/rsi
  put1(0x57);                  // push edi/rdi
  if (S==4) {
    put4(0x8b7c2414);          // mov edi,[esp+0x14] ; (1st arg = pr)
    put4(0x8b6c2418);          // mov ebp,[esp+0x18] ; (2nd arg = y)
  }
  else {
#if defined(unix) && !defined(__CYGWIN__)  // (1st arg already in rdi)
    put3(0x4889f5);            // mov rbp, rsi (2nd arg in Linux-64)
#else
    put3(0x4889cf);            // mov rdi, rcx (1st arg in Win64)
    put3(0x4889d5);            // mov rbp, rdx (2nd arg)
#endif // corresponds to #if (#if defined(unix) && !defined(__CYGWIN__)  // (1st arg already in rdi))
  }
  // Code update() for each component
  cp=hcomp+7;
  for (int i=0; i<n; ++i, cp+=compsize[cp[0]]) {
    assert(cp-hcomp<pr.z.cend);
    assert (cp[0]>=1 && cp[0]<=9);
    assert(compsize[cp[0]]>0 && compsize[cp[0]]<8);
    switch (cp[0]) {
      case CONS:  // c
        break;
      case SSE:  // sizebits j start limit
      case CM:   // sizebits limit
        // train(cr, y);
        //
        // reduce prediction error in cr.cm
        // void train(Component& cr, int y) {
        //   assert(y==0 || y==1);
        //   U32& pn=cr.cm(cr.cxt);
        //   U32 count=pn&0x3ff;
        //   int error=y*32767-(cr.cm(cr.cxt)>>17);
        //   pn+=(error*dt[count]&-1024)+(count<cr.limit);
        if (S==8) put1(0x48);          // rex.w (esi->rsi)
        put2a(0x8bb7, offc(cm));       // mov esi,[edi+cm]  ; cm
        put2a(0x8b87, offc(cxt));      // mov eax,[edi+cxt] ; cxt
        put1a(0x25, pr.comp[i].cm.size()-1);  // and eax, size-1
        if (S==8) put1(0x48);          // rex.w
        put3(0x8d3486);                // lea esi,[esi+eax*4] ; &cm[cxt]
        put2(0x8b06);                  // mov eax,[esi] ; cm[cxt]
        put2(0x89c2);                  // mov edx, eax  ; cm[cxt]
        put3(0xc1e811);                // shr eax, 17   ; cm[cxt]>>17
        put2(0x89e9);                  // mov ecx, ebp  ; y
        put3(0xc1e10f);                // shl ecx, 15   ; y*32768
        put2(0x29e9);                  // sub ecx, ebp  ; y*32767
        put2(0x29c1);                  // sub ecx, eax  ; error
        put2a(0x81e2, 0x3ff);          // and edx, 1023 ; count
        put3a(0x8b8497, off(dt));      // mov eax,[edi+edx*4+dt] ; dt[count]
        put3(0x0fafc8);                // imul ecx, eax ; error*dt[count]
        put2a(0x81e1, 0xfffffc00);     // and ecx, -1024
        put2a(0x81fa, cp[2+2*(cp[0]==SSE)]*4); // cmp edx, limit*4
        put2(0x110e);                  // adc [esi], ecx ; pn+=...
        break;
      case ICM:   // sizebits: cxt=bh, ht[c][0..15]=bh row
        // cr.ht[cr.c+(hmap4&15)]=st.next(cr.ht[cr.c+(hmap4&15)], y);
        // U32& pn=cr.cm(cr.cxt);
        // pn+=int(y*32767-(pn>>8))>>2;
      case ISSE:  // sizebits j  -- c=hi, cxt=bh
        // assert(cr.cxt==cr.ht[cr.c+(hmap4&15)]);
        // int err=y*32767-squash(p[i]);
        // int *wt=(int*)&cr.cm[cr.cxt*2];
        // wt[0]=clamp512k(wt[0]+((err*p[cp[2]]+(1<<12))>>13));
        // wt[1]=clamp512k(wt[1]+((err+16)>>5));
        // cr.ht[cr.c+(hmap4&15)]=st.next(cr.cxt, y);
        // update bit history bh to next(bh,y=ebp) in ht[c+(hmap4&15)]
        put3(0x8b4700+off(hmap4));     // mov eax, [edi+&hmap4]
        put3(0x83e00f);                // and eax, 15
        put2a(0x0387, offc(c));        // add eax [edi+&c] ; cxt
        if (S==8) put1(0x48);          // rex.w
        put2a(0x8bb7, offc(ht));       // mov esi, [edi+&ht]
        put4(0x0fb61406);              // movzx edx, byte [esi+eax] ; bh
        put4(0x8d5c9500);              // lea ebx, [ebp+edx*4] ; index to st
        put4a(0x0fb69c1f, off(st));    // movzx ebx,byte[edi+ebx+st]; next bh
        put3(0x881c06);                // mov [esi+eax], bl ; save next bh
        if (S==8) put1(0x48);          // rex.w
        put2a(0x8bb7, offc(cm));       // mov esi, [edi+&cm]
        // ICM: update cm[cxt=edx=bit history] to reduce prediction error
        // esi = &cm
        if (cp[0]==ICM) {
          if (S==8) put1(0x48);        // rex.w
          put3(0x8d3496);              // lea esi, [esi+edx*4] ; &cm[bh]
          put2(0x8b06);                // mov eax, [esi] ; pn
          put3(0xc1e808);              // shr eax, 8 ; pn>>8
          put2(0x89e9);                // mov ecx, ebp ; y
          put3(0xc1e10f);              // shl ecx, 15
          put2(0x29e9);                // sub ecx, ebp ; y*32767
          put2(0x29c1);                // sub ecx, eax
          put3(0xc1f902);              // sar ecx, 2
          put2(0x010e);                // add [esi], ecx
        }
        // ISSE: update weights. edx=cxt=bit history (0..255), esi=cm[512]
        else {
          put2a(0x8b87, off(p[i]));    // mov eax, [edi+&p[i]]
          put1a(0x05, 2048);           // add eax, 2048
          put4a(0x0fb78447, off(squasht)); // movzx eax, word [edi+eax*2+..]
          put2(0x89e9);                // mov ecx, ebp ; y
          put3(0xc1e10f);              // shl ecx, 15
          put2(0x29e9);                // sub ecx, ebp ; y*32767
          put2(0x29c1);                // sub ecx, eax ; err
          put2a(0x8b87, off(p[cp[2]]));// mov eax, [edi+&p[j]]
          put3(0x0fafc1);              // imul eax, ecx
          put1a(0x05, (1<<12));        // add eax, 4096
          put3(0xc1f80d);              // sar eax, 13
          put3(0x0304d6);              // add eax, [esi+edx*8] ; wt[0]
          put1a(0x3d, (1<<19)-1);      // cmp eax, (1<<19)-1
          put2(0x7e05);                // jle L1
          put1a(0xb8, (1<<19)-1);      // mov eax, (1<<19)-1
          put1a(0x3d, 0xfff80000);     // cmp eax, -1<<19
          put2(0x7d05);                // jge L2
          put1a(0xb8, 0xfff80000);     // mov eax, -1<<19
          put3(0x8904d6);              // L2: mov [esi+edx*8], eax
          put3(0x83c110);              // add ecx, 16 ; err
          put3(0xc1f905);              // sar ecx, 5
          put4(0x034cd604);            // add ecx, [esi+edx*8+4] ; wt[1]
          put2a(0x81f9, (1<<19)-1);    // cmp ecx, (1<<19)-1
          put2(0x7e05);                // jle L3
          put1a(0xb9, (1<<19)-1);      // mov ecx, (1<<19)-1
          put2a(0x81f9, 0xfff80000);   // cmp ecx, -1<<19
          put2(0x7d05);                // jge L4
          put1a(0xb9, 0xfff80000);     // mov ecx, -1<<19
          put4(0x894cd604);            // L4: mov [esi+edx*8+4], ecx
        }
        break;
      case MATCH: // sizebits bufbits:
                  //   a=len, b=offset, c=bit, cm=index, cxt=bitpos
                  //   ht=buf, limit=pos
        // assert(cr.a<=255);
        // assert(cr.c==0 || cr.c==1);
        // assert(cr.cxt<8);
        // assert(cr.cm.size()==(size_t(1)<<cp[1]));
        // assert(cr.ht.size()==(size_t(1)<<cp[2]));
        // if (int(cr.c)!=y) cr.a=0;  // mismatch?
        // cr.ht(cr.limit)+=cr.ht(cr.limit)+y;
        // if (++cr.cxt==8) {
        //   cr.cxt=0;
        //   ++cr.limit;
        //   cr.limit&=(1<<cp[2])-1;
        //   if (cr.a==0) {  // look for a match
        //     cr.b=cr.limit-cr.cm(h[i]);
        //     if (cr.b&(cr.ht.size()-1))
        //       while (cr.a<255
        //              && cr.ht(cr.limit-cr.a-1)==cr.ht(cr.limit-cr.a-cr.b-1))
        //         ++cr.a;
        //   }
        //   else cr.a+=cr.a<255;
        //   cr.cm(h[i])=cr.limit;
        // }
        // Set pointers ebx=&cm, esi=&ht
        if (S==8) put1(0x48);          // rex.w
        put2a(0x8bb7, offc(ht));       // mov esi, [edi+&ht]
        if (S==8) put1(0x48);          // rex.w
        put2a(0x8b9f, offc(cm));       // mov ebx, [edi+&cm]
        // if (c!=y) a=0;
        put2a(0x8b87, offc(c));        // mov eax, [edi+&c]
        put2(0x39e8);                  // cmp eax, ebp ; y
        put2(0x7408);                  // jz L1
        put2(0x31c0);                  // xor eax, eax
        put2a(0x8987, offc(a));        // mov [edi+&a], eax
        // ht(limit)+=ht(limit)+y  (1E)
        put2a(0x8b87, offc(limit));    // mov eax, [edi+&limit]
        put4(0x0fb60c06);              // movzx, ecx, byte [esi+eax]
        put2(0x01c9);                  // add ecx, ecx
        put2(0x01e9);                  // add ecx, ebp
        put3(0x880c06);                // mov [esi+eax], cl
        // if (++cxt==8)
        put2a(0x8b87, offc(cxt));      // mov eax, [edi+&cxt]
        put2(0xffc0);                  // inc eax
        put3(0x83e007);                // and eax,byte +0x7
        put2a(0x8987, offc(cxt));      // mov [edi+&cxt],eax
        put2a(0x0f85, 0x9b);           // jnz L8
        // ++limit;
        // limit&=bufsize-1;
        put2a(0x8b87, offc(limit));    // mov eax,[edi+&limit]
        put2(0xffc0);                  // inc eax
        put1a(0x25, (1<<cp[2])-1);     // and eax, bufsize-1
        put2a(0x8987, offc(limit));    // mov [edi+&limit],eax
        // if (a==0)
        put2a(0x8b87, offc(a));        // mov eax, [edi+&a]
        put2(0x85c0);                  // test eax,eax
        put2(0x755c);                  // jnz L6
        //   b=limit-cm(h[i])
        put2a(0x8b8f, off(h[i]));      // mov ecx,[edi+h[i]]
        put2a(0x81e1, (1<<cp[1])-1);   // and ecx, size-1
        put2a(0x8b87, offc(limit));    // mov eax,[edi-&limit]
        put3(0x2b048b);                // sub eax,[ebx+ecx*4]
        put2a(0x8987, offc(b));        // mov [edi+&b],eax
        //   if (b&(bufsize-1))
        put1a(0xa9, (1<<cp[2])-1);     // test eax, bufsize-1
        put2(0x7448);                  // jz L7
        //      while (a<255 && ht(limit-a-1)==ht(limit-a-b-1)) ++a;
        put1(0x53);                    // push ebx
        put2a(0x8b9f, offc(limit));    // mov ebx,[edi+&limit]
        put2(0x89da);                  // mov edx,ebx
        put2(0x29c3);                  // sub ebx,eax  ; limit-b
        put2(0x31c9);                  // xor ecx,ecx  ; a=0
        put2a(0x81f9, 0xff);           // L2: cmp ecx,0xff ; while
        put2(0x741c);                  // jz L3 ; break
        put2(0xffca);                  // dec edx
        put2(0xffcb);                  // dec ebx
        put2a(0x81e2, (1<<cp[2])-1);   // and edx, bufsize-1
        put2a(0x81e3, (1<<cp[2])-1);   // and ebx, bufsize-1
        put3(0x8a0416);                // mov al,[esi+edx]
        put3(0x3a041e);                // cmp al,[esi+ebx]
        put2(0x7504);                  // jnz L3 ; break
        put2(0xffc1);                  // inc ecx
        put2(0xebdc);                  // jmp short L2 ; end while
        put1(0x5b);                    // L3: pop ebx
        put2a(0x898f, offc(a));        // mov [edi+&a],ecx
        put2(0xeb0e);                  // jmp short L7
        // a+=(a<255)
        put1a(0x3d, 0xff);             // L6: cmp eax, 0xff ; a
        put3(0x83d000);                // adc eax, 0
        put2a(0x8987, offc(a));        // mov [edi+&a],eax
        // cm(h[i])=limit
        put2a(0x8b87, off(h[i]));      // L7: mov eax,[edi+&h[i]]
        put1a(0x25, (1<<cp[1])-1);     // and eax, size-1
        put2a(0x8b8f, offc(limit));    // mov ecx,[edi+&limit]
        put3(0x890c83);                // mov [ebx+eax*4],ecx
                                       // L8:
        break;
      case AVG:  // j k wt
        break;
      case MIX2: // sizebits j k rate mask
                 // cm=wt[size], cxt=input
        // assert(cr.a16.size()==cr.c);
        // assert(cr.cxt<cr.a16.size());
        // int err=(y*32767-squash(p[i]))*cp[4]>>5;
        // int w=cr.a16[cr.cxt];
        // w+=(err*(p[cp[2]]-p[cp[3]])+(1<<12))>>13;
        // if (w<0) w=0;
        // if (w>65535) w=65535;
        // cr.a16[cr.cxt]=w;
        // set ecx=err
        put2a(0x8b87, off(p[i]));      // mov eax, [edi+&p[i]]
        put1a(0x05, 2048);             // add eax, 2048
        put4a(0x0fb78447, off(squasht));//movzx eax, word [edi+eax*2+&squasht]
        put2(0x89e9);                  // mov ecx, ebp ; y
        put3(0xc1e10f);                // shl ecx, 15
        put2(0x29e9);                  // sub ecx, ebp ; y*32767
        put2(0x29c1);                  // sub ecx, eax
        put2a(0x69c9, cp[4]);          // imul ecx, rate
        put3(0xc1f905);                // sar ecx, 5  ; err
        // Update w
        put2a(0x8b87, offc(cxt));      // mov eax, [edi+&cxt]
        if (S==8) put1(0x48);          // rex.w
        put2a(0x8bb7, offc(a16));      // mov esi, [edi+&a16]
        if (S==8) put1(0x48);          // rex.w
        put3(0x8d3446);                // lea esi, [esi+eax*2] ; &w
        put2a(0x8b87, off(p[cp[2]]));  // mov eax, [edi+&p[j]]
        put2a(0x2b87, off(p[cp[3]]));  // sub eax, [edi+&p[k]] ; p[j]-p[k]
        put3(0x0fafc1);                // imul eax, ecx  ; * err
        put1a(0x05, 1<<12);            // add eax, 4096
        put3(0xc1f80d);                // sar eax, 13
        put3(0x0fb716);                // movzx edx, word [esi] ; w
        put2(0x01d0);                  // add eax, edx
        put1a(0xba, 0xffff);           // mov edx, 65535
        put2(0x39d0);                  // cmp eax, edx
        put3(0x0f4fc2);                // cmovg eax, edx
        put2(0x31d2);                  // xor edx, edx
        put2(0x39d0);                  // cmp eax, edx
        put3(0x0f4cc2);                // cmovl eax, edx
        put3(0x668906);                // mov word [esi], ax
        break;
      case MIX: // sizebits j m rate mask
                // cm=wt[size][m], cxt=input
        // int m=cp[3];
        // assert(m>0 && m<=i);
        // assert(cr.cm.size()==m*cr.c);
        // assert(cr.cxt+m<=cr.cm.size());
        // int err=(y*32767-squash(p[i]))*cp[4]>>4;
        // int* wt=(int*)&cr.cm[cr.cxt];
        // for (int j=0; j<m; ++j)
        //   wt[j]=clamp512k(wt[j]+((err*p[cp[2]+j]+(1<<12))>>13));
        // set ecx=err
        put2a(0x8b87, off(p[i]));      // mov eax, [edi+&p[i]]
        put1a(0x05, 2048);             // add eax, 2048
        put4a(0x0fb78447, off(squasht));//movzx eax, word [edi+eax*2+&squasht]
        put2(0x89e9);                  // mov ecx, ebp ; y
        put3(0xc1e10f);                // shl ecx, 15
        put2(0x29e9);                  // sub ecx, ebp ; y*32767
        put2(0x29c1);                  // sub ecx, eax
        put2a(0x69c9, cp[4]);          // imul ecx, rate
        put3(0xc1f904);                // sar ecx, 4  ; err
        // set esi=wt
        put2a(0x8b87, offc(cxt));      // mov eax, [edi+&cxt] ; cxt
        if (S==8) put1(0x48);          // rex.w
        put2a(0x8bb7, offc(cm));       // mov esi, [edi+&cm]
        if (S==8) put1(0x48);          // rex.w
        put3(0x8d3486);                // lea esi, [esi+eax*4] ; wt
        for (int k=0; k<cp[3]; ++k) {
          put2a(0x8b87,off(p[cp[2]+k]));//mov eax, [edi+&p[cp[2]+k]
          put3(0x0fafc1);              // imul eax, ecx
          put1a(0x05, 1<<12);          // add eax, 1<<12
          put3(0xc1f80d);              // sar eax, 13
          put2(0x0306);                // add eax, [esi]
          put1a(0x3d, (1<<19)-1);      // cmp eax, (1<<19)-1
          put2(0x7e05);                // jge L1
          put1a(0xb8, (1<<19)-1);      // mov eax, (1<<19)-1
          put1a(0x3d, 0xfff80000);     // cmp eax, -1<<19
          put2(0x7d05);                // jle L2
          put1a(0xb8, 0xfff80000);     // mov eax, -1<<19
          put2(0x8906);                // L2: mov [esi], eax
          if (k<cp[3]-1) {
            if (S==8) put1(0x48);      // rex.w
            put3(0x83c604);            // add esi, 4
          }
        }
        break;
      default:
        error("invalid ZPAQ component");
    }
  }
  // return from update()
  put1(0x5f);                 // pop edi
  put1(0x5e);                 // pop esi
  put1(0x5d);                 // pop ebp
  put1(0x5b);                 // pop ebx
  put1(0xc3);                 // ret
  return o;
}


// Return a prediction of the next bit in range 0..32767
// Use JIT code starting at pcode[0] if available, or else create it.
int Predictor::predict() {
	if (flagnojit)
		return predict0();
	
  if (!pcode) {
    allocx(pcode, pcode_size, (z.cend*100+4096)&-4096);
    int n=assemble_p();
    if (n>pcode_size) {
      allocx(pcode, pcode_size, n);
      n=assemble_p();
    }
    if (!pcode || n<15 || pcode_size<15)
      error("run JIT failed");
  }
  ///assert(pcode && pcode[0]);
  if (!(pcode && pcode[0]))
	  error("14367: pcode/pcode[0] kaputt\n");
  if (!pcode || !pcode[10]) 
    error("Invalid function pointer at pcode[10]");
 return ((int(*)(Predictor*))&pcode[10])(this);
}
// Update the model with bit y = 0..1
// Use the JIT code starting at pcode[5].
void Predictor::update(int y) {
	if (flagnojit)
	{
		update0(y);
		return;
	}
  assert(pcode && pcode[5]);
  ((void(*)(Predictor*, int))&pcode[5])(this, y);
  // Save bit y in c8, hmap4 (not implemented in JIT)
  c8+=c8+y;
  if (c8>=256) {
    z.run(c8-256);
    hmap4=1;
    c8=1;
    for (int i=0; i<z.header[6]; ++i) h[i]=z.H(i);
  }
  else if (c8>=16 && c8<32)
    hmap4=(hmap4&0xf)<<5|y<<4|1;
  else
    hmap4=(hmap4&0x1f0)|(((hmap4&0xf)*2+y)&0xf);
}
// Execute the ZPAQL code with input byte or -1 for EOF.
// Use JIT code at rcode if available, or else create it.
void ZPAQL::run(U32 input) {
	if (flagnojit)
	{
		run0(input);
		return;
	}
  if (!rcode) {
    allocx(rcode, rcode_size, (hend*10+4096)&-4096);
    int n=assemble();
    if (n>rcode_size) {
      allocx(rcode, rcode_size, n);
      n=assemble();
    }
    if (!rcode || n<10 || rcode_size<10)
      error("run JIT failed");
  }
  a=input;
  
   if (rcode && rcode[0]) 
   {
        const U32 rc = ((int(*)())(&rcode[0]))();
        if (rc == 0) return;
        else if (rc == 1) libzpaq::error("Bad ZPAQL opcode");
        else if (rc == 2) libzpaq::error("Out of memory");
        else if (rc == 3) libzpaq::error("Write error");
        else libzpaq::error("ZPAQL execution error");
    } 
	else 
	{
        libzpaq::error("14427 Invalid function pointer in rcode[0]");
    }
	/*
	
	
  const U32 rc=((int(*)())(&rcode[0]))();
  if (rc==0) return;
  else if (rc==1) libzpaq::error("Bad ZPAQL opcode");
  else if (rc==2) libzpaq::error("Out of memory");
  else if (rc==3) libzpaq::error("Write error");
  else libzpaq::error("ZPAQL execution error");
  */
}

/// LICENSE_START.6
////////////////////////// divsufsort ///////////////////////////////
/*
 * divsufsort.c for libdivsufsort-lite
 * Copyright (c) 2003-2008 Yuta Mori All Rights Reserved.
 Just a bit stripped
 */
#define INLINE_divsuf __inline
#if defined(ALPHABET_SIZE) && (ALPHABET_SIZE < 1)
# undef ALPHABET_SIZE
#endif // corresponds to #if (#if defined(ALPHABET_SIZE) && (ALPHABET_SIZE < 1))
#if !defined(ALPHABET_SIZE)
# define ALPHABET_SIZE (256)
#endif // corresponds to #if (#if !defined(ALPHABET_SIZE))
#define BUCKET_A_SIZE (ALPHABET_SIZE)
#define BUCKET_B_SIZE (ALPHABET_SIZE * ALPHABET_SIZE)
#if defined(SS_INSERTIONSORT_THRESHOLD)
# if SS_INSERTIONSORT_THRESHOLD < 1
#  undef SS_INSERTIONSORT_THRESHOLD
#  define SS_INSERTIONSORT_THRESHOLD (1)
# endif
#else
# define SS_INSERTIONSORT_THRESHOLD (8)
#endif // corresponds to #if (#if defined(SS_INSERTIONSORT_THRESHOLD))
#if defined(SS_BLOCKSIZE)
# if SS_BLOCKSIZE < 0
#  undef SS_BLOCKSIZE
#  define SS_BLOCKSIZE (0)
# elif 32768 <= SS_BLOCKSIZE
#  undef SS_BLOCKSIZE
#  define SS_BLOCKSIZE (32767)
# endif
#else
# define SS_BLOCKSIZE (1024)
#endif // corresponds to #if (#if defined(SS_BLOCKSIZE))
#if SS_BLOCKSIZE == 0
# define SS_MISORT_STACKSIZE (96)
#elif SS_BLOCKSIZE <= 4096
# define SS_MISORT_STACKSIZE (16)
#else
# define SS_MISORT_STACKSIZE (24)
#endif // corresponds to #if (#if SS_BLOCKSIZE == 0)
#define SS_SMERGE_STACKSIZE (32)
#define TR_INSERTIONSORT_THRESHOLD (8)
#define TR_STACKSIZE (64)
#ifndef SWAP
# define SWAP(_a, _b) do { t = (_a); (_a) = (_b); (_b) = t; } while(0)
#endif // corresponds to #ifndef (#ifndef SWAP)
#ifndef MIN
# define MIN(_a, _b) (((_a) < (_b)) ? (_a) : (_b))
#endif // corresponds to #ifndef (#ifndef MIN)
#ifndef MAX
# define MAX(_a, _b) (((_a) > (_b)) ? (_a) : (_b))
#endif // corresponds to #ifndef (#ifndef MAX)
#define STACK_PUSH(_a, _b, _c, _d)\
  do {\
    assert(ssize < STACK_SIZE);\
    stack[ssize].a = (_a), stack[ssize].b = (_b),\
    stack[ssize].c = (_c), stack[ssize++].d = (_d);\
  } while(0)
#define STACK_PUSH5(_a, _b, _c, _d, _e)\
  do {\
    assert(ssize < STACK_SIZE);\
    stack[ssize].a = (_a), stack[ssize].b = (_b),\
    stack[ssize].c = (_c), stack[ssize].d = (_d), stack[ssize++].e = (_e);\
  } while(0)
#define STACK_POP(_a, _b, _c, _d)\
  do {\
    assert(0 <= ssize);\
    if(ssize == 0) { return; }\
    (_a) = stack[--ssize].a, (_b) = stack[ssize].b,\
    (_c) = stack[ssize].c, (_d) = stack[ssize].d;\
  } while(0)
#define STACK_POP5(_a, _b, _c, _d, _e)\
  do {\
    assert(0 <= ssize);\
    if(ssize == 0) { return; }\
    (_a) = stack[--ssize].a, (_b) = stack[ssize].b,\
    (_c) = stack[ssize].c, (_d) = stack[ssize].d, (_e) = stack[ssize].e;\
  } while(0)
#define BUCKET_A(_c0) bucket_A[(_c0)]
#if ALPHABET_SIZE == 256
#define BUCKET_B(_c0, _c1) (bucket_B[((_c1) << 8) | (_c0)])
#define BUCKET_BSTAR(_c0, _c1) (bucket_B[((_c0) << 8) | (_c1)])
#else
#define BUCKET_B(_c0, _c1) (bucket_B[(_c1) * ALPHABET_SIZE + (_c0)])
#define BUCKET_BSTAR(_c0, _c1) (bucket_B[(_c0) * ALPHABET_SIZE + (_c1)])
#endif // corresponds to #if (#if ALPHABET_SIZE == 256)
static const int lg_table[256]= {
 -1,0,1,1,2,2,2,2,3,3,3,3,3,3,3,3,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,
  5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
  6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,
  6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,
  7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
  7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
  7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
  7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7
};
#if (SS_BLOCKSIZE == 0) || (SS_INSERTIONSORT_THRESHOLD < SS_BLOCKSIZE)
static INLINE_divsuf
int
ss_ilg(int n) {
#if SS_BLOCKSIZE == 0
  return (n & 0xffff0000) ?
          ((n & 0xff000000) ?
            24 + lg_table[(n >> 24) & 0xff] :
            16 + lg_table[(n >> 16) & 0xff]) :
          ((n & 0x0000ff00) ?
             8 + lg_table[(n >>  8) & 0xff] :
             0 + lg_table[(n >>  0) & 0xff]);
#elif SS_BLOCKSIZE < 256
  return lg_table[n];
#else
  return (n & 0xff00) ?
          8 + lg_table[(n >> 8) & 0xff] :
          0 + lg_table[(n >> 0) & 0xff];
#endif // corresponds to #if (#if SS_BLOCKSIZE == 0)
}
#endif /* (SS_BLOCKSIZE == 0) || (SS_INSERTIONSORT_THRESHOLD < SS_BLOCKSIZE) */ // corresponds to #if (#if (SS_BLOCKSIZE == 0) || (SS_INSERTIONSORT_THRESHOLD < SS_BLOCKSIZE))
#if SS_BLOCKSIZE != 0
static const int sqq_table[256] = {
  0,  16,  22,  27,  32,  35,  39,  42,  45,  48,  50,  53,  55,  57,  59,  61,
 64,  65,  67,  69,  71,  73,  75,  76,  78,  80,  81,  83,  84,  86,  87,  89,
 90,  91,  93,  94,  96,  97,  98,  99, 101, 102, 103, 104, 106, 107, 108, 109,
110, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126,
128, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142,
143, 144, 144, 145, 146, 147, 148, 149, 150, 150, 151, 152, 153, 154, 155, 155,
156, 157, 158, 159, 160, 160, 161, 162, 163, 163, 164, 165, 166, 167, 167, 168,
169, 170, 170, 171, 172, 173, 173, 174, 175, 176, 176, 177, 178, 178, 179, 180,
181, 181, 182, 183, 183, 184, 185, 185, 186, 187, 187, 188, 189, 189, 190, 191,
192, 192, 193, 193, 194, 195, 195, 196, 197, 197, 198, 199, 199, 200, 201, 201,
202, 203, 203, 204, 204, 205, 206, 206, 207, 208, 208, 209, 209, 210, 211, 211,
212, 212, 213, 214, 214, 215, 215, 216, 217, 217, 218, 218, 219, 219, 220, 221,
221, 222, 222, 223, 224, 224, 225, 225, 226, 226, 227, 227, 228, 229, 229, 230,
230, 231, 231, 232, 232, 233, 234, 234, 235, 235, 236, 236, 237, 237, 238, 238,
239, 240, 240, 241, 241, 242, 242, 243, 243, 244, 244, 245, 245, 246, 246, 247,
247, 248, 248, 249, 249, 250, 250, 251, 251, 252, 252, 253, 253, 254, 254, 255
};
static INLINE_divsuf
int
ss_isqrt(int x) {
  int y, e;
  if(x >= (SS_BLOCKSIZE * SS_BLOCKSIZE)) { return SS_BLOCKSIZE; }
  e = (x & 0xffff0000) ?
        ((x & 0xff000000) ?
          24 + lg_table[(x >> 24) & 0xff] :
          16 + lg_table[(x >> 16) & 0xff]) :
        ((x & 0x0000ff00) ?
           8 + lg_table[(x >>  8) & 0xff] :
           0 + lg_table[(x >>  0) & 0xff]);
  if(e >= 16) {
    y = sqq_table[x >> ((e - 6) - (e & 1))] << ((e >> 1) - 7);
    if(e >= 24) { y = (y + 1 + x / y) >> 1; }
    y = (y + 1 + x / y) >> 1;
  } else if(e >= 8) {
    y = (sqq_table[x >> ((e - 6) - (e & 1))] >> (7 - (e >> 1))) + 1;
  } else {
    return sqq_table[x] >> 4;
  }
  return (x < (y * y)) ? y - 1 : y;
}
#endif /* SS_BLOCKSIZE != 0 */ // corresponds to #if (#if SS_BLOCKSIZE != 0)
static INLINE_divsuf
int
ss_compare(const unsigned char *T,
           const int *p1, const int *p2,
           int depth) {
  const unsigned char *U1, *U2, *U1n, *U2n;
  for(U1 = T + depth + *p1,
      U2 = T + depth + *p2,
      U1n = T + *(p1 + 1) + 2,
      U2n = T + *(p2 + 1) + 2;
      (U1 < U1n) && (U2 < U2n) && (*U1 == *U2);
      ++U1, ++U2) {
  }
  return U1 < U1n ?
        (U2 < U2n ? *U1 - *U2 : 1) :
        (U2 < U2n ? -1 : 0);
}
#if (SS_BLOCKSIZE != 1) && (SS_INSERTIONSORT_THRESHOLD != 1)
static
void
ss_insertionsort(const unsigned char *T, const int *PA,
                 int *first, int *last, int depth) {
  int *i, *j;
  int t;
  int r;
  for(i = last - 2; first <= i; --i) {
    for(t = *i, j = i + 1; 0 < (r = ss_compare(T, PA + t, PA + *j, depth));) {
      do { *(j - 1) = *j; } while((++j < last) && (*j < 0));
      if(last <= j) { break; }
    }
    if(r == 0) { *j = ~*j; }
    *(j - 1) = t;
  }
}
#endif /* (SS_BLOCKSIZE != 1) && (SS_INSERTIONSORT_THRESHOLD != 1) */ // corresponds to #if (#if (SS_BLOCKSIZE != 1) && (SS_INSERTIONSORT_THRESHOLD != 1))
#if (SS_BLOCKSIZE == 0) || (SS_INSERTIONSORT_THRESHOLD < SS_BLOCKSIZE)
static INLINE_divsuf
void
ss_fixdown(const unsigned char *Td, const int *PA,
           int *SA, int i, int size) {
  int j, k;
  int v;
  int c, d, e;
  for(v = SA[i], c = Td[PA[v]]; (j = 2 * i + 1) < size; SA[i] = SA[k], i = k) {
    d = Td[PA[SA[k = j++]]];
    if(d < (e = Td[PA[SA[j]]])) { k = j; d = e; }
    if(d <= c) { break; }
  }
  SA[i] = v;
}
/* Simple top-down heapsort. */
static
void
ss_heapsort(const unsigned char *Td, const int *PA, int *SA, int size) {
  int i, m;
  int t;
  m = size;
  if((size % 2) == 0) {
    m--;
    if(Td[PA[SA[m / 2]]] < Td[PA[SA[m]]]) { SWAP(SA[m], SA[m / 2]); }
  }
  for(i = m / 2 - 1; 0 <= i; --i) { ss_fixdown(Td, PA, SA, i, m); }
  if((size % 2) == 0) { SWAP(SA[0], SA[m]); ss_fixdown(Td, PA, SA, 0, m); }
  for(i = m - 1; 0 < i; --i) {
    t = SA[0], SA[0] = SA[i];
    ss_fixdown(Td, PA, SA, 0, i);
    SA[i] = t;
  }
}
/* Returns the median of three elements. */
static INLINE_divsuf
int *
ss_median3(const unsigned char *Td, const int *PA,
           int *v1, int *v2, int *v3) {
  int *t;
  if(Td[PA[*v1]] > Td[PA[*v2]]) { SWAP(v1, v2); }
  if(Td[PA[*v2]] > Td[PA[*v3]]) {
    if(Td[PA[*v1]] > Td[PA[*v3]]) { return v1; }
    else { return v3; }
  }
  return v2;
}
/* Returns the median of five elements. */
static INLINE_divsuf
int *
ss_median5(const unsigned char *Td, const int *PA,
           int *v1, int *v2, int *v3, int *v4, int *v5) {
  int *t;
  if(Td[PA[*v2]] > Td[PA[*v3]]) { SWAP(v2, v3); }
  if(Td[PA[*v4]] > Td[PA[*v5]]) { SWAP(v4, v5); }
  if(Td[PA[*v2]] > Td[PA[*v4]]) { SWAP(v2, v4); SWAP(v3, v5); }
  if(Td[PA[*v1]] > Td[PA[*v3]]) { SWAP(v1, v3); }
  if(Td[PA[*v1]] > Td[PA[*v4]]) { SWAP(v1, v4); SWAP(v3, v5); }
  if(Td[PA[*v3]] > Td[PA[*v4]]) { return v4; }
  return v3;
}
/* Returns the pivot element. */
static INLINE_divsuf
int *
ss_pivot(const unsigned char *Td, const int *PA, int *first, int *last) {
  int *middle;
  int t;
  t = last - first;
  middle = first + t / 2;
  if(t <= 512) {
    if(t <= 32) {
      return ss_median3(Td, PA, first, middle, last - 1);
    } else {
      t >>= 2;
      return ss_median5(Td, PA, first, first + t, middle, last - 1 - t, last - 1);
    }
  }
  t >>= 3;
  first  = ss_median3(Td, PA, first, first + t, first + (t << 1));
  middle = ss_median3(Td, PA, middle - t, middle, middle + t);
  last   = ss_median3(Td, PA, last - 1 - (t << 1), last - 1 - t, last - 1);
  return ss_median3(Td, PA, first, middle, last);
}
/* Binary partition for substrings. */
static INLINE_divsuf
int *
ss_partition(const int *PA,
                    int *first, int *last, int depth) {
  int *a, *b;
  int t;
  for(a = first - 1, b = last;;) {
    for(; (++a < b) && ((PA[*a] + depth) >= (PA[*a + 1] + 1));) { *a = ~*a; }
    for(; (a < --b) && ((PA[*b] + depth) <  (PA[*b + 1] + 1));) { }
    if(b <= a) { break; }
    t = ~*b;
    *b = *a;
    *a = t;
  }
  if(first < a) { *first = ~*first; }
  return a;
}
/* Multikey introsort for medium size groups. */
static
void
ss_mintrosort(const unsigned char *T, const int *PA,
              int *first, int *last,
              int depth) {
#define STACK_SIZE SS_MISORT_STACKSIZE
  struct { int *a, *b, c; int d; } stack[STACK_SIZE];
  const unsigned char *Td;
  int *a, *b, *c, *d, *e, *f;
  int s, t;
  int ssize;
  int limit;
  int v, x = 0;
  for(ssize = 0, limit = ss_ilg(last - first);;) {
    if((last - first) <= SS_INSERTIONSORT_THRESHOLD) {
#if 1 < SS_INSERTIONSORT_THRESHOLD
      if(1 < (last - first)) { ss_insertionsort(T, PA, first, last, depth); }
#endif // corresponds to #if (#if 1 < SS_INSERTIONSORT_THRESHOLD)
      STACK_POP(first, last, depth, limit);
      continue;
    }
    Td = T + depth;
    if(limit-- == 0) { ss_heapsort(Td, PA, first, last - first); }
    if(limit < 0) {
      for(a = first + 1, v = Td[PA[*first]]; a < last; ++a) {
        if((x = Td[PA[*a]]) != v) {
          if(1 < (a - first)) { break; }
          v = x;
          first = a;
        }
      }
      if(Td[PA[*first] - 1] < v) {
        first = ss_partition(PA, first, a, depth);
      }
      if((a - first) <= (last - a)) {
        if(1 < (a - first)) {
          STACK_PUSH(a, last, depth, -1);
          last = a, depth += 1, limit = ss_ilg(a - first);
        } else {
          first = a, limit = -1;
        }
      } else {
        if(1 < (last - a)) {
          STACK_PUSH(first, a, depth + 1, ss_ilg(a - first));
          first = a, limit = -1;
        } else {
          last = a, depth += 1, limit = ss_ilg(a - first);
        }
      }
      continue;
    }
    /* choose pivot */
    a = ss_pivot(Td, PA, first, last);
    v = Td[PA[*a]];
    SWAP(*first, *a);
    /* partition */
    for(b = first; (++b < last) && ((x = Td[PA[*b]]) == v);) { }
    if(((a = b) < last) && (x < v)) {
      for(; (++b < last) && ((x = Td[PA[*b]]) <= v);) {
        if(x == v) { SWAP(*b, *a); ++a; }
      }
    }
    for(c = last; (b < --c) && ((x = Td[PA[*c]]) == v);) { }
    if((b < (d = c)) && (x > v)) {
      for(; (b < --c) && ((x = Td[PA[*c]]) >= v);) {
        if(x == v) { SWAP(*c, *d); --d; }
      }
    }
    for(; b < c;) {
      SWAP(*b, *c);
      for(; (++b < c) && ((x = Td[PA[*b]]) <= v);) {
        if(x == v) { SWAP(*b, *a); ++a; }
      }
      for(; (b < --c) && ((x = Td[PA[*c]]) >= v);) {
        if(x == v) { SWAP(*c, *d); --d; }
      }
    }
    if(a <= d) {
      c = b - 1;
      if((s = a - first) > (t = b - a)) { s = t; }
      for(e = first, f = b - s; 0 < s; --s, ++e, ++f) { SWAP(*e, *f); }
      if((s = d - c) > (t = last - d - 1)) { s = t; }
      for(e = b, f = last - s; 0 < s; --s, ++e, ++f) { SWAP(*e, *f); }
      a = first + (b - a), c = last - (d - c);
      b = (v <= Td[PA[*a] - 1]) ? a : ss_partition(PA, a, c, depth);
      if((a - first) <= (last - c)) {
        if((last - c) <= (c - b)) {
          STACK_PUSH(b, c, depth + 1, ss_ilg(c - b));
          STACK_PUSH(c, last, depth, limit);
          last = a;
        } else if((a - first) <= (c - b)) {
          STACK_PUSH(c, last, depth, limit);
          STACK_PUSH(b, c, depth + 1, ss_ilg(c - b));
          last = a;
        } else {
          STACK_PUSH(c, last, depth, limit);
          STACK_PUSH(first, a, depth, limit);
          first = b, last = c, depth += 1, limit = ss_ilg(c - b);
        }
      } else {
        if((a - first) <= (c - b)) {
          STACK_PUSH(b, c, depth + 1, ss_ilg(c - b));
          STACK_PUSH(first, a, depth, limit);
          first = c;
        } else if((last - c) <= (c - b)) {
          STACK_PUSH(first, a, depth, limit);
          STACK_PUSH(b, c, depth + 1, ss_ilg(c - b));
          first = c;
        } else {
          STACK_PUSH(first, a, depth, limit);
          STACK_PUSH(c, last, depth, limit);
          first = b, last = c, depth += 1, limit = ss_ilg(c - b);
        }
      }
    } else {
      limit += 1;
      if(Td[PA[*first] - 1] < v) {
        first = ss_partition(PA, first, last, depth);
        limit = ss_ilg(last - first);
      }
      depth += 1;
    }
  }
#undef STACK_SIZE
}
#endif /* (SS_BLOCKSIZE == 0) || (SS_INSERTIONSORT_THRESHOLD < SS_BLOCKSIZE) */ // corresponds to #if (#if (SS_BLOCKSIZE == 0) || (SS_INSERTIONSORT_THRESHOLD < SS_BLOCKSIZE))
#if SS_BLOCKSIZE != 0
static INLINE_divsuf
void
ss_blockswap(int *a, int *b, int n) {
  int t;
  for(; 0 < n; --n, ++a, ++b) {
    t = *a, *a = *b, *b = t;
  }
}
static INLINE_divsuf
void
ss_rotate(int *first, int *middle, int *last) {
  int *a, *b, t;
  int l, r;
  l = middle - first, r = last - middle;
  for(; (0 < l) && (0 < r);) {
    if(l == r) { ss_blockswap(first, middle, l); break; }
    if(l < r) {
      a = last - 1, b = middle - 1;
      t = *a;
      do {
        *a-- = *b, *b-- = *a;
        if(b < first) {
          *a = t;
          last = a;
          if((r -= l + 1) <= l) { break; }
          a -= 1, b = middle - 1;
          t = *a;
        }
      } while(1);
    } else {
      a = first, b = middle;
      t = *a;
      do {
        *a++ = *b, *b++ = *a;
        if(last <= b) {
          *a = t;
          first = a + 1;
          if((l -= r + 1) <= r) { break; }
          a += 1, b = middle;
          t = *a;
        }
      } while(1);
    }
  }
}
static
void
ss_inplacemerge(const unsigned char *T, const int *PA,
                int *first, int *middle, int *last,
                int depth) {
  const int *p;
  int *a, *b;
  int len, half;
  int q, r;
  int x;
  for(;;) {
    if(*(last - 1) < 0) { x = 1; p = PA + ~*(last - 1); }
    else                { x = 0; p = PA +  *(last - 1); }
    for(a = first, len = middle - first, half = len >> 1, r = -1;
        0 < len;
        len = half, half >>= 1) {
      b = a + half;
      q = ss_compare(T, PA + ((0 <= *b) ? *b : ~*b), p, depth);
      if(q < 0) {
        a = b + 1;
        half -= (len & 1) ^ 1;
      } else {
        r = q;
      }
    }
    if(a < middle) {
      if(r == 0) { *a = ~*a; }
      ss_rotate(a, middle, last);
      last -= middle - a;
      middle = a;
      if(first == middle) { break; }
    }
    --last;
    if(x != 0) { while(*--last < 0) { } }
    if(middle == last) { break; }
  }
}
/* Merge-forward with internal buffer. */
static
void
ss_mergeforward(const unsigned char *T, const int *PA,
                int *first, int *middle, int *last,
                int *buf, int depth) {
  int *a, *b, *c, *bufend;
  int t;
  int r;
  bufend = buf + (middle - first) - 1;
  ss_blockswap(buf, first, middle - first);
  for(t = *(a = first), b = buf, c = middle;;) {
    r = ss_compare(T, PA + *b, PA + *c, depth);
    if(r < 0) {
      do {
        *a++ = *b;
        if(bufend <= b) { *bufend = t; return; }
        *b++ = *a;
      } while(*b < 0);
    } else if(r > 0) {
      do {
        *a++ = *c, *c++ = *a;
        if(last <= c) {
          while(b < bufend) { *a++ = *b, *b++ = *a; }
          *a = *b, *b = t;
          return;
        }
      } while(*c < 0);
    } else {
      *c = ~*c;
      do {
        *a++ = *b;
        if(bufend <= b) { *bufend = t; return; }
        *b++ = *a;
      } while(*b < 0);
      do {
        *a++ = *c, *c++ = *a;
        if(last <= c) {
          while(b < bufend) { *a++ = *b, *b++ = *a; }
          *a = *b, *b = t;
          return;
        }
      } while(*c < 0);
    }
  }
}
/* Merge-backward with internal buffer. */
static
void
ss_mergebackward(const unsigned char *T, const int *PA,
                 int *first, int *middle, int *last,
                 int *buf, int depth) {
  const int *p1, *p2;
  int *a, *b, *c, *bufend;
  int t;
  int r;
  int x;
  bufend = buf + (last - middle) - 1;
  ss_blockswap(buf, middle, last - middle);
  x = 0;
  if(*bufend < 0)       { p1 = PA + ~*bufend; x |= 1; }
  else                  { p1 = PA +  *bufend; }
  if(*(middle - 1) < 0) { p2 = PA + ~*(middle - 1); x |= 2; }
  else                  { p2 = PA +  *(middle - 1); }
  for(t = *(a = last - 1), b = bufend, c = middle - 1;;) {
    r = ss_compare(T, p1, p2, depth);
    if(0 < r) {
      if(x & 1) { do { *a-- = *b, *b-- = *a; } while(*b < 0); x ^= 1; }
      *a-- = *b;
      if(b <= buf) { *buf = t; break; }
      *b-- = *a;
      if(*b < 0) { p1 = PA + ~*b; x |= 1; }
      else       { p1 = PA +  *b; }
    } else if(r < 0) {
      if(x & 2) { do { *a-- = *c, *c-- = *a; } while(*c < 0); x ^= 2; }
      *a-- = *c, *c-- = *a;
      if(c < first) {
        while(buf < b) { *a-- = *b, *b-- = *a; }
        *a = *b, *b = t;
        break;
      }
      if(*c < 0) { p2 = PA + ~*c; x |= 2; }
      else       { p2 = PA +  *c; }
    } else {
      if(x & 1) { do { *a-- = *b, *b-- = *a; } while(*b < 0); x ^= 1; }
      *a-- = ~*b;
      if(b <= buf) { *buf = t; break; }
      *b-- = *a;
      if(x & 2) { do { *a-- = *c, *c-- = *a; } while(*c < 0); x ^= 2; }
      *a-- = *c, *c-- = *a;
      if(c < first) {
        while(buf < b) { *a-- = *b, *b-- = *a; }
        *a = *b, *b = t;
        break;
      }
      if(*b < 0) { p1 = PA + ~*b; x |= 1; }
      else       { p1 = PA +  *b; }
      if(*c < 0) { p2 = PA + ~*c; x |= 2; }
      else       { p2 = PA +  *c; }
    }
  }
}
/* D&C based merge. */
static
void
ss_swapmerge(const unsigned char *T, const int *PA,
             int *first, int *middle, int *last,
             int *buf, int bufsize, int depth) {
#define STACK_SIZE SS_SMERGE_STACKSIZE
#define GETIDX(a) ((0 <= (a)) ? (a) : (~(a)))
#define MERGE_CHECK(a, b, c)\
  do {\
    if(((c) & 1) ||\
       (((c) & 2) && (ss_compare(T, PA + GETIDX(*((a) - 1)), PA + *(a), depth) == 0))) {\
      *(a) = ~*(a);\
    }\
    if(((c) & 4) && ((ss_compare(T, PA + GETIDX(*((b) - 1)), PA + *(b), depth) == 0))) {\
      *(b) = ~*(b);\
    }\
  } while(0)
  struct { int *a, *b, *c; int d; } stack[STACK_SIZE];
  int *l, *r, *lm, *rm;
  int m, len, half;
  int ssize;
  int check, next;
  for(check = 0, ssize = 0;;) {
    if((last - middle) <= bufsize) {
      if((first < middle) && (middle < last)) {
        ss_mergebackward(T, PA, first, middle, last, buf, depth);
      }
      MERGE_CHECK(first, last, check);
      STACK_POP(first, middle, last, check);
      continue;
    }
    if((middle - first) <= bufsize) {
      if(first < middle) {
        ss_mergeforward(T, PA, first, middle, last, buf, depth);
      }
      MERGE_CHECK(first, last, check);
      STACK_POP(first, middle, last, check);
      continue;
    }
    for(m = 0, len = MIN(middle - first, last - middle), half = len >> 1;
        0 < len;
        len = half, half >>= 1) {
      if(ss_compare(T, PA + GETIDX(*(middle + m + half)),
                       PA + GETIDX(*(middle - m - half - 1)), depth) < 0) {
        m += half + 1;
        half -= (len & 1) ^ 1;
      }
    }
    if(0 < m) {
      lm = middle - m, rm = middle + m;
      ss_blockswap(lm, middle, m);
      l = r = middle, next = 0;
      if(rm < last) {
        if(*rm < 0) {
          *rm = ~*rm;
          if(first < lm) { for(; *--l < 0;) { } next |= 4; }
          next |= 1;
        } else if(first < lm) {
          for(; *r < 0; ++r) { }
          next |= 2;
        }
      }
      if((l - first) <= (last - r)) {
        STACK_PUSH(r, rm, last, (next & 3) | (check & 4));
        middle = lm, last = l, check = (check & 3) | (next & 4);
      } else {
        if((next & 2) && (r == middle)) { next ^= 6; }
        STACK_PUSH(first, lm, l, (check & 3) | (next & 4));
        first = r, middle = rm, check = (next & 3) | (check & 4);
      }
    } else {
      if(ss_compare(T, PA + GETIDX(*(middle - 1)), PA + *middle, depth) == 0) {
        *middle = ~*middle;
      }
      MERGE_CHECK(first, last, check);
      STACK_POP(first, middle, last, check);
    }
  }
#undef STACK_SIZE
}
#endif /* SS_BLOCKSIZE != 0 */ // corresponds to #if (#if SS_BLOCKSIZE != 0)
/* Substring sort */
static
void
sssort(const unsigned char *T, const int *PA,
       int *first, int *last,
       int *buf, int bufsize,
       int depth, int n, int lastsuffix) {
  int *a;
#if SS_BLOCKSIZE != 0
  int *b, *middle, *curbuf;
  int j, k, curbufsize, limit;
#endif // corresponds to #if (#if SS_BLOCKSIZE != 0)
  int i;
  if(lastsuffix != 0) { ++first; }
#if SS_BLOCKSIZE == 0
  ss_mintrosort(T, PA, first, last, depth);
#else
  if((bufsize < SS_BLOCKSIZE) &&
      (bufsize < (last - first)) &&
      (bufsize < (limit = ss_isqrt(last - first)))) {
    if(SS_BLOCKSIZE < limit) { limit = SS_BLOCKSIZE; }
    buf = middle = last - limit, bufsize = limit;
  } else {
    middle = last, limit = 0;
  }
  for(a = first, i = 0; SS_BLOCKSIZE < (middle - a); a += SS_BLOCKSIZE, ++i) {
#if SS_INSERTIONSORT_THRESHOLD < SS_BLOCKSIZE
    ss_mintrosort(T, PA, a, a + SS_BLOCKSIZE, depth);
#elif 1 < SS_BLOCKSIZE
    ss_insertionsort(T, PA, a, a + SS_BLOCKSIZE, depth);
#endif // corresponds to #if (#if SS_INSERTIONSORT_THRESHOLD < SS_BLOCKSIZE)
    curbufsize = last - (a + SS_BLOCKSIZE);
    curbuf = a + SS_BLOCKSIZE;
    if(curbufsize <= bufsize) { curbufsize = bufsize, curbuf = buf; }
    for(b = a, k = SS_BLOCKSIZE, j = i; j & 1; b -= k, k <<= 1, j >>= 1) {
      ss_swapmerge(T, PA, b - k, b, b + k, curbuf, curbufsize, depth);
    }
  }
#if SS_INSERTIONSORT_THRESHOLD < SS_BLOCKSIZE
  ss_mintrosort(T, PA, a, middle, depth);
#elif 1 < SS_BLOCKSIZE
  ss_insertionsort(T, PA, a, middle, depth);
#endif // corresponds to #if (#if SS_INSERTIONSORT_THRESHOLD < SS_BLOCKSIZE)
  for(k = SS_BLOCKSIZE; i != 0; k <<= 1, i >>= 1) {
    if(i & 1) {
      ss_swapmerge(T, PA, a - k, a, middle, buf, bufsize, depth);
      a -= k;
    }
  }
  if(limit != 0) {
#if SS_INSERTIONSORT_THRESHOLD < SS_BLOCKSIZE
    ss_mintrosort(T, PA, middle, last, depth);
#elif 1 < SS_BLOCKSIZE
    ss_insertionsort(T, PA, middle, last, depth);
#endif // corresponds to #if (#if SS_INSERTIONSORT_THRESHOLD < SS_BLOCKSIZE)
    ss_inplacemerge(T, PA, first, middle, last, depth);
  }
#endif // corresponds to #if (#if SS_BLOCKSIZE == 0)
  if(lastsuffix != 0) {
    /* Insert last type B* suffix. */
    int PAi[2]; PAi[0] = PA[*(first - 1)], PAi[1] = n - 2;
    for(a = first, i = *(first - 1);
        (a < last) && ((*a < 0) || (0 < ss_compare(T, &(PAi[0]), PA + *a, depth)));
        ++a) {
      *(a - 1) = *a;
    }
    *(a - 1) = i;
  }
}
static INLINE_divsuf
int
tr_ilg(int n) {
  return (n & 0xffff0000) ?
          ((n & 0xff000000) ?
            24 + lg_table[(n >> 24) & 0xff] :
            16 + lg_table[(n >> 16) & 0xff]) :
          ((n & 0x0000ff00) ?
             8 + lg_table[(n >>  8) & 0xff] :
             0 + lg_table[(n >>  0) & 0xff]);
}
/* Simple insertionsort for small size groups. */
static
void
tr_insertionsort(const int *ISAd, int *first, int *last) {
  int *a, *b;
  int t, r;
  for(a = first + 1; a < last; ++a) {
    for(t = *a, b = a - 1; 0 > (r = ISAd[t] - ISAd[*b]);) {
      do { *(b + 1) = *b; } while((first <= --b) && (*b < 0));
      if(b < first) { break; }
    }
    if(r == 0) { *b = ~*b; }
    *(b + 1) = t;
  }
}
static INLINE_divsuf
void
tr_fixdown(const int *ISAd, int *SA, int i, int size) {
  int j, k;
  int v;
  int c, d, e;
  for(v = SA[i], c = ISAd[v]; (j = 2 * i + 1) < size; SA[i] = SA[k], i = k) {
    d = ISAd[SA[k = j++]];
    if(d < (e = ISAd[SA[j]])) { k = j; d = e; }
    if(d <= c) { break; }
  }
  SA[i] = v;
}
/* Simple top-down heapsort. */
static
void
tr_heapsort(const int *ISAd, int *SA, int size) {
  int i, m;
  int t;
  m = size;
  if((size % 2) == 0) {
    m--;
    if(ISAd[SA[m / 2]] < ISAd[SA[m]]) { SWAP(SA[m], SA[m / 2]); }
  }
  for(i = m / 2 - 1; 0 <= i; --i) { tr_fixdown(ISAd, SA, i, m); }
  if((size % 2) == 0) { SWAP(SA[0], SA[m]); tr_fixdown(ISAd, SA, 0, m); }
  for(i = m - 1; 0 < i; --i) {
    t = SA[0], SA[0] = SA[i];
    tr_fixdown(ISAd, SA, 0, i);
    SA[i] = t;
  }
}
/* Returns the median of three elements. */
static INLINE_divsuf
int *
tr_median3(const int *ISAd, int *v1, int *v2, int *v3) {
  int *t;
  if(ISAd[*v1] > ISAd[*v2]) { SWAP(v1, v2); }
  if(ISAd[*v2] > ISAd[*v3]) {
    if(ISAd[*v1] > ISAd[*v3]) { return v1; }
    else { return v3; }
  }
  return v2;
}
static INLINE_divsuf
int *
tr_median5(const int *ISAd,
           int *v1, int *v2, int *v3, int *v4, int *v5) {
  int *t;
  if(ISAd[*v2] > ISAd[*v3]) { SWAP(v2, v3); }
  if(ISAd[*v4] > ISAd[*v5]) { SWAP(v4, v5); }
  if(ISAd[*v2] > ISAd[*v4]) { SWAP(v2, v4); SWAP(v3, v5); }
  if(ISAd[*v1] > ISAd[*v3]) { SWAP(v1, v3); }
  if(ISAd[*v1] > ISAd[*v4]) { SWAP(v1, v4); SWAP(v3, v5); }
  if(ISAd[*v3] > ISAd[*v4]) { return v4; }
  return v3;
}
static INLINE_divsuf
int *
tr_pivot(const int *ISAd, int *first, int *last) {
  int *middle;
  int t;
  t = last - first;
  middle = first + t / 2;
  if(t <= 512) {
    if(t <= 32) {
      return tr_median3(ISAd, first, middle, last - 1);
    } else {
      t >>= 2;
      return tr_median5(ISAd, first, first + t, middle, last - 1 - t, last - 1);
    }
  }
  t >>= 3;
  first  = tr_median3(ISAd, first, first + t, first + (t << 1));
  middle = tr_median3(ISAd, middle - t, middle, middle + t);
  last   = tr_median3(ISAd, last - 1 - (t << 1), last - 1 - t, last - 1);
  return tr_median3(ISAd, first, middle, last);
}
typedef struct _trbudget_t trbudget_t;
struct _trbudget_t {
  int chance;
  int remain;
  int incval;
  int count;
};
static INLINE_divsuf
void
trbudget_init(trbudget_t *budget, int chance, int incval) {
  budget->chance = chance;
  budget->remain = budget->incval = incval;
}
static INLINE_divsuf
int
trbudget_check(trbudget_t *budget, int size) {
  if(size <= budget->remain) { budget->remain -= size; return 1; }
  if(budget->chance == 0) { budget->count += size; return 0; }
  budget->remain += budget->incval - size;
  budget->chance -= 1;
  return 1;
}
static INLINE_divsuf
void
tr_partition(const int *ISAd,
             int *first, int *middle, int *last,
             int **pa, int **pb, int v) {
  int *a, *b, *c, *d, *e, *f;
  int t, s;
  int x = 0;
  for(b = middle - 1; (++b < last) && ((x = ISAd[*b]) == v);) { }
  if(((a = b) < last) && (x < v)) {
    for(; (++b < last) && ((x = ISAd[*b]) <= v);) {
      if(x == v) { SWAP(*b, *a); ++a; }
    }
  }
  for(c = last; (b < --c) && ((x = ISAd[*c]) == v);) { }
  if((b < (d = c)) && (x > v)) {
    for(; (b < --c) && ((x = ISAd[*c]) >= v);) {
      if(x == v) { SWAP(*c, *d); --d; }
    }
  }
  for(; b < c;) {
    SWAP(*b, *c);
    for(; (++b < c) && ((x = ISAd[*b]) <= v);) {
      if(x == v) { SWAP(*b, *a); ++a; }
    }
    for(; (b < --c) && ((x = ISAd[*c]) >= v);) {
      if(x == v) { SWAP(*c, *d); --d; }
    }
  }
  if(a <= d) {
    c = b - 1;
    if((s = a - first) > (t = b - a)) { s = t; }
    for(e = first, f = b - s; 0 < s; --s, ++e, ++f) { SWAP(*e, *f); }
    if((s = d - c) > (t = last - d - 1)) { s = t; }
    for(e = b, f = last - s; 0 < s; --s, ++e, ++f) { SWAP(*e, *f); }
    first += (b - a), last -= (d - c);
  }
  *pa = first, *pb = last;
}
static
void
tr_copy(int *ISA, const int *SA,
        int *first, int *a, int *b, int *last,
        int depth) {
  /* sort suffixes of middle partition
     by using sorted order of suffixes of left and right partition. */
  int *c, *d, *e;
  int s, v;
  v = b - SA - 1;
  for(c = first, d = a - 1; c <= d; ++c) {
    if((0 <= (s = *c - depth)) && (ISA[s] == v)) {
      *++d = s;
      ISA[s] = d - SA;
    }
  }
  for(c = last - 1, e = d + 1, d = b; e < d; --c) {
    if((0 <= (s = *c - depth)) && (ISA[s] == v)) {
      *--d = s;
      ISA[s] = d - SA;
    }
  }
}
static
void
tr_partialcopy(int *ISA, const int *SA,
               int *first, int *a, int *b, int *last,
               int depth) {
  int *c, *d, *e;
  int s, v;
  int rank, lastrank, newrank = -1;
  v = b - SA - 1;
  lastrank = -1;
  for(c = first, d = a - 1; c <= d; ++c) {
    if((0 <= (s = *c - depth)) && (ISA[s] == v)) {
      *++d = s;
      rank = ISA[s + depth];
      if(lastrank != rank) { lastrank = rank; newrank = d - SA; }
      ISA[s] = newrank;
    }
  }
  lastrank = -1;
  for(e = d; first <= e; --e) {
    rank = ISA[*e];
    if(lastrank != rank) { lastrank = rank; newrank = e - SA; }
    if(newrank != rank) { ISA[*e] = newrank; }
  }
  lastrank = -1;
  for(c = last - 1, e = d + 1, d = b; e < d; --c) {
    if((0 <= (s = *c - depth)) && (ISA[s] == v)) {
      *--d = s;
      rank = ISA[s + depth];
      if(lastrank != rank) { lastrank = rank; newrank = d - SA; }
      ISA[s] = newrank;
    }
  }
}
static
void
tr_introsort(int *ISA, const int *ISAd,
             int *SA, int *first, int *last,
             trbudget_t *budget) {
#define STACK_SIZE TR_STACKSIZE
  struct { const int *a; int *b, *c; int d, e; }stack[STACK_SIZE];
  int *a, *b, *c;
  int t;
  int v, x = 0;
  int incr = ISAd - ISA;
  int limit, next;
  int ssize, trlink = -1;
  for(ssize = 0, limit = tr_ilg(last - first);;) {
    if(limit < 0) {
      if(limit == -1) {
        /* tandem repeat partition */
        tr_partition(ISAd - incr, first, first, last, &a, &b, last - SA - 1);
        /* update ranks */
        if(a < last) {
          for(c = first, v = a - SA - 1; c < a; ++c) { ISA[*c] = v; }
        }
        if(b < last) {
          for(c = a, v = b - SA - 1; c < b; ++c) { ISA[*c] = v; }
        }
        /* push */
        if(1 < (b - a)) {
          STACK_PUSH5(NULL, a, b, 0, 0);
          STACK_PUSH5(ISAd - incr, first, last, -2, trlink);
          trlink = ssize - 2;
        }
        if((a - first) <= (last - b)) {
          if(1 < (a - first)) {
            STACK_PUSH5(ISAd, b, last, tr_ilg(last - b), trlink);
            last = a, limit = tr_ilg(a - first);
          } else if(1 < (last - b)) {
            first = b, limit = tr_ilg(last - b);
          } else {
            STACK_POP5(ISAd, first, last, limit, trlink);
          }
        } else {
          if(1 < (last - b)) {
            STACK_PUSH5(ISAd, first, a, tr_ilg(a - first), trlink);
            first = b, limit = tr_ilg(last - b);
          } else if(1 < (a - first)) {
            last = a, limit = tr_ilg(a - first);
          } else {
            STACK_POP5(ISAd, first, last, limit, trlink);
          }
        }
      } else if(limit == -2) {
        /* tandem repeat copy */
        a = stack[--ssize].b, b = stack[ssize].c;
        if(stack[ssize].d == 0) {
          tr_copy(ISA, SA, first, a, b, last, ISAd - ISA);
        } else {
          if(0 <= trlink) { stack[trlink].d = -1; }
          tr_partialcopy(ISA, SA, first, a, b, last, ISAd - ISA);
        }
        STACK_POP5(ISAd, first, last, limit, trlink);
      } else {
        /* sorted partition */
        if(0 <= *first) {
          a = first;
          do { ISA[*a] = a - SA; } while((++a < last) && (0 <= *a));
          first = a;
        }
        if(first < last) {
          a = first; do { *a = ~*a; } while(*++a < 0);
          next = (ISA[*a] != ISAd[*a]) ? tr_ilg(a - first + 1) : -1;
          if(++a < last) { for(b = first, v = a - SA - 1; b < a; ++b) { ISA[*b] = v; } }
          /* push */
          if(trbudget_check(budget, a - first)) {
            if((a - first) <= (last - a)) {
              STACK_PUSH5(ISAd, a, last, -3, trlink);
              ISAd += incr, last = a, limit = next;
            } else {
              if(1 < (last - a)) {
                STACK_PUSH5(ISAd + incr, first, a, next, trlink);
                first = a, limit = -3;
              } else {
                ISAd += incr, last = a, limit = next;
              }
            }
          } else {
            if(0 <= trlink) { stack[trlink].d = -1; }
            if(1 < (last - a)) {
              first = a, limit = -3;
            } else {
              STACK_POP5(ISAd, first, last, limit, trlink);
            }
          }
        } else {
          STACK_POP5(ISAd, first, last, limit, trlink);
        }
      }
      continue;
    }
    if((last - first) <= TR_INSERTIONSORT_THRESHOLD) {
      tr_insertionsort(ISAd, first, last);
      limit = -3;
      continue;
    }
    if(limit-- == 0) {
      tr_heapsort(ISAd, first, last - first);
      for(a = last - 1; first < a; a = b) {
        for(x = ISAd[*a], b = a - 1; (first <= b) && (ISAd[*b] == x); --b) { *b = ~*b; }
      }
      limit = -3;
      continue;
    }
    /* choose pivot */
    a = tr_pivot(ISAd, first, last);
    SWAP(*first, *a);
    v = ISAd[*first];
    /* partition */
    tr_partition(ISAd, first, first + 1, last, &a, &b, v);
    if((last - first) != (b - a)) {
      next = (ISA[*a] != v) ? tr_ilg(b - a) : -1;
      /* update ranks */
      for(c = first, v = a - SA - 1; c < a; ++c) { ISA[*c] = v; }
      if(b < last) { for(c = a, v = b - SA - 1; c < b; ++c) { ISA[*c] = v; } }
      /* push */
      if((1 < (b - a)) && (trbudget_check(budget, b - a))) {
        if((a - first) <= (last - b)) {
          if((last - b) <= (b - a)) {
            if(1 < (a - first)) {
              STACK_PUSH5(ISAd + incr, a, b, next, trlink);
              STACK_PUSH5(ISAd, b, last, limit, trlink);
              last = a;
            } else if(1 < (last - b)) {
              STACK_PUSH5(ISAd + incr, a, b, next, trlink);
              first = b;
            } else {
              ISAd += incr, first = a, last = b, limit = next;
            }
          } else if((a - first) <= (b - a)) {
            if(1 < (a - first)) {
              STACK_PUSH5(ISAd, b, last, limit, trlink);
              STACK_PUSH5(ISAd + incr, a, b, next, trlink);
              last = a;
            } else {
              STACK_PUSH5(ISAd, b, last, limit, trlink);
              ISAd += incr, first = a, last = b, limit = next;
            }
          } else {
            STACK_PUSH5(ISAd, b, last, limit, trlink);
            STACK_PUSH5(ISAd, first, a, limit, trlink);
            ISAd += incr, first = a, last = b, limit = next;
          }
        } else {
          if((a - first) <= (b - a)) {
            if(1 < (last - b)) {
              STACK_PUSH5(ISAd + incr, a, b, next, trlink);
              STACK_PUSH5(ISAd, first, a, limit, trlink);
              first = b;
            } else if(1 < (a - first)) {
              STACK_PUSH5(ISAd + incr, a, b, next, trlink);
              last = a;
            } else {
              ISAd += incr, first = a, last = b, limit = next;
            }
          } else if((last - b) <= (b - a)) {
            if(1 < (last - b)) {
              STACK_PUSH5(ISAd, first, a, limit, trlink);
              STACK_PUSH5(ISAd + incr, a, b, next, trlink);
              first = b;
            } else {
              STACK_PUSH5(ISAd, first, a, limit, trlink);
              ISAd += incr, first = a, last = b, limit = next;
            }
          } else {
            STACK_PUSH5(ISAd, first, a, limit, trlink);
            STACK_PUSH5(ISAd, b, last, limit, trlink);
            ISAd += incr, first = a, last = b, limit = next;
          }
        }
      } else {
        if((1 < (b - a)) && (0 <= trlink)) { stack[trlink].d = -1; }
        if((a - first) <= (last - b)) {
          if(1 < (a - first)) {
            STACK_PUSH5(ISAd, b, last, limit, trlink);
            last = a;
          } else if(1 < (last - b)) {
            first = b;
          } else {
            STACK_POP5(ISAd, first, last, limit, trlink);
          }
        } else {
          if(1 < (last - b)) {
            STACK_PUSH5(ISAd, first, a, limit, trlink);
            first = b;
          } else if(1 < (a - first)) {
            last = a;
          } else {
            STACK_POP5(ISAd, first, last, limit, trlink);
          }
        }
      }
    } else {
      if(trbudget_check(budget, last - first)) {
        limit = tr_ilg(last - first), ISAd += incr;
      } else {
        if(0 <= trlink) { stack[trlink].d = -1; }
        STACK_POP5(ISAd, first, last, limit, trlink);
      }
    }
  }
#undef STACK_SIZE
}
/* Tandem repeat sort */
static
void
trsort(int *ISA, int *SA, int n, int depth) {
  int *ISAd;
  int *first, *last;
  trbudget_t budget;
  int t, skip, unsorted;
  trbudget_init(&budget, tr_ilg(n) * 2 / 3, n);
/*  trbudget_init(&budget, tr_ilg(n) * 3 / 4, n); */
  for(ISAd = ISA + depth; -n < *SA; ISAd += ISAd - ISA) {
    first = SA;
    skip = 0;
    unsorted = 0;
    do {
      if((t = *first) < 0) { first -= t; skip += t; }
      else {
        if(skip != 0) { *(first + skip) = skip; skip = 0; }
        last = SA + ISA[t] + 1;
        if(1 < (last - first)) {
          budget.count = 0;
          tr_introsort(ISA, ISAd, SA, first, last, &budget);
          if(budget.count != 0) { unsorted += budget.count; }
          else { skip = first - last; }
        } else if((last - first) == 1) {
          skip = -1;
        }
        first = last;
      }
    } while(first < (SA + n));
    if(skip != 0) { *(first + skip) = skip; }
    if(unsorted == 0) { break; }
  }
}
/* Sorts suffixes of type B*. */
static
int
sort_typeBstar(const unsigned char *T, int *SA,
               int *bucket_A, int *bucket_B,
               int n) {
  int *PAb, *ISAb, *buf;
  int i, j, k, t, m, bufsize;
  int c0, c1;
  /* Initialize bucket arrays. */
  for(i = 0; i < BUCKET_A_SIZE; ++i) { bucket_A[i] = 0; }
  for(i = 0; i < BUCKET_B_SIZE; ++i) { bucket_B[i] = 0; }
  /* Count the number of occurrences of the first one or two characters of each
     type A, B and B* suffix. Moreover, store the beginning position of all
     type B* suffixes into the array SA. */
  for(i = n - 1, m = n, c0 = T[n - 1]; 0 <= i;) {
    /* type A suffix. */
    do { ++BUCKET_A(c1 = c0); } while((0 <= --i) && ((c0 = T[i]) >= c1));
    if(0 <= i) {
      /* type B* suffix. */
      ++BUCKET_BSTAR(c0, c1);
      SA[--m] = i;
      /* type B suffix. */
      for(--i, c1 = c0; (0 <= i) && ((c0 = T[i]) <= c1); --i, c1 = c0) {
        ++BUCKET_B(c0, c1);
      }
    }
  }
  m = n - m;
/*
note:
  A type B* suffix is lexicographically smaller than a type B suffix that
  begins with the same first two characters.
*/
  /* Calculate the index of start/end point of each bucket. */
  for(c0 = 0, i = 0, j = 0; c0 < ALPHABET_SIZE; ++c0) {
    t = i + BUCKET_A(c0);
    BUCKET_A(c0) = i + j; /* start point */
    i = t + BUCKET_B(c0, c0);
    for(c1 = c0 + 1; c1 < ALPHABET_SIZE; ++c1) {
      j += BUCKET_BSTAR(c0, c1);
      BUCKET_BSTAR(c0, c1) = j; /* end point */
      i += BUCKET_B(c0, c1);
    }
  }
  if(0 < m) {
    /* Sort the type B* suffixes by their first two characters. */
    PAb = SA + n - m; ISAb = SA + m;
    for(i = m - 2; 0 <= i; --i) {
      t = PAb[i], c0 = T[t], c1 = T[t + 1];
      SA[--BUCKET_BSTAR(c0, c1)] = i;
    }
    t = PAb[m - 1], c0 = T[t], c1 = T[t + 1];
    SA[--BUCKET_BSTAR(c0, c1)] = m - 1;
    /* Sort the type B* substrings using sssort. */
    buf = SA + m, bufsize = n - (2 * m);
    for(c0 = ALPHABET_SIZE - 2, j = m; 0 < j; --c0) {
      for(c1 = ALPHABET_SIZE - 1; c0 < c1; j = i, --c1) {
        i = BUCKET_BSTAR(c0, c1);
        if(1 < (j - i)) {
          sssort(T, PAb, SA + i, SA + j,
                 buf, bufsize, 2, n, *(SA + i) == (m - 1));
        }
      }
    }
    /* Compute ranks of type B* substrings. */
    for(i = m - 1; 0 <= i; --i) {
      if(0 <= SA[i]) {
        j = i;
        do { ISAb[SA[i]] = i; } while((0 <= --i) && (0 <= SA[i]));
        SA[i + 1] = i - j;
        if(i <= 0) { break; }
      }
      j = i;
      do { ISAb[SA[i] = ~SA[i]] = j; } while(SA[--i] < 0);
      ISAb[SA[i]] = j;
    }
    /* Construct the inverse suffix array of type B* suffixes using trsort. */
    trsort(ISAb, SA, m, 1);
    /* Set the sorted order of tyoe B* suffixes. */
    for(i = n - 1, j = m, c0 = T[n - 1]; 0 <= i;) {
      for(--i, c1 = c0; (0 <= i) && ((c0 = T[i]) >= c1); --i, c1 = c0) { }
      if(0 <= i) {
        t = i;
        for(--i, c1 = c0; (0 <= i) && ((c0 = T[i]) <= c1); --i, c1 = c0) { }
        SA[ISAb[--j]] = ((t == 0) || (1 < (t - i))) ? t : ~t;
      }
    }
    /* Calculate the index of start/end point of each bucket. */
    BUCKET_B(ALPHABET_SIZE - 1, ALPHABET_SIZE - 1) = n; /* end point */
    for(c0 = ALPHABET_SIZE - 2, k = m - 1; 0 <= c0; --c0) {
      i = BUCKET_A(c0 + 1) - 1;
      for(c1 = ALPHABET_SIZE - 1; c0 < c1; --c1) {
        t = i - BUCKET_B(c0, c1);
        BUCKET_B(c0, c1) = i; /* end point */
        /* Move all type B* suffixes to the correct position. */
        for(i = t, j = BUCKET_BSTAR(c0, c1);
            j <= k;
            --i, --k) { SA[i] = SA[k]; }
      }
      BUCKET_BSTAR(c0, c0 + 1) = i - BUCKET_B(c0, c0) + 1; /* start point */
      BUCKET_B(c0, c0) = i; /* end point */
    }
  }
  return m;
}
/* Constructs the suffix array by using the sorted order of type B* suffixes. */
static
void
construct_SA(const unsigned char *T, int *SA,
             int *bucket_A, int *bucket_B,
             int n, int m) {
  int *i, *j, *k;
  int s;
  int c0, c1, c2;
  if(0 < m) {
    /* Construct the sorted order of type B suffixes by using
       the sorted order of type B* suffixes. */
    for(c1 = ALPHABET_SIZE - 2; 0 <= c1; --c1) {
      /* Scan the suffix array from right to left. */
      for(i = SA + BUCKET_BSTAR(c1, c1 + 1),
          j = SA + BUCKET_A(c1 + 1) - 1, k = NULL, c2 = -1;
          i <= j;
          --j) {
        if(0 < (s = *j)) {
          assert(T[s] == c1);
          assert(((s + 1) < n) && (T[s] <= T[s + 1]));
          assert(T[s - 1] <= T[s]);
          *j = ~s;
          c0 = T[--s];
          if((0 < s) && (T[s - 1] > c0)) { s = ~s; }
          if(c0 != c2) {
            if(0 <= c2) { BUCKET_B(c2, c1) = k - SA; }
            k = SA + BUCKET_B(c2 = c0, c1);
          }
          assert(k < j);
			if (k!=NULL)
			*k-- = s;
		else
		{
			myprintf("15845: k null!\n");
			exit(0);
		}
        } else {
          assert(((s == 0) && (T[s] == c1)) || (s < 0));
          *j = ~s;
        }
      }
    }
  }
  /* Construct the suffix array by using
     the sorted order of type B suffixes. */
  k = SA + BUCKET_A(c2 = T[n - 1]);
  *k++ = (T[n - 2] < c2) ? ~(n - 1) : (n - 1);
  /* Scan the suffix array from left to right. */
  for(i = SA, j = SA + n; i < j; ++i) {
    if(0 < (s = *i)) {
      assert(T[s - 1] >= T[s]);
      c0 = T[--s];
      if((s == 0) || (T[s - 1] < c0)) { s = ~s; }
      if(c0 != c2) {
        BUCKET_A(c2) = k - SA;
        k = SA + BUCKET_A(c2 = c0);
      }
      assert(i < k);
      *k++ = s;
    } else {
      assert(s < 0);
      *i = ~s;
    }
  }
}
/*- Function -*/
int
divsufsort(const unsigned char *T, int *SA, int n) {
  int *bucket_A, *bucket_B;
  int m;
  int err = 0;
  /* Check arguments. */
  if((T == NULL) || (SA == NULL) || (n < 0)) { return -1; }
  else if(n == 0) { return 0; }
  else if(n == 1) { SA[0] = 0; return 0; }
  else if(n == 2) { m = (T[0] < T[1]); SA[m ^ 1] = 0, SA[m] = 1; return 0; }
  bucket_A = (int *)franz_malloc(BUCKET_A_SIZE * sizeof(int));
  bucket_B = (int *)franz_malloc(BUCKET_B_SIZE * sizeof(int));
  
//	g_allocatedram+=BUCKET_A_SIZE * sizeof(int)+BUCKET_B_SIZE * sizeof(int);

  /* Suffixsort. */
  if((bucket_A != NULL) && (bucket_B != NULL)) {
    m = sort_typeBstar(T, SA, bucket_A, bucket_B, n);
    construct_SA(T, SA, bucket_A, bucket_B, n, m);
  } else {
    err = -2;
  }
  franz_free(bucket_B);
  franz_free(bucket_A);
  return err;
}
// End divsufsort.c
/// LICENSE_END.6


/////////////////////////////// add ///////////////////////////////////
// Convert non-negative decimal number x to string of at least n digits
std::string itos(int64_t x, int n=1) {
  assert(x>=0);
  assert(n>=0);
  std::string r;
  for (; x || n>0; x/=10, --n) r=std::string(1, '0'+x%10)+r;
  return r;
}
// E8E9 transform of buf[0..n-1] to improve compression of .exe and .dll.
// Patterns (E8|E9 xx xx xx 00|FF) at offset i replace the 3 middle
// bytes with x+i mod 2^24, LSB first, reading backward.
void e8e9(unsigned char* buf, int n) {
  for (int i=n-5; i>=0; --i) {
    if (((buf[i]&254)==0xe8) && ((buf[i+4]+1)&254)==0) {
      unsigned a=(buf[i+1]|buf[i+2]<<8|buf[i+3]<<16)+i;
      buf[i+1]=a;
      buf[i+2]=a>>8;
      buf[i+3]=a>>16;
    }
  }
}
// Encode inbuf to buf using LZ77. args are as follows:
// args[0] is log2 buffer size in MB.
// args[1] is level (1=var. length, 2=byte aligned lz77, 3=bwt) + 4 if E8E9.
// args[2] is the lz77 minimum match length and context order.
// args[3] is the lz77 higher context order to search first, or else 0.
// args[4] is the log2 hash bucket size (number of searches).
// args[5] is the log2 hash table size. If 21+args[0] then use a suffix array.
// args[6] is the secondary context look ahead
// sap is pointer to external suffix array of inbuf or 0. If supplied and
//   args[0]=5..7 then it is assumed that E8E9 was already applied to
//   both the input and sap and the input buffer is not modified.
class LZBuffer: public libzpaq::Reader {
  libzpaq::Array<unsigned> ht;// hash table, confirm in low bits, or SA+ISA
  const unsigned char* in;    // input pointer
  const int checkbits;        // hash confirmation size or lg(ISA size)
  const int level;            // 1=var length LZ77, 2=byte aligned LZ77, 3=BWT
  const unsigned htsize;      // size of hash table
  const unsigned n;           // input length
  unsigned i;                 // current location in in (0 <= i < n)
  const unsigned minMatch;    // minimum match length
  const unsigned minMatch2;   // second context order or 0 if not used
  const unsigned maxMatch;    // longest match length allowed
  const unsigned maxLiteral;  // longest literal length allowed
  const unsigned lookahead;   // second context look ahead
  unsigned h1, h2;            // low, high order context hashes of in[i..]
  const unsigned bucket;      // number of matches to search per hash - 1
  const unsigned shift1, shift2;  // how far to shift h1, h2 per hash
  const int minMatchBoth;     // max(minMatch, minMatch2)
  const unsigned rb;          // number of level 1 r bits in match code
  unsigned bits;              // pending output bits (level 1)
  unsigned nbits;             // number of bits in bits
  unsigned rpos, wpos;        // read, write pointers
  unsigned idx;               // BWT index
  const unsigned* sa;         // suffix array for BWT or LZ77-SA
  unsigned* isa;              // inverse suffix array for LZ77-SA
  enum {BUFSIZE=1<<14};       // output buffer size
  unsigned char buf[BUFSIZE]; // output buffer
  void write_literal(unsigned i, unsigned& lit);
  void write_match(unsigned len, unsigned off);
  void fill();  // encode to buf
  // write k bits of x
  void putb(unsigned x, int k) {
    x&=(1<<k)-1;
    bits|=x<<nbits;
    nbits+=k;
    while (nbits>7) {
      assert(wpos<BUFSIZE);
      if (flagdebug5)
		  myprintf("15900: wpos %d BUFSIZE %d\n",wpos,BUFSIZE);
      buf[wpos++]=bits, bits>>=8, nbits-=8;
    }
  }
  // write last byte
  void flush() {
    assert(wpos<BUFSIZE);
    if (nbits>0) buf[wpos++]=bits;
    bits=nbits=0;
  }
  // write 1 byte
  void put(int c) {
    assert(wpos<BUFSIZE);
    buf[wpos++]=c;
  }
public:
  LZBuffer(StringBuffer& inbuf, int args[], const unsigned* sap=0);
  // return 1 byte of compressed output (overrides Reader)
  int get() {
    int c=-1;
    if (rpos==wpos) fill();
    if (rpos<wpos) c=buf[rpos++];
    if (rpos==wpos) rpos=wpos=0;
    return c;
  }
  // Read up to p[0..n-1] and return bytes read.
  int read(char* p, int n);
};
// LZ/BWT preprocessor for levels 1..3 compression and e8e9 filter.
// Level 1 uses variable length LZ77 codes like in the lazy compressor:
//
//   00,n,L[n] = n literal bytes
//   mm,mmm,n,ll,r,q (mm > 00) = match 4*n+ll at offset (q<<rb)+r-1
//
// where q is written in 8mm+mmm-8 (0..23) bits with an implied leading 1 bit
// and n is written using interleaved Elias Gamma coding, i.e. the leading
// 1 bit is implied, remaining bits are preceded by a 1 and terminated by
// a 0. e.g. abc is written 1,b,1,c,0. Codes are packed LSB first and
// padded with leading 0 bits in the last byte. r is a number with rb bits,
// where rb = log2(blocksize) - 24.
//
// Level 2 is byte oriented LZ77 with minimum match length m = $4 = args[3]
// with m in 1..64. Lengths and offsets are MSB first:
// 00xxxxxx   x+1 (1..64) literals follow
// yyxxxxxx   y+1 (2..4) offset bytes follow, match length x+m (m..m+63)
//
// Level 3 is BWT with the end of string byte coded as 255 and the
// last 4 bytes giving its position LSB first.
// floor(log2(x)) + 1 = number of bits excluding leading zeros (0..32)
int lg(unsigned x) {
  unsigned r=0;
  if (x>=65536) r=16, x>>=16;
  if (x>=256) r+=8, x>>=8;
  if (x>=16) r+=4, x>>=4;
  assert(x>=0 && x<16);
  return
    "\x00\x01\x02\x02\x03\x03\x03\x03\x04\x04\x04\x04\x04\x04\x04\x04"[x]+r;
}
// return number of 1 bits in x
int nbits(unsigned x) {
  int r;
  for (r=0; x; x>>=1) r+=x&1;
  return r;
}
// catch buffer overflow with gdb backtrace
void *alpine_memcpy(void *dest, const void *src, size_t n) 
{
	if (dest==NULL)
	{
		myprintf("15965: GURU dest NULL\n");
		exit(0);
	}
	if (src==NULL)
	{
		myprintf("15970: GURU src NULL\n");
		exit(0);
	}
	if (n==0)
		return dest;
	
    unsigned char *d = (unsigned char *)dest;
    const unsigned char *s = (const unsigned char *)src;

    for (size_t i=0;i<n;i++) 
	    d[i]=s[i];
    
    return dest;
}

// Read n bytes of compressed output into p and return number of
// bytes read in 0..n. 0 signals EOF (overrides Reader).
int LZBuffer::read(char* p, int n) 
{
///	if (flagdebug5)
///		myprintf("15964: LZBuffer::read char*p %s  int n %d\n",migliaia(int64_t(p)),n);
  if (rpos==wpos) fill();
  int nr=n;
  if (nr>int(wpos-rpos)) nr=wpos-rpos;
  ///alpine linux does not like this. why? I do not know.
  
  if (flagdebug5)
  {
	if (nr) alpine_memcpy(p, buf+rpos, nr);
  }
  else
  {
	if (nr) memcpy(p, buf+rpos, nr);
  }
  rpos+=nr;
  assert(rpos<=wpos);
  if (rpos==wpos) rpos=wpos=0;
  return nr;
}
LZBuffer::LZBuffer(StringBuffer& inbuf, int args[], const unsigned* sap):
    ht((args[1]&3)==3 ? (inbuf.size()+1)*!sap      // for BWT suffix array
        : args[5]-args[0]<21 ? 1u<<args[5]         // for LZ77 hash table
        : (inbuf.size()*!sap)+(1u<<17<<args[0])),  // for LZ77 SA and ISA
    in(inbuf.data()),
    checkbits(args[5]-args[0]<21 ? 12-args[0] : 17+args[0]),
    level(args[1]&3),
    htsize(ht.size()),
    n(inbuf.size()),
    i(0),
    minMatch(args[2]),
    minMatch2(args[3]),
    maxMatch(BUFSIZE*3),
    maxLiteral(BUFSIZE/4),
    lookahead(args[6]),
    h1(0), h2(0),
    bucket((1<<args[4])-1),
    shift1(minMatch>0 ? (args[5]-1)/minMatch+1 : 1),
    shift2(minMatch2>0 ? (args[5]-1)/minMatch2+1 : 0),
    minMatchBoth(MAX(minMatch, minMatch2+lookahead)+4),
    rb(args[0]>4 ? args[0]-4 : 0),
    bits(0), nbits(0), rpos(0), wpos(0),
    idx(0), sa(0), isa(0) {
  assert(args[0]>=0);
  assert(n<=(1u<<20<<args[0]));
  assert(args[1]>=1 && args[1]<=7 && args[1]!=4);
  assert(level>=1 && level<=3);
  if ((minMatch<4 && level==1) || (minMatch<1 && level==2))
    error("match length $3 too small");
  // e8e9 transform
  if (args[1]>4 && !sap) e8e9(inbuf.data(), n);
  // build suffix array if not supplied
  if (args[5]-args[0]>=21 || level==3) {  // LZ77-SA or BWT
    if (sap)
      sa=sap;
    else {
      assert(ht.size()>=n);
      assert(ht.size()>0);
      sa=&ht[0];
      if (n>0) divsufsort((const unsigned char*)in, (int*)sa, n);
    }
    if (level<3) {
      assert(ht.size()>=(n*(sap==0))+(1u<<17<<args[0]));
      isa=&ht[n*(sap==0)];
    }
  }
}
// Encode from in to buf until end of input or buf is not empty
void LZBuffer::fill() {
  // BWT
  if (level==3) {
    assert(in || n==0);
    assert(sa);
    for (; wpos<BUFSIZE && i<n+5; ++i) {
      if (i==0) put(n>0 ? in[n-1] : 255);
      else if (i>n) put(idx&255), idx>>=8;
      else if (sa[i-1]==0) idx=i, put(255);
      else put(in[sa[i-1]-1]);
    }
    return;
  }
  // LZ77: scan the input
  unsigned lit=0;  // number of output literals pending
  const unsigned mask=(1<<checkbits)-1;
  while (i<n && wpos*2<BUFSIZE) {
    // Search for longest match, or pick closest in case of tie
    unsigned blen=minMatch-1;  // best match length
    unsigned bp=0;  // pointer to best match
    unsigned blit=0;  // literals before best match
    int bscore=0;  // best cost
    // Look up contexts in suffix array
    if (isa) {
      if (sa[isa[i&mask]]!=i) // rebuild ISA
        for (unsigned j=0; j<n; ++j)
          if ((sa[j]&~mask)==(i&~mask))
            isa[sa[j]&mask]=j;
      for (unsigned h=0; h<=lookahead; ++h) {
        unsigned q=isa[(h+i)&mask];  // location of h+i in SA
        assert(q<n);
        if (sa[q]!=h+i) continue;
        for (int j=-1; j<=1; j+=2) {  // search backward and forward
          for (unsigned k=1; k<=bucket; ++k) {
            unsigned p;  // match to be tested
            if (q+j*k<n && (p=sa[q+j*k]-h)<i) {
              assert(p<n);
              unsigned l, l1;  // length of match, leading literals
              for (l=h; i+l<n && l<maxMatch && in[p+l]==in[i+l]; ++l);
              for (l1=h; l1>0 && in[p+l1-1]==in[i+l1-1]; --l1);
              int score=int(l-l1)*8-lg(i-p)-4*(lit==0 && l1>0)-11;
              for (unsigned a=0; a<h; ++a) score=score*5/8;
              if (score>bscore) blen=l, bp=p, blit=l1, bscore=score;
              if (l<blen || l<minMatch || l>255) break;
            }
          }
        }
        if (bscore<=0 || blen<minMatch) break;
      }
    }
    // Look up contexts in a hash table.
    // Try the longest context orders first. If a match is found, then
    // skip the lower order as a speed optimization.
    else if (level==1 || minMatch<=64) {
      if (minMatch2>0) {
        for (unsigned k=0; k<=bucket; ++k) {
          unsigned p=ht[h2^k];
          if (p && (p&mask)==(in[i+3]&mask)) {
            p>>=checkbits;
            if (p<i && i+blen<=n && in[p+blen-1]==in[i+blen-1]) {
              unsigned l;  // match length from lookahead
              for (l=lookahead; i+l<n && l<maxMatch && in[p+l]==in[i+l]; ++l);
              if (l>=minMatch2+lookahead) {
                int l1;  // length back from lookahead
                for (l1=lookahead; l1>0 && in[p+l1-1]==in[i+l1-1]; --l1);
                assert(l1>=0 && l1<=int(lookahead));
                int score=int(l-l1)*8-lg(i-p)-8*(lit==0 && l1>0)-11;
                if (score>bscore) blen=l, bp=p, blit=l1, bscore=score;
              }
            }
          }
          if (blen>=128) break;
        }
      }
      // Search the lower order context
      if (!minMatch2 || blen<minMatch2) {
        for (unsigned k=0; k<=bucket; ++k) {
          unsigned p=ht[h1^k];
          if (p && i+3<n && (p&mask)==(in[i+3]&mask)) {
            p>>=checkbits;
            if (p<i && i+blen<=n && in[p+blen-1]==in[i+blen-1]) {
              unsigned l;
              for (l=0; i+l<n && l<maxMatch && in[p+l]==in[i+l]; ++l);
              int score=l*8-lg(i-p)-2*(lit>0)-11;
              if (score>bscore) blen=l, bp=p, blit=0, bscore=score;
            }
          }
          if (blen>=128) break;
        }
      }
    }
    // If match is long enough, then output any pending literals first,
    // and then the match. blen is the length of the match.
    assert(i>=bp);
    const unsigned off=i-bp;  // offset
    if (off>0 && bscore>0
        && blen-blit>=minMatch+(level==2)*((off>=(1<<16))+(off>=(1<<24)))) {
      lit+=blit;
      write_literal(i+blit, lit);
      write_match(blen-blit, off);
    }
    // Otherwise add to literal length
    else {
      blen=1;
      ++lit;
    }
    // Update index, advance blen bytes
    if (isa)
      i+=blen;
    else {
      while (blen--) {
        if (i+minMatchBoth<n) {
          unsigned ih=((i*1234547)>>19)&bucket;
          const unsigned p=(i<<checkbits)|(in[i+3]&mask);
          assert(ih<=bucket);
          if (minMatch2) {
            ht[h2^ih]=p;
            h2=(((h2*9)<<shift2)
                +(in[i+minMatch2+lookahead]+1)*23456789u)&(htsize-1);
          }
          ht[h1^ih]=p;	
		  ///alpine
/*
		  if (flagdebug5)
		  {
			  myprintf("16181: inzuppo i %d minMatch %d sum %d\n",i,minMatch,i+minMatch);
			  myprintf("16186: byte %03d %03d+1\n",in[i+minMatch] & 0xff,(in[i+minMatch]+1) & 0xff);
			  myprintf("16187: Z1   %d\n",((in[i+minMatch]+1)*123456791u)&(htsize-1));
			  myprintf("16188: Z2   %d\n",(h1*5)<<shift1);
		  }
*/
          h1=(((h1*5)<<shift1)+(in[i+minMatch]+1)*123456791u)&(htsize-1);
        }
        ++i;
      }
    }
    // Write long literals to keep buf from filling up
    if (lit>=maxLiteral)
      write_literal(i, lit);
  }
  // Write pending literals at end of input
  assert(i<=n);
  if (i==n) {
    write_literal(n, lit);
    flush();
  }
}
// Write literal sequence in[i-lit..i-1], set lit=0
void LZBuffer::write_literal(unsigned i, unsigned& lit) {
  assert(lit>=0);
  assert(i>=0 && i<=n);
  assert(i>=lit);
  if (level==1) {
    if (lit<1) return;
    int ll=lg(lit);
    assert(ll>=1 && ll<=24);
    putb(0, 2);
    --ll;
    while (--ll>=0) {
      putb(1, 1);
      putb((lit>>ll)&1, 1);
    }
    putb(0, 1);
    while (lit) putb(in[i-lit--], 8);
  }
  else {
    assert(level==2);
    while (lit>0) {
      unsigned lit1=lit;
      if (lit1>64) lit1=64;
      put(lit1-1);
      for (unsigned j=i-lit; j<i-lit+lit1; ++j) put(in[j]);
      lit-=lit1;
    }
  }
}
// Write match sequence of given length and offset
void LZBuffer::write_match(unsigned len, unsigned off) {
  // mm,mmm,n,ll,r,q[mmmmm-8] = match n*4+ll, offset ((q-1)<<rb)+r+1
  if (level==1) {
    assert(len>=minMatch && len<=maxMatch);
    assert(off>0);
    assert(len>=4);
    assert(rb>=0 && rb<=8);
    int ll=lg(len)-1;
    assert(ll>=2);
    off+=(1<<rb)-1;
    int lo=lg(off)-1-rb;
    assert(lo>=0 && lo<=23);
    putb((lo+8)>>3, 2);// mm
    putb(lo&7, 3);     // mmm
    while (--ll>=2) {  // n
      putb(1, 1);
      putb((len>>ll)&1, 1);
    }
    putb(0, 1);
    putb(len&3, 2);    // ll
    putb(off, rb);     // r
    putb(off>>rb, lo); // q
  }
  // x[2]:len[6] off[x-1]
  else {
    assert(level==2);
    assert(minMatch>=1 && minMatch<=64);
    --off;
    while (len>0) {  // Split long matches to len1=minMatch..minMatch+63
      const unsigned len1=len>minMatch*2+63 ? minMatch+63 :
          len>minMatch+63 ? len-minMatch : len;
      assert(wpos<BUFSIZE-5);
      assert(len1>=minMatch && len1<minMatch+64);
      if (off<(1<<16)) {
        put(64+len1-minMatch);
        put(off>>8);
        put(off);
      }
      else if (off<(1<<24)) {
        put(128+len1-minMatch);
        put(off>>16);
        put(off>>8);
        put(off);
      }
      else {
        put(192+len1-minMatch);
        put(off>>24);
        put(off>>16);
        put(off>>8);
        put(off);
      }
      len-=len1;
    }
  }
}
// Generate a config file from the method argument with syntax:
// {0|x|s|i}[N1[,N2]...][{ciamtswf<cfg>}[N1[,N2]]...]...
std::string makeConfig(const char* method, int args[]) {
  assert(method);
  const char type=method[0];
  assert(type=='x' || type=='s' || type=='0' || type=='i');
  // Read "{x|s|i|0}N1,N2...N9" into args[0..8] ($1..$9)
  args[0]=0;  // log block size in MiB
  args[1]=0;  // 0=none, 1=var-LZ77, 2=byte-LZ77, 3=BWT, 4..7 adds E8E9
  args[2]=0;  // lz77 minimum match length
  args[3]=0;  // secondary context length
  args[4]=0;  // log searches
  args[5]=0;  // lz77 hash table size or SA if args[0]+21
  args[6]=0;  // secondary context look ahead
  args[7]=0;  // not used
  args[8]=0;  // not used
  if (isdigit(*++method)) args[0]=0;
  for (int i=0; i<9 && (isdigit(*method) || *method==',' || *method=='.');) {
    if (isdigit(*method))
      args[i]=args[i]*10+*method-'0';
    else if (++i<9)
      args[i]=0;
    ++method;
  }
  // "0..." = No compression
  if (type=='0')
    return "comp 0 0 0 0 0 hcomp end\n";
  // Generate the postprocessor
  std::string hdr, pcomp;
  const int level=args[1]&3;
  const bool doe8=args[1]>=4 && args[1]<=7;
  // LZ77+Huffman, with or without E8E9
  if (level==1) {
    const int rb=args[0]>4 ? args[0]-4 : 0;
    hdr="comp 9 16 0 $1+20 ";
    pcomp=
    "pcomp lazy2 3 ;\n"
    " (r1 = state\n"
    "  r2 = len - match or literal length\n"
    "  r3 = m - number of offset bits expected\n"
    "  r4 = ptr to buf\n"
    "  r5 = r - low bits of offset\n"
    "  c = bits - input buffer\n"
    "  d = n - number of bits in c)\n"
    "\n"
    "  a> 255 if\n";
    if (doe8)
      pcomp+=
      "    b=0 d=r 4 do (for b=0..d-1, d = end of buf)\n"
      "      a=b a==d ifnot\n"
      "        a+= 4 a<d if\n"
      "          a=*b a&= 254 a== 232 if (e8 or e9?)\n"
      "            c=b b++ b++ b++ b++ a=*b a++ a&= 254 a== 0 if (00 or ff)\n"
      "              b-- a=*b\n"
      "              b-- a<<= 8 a+=*b\n"
      "              b-- a<<= 8 a+=*b\n"
      "              a-=b a++\n"
      "              *b=a a>>= 8 b++\n"
      "              *b=a a>>= 8 b++\n"
      "              *b=a b++\n"
      "            endif\n"
      "            b=c\n"
      "          endif\n"
      "        endif\n"
      "        a=*b out b++\n"
      "      forever\n"
      "    endif\n"
      "\n";
    pcomp+=
    "    (reset state)\n"
    "    a=0 b=0 c=0 d=0 r=a 1 r=a 2 r=a 3 r=a 4\n"
    "    halt\n"
    "  endif\n"
    "\n"
    "  a<<=d a+=c c=a               (bits+=a<<n)\n"
    "  a= 8 a+=d d=a                (n+=8)\n"
    "\n"
    "  (if state==0 (expect new code))\n"
    "  a=r 1 a== 0 if (match code mm,mmm)\n"
    "    a= 1 r=a 2                 (len=1)\n"
    "    a=c a&= 3 a> 0 if          (if (bits&3))\n"
    "      a-- a<<= 3 r=a 3           (m=((bits&3)-1)*8)\n"
    "      a=c a>>= 2 c=a             (bits>>=2)\n"
    "      b=r 3 a&= 7 a+=b r=a 3     (m+=bits&7)\n"
    "      a=c a>>= 3 c=a             (bits>>=3)\n"
    "      a=d a-= 5 d=a              (n-=5)\n"
    "      a= 1 r=a 1                 (state=1)\n"
    "    else (literal, discard 00)\n"
    "      a=c a>>= 2 c=a             (bits>>=2)\n"
    "      d-- d--                    (n-=2)\n"
    "      a= 3 r=a 1                 (state=3)\n"
    "    endif\n"
    "  endif\n"
    "\n"
    "  (while state==1 && n>=3 (expect match length n*4+ll -> r2))\n"
    "  do a=r 1 a== 1 if a=d a> 2 if\n"
    "    a=c a&= 1 a== 1 if         (if bits&1)\n"
    "      a=c a>>= 1 c=a             (bits>>=1)\n"
    "      b=r 2 a=c a&= 1 a+=b a+=b r=a 2 (len+=len+(bits&1))\n"
    "      a=c a>>= 1 c=a             (bits>>=1)\n"
    "      d-- d--                    (n-=2)\n"
    "    else\n"
    "      a=c a>>= 1 c=a             (bits>>=1)\n"
    "      a=r 2 a<<= 2 b=a           (len<<=2)\n"
    "      a=c a&= 3 a+=b r=a 2       (len+=bits&3)\n"
    "      a=c a>>= 2 c=a             (bits>>=2)\n"
    "      d-- d-- d--                (n-=3)\n";
    if (rb)
      pcomp+="      a= 5 r=a 1                 (state=5)\n";
    else
      pcomp+="      a= 2 r=a 1                 (state=2)\n";
    pcomp+=
    "    endif\n"
    "  forever endif endif\n"
    "\n";
    if (rb) pcomp+=  // save r in r5
      "  (if state==5 && n>=8) (expect low bits of offset to put in r5)\n"
      "  a=r 1 a== 5 if a=d a> "+itos(rb-1)+" if\n"
      "    a=c a&= "+itos((1<<rb)-1)+" r=a 5            (save r in r5)\n"
      "    a=c a>>= "+itos(rb)+" c=a\n"
      "    a=d a-= "+itos(rb)+ " d=a\n"
      "    a= 2 r=a 1                   (go to state 2)\n"
      "  endif endif\n"
      "\n";
    pcomp+=
    "  (if state==2 && n>=m) (expect m offset bits)\n"
    "  a=r 1 a== 2 if a=r 3 a>d ifnot\n"
    "    a=c r=a 6 a=d r=a 7          (save c=bits, d=n in r6,r7)\n"
    "    b=r 3 a= 1 a<<=b d=a         (d=1<<m)\n"
    "    a-- a&=c a+=d                (d=offset=bits&((1<<m)-1)|(1<<m))\n";
    if (rb)
      pcomp+=  // insert r into low bits of d
      "    a<<= "+itos(rb)+" d=r 5 a+=d a-= "+itos((1<<rb)-1)+"\n";
    pcomp+=
    "    d=a b=r 4 a=b a-=d c=a       (c=p=(b=ptr)-offset)\n"
    "\n"
    "    (while len-- (copy and output match d bytes from *c to *b))\n"
    "    d=r 2 do a=d a> 0 if d--\n"
    "      a=*c *b=a c++ b++          (buf[ptr++]-buf[p++])\n";
    if (!doe8) pcomp+=" out\n";
    pcomp+=
    "    forever endif\n"
    "    a=b r=a 4\n"
    "\n"
    "    a=r 6 b=r 3 a>>=b c=a        (bits>>=m)\n"
    "    a=r 7 a-=b d=a               (n-=m)\n"
    "    a=0 r=a 1                    (state=0)\n"
    "  endif endif\n"
    "\n"
    "  (while state==3 && n>=2 (expect literal length))\n"
    "  do a=r 1 a== 3 if a=d a> 1 if\n"
    "    a=c a&= 1 a== 1 if         (if bits&1)\n"
    "      a=c a>>= 1 c=a              (bits>>=1)\n"
    "      b=r 2 a&= 1 a+=b a+=b r=a 2 (len+=len+(bits&1))\n"
    "      a=c a>>= 1 c=a              (bits>>=1)\n"
    "      d-- d--                     (n-=2)\n"
    "    else\n"
    "      a=c a>>= 1 c=a              (bits>>=1)\n"
    "      d--                         (--n)\n"
    "      a= 4 r=a 1                  (state=4)\n"
    "    endif\n"
    "  forever endif endif\n"
    "\n"
    "  (if state==4 && n>=8 (expect len literals))\n"
    "  a=r 1 a== 4 if a=d a> 7 if\n"
    "    b=r 4 a=c *b=a\n";
    if (!doe8) pcomp+=" out\n";
    pcomp+=
    "    b++ a=b r=a 4                 (buf[ptr++]=bits)\n"
    "    a=c a>>= 8 c=a                (bits>>=8)\n"
    "    a=d a-= 8 d=a                 (n-=8)\n"
    "    a=r 2 a-- r=a 2 a== 0 if      (if --len<1)\n"
    "      a=0 r=a 1                     (state=0)\n"
    "    endif\n"
    "  endif endif\n"
    "  halt\n"
    "end\n";
  }
  // Byte aligned LZ77, with or without E8E9
  else if (level==2) {
    hdr="comp 9 16 0 $1+20 ";
    pcomp=
    "pcomp lzpre c ;\n"
    "  (Decode LZ77: d=state, M=output buffer, b=size)\n"
    "  a> 255 if (at EOF decode e8e9 and output)\n";
    if (doe8)
      pcomp+=
      "    d=b b=0 do (for b=0..d-1, d = end of buf)\n"
      "      a=b a==d ifnot\n"
      "        a+= 4 a<d if\n"
      "          a=*b a&= 254 a== 232 if (e8 or e9?)\n"
      "            c=b b++ b++ b++ b++ a=*b a++ a&= 254 a== 0 if (00 or ff)\n"
      "              b-- a=*b\n"
      "              b-- a<<= 8 a+=*b\n"
      "              b-- a<<= 8 a+=*b\n"
      "              a-=b a++\n"
      "              *b=a a>>= 8 b++\n"
      "              *b=a a>>= 8 b++\n"
      "              *b=a b++\n"
      "            endif\n"
      "            b=c\n"
      "          endif\n"
      "        endif\n"
      "        a=*b out b++\n"
      "      forever\n"
      "    endif\n";
    pcomp+=
    "    b=0 c=0 d=0 a=0 r=a 1 r=a 2 (reset state)\n"
    "  halt\n"
    "  endif\n"
    "\n"
    "  (in state d==0, expect a new code)\n"
    "  (put length in r1 and initial part of offset in r2)\n"
    "  c=a a=d a== 0 if\n"
    "    a=c a>>= 6 a++ d=a\n"
    "    a== 1 if (literal?)\n"
    "      a+=c r=a 1 a=0 r=a 2\n"
    "    else (3 to 5 byte match)\n"
    "      d++ a=c a&= 63 a+= $3 r=a 1 a=0 r=a 2\n"
    "    endif\n"
    "  else\n"
    "    a== 1 if (writing literal)\n"
    "      a=c *b=a b++\n";
    if (!doe8) pcomp+=" out\n";
    pcomp+=
    "      a=r 1 a-- a== 0 if d=0 endif r=a 1 (if (--len==0) state=0)\n"
    "    else\n"
    "      a> 2 if (reading offset)\n"
    "        a=r 2 a<<= 8 a|=c r=a 2 d-- (off=off<<8|c, --state)\n"
    "      else (state==2, write match)\n"
    "        a=r 2 a<<= 8 a|=c c=a a=b a-=c a-- c=a (c=i-off-1)\n"
    "        d=r 1 (d=len)\n"
    "        do (copy and output d=len bytes)\n"
    "          a=*c *b=a c++ b++\n";
    if (!doe8) pcomp+=" out\n";
    pcomp+=
    "        d-- a=d a> 0 while\n"
    "        (d=state=0. off, len don\'t matter)\n"
    "      endif\n"
    "    endif\n"
    "  endif\n"
    "  halt\n"
    "end\n";
  }
  // BWT with or without E8E9
  else if (level==3) {  // IBWT
    hdr="comp 9 16 $1+20 $1+20 ";  // 2^$1 = block size in MB
    pcomp=
    "pcomp bwtrle c ;\n"
    "\n"
    "  (read BWT, index into M, size in b)\n"
    "  a> 255 ifnot\n"
    "    *b=a b++\n"
    "\n"
    "  (inverse BWT)\n"
    "  elsel\n"
    "\n"
    "    (index in last 4 bytes, put in c and R1)\n"
    "    b-- a=*b\n"
    "    b-- a<<= 8 a+=*b\n"
    "    b-- a<<= 8 a+=*b\n"
    "    b-- a<<= 8 a+=*b c=a r=a 1\n"
    "\n"
    "    (save size in R2)\n"
    "    a=b r=a 2\n"
    "\n"
    "    (count bytes in H[~1..~255, ~0])\n"
    "    do\n"
    "      a=b a> 0 if\n"
    "        b-- a=*b a++ a&= 255 d=a d! *d++\n"
    "      forever\n"
    "    endif\n"
    "\n"
    "    (cumulative counts: H[~i=0..255] = count of bytes before i)\n"
    "    d=0 d! *d= 1 a=0\n"
    "    do\n"
    "      a+=*d *d=a d--\n"
    "    d<>a a! a> 255 a! d<>a until\n"
    "\n"
    "    (build first part of linked list in H[0..idx-1])\n"
    "    b=0 do\n"
    "      a=c a>b if\n"
    "        d=*b d! *d++ d=*d d-- *d=b\n"
    "      b++ forever\n"
    "    endif\n"
    "\n"
    "    (rest of list in H[idx+1..n-1])\n"
    "    b=c b++ c=r 2 do\n"
    "      a=c a>b if\n"
    "        d=*b d! *d++ d=*d d-- *d=b\n"
    "      b++ forever\n"
    "    endif\n"
    "\n";
    if (args[0]<=4) {  // faster IBWT list traversal limited to 16 MB blocks
      pcomp+=
      "    (copy M to low 8 bits of H to reduce cache misses in next loop)\n"
      "    b=0 do\n"
      "      a=c a>b if\n"
      "        d=b a=*d a<<= 8 a+=*b *d=a\n"
      "      b++ forever\n"
      "    endif\n"
      "\n"
      "    (traverse list and output or copy to M)\n"
      "    d=r 1 b=0 do\n"
      "      a=d a== 0 ifnot\n"
      "        a=*d a>>= 8 d=a\n";
      if (doe8) pcomp+=" *b=*d b++\n";
      else      pcomp+=" a=*d out\n";
      pcomp+=
      "      forever\n"
      "    endif\n"
      "\n";
      if (doe8)  // IBWT+E8E9
        pcomp+=
        "    (e8e9 transform to out)\n"
        "    d=b b=0 do (for b=0..d-1, d = end of buf)\n"
        "      a=b a==d ifnot\n"
        "        a+= 4 a<d if\n"
        "          a=*b a&= 254 a== 232 if\n"
        "            c=b b++ b++ b++ b++ a=*b a++ a&= 254 a== 0 if\n"
        "              b-- a=*b\n"
        "              b-- a<<= 8 a+=*b\n"
        "              b-- a<<= 8 a+=*b\n"
        "              a-=b a++\n"
        "              *b=a a>>= 8 b++\n"
        "              *b=a a>>= 8 b++\n"
        "              *b=a b++\n"
        "            endif\n"
        "            b=c\n"
        "          endif\n"
        "        endif\n"
        "        a=*b out b++\n"
        "      forever\n"
        "    endif\n";
      pcomp+=
      "  endif\n"
      "  halt\n"
      "end\n";
    }
    else {  // slower IBWT list traversal for all sized blocks
      if (doe8) {  // E8E9 after IBWT
        pcomp+=
        "    (R2 = output size without EOS)\n"
        "    a=r 2 a-- r=a 2\n"
        "\n"
        "    (traverse list (d = IBWT pointer) and output inverse e8e9)\n"
        "    (C = offset = 0..R2-1)\n"
        "    (R4 = last 4 bytes shifted in from MSB end)\n"
        "    (R5 = temp pending output byte)\n"
        "    c=0 d=r 1 do\n"
        "      a=d a== 0 ifnot\n"
        "        d=*d\n"
        "\n"
        "        (store byte in R4 and shift out to R5)\n"
        "        b=d a=*b a<<= 24 b=a\n"
        "        a=r 4 r=a 5 a>>= 8 a|=b r=a 4\n"
        "\n"
        "        (if E8|E9 xx xx xx 00|FF in R4:R5 then subtract c from x)\n"
        "        a=c a> 3 if\n"
        "          a=r 5 a&= 254 a== 232 if\n"
        "            a=r 4 a>>= 24 b=a a++ a&= 254 a< 2 if\n"
        "              a=r 4 a-=c a+= 4 a<<= 8 a>>= 8 \n"
        "              b<>a a<<= 24 a+=b r=a 4\n"
        "            endif\n"
        "          endif\n"
        "        endif\n"
        "\n"
        "        (output buffered byte)\n"
        "        a=c a> 3 if a=r 5 out endif c++\n"
        "\n"
        "      forever\n"
        "    endif\n"
        "\n"
        "    (output up to 4 pending bytes in R4)\n"
        "    b=r 4\n"
        "    a=c a> 3 a=b if out endif a>>= 8 b=a\n"
        "    a=c a> 2 a=b if out endif a>>= 8 b=a\n"
        "    a=c a> 1 a=b if out endif a>>= 8 b=a\n"
        "    a=c a> 0 a=b if out endif\n"
        "\n"
        "  endif\n"
        "  halt\n"
        "end\n";
      }
      else {
        pcomp+=
        "    (traverse list and output)\n"
        "    d=r 1 do\n"
        "      a=d a== 0 ifnot\n"
        "        d=*d\n"
        "        b=d a=*b out\n"
        "      forever\n"
        "    endif\n"
        "  endif\n"
        "  halt\n"
        "end\n";
      }
    }
  }
  // E8E9 or no preprocessing
  else if (level==0) {
    hdr="comp 9 16 0 0 ";
    if (doe8) { // E8E9?
      pcomp=
      "pcomp e8e9 d ;\n"
      "  a> 255 if\n"
      "    a=c a> 4 if\n"
      "      c= 4\n"
      "    else\n"
      "      a! a+= 5 a<<= 3 d=a a=b a>>=d b=a\n"
      "    endif\n"
      "    do a=c a> 0 if\n"
      "      a=b out a>>= 8 b=a c--\n"
      "    forever endif\n"
      "  else\n"
      "    *b=b a<<= 24 d=a a=b a>>= 8 a+=d b=a c++\n"
      "    a=c a> 4 if\n"
      "      a=*b out\n"
      "      a&= 254 a== 232 if\n"
      "        a=b a>>= 24 a++ a&= 254 a== 0 if\n"
      "          a=b a>>= 24 a<<= 24 d=a\n"
      "          a=b a-=c a+= 5\n"
      "          a<<= 8 a>>= 8 a|=d b=a\n"
      "        endif\n"
      "      endif\n"
      "    endif\n"
      "  endif\n"
      "  halt\n"
      "end\n";
    }
    else
      pcomp="end\n";
  }
  else
    error("Unsupported method");
  // Build context model (comp, hcomp) assuming:
  // H[0..254] = contexts
  // H[255..511] = location of last byte i-255
  // M = last 64K bytes, filling backward
  // C = pointer to most recent byte
  // R1 = level 2 lz77 1+bytes expected until next code, 0=init
  // R2 = level 2 lz77 first byte of code
  int ncomp=0;  // number of components
  const int membits=args[0]+20;
  int sb=5;  // bits in last context
  std::string comp;
  std::string hcomp="hcomp\n"
    "c-- *c=a a+= 255 d=a *d=c\n";
  if (level==2) {  // put level 2 lz77 parse state in R1, R2
    hcomp+=
    "  (decode lz77 into M. Codes:\n"
    "  00xxxxxx = literal length xxxxxx+1\n"
    "  xx......, xx > 0 = match with xx offset bytes to follow)\n"
    "\n"
    "  a=r 1 a== 0 if (init)\n"
    "    a= "+itos(111+57*doe8)+" (skip post code)\n"
    "  else a== 1 if  (new code?)\n"
    "    a=*c r=a 2  (save code in R2)\n"
    "    a> 63 if a>>= 6 a++ a++  (match)\n"
    "    else a++ a++ endif  (literal)\n"
    "  else (read rest of code)\n"
    "    a--\n"
    "  endif endif\n"
    "  r=a 1  (R1 = 1+expected bytes to next code)\n";
  }
  // Generate the context model
  while (*method && ncomp<254) {
    // parse command C[N1[,N2]...] into v = {C, N1, N2...}
    std::vector<int> v;
    v.push_back(*method++);
    if (isdigit(*method)) {
      v.push_back(*method++-'0');
      while (isdigit(*method) || *method==',' || *method=='.') {
        if (isdigit(*method))
          v.back()=v.back()*10+*method++-'0';
        else {
          v.push_back(0);
          ++method;
        }
      }
    }
    // c: context model
    // N1%1000: 0=ICM 1..256=CM limit N1-1
    // N1/1000: number of times to halve memory
    // N2: 1..255=offset mod N2. 1000..1255=distance to N2-1000
    // N3...: 0..255=byte mask + 256=lz77 state. 1000+=run of N3-1000 zeros.
    if (v[0]=='c') {
      while (v.size()<3) v.push_back(0);
      comp+=itos(ncomp)+" ";
      sb=11;  // count context bits
      if (v[2]<256) sb+=lg(v[2]);
      else sb+=6;
      for (unsigned i=3; i<v.size(); ++i)
        if (v[i]<512) sb+=nbits(v[i])*3/4;
      if (sb>membits) sb=membits;
      if (v[1]%1000==0) comp+="icm "+itos(sb-6-v[1]/1000)+"\n";
      else comp+="cm "+itos(sb-2-v[1]/1000)+" "+itos(v[1]%1000-1)+"\n";
      // special contexts
      hcomp+="d= "+itos(ncomp)+" *d=0\n";
      if (v[2]>1 && v[2]<=255) {  // periodic context
        if (lg(v[2])!=lg(v[2]-1))
          hcomp+="a=c a&= "+itos(v[2]-1)+" hashd\n";
        else
          hcomp+="a=c a%= "+itos(v[2])+" hashd\n";
      }
      else if (v[2]>=1000 && v[2]<=1255)  // distance context
        hcomp+="a= 255 a+= "+itos(v[2]-1000)+
               " d=a a=*d a-=c a> 255 if a= 255 endif d= "+
               itos(ncomp)+" hashd\n";
      // Masked context
      for (unsigned i=3; i<v.size(); ++i) {
        if (i==3) hcomp+="b=c ";
        if (v[i]==255)
          hcomp+="a=*b hashd\n";  // ordinary byte
        else if (v[i]>0 && v[i]<255)
          hcomp+="a=*b a&= "+itos(v[i])+" hashd\n";  // masked byte
        else if (v[i]>=256 && v[i]<512) { // lz77 state or masked literal byte
          hcomp+=
          "a=r 1 a> 1 if\n"  // expect literal or offset
          "  a=r 2 a< 64 if\n"  // expect literal
          "    a=*b ";
          if (v[i]<511) hcomp+="a&= "+itos(v[i]-256);
          hcomp+=" hashd\n"
          "  else\n"  // expect match offset byte
          "    a>>= 6 hashd a=r 1 hashd\n"
          "  endif\n"
          "else\n"  // expect new code
          "  a= 255 hashd a=r 2 hashd\n"
          "endif\n";
        }
        else if (v[i]>=1256)  // skip v[i]-1000 bytes
          hcomp+="a= "+itos(((v[i]-1000)>>8)&255)+" a<<= 8 a+= "
               +itos((v[i]-1000)&255)+
          " a+=b b=a\n";
        else if (v[i]>1000)
          hcomp+="a= "+itos(v[i]-1000)+" a+=b b=a\n";
///        if (v[i]<512 && i<v.size()-1)
        if (i<v.size()-1)
			if (v[i]<512)
          hcomp+="b++ ";
      }
      ++ncomp;
    }
    // m,8,24: MIX, size, rate
    // t,8,24: MIX2, size, rate
    // s,8,32,255: SSE, size, start, limit
    if (strchr("mts", v[0]) && ncomp>int(v[0]=='t')) {
      if (v.size()<=1) v.push_back(8);
      if (v.size()<=2) v.push_back(24+8*(v[0]=='s'));
      if (v[0]=='s' && v.size()<=3) v.push_back(255);
      comp+=itos(ncomp);
      sb=5+v[1]*3/4;
      if (v[0]=='m')
        comp+=" mix "+itos(v[1])+" 0 "+itos(ncomp)+" "+itos(v[2])+" 255\n";
      else if (v[0]=='t')
        comp+=" mix2 "+itos(v[1])+" "+itos(ncomp-1)+" "+itos(ncomp-2)
            +" "+itos(v[2])+" 255\n";
      else // s
        comp+=" sse "+itos(v[1])+" "+itos(ncomp-1)+" "+itos(v[2])+" "
            +itos(v[3])+"\n";
      if (v[1]>8) {
        hcomp+="d= "+itos(ncomp)+" *d=0 b=c a=0\n";
        for (; v[1]>=16; v[1]-=8) {
          hcomp+="a<<= 8 a+=*b";
          if (v[1]>16) hcomp+=" b++";
          hcomp+="\n";
        }
        if (v[1]>8)
          hcomp+="a<<= 8 a+=*b a>>= "+itos(16-v[1])+"\n";
        hcomp+="a<<= 8 *d=a\n";
      }
      ++ncomp;
    }
    // i: ISSE chain with order increasing by N1,N2...
    if (v[0]=='i' && ncomp>0) {
      assert(sb>=5);
      hcomp+="d= "+itos(ncomp-1)+" b=c a=*d d++\n";
      for (unsigned i=1; i<v.size() && ncomp<254; ++i) {
        for (int j=0; j<v[i]%10; ++j) {
          hcomp+="hash ";
          if (i<v.size()-1 || j<v[i]%10-1) hcomp+="b++ ";
          sb+=6;
        }
        hcomp+="*d=a";
        if (i<v.size()-1) hcomp+=" d++";
        hcomp+="\n";
        if (sb>membits) sb=membits;
        comp+=itos(ncomp)+" isse "+itos(sb-6-v[i]/10)+" "+itos(ncomp-1)+"\n";
        ++ncomp;
      }
    }
    // a24,0,0: MATCH. N1=hash multiplier. N2,N3=halve buf, table.
    if (v[0]=='a') {
      if (v.size()<=1) v.push_back(24);
      while (v.size()<4) v.push_back(0);
      comp+=itos(ncomp)+" match "+itos(membits-v[3]-2)+" "
          +itos(membits-v[2])+"\n";
      hcomp+="d= "+itos(ncomp)+" a=*d a*= "+itos(v[1])
           +" a+=*c a++ *d=a\n";
      sb=5+(membits-v[2])*3/4;
      ++ncomp;
    }
    // w1,65,26,223,20,0: ICM-ISSE chain of length N1 with word contexts,
    // where a word is a sequence of c such that c&N4 is in N2..N2+N3-1.
    // Word is hashed by: hash := hash*N5+c+1
    // Decrease memory by 2^-N6.
    if (v[0]=='w') {
      if (v.size()<=1) v.push_back(1);
      if (v.size()<=2) v.push_back(65);
      if (v.size()<=3) v.push_back(26);
      if (v.size()<=4) v.push_back(223);
      if (v.size()<=5) v.push_back(20);
      if (v.size()<=6) v.push_back(0);
      comp+=itos(ncomp)+" icm "+itos(membits-6-v[6])+"\n";
      for (int i=1; i<v[1]; ++i)
        comp+=itos(ncomp+i)+" isse "+itos(membits-6-v[6])+" "
            +itos(ncomp+i-1)+"\n";
      hcomp+="a=*c a&= "+itos(v[4])+" a-= "+itos(v[2])+" a&= 255 a< "
           +itos(v[3])+" if\n";
      for (int i=0; i<v[1]; ++i) {
        if (i==0) hcomp+="  d= "+itos(ncomp);
        else hcomp+="  d++";
        hcomp+=" a=*d a*= "+itos(v[5])+" a+=*c a++ *d=a\n";
      }
      hcomp+="else\n";
      for (int i=v[1]-1; i>0; --i)
        hcomp+="  d= "+itos(ncomp+i-1)+" a=*d d++ *d=a\n";
      hcomp+="  d= "+itos(ncomp)+" *d=0\n"
           "endif\n";
      ncomp+=v[1]-1;
      sb=membits-v[6];
      ++ncomp;
    }
  }
  return hdr+itos(ncomp)+"\n"+comp+hcomp+"halt\n"+pcomp;
}
// Compress from in to out in 1 segment in 1 block using the algorithm
// descried in method. If method begins with a digit then choose
// a method depending on type. Save filename and comment
// in the segment header. If comment is 0 then the default is the input size
// as a decimal string, plus " jDC\x01" for a journaling method (method[0]
// is not 's'). Write the generated method to methodOut if not 0.
void compressBlock(StringBuffer* in, Writer* out, const char* method_,
                   const char* filename, const char* comment, bool dosha1) {
  assert(in);
  assert(out);
  assert(method_);
  assert(method_[0]);
  std::string method=method_;
  const unsigned n=in->size();  // input size
  const int arg0=MAX(lg(n+4095)-20, 0);  // block size
  assert((1u<<(arg0+20))>=n+4096);
  // Get type from method "LB,R,t" where L is level 0..5, B is block
  // size 0..11, R is redundancy 0..255, t = 0..3 = binary, text, exe, both.
  unsigned type=0;
  if (isdigit(method[0])) {
    int commas=0, arg[4]={0};
    for (int i=1; i<int(method.size()) && commas<4; ++i) {
      if (method[i]==',' || method[i]=='.') ++commas;
      else if (isdigit(method[i])) arg[commas]=arg[commas]*10+method[i]-'0';
    }
    if (commas==0) type=512;
    else type=arg[1]*4+arg[2];
  }
  // Get hash of input
  libzpaq::SHA1 sha1;
  const char* sha1ptr=0;
#ifdef DEBUG
  if (true) {
#else
  if (dosha1) {
#endif // corresponds to #ifdef (#ifdef DEBUG)
    sha1.write(in->c_str(), n);
    sha1ptr=sha1.result();
  }
  // Expand default methods
  if (isdigit(method[0])) {
    const int level=method[0]-'0';
    assert(level>=0 && level<=9);
    // build models
    const int doe8=(type&2)*2;
    method="x"+itos(arg0);
    std::string htsz=","+itos(19+arg0+(arg0<=6));  // lz77 hash table size
    std::string sasz=","+itos(21+arg0);            // lz77 suffix array size
    // store uncompressed
    if (level==0)
      method="0"+itos(arg0)+",0";
    // LZ77, no model. Store if hard to compress
    else if (level==1) {
      if (type<40) method+=",0";
      else {
        method+=","+itos(1+doe8)+",";
        if      (type<80)  method+="4,0,1,15";
        else if (type<128) method+="4,0,2,16";
        else if (type<256) method+="4,0,2"+htsz;
        else if (type<960) method+="5,0,3"+htsz;
        else               method+="6,0,3"+htsz;
      }
    }
    // LZ77 with longer search
    else if (level==2) {
      if (type<32) method+=",0";
      else {
        method+=","+itos(1+doe8)+",";
        if (type<64) method+="4,0,3"+htsz;
        else method+="4,0,7"+sasz+",1";
      }
    }
    // LZ77 with CM depending on redundancy
    else if (level==3) {
      if (type<20)  // store if not compressible
        method+=",0";
      else if (type<48)  // fast LZ77 if barely compressible
        method+=","+itos(1+doe8)+",4,0,3"+htsz;
      else if (type>=640 || (type&1))  // BWT if text or highly compressible
        method+=","+itos(3+doe8)+"ci1";
      else  // LZ77 with O0-1 compression of up to 12 literals
        method+=","+itos(2+doe8)+",12,0,7"+sasz+",1c0,0,511i2";
    }
    // LZ77+CM, fast CM, or BWT depending on type
    else if (level==4) {
      if (type<12)
        method+=",0";
      else if (type<24)
        method+=","+itos(1+doe8)+",4,0,3"+htsz;
      else if (type<48)
        method+=","+itos(2+doe8)+",5,0,7"+sasz+"1c0,0,511";
      else if (type<900) {
        method+=","+itos(doe8)+"ci1,1,1,1,2a";
        if (type&1) method+="w";
        method+="m";
      }
      else
        method+=","+itos(3+doe8)+"ci1";
    }
    // Slow CM with lots of models
    else {  // 5..9
      // Model text files
      method+=","+itos(doe8);
      if (type&1) method+="w2c0,1010,255i1";
      else method+="w1i1";
      method+="c256ci1,1,1,1,1,1,2a";
      // Analyze the data
      const int NR=1<<12;
      int pt[256]={0};  // position of last occurrence
      int r[NR]={0};    // count repetition gaps of length r
      const unsigned char* p=in->data();
      if (level>0) {
        for (unsigned i=0; i<n; ++i) {
          const int k=i-pt[p[i]];
          if (k>0 && k<NR) ++r[k];
          pt[p[i]]=i;
        }
      }
      // Add periodic models
      int n1=n-r[1]-r[2]-r[3];
      for (int i=0; i<2; ++i) {
        int period=0;
        double score=0;
        int t=0;
        for (int j=5; j<NR && t<n1; ++j) {
          const double s=r[j]/(256.0+n1-t);
          if (s>score) score=s, period=j;
          t+=r[j];
        }
        if (period>4 && score>0.1) {
          method+="c0,0,"+itos(999+period)+",255i1";
          if (period<=255)
            method+="c0,"+itos(period)+"i1";
          n1-=r[period];
          r[period]=0;
        }
        else
          break;
      }
      method+="c0,2,0,255i1c0,3,0,0,255i1c0,4,0,0,0,255i1mm16ts19t0";
    }
  }
  // Compress
  std::string config;
  int args[9]={0};
  config=makeConfig(method.c_str(), args);
  assert(n<=(0x100000u<<args[0])-4096);
  libzpaq::Compressor co;
  co.setOutput(out);
#ifdef DEBUG
  co.setVerify(true);
#endif // corresponds to #ifdef (#ifdef DEBUG)
  StringBuffer pcomp_cmd;
  co.writeTag();
  co.startBlock(config.c_str(), args, &pcomp_cmd);
  std::string cs=itos(n);
  if (comment) cs=cs+" "+comment;
  co.startSegment(filename, cs.c_str());
  if (args[1]>=1 && args[1]<=7 && args[1]!=4) {  // LZ77 or BWT
    LZBuffer lz(*in, args);
    co.setInput(&lz);
    co.compress();
  }
  else {  // compress with e8e9 or no preprocessing
    if (args[1]>=4 && args[1]<=7)
      e8e9(in->data(), in->size());
    co.setInput(in);
    co.compress();
  }
#ifdef DEBUG  // verify pre-post processing are inverses
  int64_t outsize;
  const char* sha1result=co.endSegmentChecksum(&outsize, dosha1);
  assert(sha1result);
  assert(sha1ptr);
  if (memcmp(sha1result, sha1ptr, 20)!=0)
    error("Pre/post-processor test failed");
#else
  co.endSegment(sha1ptr);
#endif // corresponds to #ifdef (#ifdef DEBUG  // verify pre-post processing are inverses)
  co.endBlock();
}
}  // end namespace libzpaq
/////// main source
using std::string;
using std::vector;
using std::map;
using libzpaq::StringBuffer;
int unz(const char * archive,const char * key); // paranoid unzpaq 2.06



void seppuku()
{
	if (g_output_handle)
		fclose(g_output_handle);
	if (g_error_handle)
		fclose(g_error_handle);
	
	color_restore();
	exit(0);
}




void append_to_g_password_keyfilehash()
{
	if (g_keyfilehash.empty())
		return;
    // Calculate the total required length
    size_t len_nuova = g_keyfilehash.length();
    size_t len_g_password = (g_password != nullptr) ? strlen(g_password) : 0;
    size_t nuova_lunghezza = len_g_password + len_nuova + 1; // +1 per il terminatore '\0'

    // Allocate new memory for the concatenated string
    char* temp = (char*)malloc(nuova_lunghezza * sizeof(char));
    if (temp == nullptr) 
	{
        printf("20104: Error allocating mem!\n");
		seppuku();
		return;
    }

    // Copy the existing string (if present) and concatenate the new one
    if (g_password != nullptr) 
	{
        strcpy(temp, g_password);
        strcat(temp, g_keyfilehash.c_str()); // Use c_str() to get the char* from std::string
    } else {
        strcpy(temp, g_keyfilehash.c_str());
    }

    // Free the previous memory (if g_password is not nullptr)
    ///free(g_password);

    // Update g_password with the new string
    g_password = temp;
}

bool ihavehw()
{
#ifndef HWSHA2
	return false;
#endif // corresponds to #ifndef (#ifndef HWSHA2)
	uint32_t a=0,b=0,c=0,d=0;
	getcpuid(0,0,a,b,c,d);
   	if (a<7)
	{
		myprintf("00001! cpuid cannot get at least EAX 7\n");
		return false;
	}

	bool 	supported_ssse3	=false;
	bool 	supported_sse41	=false;
	bool	supported_sha	=false;

	getcpuid(1,0,a,b,c,d);
	supported_ssse3	=(c & (1UL << 9));
	supported_sse41	=(c & (1UL << 19));
	if (flagdebug3)
		myprintf("00002: new ecx %d\n",(int)c);

	getcpuid(7,0,a,b,c,d);
	supported_sha	=(b & (1UL << 29));
	if (flagdebug3)
		myprintf("00003: new ebx %d\n",(int)b);

	if (flagdebug)
	{
		myprintf("00004: SSSE3 :");
		if (supported_ssse3)
			myprintf("OK\n");
		else
			myprintf("NO\n");

		myprintf("00005: SSE41 :");
		if (supported_sse41)
			myprintf("OK\n");
		else
			myprintf("NO\n");

		myprintf("00006: SHA   :");
		if (supported_sha)
			myprintf("OK\n");
		else
			myprintf("NO\n");
	}
	return supported_ssse3 && supported_sse41 && supported_sha;
}


string print_datetime(bool i_flagout)
{
	int hours, minutes, seconds, day, month, year;
	time_t nowz;
	time(&nowz);
	const struct tm *local = localtime(&nowz);
	if (local==NULL)
	{
		myprintf("00007! guru on tm\n");
		exit(0);
	}
	hours = local->tm_hour;
	minutes = local->tm_min;
	seconds = local->tm_sec;
	day = local->tm_mday;
	month = local->tm_mon + 1;
	year = local->tm_year + 1900;
	char buffer[40];
	snprintf(buffer,sizeof(buffer),"%02d/%02d/%d %02d:%02d:%02d ", day, month, year, hours,minutes,seconds);
	if (i_flagout)
		myprintf("%s",buffer);
	return buffer;
}

typedef std::map<std::string, bool*> 	MAPPAFLAGS;
typedef std::map<std::string, string> HELPFLAGS;






/*
	Section: hashers
*/

bool isdirectory(const string i_filename)
{
	if (i_filename.length()==0)
		return false;
	else
	return
		i_filename[i_filename.size()-1]=='/';
}

typedef string (*finalize_function)(void*); // type for conciseness

struct tipohash
{
	string 	hashname;
	string	switchname;
	string	hashdescription;
	string	franzocode;
	string	hasherror;
	int		hashlen;
	bool*	switchflag;
	bool	flagiszpaq;
	bool	flagisbenchmark;
	int		checkedok;
	int		checkedfailed;
	int		checkednotfound;
	int64_t checksize;

	finalize_function	ffinalize;

	tipohash(const string& i_hashname,int i_hashlen, const string& i_hashdescription,bool i_iszpaq,const string& i_switchname,bool* i_switchflag,finalize_function i_finalize,string i_franzcode): franzocode(""),switchflag(NULL),flagiszpaq(i_iszpaq),flagisbenchmark(false),
	checkedok(0),checkedfailed(0),checkednotfound(0),checksize(0)
	{
		hashname		=i_hashname;
		hashdescription	=i_hashdescription;
		switchname		=i_switchname;
		switchflag		=i_switchflag;
		if (i_finalize==NULL)
		{
			myprintf("00008! i_finalize NULL! %s\n",i_hashname.c_str());
		}
		
		ffinalize		=i_finalize;
		hashlen			=i_hashlen;
		franzocode		="";
		if (i_franzcode.size()==2)
			franzocode=std::string()+ i_franzcode[0]+i_franzcode[1];
		hasherror="!ERROR!";
		while (hasherror.size()<(unsigned int)i_hashlen)
			hasherror+=' ';

	}
	void resetcheckstat()
	{
		checkedok=0;
		checkedfailed=0;
		checkednotfound=0;
		checksize=0;
	}

};

typedef std::map<int, 	tipohash> MAPPATIPOHASH;

MAPPATIPOHASH g_mappatipohash;

tipohash* franz_get_hash(const string& i_hashstring)
{
	for (MAPPATIPOHASH::iterator p=g_mappatipohash.begin(); p!=g_mappatipohash.end(); ++p)
		if (i_hashstring==p->second.hashname)
			return &p->second;
	return NULL;
}




string	binarytohex(const unsigned char* i_risultato,const int i_lunghezza)
{
	if ((i_risultato==NULL) || (i_lunghezza<=0))
		return "";
	/// slow, and dirty
	string risultato="";
	char myhex[4];
	if (i_lunghezza>0)
		for (int j=0;j<i_lunghezza;j++)
		{
			snprintf(myhex,sizeof(myhex),"%02X", (unsigned char)i_risultato[j]);
			risultato.push_back(myhex[0]);
			risultato.push_back(myhex[1]);
		}
	return risultato;
}
// no to_string on old gcc
string myto_string(int64_t i_number)
{
	return myulltoa(i_number,-1);
}

string decodealgoname(int franzotype)
{
	if (franzotype==FRANZO_NONE)
		return "";
	if (franzotype==FRANZO_CRC_32)
		return "CRC-32";

	MAPPATIPOHASH::iterator p=g_mappatipohash.find(franzotype);
	if (p==g_mappatipohash.end())
	{
		string temp="13882: franzotype strange "+myto_string(franzotype);
		perror(temp.c_str());
		return "";
	}
	if (!p->second.flagiszpaq)
	{
		string temp="13888: franzotype does not seems iszpaq "+myto_string(franzotype);
		perror(temp.c_str());
		return "";
	}
	return p->second.hashname;
}

string decodefranzoffset(int franzotype)
{
	if (franzotype==FRANZO_NONE)
		return "NOTHING (LIKE 7.15)";
	if (franzotype==FRANZO_CRC_32)
		return "CRC-32";

	MAPPATIPOHASH::iterator p=g_mappatipohash.find(franzotype);
	if (p==g_mappatipohash.end())
	{
		string temp="16839: franzotype strange "+myto_string(franzotype);
		perror(temp.c_str());
		return "";
	}
	if (!p->second.flagiszpaq)
	{
		string temp="09603: franzotype does not seems iszpaq "+myto_string(franzotype);
		perror(temp.c_str());
		return "";
	}

	return p->second.hashname+"+CRC-32";
}

string emptyalgo(const string& i_string)
{
	if (i_string=="BLAKE3")
		return "AF1349B9F5F9A1A6A0404DEA36DCC9499BCB25C9ADC112B7CC9A93CAE41F3262";
	else
	if (i_string=="BLAKE3B")
		return "AF1349B9F5F9A1A6A0404DEA36DCC9499BCB25C9ADC112B7CC9A93CAE41F3262";
	else
	if (i_string=="QUICK")
		return "EF46DB3751D8E999";
	else
	if (i_string=="XXHASH64")
		return "EF46DB3751D8E999";
	else
	if (i_string=="WINHASH64")
		return "EF46DB3751D8E999";
	else
	if (i_string=="XXHASH64B")
		return "EF46DB3751D8E999";
	else
	if (i_string=="WYHASH")
		return "";
	else
	if (i_string=="CRC-32")
		return "00000000";
	else
	if (i_string=="ENTROPY")
		return "00000000";
	else
	if (i_string=="CRC-32C")
		return "00000000";
	else
	if (i_string=="XXH3")
		return "99AA06D3014798D86001C324468D497F";
	else
	if (i_string=="XXH3B")
		return "99AA06D3014798D86001C324468D497F";
	else
	if (i_string=="SHA-256")
		return "E3B0C44298FC1C149AFBF4C8996FB92427AE41E4649B934CA495991B7852B855";
	else
	if (i_string=="SHA-256B")
		return "E3B0C44298FC1C149AFBF4C8996FB92427AE41E4649B934CA495991B7852B855";
	else
	if (i_string=="WHIRLPOOL")
		return "19FA61D75522A4669B44E39C1D2E1726C530232130D407F89AFEE0964997F7A73E83BE698B288FEBCF88E3E03C4F0757EA8964E59B63D93708B138CC42A66EB3";
	else
	if (i_string=="MD5")
		return "D41D8CD98F00B204E9800998ECF8427E";
	else
	if (i_string=="MD5B")
		return "D41D8CD98F00B204E9800998ECF8427E";
	else
	if (i_string=="NILSIMSA")
		return "VUOTO";
	else
	if (i_string=="HIGHWAY64")
		return "92943A34E3447FAA";
	else
	if (i_string=="HIGHWAY128")
		return "D39FAE4F2222AD3611D8E8215B1B01F2";
	else
	if (i_string=="HIGHWAY256")
		return "D6EB09DBE820BC5A8050209986CEDE586E78E6815864E99DC22811C2FCFE001B";
	else
	if (i_string=="ZETA")
		return "0000000000000000";
	else
	if (i_string=="ZETAENC")
		return "0000000000000000";
	else
	if (i_string=="SHA-3")
		return "A7FFC6F8BF1ED76651C14756A061D662F580FF4DE43B49FA82D80A4B80F8434A";
	else
	if (i_string=="SHA-3B")
		return "A7FFC6F8BF1ED76651C14756A061D662F580FF4DE43B49FA82D80A4B80F8434A";
	else
		return "DA39A3EE5E6B4B0D3255BFEF95601890AFD80709"; //sha1
	
}

/// LICENSE_START.8

/*
	Experimental "antihash" function: sort "similar" files
*/
/*!
 * The MIT License (MIT)
 * =====================
 *
 * Copyright 2017 Sepehr Laal
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
*/
/*!
 * @fn nilsimsa_compute
 * @brief computes the Nilsimsa hash of the given data.
 * @arg data [IN] input data byte (char) array
 * @arg size [IN] input data size
 * @arg out [OUT] output hash string (must be allocated
 * to hold exactly 64 characters + 1 null character. So
 * total of 65 characters e.g. char hash[65])
 */
void nilsimsa_compute(const char* data, int size, char* out);
/*!
 * @fn nilsimsa_compare
 * @brief compares two given Nilsimsa hashes
 * @returns A score between -127 and 128 where -127 means
 * completely uncorrelated data and 128 means same data.
 * @arg lhs [IN] left hand side hash
 * @arg rhs [IN] right hand side hash
 */
static int __tran3(int a, int b, int c, int n);
static const char* __int_to_hexchar(int num);
#define ACCUM_LENGTH 256
#define DIGEST_LENGTH 32
#define WINDOW_LENGTH 4
void nilsimsa_compute(const char* data, int n, char* out)
{
    int accum[ACCUM_LENGTH] = { 0 };
    int digest[DIGEST_LENGTH] = { 0 };
    int window[WINDOW_LENGTH] = { -1, -1, -1, -1 };
    for (int i = 0; i < n; ++i)
    {
        int ch = data[i] & 0xFF;
        if (window[1] > -1)
        {
            accum[__tran3(ch, window[0], window[1], 0)] += 1;
        }
        if (window[2] > -1)
        {
            accum[__tran3(ch, window[0], window[2], 1)] += 1;
            accum[__tran3(ch, window[1], window[2], 2)] += 1;
        }
        if (window[3] > -1)
        {
            accum[__tran3(ch, window[0], window[3], 3)] += 1;
            accum[__tran3(ch, window[1], window[3], 4)] += 1;
            accum[__tran3(ch, window[2], window[3], 5)] += 1;
            accum[__tran3(window[3], window[0], ch, 6)] += 1;
            accum[__tran3(window[3], window[2], ch, 7)] += 1;
        }
        window[3] = window[2];
        window[2] = window[1];
        window[1] = window[0];
        window[0] = ch;
    }
    int total = 0;
    if (n == 3)
        total = 1;
    else if (n == 4)
        total = 4;
    else if (n > 4)
        total = 8 * n - 28;
    int threshold = total / ACCUM_LENGTH;
    for (int i = 0; i < ACCUM_LENGTH; i++)
        if (accum[i] > threshold)
            digest[i >> 3] += 1 << (i & 7);
    int rev_index;
    for (int i = 0; i < DIGEST_LENGTH; ++i)
    {
        rev_index = DIGEST_LENGTH - i - 1;
        out[2*i  ] = __int_to_hexchar(digest[rev_index])[0];
        out[2*i+1] = __int_to_hexchar(digest[rev_index])[1];
    }
    out[2 * DIGEST_LENGTH] = '\0';
}
// This is a precomputed constant for the standard Nilsimsa "53"-based transition table.
static const int __TRAN53[] =
{
    0x02, 0xD6, 0x9E, 0x6F, 0xF9, 0x1D, 0x04, 0xAB, 0xD0, 0x22, 0x16, 0x1F, 0xD8, 0x73, 0xA1, 0xAC,
    0x3B, 0x70, 0x62, 0x96, 0x1E, 0x6E, 0x8F, 0x39, 0x9D, 0x05, 0x14, 0x4A, 0xA6, 0xBE, 0xAE, 0x0E,
    0xCF, 0xB9, 0x9C, 0x9A, 0xC7, 0x68, 0x13, 0xE1, 0x2D, 0xA4, 0xEB, 0x51, 0x8D, 0x64, 0x6B, 0x50,
    0x23, 0x80, 0x03, 0x41, 0xEC, 0xBB, 0x71, 0xCC, 0x7A, 0x86, 0x7F, 0x98, 0xF2, 0x36, 0x5E, 0xEE,
    0x8E, 0xCE, 0x4F, 0xB8, 0x32, 0xB6, 0x5F, 0x59, 0xDC, 0x1B, 0x31, 0x4C, 0x7B, 0xF0, 0x63, 0x01,
    0x6C, 0xBA, 0x07, 0xE8, 0x12, 0x77, 0x49, 0x3C, 0xDA, 0x46, 0xFE, 0x2F, 0x79, 0x1C, 0x9B, 0x30,
    0xE3, 0x00, 0x06, 0x7E, 0x2E, 0x0F, 0x38, 0x33, 0x21, 0xAD, 0xA5, 0x54, 0xCA, 0xA7, 0x29, 0xFC,
    0x5A, 0x47, 0x69, 0x7D, 0xC5, 0x95, 0xB5, 0xF4, 0x0B, 0x90, 0xA3, 0x81, 0x6D, 0x25, 0x55, 0x35,
    0xF5, 0x75, 0x74, 0x0A, 0x26, 0xBF, 0x19, 0x5C, 0x1A, 0xC6, 0xFF, 0x99, 0x5D, 0x84, 0xAA, 0x66,
    0x3E, 0xAF, 0x78, 0xB3, 0x20, 0x43, 0xC1, 0xED, 0x24, 0xEA, 0xE6, 0x3F, 0x18, 0xF3, 0xA0, 0x42,
    0x57, 0x08, 0x53, 0x60, 0xC3, 0xC0, 0x83, 0x40, 0x82, 0xD7, 0x09, 0xBD, 0x44, 0x2A, 0x67, 0xA8,
    0x93, 0xE0, 0xC2, 0x56, 0x9F, 0xD9, 0xDD, 0x85, 0x15, 0xB4, 0x8A, 0x27, 0x28, 0x92, 0x76, 0xDE,
    0xEF, 0xF8, 0xB2, 0xB7, 0xC9, 0x3D, 0x45, 0x94, 0x4B, 0x11, 0x0D, 0x65, 0xD5, 0x34, 0x8B, 0x91,
    0x0C, 0xFA, 0x87, 0xE9, 0x7C, 0x5B, 0xB1, 0x4D, 0xE5, 0xD4, 0xCB, 0x10, 0xA2, 0x17, 0x89, 0xBC,
    0xDB, 0xB0, 0xE2, 0x97, 0x88, 0x52, 0xF7, 0x48, 0xD3, 0x61, 0x2C, 0x3A, 0x2B, 0xD1, 0x8C, 0xFB,
    0xF1, 0xCD, 0xE4, 0x6A, 0xE7, 0xA9, 0xFD, 0xC4, 0x37, 0xC8, 0xD2, 0xF6, 0xDF, 0x58, 0x72, 0x4E
};
/*
* Used to convert integers to 1-byte hex strings
* Integers in between the range of 0 and 256.
*/
static const char* __HEX_BYTE_DIGITS[] =
{
    "00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0A", "0B", "0C", "0D", "0E", "0F",
    "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1A", "1B", "1C", "1D", "1E", "1F",
    "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2A", "2B", "2C", "2D", "2E", "2F",
    "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3A", "3B", "3C", "3D", "3E", "3F",
    "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4A", "4B", "4C", "4D", "4E", "4F",
    "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5A", "5B", "5C", "5D", "5E", "5F",
    "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6A", "6B", "6C", "6D", "6E", "6F",
    "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7A", "7B", "7C", "7D", "7E", "7F",
    "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8A", "8B", "8C", "8D", "8E", "8F",
    "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9A", "9B", "9C", "9D", "9E", "9F",
    "A0", "A1", "A2", "A3", "A4", "A5", "A6", "A7", "A8", "A9", "AA", "AB", "AC", "AD", "AE", "AF",
    "B0", "B1", "B2", "B3", "B4", "B5", "B6", "B7", "B8", "B9", "BA", "BB", "BC", "BD", "BE", "BF",
    "C0", "C1", "C2", "C3", "C4", "C5", "C6", "C7", "C8", "C9", "CA", "CB", "CC", "CD", "CE", "CF",
    "D0", "D1", "D2", "D3", "D4", "D5", "D6", "D7", "D8", "D9", "DA", "DB", "DC", "DD", "DE", "DF",
    "E0", "E1", "E2", "E3", "E4", "E5", "E6", "E7", "E8", "E9", "EA", "EB", "EC", "ED", "EE", "EF",
    "F0", "F1", "F2", "F3", "F4", "F5", "F6", "F7", "F8", "F9", "FA", "FB", "FC", "FD", "FE", "FF"
};
static int __tran3(int a, int b, int c, int n)
{
    return (((__TRAN53[(a + n) & 255] ^ __TRAN53[b] * (n + n + 1)) + __TRAN53[c ^ __TRAN53[n]]) & 255);
}
static const char* __int_to_hexchar(int num)
{
    return __HEX_BYTE_DIGITS[num];
}
/// LICENSE_END.8



/// LICENSE_START.18
/// This is a (minor) rework of https://github.com/google/highwayhash/tree/master/c
/*
By Jan Wassenberg jan.wassenberg@gmail.com and Jyrki Alakuijala jyrki.alakuijala@gmail.com

This is not an official Google product.
*/


/*////////////////////////////////////////////////////////////////////////////*/
/* Low-level API, use for implementing streams etc...                         */
/*////////////////////////////////////////////////////////////////////////////*/

typedef struct {
  uint64_t v0[4];
  uint64_t v1[4];
  uint64_t mul0[4];
  uint64_t mul1[4];
} HighwayHashState;

/* Initializes state with given key */
static void HighwayHashReset(const uint64_t key[4], HighwayHashState* state);
/* Takes a packet of 32 bytes */
void HighwayHashUpdatePacket(const uint8_t* packet, HighwayHashState* state);
/* Adds the final 1..31 bytes, do not use if 0 remain */
void HighwayHashUpdateRemainder(const uint8_t* bytes, const size_t size_mod32,
                                HighwayHashState* state);
/* Compute final hash value. Makes state invalid. */
static uint64_t HighwayHashFinalize64(HighwayHashState* state);
static void HighwayHashFinalize128(HighwayHashState* state, uint64_t hash[2]);
static void HighwayHashFinalize256(HighwayHashState* state, uint64_t hash[4]);

/*////////////////////////////////////////////////////////////////////////////*/
/* Non-cat API: single call on full data                                      */
/*////////////////////////////////////////////////////////////////////////////*/

/*////////////////////////////////////////////////////////////////////////////*/
/* Cat API: allows appending with multiple calls                              */
/*////////////////////////////////////////////////////////////////////////////*/

typedef struct {
  HighwayHashState state;
  uint8_t packet[32];
  int num;
} HighwayHashCat;

/* Allocates new state for a new streaming hash computation */
void HighwayHashCatStart(const uint64_t key[4], HighwayHashCat* state);

void HighwayHashCatAppend(const uint8_t* bytes, size_t num,
                          HighwayHashCat* state);

/* Computes final hash value */
uint64_t HighwayHashCatFinish64(const HighwayHashCat* state);
void HighwayHashCatFinish128(const HighwayHashCat* state, uint64_t hash[2]);
void HighwayHashCatFinish256(const HighwayHashCat* state, uint64_t hash[4]);



/*
This code is compatible with C90 with the additional requirement of
supporting uint64_t.
*/

/*////////////////////////////////////////////////////////////////////////////*/
/* Internal implementation                                                    */
/*////////////////////////////////////////////////////////////////////////////*/

/// this is a weird "fix" for gcc bug https://github.com/fcorbelli/zpaqfranz/issues/71
/// please don't ask anything, took a couple of hours

void fixgcc(const char* fmt, ...)
{
   va_list args;
   va_start(args, fmt);
   va_end(args);
}

void HighwayHashReset(const uint64_t key[4], HighwayHashState* state) {
  state->mul0[0] = 0xdbe6d5d5fe4cce2full;
  state->mul0[1] = 0xa4093822299f31d0ull;
  state->mul0[2] = 0x13198a2e03707344ull;
  state->mul0[3] = 0x243f6a8885a308d3ull;
  state->mul1[0] = 0x3bd39e10cb0ef593ull;
  state->mul1[1] = 0xc0acf169b5f18a8cull;
  state->mul1[2] = 0xbe5466cf34e90c6cull;
  state->mul1[3] = 0x452821e638d01377ull;
  state->v0[0] = state->mul0[0] ^ key[0];
  state->v0[1] = state->mul0[1] ^ key[1];
  state->v0[2] = state->mul0[2] ^ key[2];
  state->v0[3] = state->mul0[3] ^ key[3];
  state->v1[0] = state->mul1[0] ^ ((key[0] >> 32) | (key[0] << 32));
  state->v1[1] = state->mul1[1] ^ ((key[1] >> 32) | (key[1] << 32));
  state->v1[2] = state->mul1[2] ^ ((key[2] >> 32) | (key[2] << 32));
	fixgcc("ciao");
  state->v1[3] = state->mul1[3] ^ ((key[3] >> 32) | (key[3] << 32));
}

static void ZipperMergeAndAdd(const uint64_t v1, const uint64_t v0,
                              uint64_t* add1, uint64_t* add0) {
  *add0 += (((v0 & 0xff000000ull) | (v1 & 0xff00000000ull)) >> 24) |
           (((v0 & 0xff0000000000ull) | (v1 & 0xff000000000000ull)) >> 16) |
           (v0 & 0xff0000ull) | ((v0 & 0xff00ull) << 32) |
           ((v1 & 0xff00000000000000ull) >> 8) | (v0 << 56);
  *add1 += (((v1 & 0xff000000ull) | (v0 & 0xff00000000ull)) >> 24) |
           (v1 & 0xff0000ull) | ((v1 & 0xff0000000000ull) >> 16) |
           ((v1 & 0xff00ull) << 24) | ((v0 & 0xff000000000000ull) >> 8) |
           ((v1 & 0xffull) << 48) | (v0 & 0xff00000000000000ull);
}

static void Update(const uint64_t lanes[4], HighwayHashState* state) {
  int i;
  for (i = 0; i < 4; ++i) {
    state->v1[i] += state->mul0[i] + lanes[i];
    state->mul0[i] ^= (state->v1[i] & 0xffffffff) * (state->v0[i] >> 32);
    state->v0[i] += state->mul1[i];
    state->mul1[i] ^= (state->v0[i] & 0xffffffff) * (state->v1[i] >> 32);
  }
  ZipperMergeAndAdd(state->v1[1], state->v1[0], &state->v0[1], &state->v0[0]);
  ZipperMergeAndAdd(state->v1[3], state->v1[2], &state->v0[3], &state->v0[2]);
  ZipperMergeAndAdd(state->v0[1], state->v0[0], &state->v1[1], &state->v1[0]);
  ZipperMergeAndAdd(state->v0[3], state->v0[2], &state->v1[3], &state->v1[2]);
}

static uint64_t Read64(const uint8_t* src) {
  return (uint64_t)src[0] | ((uint64_t)src[1] << 8) |
      ((uint64_t)src[2] << 16) | ((uint64_t)src[3] << 24) |
      ((uint64_t)src[4] << 32) | ((uint64_t)src[5] << 40) |
      ((uint64_t)src[6] << 48) | ((uint64_t)src[7] << 56);
}

void HighwayHashUpdatePacket(const uint8_t* packet, HighwayHashState* state) {
  uint64_t lanes[4];
  lanes[0] = Read64(packet + 0);
  lanes[1] = Read64(packet + 8);
  lanes[2] = Read64(packet + 16);
  lanes[3] = Read64(packet + 24);
  Update(lanes, state);
}

static void Rotate32By(uint64_t count, uint64_t lanes[4]) {
  int i;
  for (i = 0; i < 4; ++i) {
    uint32_t half0 = lanes[i] & 0xffffffff;
    uint32_t half1 = (lanes[i] >> 32);
    lanes[i] = (half0 << count) | (half0 >> (32 - count));
    lanes[i] |= (uint64_t)((half1 << count) | (half1 >> (32 - count))) << 32;
  }
}

void HighwayHashUpdateRemainder(const uint8_t* bytes, const size_t size_mod32,
                                HighwayHashState* state) {
  int i;
  const size_t size_mod4 = size_mod32 & 3;
  const uint8_t* remainder = bytes + (size_mod32 & ~3);
  uint8_t packet[32] = {0};
  for (i = 0; i < 4; ++i) {
    state->v0[i] += ((uint64_t)size_mod32 << 32) + size_mod32;
  }
  Rotate32By(size_mod32, state->v1);
  for (i = 0; i < remainder - bytes; i++) {
    packet[i] = bytes[i];
  }
  if (size_mod32 & 16) {
    for (i = 0; i < 4; i++) {
      packet[28 + i] = remainder[i + size_mod4 - 4];
    }
  } else {
    if (size_mod4) {
      packet[16 + 0] = remainder[0];
      packet[16 + 1] = remainder[size_mod4 >> 1];
      packet[16 + 2] = remainder[size_mod4 - 1];
    }
  }
  HighwayHashUpdatePacket(packet, state);
}

static void Permute(const uint64_t v[4], uint64_t* permuted) {
  permuted[0] = (v[2] >> 32) | (v[2] << 32);
  permuted[1] = (v[3] >> 32) | (v[3] << 32);
  permuted[2] = (v[0] >> 32) | (v[0] << 32);
  permuted[3] = (v[1] >> 32) | (v[1] << 32);
}

void PermuteAndUpdate(HighwayHashState* state) {
  uint64_t permuted[4];
  Permute(state->v0, permuted);
  Update(permuted, state);
}

static void ModularReduction(uint64_t a3_unmasked, uint64_t a2, uint64_t a1,
                             uint64_t a0, uint64_t* m1, uint64_t* m0) {
  uint64_t a3 = a3_unmasked & 0x3FFFFFFFFFFFFFFFull;
  *m1 = a1 ^ ((a3 << 1) | (a2 >> 63)) ^ ((a3 << 2) | (a2 >> 62));
  *m0 = a0 ^ (a2 << 1) ^ (a2 << 2);
}

static uint64_t HighwayHashFinalize64(HighwayHashState* state) {
  int i;
  for (i = 0; i < 4; i++) {
    PermuteAndUpdate(state);
  }

  return state->v0[0] + state->v1[0] + state->mul0[0] + state->mul1[0];
}

static void HighwayHashFinalize128(HighwayHashState* state, uint64_t hash[2]) {
  int i;

  for (i = 0; i < 6; i++) {
    PermuteAndUpdate(state);
  }

  hash[0] = state->v0[0] + state->mul0[0] + state->v1[2] + state->mul1[2];
  hash[1] = state->v0[1] + state->mul0[1] + state->v1[3] + state->mul1[3];
}

static void HighwayHashFinalize256(HighwayHashState* state, uint64_t hash[4]) {
  int i;
  /* We anticipate that 256-bit hashing will be mostly used with long messages
     because storing and using the 256-bit hash (in contrast to 128-bit)
     carries a larger additional constant cost by itself. Doing extra rounds
     here hardly increases the per-byte cost of long messages. */
  for (i = 0; i < 10; i++) {
    PermuteAndUpdate(state);
  }
  ModularReduction(state->v1[1] + state->mul1[1], state->v1[0] + state->mul1[0],
                   state->v0[1] + state->mul0[1], state->v0[0] + state->mul0[0],
                   &hash[1], &hash[0]);
  ModularReduction(state->v1[3] + state->mul1[3], state->v1[2] + state->mul1[2],
                   state->v0[3] + state->mul0[3], state->v0[2] + state->mul0[2],
                   &hash[3], &hash[2]);
}



/*////////////////////////////////////////////////////////////////////////////*/
/* Cat API: allows appending with multiple calls                              */
/*////////////////////////////////////////////////////////////////////////////*/

void HighwayHashCatStart(const uint64_t key[4], HighwayHashCat* state) {
  HighwayHashReset(key, &state->state);
  state->num = 0;
}

void HighwayHashCatAppend(const uint8_t* bytes, size_t num,
                          HighwayHashCat* state) {
  size_t i;
  if (state->num != 0) {
    size_t num_add = num > (32u - state->num) ? (32u - state->num) : num;
    for (i = 0; i < num_add; i++) {
      state->packet[state->num + i] = bytes[i];
    }
    state->num += num_add;
    num -= num_add;
    bytes += num_add;
    if (state->num == 32) {
      HighwayHashUpdatePacket(state->packet, &state->state);
      state->num = 0;
    }
  }
  while (num >= 32) {
    HighwayHashUpdatePacket(bytes, &state->state);
    num -= 32;
    bytes += 32;
  }
  for (i = 0; i < num; i++) {
    state->packet[state->num] = bytes[i];
    state->num++;
  }
}

uint64_t HighwayHashCatFinish64(const HighwayHashCat* state) {
  HighwayHashState copy = state->state;
  if (state->num) {
    HighwayHashUpdateRemainder(state->packet, state->num, &copy);
  }
  return HighwayHashFinalize64(&copy);
}

void HighwayHashCatFinish128(const HighwayHashCat* state, uint64_t hash[2]) {
  HighwayHashState copy = state->state;
  if (state->num) {
    HighwayHashUpdateRemainder(state->packet, state->num, &copy);
  }
  HighwayHashFinalize128(&copy, hash);
}

void HighwayHashCatFinish256(const HighwayHashCat* state, uint64_t hash[4]) {
  HighwayHashState copy = state->state;
  if (state->num) {
    HighwayHashUpdateRemainder(state->packet, state->num, &copy);
  }
  HighwayHashFinalize256(&copy, hash);
}
/// LICENSE_END.18



/// LICENSE_START.11
// //////////////////////////////////////////////////////////
// sha3.h
// Copyright (c) 2014,2015 Stephan Brumme. All rights reserved.
// see http://create.stephan-brumme.com/disclaimer.html
//
class SHA3
{
public:
  enum Bits { Bits224 = 224, Bits256 = 256, Bits384 = 384, Bits512 = 512 };
  explicit SHA3(Bits bits = Bits256);
  void add(const void* data, size_t numBytes);
  std::string getHash();
  void reset();
private:
  void processBlock(const void* data);
  void processBuffer();
  /// 1600 bits, stored as 25x64 bit, BlockSize is no more than 1152 bits (Keccak224)
  enum { StateSize    = 1600 / (8 * 8),
         MaxBlockSize =  200 - 2 * (224 / 8) };
  /// hash
  uint64_t m_hash[StateSize];
  /// size of processed data in bytes
  uint64_t m_numBytes;
  /// block size (less or equal to MaxBlockSize)
  size_t   m_blockSize;
  /// valid bytes in m_buffer
  size_t   m_bufferSize;
  /// bytes not processed yet
  uint8_t  m_buffer[MaxBlockSize];
  /// variant
  Bits     m_bits;
};
SHA3::SHA3(Bits bits)
: m_blockSize(200 - 2 * (bits / 8)),
  m_bits(bits)
{
	memset(m_hash, 0, sizeof(m_hash));

  reset();
}
void SHA3::reset()
{
  for (size_t i = 0; i < StateSize; i++)
    m_hash[i] = 0;
  m_numBytes   = 0;
  m_bufferSize = 0;
}
namespace
{
  const unsigned int Rounds = 24;
  const uint64_t XorMasks[Rounds] =
  {
    0x0000000000000001ULL, 0x0000000000008082ULL, 0x800000000000808aULL,
    0x8000000080008000ULL, 0x000000000000808bULL, 0x0000000080000001ULL,
    0x8000000080008081ULL, 0x8000000000008009ULL, 0x000000000000008aULL,
    0x0000000000000088ULL, 0x0000000080008009ULL, 0x000000008000000aULL,
    0x000000008000808bULL, 0x800000000000008bULL, 0x8000000000008089ULL,
    0x8000000000008003ULL, 0x8000000000008002ULL, 0x8000000000000080ULL,
    0x000000000000800aULL, 0x800000008000000aULL, 0x8000000080008081ULL,
    0x8000000000008080ULL, 0x0000000080000001ULL, 0x8000000080008008ULL
  };
  inline uint64_t rotateLeft(uint64_t x, uint8_t numBits)
  {
    return (x << numBits) | (x >> (64 - numBits));
  }
  /// convert litte vs big endian
#ifdef BIG
  inline uint64_t swap(uint64_t x)
  {
#ifdef ANCIENT
  return  (x >> 56) |
           ((x >> 40) & 0x000000000000FF00ULL) |
           ((x >> 24) & 0x0000000000FF0000ULL) |
           ((x >>  8) & 0x00000000FF000000ULL) |
           ((x <<  8) & 0x000000FF00000000ULL) |
           ((x << 24) & 0x0000FF0000000000ULL) |
           ((x << 40) & 0x00FF000000000000ULL) |
            (x << 56);
#else
    return __builtin_bswap64(x);
#endif // corresponds to #ifdef (#ifdef ANCIENT)
  }
#endif // corresponds to #ifdef (#ifdef BIG)
  unsigned int mod5(unsigned int x)
  {
    if (x < 5)
      return x;
    return x - 5;
  }
}
void SHA3::processBlock(const void* data)
{
#ifdef BIG
#define MYLITTLEENDIAN2(x) swap(x)
#else
#define MYLITTLEENDIAN2(x) (x)
#endif // corresponds to #ifdef (#ifdef BIG)
  const uint64_t* data64 = (const uint64_t*) data;
  for (unsigned int i = 0; i < m_blockSize / 8; i++)
    m_hash[i] ^= MYLITTLEENDIAN2(data64[i]);
  for (unsigned int round = 0; round < Rounds; round++)
  {
    uint64_t coefficients[5];
    for (unsigned int i = 0; i < 5; i++)
      coefficients[i] = m_hash[i] ^ m_hash[i + 5] ^ m_hash[i + 10] ^ m_hash[i + 15] ^ m_hash[i + 20];
    for (unsigned int i = 0; i < 5; i++)
    {
      uint64_t one = coefficients[mod5(i + 4)] ^ rotateLeft(coefficients[mod5(i + 1)], 1);
      m_hash[i     ] ^= one;
      m_hash[i +  5] ^= one;
      m_hash[i + 10] ^= one;
      m_hash[i + 15] ^= one;
      m_hash[i + 20] ^= one;
    }
    uint64_t one;
    uint64_t last = m_hash[1];
    one = m_hash[10]; m_hash[10] = rotateLeft(last,  1); last = one;
    one = m_hash[ 7]; m_hash[ 7] = rotateLeft(last,  3); last = one;
    one = m_hash[11]; m_hash[11] = rotateLeft(last,  6); last = one;
    one = m_hash[17]; m_hash[17] = rotateLeft(last, 10); last = one;
    one = m_hash[18]; m_hash[18] = rotateLeft(last, 15); last = one;
    one = m_hash[ 3]; m_hash[ 3] = rotateLeft(last, 21); last = one;
    one = m_hash[ 5]; m_hash[ 5] = rotateLeft(last, 28); last = one;
    one = m_hash[16]; m_hash[16] = rotateLeft(last, 36); last = one;
    one = m_hash[ 8]; m_hash[ 8] = rotateLeft(last, 45); last = one;
    one = m_hash[21]; m_hash[21] = rotateLeft(last, 55); last = one;
    one = m_hash[24]; m_hash[24] = rotateLeft(last,  2); last = one;
    one = m_hash[ 4]; m_hash[ 4] = rotateLeft(last, 14); last = one;
    one = m_hash[15]; m_hash[15] = rotateLeft(last, 27); last = one;
    one = m_hash[23]; m_hash[23] = rotateLeft(last, 41); last = one;
    one = m_hash[19]; m_hash[19] = rotateLeft(last, 56); last = one;
    one = m_hash[13]; m_hash[13] = rotateLeft(last,  8); last = one;
    one = m_hash[12]; m_hash[12] = rotateLeft(last, 25); last = one;
    one = m_hash[ 2]; m_hash[ 2] = rotateLeft(last, 43); last = one;
    one = m_hash[20]; m_hash[20] = rotateLeft(last, 62); last = one;
    one = m_hash[14]; m_hash[14] = rotateLeft(last, 18); last = one;
    one = m_hash[22]; m_hash[22] = rotateLeft(last, 39); last = one;
    one = m_hash[ 9]; m_hash[ 9] = rotateLeft(last, 61); last = one;
    one = m_hash[ 6]; m_hash[ 6] = rotateLeft(last, 20); last = one;
                      m_hash[ 1] = rotateLeft(last, 44);
    for (unsigned int j = 0; j < StateSize; j += 5)
    {
      uint64_t one = m_hash[j];
      uint64_t two = m_hash[j + 1];
      m_hash[j]     ^= m_hash[j + 2] & ~two;
      m_hash[j + 1] ^= m_hash[j + 3] & ~m_hash[j + 2];
      m_hash[j + 2] ^= m_hash[j + 4] & ~m_hash[j + 3];
      m_hash[j + 3] ^=      one      & ~m_hash[j + 4];
      m_hash[j + 4] ^=      two      & ~one;
    }
    m_hash[0] ^= XorMasks[round];
  }
}
void SHA3::add(const void* data, size_t numBytes)
{
  const uint8_t* current = (const uint8_t*) data;
  // copy data to buffer
  if (m_bufferSize > 0)
    while (numBytes > 0 && m_bufferSize < m_blockSize)
    {
      m_buffer[m_bufferSize++] = *current++;
      numBytes--;
    }
  // full buffer
  if (m_bufferSize == m_blockSize)
  {
    processBlock((void*)m_buffer);
    m_numBytes  += m_blockSize;
    m_bufferSize = 0;
  }
  // no more data ?
  if (numBytes == 0)
    return;
  // process full blocks
  while (numBytes >= m_blockSize)
  {
    processBlock(current);
    current    += m_blockSize;
    m_numBytes += m_blockSize;
    numBytes   -= m_blockSize;
  }
  // keep remaining bytes in buffer
  while (numBytes > 0)
  {
    m_buffer[m_bufferSize++] = *current++;
    numBytes--;
  }
}
void SHA3::processBuffer()
{
  // add padding
  size_t offset = m_bufferSize;
  // add a "1" byte
  m_buffer[offset++] = 0x06;
  // fill with zeros
  while (offset < m_blockSize)
    m_buffer[offset++] = 0;
  // and add a single set bit
  m_buffer[offset - 1] |= 0x80;
  processBlock(m_buffer);
}
std::string SHA3::getHash()
{
  // save hash state
  uint64_t oldHash[StateSize];
  for (unsigned int i = 0; i < StateSize; i++)
    oldHash[i] = m_hash[i];
  processBuffer();
  static const char dec2hex[16 + 1] = "0123456789ABCDEF";
  // number of significant elements in hash (uint64_t)
  unsigned int hashLength = m_bits / 64;
  std::string result;
  result.reserve(m_bits / 4);
  for (unsigned int i = 0; i < hashLength; i++)
    for (unsigned int j = 0; j < 8; j++) // 64 bits => 8 bytes
    {
      // convert a byte to hex
      unsigned char oneByte = (unsigned char) (m_hash[i] >> (8 * j));
      result += dec2hex[oneByte >> 4];
      result += dec2hex[oneByte & 15];
    }
  // SHA3-224's last entry in m_hash provides only 32 bits instead of 64 bits
  unsigned int remainder = m_bits - hashLength * 64;
  unsigned int processed = 0;
  while (processed < remainder)
  {
    // convert a byte to hex
    unsigned char oneByte = (unsigned char) (m_hash[hashLength] >> processed);
    result += dec2hex[oneByte >> 4];
    result += dec2hex[oneByte & 15];
    processed += 8;
  }
  // restore state
  for (unsigned int i = 0; i < StateSize; i++)
    m_hash[i] = oldHash[i];
  return result;
}
// //////////////////////////////////////////////////////////
// md5.h
// Copyright (c) 2014 Stephan Brumme. All rights reserved.
// see http://create.stephan-brumme.com/disclaimer.html
//
/** Usage:
    MD5 md5;
    while (more data available)
      md5.add(pointer to fresh data, number of new bytes);
    std::string myHash3 = md5.getHash();
  */
class MD5
{
public:
  /// split into 64 byte blocks (=> 512 bits), hash is 16 bytes long
  enum { BlockSize = 512 / 8, HashBytes = 16 };
  MD5();
  void add(const void* data, size_t numBytes);
  std::string getHash();
  void getHash(unsigned char buffer[HashBytes]);
  void reset();
private:
  void processBlock(const void* data);
  void processBuffer();
  /// size of processed data in bytes
  uint64_t m_numBytes;
  /// valid bytes in m_buffer
  size_t   m_bufferSize;
  /// bytes not processed yet
  uint8_t  m_buffer[BlockSize];
  enum { HashValues = HashBytes / 4 };
  /// hash, stored as integers
  uint32_t m_hash[HashValues];
};
/// same as reset()
MD5::MD5()
{
  reset();
}
/// restart
void MD5::reset()
{
  m_numBytes   = 0;
  m_bufferSize = 0;
  // according to RFC 1321
  m_hash[0] = 0x67452301;
  m_hash[1] = 0xefcdab89;
  m_hash[2] = 0x98badcfe;
  m_hash[3] = 0x10325476;
}
namespace
{
  // mix functions for processBlock()
  inline uint32_t f1(uint32_t b, uint32_t c, uint32_t d)
  {
    return d ^ (b & (c ^ d)); // original: f = (b & c) | ((~b) & d);
  }
  inline uint32_t f2(uint32_t b, uint32_t c, uint32_t d)
  {
    return c ^ (d & (b ^ c)); // original: f = (b & d) | (c & (~d));
  }
  inline uint32_t f3(uint32_t b, uint32_t c, uint32_t d)
  {
    return b ^ c ^ d;
  }
  inline uint32_t f4(uint32_t b, uint32_t c, uint32_t d)
  {
    return c ^ (b | ~d);
  }
  inline uint32_t rotate(uint32_t a, uint32_t c)
  {
    return (a << c) | (a >> (32 - c));
  }
#if defined(__BYTE_ORDER) && (__BYTE_ORDER != 0) && (__BYTE_ORDER == __BIG_ENDIAN)
  static inline uint32_t swap(uint32_t x)
  {
#ifdef ANCIENT
    return (x >> 24) |
          ((x >>  8) & 0x0000FF00) |
          ((x <<  8) & 0x00FF0000) |
           (x << 24);
#else
    return __builtin_bswap32(x);
#endif // corresponds to #ifdef (#ifdef ANCIENT)
  }

#endif // corresponds to #if (#if defined(__BYTE_ORDER) && (__BYTE_ORDER != 0) && (__BYTE_ORDER == __BIG_ENDIAN))
}
/// process 64 bytes
void MD5::processBlock(const void* data)
{
  // get last hash
  uint32_t a = m_hash[0];
  uint32_t b = m_hash[1];
  uint32_t c = m_hash[2];
  uint32_t d = m_hash[3];
  // data represented as 16x 32-bit words
  const uint32_t* words = (uint32_t*) data;
  // computations are little endian, swap data if necessary
#if defined(__BYTE_ORDER) && (__BYTE_ORDER != 0) && (__BYTE_ORDER == __BIG_ENDIAN)
#define MYLITTLEENDIAN(x) swap(x)
#else
#define MYLITTLEENDIAN(x) (x)
#endif // corresponds to #if (#if defined(__BYTE_ORDER) && (__BYTE_ORDER != 0) && (__BYTE_ORDER == __BIG_ENDIAN))
  // first round
  uint32_t word0  = MYLITTLEENDIAN(words[ 0]);
  a = rotate(a + f1(b,c,d) + word0  + 0xd76aa478,  7) + b;
  uint32_t word1  = MYLITTLEENDIAN(words[ 1]);
  d = rotate(d + f1(a,b,c) + word1  + 0xe8c7b756, 12) + a;
  uint32_t word2  = MYLITTLEENDIAN(words[ 2]);
  c = rotate(c + f1(d,a,b) + word2  + 0x242070db, 17) + d;
  uint32_t word3  = MYLITTLEENDIAN(words[ 3]);
  b = rotate(b + f1(c,d,a) + word3  + 0xc1bdceee, 22) + c;
  uint32_t word4  = MYLITTLEENDIAN(words[ 4]);
  a = rotate(a + f1(b,c,d) + word4  + 0xf57c0faf,  7) + b;
  uint32_t word5  = MYLITTLEENDIAN(words[ 5]);
  d = rotate(d + f1(a,b,c) + word5  + 0x4787c62a, 12) + a;
  uint32_t word6  = MYLITTLEENDIAN(words[ 6]);
  c = rotate(c + f1(d,a,b) + word6  + 0xa8304613, 17) + d;
  uint32_t word7  = MYLITTLEENDIAN(words[ 7]);
  b = rotate(b + f1(c,d,a) + word7  + 0xfd469501, 22) + c;
  uint32_t word8  = MYLITTLEENDIAN(words[ 8]);
  a = rotate(a + f1(b,c,d) + word8  + 0x698098d8,  7) + b;
  uint32_t word9  = MYLITTLEENDIAN(words[ 9]);
  d = rotate(d + f1(a,b,c) + word9  + 0x8b44f7af, 12) + a;
  uint32_t word10 = MYLITTLEENDIAN(words[10]);
  c = rotate(c + f1(d,a,b) + word10 + 0xffff5bb1, 17) + d;
  uint32_t word11 = MYLITTLEENDIAN(words[11]);
  b = rotate(b + f1(c,d,a) + word11 + 0x895cd7be, 22) + c;
  uint32_t word12 = MYLITTLEENDIAN(words[12]);
  a = rotate(a + f1(b,c,d) + word12 + 0x6b901122,  7) + b;
  uint32_t word13 = MYLITTLEENDIAN(words[13]);
  d = rotate(d + f1(a,b,c) + word13 + 0xfd987193, 12) + a;
  uint32_t word14 = MYLITTLEENDIAN(words[14]);
  c = rotate(c + f1(d,a,b) + word14 + 0xa679438e, 17) + d;
  uint32_t word15 = MYLITTLEENDIAN(words[15]);
  b = rotate(b + f1(c,d,a) + word15 + 0x49b40821, 22) + c;
  // second round
  a = rotate(a + f2(b,c,d) + word1  + 0xf61e2562,  5) + b;
  d = rotate(d + f2(a,b,c) + word6  + 0xc040b340,  9) + a;
  c = rotate(c + f2(d,a,b) + word11 + 0x265e5a51, 14) + d;
  b = rotate(b + f2(c,d,a) + word0  + 0xe9b6c7aa, 20) + c;
  a = rotate(a + f2(b,c,d) + word5  + 0xd62f105d,  5) + b;
  d = rotate(d + f2(a,b,c) + word10 + 0x02441453,  9) + a;
  c = rotate(c + f2(d,a,b) + word15 + 0xd8a1e681, 14) + d;
  b = rotate(b + f2(c,d,a) + word4  + 0xe7d3fbc8, 20) + c;
  a = rotate(a + f2(b,c,d) + word9  + 0x21e1cde6,  5) + b;
  d = rotate(d + f2(a,b,c) + word14 + 0xc33707d6,  9) + a;
  c = rotate(c + f2(d,a,b) + word3  + 0xf4d50d87, 14) + d;
  b = rotate(b + f2(c,d,a) + word8  + 0x455a14ed, 20) + c;
  a = rotate(a + f2(b,c,d) + word13 + 0xa9e3e905,  5) + b;
  d = rotate(d + f2(a,b,c) + word2  + 0xfcefa3f8,  9) + a;
  c = rotate(c + f2(d,a,b) + word7  + 0x676f02d9, 14) + d;
  b = rotate(b + f2(c,d,a) + word12 + 0x8d2a4c8a, 20) + c;
  // third round
  a = rotate(a + f3(b,c,d) + word5  + 0xfffa3942,  4) + b;
  d = rotate(d + f3(a,b,c) + word8  + 0x8771f681, 11) + a;
  c = rotate(c + f3(d,a,b) + word11 + 0x6d9d6122, 16) + d;
  b = rotate(b + f3(c,d,a) + word14 + 0xfde5380c, 23) + c;
  a = rotate(a + f3(b,c,d) + word1  + 0xa4beea44,  4) + b;
  d = rotate(d + f3(a,b,c) + word4  + 0x4bdecfa9, 11) + a;
  c = rotate(c + f3(d,a,b) + word7  + 0xf6bb4b60, 16) + d;
  b = rotate(b + f3(c,d,a) + word10 + 0xbebfbc70, 23) + c;
  a = rotate(a + f3(b,c,d) + word13 + 0x289b7ec6,  4) + b;
  d = rotate(d + f3(a,b,c) + word0  + 0xeaa127fa, 11) + a;
  c = rotate(c + f3(d,a,b) + word3  + 0xd4ef3085, 16) + d;
  b = rotate(b + f3(c,d,a) + word6  + 0x04881d05, 23) + c;
  a = rotate(a + f3(b,c,d) + word9  + 0xd9d4d039,  4) + b;
  d = rotate(d + f3(a,b,c) + word12 + 0xe6db99e5, 11) + a;
  c = rotate(c + f3(d,a,b) + word15 + 0x1fa27cf8, 16) + d;
  b = rotate(b + f3(c,d,a) + word2  + 0xc4ac5665, 23) + c;
  // fourth round
  a = rotate(a + f4(b,c,d) + word0  + 0xf4292244,  6) + b;
  d = rotate(d + f4(a,b,c) + word7  + 0x432aff97, 10) + a;
  c = rotate(c + f4(d,a,b) + word14 + 0xab9423a7, 15) + d;
  b = rotate(b + f4(c,d,a) + word5  + 0xfc93a039, 21) + c;
  a = rotate(a + f4(b,c,d) + word12 + 0x655b59c3,  6) + b;
  d = rotate(d + f4(a,b,c) + word3  + 0x8f0ccc92, 10) + a;
  c = rotate(c + f4(d,a,b) + word10 + 0xffeff47d, 15) + d;
  b = rotate(b + f4(c,d,a) + word1  + 0x85845dd1, 21) + c;
  a = rotate(a + f4(b,c,d) + word8  + 0x6fa87e4f,  6) + b;
  d = rotate(d + f4(a,b,c) + word15 + 0xfe2ce6e0, 10) + a;
  c = rotate(c + f4(d,a,b) + word6  + 0xa3014314, 15) + d;
  b = rotate(b + f4(c,d,a) + word13 + 0x4e0811a1, 21) + c;
  a = rotate(a + f4(b,c,d) + word4  + 0xf7537e82,  6) + b;
  d = rotate(d + f4(a,b,c) + word11 + 0xbd3af235, 10) + a;
  c = rotate(c + f4(d,a,b) + word2  + 0x2ad7d2bb, 15) + d;
  b = rotate(b + f4(c,d,a) + word9  + 0xeb86d391, 21) + c;
  // update hash
  m_hash[0] += a;
  m_hash[1] += b;
  m_hash[2] += c;
  m_hash[3] += d;
}
/// add arbitrary number of bytes
void MD5::add(const void* data, size_t numBytes)
{
  const uint8_t* current = (const uint8_t*) data;
  if (m_bufferSize > 0)
  {
    while (numBytes > 0 && m_bufferSize < BlockSize)
    {
      m_buffer[m_bufferSize++] = *current++;
      numBytes--;
    }
  }
  // full buffer
  if (m_bufferSize == BlockSize)
  {
    processBlock(m_buffer);
    m_numBytes  += BlockSize;
    m_bufferSize = 0;
  }
  // no more data ?
  if (numBytes == 0)
    return;
  // process full blocks
  while (numBytes >= BlockSize)
  {
    processBlock(current);
    current    += BlockSize;
    m_numBytes += BlockSize;
    numBytes   -= BlockSize;
  }
  // keep remaining bytes in buffer
  while (numBytes > 0)
  {
    m_buffer[m_bufferSize++] = *current++;
    numBytes--;
  }
}
/// process final block, less than 64 bytes
void MD5::processBuffer()
{
  // the input bytes are considered as bits strings, where the first bit is the most significant bit of the byte
  // - append "1" bit to message
  // - append "0" bits until message length in bit mod 512 is 448
  // - append length as 64 bit integer
  // number of bits
  size_t paddedLength = m_bufferSize * 8;
  // plus one bit set to 1 (always appended)
  paddedLength++;
  // number of bits must be (numBits % 512) = 448
  size_t lower11Bits = paddedLength & 511;
  if (lower11Bits <= 448)
    paddedLength +=       448 - lower11Bits;
  else
    paddedLength += 512 + 448 - lower11Bits;
  // convert from bits to bytes
  paddedLength /= 8;
  // only needed if additional data flows over into a second block
  unsigned char extra[BlockSize];
  // append a "1" bit, 128 => binary 10000000
  if (m_bufferSize < BlockSize)
    m_buffer[m_bufferSize] = 128;
  else
    extra[0] = 128;
  size_t i;
  for (i = m_bufferSize + 1; i < BlockSize; i++)
    m_buffer[i] = 0;
  for (; i < paddedLength; i++)
    extra[i - BlockSize] = 0;
  // add message length in bits as 64 bit number
  uint64_t msgBits = 8 * (m_numBytes + m_bufferSize);
  // find right position
  unsigned char* addLength;
  if (paddedLength < BlockSize)
    addLength = m_buffer + paddedLength;
  else
    addLength = extra + paddedLength - BlockSize;
  // must be little endian
  *addLength++ = msgBits & 0xFF; msgBits >>= 8;
  *addLength++ = msgBits & 0xFF; msgBits >>= 8;
  *addLength++ = msgBits & 0xFF; msgBits >>= 8;
  *addLength++ = msgBits & 0xFF; msgBits >>= 8;
  *addLength++ = msgBits & 0xFF; msgBits >>= 8;
  *addLength++ = msgBits & 0xFF; msgBits >>= 8;
  *addLength++ = msgBits & 0xFF; msgBits >>= 8;
  *addLength++ = msgBits & 0xFF;
  // process blocks
  processBlock(m_buffer);
  // flowed over into a second block ?
  if (paddedLength > BlockSize)
    processBlock(extra);
}
/// return latest hash as 32 hex characters
std::string MD5::getHash()
{
  // compute hash (as raw bytes)
  unsigned char rawHash[HashBytes];
  getHash(rawHash);
  // convert to hex string
  std::string result;
  result.reserve(2 * HashBytes);
  for (int i = 0; i < HashBytes; i++)
  {
    static const char dec2hex[16+1] = "0123456789ABCDEF";
    result += dec2hex[(rawHash[i] >> 4) & 15];
    result += dec2hex[ rawHash[i]       & 15];
  }
  return result;
}
/// return latest hash as bytes
void MD5::getHash(unsigned char buffer[MD5::HashBytes])
{
  // save old hash if buffer is partially filled
  uint32_t oldHash[HashValues];
  for (int i = 0; i < HashValues; i++)
    oldHash[i] = m_hash[i];
  // process remaining bytes
  processBuffer();
  unsigned char* current = buffer;
  for (int i = 0; i < HashValues; i++)
  {
    *current++ =  m_hash[i]        & 0xFF;
    *current++ = (m_hash[i] >>  8) & 0xFF;
    *current++ = (m_hash[i] >> 16) & 0xFF;
    *current++ = (m_hash[i] >> 24) & 0xFF;
    // restore old hash
    m_hash[i] = oldHash[i];
  }
}
/// LICENSE_END.11



/// LICENSE_START.15
#if !defined(HWBLAKE3)
// Sligthly reworked to compile on C++ (and FreeBSD)
#define BLAKE3_KEY_LEN 32
#define BLAKE3_OUT_LEN 32
#define BLAKE3_BLOCK_LEN 64
#define BLAKE3_CHUNK_LEN 1024
#define BLAKE3_MAX_DEPTH 54
typedef struct {
  uint32_t cv[8];
  uint64_t chunk_counter;
  uint8_t buf[BLAKE3_BLOCK_LEN];
  uint8_t buf_len;
  uint8_t blocks_compressed;
  uint8_t flags;
} blake3_chunk_state;
typedef struct {
  uint32_t key[8];
  blake3_chunk_state chunk;
  uint8_t cv_stack_len;
  uint8_t cv_stack[(BLAKE3_MAX_DEPTH + 1) * BLAKE3_OUT_LEN];
} blake3_hasher;
void blake3_hasher_init(blake3_hasher *self);
void blake3_hasher_update(blake3_hasher *self, const void *input,
                          size_t input_len);
void blake3_hasher_finalize(const blake3_hasher *self, uint8_t *out,
                            size_t out_len);
void blake3_hasher_finalize_seek(const blake3_hasher *self, uint64_t seek,
                                 uint8_t *out, size_t out_len);
enum blake3_flags {
  CHUNK_START         = 1 << 0,
  CHUNK_END           = 1 << 1,
  PARENT              = 1 << 2,
  ROOT                = 1 << 3,
  KEYED_HASH          = 1 << 4,
  DERIVE_KEY_CONTEXT  = 1 << 5,
  DERIVE_KEY_MATERIAL = 1 << 6
};
#define MAX_SIMD_DEGREE 1
#define MAX_SIMD_DEGREE_OR_2 (MAX_SIMD_DEGREE > 2 ? MAX_SIMD_DEGREE : 2)
static const uint32_t IV[8] = {0x6A09E667UL, 0xBB67AE85UL, 0x3C6EF372UL,
                               0xA54FF53AUL, 0x510E527FUL, 0x9B05688CUL,
                               0x1F83D9ABUL, 0x5BE0CD19UL};
static const uint8_t MSG_SCHEDULE[7][16] = {
    {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15},
    {2, 6, 3, 10, 7, 0, 4, 13, 1, 11, 12, 5, 9, 14, 15, 8},
    {3, 4, 10, 12, 13, 2, 7, 14, 6, 5, 9, 0, 11, 15, 8, 1},
    {10, 7, 12, 9, 14, 3, 13, 15, 4, 0, 11, 2, 5, 8, 1, 6},
    {12, 13, 9, 11, 15, 10, 14, 8, 7, 2, 5, 3, 0, 1, 6, 4},
    {9, 14, 11, 5, 8, 12, 15, 1, 13, 3, 0, 10, 2, 6, 4, 7},
    {11, 15, 5, 0, 1, 9, 8, 6, 14, 10, 2, 12, 3, 4, 7, 13},
};
static unsigned int highest_one(uint64_t x) {
#if defined(__GNUC__) || defined(__clang__)
  return 63 ^ __builtin_clzll(x);
#elif defined(_MSC_VER) && defined(IS_X86_64)
  unsigned long index;
  _BitScanReverse64(&index, x);
  return index;
#elif defined(_MSC_VER) && defined(IS_X86_32)
  if(x >> 32) {
    unsigned long index;
    _BitScanReverse(&index, x >> 32);
    return 32 + index;
  } else {
    unsigned long index;
    _BitScanReverse(&index, x);
    return index;
  }
#else
  unsigned int c = 0;
  if(x & 0xffffffff00000000ULL) { x >>= 32; c += 32; }
  if(x & 0x00000000ffff0000ULL) { x >>= 16; c += 16; }
  if(x & 0x000000000000ff00ULL) { x >>=  8; c +=  8; }
  if(x & 0x00000000000000f0ULL) { x >>=  4; c +=  4; }
  if(x & 0x000000000000000cULL) { x >>=  2; c +=  2; }
  if(x & 0x0000000000000002ULL) {           c +=  1; }
  return c;
#endif // corresponds to #if (#if defined(__GNUC__) || defined(__clang__))
}
INLINE_divsuf unsigned int popcnt(uint64_t x) {
#if defined(__GNUC__) || defined(__clang__)
  return __builtin_popcountll(x);
#else
  unsigned int count = 0;
  while (x != 0) {
    count += 1;
    x &= x - 1;
  }
  return count;
#endif // corresponds to #if (#if defined(__GNUC__) || defined(__clang__))
}
INLINE_divsuf uint64_t round_down_to_power_of_2(uint64_t x) {
  return 1ULL << highest_one(x | 1);
}
INLINE_divsuf uint32_t counter_low(uint64_t counter) { return (uint32_t)counter; }
INLINE_divsuf uint32_t counter_high(uint64_t counter) {
  return (uint32_t)(counter >> 32);
}
INLINE_divsuf uint32_t load32(const void *src) {
  const uint8_t *p = (const uint8_t *)src;
  return ((uint32_t)(p[0]) << 0) | ((uint32_t)(p[1]) << 8) |
         ((uint32_t)(p[2]) << 16) | ((uint32_t)(p[3]) << 24);
}
INLINE_divsuf void store32(void *dst, uint32_t w) {
  uint8_t *p = (uint8_t *)dst;
  p[0] = (uint8_t)(w >> 0);
  p[1] = (uint8_t)(w >> 8);
  p[2] = (uint8_t)(w >> 16);
  p[3] = (uint8_t)(w >> 24);
}
INLINE_divsuf void store_cv_words(uint8_t bytes_out[32], uint32_t cv_words[8]) {
  store32(&bytes_out[0 * 4], cv_words[0]);
  store32(&bytes_out[1 * 4], cv_words[1]);
  store32(&bytes_out[2 * 4], cv_words[2]);
  store32(&bytes_out[3 * 4], cv_words[3]);
  store32(&bytes_out[4 * 4], cv_words[4]);
  store32(&bytes_out[5 * 4], cv_words[5]);
  store32(&bytes_out[6 * 4], cv_words[6]);
  store32(&bytes_out[7 * 4], cv_words[7]);
}
void blake3_compress_in_place(uint32_t cv[8],
                              const uint8_t block[BLAKE3_BLOCK_LEN],
                              uint8_t block_len, uint64_t counter,
                              uint8_t flags);
void blake3_compress_xof(const uint32_t cv[8],
                         const uint8_t block[BLAKE3_BLOCK_LEN],
                         uint8_t block_len, uint64_t counter, uint8_t flags,
                         uint8_t out[64]);
void blake3_hash_many(const uint8_t *const *inputs, size_t num_inputs,
                      size_t blocks, const uint32_t key[8], uint64_t counter,
                      bool increment_counter, uint8_t flags,
                      uint8_t flags_start, uint8_t flags_end, uint8_t *out);
size_t blake3_simd_degree(void);
void blake3_compress_in_place_portable(uint32_t cv[8],
                                       const uint8_t block[BLAKE3_BLOCK_LEN],
                                       uint8_t block_len, uint64_t counter,
                                       uint8_t flags);
void blake3_compress_xof_portable(const uint32_t cv[8],
                                  const uint8_t block[BLAKE3_BLOCK_LEN],
                                  uint8_t block_len, uint64_t counter,
                                  uint8_t flags, uint8_t out[64]);
void blake3_hash_many_portable(const uint8_t *const *inputs, size_t num_inputs,
                               size_t blocks, const uint32_t key[8],
                               uint64_t counter, bool increment_counter,
                               uint8_t flags, uint8_t flags_start,
                               uint8_t flags_end, uint8_t *out);
INLINE_divsuf void chunk_state_init(blake3_chunk_state *self, const uint32_t key[8],
                             uint8_t flags) {
  memcpy(self->cv, key, BLAKE3_KEY_LEN);
  self->chunk_counter = 0;
  memset(self->buf, 0, BLAKE3_BLOCK_LEN);
  self->buf_len = 0;
  self->blocks_compressed = 0;
  self->flags = flags;
}
INLINE_divsuf void chunk_state_reset(blake3_chunk_state *self, const uint32_t key[8],
                              uint64_t chunk_counter) {
  memcpy(self->cv, key, BLAKE3_KEY_LEN);
  self->chunk_counter = chunk_counter;
  self->blocks_compressed = 0;
  memset(self->buf, 0, BLAKE3_BLOCK_LEN);
  self->buf_len = 0;
}
INLINE_divsuf size_t chunk_state_len(const blake3_chunk_state *self) {
  return (BLAKE3_BLOCK_LEN * (size_t)self->blocks_compressed) +
         ((size_t)self->buf_len);
}
INLINE_divsuf size_t chunk_state_fill_buf(blake3_chunk_state *self,
                                   const uint8_t *input, size_t input_len) {
  size_t take = BLAKE3_BLOCK_LEN - ((size_t)self->buf_len);
  if (take > input_len) {
    take = input_len;
  }
  uint8_t *dest = self->buf + ((size_t)self->buf_len);
  memcpy(dest, input, take);
  self->buf_len += (uint8_t)take;
  return take;
}
INLINE_divsuf uint8_t chunk_state_maybe_start_flag(const blake3_chunk_state *self) {
  if (self->blocks_compressed == 0) {
    return CHUNK_START;
  } else {
    return 0;
  }
}
typedef struct {
  uint32_t input_cv[8];
  uint64_t counter;
  uint8_t block[BLAKE3_BLOCK_LEN];
  uint8_t block_len;
  uint8_t flags;
} output_t;
INLINE_divsuf output_t make_output(const uint32_t input_cv[8],
                            const uint8_t block[BLAKE3_BLOCK_LEN],
                            uint8_t block_len, uint64_t counter,
                            uint8_t flags) {
  output_t ret;
  memcpy(ret.input_cv, input_cv, 32);
  memcpy(ret.block, block, BLAKE3_BLOCK_LEN);
  ret.block_len = block_len;
  ret.counter = counter;
  ret.flags = flags;
  return ret;
}
INLINE_divsuf void output_chaining_value(const output_t *self, uint8_t cv[32]) {
  uint32_t cv_words[8];
  memcpy(cv_words, self->input_cv, 32);
  blake3_compress_in_place(cv_words, self->block, self->block_len,
                           self->counter, self->flags);
  store_cv_words(cv, cv_words);
}
INLINE_divsuf void output_root_bytes(const output_t *self, uint64_t seek, uint8_t *out,
                              size_t out_len) {
  uint64_t output_block_counter = seek / 64;
  size_t offset_within_block = seek % 64;
  uint8_t wide_buf[64];
  while (out_len > 0) {
    blake3_compress_xof(self->input_cv, self->block, self->block_len,
                        output_block_counter, self->flags | ROOT, wide_buf);
    size_t available_bytes = 64 - offset_within_block;
    size_t memcpy_len;
    if (out_len > available_bytes) {
      memcpy_len = available_bytes;
    } else {
      memcpy_len = out_len;
    }
    memcpy(out, wide_buf + offset_within_block, memcpy_len);
    out += memcpy_len;
    out_len -= memcpy_len;
    output_block_counter += 1;
    offset_within_block = 0;
  }
}
INLINE_divsuf void chunk_state_update(blake3_chunk_state *self, const uint8_t *input,
                               size_t input_len) {
  if (self->buf_len > 0) {
    size_t take = chunk_state_fill_buf(self, input, input_len);
    input += take;
    input_len -= take;
    if (input_len > 0) {
      blake3_compress_in_place(
          self->cv, self->buf, BLAKE3_BLOCK_LEN, self->chunk_counter,
          self->flags | chunk_state_maybe_start_flag(self));
      self->blocks_compressed += 1;
      self->buf_len = 0;
      memset(self->buf, 0, BLAKE3_BLOCK_LEN);
    }
  }
  while (input_len > BLAKE3_BLOCK_LEN) {
    blake3_compress_in_place(self->cv, input, BLAKE3_BLOCK_LEN,
                             self->chunk_counter,
                             self->flags | chunk_state_maybe_start_flag(self));
    self->blocks_compressed += 1;
    input += BLAKE3_BLOCK_LEN;
    input_len -= BLAKE3_BLOCK_LEN;
  }
	(void)chunk_state_fill_buf(self, input, input_len);
///  size_t take = chunk_state_fill_buf(self, input, input_len);
///  input += take;
///  input_len -= take;
}
INLINE_divsuf output_t chunk_state_output(const blake3_chunk_state *self) {
  uint8_t block_flags =
      self->flags | chunk_state_maybe_start_flag(self) | CHUNK_END;
  return make_output(self->cv, self->buf, self->buf_len, self->chunk_counter,
                     block_flags);
}
INLINE_divsuf output_t parent_output(const uint8_t block[BLAKE3_BLOCK_LEN],
                              const uint32_t key[8], uint8_t flags) {
  return make_output(key, block, BLAKE3_BLOCK_LEN, 0, flags | PARENT);
}
INLINE_divsuf size_t left_len(size_t content_len) {
  size_t full_chunks = (content_len - 1) / BLAKE3_CHUNK_LEN;
  return round_down_to_power_of_2(full_chunks) * BLAKE3_CHUNK_LEN;
}
INLINE_divsuf size_t compress_chunks_parallel(const uint8_t *input, size_t input_len,
                                       const uint32_t key[8],
                                       uint64_t chunk_counter, uint8_t flags,
                                       uint8_t *out) {
#if defined(BLAKE3_TESTING)
  assert(0 < input_len);
  assert(input_len <= MAX_SIMD_DEGREE * BLAKE3_CHUNK_LEN);
#endif // corresponds to #if (#if defined(BLAKE3_TESTING))
  const uint8_t *chunks_array[MAX_SIMD_DEGREE];
  size_t input_position = 0;
  size_t chunks_array_len = 0;
  while (input_len - input_position >= BLAKE3_CHUNK_LEN) {
    chunks_array[chunks_array_len] = &input[input_position];
    input_position += BLAKE3_CHUNK_LEN;
    chunks_array_len += 1;
  }
  blake3_hash_many(chunks_array, chunks_array_len,
                   BLAKE3_CHUNK_LEN / BLAKE3_BLOCK_LEN, key, chunk_counter,
                   true, flags, CHUNK_START, CHUNK_END, out);
  if (input_len > input_position) {
    uint64_t counter = chunk_counter + (uint64_t)chunks_array_len;
    blake3_chunk_state chunk_state;
    chunk_state_init(&chunk_state, key, flags);
    chunk_state.chunk_counter = counter;
    chunk_state_update(&chunk_state, &input[input_position],
                       input_len - input_position);
    output_t output = chunk_state_output(&chunk_state);
    output_chaining_value(&output, &out[chunks_array_len * BLAKE3_OUT_LEN]);
    return chunks_array_len + 1;
  } else {
    return chunks_array_len;
  }
}
INLINE_divsuf size_t compress_parents_parallel(const uint8_t *child_chaining_values,
                                        size_t num_chaining_values,
                                        const uint32_t key[8], uint8_t flags,
                                        uint8_t *out) {
#if defined(BLAKE3_TESTING)
  assert(2 <= num_chaining_values);
  assert(num_chaining_values <= 2 * MAX_SIMD_DEGREE_OR_2);
#endif // corresponds to #if (#if defined(BLAKE3_TESTING))
  const uint8_t *parents_array[MAX_SIMD_DEGREE_OR_2];
  size_t parents_array_len = 0;
  while (num_chaining_values - (2 * parents_array_len) >= 2) {
    parents_array[parents_array_len] =
        &child_chaining_values[2 * parents_array_len * BLAKE3_OUT_LEN];
    parents_array_len += 1;
  }
  blake3_hash_many(parents_array, parents_array_len, 1, key,
                   0,
                   false, flags | PARENT,
                   0,
                   0,
                   out);
  if (num_chaining_values > 2 * parents_array_len) {
	  memcpy(&out+(parents_array_len * BLAKE3_OUT_LEN),
           &child_chaining_values+(2 * parents_array_len * BLAKE3_OUT_LEN),
           BLAKE3_OUT_LEN); /// FAKE COMPILER WARNING
    return parents_array_len + 1;
  } else {
    return parents_array_len;
  }
}
static size_t blake3_compress_subtree_wide(const uint8_t *input,
                                           size_t input_len,
                                           const uint32_t key[8],
                                           uint64_t chunk_counter,
                                           uint8_t flags, uint8_t *out) {
  if (input_len <= blake3_simd_degree() * BLAKE3_CHUNK_LEN) {
    return compress_chunks_parallel(input, input_len, key, chunk_counter, flags,
                                    out);
  }
  size_t left_input_len = left_len(input_len);
  size_t right_input_len = input_len - left_input_len;
  const uint8_t *right_input = &input[left_input_len];
  uint64_t right_chunk_counter =
      chunk_counter + (uint64_t)(left_input_len / BLAKE3_CHUNK_LEN);
  uint8_t cv_array[2 * MAX_SIMD_DEGREE_OR_2 * BLAKE3_OUT_LEN];
  size_t degree = blake3_simd_degree();
  if (left_input_len > BLAKE3_CHUNK_LEN && degree == 1) {
    degree = 2;
  }
  uint8_t *right_cvs = &cv_array[degree * BLAKE3_OUT_LEN];
  size_t left_n = blake3_compress_subtree_wide(input, left_input_len, key,
                                               chunk_counter, flags, cv_array);
  size_t right_n = blake3_compress_subtree_wide(
      right_input, right_input_len, key, right_chunk_counter, flags, right_cvs);
  if (left_n == 1) {
    memcpy(out, cv_array, 2 * BLAKE3_OUT_LEN);
    return 2;
  }
  size_t num_chaining_values = left_n + right_n;
  return compress_parents_parallel(cv_array, num_chaining_values, key, flags,
                                   out); /// FAKE WARNING
}
INLINE_divsuf void compress_subtree_to_parent_node(
    const uint8_t *input, size_t input_len, const uint32_t key[8],
    uint64_t chunk_counter, uint8_t flags, uint8_t out[2 * BLAKE3_OUT_LEN]) {
#if defined(BLAKE3_TESTING)
  assert(input_len > BLAKE3_CHUNK_LEN);
#endif // corresponds to #if (#if defined(BLAKE3_TESTING))
  uint8_t cv_array[MAX_SIMD_DEGREE_OR_2 * BLAKE3_OUT_LEN];
  size_t num_cvs = blake3_compress_subtree_wide(input, input_len, key,
                                                chunk_counter, flags, cv_array);
  uint8_t out_array[MAX_SIMD_DEGREE_OR_2 * BLAKE3_OUT_LEN ];
  while (num_cvs > 2) {
    num_cvs =
        compress_parents_parallel(cv_array, num_cvs, key, flags, out_array);
    memcpy(cv_array, out_array, num_cvs * BLAKE3_OUT_LEN);
  }
  memcpy(out, cv_array, 2 * BLAKE3_OUT_LEN);
}
	INLINE_divsuf void hasher_init_base(blake3_hasher *self, const uint32_t key[8],
								 uint8_t flags) {
	   if ((key == NULL) || (self == NULL)) //fix my me for compiler warning
		   return;
	  memcpy(self->key, key, BLAKE3_KEY_LEN);
	  chunk_state_init(&self->chunk, key, flags);
	  self->cv_stack_len = 0;
	}
void blake3_hasher_init(blake3_hasher *self) { hasher_init_base(self, IV, 0); }
INLINE_divsuf void hasher_merge_cv_stack(blake3_hasher *self, uint64_t total_len) {
  size_t post_merge_stack_len = (size_t)popcnt(total_len);
  while (self->cv_stack_len > post_merge_stack_len) {
    uint8_t *parent_node =
        &self->cv_stack[(self->cv_stack_len - 2) * BLAKE3_OUT_LEN];
    output_t output = parent_output(parent_node, self->key, self->chunk.flags);
    output_chaining_value(&output, parent_node);
    self->cv_stack_len -= 1;
  }
}
INLINE_divsuf void hasher_push_cv(blake3_hasher *self, uint8_t new_cv[BLAKE3_OUT_LEN],
                           uint64_t chunk_counter) {
  hasher_merge_cv_stack(self, chunk_counter);
  memcpy(&self->cv_stack[self->cv_stack_len * BLAKE3_OUT_LEN], new_cv,
         BLAKE3_OUT_LEN);
  self->cv_stack_len += 1;
}
void blake3_hasher_update(blake3_hasher *self, const void *input,
                          size_t input_len) {
  if (input_len == 0) {
    return;
  }
  const uint8_t *input_bytes = (const uint8_t *)input;
  if (chunk_state_len(&self->chunk) > 0) {
    size_t take = BLAKE3_CHUNK_LEN - chunk_state_len(&self->chunk);
    if (take > input_len) {
      take = input_len;
    }
    chunk_state_update(&self->chunk, input_bytes, take);
    input_bytes += take;
    input_len -= take;
    if (input_len > 0) {
      output_t output = chunk_state_output(&self->chunk);
      uint8_t chunk_cv[32];
      output_chaining_value(&output, chunk_cv);
      hasher_push_cv(self, chunk_cv, self->chunk.chunk_counter);
      chunk_state_reset(&self->chunk, self->key, self->chunk.chunk_counter + 1);
    } else {
      return;
    }
  }
  while (input_len > BLAKE3_CHUNK_LEN) {
    size_t subtree_len = round_down_to_power_of_2(input_len);
    uint64_t count_so_far = self->chunk.chunk_counter * BLAKE3_CHUNK_LEN;
    while ((((uint64_t)(subtree_len - 1)) & count_so_far) != 0) {
      subtree_len /= 2;
    }
    uint64_t subtree_chunks = subtree_len / BLAKE3_CHUNK_LEN;
    if (subtree_len <= BLAKE3_CHUNK_LEN) {
      blake3_chunk_state chunk_state;
      chunk_state_init(&chunk_state, self->key, self->chunk.flags);
      chunk_state.chunk_counter = self->chunk.chunk_counter;
      chunk_state_update(&chunk_state, input_bytes, subtree_len);
      output_t output = chunk_state_output(&chunk_state);
      uint8_t cv[BLAKE3_OUT_LEN];
      output_chaining_value(&output, cv);
      hasher_push_cv(self, cv, chunk_state.chunk_counter);
    } else {
      uint8_t cv_pair[2 * BLAKE3_OUT_LEN];
      compress_subtree_to_parent_node(input_bytes, subtree_len, self->key,
                                      self->chunk.chunk_counter,
                                      self->chunk.flags, cv_pair); /// FAKE COMPILER WARNING HERE!
      hasher_push_cv(self, cv_pair, self->chunk.chunk_counter);
      hasher_push_cv(self, &cv_pair[BLAKE3_OUT_LEN],
                     self->chunk.chunk_counter + (subtree_chunks / 2));
    }
    self->chunk.chunk_counter += subtree_chunks;
    input_bytes += subtree_len;
    input_len -= subtree_len;
  }
  if (input_len > 0) {
    chunk_state_update(&self->chunk, input_bytes, input_len);
    hasher_merge_cv_stack(self, self->chunk.chunk_counter);
  }
}
void blake3_hasher_finalize(const blake3_hasher *self, uint8_t *out,
                            size_t out_len) {
  blake3_hasher_finalize_seek(self, 0, out, out_len);
}
void blake3_hasher_finalize_seek(const blake3_hasher *self, uint64_t seek,
                                 uint8_t *out, size_t out_len) {
  if (out_len == 0) {
    return;
  }
  if (self->cv_stack_len == 0) {
    output_t output = chunk_state_output(&self->chunk);
    output_root_bytes(&output, seek, out, out_len);
    return;
  }
  output_t output;
  size_t cvs_remaining;
  if (chunk_state_len(&self->chunk) > 0) {
    cvs_remaining = self->cv_stack_len;
    output = chunk_state_output(&self->chunk);
  } else {
    cvs_remaining = self->cv_stack_len - 2;
    output = parent_output(&self->cv_stack[cvs_remaining * 32], self->key,
                           self->chunk.flags);
  }
  while (cvs_remaining > 0) {
    cvs_remaining -= 1;
    uint8_t parent_block[BLAKE3_BLOCK_LEN];
    memcpy(parent_block, &self->cv_stack[cvs_remaining * 32], 32);
    output_chaining_value(&output, &parent_block[32]);
    output = parent_output(parent_block, self->key, self->chunk.flags);
  }
  output_root_bytes(&output, seek, out, out_len);
}
#define MAYBE_UNUSED(x) (void)((x))
#if defined(IS_X86)
static uint64_t xgetbv() {
#if defined(_MSC_VER)
  return _xgetbv(0);
#else
  uint32_t eax = 0, edx = 0;
  __asm__ __volatile__("xgetbv\n" : "=a"(eax), "=d"(edx) : "c"(0));
  return ((uint64_t)edx << 32) | eax;
#endif // corresponds to #if (#if defined(_MSC_VER))
}
static void cpuid(uint32_t out[4], uint32_t id) {
#if defined(_MSC_VER)
  __cpuid((int *)out, id);
#elif defined(__i386__) || defined(_M_IX86)
  __asm__ __volatile__("movl %%ebx, %1\n"
                       "cpuid\n"
                       "xchgl %1, %%ebx\n"
                       : "=a"(out[0]), "=r"(out[1]), "=c"(out[2]), "=d"(out[3])
                       : "a"(id));
#else
  __asm__ __volatile__("cpuid\n"
                       : "=a"(out[0]), "=b"(out[1]), "=c"(out[2]), "=d"(out[3])
                       : "a"(id));
#endif // corresponds to #if (#if defined(_MSC_VER))
}
static void cpuidex(uint32_t out[4], uint32_t id, uint32_t sid) {
#if defined(_MSC_VER)
  __cpuidex((int *)out, id, sid);
#elif defined(__i386__) || defined(_M_IX86)
  __asm__ __volatile__("movl %%ebx, %1\n"
                       "cpuid\n"
                       "xchgl %1, %%ebx\n"
                       : "=a"(out[0]), "=r"(out[1]), "=c"(out[2]), "=d"(out[3])
                       : "a"(id), "c"(sid));
#else
  __asm__ __volatile__("cpuid\n"
                       : "=a"(out[0]), "=b"(out[1]), "=c"(out[2]), "=d"(out[3])
                       : "a"(id), "c"(sid));
#endif // corresponds to #if (#if defined(_MSC_VER))
}
#endif // corresponds to #if (#if defined(IS_X86))
void blake3_compress_in_place(uint32_t cv[8],
                              const uint8_t block[BLAKE3_BLOCK_LEN],
                              uint8_t block_len, uint64_t counter,
                              uint8_t flags) {
  blake3_compress_in_place_portable(cv, block, block_len, counter, flags);
}
void blake3_compress_xof(const uint32_t cv[8],
                         const uint8_t block[BLAKE3_BLOCK_LEN],
                         uint8_t block_len, uint64_t counter, uint8_t flags,
                         uint8_t out[64]) {
  blake3_compress_xof_portable(cv, block, block_len, counter, flags, out);
}
void blake3_hash_many(const uint8_t *const *inputs, size_t num_inputs,
                      size_t blocks, const uint32_t key[8], uint64_t counter,
                      bool increment_counter, uint8_t flags,
                      uint8_t flags_start, uint8_t flags_end, uint8_t *out) {
  blake3_hash_many_portable(inputs, num_inputs, blocks, key, counter,
                            increment_counter, flags, flags_start, flags_end,
                            out);
}
size_t blake3_simd_degree(void)
{
  return 1;
}
INLINE_divsuf uint32_t rotr32(uint32_t w, uint32_t c) {
  return (w >> c) | (w << (32 - c));
}
INLINE_divsuf void g(uint32_t *state, size_t a, size_t b, size_t c, size_t d,
              uint32_t x, uint32_t y) {
  state[a] = state[a] + state[b] + x;
  state[d] = rotr32(state[d] ^ state[a], 16);
  state[c] = state[c] + state[d];
  state[b] = rotr32(state[b] ^ state[c], 12);
  state[a] = state[a] + state[b] + y;
  state[d] = rotr32(state[d] ^ state[a], 8);
  state[c] = state[c] + state[d];
  state[b] = rotr32(state[b] ^ state[c], 7);
}
INLINE_divsuf void round_fn(uint32_t state[16], const uint32_t *msg, size_t round) {
  const uint8_t *schedule = MSG_SCHEDULE[round];
  g(state, 0, 4, 8, 12, msg[schedule[0]], msg[schedule[1]]);
  g(state, 1, 5, 9, 13, msg[schedule[2]], msg[schedule[3]]);
  g(state, 2, 6, 10, 14, msg[schedule[4]], msg[schedule[5]]);
  g(state, 3, 7, 11, 15, msg[schedule[6]], msg[schedule[7]]);
  g(state, 0, 5, 10, 15, msg[schedule[8]], msg[schedule[9]]);
  g(state, 1, 6, 11, 12, msg[schedule[10]], msg[schedule[11]]);
  g(state, 2, 7, 8, 13, msg[schedule[12]], msg[schedule[13]]);
  g(state, 3, 4, 9, 14, msg[schedule[14]], msg[schedule[15]]);
}
INLINE_divsuf void compress_pre(uint32_t state[16], const uint32_t cv[8],
                         const uint8_t block[BLAKE3_BLOCK_LEN],
                         uint8_t block_len, uint64_t counter, uint8_t flags) {
  uint32_t block_words[16];
  block_words[0] = load32(block + 4 * 0);
  block_words[1] = load32(block + 4 * 1);
  block_words[2] = load32(block + 4 * 2);
  block_words[3] = load32(block + 4 * 3);
  block_words[4] = load32(block + 4 * 4);
  block_words[5] = load32(block + 4 * 5);
  block_words[6] = load32(block + 4 * 6);
  block_words[7] = load32(block + 4 * 7);
  block_words[8] = load32(block + 4 * 8);
  block_words[9] = load32(block + 4 * 9);
  block_words[10] = load32(block + 4 * 10);
  block_words[11] = load32(block + 4 * 11);
  block_words[12] = load32(block + 4 * 12);
  block_words[13] = load32(block + 4 * 13);
  block_words[14] = load32(block + 4 * 14);
  block_words[15] = load32(block + 4 * 15);
  state[0] = cv[0];
  state[1] = cv[1];
  state[2] = cv[2];
  state[3] = cv[3];
  state[4] = cv[4];
  state[5] = cv[5];
  state[6] = cv[6];
  state[7] = cv[7];
  state[8] = IV[0];
  state[9] = IV[1];
  state[10] = IV[2];
  state[11] = IV[3];
  state[12] = counter_low(counter);
  state[13] = counter_high(counter);
  state[14] = (uint32_t)block_len;
  state[15] = (uint32_t)flags;
  round_fn(state, &block_words[0], 0);
  round_fn(state, &block_words[0], 1);
  round_fn(state, &block_words[0], 2);
  round_fn(state, &block_words[0], 3);
  round_fn(state, &block_words[0], 4);
  round_fn(state, &block_words[0], 5);
  round_fn(state, &block_words[0], 6);
}
void blake3_compress_in_place_portable(uint32_t cv[8],
                                       const uint8_t block[BLAKE3_BLOCK_LEN],
                                       uint8_t block_len, uint64_t counter,
                                       uint8_t flags) {
  uint32_t state[16];
  compress_pre(state, cv, block, block_len, counter, flags);
  cv[0] = state[0] ^ state[8];
  cv[1] = state[1] ^ state[9];
  cv[2] = state[2] ^ state[10];
  cv[3] = state[3] ^ state[11];
  cv[4] = state[4] ^ state[12];
  cv[5] = state[5] ^ state[13];
  cv[6] = state[6] ^ state[14];
  cv[7] = state[7] ^ state[15];
}
void blake3_compress_xof_portable(const uint32_t cv[8],
                                  const uint8_t block[BLAKE3_BLOCK_LEN],
                                  uint8_t block_len, uint64_t counter,
                                  uint8_t flags, uint8_t out[64]) {
  uint32_t state[16];
  compress_pre(state, cv, block, block_len, counter, flags);
  store32(&out[0 * 4], state[0] ^ state[8]);
  store32(&out[1 * 4], state[1] ^ state[9]);
  store32(&out[2 * 4], state[2] ^ state[10]);
  store32(&out[3 * 4], state[3] ^ state[11]);
  store32(&out[4 * 4], state[4] ^ state[12]);
  store32(&out[5 * 4], state[5] ^ state[13]);
  store32(&out[6 * 4], state[6] ^ state[14]);
  store32(&out[7 * 4], state[7] ^ state[15]);
  store32(&out[8 * 4], state[8] ^ cv[0]);
  store32(&out[9 * 4], state[9] ^ cv[1]);
  store32(&out[10 * 4], state[10] ^ cv[2]);
  store32(&out[11 * 4], state[11] ^ cv[3]);
  store32(&out[12 * 4], state[12] ^ cv[4]);
  store32(&out[13 * 4], state[13] ^ cv[5]);
  store32(&out[14 * 4], state[14] ^ cv[6]);
  store32(&out[15 * 4], state[15] ^ cv[7]);
}
INLINE_divsuf void hash_one_portable(const uint8_t *input, size_t blocks,
                              const uint32_t key[8], uint64_t counter,
                              uint8_t flags, uint8_t flags_start,
                              uint8_t flags_end, uint8_t out[BLAKE3_OUT_LEN]) {
  uint32_t cv[8];
  memcpy(cv, key, BLAKE3_KEY_LEN);
  uint8_t block_flags = flags | flags_start;
  while (blocks > 0) {
    if (blocks == 1) {
      block_flags |= flags_end;
    }
    blake3_compress_in_place_portable(cv, input, BLAKE3_BLOCK_LEN, counter,
                                      block_flags);
    input = &input[BLAKE3_BLOCK_LEN];
    blocks -= 1;
    block_flags = flags;
  }
  store_cv_words(out, cv);
}
void blake3_hash_many_portable(const uint8_t *const *inputs, size_t num_inputs,
                               size_t blocks, const uint32_t key[8],
                               uint64_t counter, bool increment_counter,
                               uint8_t flags, uint8_t flags_start,
                               uint8_t flags_end, uint8_t *out) {
  while (num_inputs > 0) {
    hash_one_portable(inputs[0], blocks, key, counter, flags, flags_start,
                      flags_end, out);
    if (increment_counter) {
      counter += 1;
    }
    inputs += 1;
    num_inputs -= 1;
    out = &out[BLAKE3_OUT_LEN];
  }
}
#else
#define BLAKE3_KEY_LEN 32
#define BLAKE3_OUT_LEN 32
#define BLAKE3_BLOCK_LEN 64
#define BLAKE3_CHUNK_LEN 1024
#define BLAKE3_MAX_DEPTH 54
typedef struct {
  uint32_t cv[8];
  uint64_t chunk_counter;
  uint8_t buf[BLAKE3_BLOCK_LEN];
  uint8_t buf_len;
  uint8_t blocks_compressed;
  uint8_t flags;
} blake3_chunk_state;
typedef struct {
  uint32_t key[8];
  blake3_chunk_state chunk;
  uint8_t cv_stack_len;
  uint8_t cv_stack[(BLAKE3_MAX_DEPTH + 1) * BLAKE3_OUT_LEN];
} blake3_hasher;
void blake3_hasher_init(blake3_hasher *self);
void blake3_hasher_init_derive_key(blake3_hasher *self, const char *context);
void blake3_hasher_init_derive_key_raw(blake3_hasher *self, const void *context,
                                       size_t context_len);
void blake3_hasher_update(blake3_hasher *self, const void *input,
                          size_t input_len);
void blake3_hasher_finalize(const blake3_hasher *self, uint8_t *out,
                            size_t out_len);
void blake3_hasher_finalize_seek(const blake3_hasher *self, uint64_t seek,
                                 uint8_t *out, size_t out_len);
enum blake3_flags {
  CHUNK_START         = 1 << 0,
  CHUNK_END           = 1 << 1,
  PARENT              = 1 << 2,
  ROOT                = 1 << 3,
  KEYED_HASH          = 1 << 4,
  DERIVE_KEY_CONTEXT  = 1 << 5,
  DERIVE_KEY_MATERIAL = 1 << 6,
};
#if defined(_MSC_VER)
#define INLINE static __forceinline
#else
#define INLINE static inline __attribute__((always_inline))
#endif // corresponds to #if (#if defined(_MSC_VER))
#if defined(__x86_64__) || defined(_M_X64)
#define IS_X86
#define IS_X86_64
#endif // corresponds to #if (#if defined(__x86_64__) || defined(_M_X64))
#if defined(__i386__) || defined(_M_IX86)
#define IS_X86
#define IS_X86_32
#endif // corresponds to #if (#if defined(__i386__) || defined(_M_IX86))
#if defined(IS_X86)
#if defined(_MSC_VER)
#include <intrin.h>
#endif // corresponds to #if (#if defined(_MSC_VER))
#include <immintrin.h>
#endif // corresponds to #if (#if defined(IS_X86))
#if defined(IS_X86)
#define MAX_SIMD_DEGREE 16
#elif defined(BLAKE3_USE_NEON)
#define MAX_SIMD_DEGREE 4
#else
#define MAX_SIMD_DEGREE 1
#endif // corresponds to #if (#if defined(IS_X86))
#define MAX_SIMD_DEGREE_OR_2 (MAX_SIMD_DEGREE > 2 ? MAX_SIMD_DEGREE : 2)
static const uint32_t IV[8] = {0x6A09E667UL, 0xBB67AE85UL, 0x3C6EF372UL,
                               0xA54FF53AUL, 0x510E527FUL, 0x9B05688CUL,
                               0x1F83D9ABUL, 0x5BE0CD19UL};
static const uint8_t MSG_SCHEDULE[7][16] = {
    {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15},
    {2, 6, 3, 10, 7, 0, 4, 13, 1, 11, 12, 5, 9, 14, 15, 8},
    {3, 4, 10, 12, 13, 2, 7, 14, 6, 5, 9, 0, 11, 15, 8, 1},
    {10, 7, 12, 9, 14, 3, 13, 15, 4, 0, 11, 2, 5, 8, 1, 6},
    {12, 13, 9, 11, 15, 10, 14, 8, 7, 2, 5, 3, 0, 1, 6, 4},
    {9, 14, 11, 5, 8, 12, 15, 1, 13, 3, 0, 10, 2, 6, 4, 7},
    {11, 15, 5, 0, 1, 9, 8, 6, 14, 10, 2, 12, 3, 4, 7, 13},
};
static unsigned int highest_one(uint64_t x) {
#if defined(__GNUC__) || defined(__clang__)
  return 63 ^ __builtin_clzll(x);
#elif defined(_MSC_VER) && defined(IS_X86_64)
  unsigned long index;
  _BitScanReverse64(&index, x);
  return index;
#elif defined(_MSC_VER) && defined(IS_X86_32)
  if(x >> 32) {
    unsigned long index;
    _BitScanReverse(&index, x >> 32);
    return 32 + index;
  } else {
    unsigned long index;
    _BitScanReverse(&index, x);
    return index;
  }
#else
  unsigned int c = 0;
  if(x & 0xffffffff00000000ULL) { x >>= 32; c += 32; }
  if(x & 0x00000000ffff0000ULL) { x >>= 16; c += 16; }
  if(x & 0x000000000000ff00ULL) { x >>=  8; c +=  8; }
  if(x & 0x00000000000000f0ULL) { x >>=  4; c +=  4; }
  if(x & 0x000000000000000cULL) { x >>=  2; c +=  2; }
  if(x & 0x0000000000000002ULL) {           c +=  1; }
  return c;
#endif // corresponds to #if (#if defined(__GNUC__) || defined(__clang__))
}
INLINE unsigned int popcnt(uint64_t x) {
#if defined(__GNUC__) || defined(__clang__)
  return __builtin_popcountll(x);
#else
  unsigned int count = 0;
  while (x != 0) {
    count += 1;
    x &= x - 1;
  }
  return count;
#endif // corresponds to #if (#if defined(__GNUC__) || defined(__clang__))
}
INLINE uint64_t round_down_to_power_of_2(uint64_t x) {
  return 1ULL << highest_one(x | 1);
}
INLINE uint32_t counter_low(uint64_t counter) { return (uint32_t)counter; }
INLINE uint32_t counter_high(uint64_t counter) {
  return (uint32_t)(counter >> 32);
}
INLINE uint32_t load32(const void *src) {
  const uint8_t *p = (const uint8_t *)src;
  return ((uint32_t)(p[0]) << 0) | ((uint32_t)(p[1]) << 8) |
         ((uint32_t)(p[2]) << 16) | ((uint32_t)(p[3]) << 24);
}
INLINE void load_key_words(const uint8_t key[BLAKE3_KEY_LEN],
                           uint32_t key_words[8]) {
  key_words[0] = load32(&key[0 * 4]);
  key_words[1] = load32(&key[1 * 4]);
  key_words[2] = load32(&key[2 * 4]);
  key_words[3] = load32(&key[3 * 4]);
  key_words[4] = load32(&key[4 * 4]);
  key_words[5] = load32(&key[5 * 4]);
  key_words[6] = load32(&key[6 * 4]);
  key_words[7] = load32(&key[7 * 4]);
}
INLINE void store32(void *dst, uint32_t w) {
  uint8_t *p = (uint8_t *)dst;
  p[0] = (uint8_t)(w >> 0);
  p[1] = (uint8_t)(w >> 8);
  p[2] = (uint8_t)(w >> 16);
  p[3] = (uint8_t)(w >> 24);
}
INLINE void store_cv_words(uint8_t bytes_out[32], uint32_t cv_words[8]) {
  store32(&bytes_out[0 * 4], cv_words[0]);
  store32(&bytes_out[1 * 4], cv_words[1]);
  store32(&bytes_out[2 * 4], cv_words[2]);
  store32(&bytes_out[3 * 4], cv_words[3]);
  store32(&bytes_out[4 * 4], cv_words[4]);
  store32(&bytes_out[5 * 4], cv_words[5]);
  store32(&bytes_out[6 * 4], cv_words[6]);
  store32(&bytes_out[7 * 4], cv_words[7]);
}
void blake3_compress_in_place(uint32_t cv[8],
                              const uint8_t block[BLAKE3_BLOCK_LEN],
                              uint8_t block_len, uint64_t counter,
                              uint8_t flags);
void blake3_compress_xof(const uint32_t cv[8],
                         const uint8_t block[BLAKE3_BLOCK_LEN],
                         uint8_t block_len, uint64_t counter, uint8_t flags,
                         uint8_t out[64]);
void blake3_hash_many(const uint8_t *const *inputs, size_t num_inputs,
                      size_t blocks, const uint32_t key[8], uint64_t counter,
                      bool increment_counter, uint8_t flags,
                      uint8_t flags_start, uint8_t flags_end, uint8_t *out);
size_t blake3_simd_degree(void);
void blake3_compress_in_place_portable(uint32_t cv[8],
                                       const uint8_t block[BLAKE3_BLOCK_LEN],
                                       uint8_t block_len, uint64_t counter,
                                       uint8_t flags);
void blake3_compress_xof_portable(const uint32_t cv[8],
                                  const uint8_t block[BLAKE3_BLOCK_LEN],
                                  uint8_t block_len, uint64_t counter,
                                  uint8_t flags, uint8_t out[64]);
void blake3_hash_many_portable(const uint8_t *const *inputs, size_t num_inputs,
                               size_t blocks, const uint32_t key[8],
                               uint64_t counter, bool increment_counter,
                               uint8_t flags, uint8_t flags_start,
                               uint8_t flags_end, uint8_t *out);
#if defined(IS_X86)
#if !defined(BLAKE3_NO_SSE2)
extern "C" void blake3_compress_in_place_sse2(uint32_t cv[8],
                                   const uint8_t block[BLAKE3_BLOCK_LEN],
                                   uint8_t block_len, uint64_t counter,
                                   uint8_t flags);
extern "C" void blake3_compress_xof_sse2(const uint32_t cv[8],
                              const uint8_t block[BLAKE3_BLOCK_LEN],
                              uint8_t block_len, uint64_t counter,
                              uint8_t flags, uint8_t out[64]);
extern "C" void blake3_hash_many_sse2(const uint8_t *const *inputs, size_t num_inputs,
                           size_t blocks, const uint32_t key[8],
                           uint64_t counter, bool increment_counter,
                           uint8_t flags, uint8_t flags_start,
                           uint8_t flags_end, uint8_t *out);
#endif // corresponds to #if (#if !defined(BLAKE3_NO_SSE2))
#if !defined(BLAKE3_NO_SSE41)
extern "C" void blake3_compress_in_place_sse41(uint32_t cv[8],
                                    const uint8_t block[BLAKE3_BLOCK_LEN],
                                    uint8_t block_len, uint64_t counter,
                                    uint8_t flags);
extern "C" void blake3_compress_xof_sse41(const uint32_t cv[8],
                               const uint8_t block[BLAKE3_BLOCK_LEN],
                               uint8_t block_len, uint64_t counter,
                               uint8_t flags, uint8_t out[64]);
extern "C" void blake3_hash_many_sse41(const uint8_t *const *inputs, size_t num_inputs,
                            size_t blocks, const uint32_t key[8],
                            uint64_t counter, bool increment_counter,
                            uint8_t flags, uint8_t flags_start,
                            uint8_t flags_end, uint8_t *out);
#endif // corresponds to #if (#if !defined(BLAKE3_NO_SSE41))
#if !defined(BLAKE3_NO_AVX2)
extern "C" void blake3_hash_many_avx2(const uint8_t *const *inputs, size_t num_inputs,
                           size_t blocks, const uint32_t key[8],
                           uint64_t counter, bool increment_counter,
                           uint8_t flags, uint8_t flags_start,
                           uint8_t flags_end, uint8_t *out);
#endif // corresponds to #if (#if !defined(BLAKE3_NO_AVX2))
#if !defined(BLAKE3_NO_AVX512)
extern "C" void blake3_compress_in_place_avx512(uint32_t cv[8],
                                     const uint8_t block[BLAKE3_BLOCK_LEN],
                                     uint8_t block_len, uint64_t counter,
                                     uint8_t flags);
extern "C" void blake3_compress_xof_avx512(const uint32_t cv[8],
                                const uint8_t block[BLAKE3_BLOCK_LEN],
                                uint8_t block_len, uint64_t counter,
                                uint8_t flags, uint8_t out[64]);
extern "C" void blake3_hash_many_avx512(const uint8_t *const *inputs, size_t num_inputs,
                             size_t blocks, const uint32_t key[8],
                             uint64_t counter, bool increment_counter,
                             uint8_t flags, uint8_t flags_start,
                             uint8_t flags_end, uint8_t *out);
#endif // corresponds to #if (#if !defined(BLAKE3_NO_AVX512))
#endif // corresponds to #if (#if defined(IS_X86))
#if defined(BLAKE3_USE_NEON)
void blake3_hash_many_neon(const uint8_t *const *inputs, size_t num_inputs,
                           size_t blocks, const uint32_t key[8],
                           uint64_t counter, bool increment_counter,
                           uint8_t flags, uint8_t flags_start,
                           uint8_t flags_end, uint8_t *out);
#endif // corresponds to #if (#if defined(BLAKE3_USE_NEON))
#if defined(IS_X86)
#if defined(_MSC_VER)
#include <intrin.h>
#elif defined(__GNUC__)
#include <immintrin.h>
#else
#error "Unimplemented!"
#endif // corresponds to #if (#if defined(_MSC_VER))
#endif // corresponds to #if (#if defined(IS_X86))
#define MAYBE_UNUSED(x) (void)((x))
#if defined(IS_X86)
static uint64_t xgetbv() {
#if defined(_MSC_VER)
  return _xgetbv(0);
#else
  uint32_t eax = 0, edx = 0;
  __asm__ __volatile__("xgetbv\n" : "=a"(eax), "=d"(edx) : "c"(0));
  return ((uint64_t)edx << 32) | eax;
#endif // corresponds to #if (#if defined(_MSC_VER))
}
static void cpuid(uint32_t out[4], uint32_t id) {
#if defined(_MSC_VER)
  __cpuid((int *)out, id);
#elif defined(__i386__) || defined(_M_IX86)
  __asm__ __volatile__("movl %%ebx, %1\n"
                       "cpuid\n"
                       "xchgl %1, %%ebx\n"
                       : "=a"(out[0]), "=r"(out[1]), "=c"(out[2]), "=d"(out[3])
                       : "a"(id));
#else
  __asm__ __volatile__("cpuid\n"
                       : "=a"(out[0]), "=b"(out[1]), "=c"(out[2]), "=d"(out[3])
                       : "a"(id));
#endif // corresponds to #if (#if defined(_MSC_VER))
}
static void cpuidex(uint32_t out[4], uint32_t id, uint32_t sid) {
#if defined(_MSC_VER)
  __cpuidex((int *)out, id, sid);
#elif defined(__i386__) || defined(_M_IX86)
  __asm__ __volatile__("movl %%ebx, %1\n"
                       "cpuid\n"
                       "xchgl %1, %%ebx\n"
                       : "=a"(out[0]), "=r"(out[1]), "=c"(out[2]), "=d"(out[3])
                       : "a"(id), "c"(sid));
#else
  __asm__ __volatile__("cpuid\n"
                       : "=a"(out[0]), "=b"(out[1]), "=c"(out[2]), "=d"(out[3])
                       : "a"(id), "c"(sid));
#endif // corresponds to #if (#if defined(_MSC_VER))
}
#endif // corresponds to #if (#if defined(IS_X86))
#define FRANZFIX
#define SSE2  		1
#define SSSE3 		2
#define SSE41 		4
#define AVX 		8
#define AVX2 		16
#define AVX512F 	32
#define AVX512VL 	64
#define UNDEFINED 1<<30
#ifdef FRANZFIX
#else
enum cpu_feature {
  SSE2 = 1 << 0,
  SSSE3 = 1 << 1,
  SSE41 = 1 << 2,
  AVX = 1 << 3,
  AVX2 = 1 << 4,
  AVX512F = 1 << 5,
  AVX512VL = 1 << 6,
  UNDEFINED = 1 << 30
};
#endif // corresponds to #ifdef (#ifdef FRANZFIX)
#if !defined(BLAKE3_TESTING)
static
#endif // corresponds to #if (#if !defined(BLAKE3_TESTING))
#ifdef FRANZFIX
    uint32_t g_cpu_features = UNDEFINED;
#else
    enum cpu_feature g_cpu_features = UNDEFINED;
#endif // corresponds to #ifdef (#ifdef FRANZFIX)
#if !defined(BLAKE3_TESTING)
static
#endif // corresponds to #if (#if !defined(BLAKE3_TESTING))
#ifdef FRANZFIX
	uint32_t
#else
    enum cpu_feature
#endif // corresponds to #ifdef (#ifdef FRANZFIX)
    get_cpu_features() {
  if (g_cpu_features != UNDEFINED) {
    return g_cpu_features;
  } else {
#if defined(IS_X86)
    uint32_t regs[4] = {0};
    uint32_t *eax = &regs[0], *ebx = &regs[1], *ecx = &regs[2], *edx = &regs[3];
    (void)edx;
#ifdef FRANZFIX
    uint32_t features = 0;
#else
    enum cpu_feature features = 0;
#endif // corresponds to #ifdef (#ifdef FRANZFIX)
    cpuid(regs, 0);
    const int max_id = *eax;
    cpuid(regs, 1);
#if defined(__amd64__) || defined(_M_X64)
    features |= SSE2;
#else
    if (*edx & (1UL << 26))
      features |= SSE2;
#endif // corresponds to #if (#if defined(__amd64__) || defined(_M_X64))
    if (*ecx & (1UL << 0))
      features |= SSSE3;
    if (*ecx & (1UL << 19))
      features |= SSE41;
    if (*ecx & (1UL << 27)) {
      const uint64_t mask = xgetbv();
      if ((mask & 6) == 6) {
        if (*ecx & (1UL << 28))
          features |= AVX;
        if (max_id >= 7) {
          cpuidex(regs, 7, 0);
          if (*ebx & (1UL << 5))
            features |= AVX2;
          if ((mask & 224) == 224) {
            if (*ebx & (1UL << 31))
              features |= AVX512VL;
            if (*ebx & (1UL << 16))
              features |= AVX512F;
          }
        }
      }
    }
	g_cpu_features = features;
	if (flagdebug3)
		myprintf("00009: CPU feature %04X\n",features);
    return features;
#else
    return 0;
#endif // corresponds to #if (#if defined(IS_X86))
  }
}
void blake3_compress_in_place(uint32_t cv[8],
                              const uint8_t block[BLAKE3_BLOCK_LEN],
                              uint8_t block_len, uint64_t counter,
                              uint8_t flags) {
#if defined(IS_X86)
#ifdef FRANZFIX
  uint32_t features = get_cpu_features();
#else
  const enum cpu_feature features = get_cpu_features();
#endif // corresponds to #ifdef (#ifdef FRANZFIX)
  MAYBE_UNUSED(features);
#if !defined(BLAKE3_NO_AVX512)
  if (features & AVX512VL) {
    blake3_compress_in_place_avx512(cv, block, block_len, counter, flags);
    return;
  }
#endif // corresponds to #if (#if !defined(BLAKE3_NO_AVX512))
#if !defined(BLAKE3_NO_SSE41)
  if (features & SSE41) {
    blake3_compress_in_place_sse41(cv, block, block_len, counter, flags);
    return;
  }
#endif // corresponds to #if (#if !defined(BLAKE3_NO_SSE41))
#if !defined(BLAKE3_NO_SSE2)
  if (features & SSE2) {
    blake3_compress_in_place_sse2(cv, block, block_len, counter, flags);
    return;
  }
#endif // corresponds to #if (#if !defined(BLAKE3_NO_SSE2))
#endif // corresponds to #if (#if defined(IS_X86))
  blake3_compress_in_place_portable(cv, block, block_len, counter, flags);
}
void blake3_compress_xof(const uint32_t cv[8],
                         const uint8_t block[BLAKE3_BLOCK_LEN],
                         uint8_t block_len, uint64_t counter, uint8_t flags,
                         uint8_t out[64]) {
#if defined(IS_X86)
#ifdef FRANZFIX
  const uint32_t features = get_cpu_features();
#else
  const enum cpu_feature features = get_cpu_features();
#endif // corresponds to #ifdef (#ifdef FRANZFIX)
  MAYBE_UNUSED(features);
#if !defined(BLAKE3_NO_AVX512)
  if (features & AVX512VL) {
    blake3_compress_xof_avx512(cv, block, block_len, counter, flags, out);
    return;
  }
#endif // corresponds to #if (#if !defined(BLAKE3_NO_AVX512))
#if !defined(BLAKE3_NO_SSE41)
  if (features & SSE41) {
    blake3_compress_xof_sse41(cv, block, block_len, counter, flags, out);
    return;
  }
#endif // corresponds to #if (#if !defined(BLAKE3_NO_SSE41))
#if !defined(BLAKE3_NO_SSE2)
  if (features & SSE2) {
    blake3_compress_xof_sse2(cv, block, block_len, counter, flags, out);
    return;
  }
#endif // corresponds to #if (#if !defined(BLAKE3_NO_SSE2))
#endif // corresponds to #if (#if defined(IS_X86))
  blake3_compress_xof_portable(cv, block, block_len, counter, flags, out);
}
void blake3_hash_many(const uint8_t *const *inputs, size_t num_inputs,
                      size_t blocks, const uint32_t key[8], uint64_t counter,
                      bool increment_counter, uint8_t flags,
                      uint8_t flags_start, uint8_t flags_end, uint8_t *out) {
#if defined(IS_X86)
#ifdef FRANZFIX
  const uint32_t features = get_cpu_features();
#else
  const enum cpu_feature features = get_cpu_features();
#endif // corresponds to #ifdef (#ifdef FRANZFIX)
  MAYBE_UNUSED(features);
#if !defined(BLAKE3_NO_AVX512)
  if ((features & (AVX512F|AVX512VL)) == (AVX512F|AVX512VL)) {
    blake3_hash_many_avx512(inputs, num_inputs, blocks, key, counter,
                            increment_counter, flags, flags_start, flags_end,
                            out);
    return;
  }
#endif // corresponds to #if (#if !defined(BLAKE3_NO_AVX512))
#if !defined(BLAKE3_NO_AVX2)
  if (features & AVX2) {
    blake3_hash_many_avx2(inputs, num_inputs, blocks, key, counter,
                          increment_counter, flags, flags_start, flags_end,
                          out);
    return;
  }
#endif // corresponds to #if (#if !defined(BLAKE3_NO_AVX2))
#if !defined(BLAKE3_NO_SSE41)
  if (features & SSE41) {
    blake3_hash_many_sse41(inputs, num_inputs, blocks, key, counter,
                           increment_counter, flags, flags_start, flags_end,
                           out);
    return;
  }
#endif // corresponds to #if (#if !defined(BLAKE3_NO_SSE41))
#if !defined(BLAKE3_NO_SSE2)
  if (features & SSE2) {
    blake3_hash_many_sse2(inputs, num_inputs, blocks, key, counter,
                          increment_counter, flags, flags_start, flags_end,
                          out);
    return;
  }
#endif // corresponds to #if (#if !defined(BLAKE3_NO_SSE2))
#endif // corresponds to #if (#if defined(IS_X86))
#if defined(BLAKE3_USE_NEON)
  blake3_hash_many_neon(inputs, num_inputs, blocks, key, counter,
                        increment_counter, flags, flags_start, flags_end, out);
  return;
#endif // corresponds to #if (#if defined(BLAKE3_USE_NEON))
  blake3_hash_many_portable(inputs, num_inputs, blocks, key, counter,
                            increment_counter, flags, flags_start, flags_end,
                            out);
}
size_t blake3_simd_degree(void) {
#if defined(IS_X86)
#ifdef FRANZFIX
  uint32_t features = get_cpu_features();
#else
  const enum cpu_feature features = get_cpu_features();
#endif // corresponds to #ifdef (#ifdef FRANZFIX)
  MAYBE_UNUSED(features);
#if !defined(BLAKE3_NO_AVX512)
  if ((features & (AVX512F|AVX512VL)) == (AVX512F|AVX512VL)) {
    return 16;
  }
#endif // corresponds to #if (#if !defined(BLAKE3_NO_AVX512))
#if !defined(BLAKE3_NO_AVX2)
  if (features & AVX2) {
    return 8;
  }
#endif // corresponds to #if (#if !defined(BLAKE3_NO_AVX2))
#if !defined(BLAKE3_NO_SSE41)
  if (features & SSE41) {
    return 4;
  }
#endif // corresponds to #if (#if !defined(BLAKE3_NO_SSE41))
#if !defined(BLAKE3_NO_SSE2)
  if (features & SSE2) {
    return 4;
  }
#endif // corresponds to #if (#if !defined(BLAKE3_NO_SSE2))
#endif // corresponds to #if (#if defined(IS_X86))
#if defined(BLAKE3_USE_NEON)
  return 4;
#endif // corresponds to #if (#if defined(BLAKE3_USE_NEON))
  return 1;
}
INLINE uint32_t rotr32(uint32_t w, uint32_t c) {
  return (w >> c) | (w << (32 - c));
}
INLINE void g(uint32_t *state, size_t a, size_t b, size_t c, size_t d,
              uint32_t x, uint32_t y) {
  state[a] = state[a] + state[b] + x;
  state[d] = rotr32(state[d] ^ state[a], 16);
  state[c] = state[c] + state[d];
  state[b] = rotr32(state[b] ^ state[c], 12);
  state[a] = state[a] + state[b] + y;
  state[d] = rotr32(state[d] ^ state[a], 8);
  state[c] = state[c] + state[d];
  state[b] = rotr32(state[b] ^ state[c], 7);
}
INLINE void round_fn(uint32_t state[16], const uint32_t *msg, size_t round) {
  const uint8_t *schedule = MSG_SCHEDULE[round];
  g(state, 0, 4, 8, 12, msg[schedule[0]], msg[schedule[1]]);
  g(state, 1, 5, 9, 13, msg[schedule[2]], msg[schedule[3]]);
  g(state, 2, 6, 10, 14, msg[schedule[4]], msg[schedule[5]]);
  g(state, 3, 7, 11, 15, msg[schedule[6]], msg[schedule[7]]);
  g(state, 0, 5, 10, 15, msg[schedule[8]], msg[schedule[9]]);
  g(state, 1, 6, 11, 12, msg[schedule[10]], msg[schedule[11]]);
  g(state, 2, 7, 8, 13, msg[schedule[12]], msg[schedule[13]]);
  g(state, 3, 4, 9, 14, msg[schedule[14]], msg[schedule[15]]);
}
INLINE void compress_pre(uint32_t state[16], const uint32_t cv[8],
                         const uint8_t block[BLAKE3_BLOCK_LEN],
                         uint8_t block_len, uint64_t counter, uint8_t flags) {
  uint32_t block_words[16];
  block_words[0] = load32(block + 4 * 0);
  block_words[1] = load32(block + 4 * 1);
  block_words[2] = load32(block + 4 * 2);
  block_words[3] = load32(block + 4 * 3);
  block_words[4] = load32(block + 4 * 4);
  block_words[5] = load32(block + 4 * 5);
  block_words[6] = load32(block + 4 * 6);
  block_words[7] = load32(block + 4 * 7);
  block_words[8] = load32(block + 4 * 8);
  block_words[9] = load32(block + 4 * 9);
  block_words[10] = load32(block + 4 * 10);
  block_words[11] = load32(block + 4 * 11);
  block_words[12] = load32(block + 4 * 12);
  block_words[13] = load32(block + 4 * 13);
  block_words[14] = load32(block + 4 * 14);
  block_words[15] = load32(block + 4 * 15);
  state[0] = cv[0];
  state[1] = cv[1];
  state[2] = cv[2];
  state[3] = cv[3];
  state[4] = cv[4];
  state[5] = cv[5];
  state[6] = cv[6];
  state[7] = cv[7];
  state[8] = IV[0];
  state[9] = IV[1];
  state[10] = IV[2];
  state[11] = IV[3];
  state[12] = counter_low(counter);
  state[13] = counter_high(counter);
  state[14] = (uint32_t)block_len;
  state[15] = (uint32_t)flags;
  round_fn(state, &block_words[0], 0);
  round_fn(state, &block_words[0], 1);
  round_fn(state, &block_words[0], 2);
  round_fn(state, &block_words[0], 3);
  round_fn(state, &block_words[0], 4);
  round_fn(state, &block_words[0], 5);
  round_fn(state, &block_words[0], 6);
}
void blake3_compress_in_place_portable(uint32_t cv[8],
                                       const uint8_t block[BLAKE3_BLOCK_LEN],
                                       uint8_t block_len, uint64_t counter,
                                       uint8_t flags) {
  uint32_t state[16];
  compress_pre(state, cv, block, block_len, counter, flags);
  cv[0] = state[0] ^ state[8];
  cv[1] = state[1] ^ state[9];
  cv[2] = state[2] ^ state[10];
  cv[3] = state[3] ^ state[11];
  cv[4] = state[4] ^ state[12];
  cv[5] = state[5] ^ state[13];
  cv[6] = state[6] ^ state[14];
  cv[7] = state[7] ^ state[15];
}
void blake3_compress_xof_portable(const uint32_t cv[8],
                                  const uint8_t block[BLAKE3_BLOCK_LEN],
                                  uint8_t block_len, uint64_t counter,
                                  uint8_t flags, uint8_t out[64]) {
  uint32_t state[16];
  compress_pre(state, cv, block, block_len, counter, flags);
  store32(&out[0 * 4], state[0] ^ state[8]);
  store32(&out[1 * 4], state[1] ^ state[9]);
  store32(&out[2 * 4], state[2] ^ state[10]);
  store32(&out[3 * 4], state[3] ^ state[11]);
  store32(&out[4 * 4], state[4] ^ state[12]);
  store32(&out[5 * 4], state[5] ^ state[13]);
  store32(&out[6 * 4], state[6] ^ state[14]);
  store32(&out[7 * 4], state[7] ^ state[15]);
  store32(&out[8 * 4], state[8] ^ cv[0]);
  store32(&out[9 * 4], state[9] ^ cv[1]);
  store32(&out[10 * 4], state[10] ^ cv[2]);
  store32(&out[11 * 4], state[11] ^ cv[3]);
  store32(&out[12 * 4], state[12] ^ cv[4]);
  store32(&out[13 * 4], state[13] ^ cv[5]);
  store32(&out[14 * 4], state[14] ^ cv[6]);
  store32(&out[15 * 4], state[15] ^ cv[7]);
}
INLINE void hash_one_portable(const uint8_t *input, size_t blocks,
                              const uint32_t key[8], uint64_t counter,
                              uint8_t flags, uint8_t flags_start,
                              uint8_t flags_end, uint8_t out[BLAKE3_OUT_LEN]) {
  uint32_t cv[8];
  memcpy(cv, key, BLAKE3_KEY_LEN);
  uint8_t block_flags = flags | flags_start;
  while (blocks > 0) {
    if (blocks == 1) {
      block_flags |= flags_end;
    }
    blake3_compress_in_place_portable(cv, input, BLAKE3_BLOCK_LEN, counter,
                                      block_flags);
    input = &input[BLAKE3_BLOCK_LEN];
    blocks -= 1;
    block_flags = flags;
  }
  store_cv_words(out, cv);
}
void blake3_hash_many_portable(const uint8_t *const *inputs, size_t num_inputs,
                               size_t blocks, const uint32_t key[8],
                               uint64_t counter, bool increment_counter,
                               uint8_t flags, uint8_t flags_start,
                               uint8_t flags_end, uint8_t *out) {
  while (num_inputs > 0) {
    hash_one_portable(inputs[0], blocks, key, counter, flags, flags_start,
                      flags_end, out);
    if (increment_counter) {
      counter += 1;
    }
    inputs += 1;
    num_inputs -= 1;
    out = &out[BLAKE3_OUT_LEN];
  }
}
INLINE void chunk_state_init(blake3_chunk_state *self, const uint32_t key[8],
                             uint8_t flags) {
  memcpy(self->cv, key, BLAKE3_KEY_LEN);
  self->chunk_counter = 0;
  memset(self->buf, 0, BLAKE3_BLOCK_LEN);
  self->buf_len = 0;
  self->blocks_compressed = 0;
  self->flags = flags;
}
INLINE void chunk_state_reset(blake3_chunk_state *self, const uint32_t key[8],
                              uint64_t chunk_counter) {
  memcpy(self->cv, key, BLAKE3_KEY_LEN);
  self->chunk_counter = chunk_counter;
  self->blocks_compressed = 0;
  memset(self->buf, 0, BLAKE3_BLOCK_LEN);
  self->buf_len = 0;
}
INLINE size_t chunk_state_len(const blake3_chunk_state *self) {
  return (BLAKE3_BLOCK_LEN * (size_t)self->blocks_compressed) +
         ((size_t)self->buf_len);
}
INLINE size_t chunk_state_fill_buf(blake3_chunk_state *self,
                                   const uint8_t *input, size_t input_len) {
  size_t take = BLAKE3_BLOCK_LEN - ((size_t)self->buf_len);
  if (take > input_len) {
    take = input_len;
  }
  uint8_t *dest = self->buf + ((size_t)self->buf_len);
  memcpy(dest, input, take);
  self->buf_len += (uint8_t)take;
  return take;
}
INLINE uint8_t chunk_state_maybe_start_flag(const blake3_chunk_state *self) {
  if (self->blocks_compressed == 0) {
    return CHUNK_START;
  } else {
    return 0;
  }
}
typedef struct {
  uint32_t input_cv[8];
  uint64_t counter;
  uint8_t block[BLAKE3_BLOCK_LEN];
  uint8_t block_len;
  uint8_t flags;
} output_t;
INLINE output_t make_output(const uint32_t input_cv[8],
                            const uint8_t block[BLAKE3_BLOCK_LEN],
                            uint8_t block_len, uint64_t counter,
                            uint8_t flags) {
  output_t ret;
  memcpy(ret.input_cv, input_cv, 32);
  memcpy(ret.block, block, BLAKE3_BLOCK_LEN);
  ret.block_len = block_len;
  ret.counter = counter;
  ret.flags = flags;
  return ret;
}
INLINE void output_chaining_value(const output_t *self, uint8_t cv[32]) {
  uint32_t cv_words[8];
  memcpy(cv_words, self->input_cv, 32);
  blake3_compress_in_place(cv_words, self->block, self->block_len,
                           self->counter, self->flags);
  store_cv_words(cv, cv_words);
}
INLINE void output_root_bytes(const output_t *self, uint64_t seek, uint8_t *out,
                              size_t out_len) {
  uint64_t output_block_counter = seek / 64;
  size_t offset_within_block = seek % 64;
  uint8_t wide_buf[64];
  while (out_len > 0) {
    blake3_compress_xof(self->input_cv, self->block, self->block_len,
                        output_block_counter, self->flags | ROOT, wide_buf);
    size_t available_bytes = 64 - offset_within_block;
    size_t memcpy_len;
    if (out_len > available_bytes) {
      memcpy_len = available_bytes;
    } else {
      memcpy_len = out_len;
    }
    memcpy(out, wide_buf + offset_within_block, memcpy_len);
    out += memcpy_len;
    out_len -= memcpy_len;
    output_block_counter += 1;
    offset_within_block = 0;
  }
}
INLINE void chunk_state_update(blake3_chunk_state *self, const uint8_t *input,
                               size_t input_len) {
  if (self->buf_len > 0) {
    size_t take = chunk_state_fill_buf(self, input, input_len);
    input += take;
    input_len -= take;
    if (input_len > 0) {
      blake3_compress_in_place(
          self->cv, self->buf, BLAKE3_BLOCK_LEN, self->chunk_counter,
          self->flags | chunk_state_maybe_start_flag(self));
      self->blocks_compressed += 1;
      self->buf_len = 0;
      memset(self->buf, 0, BLAKE3_BLOCK_LEN);
    }
  }
  while (input_len > BLAKE3_BLOCK_LEN) {
    blake3_compress_in_place(self->cv, input, BLAKE3_BLOCK_LEN,
                             self->chunk_counter,
                             self->flags | chunk_state_maybe_start_flag(self));
    self->blocks_compressed += 1;
    input += BLAKE3_BLOCK_LEN;
    input_len -= BLAKE3_BLOCK_LEN;
  }
  size_t take = chunk_state_fill_buf(self, input, input_len);
  input += take;
  input_len -= take;
}
INLINE output_t chunk_state_output(const blake3_chunk_state *self) {
  uint8_t block_flags =
      self->flags | chunk_state_maybe_start_flag(self) | CHUNK_END;
  return make_output(self->cv, self->buf, self->buf_len, self->chunk_counter,
                     block_flags);
}
INLINE output_t parent_output(const uint8_t block[BLAKE3_BLOCK_LEN],
                              const uint32_t key[8], uint8_t flags) {
  return make_output(key, block, BLAKE3_BLOCK_LEN, 0, flags | PARENT);
}
INLINE size_t left_len(size_t content_len) {
  size_t full_chunks = (content_len - 1) / BLAKE3_CHUNK_LEN;
  return round_down_to_power_of_2(full_chunks) * BLAKE3_CHUNK_LEN;
}
INLINE size_t compress_chunks_parallel(const uint8_t *input, size_t input_len,
                                       const uint32_t key[8],
                                       uint64_t chunk_counter, uint8_t flags,
                                       uint8_t *out) {
#if defined(BLAKE3_TESTING)
  assert(0 < input_len);
  assert(input_len <= MAX_SIMD_DEGREE * BLAKE3_CHUNK_LEN);
#endif // corresponds to #if (#if defined(BLAKE3_TESTING))
  const uint8_t *chunks_array[MAX_SIMD_DEGREE];
  size_t input_position = 0;
  size_t chunks_array_len = 0;
  while (input_len - input_position >= BLAKE3_CHUNK_LEN) {
    chunks_array[chunks_array_len] = &input[input_position];
    input_position += BLAKE3_CHUNK_LEN;
    chunks_array_len += 1;
  }
  blake3_hash_many(chunks_array, chunks_array_len,
                   BLAKE3_CHUNK_LEN / BLAKE3_BLOCK_LEN, key, chunk_counter,
                   true, flags, CHUNK_START, CHUNK_END, out);
  if (input_len > input_position) {
    uint64_t counter = chunk_counter + (uint64_t)chunks_array_len;
    blake3_chunk_state chunk_state;
    chunk_state_init(&chunk_state, key, flags);
    chunk_state.chunk_counter = counter;
    chunk_state_update(&chunk_state, &input[input_position],
                       input_len - input_position);
    output_t output = chunk_state_output(&chunk_state);
    output_chaining_value(&output, &out[chunks_array_len * BLAKE3_OUT_LEN]);
    return chunks_array_len + 1;
  } else {
    return chunks_array_len;
  }
}
INLINE size_t compress_parents_parallel(const uint8_t *child_chaining_values,
                                        size_t num_chaining_values,
                                        const uint32_t key[8], uint8_t flags,
                                        uint8_t *out) {
#if defined(BLAKE3_TESTING)
  assert(2 <= num_chaining_values);
  assert(num_chaining_values <= 2 * MAX_SIMD_DEGREE_OR_2);
#endif // corresponds to #if (#if defined(BLAKE3_TESTING))
  const uint8_t *parents_array[MAX_SIMD_DEGREE_OR_2];
  size_t parents_array_len = 0;
  while (num_chaining_values - (2 * parents_array_len) >= 2) {
    parents_array[parents_array_len] =
        &child_chaining_values[2 * parents_array_len * BLAKE3_OUT_LEN];
    parents_array_len += 1;
  }
  blake3_hash_many(parents_array, parents_array_len, 1, key,
                   0,
                   false, flags | PARENT,
                   0,
                   0,
                   out);
  if (num_chaining_values > 2 * parents_array_len) {
    memcpy(&out[parents_array_len * BLAKE3_OUT_LEN],
           &child_chaining_values[2 * parents_array_len * BLAKE3_OUT_LEN],
           BLAKE3_OUT_LEN);
    return parents_array_len + 1;
  } else {
    return parents_array_len;
  }
}
static size_t blake3_compress_subtree_wide(const uint8_t *input,
                                           size_t input_len,
                                           const uint32_t key[8],
                                           uint64_t chunk_counter,
                                           uint8_t flags, uint8_t *out) {
  if (input_len <= blake3_simd_degree() * BLAKE3_CHUNK_LEN) {
    return compress_chunks_parallel(input, input_len, key, chunk_counter, flags,
                                    out);
  }
  size_t left_input_len = left_len(input_len);
  size_t right_input_len = input_len - left_input_len;
  const uint8_t *right_input = &input[left_input_len];
  uint64_t right_chunk_counter =
      chunk_counter + (uint64_t)(left_input_len / BLAKE3_CHUNK_LEN);
  uint8_t cv_array[2 * MAX_SIMD_DEGREE_OR_2 * BLAKE3_OUT_LEN];
  size_t degree = blake3_simd_degree();
  if (left_input_len > BLAKE3_CHUNK_LEN && degree == 1) {
    degree = 2;
  }
  uint8_t *right_cvs = &cv_array[degree * BLAKE3_OUT_LEN];
  size_t left_n = blake3_compress_subtree_wide(input, left_input_len, key,
                                               chunk_counter, flags, cv_array);
  size_t right_n = blake3_compress_subtree_wide(
      right_input, right_input_len, key, right_chunk_counter, flags, right_cvs);
  if (left_n == 1) {
    memcpy(out, cv_array, 2 * BLAKE3_OUT_LEN);
    return 2;
  }
  size_t num_chaining_values = left_n + right_n;
  return compress_parents_parallel(cv_array, num_chaining_values, key, flags,
                                   out);
}
INLINE void compress_subtree_to_parent_node(
    const uint8_t *input, size_t input_len, const uint32_t key[8],
    uint64_t chunk_counter, uint8_t flags, uint8_t out[2 * BLAKE3_OUT_LEN]) {
#if defined(BLAKE3_TESTING)
  assert(input_len > BLAKE3_CHUNK_LEN);
#endif // corresponds to #if (#if defined(BLAKE3_TESTING))
  uint8_t cv_array[MAX_SIMD_DEGREE_OR_2 * BLAKE3_OUT_LEN];
  size_t num_cvs = blake3_compress_subtree_wide(input, input_len, key,
                                                chunk_counter, flags, cv_array);
  uint8_t out_array[MAX_SIMD_DEGREE_OR_2 * BLAKE3_OUT_LEN / 2];
  while (num_cvs > 2) {
    num_cvs =
        compress_parents_parallel(cv_array, num_cvs, key, flags, out_array);
    memcpy(cv_array, out_array, num_cvs * BLAKE3_OUT_LEN);
  }
  memcpy(out, cv_array, 2 * BLAKE3_OUT_LEN);
}
INLINE void hasher_init_base(blake3_hasher *self, const uint32_t key[8],
                             uint8_t flags) {
  memcpy(self->key, key, BLAKE3_KEY_LEN);
  chunk_state_init(&self->chunk, key, flags);
  self->cv_stack_len = 0;
}
void blake3_hasher_init(blake3_hasher *self) { hasher_init_base(self, IV, 0); }
void blake3_hasher_init_derive_key_raw(blake3_hasher *self, const void *context,
                                       size_t context_len) {
  blake3_hasher context_hasher;
  hasher_init_base(&context_hasher, IV, DERIVE_KEY_CONTEXT);
  blake3_hasher_update(&context_hasher, context, context_len);
  uint8_t context_key[BLAKE3_KEY_LEN];
  blake3_hasher_finalize(&context_hasher, context_key, BLAKE3_KEY_LEN);
  uint32_t context_key_words[8];
  load_key_words(context_key, context_key_words);
  hasher_init_base(self, context_key_words, DERIVE_KEY_MATERIAL);
}
void blake3_hasher_init_derive_key(blake3_hasher *self, const char *context) {
  blake3_hasher_init_derive_key_raw(self, context, strlen(context));
}
INLINE void hasher_merge_cv_stack(blake3_hasher *self, uint64_t total_len) {
  size_t post_merge_stack_len = (size_t)popcnt(total_len);
  while (self->cv_stack_len > post_merge_stack_len) {
    uint8_t *parent_node =
        &self->cv_stack[(self->cv_stack_len - 2) * BLAKE3_OUT_LEN];
    output_t output = parent_output(parent_node, self->key, self->chunk.flags);
    output_chaining_value(&output, parent_node);
    self->cv_stack_len -= 1;
  }
}
INLINE void hasher_push_cv(blake3_hasher *self, uint8_t new_cv[BLAKE3_OUT_LEN],
                           uint64_t chunk_counter) {
  hasher_merge_cv_stack(self, chunk_counter);
  memcpy(&self->cv_stack[self->cv_stack_len * BLAKE3_OUT_LEN], new_cv,
         BLAKE3_OUT_LEN);
  self->cv_stack_len += 1;
}
void blake3_hasher_update(blake3_hasher *self, const void *input,
                          size_t input_len) {
  if (input_len == 0) {
    return;
  }
  const uint8_t *input_bytes = (const uint8_t *)input;
  if (chunk_state_len(&self->chunk) > 0) {
    size_t take = BLAKE3_CHUNK_LEN - chunk_state_len(&self->chunk);
    if (take > input_len) {
      take = input_len;
    }
    chunk_state_update(&self->chunk, input_bytes, take);
    input_bytes += take;
    input_len -= take;
    if (input_len > 0) {
      output_t output = chunk_state_output(&self->chunk);
      uint8_t chunk_cv[32];
      output_chaining_value(&output, chunk_cv);
      hasher_push_cv(self, chunk_cv, self->chunk.chunk_counter);
      chunk_state_reset(&self->chunk, self->key, self->chunk.chunk_counter + 1);
    } else {
      return;
    }
  }
  while (input_len > BLAKE3_CHUNK_LEN) {
    size_t subtree_len = round_down_to_power_of_2(input_len);
    uint64_t count_so_far = self->chunk.chunk_counter * BLAKE3_CHUNK_LEN;
    while ((((uint64_t)(subtree_len - 1)) & count_so_far) != 0) {
      subtree_len /= 2;
    }
    uint64_t subtree_chunks = subtree_len / BLAKE3_CHUNK_LEN;
    if (subtree_len <= BLAKE3_CHUNK_LEN) {
      blake3_chunk_state chunk_state;
      chunk_state_init(&chunk_state, self->key, self->chunk.flags);
      chunk_state.chunk_counter = self->chunk.chunk_counter;
      chunk_state_update(&chunk_state, input_bytes, subtree_len);
      output_t output = chunk_state_output(&chunk_state);
      uint8_t cv[BLAKE3_OUT_LEN];
      output_chaining_value(&output, cv);
      hasher_push_cv(self, cv, chunk_state.chunk_counter);
    } else {
      uint8_t cv_pair[2 * BLAKE3_OUT_LEN];
      compress_subtree_to_parent_node(input_bytes, subtree_len, self->key,
                                      self->chunk.chunk_counter,
                                      self->chunk.flags, cv_pair);
      hasher_push_cv(self, cv_pair, self->chunk.chunk_counter);
      hasher_push_cv(self, &cv_pair[BLAKE3_OUT_LEN],
                     self->chunk.chunk_counter + (subtree_chunks / 2));
    }
    self->chunk.chunk_counter += subtree_chunks;
    input_bytes += subtree_len;
    input_len -= subtree_len;
  }
  if (input_len > 0) {
    chunk_state_update(&self->chunk, input_bytes, input_len);
    hasher_merge_cv_stack(self, self->chunk.chunk_counter);
  }
}
void blake3_hasher_finalize(const blake3_hasher *self, uint8_t *out,
                            size_t out_len) {
  blake3_hasher_finalize_seek(self, 0, out, out_len);
}
void blake3_hasher_finalize_seek(const blake3_hasher *self, uint64_t seek,
                                 uint8_t *out, size_t out_len) {
  if (out_len == 0) {
    return;
  }
  if (self->cv_stack_len == 0) {
    output_t output = chunk_state_output(&self->chunk);
    output_root_bytes(&output, seek, out, out_len);
    return;
  }
  output_t output;
  size_t cvs_remaining;
  if (chunk_state_len(&self->chunk) > 0) {
    cvs_remaining = self->cv_stack_len;
    output = chunk_state_output(&self->chunk);
  } else {
    cvs_remaining = self->cv_stack_len - 2;
    output = parent_output(&self->cv_stack[cvs_remaining * 32], self->key,
                           self->chunk.flags);
  }
  while (cvs_remaining > 0) {
    cvs_remaining -= 1;
    uint8_t parent_block[BLAKE3_BLOCK_LEN];
    memcpy(parent_block, &self->cv_stack[cvs_remaining * 32], 32);
    output_chaining_value(&output, &parent_block[32]);
    output = parent_output(parent_block, self->key, self->chunk.flags);
  }
  output_root_bytes(&output, seek, out, out_len);
}
#endif ///HWBLAKE3 // corresponds to #if (#if !defined(HWBLAKE3))
/// LICENSE_END.15




/// LICENSE_START.16
/**
 * The Whirlpool hashing function.
 *
 * <P>
 * <b>References</b>
 *
 * <P>
 * The Whirlpool algorithm was developed by
 * <a href="mailto:pbarreto@scopus.com.br">Paulo S. L. M. Barreto</a> and
 * <a href="mailto:vincent.rijmen@cryptomathic.com">Vincent Rijmen</a>.
 */
typedef signed char s8;
typedef unsigned char u8;
#if UINT_MAX >= 4294967295UL
typedef signed short s16;
typedef signed int s32;
typedef unsigned short u16;
typedef unsigned int u32;
#define ONE32   0xffffffffU
#else
typedef signed int s16;
typedef signed long s32;
typedef unsigned int u16;
typedef unsigned long u32;
#define ONE32   0xffffffffUL
#endif // corresponds to #if (#if UINT_MAX >= 4294967295UL)
#define ONE8    0xffU
#define ONE16   0xffffU
#define T8(x)   ((x) & ONE8)
#define T16(x)  ((x) & ONE16)
#define T32(x)  ((x) & ONE32)
#ifdef _MSC_VER
typedef unsigned __int64 u64;
typedef signed __int64 s64;
#define LL(v)   (v##i64)
#define ONE64   LL(0xffffffffffffffff)
#else
typedef unsigned long long u64;
typedef signed long long s64;
#define LL(v)   (v##ULL)
#define ONE64   LL(0xffffffffffffffff)
#endif // corresponds to #ifdef (#ifdef _MSC_VER)
#define T64(x)  ((x) & ONE64)
#define ROTR64(v, n)   (((v) >> (n)) | T64((v) << (64 - (n))))
#define U8TO32_BIG(c)  (((u32)T8(*(c)) << 24) | ((u32)T8(*((c) + 1)) << 16) | ((u32)T8(*((c) + 2)) << 8) | ((u32)T8(*((c) + 3))))
#define U8TO32_LITTLE(c)  (((u32)T8(*(c))) | ((u32)T8(*((c) + 1)) << 8) | (u32)T8(*((c) + 2)) << 16) | ((u32)T8(*((c) + 3)) << 24))
#define U32TO8_BIG(c, v)    do { u32 x = (v); u8 *d = (c); d[0] = T8(x >> 24); d[1] = T8(x >> 16); d[2] = T8(x >> 8); d[3] = T8(x); } while (0)
#define U32TO8_LITTLE(c, v)    do { u32 x = (v); u8 *d = (c); d[0] = T8(x); d[1] = T8(x >> 8); d[2] = T8(x >> 16); d[3] = T8(x >> 24); } while (0)
#define ROTL32(v, n)   (T32((v) << (n)) | ((v) >> (32 - (n))))
#define DIGESTBYTES 64
#define DIGESTBITS  (8*DIGESTBYTES)
#define WBLOCKBYTES 64
#define LENGTHBYTES 32
typedef struct NESSIEstruct {
	u8  bitLength[LENGTHBYTES];
	u8  buffer[WBLOCKBYTES];
	int bufferBits;
	int bufferPos;
	u64 hash[DIGESTBYTES/8];
} NESSIEstruct;
#define WHIRLPOOL_R 10
static const u64 C0[256] = {
    LL(0x18186018c07830d8), LL(0x23238c2305af4626), LL(0xc6c63fc67ef991b8), LL(0xe8e887e8136fcdfb),
    LL(0x878726874ca113cb), LL(0xb8b8dab8a9626d11), LL(0x0101040108050209), LL(0x4f4f214f426e9e0d),
    LL(0x3636d836adee6c9b), LL(0xa6a6a2a6590451ff), LL(0xd2d26fd2debdb90c), LL(0xf5f5f3f5fb06f70e),
    LL(0x7979f979ef80f296), LL(0x6f6fa16f5fcede30), LL(0x91917e91fcef3f6d), LL(0x52525552aa07a4f8),
    LL(0x60609d6027fdc047), LL(0xbcbccabc89766535), LL(0x9b9b569baccd2b37), LL(0x8e8e028e048c018a),
    LL(0xa3a3b6a371155bd2), LL(0x0c0c300c603c186c), LL(0x7b7bf17bff8af684), LL(0x3535d435b5e16a80),
    LL(0x1d1d741de8693af5), LL(0xe0e0a7e05347ddb3), LL(0xd7d77bd7f6acb321), LL(0xc2c22fc25eed999c),
    LL(0x2e2eb82e6d965c43), LL(0x4b4b314b627a9629), LL(0xfefedffea321e15d), LL(0x575741578216aed5),
    LL(0x15155415a8412abd), LL(0x7777c1779fb6eee8), LL(0x3737dc37a5eb6e92), LL(0xe5e5b3e57b56d79e),
    LL(0x9f9f469f8cd92313), LL(0xf0f0e7f0d317fd23), LL(0x4a4a354a6a7f9420), LL(0xdada4fda9e95a944),
    LL(0x58587d58fa25b0a2), LL(0xc9c903c906ca8fcf), LL(0x2929a429558d527c), LL(0x0a0a280a5022145a),
    LL(0xb1b1feb1e14f7f50), LL(0xa0a0baa0691a5dc9), LL(0x6b6bb16b7fdad614), LL(0x85852e855cab17d9),
    LL(0xbdbdcebd8173673c), LL(0x5d5d695dd234ba8f), LL(0x1010401080502090), LL(0xf4f4f7f4f303f507),
    LL(0xcbcb0bcb16c08bdd), LL(0x3e3ef83eedc67cd3), LL(0x0505140528110a2d), LL(0x676781671fe6ce78),
    LL(0xe4e4b7e47353d597), LL(0x27279c2725bb4e02), LL(0x4141194132588273), LL(0x8b8b168b2c9d0ba7),
    LL(0xa7a7a6a7510153f6), LL(0x7d7de97dcf94fab2), LL(0x95956e95dcfb3749), LL(0xd8d847d88e9fad56),
    LL(0xfbfbcbfb8b30eb70), LL(0xeeee9fee2371c1cd), LL(0x7c7ced7cc791f8bb), LL(0x6666856617e3cc71),
    LL(0xdddd53dda68ea77b), LL(0x17175c17b84b2eaf), LL(0x4747014702468e45), LL(0x9e9e429e84dc211a),
    LL(0xcaca0fca1ec589d4), LL(0x2d2db42d75995a58), LL(0xbfbfc6bf9179632e), LL(0x07071c07381b0e3f),
    LL(0xadad8ead012347ac), LL(0x5a5a755aea2fb4b0), LL(0x838336836cb51bef), LL(0x3333cc3385ff66b6),
    LL(0x636391633ff2c65c), LL(0x02020802100a0412), LL(0xaaaa92aa39384993), LL(0x7171d971afa8e2de),
    LL(0xc8c807c80ecf8dc6), LL(0x19196419c87d32d1), LL(0x494939497270923b), LL(0xd9d943d9869aaf5f),
    LL(0xf2f2eff2c31df931), LL(0xe3e3abe34b48dba8), LL(0x5b5b715be22ab6b9), LL(0x88881a8834920dbc),
    LL(0x9a9a529aa4c8293e), LL(0x262698262dbe4c0b), LL(0x3232c8328dfa64bf), LL(0xb0b0fab0e94a7d59),
    LL(0xe9e983e91b6acff2), LL(0x0f0f3c0f78331e77), LL(0xd5d573d5e6a6b733), LL(0x80803a8074ba1df4),
    LL(0xbebec2be997c6127), LL(0xcdcd13cd26de87eb), LL(0x3434d034bde46889), LL(0x48483d487a759032),
    LL(0xffffdbffab24e354), LL(0x7a7af57af78ff48d), LL(0x90907a90f4ea3d64), LL(0x5f5f615fc23ebe9d),
    LL(0x202080201da0403d), LL(0x6868bd6867d5d00f), LL(0x1a1a681ad07234ca), LL(0xaeae82ae192c41b7),
    LL(0xb4b4eab4c95e757d), LL(0x54544d549a19a8ce), LL(0x93937693ece53b7f), LL(0x222288220daa442f),
    LL(0x64648d6407e9c863), LL(0xf1f1e3f1db12ff2a), LL(0x7373d173bfa2e6cc), LL(0x12124812905a2482),
    LL(0x40401d403a5d807a), LL(0x0808200840281048), LL(0xc3c32bc356e89b95), LL(0xecec97ec337bc5df),
    LL(0xdbdb4bdb9690ab4d), LL(0xa1a1bea1611f5fc0), LL(0x8d8d0e8d1c830791), LL(0x3d3df43df5c97ac8),
    LL(0x97976697ccf1335b), LL(0x0000000000000000), LL(0xcfcf1bcf36d483f9), LL(0x2b2bac2b4587566e),
    LL(0x7676c57697b3ece1), LL(0x8282328264b019e6), LL(0xd6d67fd6fea9b128), LL(0x1b1b6c1bd87736c3),
    LL(0xb5b5eeb5c15b7774), LL(0xafaf86af112943be), LL(0x6a6ab56a77dfd41d), LL(0x50505d50ba0da0ea),
    LL(0x45450945124c8a57), LL(0xf3f3ebf3cb18fb38), LL(0x3030c0309df060ad), LL(0xefef9bef2b74c3c4),
    LL(0x3f3ffc3fe5c37eda), LL(0x55554955921caac7), LL(0xa2a2b2a2791059db), LL(0xeaea8fea0365c9e9),
    LL(0x656589650fecca6a), LL(0xbabad2bab9686903), LL(0x2f2fbc2f65935e4a), LL(0xc0c027c04ee79d8e),
    LL(0xdede5fdebe81a160), LL(0x1c1c701ce06c38fc), LL(0xfdfdd3fdbb2ee746), LL(0x4d4d294d52649a1f),
    LL(0x92927292e4e03976), LL(0x7575c9758fbceafa), LL(0x06061806301e0c36), LL(0x8a8a128a249809ae),
    LL(0xb2b2f2b2f940794b), LL(0xe6e6bfe66359d185), LL(0x0e0e380e70361c7e), LL(0x1f1f7c1ff8633ee7),
    LL(0x6262956237f7c455), LL(0xd4d477d4eea3b53a), LL(0xa8a89aa829324d81), LL(0x96966296c4f43152),
    LL(0xf9f9c3f99b3aef62), LL(0xc5c533c566f697a3), LL(0x2525942535b14a10), LL(0x59597959f220b2ab),
    LL(0x84842a8454ae15d0), LL(0x7272d572b7a7e4c5), LL(0x3939e439d5dd72ec), LL(0x4c4c2d4c5a619816),
    LL(0x5e5e655eca3bbc94), LL(0x7878fd78e785f09f), LL(0x3838e038ddd870e5), LL(0x8c8c0a8c14860598),
    LL(0xd1d163d1c6b2bf17), LL(0xa5a5aea5410b57e4), LL(0xe2e2afe2434dd9a1), LL(0x616199612ff8c24e),
    LL(0xb3b3f6b3f1457b42), LL(0x2121842115a54234), LL(0x9c9c4a9c94d62508), LL(0x1e1e781ef0663cee),
    LL(0x4343114322528661), LL(0xc7c73bc776fc93b1), LL(0xfcfcd7fcb32be54f), LL(0x0404100420140824),
    LL(0x51515951b208a2e3), LL(0x99995e99bcc72f25), LL(0x6d6da96d4fc4da22), LL(0x0d0d340d68391a65),
    LL(0xfafacffa8335e979), LL(0xdfdf5bdfb684a369), LL(0x7e7ee57ed79bfca9), LL(0x242490243db44819),
    LL(0x3b3bec3bc5d776fe), LL(0xabab96ab313d4b9a), LL(0xcece1fce3ed181f0), LL(0x1111441188552299),
    LL(0x8f8f068f0c890383), LL(0x4e4e254e4a6b9c04), LL(0xb7b7e6b7d1517366), LL(0xebeb8beb0b60cbe0),
    LL(0x3c3cf03cfdcc78c1), LL(0x81813e817cbf1ffd), LL(0x94946a94d4fe3540), LL(0xf7f7fbf7eb0cf31c),
    LL(0xb9b9deb9a1676f18), LL(0x13134c13985f268b), LL(0x2c2cb02c7d9c5851), LL(0xd3d36bd3d6b8bb05),
    LL(0xe7e7bbe76b5cd38c), LL(0x6e6ea56e57cbdc39), LL(0xc4c437c46ef395aa), LL(0x03030c03180f061b),
    LL(0x565645568a13acdc), LL(0x44440d441a49885e), LL(0x7f7fe17fdf9efea0), LL(0xa9a99ea921374f88),
    LL(0x2a2aa82a4d825467), LL(0xbbbbd6bbb16d6b0a), LL(0xc1c123c146e29f87), LL(0x53535153a202a6f1),
    LL(0xdcdc57dcae8ba572), LL(0x0b0b2c0b58271653), LL(0x9d9d4e9d9cd32701), LL(0x6c6cad6c47c1d82b),
    LL(0x3131c43195f562a4), LL(0x7474cd7487b9e8f3), LL(0xf6f6fff6e309f115), LL(0x464605460a438c4c),
    LL(0xacac8aac092645a5), LL(0x89891e893c970fb5), LL(0x14145014a04428b4), LL(0xe1e1a3e15b42dfba),
    LL(0x16165816b04e2ca6), LL(0x3a3ae83acdd274f7), LL(0x6969b9696fd0d206), LL(0x09092409482d1241),
    LL(0x7070dd70a7ade0d7), LL(0xb6b6e2b6d954716f), LL(0xd0d067d0ceb7bd1e), LL(0xeded93ed3b7ec7d6),
    LL(0xcccc17cc2edb85e2), LL(0x424215422a578468), LL(0x98985a98b4c22d2c), LL(0xa4a4aaa4490e55ed),
    LL(0x2828a0285d885075), LL(0x5c5c6d5cda31b886), LL(0xf8f8c7f8933fed6b), LL(0x8686228644a411c2),
};
static const u64 C1[256] = {
    LL(0xd818186018c07830), LL(0x2623238c2305af46), LL(0xb8c6c63fc67ef991), LL(0xfbe8e887e8136fcd),
    LL(0xcb878726874ca113), LL(0x11b8b8dab8a9626d), LL(0x0901010401080502), LL(0x0d4f4f214f426e9e),
    LL(0x9b3636d836adee6c), LL(0xffa6a6a2a6590451), LL(0x0cd2d26fd2debdb9), LL(0x0ef5f5f3f5fb06f7),
    LL(0x967979f979ef80f2), LL(0x306f6fa16f5fcede), LL(0x6d91917e91fcef3f), LL(0xf852525552aa07a4),
    LL(0x4760609d6027fdc0), LL(0x35bcbccabc897665), LL(0x379b9b569baccd2b), LL(0x8a8e8e028e048c01),
    LL(0xd2a3a3b6a371155b), LL(0x6c0c0c300c603c18), LL(0x847b7bf17bff8af6), LL(0x803535d435b5e16a),
    LL(0xf51d1d741de8693a), LL(0xb3e0e0a7e05347dd), LL(0x21d7d77bd7f6acb3), LL(0x9cc2c22fc25eed99),
    LL(0x432e2eb82e6d965c), LL(0x294b4b314b627a96), LL(0x5dfefedffea321e1), LL(0xd5575741578216ae),
    LL(0xbd15155415a8412a), LL(0xe87777c1779fb6ee), LL(0x923737dc37a5eb6e), LL(0x9ee5e5b3e57b56d7),
    LL(0x139f9f469f8cd923), LL(0x23f0f0e7f0d317fd), LL(0x204a4a354a6a7f94), LL(0x44dada4fda9e95a9),
    LL(0xa258587d58fa25b0), LL(0xcfc9c903c906ca8f), LL(0x7c2929a429558d52), LL(0x5a0a0a280a502214),
    LL(0x50b1b1feb1e14f7f), LL(0xc9a0a0baa0691a5d), LL(0x146b6bb16b7fdad6), LL(0xd985852e855cab17),
    LL(0x3cbdbdcebd817367), LL(0x8f5d5d695dd234ba), LL(0x9010104010805020), LL(0x07f4f4f7f4f303f5),
    LL(0xddcbcb0bcb16c08b), LL(0xd33e3ef83eedc67c), LL(0x2d0505140528110a), LL(0x78676781671fe6ce),
    LL(0x97e4e4b7e47353d5), LL(0x0227279c2725bb4e), LL(0x7341411941325882), LL(0xa78b8b168b2c9d0b),
    LL(0xf6a7a7a6a7510153), LL(0xb27d7de97dcf94fa), LL(0x4995956e95dcfb37), LL(0x56d8d847d88e9fad),
    LL(0x70fbfbcbfb8b30eb), LL(0xcdeeee9fee2371c1), LL(0xbb7c7ced7cc791f8), LL(0x716666856617e3cc),
    LL(0x7bdddd53dda68ea7), LL(0xaf17175c17b84b2e), LL(0x454747014702468e), LL(0x1a9e9e429e84dc21),
    LL(0xd4caca0fca1ec589), LL(0x582d2db42d75995a), LL(0x2ebfbfc6bf917963), LL(0x3f07071c07381b0e),
    LL(0xacadad8ead012347), LL(0xb05a5a755aea2fb4), LL(0xef838336836cb51b), LL(0xb63333cc3385ff66),
    LL(0x5c636391633ff2c6), LL(0x1202020802100a04), LL(0x93aaaa92aa393849), LL(0xde7171d971afa8e2),
    LL(0xc6c8c807c80ecf8d), LL(0xd119196419c87d32), LL(0x3b49493949727092), LL(0x5fd9d943d9869aaf),
    LL(0x31f2f2eff2c31df9), LL(0xa8e3e3abe34b48db), LL(0xb95b5b715be22ab6), LL(0xbc88881a8834920d),
    LL(0x3e9a9a529aa4c829), LL(0x0b262698262dbe4c), LL(0xbf3232c8328dfa64), LL(0x59b0b0fab0e94a7d),
    LL(0xf2e9e983e91b6acf), LL(0x770f0f3c0f78331e), LL(0x33d5d573d5e6a6b7), LL(0xf480803a8074ba1d),
    LL(0x27bebec2be997c61), LL(0xebcdcd13cd26de87), LL(0x893434d034bde468), LL(0x3248483d487a7590),
    LL(0x54ffffdbffab24e3), LL(0x8d7a7af57af78ff4), LL(0x6490907a90f4ea3d), LL(0x9d5f5f615fc23ebe),
    LL(0x3d202080201da040), LL(0x0f6868bd6867d5d0), LL(0xca1a1a681ad07234), LL(0xb7aeae82ae192c41),
    LL(0x7db4b4eab4c95e75), LL(0xce54544d549a19a8), LL(0x7f93937693ece53b), LL(0x2f222288220daa44),
    LL(0x6364648d6407e9c8), LL(0x2af1f1e3f1db12ff), LL(0xcc7373d173bfa2e6), LL(0x8212124812905a24),
    LL(0x7a40401d403a5d80), LL(0x4808082008402810), LL(0x95c3c32bc356e89b), LL(0xdfecec97ec337bc5),
    LL(0x4ddbdb4bdb9690ab), LL(0xc0a1a1bea1611f5f), LL(0x918d8d0e8d1c8307), LL(0xc83d3df43df5c97a),
    LL(0x5b97976697ccf133), LL(0x0000000000000000), LL(0xf9cfcf1bcf36d483), LL(0x6e2b2bac2b458756),
    LL(0xe17676c57697b3ec), LL(0xe68282328264b019), LL(0x28d6d67fd6fea9b1), LL(0xc31b1b6c1bd87736),
    LL(0x74b5b5eeb5c15b77), LL(0xbeafaf86af112943), LL(0x1d6a6ab56a77dfd4), LL(0xea50505d50ba0da0),
    LL(0x5745450945124c8a), LL(0x38f3f3ebf3cb18fb), LL(0xad3030c0309df060), LL(0xc4efef9bef2b74c3),
    LL(0xda3f3ffc3fe5c37e), LL(0xc755554955921caa), LL(0xdba2a2b2a2791059), LL(0xe9eaea8fea0365c9),
    LL(0x6a656589650fecca), LL(0x03babad2bab96869), LL(0x4a2f2fbc2f65935e), LL(0x8ec0c027c04ee79d),
    LL(0x60dede5fdebe81a1), LL(0xfc1c1c701ce06c38), LL(0x46fdfdd3fdbb2ee7), LL(0x1f4d4d294d52649a),
    LL(0x7692927292e4e039), LL(0xfa7575c9758fbcea), LL(0x3606061806301e0c), LL(0xae8a8a128a249809),
    LL(0x4bb2b2f2b2f94079), LL(0x85e6e6bfe66359d1), LL(0x7e0e0e380e70361c), LL(0xe71f1f7c1ff8633e),
    LL(0x556262956237f7c4), LL(0x3ad4d477d4eea3b5), LL(0x81a8a89aa829324d), LL(0x5296966296c4f431),
    LL(0x62f9f9c3f99b3aef), LL(0xa3c5c533c566f697), LL(0x102525942535b14a), LL(0xab59597959f220b2),
    LL(0xd084842a8454ae15), LL(0xc57272d572b7a7e4), LL(0xec3939e439d5dd72), LL(0x164c4c2d4c5a6198),
    LL(0x945e5e655eca3bbc), LL(0x9f7878fd78e785f0), LL(0xe53838e038ddd870), LL(0x988c8c0a8c148605),
    LL(0x17d1d163d1c6b2bf), LL(0xe4a5a5aea5410b57), LL(0xa1e2e2afe2434dd9), LL(0x4e616199612ff8c2),
    LL(0x42b3b3f6b3f1457b), LL(0x342121842115a542), LL(0x089c9c4a9c94d625), LL(0xee1e1e781ef0663c),
    LL(0x6143431143225286), LL(0xb1c7c73bc776fc93), LL(0x4ffcfcd7fcb32be5), LL(0x2404041004201408),
    LL(0xe351515951b208a2), LL(0x2599995e99bcc72f), LL(0x226d6da96d4fc4da), LL(0x650d0d340d68391a),
    LL(0x79fafacffa8335e9), LL(0x69dfdf5bdfb684a3), LL(0xa97e7ee57ed79bfc), LL(0x19242490243db448),
    LL(0xfe3b3bec3bc5d776), LL(0x9aabab96ab313d4b), LL(0xf0cece1fce3ed181), LL(0x9911114411885522),
    LL(0x838f8f068f0c8903), LL(0x044e4e254e4a6b9c), LL(0x66b7b7e6b7d15173), LL(0xe0ebeb8beb0b60cb),
    LL(0xc13c3cf03cfdcc78), LL(0xfd81813e817cbf1f), LL(0x4094946a94d4fe35), LL(0x1cf7f7fbf7eb0cf3),
    LL(0x18b9b9deb9a1676f), LL(0x8b13134c13985f26), LL(0x512c2cb02c7d9c58), LL(0x05d3d36bd3d6b8bb),
    LL(0x8ce7e7bbe76b5cd3), LL(0x396e6ea56e57cbdc), LL(0xaac4c437c46ef395), LL(0x1b03030c03180f06),
    LL(0xdc565645568a13ac), LL(0x5e44440d441a4988), LL(0xa07f7fe17fdf9efe), LL(0x88a9a99ea921374f),
    LL(0x672a2aa82a4d8254), LL(0x0abbbbd6bbb16d6b), LL(0x87c1c123c146e29f), LL(0xf153535153a202a6),
    LL(0x72dcdc57dcae8ba5), LL(0x530b0b2c0b582716), LL(0x019d9d4e9d9cd327), LL(0x2b6c6cad6c47c1d8),
    LL(0xa43131c43195f562), LL(0xf37474cd7487b9e8), LL(0x15f6f6fff6e309f1), LL(0x4c464605460a438c),
    LL(0xa5acac8aac092645), LL(0xb589891e893c970f), LL(0xb414145014a04428), LL(0xbae1e1a3e15b42df),
    LL(0xa616165816b04e2c), LL(0xf73a3ae83acdd274), LL(0x066969b9696fd0d2), LL(0x4109092409482d12),
    LL(0xd77070dd70a7ade0), LL(0x6fb6b6e2b6d95471), LL(0x1ed0d067d0ceb7bd), LL(0xd6eded93ed3b7ec7),
    LL(0xe2cccc17cc2edb85), LL(0x68424215422a5784), LL(0x2c98985a98b4c22d), LL(0xeda4a4aaa4490e55),
    LL(0x752828a0285d8850), LL(0x865c5c6d5cda31b8), LL(0x6bf8f8c7f8933fed), LL(0xc28686228644a411),
};
static const u64 C2[256] = {
    LL(0x30d818186018c078), LL(0x462623238c2305af), LL(0x91b8c6c63fc67ef9), LL(0xcdfbe8e887e8136f),
    LL(0x13cb878726874ca1), LL(0x6d11b8b8dab8a962), LL(0x0209010104010805), LL(0x9e0d4f4f214f426e),
    LL(0x6c9b3636d836adee), LL(0x51ffa6a6a2a65904), LL(0xb90cd2d26fd2debd), LL(0xf70ef5f5f3f5fb06),
    LL(0xf2967979f979ef80), LL(0xde306f6fa16f5fce), LL(0x3f6d91917e91fcef), LL(0xa4f852525552aa07),
    LL(0xc04760609d6027fd), LL(0x6535bcbccabc8976), LL(0x2b379b9b569baccd), LL(0x018a8e8e028e048c),
    LL(0x5bd2a3a3b6a37115), LL(0x186c0c0c300c603c), LL(0xf6847b7bf17bff8a), LL(0x6a803535d435b5e1),
    LL(0x3af51d1d741de869), LL(0xddb3e0e0a7e05347), LL(0xb321d7d77bd7f6ac), LL(0x999cc2c22fc25eed),
    LL(0x5c432e2eb82e6d96), LL(0x96294b4b314b627a), LL(0xe15dfefedffea321), LL(0xaed5575741578216),
    LL(0x2abd15155415a841), LL(0xeee87777c1779fb6), LL(0x6e923737dc37a5eb), LL(0xd79ee5e5b3e57b56),
    LL(0x23139f9f469f8cd9), LL(0xfd23f0f0e7f0d317), LL(0x94204a4a354a6a7f), LL(0xa944dada4fda9e95),
    LL(0xb0a258587d58fa25), LL(0x8fcfc9c903c906ca), LL(0x527c2929a429558d), LL(0x145a0a0a280a5022),
    LL(0x7f50b1b1feb1e14f), LL(0x5dc9a0a0baa0691a), LL(0xd6146b6bb16b7fda), LL(0x17d985852e855cab),
    LL(0x673cbdbdcebd8173), LL(0xba8f5d5d695dd234), LL(0x2090101040108050), LL(0xf507f4f4f7f4f303),
    LL(0x8bddcbcb0bcb16c0), LL(0x7cd33e3ef83eedc6), LL(0x0a2d050514052811), LL(0xce78676781671fe6),
    LL(0xd597e4e4b7e47353), LL(0x4e0227279c2725bb), LL(0x8273414119413258), LL(0x0ba78b8b168b2c9d),
    LL(0x53f6a7a7a6a75101), LL(0xfab27d7de97dcf94), LL(0x374995956e95dcfb), LL(0xad56d8d847d88e9f),
    LL(0xeb70fbfbcbfb8b30), LL(0xc1cdeeee9fee2371), LL(0xf8bb7c7ced7cc791), LL(0xcc716666856617e3),
    LL(0xa77bdddd53dda68e), LL(0x2eaf17175c17b84b), LL(0x8e45474701470246), LL(0x211a9e9e429e84dc),
    LL(0x89d4caca0fca1ec5), LL(0x5a582d2db42d7599), LL(0x632ebfbfc6bf9179), LL(0x0e3f07071c07381b),
    LL(0x47acadad8ead0123), LL(0xb4b05a5a755aea2f), LL(0x1bef838336836cb5), LL(0x66b63333cc3385ff),
    LL(0xc65c636391633ff2), LL(0x041202020802100a), LL(0x4993aaaa92aa3938), LL(0xe2de7171d971afa8),
    LL(0x8dc6c8c807c80ecf), LL(0x32d119196419c87d), LL(0x923b494939497270), LL(0xaf5fd9d943d9869a),
    LL(0xf931f2f2eff2c31d), LL(0xdba8e3e3abe34b48), LL(0xb6b95b5b715be22a), LL(0x0dbc88881a883492),
    LL(0x293e9a9a529aa4c8), LL(0x4c0b262698262dbe), LL(0x64bf3232c8328dfa), LL(0x7d59b0b0fab0e94a),
    LL(0xcff2e9e983e91b6a), LL(0x1e770f0f3c0f7833), LL(0xb733d5d573d5e6a6), LL(0x1df480803a8074ba),
    LL(0x6127bebec2be997c), LL(0x87ebcdcd13cd26de), LL(0x68893434d034bde4), LL(0x903248483d487a75),
    LL(0xe354ffffdbffab24), LL(0xf48d7a7af57af78f), LL(0x3d6490907a90f4ea), LL(0xbe9d5f5f615fc23e),
    LL(0x403d202080201da0), LL(0xd00f6868bd6867d5), LL(0x34ca1a1a681ad072), LL(0x41b7aeae82ae192c),
    LL(0x757db4b4eab4c95e), LL(0xa8ce54544d549a19), LL(0x3b7f93937693ece5), LL(0x442f222288220daa),
    LL(0xc86364648d6407e9), LL(0xff2af1f1e3f1db12), LL(0xe6cc7373d173bfa2), LL(0x248212124812905a),
    LL(0x807a40401d403a5d), LL(0x1048080820084028), LL(0x9b95c3c32bc356e8), LL(0xc5dfecec97ec337b),
    LL(0xab4ddbdb4bdb9690), LL(0x5fc0a1a1bea1611f), LL(0x07918d8d0e8d1c83), LL(0x7ac83d3df43df5c9),
    LL(0x335b97976697ccf1), LL(0x0000000000000000), LL(0x83f9cfcf1bcf36d4), LL(0x566e2b2bac2b4587),
    LL(0xece17676c57697b3), LL(0x19e68282328264b0), LL(0xb128d6d67fd6fea9), LL(0x36c31b1b6c1bd877),
    LL(0x7774b5b5eeb5c15b), LL(0x43beafaf86af1129), LL(0xd41d6a6ab56a77df), LL(0xa0ea50505d50ba0d),
    LL(0x8a5745450945124c), LL(0xfb38f3f3ebf3cb18), LL(0x60ad3030c0309df0), LL(0xc3c4efef9bef2b74),
    LL(0x7eda3f3ffc3fe5c3), LL(0xaac755554955921c), LL(0x59dba2a2b2a27910), LL(0xc9e9eaea8fea0365),
    LL(0xca6a656589650fec), LL(0x6903babad2bab968), LL(0x5e4a2f2fbc2f6593), LL(0x9d8ec0c027c04ee7),
    LL(0xa160dede5fdebe81), LL(0x38fc1c1c701ce06c), LL(0xe746fdfdd3fdbb2e), LL(0x9a1f4d4d294d5264),
    LL(0x397692927292e4e0), LL(0xeafa7575c9758fbc), LL(0x0c3606061806301e), LL(0x09ae8a8a128a2498),
    LL(0x794bb2b2f2b2f940), LL(0xd185e6e6bfe66359), LL(0x1c7e0e0e380e7036), LL(0x3ee71f1f7c1ff863),
    LL(0xc4556262956237f7), LL(0xb53ad4d477d4eea3), LL(0x4d81a8a89aa82932), LL(0x315296966296c4f4),
    LL(0xef62f9f9c3f99b3a), LL(0x97a3c5c533c566f6), LL(0x4a102525942535b1), LL(0xb2ab59597959f220),
    LL(0x15d084842a8454ae), LL(0xe4c57272d572b7a7), LL(0x72ec3939e439d5dd), LL(0x98164c4c2d4c5a61),
    LL(0xbc945e5e655eca3b), LL(0xf09f7878fd78e785), LL(0x70e53838e038ddd8), LL(0x05988c8c0a8c1486),
    LL(0xbf17d1d163d1c6b2), LL(0x57e4a5a5aea5410b), LL(0xd9a1e2e2afe2434d), LL(0xc24e616199612ff8),
    LL(0x7b42b3b3f6b3f145), LL(0x42342121842115a5), LL(0x25089c9c4a9c94d6), LL(0x3cee1e1e781ef066),
    LL(0x8661434311432252), LL(0x93b1c7c73bc776fc), LL(0xe54ffcfcd7fcb32b), LL(0x0824040410042014),
    LL(0xa2e351515951b208), LL(0x2f2599995e99bcc7), LL(0xda226d6da96d4fc4), LL(0x1a650d0d340d6839),
    LL(0xe979fafacffa8335), LL(0xa369dfdf5bdfb684), LL(0xfca97e7ee57ed79b), LL(0x4819242490243db4),
    LL(0x76fe3b3bec3bc5d7), LL(0x4b9aabab96ab313d), LL(0x81f0cece1fce3ed1), LL(0x2299111144118855),
    LL(0x03838f8f068f0c89), LL(0x9c044e4e254e4a6b), LL(0x7366b7b7e6b7d151), LL(0xcbe0ebeb8beb0b60),
    LL(0x78c13c3cf03cfdcc), LL(0x1ffd81813e817cbf), LL(0x354094946a94d4fe), LL(0xf31cf7f7fbf7eb0c),
    LL(0x6f18b9b9deb9a167), LL(0x268b13134c13985f), LL(0x58512c2cb02c7d9c), LL(0xbb05d3d36bd3d6b8),
    LL(0xd38ce7e7bbe76b5c), LL(0xdc396e6ea56e57cb), LL(0x95aac4c437c46ef3), LL(0x061b03030c03180f),
    LL(0xacdc565645568a13), LL(0x885e44440d441a49), LL(0xfea07f7fe17fdf9e), LL(0x4f88a9a99ea92137),
    LL(0x54672a2aa82a4d82), LL(0x6b0abbbbd6bbb16d), LL(0x9f87c1c123c146e2), LL(0xa6f153535153a202),
    LL(0xa572dcdc57dcae8b), LL(0x16530b0b2c0b5827), LL(0x27019d9d4e9d9cd3), LL(0xd82b6c6cad6c47c1),
    LL(0x62a43131c43195f5), LL(0xe8f37474cd7487b9), LL(0xf115f6f6fff6e309), LL(0x8c4c464605460a43),
    LL(0x45a5acac8aac0926), LL(0x0fb589891e893c97), LL(0x28b414145014a044), LL(0xdfbae1e1a3e15b42),
    LL(0x2ca616165816b04e), LL(0x74f73a3ae83acdd2), LL(0xd2066969b9696fd0), LL(0x124109092409482d),
    LL(0xe0d77070dd70a7ad), LL(0x716fb6b6e2b6d954), LL(0xbd1ed0d067d0ceb7), LL(0xc7d6eded93ed3b7e),
    LL(0x85e2cccc17cc2edb), LL(0x8468424215422a57), LL(0x2d2c98985a98b4c2), LL(0x55eda4a4aaa4490e),
    LL(0x50752828a0285d88), LL(0xb8865c5c6d5cda31), LL(0xed6bf8f8c7f8933f), LL(0x11c28686228644a4),
};
static const u64 C3[256] = {
    LL(0x7830d818186018c0), LL(0xaf462623238c2305), LL(0xf991b8c6c63fc67e), LL(0x6fcdfbe8e887e813),
    LL(0xa113cb878726874c), LL(0x626d11b8b8dab8a9), LL(0x0502090101040108), LL(0x6e9e0d4f4f214f42),
    LL(0xee6c9b3636d836ad), LL(0x0451ffa6a6a2a659), LL(0xbdb90cd2d26fd2de), LL(0x06f70ef5f5f3f5fb),
    LL(0x80f2967979f979ef), LL(0xcede306f6fa16f5f), LL(0xef3f6d91917e91fc), LL(0x07a4f852525552aa),
    LL(0xfdc04760609d6027), LL(0x766535bcbccabc89), LL(0xcd2b379b9b569bac), LL(0x8c018a8e8e028e04),
    LL(0x155bd2a3a3b6a371), LL(0x3c186c0c0c300c60), LL(0x8af6847b7bf17bff), LL(0xe16a803535d435b5),
    LL(0x693af51d1d741de8), LL(0x47ddb3e0e0a7e053), LL(0xacb321d7d77bd7f6), LL(0xed999cc2c22fc25e),
    LL(0x965c432e2eb82e6d), LL(0x7a96294b4b314b62), LL(0x21e15dfefedffea3), LL(0x16aed55757415782),
    LL(0x412abd15155415a8), LL(0xb6eee87777c1779f), LL(0xeb6e923737dc37a5), LL(0x56d79ee5e5b3e57b),
    LL(0xd923139f9f469f8c), LL(0x17fd23f0f0e7f0d3), LL(0x7f94204a4a354a6a), LL(0x95a944dada4fda9e),
    LL(0x25b0a258587d58fa), LL(0xca8fcfc9c903c906), LL(0x8d527c2929a42955), LL(0x22145a0a0a280a50),
    LL(0x4f7f50b1b1feb1e1), LL(0x1a5dc9a0a0baa069), LL(0xdad6146b6bb16b7f), LL(0xab17d985852e855c),
    LL(0x73673cbdbdcebd81), LL(0x34ba8f5d5d695dd2), LL(0x5020901010401080), LL(0x03f507f4f4f7f4f3),
    LL(0xc08bddcbcb0bcb16), LL(0xc67cd33e3ef83eed), LL(0x110a2d0505140528), LL(0xe6ce78676781671f),
    LL(0x53d597e4e4b7e473), LL(0xbb4e0227279c2725), LL(0x5882734141194132), LL(0x9d0ba78b8b168b2c),
    LL(0x0153f6a7a7a6a751), LL(0x94fab27d7de97dcf), LL(0xfb374995956e95dc), LL(0x9fad56d8d847d88e),
    LL(0x30eb70fbfbcbfb8b), LL(0x71c1cdeeee9fee23), LL(0x91f8bb7c7ced7cc7), LL(0xe3cc716666856617),
    LL(0x8ea77bdddd53dda6), LL(0x4b2eaf17175c17b8), LL(0x468e454747014702), LL(0xdc211a9e9e429e84),
    LL(0xc589d4caca0fca1e), LL(0x995a582d2db42d75), LL(0x79632ebfbfc6bf91), LL(0x1b0e3f07071c0738),
    LL(0x2347acadad8ead01), LL(0x2fb4b05a5a755aea), LL(0xb51bef838336836c), LL(0xff66b63333cc3385),
    LL(0xf2c65c636391633f), LL(0x0a04120202080210), LL(0x384993aaaa92aa39), LL(0xa8e2de7171d971af),
    LL(0xcf8dc6c8c807c80e), LL(0x7d32d119196419c8), LL(0x70923b4949394972), LL(0x9aaf5fd9d943d986),
    LL(0x1df931f2f2eff2c3), LL(0x48dba8e3e3abe34b), LL(0x2ab6b95b5b715be2), LL(0x920dbc88881a8834),
    LL(0xc8293e9a9a529aa4), LL(0xbe4c0b262698262d), LL(0xfa64bf3232c8328d), LL(0x4a7d59b0b0fab0e9),
    LL(0x6acff2e9e983e91b), LL(0x331e770f0f3c0f78), LL(0xa6b733d5d573d5e6), LL(0xba1df480803a8074),
    LL(0x7c6127bebec2be99), LL(0xde87ebcdcd13cd26), LL(0xe468893434d034bd), LL(0x75903248483d487a),
    LL(0x24e354ffffdbffab), LL(0x8ff48d7a7af57af7), LL(0xea3d6490907a90f4), LL(0x3ebe9d5f5f615fc2),
    LL(0xa0403d202080201d), LL(0xd5d00f6868bd6867), LL(0x7234ca1a1a681ad0), LL(0x2c41b7aeae82ae19),
    LL(0x5e757db4b4eab4c9), LL(0x19a8ce54544d549a), LL(0xe53b7f93937693ec), LL(0xaa442f222288220d),
    LL(0xe9c86364648d6407), LL(0x12ff2af1f1e3f1db), LL(0xa2e6cc7373d173bf), LL(0x5a24821212481290),
    LL(0x5d807a40401d403a), LL(0x2810480808200840), LL(0xe89b95c3c32bc356), LL(0x7bc5dfecec97ec33),
    LL(0x90ab4ddbdb4bdb96), LL(0x1f5fc0a1a1bea161), LL(0x8307918d8d0e8d1c), LL(0xc97ac83d3df43df5),
    LL(0xf1335b97976697cc), LL(0x0000000000000000), LL(0xd483f9cfcf1bcf36), LL(0x87566e2b2bac2b45),
    LL(0xb3ece17676c57697), LL(0xb019e68282328264), LL(0xa9b128d6d67fd6fe), LL(0x7736c31b1b6c1bd8),
    LL(0x5b7774b5b5eeb5c1), LL(0x2943beafaf86af11), LL(0xdfd41d6a6ab56a77), LL(0x0da0ea50505d50ba),
    LL(0x4c8a574545094512), LL(0x18fb38f3f3ebf3cb), LL(0xf060ad3030c0309d), LL(0x74c3c4efef9bef2b),
    LL(0xc37eda3f3ffc3fe5), LL(0x1caac75555495592), LL(0x1059dba2a2b2a279), LL(0x65c9e9eaea8fea03),
    LL(0xecca6a656589650f), LL(0x686903babad2bab9), LL(0x935e4a2f2fbc2f65), LL(0xe79d8ec0c027c04e),
    LL(0x81a160dede5fdebe), LL(0x6c38fc1c1c701ce0), LL(0x2ee746fdfdd3fdbb), LL(0x649a1f4d4d294d52),
    LL(0xe0397692927292e4), LL(0xbceafa7575c9758f), LL(0x1e0c360606180630), LL(0x9809ae8a8a128a24),
    LL(0x40794bb2b2f2b2f9), LL(0x59d185e6e6bfe663), LL(0x361c7e0e0e380e70), LL(0x633ee71f1f7c1ff8),
    LL(0xf7c4556262956237), LL(0xa3b53ad4d477d4ee), LL(0x324d81a8a89aa829), LL(0xf4315296966296c4),
    LL(0x3aef62f9f9c3f99b), LL(0xf697a3c5c533c566), LL(0xb14a102525942535), LL(0x20b2ab59597959f2),
    LL(0xae15d084842a8454), LL(0xa7e4c57272d572b7), LL(0xdd72ec3939e439d5), LL(0x6198164c4c2d4c5a),
    LL(0x3bbc945e5e655eca), LL(0x85f09f7878fd78e7), LL(0xd870e53838e038dd), LL(0x8605988c8c0a8c14),
    LL(0xb2bf17d1d163d1c6), LL(0x0b57e4a5a5aea541), LL(0x4dd9a1e2e2afe243), LL(0xf8c24e616199612f),
    LL(0x457b42b3b3f6b3f1), LL(0xa542342121842115), LL(0xd625089c9c4a9c94), LL(0x663cee1e1e781ef0),
    LL(0x5286614343114322), LL(0xfc93b1c7c73bc776), LL(0x2be54ffcfcd7fcb3), LL(0x1408240404100420),
    LL(0x08a2e351515951b2), LL(0xc72f2599995e99bc), LL(0xc4da226d6da96d4f), LL(0x391a650d0d340d68),
    LL(0x35e979fafacffa83), LL(0x84a369dfdf5bdfb6), LL(0x9bfca97e7ee57ed7), LL(0xb44819242490243d),
    LL(0xd776fe3b3bec3bc5), LL(0x3d4b9aabab96ab31), LL(0xd181f0cece1fce3e), LL(0x5522991111441188),
    LL(0x8903838f8f068f0c), LL(0x6b9c044e4e254e4a), LL(0x517366b7b7e6b7d1), LL(0x60cbe0ebeb8beb0b),
    LL(0xcc78c13c3cf03cfd), LL(0xbf1ffd81813e817c), LL(0xfe354094946a94d4), LL(0x0cf31cf7f7fbf7eb),
    LL(0x676f18b9b9deb9a1), LL(0x5f268b13134c1398), LL(0x9c58512c2cb02c7d), LL(0xb8bb05d3d36bd3d6),
    LL(0x5cd38ce7e7bbe76b), LL(0xcbdc396e6ea56e57), LL(0xf395aac4c437c46e), LL(0x0f061b03030c0318),
    LL(0x13acdc565645568a), LL(0x49885e44440d441a), LL(0x9efea07f7fe17fdf), LL(0x374f88a9a99ea921),
    LL(0x8254672a2aa82a4d), LL(0x6d6b0abbbbd6bbb1), LL(0xe29f87c1c123c146), LL(0x02a6f153535153a2),
    LL(0x8ba572dcdc57dcae), LL(0x2716530b0b2c0b58), LL(0xd327019d9d4e9d9c), LL(0xc1d82b6c6cad6c47),
    LL(0xf562a43131c43195), LL(0xb9e8f37474cd7487), LL(0x09f115f6f6fff6e3), LL(0x438c4c464605460a),
    LL(0x2645a5acac8aac09), LL(0x970fb589891e893c), LL(0x4428b414145014a0), LL(0x42dfbae1e1a3e15b),
    LL(0x4e2ca616165816b0), LL(0xd274f73a3ae83acd), LL(0xd0d2066969b9696f), LL(0x2d12410909240948),
    LL(0xade0d77070dd70a7), LL(0x54716fb6b6e2b6d9), LL(0xb7bd1ed0d067d0ce), LL(0x7ec7d6eded93ed3b),
    LL(0xdb85e2cccc17cc2e), LL(0x578468424215422a), LL(0xc22d2c98985a98b4), LL(0x0e55eda4a4aaa449),
    LL(0x8850752828a0285d), LL(0x31b8865c5c6d5cda), LL(0x3fed6bf8f8c7f893), LL(0xa411c28686228644),
};
static const u64 C4[256] = {
    LL(0xc07830d818186018), LL(0x05af462623238c23), LL(0x7ef991b8c6c63fc6), LL(0x136fcdfbe8e887e8),
    LL(0x4ca113cb87872687), LL(0xa9626d11b8b8dab8), LL(0x0805020901010401), LL(0x426e9e0d4f4f214f),
    LL(0xadee6c9b3636d836), LL(0x590451ffa6a6a2a6), LL(0xdebdb90cd2d26fd2), LL(0xfb06f70ef5f5f3f5),
    LL(0xef80f2967979f979), LL(0x5fcede306f6fa16f), LL(0xfcef3f6d91917e91), LL(0xaa07a4f852525552),
    LL(0x27fdc04760609d60), LL(0x89766535bcbccabc), LL(0xaccd2b379b9b569b), LL(0x048c018a8e8e028e),
    LL(0x71155bd2a3a3b6a3), LL(0x603c186c0c0c300c), LL(0xff8af6847b7bf17b), LL(0xb5e16a803535d435),
    LL(0xe8693af51d1d741d), LL(0x5347ddb3e0e0a7e0), LL(0xf6acb321d7d77bd7), LL(0x5eed999cc2c22fc2),
    LL(0x6d965c432e2eb82e), LL(0x627a96294b4b314b), LL(0xa321e15dfefedffe), LL(0x8216aed557574157),
    LL(0xa8412abd15155415), LL(0x9fb6eee87777c177), LL(0xa5eb6e923737dc37), LL(0x7b56d79ee5e5b3e5),
    LL(0x8cd923139f9f469f), LL(0xd317fd23f0f0e7f0), LL(0x6a7f94204a4a354a), LL(0x9e95a944dada4fda),
    LL(0xfa25b0a258587d58), LL(0x06ca8fcfc9c903c9), LL(0x558d527c2929a429), LL(0x5022145a0a0a280a),
    LL(0xe14f7f50b1b1feb1), LL(0x691a5dc9a0a0baa0), LL(0x7fdad6146b6bb16b), LL(0x5cab17d985852e85),
    LL(0x8173673cbdbdcebd), LL(0xd234ba8f5d5d695d), LL(0x8050209010104010), LL(0xf303f507f4f4f7f4),
    LL(0x16c08bddcbcb0bcb), LL(0xedc67cd33e3ef83e), LL(0x28110a2d05051405), LL(0x1fe6ce7867678167),
    LL(0x7353d597e4e4b7e4), LL(0x25bb4e0227279c27), LL(0x3258827341411941), LL(0x2c9d0ba78b8b168b),
    LL(0x510153f6a7a7a6a7), LL(0xcf94fab27d7de97d), LL(0xdcfb374995956e95), LL(0x8e9fad56d8d847d8),
    LL(0x8b30eb70fbfbcbfb), LL(0x2371c1cdeeee9fee), LL(0xc791f8bb7c7ced7c), LL(0x17e3cc7166668566),
    LL(0xa68ea77bdddd53dd), LL(0xb84b2eaf17175c17), LL(0x02468e4547470147), LL(0x84dc211a9e9e429e),
    LL(0x1ec589d4caca0fca), LL(0x75995a582d2db42d), LL(0x9179632ebfbfc6bf), LL(0x381b0e3f07071c07),
    LL(0x012347acadad8ead), LL(0xea2fb4b05a5a755a), LL(0x6cb51bef83833683), LL(0x85ff66b63333cc33),
    LL(0x3ff2c65c63639163), LL(0x100a041202020802), LL(0x39384993aaaa92aa), LL(0xafa8e2de7171d971),
    LL(0x0ecf8dc6c8c807c8), LL(0xc87d32d119196419), LL(0x7270923b49493949), LL(0x869aaf5fd9d943d9),
    LL(0xc31df931f2f2eff2), LL(0x4b48dba8e3e3abe3), LL(0xe22ab6b95b5b715b), LL(0x34920dbc88881a88),
    LL(0xa4c8293e9a9a529a), LL(0x2dbe4c0b26269826), LL(0x8dfa64bf3232c832), LL(0xe94a7d59b0b0fab0),
    LL(0x1b6acff2e9e983e9), LL(0x78331e770f0f3c0f), LL(0xe6a6b733d5d573d5), LL(0x74ba1df480803a80),
    LL(0x997c6127bebec2be), LL(0x26de87ebcdcd13cd), LL(0xbde468893434d034), LL(0x7a75903248483d48),
    LL(0xab24e354ffffdbff), LL(0xf78ff48d7a7af57a), LL(0xf4ea3d6490907a90), LL(0xc23ebe9d5f5f615f),
    LL(0x1da0403d20208020), LL(0x67d5d00f6868bd68), LL(0xd07234ca1a1a681a), LL(0x192c41b7aeae82ae),
    LL(0xc95e757db4b4eab4), LL(0x9a19a8ce54544d54), LL(0xece53b7f93937693), LL(0x0daa442f22228822),
    LL(0x07e9c86364648d64), LL(0xdb12ff2af1f1e3f1), LL(0xbfa2e6cc7373d173), LL(0x905a248212124812),
    LL(0x3a5d807a40401d40), LL(0x4028104808082008), LL(0x56e89b95c3c32bc3), LL(0x337bc5dfecec97ec),
    LL(0x9690ab4ddbdb4bdb), LL(0x611f5fc0a1a1bea1), LL(0x1c8307918d8d0e8d), LL(0xf5c97ac83d3df43d),
    LL(0xccf1335b97976697), LL(0x0000000000000000), LL(0x36d483f9cfcf1bcf), LL(0x4587566e2b2bac2b),
    LL(0x97b3ece17676c576), LL(0x64b019e682823282), LL(0xfea9b128d6d67fd6), LL(0xd87736c31b1b6c1b),
    LL(0xc15b7774b5b5eeb5), LL(0x112943beafaf86af), LL(0x77dfd41d6a6ab56a), LL(0xba0da0ea50505d50),
    LL(0x124c8a5745450945), LL(0xcb18fb38f3f3ebf3), LL(0x9df060ad3030c030), LL(0x2b74c3c4efef9bef),
    LL(0xe5c37eda3f3ffc3f), LL(0x921caac755554955), LL(0x791059dba2a2b2a2), LL(0x0365c9e9eaea8fea),
    LL(0x0fecca6a65658965), LL(0xb9686903babad2ba), LL(0x65935e4a2f2fbc2f), LL(0x4ee79d8ec0c027c0),
    LL(0xbe81a160dede5fde), LL(0xe06c38fc1c1c701c), LL(0xbb2ee746fdfdd3fd), LL(0x52649a1f4d4d294d),
    LL(0xe4e0397692927292), LL(0x8fbceafa7575c975), LL(0x301e0c3606061806), LL(0x249809ae8a8a128a),
    LL(0xf940794bb2b2f2b2), LL(0x6359d185e6e6bfe6), LL(0x70361c7e0e0e380e), LL(0xf8633ee71f1f7c1f),
    LL(0x37f7c45562629562), LL(0xeea3b53ad4d477d4), LL(0x29324d81a8a89aa8), LL(0xc4f4315296966296),
    LL(0x9b3aef62f9f9c3f9), LL(0x66f697a3c5c533c5), LL(0x35b14a1025259425), LL(0xf220b2ab59597959),
    LL(0x54ae15d084842a84), LL(0xb7a7e4c57272d572), LL(0xd5dd72ec3939e439), LL(0x5a6198164c4c2d4c),
    LL(0xca3bbc945e5e655e), LL(0xe785f09f7878fd78), LL(0xddd870e53838e038), LL(0x148605988c8c0a8c),
    LL(0xc6b2bf17d1d163d1), LL(0x410b57e4a5a5aea5), LL(0x434dd9a1e2e2afe2), LL(0x2ff8c24e61619961),
    LL(0xf1457b42b3b3f6b3), LL(0x15a5423421218421), LL(0x94d625089c9c4a9c), LL(0xf0663cee1e1e781e),
    LL(0x2252866143431143), LL(0x76fc93b1c7c73bc7), LL(0xb32be54ffcfcd7fc), LL(0x2014082404041004),
    LL(0xb208a2e351515951), LL(0xbcc72f2599995e99), LL(0x4fc4da226d6da96d), LL(0x68391a650d0d340d),
    LL(0x8335e979fafacffa), LL(0xb684a369dfdf5bdf), LL(0xd79bfca97e7ee57e), LL(0x3db4481924249024),
    LL(0xc5d776fe3b3bec3b), LL(0x313d4b9aabab96ab), LL(0x3ed181f0cece1fce), LL(0x8855229911114411),
    LL(0x0c8903838f8f068f), LL(0x4a6b9c044e4e254e), LL(0xd1517366b7b7e6b7), LL(0x0b60cbe0ebeb8beb),
    LL(0xfdcc78c13c3cf03c), LL(0x7cbf1ffd81813e81), LL(0xd4fe354094946a94), LL(0xeb0cf31cf7f7fbf7),
    LL(0xa1676f18b9b9deb9), LL(0x985f268b13134c13), LL(0x7d9c58512c2cb02c), LL(0xd6b8bb05d3d36bd3),
    LL(0x6b5cd38ce7e7bbe7), LL(0x57cbdc396e6ea56e), LL(0x6ef395aac4c437c4), LL(0x180f061b03030c03),
    LL(0x8a13acdc56564556), LL(0x1a49885e44440d44), LL(0xdf9efea07f7fe17f), LL(0x21374f88a9a99ea9),
    LL(0x4d8254672a2aa82a), LL(0xb16d6b0abbbbd6bb), LL(0x46e29f87c1c123c1), LL(0xa202a6f153535153),
    LL(0xae8ba572dcdc57dc), LL(0x582716530b0b2c0b), LL(0x9cd327019d9d4e9d), LL(0x47c1d82b6c6cad6c),
    LL(0x95f562a43131c431), LL(0x87b9e8f37474cd74), LL(0xe309f115f6f6fff6), LL(0x0a438c4c46460546),
    LL(0x092645a5acac8aac), LL(0x3c970fb589891e89), LL(0xa04428b414145014), LL(0x5b42dfbae1e1a3e1),
    LL(0xb04e2ca616165816), LL(0xcdd274f73a3ae83a), LL(0x6fd0d2066969b969), LL(0x482d124109092409),
    LL(0xa7ade0d77070dd70), LL(0xd954716fb6b6e2b6), LL(0xceb7bd1ed0d067d0), LL(0x3b7ec7d6eded93ed),
    LL(0x2edb85e2cccc17cc), LL(0x2a57846842421542), LL(0xb4c22d2c98985a98), LL(0x490e55eda4a4aaa4),
    LL(0x5d8850752828a028), LL(0xda31b8865c5c6d5c), LL(0x933fed6bf8f8c7f8), LL(0x44a411c286862286),
};
static const u64 C5[256] = {
    LL(0x18c07830d8181860), LL(0x2305af462623238c), LL(0xc67ef991b8c6c63f), LL(0xe8136fcdfbe8e887),
    LL(0x874ca113cb878726), LL(0xb8a9626d11b8b8da), LL(0x0108050209010104), LL(0x4f426e9e0d4f4f21),
    LL(0x36adee6c9b3636d8), LL(0xa6590451ffa6a6a2), LL(0xd2debdb90cd2d26f), LL(0xf5fb06f70ef5f5f3),
    LL(0x79ef80f2967979f9), LL(0x6f5fcede306f6fa1), LL(0x91fcef3f6d91917e), LL(0x52aa07a4f8525255),
    LL(0x6027fdc04760609d), LL(0xbc89766535bcbcca), LL(0x9baccd2b379b9b56), LL(0x8e048c018a8e8e02),
    LL(0xa371155bd2a3a3b6), LL(0x0c603c186c0c0c30), LL(0x7bff8af6847b7bf1), LL(0x35b5e16a803535d4),
    LL(0x1de8693af51d1d74), LL(0xe05347ddb3e0e0a7), LL(0xd7f6acb321d7d77b), LL(0xc25eed999cc2c22f),
    LL(0x2e6d965c432e2eb8), LL(0x4b627a96294b4b31), LL(0xfea321e15dfefedf), LL(0x578216aed5575741),
    LL(0x15a8412abd151554), LL(0x779fb6eee87777c1), LL(0x37a5eb6e923737dc), LL(0xe57b56d79ee5e5b3),
    LL(0x9f8cd923139f9f46), LL(0xf0d317fd23f0f0e7), LL(0x4a6a7f94204a4a35), LL(0xda9e95a944dada4f),
    LL(0x58fa25b0a258587d), LL(0xc906ca8fcfc9c903), LL(0x29558d527c2929a4), LL(0x0a5022145a0a0a28),
    LL(0xb1e14f7f50b1b1fe), LL(0xa0691a5dc9a0a0ba), LL(0x6b7fdad6146b6bb1), LL(0x855cab17d985852e),
    LL(0xbd8173673cbdbdce), LL(0x5dd234ba8f5d5d69), LL(0x1080502090101040), LL(0xf4f303f507f4f4f7),
    LL(0xcb16c08bddcbcb0b), LL(0x3eedc67cd33e3ef8), LL(0x0528110a2d050514), LL(0x671fe6ce78676781),
    LL(0xe47353d597e4e4b7), LL(0x2725bb4e0227279c), LL(0x4132588273414119), LL(0x8b2c9d0ba78b8b16),
    LL(0xa7510153f6a7a7a6), LL(0x7dcf94fab27d7de9), LL(0x95dcfb374995956e), LL(0xd88e9fad56d8d847),
    LL(0xfb8b30eb70fbfbcb), LL(0xee2371c1cdeeee9f), LL(0x7cc791f8bb7c7ced), LL(0x6617e3cc71666685),
    LL(0xdda68ea77bdddd53), LL(0x17b84b2eaf17175c), LL(0x4702468e45474701), LL(0x9e84dc211a9e9e42),
    LL(0xca1ec589d4caca0f), LL(0x2d75995a582d2db4), LL(0xbf9179632ebfbfc6), LL(0x07381b0e3f07071c),
    LL(0xad012347acadad8e), LL(0x5aea2fb4b05a5a75), LL(0x836cb51bef838336), LL(0x3385ff66b63333cc),
    LL(0x633ff2c65c636391), LL(0x02100a0412020208), LL(0xaa39384993aaaa92), LL(0x71afa8e2de7171d9),
    LL(0xc80ecf8dc6c8c807), LL(0x19c87d32d1191964), LL(0x497270923b494939), LL(0xd9869aaf5fd9d943),
    LL(0xf2c31df931f2f2ef), LL(0xe34b48dba8e3e3ab), LL(0x5be22ab6b95b5b71), LL(0x8834920dbc88881a),
    LL(0x9aa4c8293e9a9a52), LL(0x262dbe4c0b262698), LL(0x328dfa64bf3232c8), LL(0xb0e94a7d59b0b0fa),
    LL(0xe91b6acff2e9e983), LL(0x0f78331e770f0f3c), LL(0xd5e6a6b733d5d573), LL(0x8074ba1df480803a),
    LL(0xbe997c6127bebec2), LL(0xcd26de87ebcdcd13), LL(0x34bde468893434d0), LL(0x487a75903248483d),
    LL(0xffab24e354ffffdb), LL(0x7af78ff48d7a7af5), LL(0x90f4ea3d6490907a), LL(0x5fc23ebe9d5f5f61),
    LL(0x201da0403d202080), LL(0x6867d5d00f6868bd), LL(0x1ad07234ca1a1a68), LL(0xae192c41b7aeae82),
    LL(0xb4c95e757db4b4ea), LL(0x549a19a8ce54544d), LL(0x93ece53b7f939376), LL(0x220daa442f222288),
    LL(0x6407e9c86364648d), LL(0xf1db12ff2af1f1e3), LL(0x73bfa2e6cc7373d1), LL(0x12905a2482121248),
    LL(0x403a5d807a40401d), LL(0x0840281048080820), LL(0xc356e89b95c3c32b), LL(0xec337bc5dfecec97),
    LL(0xdb9690ab4ddbdb4b), LL(0xa1611f5fc0a1a1be), LL(0x8d1c8307918d8d0e), LL(0x3df5c97ac83d3df4),
    LL(0x97ccf1335b979766), LL(0x0000000000000000), LL(0xcf36d483f9cfcf1b), LL(0x2b4587566e2b2bac),
    LL(0x7697b3ece17676c5), LL(0x8264b019e6828232), LL(0xd6fea9b128d6d67f), LL(0x1bd87736c31b1b6c),
    LL(0xb5c15b7774b5b5ee), LL(0xaf112943beafaf86), LL(0x6a77dfd41d6a6ab5), LL(0x50ba0da0ea50505d),
    LL(0x45124c8a57454509), LL(0xf3cb18fb38f3f3eb), LL(0x309df060ad3030c0), LL(0xef2b74c3c4efef9b),
    LL(0x3fe5c37eda3f3ffc), LL(0x55921caac7555549), LL(0xa2791059dba2a2b2), LL(0xea0365c9e9eaea8f),
    LL(0x650fecca6a656589), LL(0xbab9686903babad2), LL(0x2f65935e4a2f2fbc), LL(0xc04ee79d8ec0c027),
    LL(0xdebe81a160dede5f), LL(0x1ce06c38fc1c1c70), LL(0xfdbb2ee746fdfdd3), LL(0x4d52649a1f4d4d29),
    LL(0x92e4e03976929272), LL(0x758fbceafa7575c9), LL(0x06301e0c36060618), LL(0x8a249809ae8a8a12),
    LL(0xb2f940794bb2b2f2), LL(0xe66359d185e6e6bf), LL(0x0e70361c7e0e0e38), LL(0x1ff8633ee71f1f7c),
    LL(0x6237f7c455626295), LL(0xd4eea3b53ad4d477), LL(0xa829324d81a8a89a), LL(0x96c4f43152969662),
    LL(0xf99b3aef62f9f9c3), LL(0xc566f697a3c5c533), LL(0x2535b14a10252594), LL(0x59f220b2ab595979),
    LL(0x8454ae15d084842a), LL(0x72b7a7e4c57272d5), LL(0x39d5dd72ec3939e4), LL(0x4c5a6198164c4c2d),
    LL(0x5eca3bbc945e5e65), LL(0x78e785f09f7878fd), LL(0x38ddd870e53838e0), LL(0x8c148605988c8c0a),
    LL(0xd1c6b2bf17d1d163), LL(0xa5410b57e4a5a5ae), LL(0xe2434dd9a1e2e2af), LL(0x612ff8c24e616199),
    LL(0xb3f1457b42b3b3f6), LL(0x2115a54234212184), LL(0x9c94d625089c9c4a), LL(0x1ef0663cee1e1e78),
    LL(0x4322528661434311), LL(0xc776fc93b1c7c73b), LL(0xfcb32be54ffcfcd7), LL(0x0420140824040410),
    LL(0x51b208a2e3515159), LL(0x99bcc72f2599995e), LL(0x6d4fc4da226d6da9), LL(0x0d68391a650d0d34),
    LL(0xfa8335e979fafacf), LL(0xdfb684a369dfdf5b), LL(0x7ed79bfca97e7ee5), LL(0x243db44819242490),
    LL(0x3bc5d776fe3b3bec), LL(0xab313d4b9aabab96), LL(0xce3ed181f0cece1f), LL(0x1188552299111144),
    LL(0x8f0c8903838f8f06), LL(0x4e4a6b9c044e4e25), LL(0xb7d1517366b7b7e6), LL(0xeb0b60cbe0ebeb8b),
    LL(0x3cfdcc78c13c3cf0), LL(0x817cbf1ffd81813e), LL(0x94d4fe354094946a), LL(0xf7eb0cf31cf7f7fb),
    LL(0xb9a1676f18b9b9de), LL(0x13985f268b13134c), LL(0x2c7d9c58512c2cb0), LL(0xd3d6b8bb05d3d36b),
    LL(0xe76b5cd38ce7e7bb), LL(0x6e57cbdc396e6ea5), LL(0xc46ef395aac4c437), LL(0x03180f061b03030c),
    LL(0x568a13acdc565645), LL(0x441a49885e44440d), LL(0x7fdf9efea07f7fe1), LL(0xa921374f88a9a99e),
    LL(0x2a4d8254672a2aa8), LL(0xbbb16d6b0abbbbd6), LL(0xc146e29f87c1c123), LL(0x53a202a6f1535351),
    LL(0xdcae8ba572dcdc57), LL(0x0b582716530b0b2c), LL(0x9d9cd327019d9d4e), LL(0x6c47c1d82b6c6cad),
    LL(0x3195f562a43131c4), LL(0x7487b9e8f37474cd), LL(0xf6e309f115f6f6ff), LL(0x460a438c4c464605),
    LL(0xac092645a5acac8a), LL(0x893c970fb589891e), LL(0x14a04428b4141450), LL(0xe15b42dfbae1e1a3),
    LL(0x16b04e2ca6161658), LL(0x3acdd274f73a3ae8), LL(0x696fd0d2066969b9), LL(0x09482d1241090924),
    LL(0x70a7ade0d77070dd), LL(0xb6d954716fb6b6e2), LL(0xd0ceb7bd1ed0d067), LL(0xed3b7ec7d6eded93),
    LL(0xcc2edb85e2cccc17), LL(0x422a578468424215), LL(0x98b4c22d2c98985a), LL(0xa4490e55eda4a4aa),
    LL(0x285d8850752828a0), LL(0x5cda31b8865c5c6d), LL(0xf8933fed6bf8f8c7), LL(0x8644a411c2868622),
};
static const u64 C6[256] = {
    LL(0x6018c07830d81818), LL(0x8c2305af46262323), LL(0x3fc67ef991b8c6c6), LL(0x87e8136fcdfbe8e8),
    LL(0x26874ca113cb8787), LL(0xdab8a9626d11b8b8), LL(0x0401080502090101), LL(0x214f426e9e0d4f4f),
    LL(0xd836adee6c9b3636), LL(0xa2a6590451ffa6a6), LL(0x6fd2debdb90cd2d2), LL(0xf3f5fb06f70ef5f5),
    LL(0xf979ef80f2967979), LL(0xa16f5fcede306f6f), LL(0x7e91fcef3f6d9191), LL(0x5552aa07a4f85252),
    LL(0x9d6027fdc0476060), LL(0xcabc89766535bcbc), LL(0x569baccd2b379b9b), LL(0x028e048c018a8e8e),
    LL(0xb6a371155bd2a3a3), LL(0x300c603c186c0c0c), LL(0xf17bff8af6847b7b), LL(0xd435b5e16a803535),
    LL(0x741de8693af51d1d), LL(0xa7e05347ddb3e0e0), LL(0x7bd7f6acb321d7d7), LL(0x2fc25eed999cc2c2),
    LL(0xb82e6d965c432e2e), LL(0x314b627a96294b4b), LL(0xdffea321e15dfefe), LL(0x41578216aed55757),
    LL(0x5415a8412abd1515), LL(0xc1779fb6eee87777), LL(0xdc37a5eb6e923737), LL(0xb3e57b56d79ee5e5),
    LL(0x469f8cd923139f9f), LL(0xe7f0d317fd23f0f0), LL(0x354a6a7f94204a4a), LL(0x4fda9e95a944dada),
    LL(0x7d58fa25b0a25858), LL(0x03c906ca8fcfc9c9), LL(0xa429558d527c2929), LL(0x280a5022145a0a0a),
    LL(0xfeb1e14f7f50b1b1), LL(0xbaa0691a5dc9a0a0), LL(0xb16b7fdad6146b6b), LL(0x2e855cab17d98585),
    LL(0xcebd8173673cbdbd), LL(0x695dd234ba8f5d5d), LL(0x4010805020901010), LL(0xf7f4f303f507f4f4),
    LL(0x0bcb16c08bddcbcb), LL(0xf83eedc67cd33e3e), LL(0x140528110a2d0505), LL(0x81671fe6ce786767),
    LL(0xb7e47353d597e4e4), LL(0x9c2725bb4e022727), LL(0x1941325882734141), LL(0x168b2c9d0ba78b8b),
    LL(0xa6a7510153f6a7a7), LL(0xe97dcf94fab27d7d), LL(0x6e95dcfb37499595), LL(0x47d88e9fad56d8d8),
    LL(0xcbfb8b30eb70fbfb), LL(0x9fee2371c1cdeeee), LL(0xed7cc791f8bb7c7c), LL(0x856617e3cc716666),
    LL(0x53dda68ea77bdddd), LL(0x5c17b84b2eaf1717), LL(0x014702468e454747), LL(0x429e84dc211a9e9e),
    LL(0x0fca1ec589d4caca), LL(0xb42d75995a582d2d), LL(0xc6bf9179632ebfbf), LL(0x1c07381b0e3f0707),
    LL(0x8ead012347acadad), LL(0x755aea2fb4b05a5a), LL(0x36836cb51bef8383), LL(0xcc3385ff66b63333),
    LL(0x91633ff2c65c6363), LL(0x0802100a04120202), LL(0x92aa39384993aaaa), LL(0xd971afa8e2de7171),
    LL(0x07c80ecf8dc6c8c8), LL(0x6419c87d32d11919), LL(0x39497270923b4949), LL(0x43d9869aaf5fd9d9),
    LL(0xeff2c31df931f2f2), LL(0xabe34b48dba8e3e3), LL(0x715be22ab6b95b5b), LL(0x1a8834920dbc8888),
    LL(0x529aa4c8293e9a9a), LL(0x98262dbe4c0b2626), LL(0xc8328dfa64bf3232), LL(0xfab0e94a7d59b0b0),
    LL(0x83e91b6acff2e9e9), LL(0x3c0f78331e770f0f), LL(0x73d5e6a6b733d5d5), LL(0x3a8074ba1df48080),
    LL(0xc2be997c6127bebe), LL(0x13cd26de87ebcdcd), LL(0xd034bde468893434), LL(0x3d487a7590324848),
    LL(0xdbffab24e354ffff), LL(0xf57af78ff48d7a7a), LL(0x7a90f4ea3d649090), LL(0x615fc23ebe9d5f5f),
    LL(0x80201da0403d2020), LL(0xbd6867d5d00f6868), LL(0x681ad07234ca1a1a), LL(0x82ae192c41b7aeae),
    LL(0xeab4c95e757db4b4), LL(0x4d549a19a8ce5454), LL(0x7693ece53b7f9393), LL(0x88220daa442f2222),
    LL(0x8d6407e9c8636464), LL(0xe3f1db12ff2af1f1), LL(0xd173bfa2e6cc7373), LL(0x4812905a24821212),
    LL(0x1d403a5d807a4040), LL(0x2008402810480808), LL(0x2bc356e89b95c3c3), LL(0x97ec337bc5dfecec),
    LL(0x4bdb9690ab4ddbdb), LL(0xbea1611f5fc0a1a1), LL(0x0e8d1c8307918d8d), LL(0xf43df5c97ac83d3d),
    LL(0x6697ccf1335b9797), LL(0x0000000000000000), LL(0x1bcf36d483f9cfcf), LL(0xac2b4587566e2b2b),
    LL(0xc57697b3ece17676), LL(0x328264b019e68282), LL(0x7fd6fea9b128d6d6), LL(0x6c1bd87736c31b1b),
    LL(0xeeb5c15b7774b5b5), LL(0x86af112943beafaf), LL(0xb56a77dfd41d6a6a), LL(0x5d50ba0da0ea5050),
    LL(0x0945124c8a574545), LL(0xebf3cb18fb38f3f3), LL(0xc0309df060ad3030), LL(0x9bef2b74c3c4efef),
    LL(0xfc3fe5c37eda3f3f), LL(0x4955921caac75555), LL(0xb2a2791059dba2a2), LL(0x8fea0365c9e9eaea),
    LL(0x89650fecca6a6565), LL(0xd2bab9686903baba), LL(0xbc2f65935e4a2f2f), LL(0x27c04ee79d8ec0c0),
    LL(0x5fdebe81a160dede), LL(0x701ce06c38fc1c1c), LL(0xd3fdbb2ee746fdfd), LL(0x294d52649a1f4d4d),
    LL(0x7292e4e039769292), LL(0xc9758fbceafa7575), LL(0x1806301e0c360606), LL(0x128a249809ae8a8a),
    LL(0xf2b2f940794bb2b2), LL(0xbfe66359d185e6e6), LL(0x380e70361c7e0e0e), LL(0x7c1ff8633ee71f1f),
    LL(0x956237f7c4556262), LL(0x77d4eea3b53ad4d4), LL(0x9aa829324d81a8a8), LL(0x6296c4f431529696),
    LL(0xc3f99b3aef62f9f9), LL(0x33c566f697a3c5c5), LL(0x942535b14a102525), LL(0x7959f220b2ab5959),
    LL(0x2a8454ae15d08484), LL(0xd572b7a7e4c57272), LL(0xe439d5dd72ec3939), LL(0x2d4c5a6198164c4c),
    LL(0x655eca3bbc945e5e), LL(0xfd78e785f09f7878), LL(0xe038ddd870e53838), LL(0x0a8c148605988c8c),
    LL(0x63d1c6b2bf17d1d1), LL(0xaea5410b57e4a5a5), LL(0xafe2434dd9a1e2e2), LL(0x99612ff8c24e6161),
    LL(0xf6b3f1457b42b3b3), LL(0x842115a542342121), LL(0x4a9c94d625089c9c), LL(0x781ef0663cee1e1e),
    LL(0x1143225286614343), LL(0x3bc776fc93b1c7c7), LL(0xd7fcb32be54ffcfc), LL(0x1004201408240404),
    LL(0x5951b208a2e35151), LL(0x5e99bcc72f259999), LL(0xa96d4fc4da226d6d), LL(0x340d68391a650d0d),
    LL(0xcffa8335e979fafa), LL(0x5bdfb684a369dfdf), LL(0xe57ed79bfca97e7e), LL(0x90243db448192424),
    LL(0xec3bc5d776fe3b3b), LL(0x96ab313d4b9aabab), LL(0x1fce3ed181f0cece), LL(0x4411885522991111),
    LL(0x068f0c8903838f8f), LL(0x254e4a6b9c044e4e), LL(0xe6b7d1517366b7b7), LL(0x8beb0b60cbe0ebeb),
    LL(0xf03cfdcc78c13c3c), LL(0x3e817cbf1ffd8181), LL(0x6a94d4fe35409494), LL(0xfbf7eb0cf31cf7f7),
    LL(0xdeb9a1676f18b9b9), LL(0x4c13985f268b1313), LL(0xb02c7d9c58512c2c), LL(0x6bd3d6b8bb05d3d3),
    LL(0xbbe76b5cd38ce7e7), LL(0xa56e57cbdc396e6e), LL(0x37c46ef395aac4c4), LL(0x0c03180f061b0303),
    LL(0x45568a13acdc5656), LL(0x0d441a49885e4444), LL(0xe17fdf9efea07f7f), LL(0x9ea921374f88a9a9),
    LL(0xa82a4d8254672a2a), LL(0xd6bbb16d6b0abbbb), LL(0x23c146e29f87c1c1), LL(0x5153a202a6f15353),
    LL(0x57dcae8ba572dcdc), LL(0x2c0b582716530b0b), LL(0x4e9d9cd327019d9d), LL(0xad6c47c1d82b6c6c),
    LL(0xc43195f562a43131), LL(0xcd7487b9e8f37474), LL(0xfff6e309f115f6f6), LL(0x05460a438c4c4646),
    LL(0x8aac092645a5acac), LL(0x1e893c970fb58989), LL(0x5014a04428b41414), LL(0xa3e15b42dfbae1e1),
    LL(0x5816b04e2ca61616), LL(0xe83acdd274f73a3a), LL(0xb9696fd0d2066969), LL(0x2409482d12410909),
    LL(0xdd70a7ade0d77070), LL(0xe2b6d954716fb6b6), LL(0x67d0ceb7bd1ed0d0), LL(0x93ed3b7ec7d6eded),
    LL(0x17cc2edb85e2cccc), LL(0x15422a5784684242), LL(0x5a98b4c22d2c9898), LL(0xaaa4490e55eda4a4),
    LL(0xa0285d8850752828), LL(0x6d5cda31b8865c5c), LL(0xc7f8933fed6bf8f8), LL(0x228644a411c28686),
};
static const u64 C7[256] = {
    LL(0x186018c07830d818), LL(0x238c2305af462623), LL(0xc63fc67ef991b8c6), LL(0xe887e8136fcdfbe8),
    LL(0x8726874ca113cb87), LL(0xb8dab8a9626d11b8), LL(0x0104010805020901), LL(0x4f214f426e9e0d4f),
    LL(0x36d836adee6c9b36), LL(0xa6a2a6590451ffa6), LL(0xd26fd2debdb90cd2), LL(0xf5f3f5fb06f70ef5),
    LL(0x79f979ef80f29679), LL(0x6fa16f5fcede306f), LL(0x917e91fcef3f6d91), LL(0x525552aa07a4f852),
    LL(0x609d6027fdc04760), LL(0xbccabc89766535bc), LL(0x9b569baccd2b379b), LL(0x8e028e048c018a8e),
    LL(0xa3b6a371155bd2a3), LL(0x0c300c603c186c0c), LL(0x7bf17bff8af6847b), LL(0x35d435b5e16a8035),
    LL(0x1d741de8693af51d), LL(0xe0a7e05347ddb3e0), LL(0xd77bd7f6acb321d7), LL(0xc22fc25eed999cc2),
    LL(0x2eb82e6d965c432e), LL(0x4b314b627a96294b), LL(0xfedffea321e15dfe), LL(0x5741578216aed557),
    LL(0x155415a8412abd15), LL(0x77c1779fb6eee877), LL(0x37dc37a5eb6e9237), LL(0xe5b3e57b56d79ee5),
    LL(0x9f469f8cd923139f), LL(0xf0e7f0d317fd23f0), LL(0x4a354a6a7f94204a), LL(0xda4fda9e95a944da),
    LL(0x587d58fa25b0a258), LL(0xc903c906ca8fcfc9), LL(0x29a429558d527c29), LL(0x0a280a5022145a0a),
    LL(0xb1feb1e14f7f50b1), LL(0xa0baa0691a5dc9a0), LL(0x6bb16b7fdad6146b), LL(0x852e855cab17d985),
    LL(0xbdcebd8173673cbd), LL(0x5d695dd234ba8f5d), LL(0x1040108050209010), LL(0xf4f7f4f303f507f4),
    LL(0xcb0bcb16c08bddcb), LL(0x3ef83eedc67cd33e), LL(0x05140528110a2d05), LL(0x6781671fe6ce7867),
    LL(0xe4b7e47353d597e4), LL(0x279c2725bb4e0227), LL(0x4119413258827341), LL(0x8b168b2c9d0ba78b),
    LL(0xa7a6a7510153f6a7), LL(0x7de97dcf94fab27d), LL(0x956e95dcfb374995), LL(0xd847d88e9fad56d8),
    LL(0xfbcbfb8b30eb70fb), LL(0xee9fee2371c1cdee), LL(0x7ced7cc791f8bb7c), LL(0x66856617e3cc7166),
    LL(0xdd53dda68ea77bdd), LL(0x175c17b84b2eaf17), LL(0x47014702468e4547), LL(0x9e429e84dc211a9e),
    LL(0xca0fca1ec589d4ca), LL(0x2db42d75995a582d), LL(0xbfc6bf9179632ebf), LL(0x071c07381b0e3f07),
    LL(0xad8ead012347acad), LL(0x5a755aea2fb4b05a), LL(0x8336836cb51bef83), LL(0x33cc3385ff66b633),
    LL(0x6391633ff2c65c63), LL(0x020802100a041202), LL(0xaa92aa39384993aa), LL(0x71d971afa8e2de71),
    LL(0xc807c80ecf8dc6c8), LL(0x196419c87d32d119), LL(0x4939497270923b49), LL(0xd943d9869aaf5fd9),
    LL(0xf2eff2c31df931f2), LL(0xe3abe34b48dba8e3), LL(0x5b715be22ab6b95b), LL(0x881a8834920dbc88),
    LL(0x9a529aa4c8293e9a), LL(0x2698262dbe4c0b26), LL(0x32c8328dfa64bf32), LL(0xb0fab0e94a7d59b0),
    LL(0xe983e91b6acff2e9), LL(0x0f3c0f78331e770f), LL(0xd573d5e6a6b733d5), LL(0x803a8074ba1df480),
    LL(0xbec2be997c6127be), LL(0xcd13cd26de87ebcd), LL(0x34d034bde4688934), LL(0x483d487a75903248),
    LL(0xffdbffab24e354ff), LL(0x7af57af78ff48d7a), LL(0x907a90f4ea3d6490), LL(0x5f615fc23ebe9d5f),
    LL(0x2080201da0403d20), LL(0x68bd6867d5d00f68), LL(0x1a681ad07234ca1a), LL(0xae82ae192c41b7ae),
    LL(0xb4eab4c95e757db4), LL(0x544d549a19a8ce54), LL(0x937693ece53b7f93), LL(0x2288220daa442f22),
    LL(0x648d6407e9c86364), LL(0xf1e3f1db12ff2af1), LL(0x73d173bfa2e6cc73), LL(0x124812905a248212),
    LL(0x401d403a5d807a40), LL(0x0820084028104808), LL(0xc32bc356e89b95c3), LL(0xec97ec337bc5dfec),
    LL(0xdb4bdb9690ab4ddb), LL(0xa1bea1611f5fc0a1), LL(0x8d0e8d1c8307918d), LL(0x3df43df5c97ac83d),
    LL(0x976697ccf1335b97), LL(0x0000000000000000), LL(0xcf1bcf36d483f9cf), LL(0x2bac2b4587566e2b),
    LL(0x76c57697b3ece176), LL(0x82328264b019e682), LL(0xd67fd6fea9b128d6), LL(0x1b6c1bd87736c31b),
    LL(0xb5eeb5c15b7774b5), LL(0xaf86af112943beaf), LL(0x6ab56a77dfd41d6a), LL(0x505d50ba0da0ea50),
    LL(0x450945124c8a5745), LL(0xf3ebf3cb18fb38f3), LL(0x30c0309df060ad30), LL(0xef9bef2b74c3c4ef),
    LL(0x3ffc3fe5c37eda3f), LL(0x554955921caac755), LL(0xa2b2a2791059dba2), LL(0xea8fea0365c9e9ea),
    LL(0x6589650fecca6a65), LL(0xbad2bab9686903ba), LL(0x2fbc2f65935e4a2f), LL(0xc027c04ee79d8ec0),
    LL(0xde5fdebe81a160de), LL(0x1c701ce06c38fc1c), LL(0xfdd3fdbb2ee746fd), LL(0x4d294d52649a1f4d),
    LL(0x927292e4e0397692), LL(0x75c9758fbceafa75), LL(0x061806301e0c3606), LL(0x8a128a249809ae8a),
    LL(0xb2f2b2f940794bb2), LL(0xe6bfe66359d185e6), LL(0x0e380e70361c7e0e), LL(0x1f7c1ff8633ee71f),
    LL(0x62956237f7c45562), LL(0xd477d4eea3b53ad4), LL(0xa89aa829324d81a8), LL(0x966296c4f4315296),
    LL(0xf9c3f99b3aef62f9), LL(0xc533c566f697a3c5), LL(0x25942535b14a1025), LL(0x597959f220b2ab59),
    LL(0x842a8454ae15d084), LL(0x72d572b7a7e4c572), LL(0x39e439d5dd72ec39), LL(0x4c2d4c5a6198164c),
    LL(0x5e655eca3bbc945e), LL(0x78fd78e785f09f78), LL(0x38e038ddd870e538), LL(0x8c0a8c148605988c),
    LL(0xd163d1c6b2bf17d1), LL(0xa5aea5410b57e4a5), LL(0xe2afe2434dd9a1e2), LL(0x6199612ff8c24e61),
    LL(0xb3f6b3f1457b42b3), LL(0x21842115a5423421), LL(0x9c4a9c94d625089c), LL(0x1e781ef0663cee1e),
    LL(0x4311432252866143), LL(0xc73bc776fc93b1c7), LL(0xfcd7fcb32be54ffc), LL(0x0410042014082404),
    LL(0x515951b208a2e351), LL(0x995e99bcc72f2599), LL(0x6da96d4fc4da226d), LL(0x0d340d68391a650d),
    LL(0xfacffa8335e979fa), LL(0xdf5bdfb684a369df), LL(0x7ee57ed79bfca97e), LL(0x2490243db4481924),
    LL(0x3bec3bc5d776fe3b), LL(0xab96ab313d4b9aab), LL(0xce1fce3ed181f0ce), LL(0x1144118855229911),
    LL(0x8f068f0c8903838f), LL(0x4e254e4a6b9c044e), LL(0xb7e6b7d1517366b7), LL(0xeb8beb0b60cbe0eb),
    LL(0x3cf03cfdcc78c13c), LL(0x813e817cbf1ffd81), LL(0x946a94d4fe354094), LL(0xf7fbf7eb0cf31cf7),
    LL(0xb9deb9a1676f18b9), LL(0x134c13985f268b13), LL(0x2cb02c7d9c58512c), LL(0xd36bd3d6b8bb05d3),
    LL(0xe7bbe76b5cd38ce7), LL(0x6ea56e57cbdc396e), LL(0xc437c46ef395aac4), LL(0x030c03180f061b03),
    LL(0x5645568a13acdc56), LL(0x440d441a49885e44), LL(0x7fe17fdf9efea07f), LL(0xa99ea921374f88a9),
    LL(0x2aa82a4d8254672a), LL(0xbbd6bbb16d6b0abb), LL(0xc123c146e29f87c1), LL(0x535153a202a6f153),
    LL(0xdc57dcae8ba572dc), LL(0x0b2c0b582716530b), LL(0x9d4e9d9cd327019d), LL(0x6cad6c47c1d82b6c),
    LL(0x31c43195f562a431), LL(0x74cd7487b9e8f374), LL(0xf6fff6e309f115f6), LL(0x4605460a438c4c46),
    LL(0xac8aac092645a5ac), LL(0x891e893c970fb589), LL(0x145014a04428b414), LL(0xe1a3e15b42dfbae1),
    LL(0x165816b04e2ca616), LL(0x3ae83acdd274f73a), LL(0x69b9696fd0d20669), LL(0x092409482d124109),
    LL(0x70dd70a7ade0d770), LL(0xb6e2b6d954716fb6), LL(0xd067d0ceb7bd1ed0), LL(0xed93ed3b7ec7d6ed),
    LL(0xcc17cc2edb85e2cc), LL(0x4215422a57846842), LL(0x985a98b4c22d2c98), LL(0xa4aaa4490e55eda4),
    LL(0x28a0285d88507528), LL(0x5c6d5cda31b8865c), LL(0xf8c7f8933fed6bf8), LL(0x86228644a411c286),
};
static const u64 rc[WHIRLPOOL_R + 1] = {
    LL(0x0000000000000000),
    LL(0x1823c6e887b8014f),
    LL(0x36a6d2f5796f9152),
    LL(0x60bc9b8ea30c7b35),
    LL(0x1de0d7c22e4bfe57),
    LL(0x157737e59ff04ada),
    LL(0x58c9290ab1a06b85),
    LL(0xbd5d10f4cb3e0567),
    LL(0xe427418ba77d95d8),
    LL(0xfbee7c66dd17479e),
    LL(0xca2dbf07ad5a8333),
};
static void processBuffer(struct NESSIEstruct * const structpointer) {
    int i, r;
    u64 K[8];
    u64 block[8];
    u64 state[8];
    u64 L[8];
    u8 *buffer = structpointer->buffer;
    for (i = 0; i < 8; i++, buffer += 8) {
        block[i] =
            (((u64)buffer[0]        ) << 56) ^
            (((u64)buffer[1] & 0xffL) << 48) ^
            (((u64)buffer[2] & 0xffL) << 40) ^
            (((u64)buffer[3] & 0xffL) << 32) ^
            (((u64)buffer[4] & 0xffL) << 24) ^
            (((u64)buffer[5] & 0xffL) << 16) ^
            (((u64)buffer[6] & 0xffL) <<  8) ^
            (((u64)buffer[7] & 0xffL)      );
    }
    state[0] = block[0] ^ (K[0] = structpointer->hash[0]);
    state[1] = block[1] ^ (K[1] = structpointer->hash[1]);
    state[2] = block[2] ^ (K[2] = structpointer->hash[2]);
    state[3] = block[3] ^ (K[3] = structpointer->hash[3]);
    state[4] = block[4] ^ (K[4] = structpointer->hash[4]);
    state[5] = block[5] ^ (K[5] = structpointer->hash[5]);
    state[6] = block[6] ^ (K[6] = structpointer->hash[6]);
    state[7] = block[7] ^ (K[7] = structpointer->hash[7]);
    for (r = 1; r <= WHIRLPOOL_R; r++) {
        L[0] =
            C0[(int)(K[0] >> 56)       ] ^
            C1[(int)(K[7] >> 48) & 0xff] ^
            C2[(int)(K[6] >> 40) & 0xff] ^
            C3[(int)(K[5] >> 32) & 0xff] ^
            C4[(int)(K[4] >> 24) & 0xff] ^
            C5[(int)(K[3] >> 16) & 0xff] ^
            C6[(int)(K[2] >>  8) & 0xff] ^
            C7[(int)(K[1]      ) & 0xff] ^
            rc[r];
        L[1] =
            C0[(int)(K[1] >> 56)       ] ^
            C1[(int)(K[0] >> 48) & 0xff] ^
            C2[(int)(K[7] >> 40) & 0xff] ^
            C3[(int)(K[6] >> 32) & 0xff] ^
            C4[(int)(K[5] >> 24) & 0xff] ^
            C5[(int)(K[4] >> 16) & 0xff] ^
            C6[(int)(K[3] >>  8) & 0xff] ^
            C7[(int)(K[2]      ) & 0xff];
        L[2] =
            C0[(int)(K[2] >> 56)       ] ^
            C1[(int)(K[1] >> 48) & 0xff] ^
            C2[(int)(K[0] >> 40) & 0xff] ^
            C3[(int)(K[7] >> 32) & 0xff] ^
            C4[(int)(K[6] >> 24) & 0xff] ^
            C5[(int)(K[5] >> 16) & 0xff] ^
            C6[(int)(K[4] >>  8) & 0xff] ^
            C7[(int)(K[3]      ) & 0xff];
        L[3] =
            C0[(int)(K[3] >> 56)       ] ^
            C1[(int)(K[2] >> 48) & 0xff] ^
            C2[(int)(K[1] >> 40) & 0xff] ^
            C3[(int)(K[0] >> 32) & 0xff] ^
            C4[(int)(K[7] >> 24) & 0xff] ^
            C5[(int)(K[6] >> 16) & 0xff] ^
            C6[(int)(K[5] >>  8) & 0xff] ^
            C7[(int)(K[4]      ) & 0xff];
        L[4] =
            C0[(int)(K[4] >> 56)       ] ^
            C1[(int)(K[3] >> 48) & 0xff] ^
            C2[(int)(K[2] >> 40) & 0xff] ^
            C3[(int)(K[1] >> 32) & 0xff] ^
            C4[(int)(K[0] >> 24) & 0xff] ^
            C5[(int)(K[7] >> 16) & 0xff] ^
            C6[(int)(K[6] >>  8) & 0xff] ^
            C7[(int)(K[5]      ) & 0xff];
        L[5] =
            C0[(int)(K[5] >> 56)       ] ^
            C1[(int)(K[4] >> 48) & 0xff] ^
            C2[(int)(K[3] >> 40) & 0xff] ^
            C3[(int)(K[2] >> 32) & 0xff] ^
            C4[(int)(K[1] >> 24) & 0xff] ^
            C5[(int)(K[0] >> 16) & 0xff] ^
            C6[(int)(K[7] >>  8) & 0xff] ^
            C7[(int)(K[6]      ) & 0xff];
        L[6] =
            C0[(int)(K[6] >> 56)       ] ^
            C1[(int)(K[5] >> 48) & 0xff] ^
            C2[(int)(K[4] >> 40) & 0xff] ^
            C3[(int)(K[3] >> 32) & 0xff] ^
            C4[(int)(K[2] >> 24) & 0xff] ^
            C5[(int)(K[1] >> 16) & 0xff] ^
            C6[(int)(K[0] >>  8) & 0xff] ^
            C7[(int)(K[7]      ) & 0xff];
        L[7] =
            C0[(int)(K[7] >> 56)       ] ^
            C1[(int)(K[6] >> 48) & 0xff] ^
            C2[(int)(K[5] >> 40) & 0xff] ^
            C3[(int)(K[4] >> 32) & 0xff] ^
            C4[(int)(K[3] >> 24) & 0xff] ^
            C5[(int)(K[2] >> 16) & 0xff] ^
            C6[(int)(K[1] >>  8) & 0xff] ^
            C7[(int)(K[0]      ) & 0xff];
        K[0] = L[0];
        K[1] = L[1];
        K[2] = L[2];
        K[3] = L[3];
        K[4] = L[4];
        K[5] = L[5];
        K[6] = L[6];
        K[7] = L[7];
        L[0] =
            C0[(int)(state[0] >> 56)       ] ^
            C1[(int)(state[7] >> 48) & 0xff] ^
            C2[(int)(state[6] >> 40) & 0xff] ^
            C3[(int)(state[5] >> 32) & 0xff] ^
            C4[(int)(state[4] >> 24) & 0xff] ^
            C5[(int)(state[3] >> 16) & 0xff] ^
            C6[(int)(state[2] >>  8) & 0xff] ^
            C7[(int)(state[1]      ) & 0xff] ^
            K[0];
        L[1] =
            C0[(int)(state[1] >> 56)       ] ^
            C1[(int)(state[0] >> 48) & 0xff] ^
            C2[(int)(state[7] >> 40) & 0xff] ^
            C3[(int)(state[6] >> 32) & 0xff] ^
            C4[(int)(state[5] >> 24) & 0xff] ^
            C5[(int)(state[4] >> 16) & 0xff] ^
            C6[(int)(state[3] >>  8) & 0xff] ^
            C7[(int)(state[2]      ) & 0xff] ^
            K[1];
        L[2] =
            C0[(int)(state[2] >> 56)       ] ^
            C1[(int)(state[1] >> 48) & 0xff] ^
            C2[(int)(state[0] >> 40) & 0xff] ^
            C3[(int)(state[7] >> 32) & 0xff] ^
            C4[(int)(state[6] >> 24) & 0xff] ^
            C5[(int)(state[5] >> 16) & 0xff] ^
            C6[(int)(state[4] >>  8) & 0xff] ^
            C7[(int)(state[3]      ) & 0xff] ^
            K[2];
        L[3] =
            C0[(int)(state[3] >> 56)       ] ^
            C1[(int)(state[2] >> 48) & 0xff] ^
            C2[(int)(state[1] >> 40) & 0xff] ^
            C3[(int)(state[0] >> 32) & 0xff] ^
            C4[(int)(state[7] >> 24) & 0xff] ^
            C5[(int)(state[6] >> 16) & 0xff] ^
            C6[(int)(state[5] >>  8) & 0xff] ^
            C7[(int)(state[4]      ) & 0xff] ^
            K[3];
        L[4] =
            C0[(int)(state[4] >> 56)       ] ^
            C1[(int)(state[3] >> 48) & 0xff] ^
            C2[(int)(state[2] >> 40) & 0xff] ^
            C3[(int)(state[1] >> 32) & 0xff] ^
            C4[(int)(state[0] >> 24) & 0xff] ^
            C5[(int)(state[7] >> 16) & 0xff] ^
            C6[(int)(state[6] >>  8) & 0xff] ^
            C7[(int)(state[5]      ) & 0xff] ^
            K[4];
        L[5] =
            C0[(int)(state[5] >> 56)       ] ^
            C1[(int)(state[4] >> 48) & 0xff] ^
            C2[(int)(state[3] >> 40) & 0xff] ^
            C3[(int)(state[2] >> 32) & 0xff] ^
            C4[(int)(state[1] >> 24) & 0xff] ^
            C5[(int)(state[0] >> 16) & 0xff] ^
            C6[(int)(state[7] >>  8) & 0xff] ^
            C7[(int)(state[6]      ) & 0xff] ^
            K[5];
        L[6] =
            C0[(int)(state[6] >> 56)       ] ^
            C1[(int)(state[5] >> 48) & 0xff] ^
            C2[(int)(state[4] >> 40) & 0xff] ^
            C3[(int)(state[3] >> 32) & 0xff] ^
            C4[(int)(state[2] >> 24) & 0xff] ^
            C5[(int)(state[1] >> 16) & 0xff] ^
            C6[(int)(state[0] >>  8) & 0xff] ^
            C7[(int)(state[7]      ) & 0xff] ^
            K[6];
        L[7] =
            C0[(int)(state[7] >> 56)       ] ^
            C1[(int)(state[6] >> 48) & 0xff] ^
            C2[(int)(state[5] >> 40) & 0xff] ^
            C3[(int)(state[4] >> 32) & 0xff] ^
            C4[(int)(state[3] >> 24) & 0xff] ^
            C5[(int)(state[2] >> 16) & 0xff] ^
            C6[(int)(state[1] >>  8) & 0xff] ^
            C7[(int)(state[0]      ) & 0xff] ^
            K[7];
        state[0] = L[0];
        state[1] = L[1];
        state[2] = L[2];
        state[3] = L[3];
        state[4] = L[4];
        state[5] = L[5];
        state[6] = L[6];
        state[7] = L[7];
    }
    structpointer->hash[0] ^= state[0] ^ block[0];
    structpointer->hash[1] ^= state[1] ^ block[1];
    structpointer->hash[2] ^= state[2] ^ block[2];
    structpointer->hash[3] ^= state[3] ^ block[3];
    structpointer->hash[4] ^= state[4] ^ block[4];
    structpointer->hash[5] ^= state[5] ^ block[5];
    structpointer->hash[6] ^= state[6] ^ block[6];
    structpointer->hash[7] ^= state[7] ^ block[7];
}
void NESSIEinit(struct NESSIEstruct * const structpointer) {
    int i;
    memset(structpointer->bitLength, 0, 32);
    structpointer->bufferBits = structpointer->bufferPos = 0;
    structpointer->buffer[0] = 0;
    for (i = 0; i < 8; i++) {
        structpointer->hash[i] = 0L;
    }
}
void NESSIEadd(const unsigned char * const source,
			   unsigned long sourceBits,
               struct NESSIEstruct * const structpointer) {
    int sourcePos    = 0;
    int sourceGap    = (8 - ((int)sourceBits & 7)) & 7;
	int bufferRem    = structpointer->bufferBits & 7;
	int i;
    u32 b, carry;
    u8 *buffer       = structpointer->buffer;
    u8 *bitLength    = structpointer->bitLength;
    int bufferBits   = structpointer->bufferBits;
    int bufferPos    = structpointer->bufferPos;
    u64 value = sourceBits;
    for (i = 31, carry = 0; i >= 0 && (carry != 0 || value != LL(0)); i--) {
        carry += bitLength[i] + ((u32)value & 0xff);
        bitLength[i] = (u8)carry;
        carry >>= 8;
        value >>= 8;
    }
    while (sourceBits > 8) {
        b = ((source[sourcePos] << sourceGap) & 0xff) |
            ((source[sourcePos + 1] & 0xff) >> (8 - sourceGap));
        buffer[bufferPos++] |= (u8)(b >> bufferRem);
        bufferBits += 8 - bufferRem;
        if (bufferBits == DIGESTBITS) {
            processBuffer(structpointer);
            bufferBits = bufferPos = 0;
        }
        buffer[bufferPos] = b << (8 - bufferRem);
        bufferBits += bufferRem;
        sourceBits -= 8;
        sourcePos++;
    }
    if (sourceBits > 0) {
        b = (source[sourcePos] << sourceGap) & 0xff;
        buffer[bufferPos] |= b >> bufferRem;
    } else {
        b = 0;
    }
    if (bufferRem + sourceBits < 8) {
        bufferBits += sourceBits;
    } else {
        bufferPos++;
        bufferBits += 8 - bufferRem;
        sourceBits -= 8 - bufferRem;
        if (bufferBits == DIGESTBITS) {
            processBuffer(structpointer);
            bufferBits = bufferPos = 0;
        }
        buffer[bufferPos] = b << (8 - bufferRem);
        bufferBits += (int)sourceBits;
    }
    structpointer->bufferBits   = bufferBits;
    structpointer->bufferPos    = bufferPos;
}
void NESSIEadd64(const unsigned char * const source,
			   uint64_t sourceBits,
               struct NESSIEstruct * const structpointer) {
    int sourcePos    = 0;
    int sourceGap    = (8 - ((int)sourceBits & 7)) & 7;
    int bufferRem    = structpointer->bufferBits & 7;
    int i;
    u32 b, carry;
    u8 *buffer       = structpointer->buffer;
    u8 *bitLength    = structpointer->bitLength;
    int bufferBits   = structpointer->bufferBits;
    int bufferPos    = structpointer->bufferPos;
    u64 value = sourceBits;
    for (i = 31, carry = 0; i >= 0 && (carry != 0 || value != LL(0)); i--) {
        carry += bitLength[i] + ((u32)value & 0xff);
        bitLength[i] = (u8)carry;
        carry >>= 8;
        value >>= 8;
    }
    while (sourceBits > 8) {
        b = ((source[sourcePos] << sourceGap) & 0xff) |
            ((source[sourcePos + 1] & 0xff) >> (8 - sourceGap));
        buffer[bufferPos++] |= (u8)(b >> bufferRem);
        bufferBits += 8 - bufferRem;
        if (bufferBits == DIGESTBITS) {
            processBuffer(structpointer);
            bufferBits = bufferPos = 0;
        }
        buffer[bufferPos] = b << (8 - bufferRem);
        bufferBits += bufferRem;
        sourceBits -= 8;
        sourcePos++;
    }
    if (sourceBits > 0) {
        b = (source[sourcePos] << sourceGap) & 0xff;
        buffer[bufferPos] |= b >> bufferRem;
    } else {
        b = 0;
    }
    if (bufferRem + sourceBits < 8) {
        bufferBits += sourceBits;
    } else {
        bufferPos++;
        bufferBits += 8 - bufferRem;
        sourceBits -= 8 - bufferRem;
        if (bufferBits == DIGESTBITS) {
            processBuffer(structpointer);
            bufferBits = bufferPos = 0;
        }
        buffer[bufferPos] = b << (8 - bufferRem);
        bufferBits += (int)sourceBits;
    }
    structpointer->bufferBits   = bufferBits;
    structpointer->bufferPos    = bufferPos;
}
void NESSIEfinalize(struct NESSIEstruct * const structpointer,
                    unsigned char * const result) {
    int i;
    u8 *buffer      = structpointer->buffer;
    const u8 *bitLength   = structpointer->bitLength;
    int bufferBits  = structpointer->bufferBits;
    int bufferPos   = structpointer->bufferPos;
    u8 *digest      = result;
    buffer[bufferPos] |= 0x80U >> (bufferBits & 7);
    bufferPos++;
    if (bufferPos > WBLOCKBYTES - LENGTHBYTES) {
        if (bufferPos < WBLOCKBYTES) {
            memset(&buffer[bufferPos], 0, WBLOCKBYTES - bufferPos);
        }
        processBuffer(structpointer);
        bufferPos = 0;
    }
    if (bufferPos < WBLOCKBYTES - LENGTHBYTES) {
        memset(&buffer[bufferPos], 0, (WBLOCKBYTES - LENGTHBYTES) - bufferPos);
    }
    bufferPos = WBLOCKBYTES - LENGTHBYTES;
    memcpy(&buffer[WBLOCKBYTES - LENGTHBYTES], bitLength, LENGTHBYTES);
    processBuffer(structpointer);
    for (i = 0; i < DIGESTBYTES/8; i++) {
        digest[0] = (u8)(structpointer->hash[i] >> 56);
        digest[1] = (u8)(structpointer->hash[i] >> 48);
        digest[2] = (u8)(structpointer->hash[i] >> 40);
        digest[3] = (u8)(structpointer->hash[i] >> 32);
        digest[4] = (u8)(structpointer->hash[i] >> 24);
        digest[5] = (u8)(structpointer->hash[i] >> 16);
        digest[6] = (u8)(structpointer->hash[i] >>  8);
        digest[7] = (u8)(structpointer->hash[i]      );
        digest += 8;
    }
    structpointer->bufferBits   = bufferBits;
    structpointer->bufferPos    = bufferPos;
}
/// LICENSE_END.16



/// LICENSE_START.13
// This is free and unencumbered software released into the public domain under The Unlicense (http://unlicense.org/)
// main repo: https://github.com/wangyi-fudan/wyhash
// author: 王一 Wang Yi <godspeed_china@yeah.net>
// contributors: Reini Urban, Dietrich Epp, Joshua Haberman, Tommy Ettinger, Daniel Lemire, Otmar Ertl, cocowalla, leo-yuriev, Diego Barrios Romero, paulie-g, dumblob, Yann Collet, ivte-ms, hyb, James Z.M. Gao, easyaspi314 (Devin), TheOneric
/* quick example:
   string s="fjsakfdsjkf";
   uint64_t hash=wyhash(s.c_str(), s.size(), 0, _wyp);

   A bit reworked
*/
//likely and unlikely macros
#if defined(__GNUC__) || defined(__INTEL_COMPILER) || defined(__clang__)
  #define _likely_(x)  __builtin_expect(x,1)
  #define _unlikely_(x)  __builtin_expect(x,0)
#else
  #define _likely_(x) (x)
  #define _unlikely_(x) (x)
#endif // corresponds to #if (#if defined(__GNUC__) || defined(__INTEL_COMPILER) || defined(__clang__))
//128bit multiply function
///static inline uint64_t _wyrot(uint64_t x) { return (x>>32)|(x<<32); }
static inline void _wymum(uint64_t *A, uint64_t *B){
#if defined(__SIZEOF_INT128__)
  __uint128_t r=*A; r*=*B;
  *A=(uint64_t)r; *B=(uint64_t)(r>>64);
#elif defined(_MSC_VER) && defined(_M_X64)
  *A=_umul128(*A,*B,B);
#else
  uint64_t ha=*A>>32, hb=*B>>32, la=(uint32_t)*A, lb=(uint32_t)*B, hi, lo;
  uint64_t rh=ha*hb, rm0=ha*lb, rm1=hb*la, rl=la*lb, t=rl+(rm0<<32), c=t<rl;
  lo=t+(rm1<<32); c+=lo<t; hi=rh+(rm0>>32)+(rm1>>32)+c;
  *A=lo;  *B=hi;
#endif // corresponds to #if (#if defined(__SIZEOF_INT128__))
}
//multiply and xor mix function, aka MUM
static inline uint64_t _wymix(uint64_t A, uint64_t B){ _wymum(&A,&B); return A^B; }
//endian macros
#ifdef BIG
    #define WYHASH_LITTLE_ENDIAN 0
#else
    #define WYHASH_LITTLE_ENDIAN 1
#endif // corresponds to #ifdef (#ifdef BIG)
//read functions
#if (WYHASH_LITTLE_ENDIAN)
static inline uint64_t _wyr8(const uint8_t *p) { uint64_t v; memcpy(&v, p, 8); return v;}
static inline uint64_t _wyr4(const uint8_t *p) { uint32_t v; memcpy(&v, p, 4); return v;}
#elif defined(__GNUC__) || defined(__INTEL_COMPILER) || defined(__clang__)
static inline uint64_t _wyr8(const uint8_t *p)
{ uint64_t v; memcpy(&v, p, 8);
#ifdef ANCIENT
  return  (v >> 56) |
           ((v >> 40) & 0x000000000000FF00ULL) |
           ((v >> 24) & 0x0000000000FF0000ULL) |
           ((v >>  8) & 0x00000000FF000000ULL) |
           ((v <<  8) & 0x000000FF00000000ULL) |
           ((v << 24) & 0x0000FF0000000000ULL) |
           ((v << 40) & 0x00FF000000000000ULL) |
            (v << 56);
#else
    return __builtin_bswap64(v);
#endif // corresponds to #ifdef (#ifdef ANCIENT)

}
static inline uint64_t _wyr4(const uint8_t *p)
{ uint32_t v; memcpy(&v, p, 4);

#ifdef ANCIENT
    return (v >> 24) |
          ((v >>  8) & 0x0000FF00) |
          ((v <<  8) & 0x00FF0000) |
           (v << 24);
#else
    return __builtin_bswap32(v);
#endif // corresponds to #ifdef (#ifdef ANCIENT)

}
#elif defined(_MSC_VER)
static inline uint64_t _wyr8(const uint8_t *p) { uint64_t v; memcpy(&v, p, 8); return _byteswap_uint64(v);}
static inline uint64_t _wyr4(const uint8_t *p) { uint32_t v; memcpy(&v, p, 4); return _byteswap_ulong(v);}
#else
static inline uint64_t _wyr8(const uint8_t *p) {
  uint64_t v; memcpy(&v, p, 8);
  return (((v >> 56) & 0xff)| ((v >> 40) & 0xff00)| ((v >> 24) & 0xff0000)| ((v >>  8) & 0xff000000)| ((v <<  8) & 0xff00000000)| ((v << 24) & 0xff0000000000)| ((v << 40) & 0xff000000000000)| ((v << 56) & 0xff00000000000000));
}
static inline uint64_t _wyr4(const uint8_t *p) {
  uint32_t v; memcpy(&v, p, 4);
  return (((v >> 24) & 0xff)| ((v >>  8) & 0xff00)| ((v <<  8) & 0xff0000)| ((v << 24) & 0xff000000));
}
#endif // corresponds to #if (#if (WYHASH_LITTLE_ENDIAN))
static inline uint64_t _wyr3(const uint8_t *p, size_t k) { return (((uint64_t)p[0])<<16)|(((uint64_t)p[k>>1])<<8)|p[k-1];}
//wyhash main function
static inline uint64_t wyhash(const void *key, size_t len, uint64_t seed, const uint64_t *secret){
  const uint8_t *p=(const uint8_t *)key; seed^=*secret;	uint64_t	a,	b;
  if(_likely_(len<=16)){
    if(_likely_(len>=4)){ a=(_wyr4(p)<<32)|_wyr4(p+((len>>3)<<2)); b=(_wyr4(p+len-4)<<32)|_wyr4(p+len-4-((len>>3)<<2)); }
    else if(_likely_(len>0)){ a=_wyr3(p,len); b=0;}
    else a=b=0;
  }
  else{
    size_t i=len;
    if(_unlikely_(i>48)){
      uint64_t see1=seed, see2=seed;
      do{
        seed=_wymix(_wyr8(p)^secret[1],_wyr8(p+8)^seed);
        see1=_wymix(_wyr8(p+16)^secret[2],_wyr8(p+24)^see1);
        see2=_wymix(_wyr8(p+32)^secret[3],_wyr8(p+40)^see2);
        p+=48; i-=48;
      }while(_likely_(i>48));
      seed^=see1^see2;
    }
    while(_unlikely_(i>16)){  seed=_wymix(_wyr8(p)^secret[1],_wyr8(p+8)^seed);  i-=16; p+=16;  }
    a=_wyr8(p+i-16);  b=_wyr8(p+i-8);
  }
  return _wymix(secret[1]^len,_wymix(a^secret[1],b^seed));
}
//the default secret parameters
///static const uint64_t _wyp[4] = {0xa0761d6478bd642full, 0xe7037ed1a0b428dbull, 0x8ebc6af09c88c6e3ull, 0x589965cc75374cc3ull};
//The wyrand PRNG that pass BigCrush and PractRand
static inline uint64_t wyrand(uint64_t *seed){ *seed+=0xa0761d6478bd642full; return _wymix(*seed,*seed^0xe7037ed1a0b428dbull);}
//make your own secret
static inline void make_secret(uint64_t seed, uint64_t *secret){
  uint8_t c[] = {15, 23, 27, 29, 30, 39, 43, 45, 46, 51, 53, 54, 57, 58, 60, 71, 75, 77, 78, 83, 85, 86, 89, 90, 92, 99, 101, 102, 105, 106, 108, 113, 114, 116, 120, 135, 139, 141, 142, 147, 149, 150, 153, 154, 156, 163, 165, 166, 169, 170, 172, 177, 178, 180, 184, 195, 197, 198, 201, 202, 204, 209, 210, 212, 216, 225, 226, 228, 232, 240 };
  for(size_t i=0;i<4;i++){
    uint8_t ok;
    do{
      ok=1; secret[i]=0;
      for(size_t j=0;j<64;j+=8) secret[i]|=((uint64_t)c[wyrand(&seed)%sizeof(c)])<<j;
      if(secret[i]%2==0){ ok=0; continue; }
      for(size_t j=0;j<i;j++) {
#if defined(__GNUC__) || defined(__INTEL_COMPILER) || defined(__clang__)
        if(__builtin_popcountll(secret[j]^secret[i])!=32){ ok=0; break; }
#elif defined(_MSC_VER) && defined(_M_X64)
        if(_mm_popcnt_u64(secret[j]^secret[i])!=32){ ok=0; break; }
#else
        //manual popcount
        uint64_t x = secret[j]^secret[i];
        x -= (x >> 1) & 0x5555555555555555;
        x = (x & 0x3333333333333333) + ((x >> 2) & 0x3333333333333333);
        x = (x + (x >> 4)) & 0x0f0f0f0f0f0f0f0f;
        x = (x * 0x0101010101010101) >> 56;
        if(x!=32){ ok=0; break; }
#endif // corresponds to #if (#if defined(__GNUC__) || defined(__INTEL_COMPILER) || defined(__clang__))
      }
    }while(!ok);
  }
}
/// LICENSE_END.13




/// LICENSE_START.14

/// I made a bit of fix of this incredibly (perhaps even too) complex implementation
/*
 * xxHash - Extremely Fast Hash algorithm
 * Header File
 * Copyright (C) 2012-2020 Yann Collet
 *
 * BSD 2-Clause License (https://www.opensource.org/licenses/bsd-license.php)
 */

#  define XXH_NAMESPACE XXH_INLINE_
#  define XXH_IPREF(Id)   XXH_INLINE_ ## Id
#  define XXH_OK XXH_IPREF(XXH_OK)
#  define XXH_ERROR XXH_IPREF(XXH_ERROR)
#  define XXH_errorcode XXH_IPREF(XXH_errorcode)
#  define XXH64_state_s XXH_IPREF(XXH64_state_s)
#  define XXH64_state_t XXH_IPREF(XXH64_state_t)
#  define XXH3_state_s  XXH_IPREF(XXH3_state_s)
#  define XXH3_state_t  XXH_IPREF(XXH3_state_t)
#  define XXH128_hash_t XXH_IPREF(XXH128_hash_t)


/* ****************************************************************
 *  Stable API
 *****************************************************************/


#  define XXH_CAT(A,B) A##B
#  define XXH_NAME2(A,B) XXH_CAT(A,B)
/* XXH64 */
#  define XXH64_createState XXH_NAME2(XXH_NAMESPACE, XXH64_createState)
#  define XXH64_reset XXH_NAME2(XXH_NAMESPACE, XXH64_reset)
#  define XXH64_update XXH_NAME2(XXH_NAMESPACE, XXH64_update)
#  define XXH64_digest XXH_NAME2(XXH_NAMESPACE, XXH64_digest)
/* XXH3_64bits */
/*  */
#  define XXH128 XXH_NAME2(XXH_NAMESPACE, XXH128)
#  define XXH3_128bits_withSecret XXH_NAME2(XXH_NAMESPACE, XXH3_128bits_withSecret)
#  define XXH3_128bits_reset XXH_NAME2(XXH_NAMESPACE, XXH3_128bits_reset)
#  define XXH3_128bits_update XXH_NAME2(XXH_NAMESPACE, XXH3_128bits_update)
#  define XXH3_128bits_digest XXH_NAME2(XXH_NAMESPACE, XXH3_128bits_digest)


/* ****************************
*  Definitions
******************************/
typedef enum { XXH_OK=0, XXH_ERROR } XXH_errorcode;
typedef uint32_t XXH32_hash_t;
typedef uint64_t XXH64_hash_t;
typedef uint8_t xxh_u8;
typedef XXH32_hash_t xxh_u32;

XXH64_hash_t XXH64 (const void* input, size_t length, XXH64_hash_t seed);

/*******   Streaming   *******/
typedef struct XXH64_state_s XXH64_state_t;   /* incomplete type */
XXH64_state_t* XXH64_createState(void);

XXH_errorcode XXH64_reset  (XXH64_state_t* statePtr, XXH64_hash_t seed);
XXH_errorcode XXH64_update (XXH64_state_t* statePtr, const void* input, size_t length);
XXH64_hash_t  XXH64_digest (const XXH64_state_t* statePtr);

/*******   Canonical representation   *******/

#define XXH3_SECRET_SIZE_MIN 136

typedef struct XXH3_state_s XXH3_state_t;

typedef struct {
 XXH64_hash_t low64;
 XXH64_hash_t high64;
} XXH128_hash_t;

XXH128_hash_t XXH3_128bits_withSecret(const void* data, size_t len, const void* secret, size_t secretSize);
XXH_errorcode XXH3_128bits_reset(XXH3_state_t* statePtr);
XXH_errorcode XXH3_128bits_update (XXH3_state_t* statePtr, const void* input, size_t length);
XXH128_hash_t XXH3_128bits_digest (const XXH3_state_t* statePtr);

struct XXH64_state_s {
   XXH64_hash_t total_len;
   XXH64_hash_t v1;
   XXH64_hash_t v2;
   XXH64_hash_t v3;
   XXH64_hash_t v4;
   XXH64_hash_t mem64[4];
   XXH32_hash_t memsize;
   XXH32_hash_t reserved32;  /* required for padding anyway */
   XXH64_hash_t reserved64;  /* never read nor write, might be removed in a future version */
};   /* typedef'd to XXH64_state_t */

#if defined (__STDC_VERSION__) && (__STDC_VERSION__ >= 201112L)   /* C11+ */
#  include <stdalign.h>
#  define XXH_ALIGN(n)      alignas(n)
#elif defined(__GNUC__)
#  define XXH_ALIGN(n)      __attribute__ ((aligned(n)))
#elif defined(_MSC_VER)
#  define XXH_ALIGN(n)      __declspec(align(n))
#else
#  define XXH_ALIGN(n)   /* disabled */
#endif // corresponds to #if (#if defined (__STDC_VERSION__) && (__STDC_VERSION__ >= 201112L)   /* C11+ */)

/* Old GCC versions only accept the attribute after the type in structures. */
#if !(defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 201112L))   /* C11+ */ \
    && defined(__GNUC__)
#   define XXH_ALIGN_MEMBER(align, type) type XXH_ALIGN(align)
#else
#   define XXH_ALIGN_MEMBER(align, type) XXH_ALIGN(align) type
#endif // corresponds to #if (#if !(defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 201112L))   /* C11+ */ \)

#define XXH3_INTERNALBUFFER_SIZE 256
#define XXH3_SECRET_DEFAULT_SIZE 192
struct XXH3_state_s {
   XXH_ALIGN_MEMBER(64, XXH64_hash_t acc[8]);
   /* used to store a custom secret generated from a seed */
   XXH_ALIGN_MEMBER(64, unsigned char customSecret[XXH3_SECRET_DEFAULT_SIZE]);
   XXH_ALIGN_MEMBER(64, unsigned char buffer[XXH3_INTERNALBUFFER_SIZE]);
   XXH32_hash_t bufferedSize;
   XXH32_hash_t reserved32;
   size_t nbStripesSoFar;
   XXH64_hash_t totalLen;
   size_t nbStripesPerBlock;
   size_t secretLimit;
   XXH64_hash_t seed;
   XXH64_hash_t reserved64;
   const unsigned char* extSecret;  /* reference to external secret;
                                     * if == NULL, use .customSecret instead */
   /* note: there may be some padding at the end due to alignment on 64 bytes */
}; /* typedef'd to XXH3_state_t */

#undef XXH_ALIGN_MEMBER

/* When the XXH3_state_t structure is merely emplaced on stack,
 * it should be initialized with XXH3_INITSTATE() or a memset()
 * in case its first reset uses XXH3_NNbits_reset_withSeed().
 * This init can be omitted if the first reset uses default or _withSecret mode.
 * This operation isn't necessary when the state is created with XXH3_createState().
 * Note that this doesn't prepare the state for a streaming operation,
 * it's still necessary to use XXH3_NNbits_reset*() afterwards.
 */
#define XXH3_INITSTATE(XXH3_state_ptr)   { (XXH3_state_ptr)->seed = 0; }

/* simple short-cut to pre-selected XXH3_128bits variant */
XXH128_hash_t XXH128(const void* data, size_t len, XXH64_hash_t seed);

#  if !defined(__clang__) && defined(__GNUC__) && defined(__ARM_FEATURE_UNALIGNED) && defined(__ARM_ARCH) && (__ARM_ARCH == 6)
#    define XXH_FORCE_MEMORY_ACCESS 2
#  elif !defined(__clang__) && ((defined(__INTEL_COMPILER) && !defined(_WIN32)) || \
  (defined(__GNUC__) && (defined(__ARM_ARCH) && __ARM_ARCH >= 7)))
#    define XXH_FORCE_MEMORY_ACCESS 1
#  endif

#ifndef XXH_ACCEPT_NULL_INPUT_POINTER   /* can be defined externally */
#  define XXH_ACCEPT_NULL_INPUT_POINTER 0
#endif // corresponds to #ifndef (#ifndef XXH_ACCEPT_NULL_INPUT_POINTER   /* can be defined externally */)

#ifndef XXH_FORCE_ALIGN_CHECK  /* can be defined externally */
#  if defined(__i386)  || defined(__x86_64__) || defined(__aarch64__) \
   || defined(_M_IX86) || defined(_M_X64)     || defined(_M_ARM64) /* visual */
#    define XXH_FORCE_ALIGN_CHECK 0
#  else
#    define XXH_FORCE_ALIGN_CHECK 1
#  endif
#endif // corresponds to #ifndef (#ifndef XXH_FORCE_ALIGN_CHECK  /* can be defined externally */)

#ifndef XXH_NO_INLINE_HINTS
#  if defined(__OPTIMIZE_SIZE__) /* -Os, -Oz */ \
   || defined(__NO_INLINE__)     /* -O0, -fno-inline */
#    define XXH_NO_INLINE_HINTS 1
#  else
#    define XXH_NO_INLINE_HINTS 0
#  endif
#endif // corresponds to #ifndef (#ifndef XXH_NO_INLINE_HINTS)

#ifndef XXH_REROLL
#  if defined(__OPTIMIZE_SIZE__)
#    define XXH_REROLL 1
#  else
#    define XXH_REROLL 0
#  endif
#endif // corresponds to #ifndef (#ifndef XXH_REROLL)


/* *************************************
*  Includes & Memory related functions
***************************************/
/*!
 * Modify the local functions below should you wish to use
 * different memory routines for malloc() and free()
 */

static void* XXH_malloc(size_t s) {  return franz_malloc(s);}
/*! and for memcpy() */
static void* XXH_memcpy(void* dest, const void* src, size_t size)
{
    return memcpy(dest,src,size);
}



/* *************************************
*  Compiler Specific Options
***************************************/
#ifdef _MSC_VER /* Visual Studio warning fix */
#  pragma warning(disable : 4127) /* disable: C4127: conditional expression is constant */
#endif // corresponds to #ifdef (#ifdef _MSC_VER /* Visual Studio warning fix */)

#if XXH_NO_INLINE_HINTS  /* disable inlining hints */
#  if defined(__GNUC__)
#    define XXH_FORCE_INLINE static __attribute__((unused))
#  else
#    define XXH_FORCE_INLINE static
#  endif
#  define XXH_NO_INLINE static
/* enable inlining hints */
#elif defined(_MSC_VER)  /* Visual Studio */
#  define XXH_FORCE_INLINE static __forceinline
#  define XXH_NO_INLINE static __declspec(noinline)
#elif defined(__GNUC__)
#  define XXH_FORCE_INLINE static __inline__ __attribute__((always_inline, unused))
#  define XXH_NO_INLINE static __attribute__((noinline))
#elif defined (__cplusplus) \
  || (defined (__STDC_VERSION__) && (__STDC_VERSION__ >= 199901L))   /* C99 */
#  define XXH_FORCE_INLINE static inline
#  define XXH_NO_INLINE static
#else
#  define XXH_FORCE_INLINE static
#  define XXH_NO_INLINE static
#endif // corresponds to #if (#if XXH_NO_INLINE_HINTS  /* disable inlining hints */)



#ifndef XXH_DEBUGLEVEL
#  ifdef DEBUGLEVEL /* backwards compat */
#    define XXH_DEBUGLEVEL DEBUGLEVEL
#  else
#    define XXH_DEBUGLEVEL 0
#  endif
#endif // corresponds to #ifndef (#ifndef XXH_DEBUGLEVEL)

#if (XXH_DEBUGLEVEL>=1)
#  include <assert.h>   /* note: can still be disabled with NDEBUG */
#  define XXH_ASSERT(c)   assert(c)
#else
#  define XXH_ASSERT(c)   ((void)0)
#endif // corresponds to #if (#if (XXH_DEBUGLEVEL>=1))

/* note: use after variable declarations */
#define XXH_STATIC_ASSERT(c)  do { enum { XXH_sa = 1/(int)(!!(c)) }; } while (0)


/* *************************************
*  Basic Types
***************************************/


/* ***   Memory access   *** */

/*
 * Manual byteshift. Best for old compilers which don't inline memcpy.
 * We actually directly use XXH_readLE32 and XXH_readBE32.
 */
#if (defined(XXH_FORCE_MEMORY_ACCESS) && (XXH_FORCE_MEMORY_ACCESS==2))

/*
 * Force direct memory access. Only works on CPU which support unaligned memory
 * access in hardware.
 */
static xxh_u32 XXH_read32(const void* memPtr) { return *(const xxh_u32*) memPtr; }

#elif (defined(XXH_FORCE_MEMORY_ACCESS) && (XXH_FORCE_MEMORY_ACCESS==1))

/*
 * __pack instructions are safer but compiler specific, hence potentially
 * problematic for some compilers.
 *
 * Currently only defined for GCC and ICC.
 */
static xxh_u32 XXH_read32(const void* ptr)
{
    typedef union { xxh_u32 u32; } __attribute__((packed)) xxh_unalign;
    return ((const xxh_unalign*)ptr)->u32;
}

#else

/*
 * Portable and safe solution. Generally efficient.
 * see: https://stackoverflow.com/a/32095106/646947
 */
static xxh_u32 XXH_read32(const void* memPtr)
{
    xxh_u32 val;
    memcpy(&val, memPtr, sizeof(val));
    return val;
}

#endif   /* XXH_FORCE_DIRECT_MEMORY_ACCESS */ // corresponds to #if (#if (defined(XXH_FORCE_MEMORY_ACCESS) && (XXH_FORCE_MEMORY_ACCESS==2)))


/* ***   Endianess   *** */
typedef enum { XXH_bigEndian=0, XXH_littleEndian=1 } XXH_endianess;

#ifdef BIG
#    define XXH_CPU_LITTLE_ENDIAN 0
#else
#    define XXH_CPU_LITTLE_ENDIAN 1
#endif // corresponds to #ifdef (#ifdef BIG)


/* ****************************************
*  Compiler-specific Functions and Macros
******************************************/
#define XXH_GCC_VERSION (__GNUC__ * 100 + __GNUC_MINOR__)

#ifdef __has_builtin
#  define XXH_HAS_BUILTIN(x) __has_builtin(x)
#else
#  define XXH_HAS_BUILTIN(x) 0
#endif // corresponds to #ifdef (#ifdef __has_builtin)

#if !defined(NO_CLANG_BUILTIN) && XXH_HAS_BUILTIN(__builtin_rotateleft32) \
                               && XXH_HAS_BUILTIN(__builtin_rotateleft64)
#  define XXH_rotl32 __builtin_rotateleft32
#  define XXH_rotl64 __builtin_rotateleft64
/* Note: although _rotl exists for minGW (GCC under windows), performance seems poor */
#elif defined(_MSC_VER)
#  define XXH_rotl32(x,r) _rotl(x,r)
#  define XXH_rotl64(x,r) _rotl64(x,r)
#else
#  define XXH_rotl32(x,r) (((x) << (r)) | ((x) >> (32 - (r))))
#  define XXH_rotl64(x,r) (((x) << (r)) | ((x) >> (64 - (r))))
#endif // corresponds to #if (#if !defined(NO_CLANG_BUILTIN) && XXH_HAS_BUILTIN(__builtin_rotateleft32) \)

#if defined(_MSC_VER)     /* Visual Studio */
#  define XXH_swap32 _byteswap_ulong
#elif XXH_GCC_VERSION >= 403
#  define XXH_swap32 __builtin_bswap32
#else
static xxh_u32 XXH_swap32 (xxh_u32 x)
{
    return  ((x << 24) & 0xff000000 ) |
            ((x <<  8) & 0x00ff0000 ) |
            ((x >>  8) & 0x0000ff00 ) |
            ((x >> 24) & 0x000000ff );
}
#endif // corresponds to #if (#if defined(_MSC_VER)     /* Visual Studio */)


/* ***************************
*  Memory reads
*****************************/
typedef enum { XXH_aligned, XXH_unaligned } XXH_alignment;

/*
 * XXH_FORCE_MEMORY_ACCESS==3 is an endian-independent byteshift load.
 *
 * This is ideal for older compilers which don't inline memcpy.
 */
#if (defined(XXH_FORCE_MEMORY_ACCESS) && (XXH_FORCE_MEMORY_ACCESS==3))

XXH_FORCE_INLINE xxh_u32 XXH_readLE32(const void* memPtr)
{
    const xxh_u8* bytePtr = (const xxh_u8 *)memPtr;
    return bytePtr[0]
         | ((xxh_u32)bytePtr[1] << 8)
         | ((xxh_u32)bytePtr[2] << 16)
         | ((xxh_u32)bytePtr[3] << 24);
}
#else
XXH_FORCE_INLINE xxh_u32 XXH_readLE32(const void* ptr)
{
    return XXH_CPU_LITTLE_ENDIAN ? XXH_read32(ptr) : XXH_swap32(XXH_read32(ptr));
}
#endif // corresponds to #if (#if (defined(XXH_FORCE_MEMORY_ACCESS) && (XXH_FORCE_MEMORY_ACCESS==3)))

XXH_FORCE_INLINE xxh_u32
XXH_readLE32_align(const void* ptr, XXH_alignment align)
{
    if (align==XXH_unaligned) {
        return XXH_readLE32(ptr);
    } else {
        return XXH_CPU_LITTLE_ENDIAN ? *(const xxh_u32*)ptr : XXH_swap32(*(const xxh_u32*)ptr);
    }
}


/* *************************************
*  Misc
***************************************/


/* *******************************************************************
*  32-bit hash functions
*********************************************************************/
static const xxh_u32 XXH_PRIME32_1 = 0x9E3779B1U;   /* 0b10011110001101110111100110110001 */
static const xxh_u32 XXH_PRIME32_2 = 0x85EBCA77U;   /* 0b10000101111010111100101001110111 */
static const xxh_u32 XXH_PRIME32_3 = 0xC2B2AE3DU;   /* 0b11000010101100101010111000111101 */


#define XXH_get32bits(p) XXH_readLE32_align(p, align)
#  undef XXH_PROCESS1
#  undef XXH_PROCESS4


/* *******************************************************************
*  64-bit hash functions
*********************************************************************/

/*******   Memory access   *******/

typedef XXH64_hash_t xxh_u64;

#ifndef XXH_REROLL_XXH64
#  if (defined(__ILP32__) || defined(_ILP32)) /* ILP32 is often defined on 32-bit GCC family */ \
   || !(defined(__x86_64__) || defined(_M_X64) || defined(_M_AMD64) /* x86-64 */ \
     || defined(_M_ARM64) || defined(__aarch64__) || defined(__arm64__) /* aarch64 */ \
     || defined(__PPC64__) || defined(__PPC64LE__) || defined(__ppc64__) || defined(__powerpc64__) /* ppc64 */ \
     || defined(__mips64__) || defined(__mips64)) /* mips64 */ \
   || (!defined(SIZE_MAX) || SIZE_MAX < ULLONG_MAX) /* check limits */
#    define XXH_REROLL_XXH64 1
#  else
#    define XXH_REROLL_XXH64 0
#  endif
#endif /* !defined(XXH_REROLL_XXH64) */ // corresponds to #ifndef (#ifndef XXH_REROLL_XXH64)

#if (defined(XXH_FORCE_MEMORY_ACCESS) && (XXH_FORCE_MEMORY_ACCESS==3))
/*
 * Manual byteshift. Best for old compilers which don't inline memcpy.
 * We actually directly use XXH_readLE64 and XXH_readBE64.
 */
#elif (defined(XXH_FORCE_MEMORY_ACCESS) && (XXH_FORCE_MEMORY_ACCESS==2))

/* Force direct memory access. Only works on CPU which support unaligned memory access in hardware */
static xxh_u64 XXH_read64(const void* memPtr) { return *(const xxh_u64*) memPtr; }

#elif (defined(XXH_FORCE_MEMORY_ACCESS) && (XXH_FORCE_MEMORY_ACCESS==1))

/*
 * __pack instructions are safer, but compiler specific, hence potentially
 * problematic for some compilers.
 *
 * Currently only defined for GCC and ICC.
 */
static xxh_u64 XXH_read64(const void* ptr)
{
    typedef union { xxh_u32 u32; xxh_u64 u64; } __attribute__((packed)) xxh_unalign64;
    return ((const xxh_unalign64*)ptr)->u64;
}

#else

/*
 * Portable and safe solution. Generally efficient.
 * see: https://stackoverflow.com/a/32095106/646947
 */
static xxh_u64 XXH_read64(const void* memPtr)
{
    xxh_u64 val;
    memcpy(&val, memPtr, sizeof(val));
    return val;
}

#endif   /* XXH_FORCE_DIRECT_MEMORY_ACCESS */ // corresponds to #if (#if (defined(XXH_FORCE_MEMORY_ACCESS) && (XXH_FORCE_MEMORY_ACCESS==3)))

#if defined(_MSC_VER)     /* Visual Studio */
#  define XXH_swap64 _byteswap_uint64
#elif XXH_GCC_VERSION >= 403
#  define XXH_swap64 __builtin_bswap64
#else
static xxh_u64 XXH_swap64 (xxh_u64 x)
{
    return  ((x << 56) & 0xff00000000000000ULL) |
            ((x << 40) & 0x00ff000000000000ULL) |
            ((x << 24) & 0x0000ff0000000000ULL) |
            ((x << 8)  & 0x000000ff00000000ULL) |
            ((x >> 8)  & 0x00000000ff000000ULL) |
            ((x >> 24) & 0x0000000000ff0000ULL) |
            ((x >> 40) & 0x000000000000ff00ULL) |
            ((x >> 56) & 0x00000000000000ffULL);
}
#endif // corresponds to #if (#if defined(_MSC_VER)     /* Visual Studio */)


/* XXH_FORCE_MEMORY_ACCESS==3 is an endian-independent byteshift load. */
#if (defined(XXH_FORCE_MEMORY_ACCESS) && (XXH_FORCE_MEMORY_ACCESS==3))

XXH_FORCE_INLINE xxh_u64 XXH_readLE64(const void* memPtr)
{
    const xxh_u8* bytePtr = (const xxh_u8 *)memPtr;
    return bytePtr[0]
         | ((xxh_u64)bytePtr[1] << 8)
         | ((xxh_u64)bytePtr[2] << 16)
         | ((xxh_u64)bytePtr[3] << 24)
         | ((xxh_u64)bytePtr[4] << 32)
         | ((xxh_u64)bytePtr[5] << 40)
         | ((xxh_u64)bytePtr[6] << 48)
         | ((xxh_u64)bytePtr[7] << 56);
}
#else
XXH_FORCE_INLINE xxh_u64 XXH_readLE64(const void* ptr)
{
    return XXH_CPU_LITTLE_ENDIAN ? XXH_read64(ptr) : XXH_swap64(XXH_read64(ptr));
}
#endif // corresponds to #if (#if (defined(XXH_FORCE_MEMORY_ACCESS) && (XXH_FORCE_MEMORY_ACCESS==3)))

XXH_FORCE_INLINE xxh_u64
XXH_readLE64_align(const void* ptr, XXH_alignment align)
{
    if (align==XXH_unaligned)
        return XXH_readLE64(ptr);
    else
        return XXH_CPU_LITTLE_ENDIAN ? *(const xxh_u64*)ptr : XXH_swap64(*(const xxh_u64*)ptr);
}


/*******   xxh64   *******/

static const xxh_u64 XXH_PRIME64_1 = 0x9E3779B185EBCA87ULL;   /* 0b1001111000110111011110011011000110000101111010111100101010000111 */
static const xxh_u64 XXH_PRIME64_2 = 0xC2B2AE3D27D4EB4FULL;   /* 0b1100001010110010101011100011110100100111110101001110101101001111 */
static const xxh_u64 XXH_PRIME64_3 = 0x165667B19E3779F9ULL;   /* 0b0001011001010110011001111011000110011110001101110111100111111001 */
static const xxh_u64 XXH_PRIME64_4 = 0x85EBCA77C2B2AE63ULL;   /* 0b1000010111101011110010100111011111000010101100101010111001100011 */
static const xxh_u64 XXH_PRIME64_5 = 0x27D4EB2F165667C5ULL;   /* 0b0010011111010100111010110010111100010110010101100110011111000101 */


static xxh_u64 XXH64_round(xxh_u64 acc, xxh_u64 input)
{
    acc += input * XXH_PRIME64_2;
    acc  = XXH_rotl64(acc, 31);
    acc *= XXH_PRIME64_1;
    return acc;
}

static xxh_u64 XXH64_mergeRound(xxh_u64 acc, xxh_u64 val)
{
    val  = XXH64_round(0, val);
    acc ^= val;
    acc  = acc * XXH_PRIME64_1 + XXH_PRIME64_4;
    return acc;
}

static xxh_u64 XXH64_avalanche(xxh_u64 h64)
{
    h64 ^= h64 >> 33;
    h64 *= XXH_PRIME64_2;
    h64 ^= h64 >> 29;
    h64 *= XXH_PRIME64_3;
    h64 ^= h64 >> 32;
    return h64;
}


#define XXH_get64bits(p) XXH_readLE64_align(p, align)

static xxh_u64
XXH64_finalize(xxh_u64 h64, const xxh_u8* ptr, size_t len, XXH_alignment align)
{
#define XXH_PROCESS1_64 do {                                   \
    h64 ^= (*ptr++) * XXH_PRIME64_5;                           \
    h64 = XXH_rotl64(h64, 11) * XXH_PRIME64_1;                 \
} while (0)

#define XXH_PROCESS4_64 do {                                   \
    h64 ^= (xxh_u64)(XXH_get32bits(ptr)) * XXH_PRIME64_1;      \
    ptr += 4;                                              \
    h64 = XXH_rotl64(h64, 23) * XXH_PRIME64_2 + XXH_PRIME64_3;     \
} while (0)

#define XXH_PROCESS8_64 do {                                   \
    xxh_u64 const k1 = XXH64_round(0, XXH_get64bits(ptr)); \
    ptr += 8;                                              \
    h64 ^= k1;                                             \
    h64  = XXH_rotl64(h64,27) * XXH_PRIME64_1 + XXH_PRIME64_4;     \
} while (0)

    /* Rerolled version for 32-bit targets is faster and much smaller. */
    if (XXH_REROLL || XXH_REROLL_XXH64) {
        len &= 31;
        while (len >= 8) {
            XXH_PROCESS8_64;
            len -= 8;
        }
        if (len >= 4) {
            XXH_PROCESS4_64;
            len -= 4;
        }
        while (len > 0) {
            XXH_PROCESS1_64;
            --len;
        }
         return  XXH64_avalanche(h64);
    } else {
        switch(len & 31) {
           case 24: XXH_PROCESS8_64;
                         /* fallthrough */
           case 16: XXH_PROCESS8_64;
                         /* fallthrough */
           case  8: XXH_PROCESS8_64;
                    return XXH64_avalanche(h64);

           case 28: XXH_PROCESS8_64;
                         /* fallthrough */
           case 20: XXH_PROCESS8_64;
                         /* fallthrough */
           case 12: XXH_PROCESS8_64;
                         /* fallthrough */
           case  4: XXH_PROCESS4_64;
                    return XXH64_avalanche(h64);

           case 25: XXH_PROCESS8_64;
                         /* fallthrough */
           case 17: XXH_PROCESS8_64;
                         /* fallthrough */
           case  9: XXH_PROCESS8_64;
                    XXH_PROCESS1_64;
                    return XXH64_avalanche(h64);

           case 29: XXH_PROCESS8_64;
                         /* fallthrough */
           case 21: XXH_PROCESS8_64;
                         /* fallthrough */
           case 13: XXH_PROCESS8_64;
                         /* fallthrough */
           case  5: XXH_PROCESS4_64;
                    XXH_PROCESS1_64;
                    return XXH64_avalanche(h64);

           case 26: XXH_PROCESS8_64;
                         /* fallthrough */
           case 18: XXH_PROCESS8_64;
                         /* fallthrough */
           case 10: XXH_PROCESS8_64;
                    XXH_PROCESS1_64;
                    XXH_PROCESS1_64;
                    return XXH64_avalanche(h64);

           case 30: XXH_PROCESS8_64;
                         /* fallthrough */
           case 22: XXH_PROCESS8_64;
                         /* fallthrough */
           case 14: XXH_PROCESS8_64;
                         /* fallthrough */
           case  6: XXH_PROCESS4_64;
                    XXH_PROCESS1_64;
                    XXH_PROCESS1_64;
                    return XXH64_avalanche(h64);

           case 27: XXH_PROCESS8_64;
                         /* fallthrough */
           case 19: XXH_PROCESS8_64;
                         /* fallthrough */
           case 11: XXH_PROCESS8_64;
                    XXH_PROCESS1_64;
                    XXH_PROCESS1_64;
                    XXH_PROCESS1_64;
                    return XXH64_avalanche(h64);

           case 31: XXH_PROCESS8_64;
                         /* fallthrough */
           case 23: XXH_PROCESS8_64;
                         /* fallthrough */
           case 15: XXH_PROCESS8_64;
                         /* fallthrough */
           case  7: XXH_PROCESS4_64;
                         /* fallthrough */
           case  3: XXH_PROCESS1_64;
                         /* fallthrough */
           case  2: XXH_PROCESS1_64;
                         /* fallthrough */
           case  1: XXH_PROCESS1_64;
                         /* fallthrough */
           case  0: return XXH64_avalanche(h64);
        }
    }
    /* impossible to reach */
    XXH_ASSERT(0);
    return 0;  /* unreachable, but some compilers complain without it */
}

#  undef XXH_PROCESS1_64
#  undef XXH_PROCESS4_64
#  undef XXH_PROCESS8_64

/*******   Hash Streaming   *******/

XXH64_state_t* XXH64_createState(void)
{
	 g_allocatedram+=sizeof(XXH64_state_t);
    return (XXH64_state_t*)XXH_malloc(sizeof(XXH64_state_t));
}

XXH_errorcode XXH64_reset(XXH64_state_t* statePtr, XXH64_hash_t seed)
{
    XXH64_state_t state;   /* use a local state to memcpy() in order to avoid strict-aliasing warnings */
    memset(&state, 0, sizeof(state));
    state.v1 = seed + XXH_PRIME64_1 + XXH_PRIME64_2;
    state.v2 = seed + XXH_PRIME64_2;
    state.v3 = seed + 0;
    state.v4 = seed - XXH_PRIME64_1;
     /* do not write into reserved64, might be removed in a future version */
    memcpy(statePtr, &state, sizeof(state) - sizeof(state.reserved64));
    return XXH_OK;
}

XXH_errorcode
XXH64_update (XXH64_state_t* state, const void* input, size_t len)
{
    if (input==NULL)
#if defined(XXH_ACCEPT_NULL_INPUT_POINTER) && (XXH_ACCEPT_NULL_INPUT_POINTER>=1)
        return XXH_OK;
#else
        return XXH_ERROR;
#endif // corresponds to #if (#if defined(XXH_ACCEPT_NULL_INPUT_POINTER) && (XXH_ACCEPT_NULL_INPUT_POINTER>=1))

    {   const xxh_u8* p = (const xxh_u8*)input;
        const xxh_u8* const bEnd = p + len;

        state->total_len += len;

        if (state->memsize + len < 32) {  /* fill in tmp buffer */
            XXH_memcpy(((xxh_u8*)state->mem64) + state->memsize, input, len);
            state->memsize += (xxh_u32)len;
            return XXH_OK;
        }

        if (state->memsize) {   /* tmp buffer is full */
            XXH_memcpy(((xxh_u8*)state->mem64) + state->memsize, input, 32-state->memsize);
            state->v1 = XXH64_round(state->v1, XXH_readLE64(state->mem64+0));
            state->v2 = XXH64_round(state->v2, XXH_readLE64(state->mem64+1));
            state->v3 = XXH64_round(state->v3, XXH_readLE64(state->mem64+2));
            state->v4 = XXH64_round(state->v4, XXH_readLE64(state->mem64+3));
            p += 32-state->memsize;
            state->memsize = 0;
        }

        if (p+32 <= bEnd) {
            const xxh_u8* const limit = bEnd - 32;
            xxh_u64 v1 = state->v1;
            xxh_u64 v2 = state->v2;
            xxh_u64 v3 = state->v3;
            xxh_u64 v4 = state->v4;

            do {
                v1 = XXH64_round(v1, XXH_readLE64(p)); p+=8;
                v2 = XXH64_round(v2, XXH_readLE64(p)); p+=8;
                v3 = XXH64_round(v3, XXH_readLE64(p)); p+=8;
                v4 = XXH64_round(v4, XXH_readLE64(p)); p+=8;
            } while (p<=limit);

            state->v1 = v1;
            state->v2 = v2;
            state->v3 = v3;
            state->v4 = v4;
        }

        if (p < bEnd) {
            XXH_memcpy(state->mem64, p, (size_t)(bEnd-p));
            state->memsize = (unsigned)(bEnd-p);
        }
    }

    return XXH_OK;
}

XXH64_hash_t XXH64_digest (const XXH64_state_t* state)
{
    xxh_u64 h64;

    if (state->total_len >= 32) {
        xxh_u64 const v1 = state->v1;
        xxh_u64 const v2 = state->v2;
        xxh_u64 const v3 = state->v3;
        xxh_u64 const v4 = state->v4;

        h64 = XXH_rotl64(v1, 1) + XXH_rotl64(v2, 7) + XXH_rotl64(v3, 12) + XXH_rotl64(v4, 18);
        h64 = XXH64_mergeRound(h64, v1);
        h64 = XXH64_mergeRound(h64, v2);
        h64 = XXH64_mergeRound(h64, v3);
        h64 = XXH64_mergeRound(h64, v4);
    } else {
        h64  = state->v3 /*seed*/ + XXH_PRIME64_5;
    }

    h64 += (xxh_u64) state->total_len;

    return XXH64_finalize(h64, (const xxh_u8*)state->mem64, (size_t)state->total_len, XXH_aligned);
}


/******* Canonical representation   *******/


/* *********************************************************************
*  XXH3
*  New generation hash designed for speed on small keys and vectorization
************************************************************************ */

/* ===   Compiler specifics   === */

#if defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L  && (!defined(SOLARIS))  /* franzfix >= C99 */
#  define XXH_RESTRICT   restrict
#else
/* Note: it might be useful to define __restrict or __restrict__ for some C++ compilers */
#  define XXH_RESTRICT   /* disable */
#endif // corresponds to #if (#if defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L  && (!defined(SOLARIS))  /* franzfix >= C99 */)

#if (defined(__GNUC__) && (__GNUC__ >= 3))  \
  || (defined(__INTEL_COMPILER) && (__INTEL_COMPILER >= 800)) \
  || defined(__clang__)
#    define XXH_likely(x) __builtin_expect(x, 1)
///#    define XXH_unlikely(x) __builtin_expect(x, 0)
#else
#    define XXH_likely(x) (x)
///#    define XXH_unlikely(x) (x)
#endif // corresponds to #if (#if (defined(__GNUC__) && (__GNUC__ >= 3))  \)

#if defined(__GNUC__)
#  if defined(__AVX2__)
#    include <immintrin.h>
#  elif defined(__SSE2__)
#    include <emmintrin.h>
#  elif defined(__ARM_NEON__) || defined(__ARM_NEON)
#    define inline __inline__  /* circumvent a clang bug */
#    include <arm_neon.h>
#    undef inline
#  endif
#elif defined(_MSC_VER)
#  include <intrin.h>
#endif // corresponds to #if (#if defined(__GNUC__))

#if defined(__thumb__) && !defined(__thumb2__) && defined(__ARM_ARCH_ISA_ARM)
#   warning "XXH3 is highly inefficient without ARM or Thumb-2."
#endif // corresponds to #if (#if defined(__thumb__) && !defined(__thumb2__) && defined(__ARM_ARCH_ISA_ARM))

/* ==========================================
 * Vectorization detection
 * ========================================== */
#define XXH_SCALAR 0  /* Portable scalar version */
#define XXH_SSE2   1  /* SSE2 for Pentium 4 and all x86_64 */
#define XXH_AVX2   2  /* AVX2 for Haswell and Bulldozer */
#define XXH_AVX512 3  /* AVX512 for Skylake and Icelake */
#define XXH_NEON   4  /* NEON for most ARMv7-A and all AArch64 */
#define XXH_VSX    5  /* VSX and ZVector for POWER8/z13 */

#ifndef XXH_VECTOR    /* can be defined on command line */
#  if defined(__AVX512F__)
#    define XXH_VECTOR XXH_AVX512
#  elif defined(__AVX2__)
#    define XXH_VECTOR XXH_AVX2
#  elif defined(__SSE2__) || defined(_M_AMD64) || defined(_M_X64) || (defined(_M_IX86_FP) && (_M_IX86_FP == 2))
#    define XXH_VECTOR XXH_SSE2
#  elif defined(__GNUC__) /* msvc support maybe later */ \
  && (defined(__ARM_NEON__) || defined(__ARM_NEON)) \
  && (defined(__LITTLE_ENDIAN__) /* We only support little endian NEON */ \
    || (defined(__BYTE_ORDER__) && __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__))
#    define XXH_VECTOR XXH_NEON
#  elif (defined(__PPC64__) && defined(__POWER8_VECTOR__)) \
     || (defined(__s390x__) && defined(__VEC__)) \
     && defined(__GNUC__) /* TODO: IBM XL */
#    define XXH_VECTOR XXH_VSX
#  else
#    define XXH_VECTOR XXH_SCALAR
#  endif
#endif // corresponds to #ifndef (#ifndef XXH_VECTOR    /* can be defined on command line */)

/*
 * Controls the alignment of the accumulator,
 * for compatibility with aligned vector loads, which are usually faster.
 */
#ifndef XXH_ACC_ALIGN
#  if defined(XXH_X86DISPATCH)
#     define XXH_ACC_ALIGN 64  /* for compatibility with avx512 */
#  elif XXH_VECTOR == XXH_SCALAR  /* scalar */
#     define XXH_ACC_ALIGN 8
#  elif XXH_VECTOR == XXH_SSE2  /* sse2 */
#     define XXH_ACC_ALIGN 16
#  elif XXH_VECTOR == XXH_AVX2  /* avx2 */
#     define XXH_ACC_ALIGN 32
#  elif XXH_VECTOR == XXH_NEON  /* neon */
#     define XXH_ACC_ALIGN 16
#  elif XXH_VECTOR == XXH_VSX   /* vsx */
#     define XXH_ACC_ALIGN 16
#  elif XXH_VECTOR == XXH_AVX512  /* avx512 */
#     define XXH_ACC_ALIGN 64
#  endif
#endif // corresponds to #ifndef (#ifndef XXH_ACC_ALIGN)

#if defined(XXH_X86DISPATCH) || XXH_VECTOR == XXH_SSE2 \
    || XXH_VECTOR == XXH_AVX2 || XXH_VECTOR == XXH_AVX512
#  define XXH_SEC_ALIGN XXH_ACC_ALIGN
#else
#  define XXH_SEC_ALIGN 8
#endif // corresponds to #if (#if defined(XXH_X86DISPATCH) || XXH_VECTOR == XXH_SSE2 \)

#if XXH_VECTOR == XXH_AVX2 /* AVX2 */ \
  && defined(__GNUC__) && !defined(__clang__) /* GCC, not Clang */ \
  && defined(__OPTIMIZE__) && !defined(__OPTIMIZE_SIZE__) /* respect -O0 and -Os */
#  pragma GCC push_options
#  pragma GCC optimize("-O2")
#endif // corresponds to #if (#if XXH_VECTOR == XXH_AVX2 /* AVX2 */ \)


#if XXH_VECTOR == XXH_NEON
# if !defined(XXH_NO_VZIP_HACK) /* define to disable */ \
   && defined(__GNUC__) \
   && !defined(__aarch64__) && !defined(__arm64__)
#  define XXH_SPLIT_IN_PLACE(in, outLo, outHi)                                              \
    do {                                                                                    \
      /* Undocumented GCC/Clang operand modifier: %e0 = lower D half, %f0 = upper D half */ \
      /* https://github.com/gcc-mirror/gcc/blob/38cf91e5/gcc/config/arm/arm.c#L22486 */     \
      /* https://github.com/llvm-mirror/llvm/blob/2c4ca683/lib/Target/ARM/ARMAsmPrinter.cpp#L399 */ \
      __asm__("vzip.32  %e0, %f0" : "+w" (in));                                             \
      (outLo) = vget_low_u32 (vreinterpretq_u32_u64(in));                                   \
      (outHi) = vget_high_u32(vreinterpretq_u32_u64(in));                                   \
   } while (0)
# else
#  define XXH_SPLIT_IN_PLACE(in, outLo, outHi)                                            \
    do {                                                                                  \
      (outLo) = vmovn_u64    (in);                                                        \
      (outHi) = vshrn_n_u64  ((in), 32);                                                  \
    } while (0)
# endif
#endif  /* XXH_VECTOR == XXH_NEON */ // corresponds to #if (#if XXH_VECTOR == XXH_NEON)

/*
 * VSX and Z Vector helpers.
 *
 * This is very messy, and any pull requests to clean this up are welcome.
 *
 * There are a lot of problems with supporting VSX and s390x, due to
 * inconsistent intrinsics, spotty coverage, and multiple endiannesses.
 */
#if XXH_VECTOR == XXH_VSX
#  if defined(__s390x__)
#    include <s390intrin.h>
#  else
/* gcc's altivec.h can have the unwanted consequence to unconditionally
 * #define bool, vector, and pixel keywords,
 * with bad consequences for programs already using these keywords for other purposes.
 * The paragraph defining these macros is skipped when __APPLE_ALTIVEC__ is defined.
 * __APPLE_ALTIVEC__ is _generally_ defined automatically by the compiler,
 * but it seems that, in some cases, it isn't.
 * Force the build macro to be defined, so that keywords are not altered.
 */
#    if defined(__GNUC__) && !defined(__APPLE_ALTIVEC__)
#      define __APPLE_ALTIVEC__
#    endif
#    include <altivec.h>
#  endif

typedef __vector unsigned long long xxh_u64x2;
typedef __vector unsigned char xxh_u8x16;
typedef __vector unsigned xxh_u32x4;


/*
 * Performs an unaligned load and byte swaps it on big endian.
 */
XXH_FORCE_INLINE xxh_u64x2 XXH_vec_loadu(const void *ptr)
{
    xxh_u64x2 ret;
    memcpy(&ret, ptr, sizeof(xxh_u64x2));
# if XXH_VSX_BE
    ret = XXH_vec_revb(ret);
# endif
    return ret;
}

/*
 * vec_mulo and vec_mule are very problematic intrinsics on PowerPC
 *
 * These intrinsics weren't added until GCC 8, despite existing for a while,
 * and they are endian dependent. Also, their meaning swap depending on version.
 * */
# if defined(__s390x__)
 /* s390x is always big endian, no issue on this platform */
#  define XXH_vec_mulo vec_mulo
#  define XXH_vec_mule vec_mule
# elif defined(__clang__) && XXH_HAS_BUILTIN(__builtin_altivec_vmuleuw)
/* Clang has a better way to control this, we can just use the builtin which doesn't swap. */
#  define XXH_vec_mulo __builtin_altivec_vmulouw
#  define XXH_vec_mule __builtin_altivec_vmuleuw
# else
/* gcc needs inline assembly */
/* Adapted from https://github.com/google/highwayhash/blob/master/highwayhash/hh_vsx.h. */
XXH_FORCE_INLINE xxh_u64x2 XXH_vec_mulo(xxh_u32x4 a, xxh_u32x4 b)
{
    xxh_u64x2 result;
    __asm__("vmulouw %0, %1, %2" : "=v" (result) : "v" (a), "v" (b));
    return result;
}
XXH_FORCE_INLINE xxh_u64x2 XXH_vec_mule(xxh_u32x4 a, xxh_u32x4 b)
{
    xxh_u64x2 result;
    __asm__("vmuleuw %0, %1, %2" : "=v" (result) : "v" (a), "v" (b));
    return result;
}
# endif /* XXH_vec_mulo, XXH_vec_mule */
#endif /* XXH_VECTOR == XXH_VSX */ // corresponds to #if (#if XXH_VECTOR == XXH_VSX)


/* prefetch
 * can be disabled, by declaring XXH_NO_PREFETCH build macro */
#if defined(XXH_NO_PREFETCH)
#  define XXH_PREFETCH(ptr)  (void)(ptr)  /* disabled */
#else
#  if defined(_MSC_VER) && (defined(_M_X64) || defined(_M_I86))  /* _mm_prefetch() is not defined outside of x86/x64 */
#    include <mmintrin.h>   /* https://msdn.microsoft.com/fr-fr/library/84szxsww(v=vs.90).aspx */
#    define XXH_PREFETCH(ptr)  _mm_prefetch((const char*)(ptr), _MM_HINT_T0)
#  elif defined(__GNUC__) && ( (__GNUC__ >= 4) || ( (__GNUC__ == 3) && (__GNUC_MINOR__ >= 1) ) )
#    define XXH_PREFETCH(ptr)  __builtin_prefetch((ptr), 0 /* rw==read */, 3 /* locality */)
#  else
#    define XXH_PREFETCH(ptr) (void)(ptr)  /* disabled */
#  endif
#endif  /* XXH_NO_PREFETCH */ // corresponds to #if (#if defined(XXH_NO_PREFETCH))


/* ==========================================
 * XXH3 default settings
 * ========================================== */

#define XXH_SECRET_DEFAULT_SIZE 192   /* minimum XXH3_SECRET_SIZE_MIN */

#if (XXH_SECRET_DEFAULT_SIZE < XXH3_SECRET_SIZE_MIN)
#  error "default keyset is not large enough"
#endif // corresponds to #if (#if (XXH_SECRET_DEFAULT_SIZE < XXH3_SECRET_SIZE_MIN))

/* Pseudorandom secret taken directly from FARSH */
XXH_ALIGN(64) static const xxh_u8 XXH3_kSecret[XXH_SECRET_DEFAULT_SIZE] = {
    0xb8, 0xfe, 0x6c, 0x39, 0x23, 0xa4, 0x4b, 0xbe, 0x7c, 0x01, 0x81, 0x2c, 0xf7, 0x21, 0xad, 0x1c,
    0xde, 0xd4, 0x6d, 0xe9, 0x83, 0x90, 0x97, 0xdb, 0x72, 0x40, 0xa4, 0xa4, 0xb7, 0xb3, 0x67, 0x1f,
    0xcb, 0x79, 0xe6, 0x4e, 0xcc, 0xc0, 0xe5, 0x78, 0x82, 0x5a, 0xd0, 0x7d, 0xcc, 0xff, 0x72, 0x21,
    0xb8, 0x08, 0x46, 0x74, 0xf7, 0x43, 0x24, 0x8e, 0xe0, 0x35, 0x90, 0xe6, 0x81, 0x3a, 0x26, 0x4c,
    0x3c, 0x28, 0x52, 0xbb, 0x91, 0xc3, 0x00, 0xcb, 0x88, 0xd0, 0x65, 0x8b, 0x1b, 0x53, 0x2e, 0xa3,
    0x71, 0x64, 0x48, 0x97, 0xa2, 0x0d, 0xf9, 0x4e, 0x38, 0x19, 0xef, 0x46, 0xa9, 0xde, 0xac, 0xd8,
    0xa8, 0xfa, 0x76, 0x3f, 0xe3, 0x9c, 0x34, 0x3f, 0xf9, 0xdc, 0xbb, 0xc7, 0xc7, 0x0b, 0x4f, 0x1d,
    0x8a, 0x51, 0xe0, 0x4b, 0xcd, 0xb4, 0x59, 0x31, 0xc8, 0x9f, 0x7e, 0xc9, 0xd9, 0x78, 0x73, 0x64,
    0xea, 0xc5, 0xac, 0x83, 0x34, 0xd3, 0xeb, 0xc3, 0xc5, 0x81, 0xa0, 0xff, 0xfa, 0x13, 0x63, 0xeb,
    0x17, 0x0d, 0xdd, 0x51, 0xb7, 0xf0, 0xda, 0x49, 0xd3, 0x16, 0x55, 0x26, 0x29, 0xd4, 0x68, 0x9e,
    0x2b, 0x16, 0xbe, 0x58, 0x7d, 0x47, 0xa1, 0xfc, 0x8f, 0xf8, 0xb8, 0xd1, 0x7a, 0xd0, 0x31, 0xce,
    0x45, 0xcb, 0x3a, 0x8f, 0x95, 0x16, 0x04, 0x28, 0xaf, 0xd7, 0xfb, 0xca, 0xbb, 0x4b, 0x40, 0x7e,
};



#if defined(_MSC_VER) && defined(_M_IX86)
#    include <intrin.h>
#    define XXH_mult32to64(x, y) __emulu((unsigned)(x), (unsigned)(y))
#else
/*
 * Downcast + upcast is usually better than masking on older compilers like
 * GCC 4.2 (especially 32-bit ones), all without affecting newer compilers.
 *
 * The other method, (x & 0xFFFFFFFF) * (y & 0xFFFFFFFF), will AND both operands
 * and perform a full 64x64 multiply -- entirely redundant on 32-bit.
 */
#    define XXH_mult32to64(x, y) ((xxh_u64)(xxh_u32)(x) * (xxh_u64)(xxh_u32)(y))
#endif // corresponds to #if (#if defined(_MSC_VER) && defined(_M_IX86))

/*
 * Calculates a 64->128-bit long multiply.
 *
 * Uses __uint128_t and _umul128 if available, otherwise uses a scalar version.
 */
static XXH128_hash_t
XXH_mult64to128(xxh_u64 lhs, xxh_u64 rhs)
{
#if defined(__GNUC__) && !defined(__wasm__) \
    && defined(__SIZEOF_INT128__) \
    || (defined(_INTEGRAL_MAX_BITS) && _INTEGRAL_MAX_BITS >= 128)

    __uint128_t const product = (__uint128_t)lhs * (__uint128_t)rhs;
    XXH128_hash_t r128;
    r128.low64  = (xxh_u64)(product);
    r128.high64 = (xxh_u64)(product >> 64);
    return r128;

    /*
     * MSVC for x64's _umul128 method.
     *
     * xxh_u64 _umul128(xxh_u64 Multiplier, xxh_u64 Multiplicand, xxh_u64 *HighProduct);
     *
     * This compiles to single operand MUL on x64.
     */
#elif defined(_M_X64) || defined(_M_IA64)

#ifndef _MSC_VER
#   pragma intrinsic(_umul128)
#endif // corresponds to #ifndef (#ifndef _MSC_VER)
    xxh_u64 product_high;
    xxh_u64 const product_low = _umul128(lhs, rhs, &product_high);
    XXH128_hash_t r128;
    r128.low64  = product_low;
    r128.high64 = product_high;
    return r128;

#else

    /* First calculate all of the cross products. */
    xxh_u64 const lo_lo = XXH_mult32to64(lhs & 0xFFFFFFFF, rhs & 0xFFFFFFFF);
    xxh_u64 const hi_lo = XXH_mult32to64(lhs >> 32,        rhs & 0xFFFFFFFF);
    xxh_u64 const lo_hi = XXH_mult32to64(lhs & 0xFFFFFFFF, rhs >> 32);
    xxh_u64 const hi_hi = XXH_mult32to64(lhs >> 32,        rhs >> 32);

    /* Now add the products together. These will never overflow. */
    xxh_u64 const cross = (lo_lo >> 32) + (hi_lo & 0xFFFFFFFF) + lo_hi;
    xxh_u64 const upper = (hi_lo >> 32) + (cross >> 32)        + hi_hi;
    xxh_u64 const lower = (cross << 32) | (lo_lo & 0xFFFFFFFF);

    XXH128_hash_t r128;
    r128.low64  = lower;
    r128.high64 = upper;
    return r128;
#endif // corresponds to #if (#if defined(__GNUC__) && !defined(__wasm__) \)
}

static xxh_u64
XXH3_mul128_fold64(xxh_u64 lhs, xxh_u64 rhs)
{
    XXH128_hash_t product = XXH_mult64to128(lhs, rhs);
    return product.low64 ^ product.high64;
}

/* Seems to produce slightly better code on GCC for some reason. */
XXH_FORCE_INLINE xxh_u64 XXH_xorshift64(xxh_u64 v64, int shift)
{
    XXH_ASSERT(0 <= shift && shift < 64);
    return v64 ^ (v64 >> shift);
}

/*
 * This is a fast avalanche stage,
 * suitable when input bits are already partially mixed
 */
static XXH64_hash_t XXH3_avalanche(xxh_u64 h64)
{
    h64 = XXH_xorshift64(h64, 37);
    h64 *= 0x165667919E3779F9ULL;
    h64 = XXH_xorshift64(h64, 32);
    return h64;
}


XXH_FORCE_INLINE xxh_u64 XXH3_mix16B(const xxh_u8* XXH_RESTRICT input,
                                     const xxh_u8* XXH_RESTRICT secret, xxh_u64 seed64)
{
#if defined(__GNUC__) && !defined(__clang__) /* GCC, not Clang */ \
  && defined(__i386__) && defined(__SSE2__)  /* x86 + SSE2 */ \
  && !defined(XXH_ENABLE_AUTOVECTORIZE)      /* Define to disable like XXH32 hack */
    __asm__ ("" : "+r" (seed64));
#endif // corresponds to #if (#if defined(__GNUC__) && !defined(__clang__) /* GCC, not Clang */ \)
    {   xxh_u64 const input_lo = XXH_readLE64(input);
        xxh_u64 const input_hi = XXH_readLE64(input+8);
        return XXH3_mul128_fold64(
            input_lo ^ (XXH_readLE64(secret)   + seed64),
            input_hi ^ (XXH_readLE64(secret+8) - seed64)
        );
    }
}


#define XXH3_MIDSIZE_MAX 240
#define XXH3_MIDSIZE_STARTOFFSET 3
#define XXH3_MIDSIZE_LASTOFFSET  17


/* =======     Long Keys     ======= */

#define XXH_STRIPE_LEN 64
#define XXH_SECRET_CONSUME_RATE 8   /* nb of secret bytes consumed at each accumulation */
#define XXH_ACC_NB (XXH_STRIPE_LEN / sizeof(xxh_u64))


XXH_FORCE_INLINE void XXH_writeLE64(void* dst, xxh_u64 v64)
{
    if (!XXH_CPU_LITTLE_ENDIAN) v64 = XXH_swap64(v64);
    memcpy(dst, &v64, sizeof(v64));
}

/* Several intrinsic functions below are supposed to accept __int64 as argument,
 * as documented in https://software.intel.com/sites/landingpage/IntrinsicsGuide/ .
 * However, several environments do not define __int64 type,
 * requiring a workaround.
 */
#if !defined (__VMS) \
  && (defined (__cplusplus) \
  || (defined (__STDC_VERSION__) && (__STDC_VERSION__ >= 199901L) /* C99 */) )
    typedef int64_t xxh_i64;
#else
    /* the following type must have a width of 64-bit */
    typedef long long xxh_i64;
#endif // corresponds to #if (#if !defined (__VMS) \)


#if (XXH_VECTOR == XXH_AVX512) || defined(XXH_X86DISPATCH)

#ifndef XXH_TARGET_AVX512
# define XXH_TARGET_AVX512  /* disable attribute target */
#endif // corresponds to #ifndef (#ifndef XXH_TARGET_AVX512)

XXH_FORCE_INLINE XXH_TARGET_AVX512 void
XXH3_accumulate_512_avx512(void* XXH_RESTRICT acc,
                     const void* XXH_RESTRICT input,
                     const void* XXH_RESTRICT secret)
{
    XXH_ALIGN(64) __m512i* const xacc = (__m512i *) acc;
    XXH_ASSERT((((size_t)acc) & 63) == 0);
    XXH_STATIC_ASSERT(XXH_STRIPE_LEN == sizeof(__m512i));

    {
        /* data_vec    = input[0]; */
        __m512i const data_vec    = _mm512_loadu_si512   (input);
        /* key_vec     = secret[0]; */
        __m512i const key_vec     = _mm512_loadu_si512   (secret);
        /* data_key    = data_vec ^ key_vec; */
        __m512i const data_key    = _mm512_xor_si512     (data_vec, key_vec);
        /* data_key_lo = data_key >> 32; */
        __m512i const data_key_lo = _mm512_shuffle_epi32 (data_key, (_MM_PERM_ENUM)_MM_SHUFFLE(0, 3, 0, 1));
        /* product     = (data_key & 0xffffffff) * (data_key_lo & 0xffffffff); */
        __m512i const product     = _mm512_mul_epu32     (data_key, data_key_lo);
        /* xacc[0] += swap(data_vec); */
        __m512i const data_swap = _mm512_shuffle_epi32(data_vec, (_MM_PERM_ENUM)_MM_SHUFFLE(1, 0, 3, 2));
        __m512i const sum       = _mm512_add_epi64(*xacc, data_swap);
        /* xacc[0] += product; */
        *xacc = _mm512_add_epi64(product, sum);
    }
}


XXH_FORCE_INLINE XXH_TARGET_AVX512 void
XXH3_scrambleAcc_avx512(void* XXH_RESTRICT acc, const void* XXH_RESTRICT secret)
{
    XXH_ASSERT((((size_t)acc) & 63) == 0);
    XXH_STATIC_ASSERT(XXH_STRIPE_LEN == sizeof(__m512i));
    {   XXH_ALIGN(64) __m512i* const xacc = (__m512i*) acc;
        const __m512i prime32 = _mm512_set1_epi32((int)XXH_PRIME32_1);

        /* xacc[0] ^= (xacc[0] >> 47) */
        __m512i const acc_vec     = *xacc;
        __m512i const shifted     = _mm512_srli_epi64    (acc_vec, 47);
        __m512i const data_vec    = _mm512_xor_si512     (acc_vec, shifted);
        /* xacc[0] ^= secret; */
        __m512i const key_vec     = _mm512_loadu_si512   (secret);
        __m512i const data_key    = _mm512_xor_si512     (data_vec, key_vec);

        /* xacc[0] *= XXH_PRIME32_1; */
        __m512i const data_key_hi = _mm512_shuffle_epi32 (data_key, (_MM_PERM_ENUM)_MM_SHUFFLE(0, 3, 0, 1));
        __m512i const prod_lo     = _mm512_mul_epu32     (data_key, prime32);
        __m512i const prod_hi     = _mm512_mul_epu32     (data_key_hi, prime32);
        *xacc = _mm512_add_epi64(prod_lo, _mm512_slli_epi64(prod_hi, 32));
    }
}

XXH_FORCE_INLINE XXH_TARGET_AVX512 void
XXH3_initCustomSecret_avx512(void* XXH_RESTRICT customSecret, xxh_u64 seed64)
{
    XXH_STATIC_ASSERT((XXH_SECRET_DEFAULT_SIZE & 63) == 0);
    XXH_STATIC_ASSERT(XXH_SEC_ALIGN == 64);
    XXH_ASSERT(((size_t)customSecret & 63) == 0);
    (void)(&XXH_writeLE64);
    {   int const nbRounds = XXH_SECRET_DEFAULT_SIZE / sizeof(__m512i);
        __m512i const seed = _mm512_mask_set1_epi64(_mm512_set1_epi64((xxh_i64)seed64), 0xAA, -(xxh_i64)seed64);

        XXH_ALIGN(64) const __m512i* const src  = (const __m512i*) XXH3_kSecret;
        XXH_ALIGN(64)       __m512i* const dest = (      __m512i*) customSecret;
        int i;
        for (i=0; i < nbRounds; ++i) {
            /* GCC has a bug, _mm512_stream_load_si512 accepts 'void*', not 'void const*',
             * this will warn "discards ?const? qualifier". */
            union {
                XXH_ALIGN(64) const __m512i* cp;
                XXH_ALIGN(64) void* p;
            } remote_const_void;
            remote_const_void.cp = src + i;
            dest[i] = _mm512_add_epi64(_mm512_stream_load_si512(remote_const_void.p), seed);
    }   }
}

#endif // corresponds to #if (#if (XXH_VECTOR == XXH_AVX512) || defined(XXH_X86DISPATCH))

#if (XXH_VECTOR == XXH_AVX2) || defined(XXH_X86DISPATCH)

#ifndef XXH_TARGET_AVX2
# define XXH_TARGET_AVX2  /* disable attribute target */
#endif // corresponds to #ifndef (#ifndef XXH_TARGET_AVX2)

XXH_FORCE_INLINE XXH_TARGET_AVX2 void
XXH3_accumulate_512_avx2( void* XXH_RESTRICT acc,
                    const void* XXH_RESTRICT input,
                    const void* XXH_RESTRICT secret)
{
    XXH_ASSERT((((size_t)acc) & 31) == 0);
    {   XXH_ALIGN(32) __m256i* const xacc    =       (__m256i *) acc;
        /* Unaligned. This is mainly for pointer arithmetic, and because
         * _mm256_loadu_si256 requires  a const __m256i * pointer for some reason. */
        const         __m256i* const xinput  = (const __m256i *) input;
        /* Unaligned. This is mainly for pointer arithmetic, and because
         * _mm256_loadu_si256 requires a const __m256i * pointer for some reason. */
        const         __m256i* const xsecret = (const __m256i *) secret;

        size_t i;
        for (i=0; i < XXH_STRIPE_LEN/sizeof(__m256i); i++) {
            /* data_vec    = xinput[i]; */
            __m256i const data_vec    = _mm256_loadu_si256    (xinput+i);
            /* key_vec     = xsecret[i]; */
            __m256i const key_vec     = _mm256_loadu_si256   (xsecret+i);
            /* data_key    = data_vec ^ key_vec; */
            __m256i const data_key    = _mm256_xor_si256     (data_vec, key_vec);
            /* data_key_lo = data_key >> 32; */
            __m256i const data_key_lo = _mm256_shuffle_epi32 (data_key, _MM_SHUFFLE(0, 3, 0, 1));
            /* product     = (data_key & 0xffffffff) * (data_key_lo & 0xffffffff); */
            __m256i const product     = _mm256_mul_epu32     (data_key, data_key_lo);
            /* xacc[i] += swap(data_vec); */
            __m256i const data_swap = _mm256_shuffle_epi32(data_vec, _MM_SHUFFLE(1, 0, 3, 2));
            __m256i const sum       = _mm256_add_epi64(xacc[i], data_swap);
            /* xacc[i] += product; */
            xacc[i] = _mm256_add_epi64(product, sum);
    }   }
}

XXH_FORCE_INLINE XXH_TARGET_AVX2 void
XXH3_scrambleAcc_avx2(void* XXH_RESTRICT acc, const void* XXH_RESTRICT secret)
{
    XXH_ASSERT((((size_t)acc) & 31) == 0);
    {   XXH_ALIGN(32) __m256i* const xacc = (__m256i*) acc;
        /* Unaligned. This is mainly for pointer arithmetic, and because
         * _mm256_loadu_si256 requires a const __m256i * pointer for some reason. */
        const         __m256i* const xsecret = (const __m256i *) secret;
        const __m256i prime32 = _mm256_set1_epi32((int)XXH_PRIME32_1);

        size_t i;
        for (i=0; i < XXH_STRIPE_LEN/sizeof(__m256i); i++) {
            /* xacc[i] ^= (xacc[i] >> 47) */
            __m256i const acc_vec     = xacc[i];
            __m256i const shifted     = _mm256_srli_epi64    (acc_vec, 47);
            __m256i const data_vec    = _mm256_xor_si256     (acc_vec, shifted);
            /* xacc[i] ^= xsecret; */
            __m256i const key_vec     = _mm256_loadu_si256   (xsecret+i);
            __m256i const data_key    = _mm256_xor_si256     (data_vec, key_vec);

            /* xacc[i] *= XXH_PRIME32_1; */
            __m256i const data_key_hi = _mm256_shuffle_epi32 (data_key, _MM_SHUFFLE(0, 3, 0, 1));
            __m256i const prod_lo     = _mm256_mul_epu32     (data_key, prime32);
            __m256i const prod_hi     = _mm256_mul_epu32     (data_key_hi, prime32);
            xacc[i] = _mm256_add_epi64(prod_lo, _mm256_slli_epi64(prod_hi, 32));
        }
    }
}

XXH_FORCE_INLINE XXH_TARGET_AVX2 void XXH3_initCustomSecret_avx2(void* XXH_RESTRICT customSecret, xxh_u64 seed64)
{
    XXH_STATIC_ASSERT((XXH_SECRET_DEFAULT_SIZE & 31) == 0);
    XXH_STATIC_ASSERT((XXH_SECRET_DEFAULT_SIZE / sizeof(__m256i)) == 6);
    XXH_STATIC_ASSERT(XXH_SEC_ALIGN <= 64);
    (void)(&XXH_writeLE64);
    XXH_PREFETCH(customSecret);
    {   __m256i const seed = _mm256_set_epi64x(-(xxh_i64)seed64, (xxh_i64)seed64, -(xxh_i64)seed64, (xxh_i64)seed64);

        XXH_ALIGN(64) const __m256i* const src  = (const __m256i*) XXH3_kSecret;
        XXH_ALIGN(64)       __m256i*       dest = (      __m256i*) customSecret;

#       if defined(__GNUC__) || defined(__clang__)
        /*
         * On GCC & Clang, marking 'dest' as modified will cause the compiler:
         *   - do not extract the secret from sse registers in the internal loop
         *   - use less common registers, and avoid pushing these reg into stack
         * The asm hack causes Clang to assume that XXH3_kSecretPtr aliases with
         * customSecret, and on aarch64, this prevented LDP from merging two
         * loads together for free. Putting the loads together before the stores
         * properly generates LDP.
         */
        __asm__("" : "+r" (dest));
#       endif

        /* GCC -O2 need unroll loop manually */
        dest[0] = _mm256_add_epi64(_mm256_stream_load_si256(src+0), seed);
        dest[1] = _mm256_add_epi64(_mm256_stream_load_si256(src+1), seed);
        dest[2] = _mm256_add_epi64(_mm256_stream_load_si256(src+2), seed);
        dest[3] = _mm256_add_epi64(_mm256_stream_load_si256(src+3), seed);
        dest[4] = _mm256_add_epi64(_mm256_stream_load_si256(src+4), seed);
        dest[5] = _mm256_add_epi64(_mm256_stream_load_si256(src+5), seed);
    }
}

#endif // corresponds to #if (#if (XXH_VECTOR == XXH_AVX2) || defined(XXH_X86DISPATCH))

#if (XXH_VECTOR == XXH_SSE2) || defined(XXH_X86DISPATCH)

#ifndef XXH_TARGET_SSE2
# define XXH_TARGET_SSE2  /* disable attribute target */
#endif // corresponds to #ifndef (#ifndef XXH_TARGET_SSE2)

XXH_FORCE_INLINE XXH_TARGET_SSE2 void
XXH3_accumulate_512_sse2( void* XXH_RESTRICT acc,
                    const void* XXH_RESTRICT input,
                    const void* XXH_RESTRICT secret)
{
    /* SSE2 is just a half-scale version of the AVX2 version. */
    XXH_ASSERT((((size_t)acc) & 15) == 0);
    {   XXH_ALIGN(16) __m128i* const xacc    =       (__m128i *) acc;
        /* Unaligned. This is mainly for pointer arithmetic, and because
         * _mm_loadu_si128 requires a const __m128i * pointer for some reason. */
        const         __m128i* const xinput  = (const __m128i *) input;
        /* Unaligned. This is mainly for pointer arithmetic, and because
         * _mm_loadu_si128 requires a const __m128i * pointer for some reason. */
        const         __m128i* const xsecret = (const __m128i *) secret;

        size_t i;
        for (i=0; i < XXH_STRIPE_LEN/sizeof(__m128i); i++) {
            /* data_vec    = xinput[i]; */
            __m128i const data_vec    = _mm_loadu_si128   (xinput+i);
            /* key_vec     = xsecret[i]; */
            __m128i const key_vec     = _mm_loadu_si128   (xsecret+i);
            /* data_key    = data_vec ^ key_vec; */
            __m128i const data_key    = _mm_xor_si128     (data_vec, key_vec);
            /* data_key_lo = data_key >> 32; */
            __m128i const data_key_lo = _mm_shuffle_epi32 (data_key, _MM_SHUFFLE(0, 3, 0, 1));
            /* product     = (data_key & 0xffffffff) * (data_key_lo & 0xffffffff); */
            __m128i const product     = _mm_mul_epu32     (data_key, data_key_lo);
            /* xacc[i] += swap(data_vec); */
            __m128i const data_swap = _mm_shuffle_epi32(data_vec, _MM_SHUFFLE(1,0,3,2));
            __m128i const sum       = _mm_add_epi64(xacc[i], data_swap);
            /* xacc[i] += product; */
            xacc[i] = _mm_add_epi64(product, sum);
    }   }
}

XXH_FORCE_INLINE XXH_TARGET_SSE2 void
XXH3_scrambleAcc_sse2(void* XXH_RESTRICT acc, const void* XXH_RESTRICT secret)
{
    XXH_ASSERT((((size_t)acc) & 15) == 0);
    {   XXH_ALIGN(16) __m128i* const xacc = (__m128i*) acc;
        /* Unaligned. This is mainly for pointer arithmetic, and because
         * _mm_loadu_si128 requires a const __m128i * pointer for some reason. */
        const         __m128i* const xsecret = (const __m128i *) secret;
        const __m128i prime32 = _mm_set1_epi32((int)XXH_PRIME32_1);

        size_t i;
        for (i=0; i < XXH_STRIPE_LEN/sizeof(__m128i); i++) {
            /* xacc[i] ^= (xacc[i] >> 47) */
            __m128i const acc_vec     = xacc[i];
            __m128i const shifted     = _mm_srli_epi64    (acc_vec, 47);
            __m128i const data_vec    = _mm_xor_si128     (acc_vec, shifted);
            /* xacc[i] ^= xsecret[i]; */
            __m128i const key_vec     = _mm_loadu_si128   (xsecret+i);
            __m128i const data_key    = _mm_xor_si128     (data_vec, key_vec);

            /* xacc[i] *= XXH_PRIME32_1; */
            __m128i const data_key_hi = _mm_shuffle_epi32 (data_key, _MM_SHUFFLE(0, 3, 0, 1));
            __m128i const prod_lo     = _mm_mul_epu32     (data_key, prime32);
            __m128i const prod_hi     = _mm_mul_epu32     (data_key_hi, prime32);
            xacc[i] = _mm_add_epi64(prod_lo, _mm_slli_epi64(prod_hi, 32));
        }
    }
}

XXH_FORCE_INLINE XXH_TARGET_SSE2 void XXH3_initCustomSecret_sse2(void* XXH_RESTRICT customSecret, xxh_u64 seed64)
{
    XXH_STATIC_ASSERT((XXH_SECRET_DEFAULT_SIZE & 15) == 0);
    (void)(&XXH_writeLE64);
    {   int const nbRounds = XXH_SECRET_DEFAULT_SIZE / sizeof(__m128i);

#       if defined(_MSC_VER) && defined(_M_IX86) && _MSC_VER < 1900
        // MSVC 32bit mode does not support _mm_set_epi64x before 2015
        XXH_ALIGN(16) const xxh_i64 seed64x2[2] = { (xxh_i64)seed64, -(xxh_i64)seed64 };
        __m128i const seed = _mm_load_si128((__m128i const*)seed64x2);
#       else
        __m128i const seed = _mm_set_epi64x(-(xxh_i64)seed64, (xxh_i64)seed64);
#       endif
        int i;

        XXH_ALIGN(64)        const float* const src  = (float const*) XXH3_kSecret;
        XXH_ALIGN(XXH_SEC_ALIGN) __m128i*       dest = (__m128i*) customSecret;
#       if defined(__GNUC__) || defined(__clang__)
        /*
         * On GCC & Clang, marking 'dest' as modified will cause the compiler:
         *   - do not extract the secret from sse registers in the internal loop
         *   - use less common registers, and avoid pushing these reg into stack
         */
        __asm__("" : "+r" (dest));
#       endif

        for (i=0; i < nbRounds; ++i) {
            dest[i] = _mm_add_epi64(_mm_castps_si128(_mm_load_ps(src+i*4)), seed);
    }   }
}

#endif // corresponds to #if (#if (XXH_VECTOR == XXH_SSE2) || defined(XXH_X86DISPATCH))

#if (XXH_VECTOR == XXH_NEON)

XXH_FORCE_INLINE void
XXH3_accumulate_512_neon( void* XXH_RESTRICT acc,
                    const void* XXH_RESTRICT input,
                    const void* XXH_RESTRICT secret)
{
    XXH_ASSERT((((size_t)acc) & 15) == 0);
    {
        XXH_ALIGN(16) uint64x2_t* const xacc = (uint64x2_t *) acc;
        /* We don't use a uint32x4_t pointer because it causes bus errors on ARMv7. */
        uint8_t const* const xinput = (const uint8_t *) input;
        uint8_t const* const xsecret  = (const uint8_t *) secret;

        size_t i;
        for (i=0; i < XXH_STRIPE_LEN / sizeof(uint64x2_t); i++) {
            /* data_vec = xinput[i]; */
            uint8x16_t data_vec    = vld1q_u8(xinput  + (i * 16));
            /* key_vec  = xsecret[i];  */
            uint8x16_t key_vec     = vld1q_u8(xsecret + (i * 16));
            uint64x2_t data_key;
            uint32x2_t data_key_lo, data_key_hi;
            /* xacc[i] += swap(data_vec); */
            uint64x2_t const data64  = vreinterpretq_u64_u8(data_vec);
            uint64x2_t const swapped = vextq_u64(data64, data64, 1);
            xacc[i] = vaddq_u64 (xacc[i], swapped);
            /* data_key = data_vec ^ key_vec; */
            data_key = vreinterpretq_u64_u8(veorq_u8(data_vec, key_vec));
            /* data_key_lo = (uint32x2_t) (data_key & 0xFFFFFFFF);
             * data_key_hi = (uint32x2_t) (data_key >> 32);
             * data_key = UNDEFINED; */
            XXH_SPLIT_IN_PLACE(data_key, data_key_lo, data_key_hi);
            /* xacc[i] += (uint64x2_t) data_key_lo * (uint64x2_t) data_key_hi; */
            xacc[i] = vmlal_u32 (xacc[i], data_key_lo, data_key_hi);

        }
    }
}

XXH_FORCE_INLINE void
XXH3_scrambleAcc_neon(void* XXH_RESTRICT acc, const void* XXH_RESTRICT secret)
{
    XXH_ASSERT((((size_t)acc) & 15) == 0);

    {   uint64x2_t* xacc       = (uint64x2_t*) acc;
        uint8_t const* xsecret = (uint8_t const*) secret;
        uint32x2_t prime       = vdup_n_u32 (XXH_PRIME32_1);

        size_t i;
        for (i=0; i < XXH_STRIPE_LEN/sizeof(uint64x2_t); i++) {
            /* xacc[i] ^= (xacc[i] >> 47); */
            uint64x2_t acc_vec  = xacc[i];
            uint64x2_t shifted  = vshrq_n_u64 (acc_vec, 47);
            uint64x2_t data_vec = veorq_u64   (acc_vec, shifted);

            /* xacc[i] ^= xsecret[i]; */
            uint8x16_t key_vec  = vld1q_u8(xsecret + (i * 16));
            uint64x2_t data_key = veorq_u64(data_vec, vreinterpretq_u64_u8(key_vec));

            /* xacc[i] *= XXH_PRIME32_1 */
            uint32x2_t data_key_lo, data_key_hi;
            /* data_key_lo = (uint32x2_t) (xacc[i] & 0xFFFFFFFF);
             * data_key_hi = (uint32x2_t) (xacc[i] >> 32);
             * xacc[i] = UNDEFINED; */
            XXH_SPLIT_IN_PLACE(data_key, data_key_lo, data_key_hi);
            {   /*
                 * prod_hi = (data_key >> 32) * XXH_PRIME32_1;
                 *
                 * Avoid vmul_u32 + vshll_n_u32 since Clang 6 and 7 will
                 * incorrectly "optimize" this:
                 *   tmp     = vmul_u32(vmovn_u64(a), vmovn_u64(b));
                 *   shifted = vshll_n_u32(tmp, 32);
                 * to this:
                 *   tmp     = "vmulq_u64"(a, b); // no such thing!
                 *   shifted = vshlq_n_u64(tmp, 32);
                 *
                 * However, unlike SSE, Clang lacks a 64-bit multiply routine
                 * for NEON, and it scalarizes two 64-bit multiplies instead.
                 *
                 * vmull_u32 has the same timing as vmul_u32, and it avoids
                 * this bug completely.
                 * See https://bugs.llvm.org/show_bug.cgi?id=39967
                 */
                uint64x2_t prod_hi = vmull_u32 (data_key_hi, prime);
                /* xacc[i] = prod_hi << 32; */
                xacc[i] = vshlq_n_u64(prod_hi, 32);
                /* xacc[i] += (prod_hi & 0xFFFFFFFF) * XXH_PRIME32_1; */
                xacc[i] = vmlal_u32(xacc[i], data_key_lo, prime);
            }
    }   }
}

#endif // corresponds to #if (#if (XXH_VECTOR == XXH_NEON))

#if (XXH_VECTOR == XXH_VSX)

XXH_FORCE_INLINE void
XXH3_accumulate_512_vsx(  void* XXH_RESTRICT acc,
                    const void* XXH_RESTRICT input,
                    const void* XXH_RESTRICT secret)
{
          xxh_u64x2* const xacc     =       (xxh_u64x2*) acc;    /* presumed aligned */
    xxh_u64x2 const* const xinput   = (xxh_u64x2 const*) input;   /* no alignment restriction */
    xxh_u64x2 const* const xsecret  = (xxh_u64x2 const*) secret;    /* no alignment restriction */
    xxh_u64x2 const v32 = { 32, 32 };
    size_t i;
    for (i = 0; i < XXH_STRIPE_LEN / sizeof(xxh_u64x2); i++) {
        /* data_vec = xinput[i]; */
        xxh_u64x2 const data_vec = XXH_vec_loadu(xinput + i);
        /* key_vec = xsecret[i]; */
        xxh_u64x2 const key_vec  = XXH_vec_loadu(xsecret + i);
        xxh_u64x2 const data_key = data_vec ^ key_vec;
        /* shuffled = (data_key << 32) | (data_key >> 32); */
        xxh_u32x4 const shuffled = (xxh_u32x4)vec_rl(data_key, v32);
        /* product = ((xxh_u64x2)data_key & 0xFFFFFFFF) * ((xxh_u64x2)shuffled & 0xFFFFFFFF); */
        xxh_u64x2 const product  = XXH_vec_mulo((xxh_u32x4)data_key, shuffled);
        xacc[i] += product;

        /* swap high and low halves */
#ifdef __s390x__
        xacc[i] += vec_permi(data_vec, data_vec, 2);
#else
        xacc[i] += vec_xxpermdi(data_vec, data_vec, 2);
#endif // corresponds to #ifdef (#ifdef __s390x__)
    }
}

XXH_FORCE_INLINE void
XXH3_scrambleAcc_vsx(void* XXH_RESTRICT acc, const void* XXH_RESTRICT secret)
{
    XXH_ASSERT((((size_t)acc) & 15) == 0);

    {         xxh_u64x2* const xacc    =       (xxh_u64x2*) acc;
        const xxh_u64x2* const xsecret = (const xxh_u64x2*) secret;
        /* constants */
        xxh_u64x2 const v32  = { 32, 32 };
        xxh_u64x2 const v47 = { 47, 47 };
        xxh_u32x4 const prime = { XXH_PRIME32_1, XXH_PRIME32_1, XXH_PRIME32_1, XXH_PRIME32_1 };
        size_t i;
        for (i = 0; i < XXH_STRIPE_LEN / sizeof(xxh_u64x2); i++) {
            /* xacc[i] ^= (xacc[i] >> 47); */
            xxh_u64x2 const acc_vec  = xacc[i];
            xxh_u64x2 const data_vec = acc_vec ^ (acc_vec >> v47);

            /* xacc[i] ^= xsecret[i]; */
            xxh_u64x2 const key_vec  = XXH_vec_loadu(xsecret + i);
            xxh_u64x2 const data_key = data_vec ^ key_vec;

            /* xacc[i] *= XXH_PRIME32_1 */
            /* prod_lo = ((xxh_u64x2)data_key & 0xFFFFFFFF) * ((xxh_u64x2)prime & 0xFFFFFFFF);  */
            xxh_u64x2 const prod_even  = XXH_vec_mule((xxh_u32x4)data_key, prime);
            /* prod_hi = ((xxh_u64x2)data_key >> 32) * ((xxh_u64x2)prime >> 32);  */
            xxh_u64x2 const prod_odd  = XXH_vec_mulo((xxh_u32x4)data_key, prime);
            xacc[i] = prod_odd + (prod_even << v32);
    }   }
}

#endif // corresponds to #if (#if (XXH_VECTOR == XXH_VSX))

/* scalar variants - universal */

XXH_FORCE_INLINE void
XXH3_accumulate_512_scalar(void* XXH_RESTRICT acc,
                     const void* XXH_RESTRICT input,
                     const void* XXH_RESTRICT secret)
{
    XXH_ALIGN(XXH_ACC_ALIGN) xxh_u64* const xacc = (xxh_u64*) acc; /* presumed aligned */
    const xxh_u8* const xinput  = (const xxh_u8*) input;  /* no alignment restriction */
    const xxh_u8* const xsecret = (const xxh_u8*) secret;   /* no alignment restriction */
    size_t i;
    XXH_ASSERT(((size_t)acc & (XXH_ACC_ALIGN-1)) == 0);
    for (i=0; i < XXH_ACC_NB; i++) {
        xxh_u64 const data_val = XXH_readLE64(xinput + 8*i);
        xxh_u64 const data_key = data_val ^ XXH_readLE64(xsecret + i*8);
        xacc[i ^ 1] += data_val; /* swap adjacent lanes */
        xacc[i] += XXH_mult32to64(data_key & 0xFFFFFFFF, data_key >> 32);
    }
}

XXH_FORCE_INLINE void
XXH3_scrambleAcc_scalar(void* XXH_RESTRICT acc, const void* XXH_RESTRICT secret)
{
    XXH_ALIGN(XXH_ACC_ALIGN) xxh_u64* const xacc = (xxh_u64*) acc;   /* presumed aligned */
    const xxh_u8* const xsecret = (const xxh_u8*) secret;   /* no alignment restriction */
    size_t i;
    XXH_ASSERT((((size_t)acc) & (XXH_ACC_ALIGN-1)) == 0);
    for (i=0; i < XXH_ACC_NB; i++) {
        xxh_u64 const key64 = XXH_readLE64(xsecret + 8*i);
        xxh_u64 acc64 = xacc[i];
        acc64 = XXH_xorshift64(acc64, 47);
        acc64 ^= key64;
        acc64 *= XXH_PRIME32_1;
        xacc[i] = acc64;
    }
}



typedef void (*XXH3_f_accumulate_512)(void* XXH_RESTRICT, const void*, const void*);
typedef void (*XXH3_f_scrambleAcc)(void* XXH_RESTRICT, const void*);
typedef void (*XXH3_f_initCustomSecret)(void* XXH_RESTRICT, xxh_u64);


#if (XXH_VECTOR == XXH_AVX512)

#define XXH3_accumulate_512 XXH3_accumulate_512_avx512
#define XXH3_scrambleAcc    XXH3_scrambleAcc_avx512
#define XXH3_initCustomSecret XXH3_initCustomSecret_avx512

#elif (XXH_VECTOR == XXH_AVX2)

#define XXH3_accumulate_512 XXH3_accumulate_512_avx2
#define XXH3_scrambleAcc    XXH3_scrambleAcc_avx2
#define XXH3_initCustomSecret XXH3_initCustomSecret_avx2

#elif (XXH_VECTOR == XXH_SSE2)

#define XXH3_accumulate_512 XXH3_accumulate_512_sse2
#define XXH3_scrambleAcc    XXH3_scrambleAcc_sse2
#define XXH3_initCustomSecret XXH3_initCustomSecret_sse2

#elif (XXH_VECTOR == XXH_NEON)

#define XXH3_accumulate_512 XXH3_accumulate_512_neon
#define XXH3_scrambleAcc    XXH3_scrambleAcc_neon

#elif (XXH_VECTOR == XXH_VSX)

#define XXH3_accumulate_512 XXH3_accumulate_512_vsx
#define XXH3_scrambleAcc    XXH3_scrambleAcc_vsx

#else /* scalar */

#define XXH3_accumulate_512 XXH3_accumulate_512_scalar
#define XXH3_scrambleAcc    XXH3_scrambleAcc_scalar

#endif // corresponds to #if (#if (XXH_VECTOR == XXH_AVX512))



#ifndef XXH_PREFETCH_DIST
#  ifdef __clang__
#    define XXH_PREFETCH_DIST 320
#  else
#    if (XXH_VECTOR == XXH_AVX512)
#      define XXH_PREFETCH_DIST 512
#    else
#      define XXH_PREFETCH_DIST 384
#    endif
#  endif  /* __clang__ */
#endif  /* XXH_PREFETCH_DIST */ // corresponds to #ifndef (#ifndef XXH_PREFETCH_DIST)

/*
 * XXH3_accumulate()
 * Loops over XXH3_accumulate_512().
 * Assumption: nbStripes will not overflow the secret size
 */
XXH_FORCE_INLINE void
XXH3_accumulate(     xxh_u64* XXH_RESTRICT acc,
                const xxh_u8* XXH_RESTRICT input,
                const xxh_u8* XXH_RESTRICT secret,
                      size_t nbStripes,
                      XXH3_f_accumulate_512 f_acc512)
{
    size_t n;
    for (n = 0; n < nbStripes; n++ ) {
        const xxh_u8* const in = input + n*XXH_STRIPE_LEN;
        XXH_PREFETCH(in + XXH_PREFETCH_DIST);
        f_acc512(acc,
                 in,
                 secret + n*XXH_SECRET_CONSUME_RATE);
    }
}

XXH_FORCE_INLINE void
XXH3_hashLong_internal_loop(xxh_u64* XXH_RESTRICT acc,
                      const xxh_u8* XXH_RESTRICT input, size_t len,
                      const xxh_u8* XXH_RESTRICT secret, size_t secretSize,
                            XXH3_f_accumulate_512 f_acc512,
                            XXH3_f_scrambleAcc f_scramble)
{
    size_t const nbStripesPerBlock = (secretSize - XXH_STRIPE_LEN) / XXH_SECRET_CONSUME_RATE;
    size_t const block_len = XXH_STRIPE_LEN * nbStripesPerBlock;
    size_t const nb_blocks = (len - 1) / block_len;

    size_t n;

    XXH_ASSERT(secretSize >= XXH3_SECRET_SIZE_MIN);

    for (n = 0; n < nb_blocks; n++) {
        XXH3_accumulate(acc, input + n*block_len, secret, nbStripesPerBlock, f_acc512);
        f_scramble(acc, secret + secretSize - XXH_STRIPE_LEN);
    }

    /* last partial block */
    XXH_ASSERT(len > XXH_STRIPE_LEN);
    {   size_t const nbStripes = ((len - 1) - (block_len * nb_blocks)) / XXH_STRIPE_LEN;
        XXH_ASSERT(nbStripes <= (secretSize / XXH_SECRET_CONSUME_RATE));
        XXH3_accumulate(acc, input + nb_blocks*block_len, secret, nbStripes, f_acc512);

        /* last stripe */
        {   const xxh_u8* const p = input + len - XXH_STRIPE_LEN;
#define XXH_SECRET_LASTACC_START 7  /* not aligned on 8, last secret is different from acc & scrambler */
            f_acc512(acc, p, secret + secretSize - XXH_STRIPE_LEN - XXH_SECRET_LASTACC_START);
    }   }
}

XXH_FORCE_INLINE xxh_u64
XXH3_mix2Accs(const xxh_u64* XXH_RESTRICT acc, const xxh_u8* XXH_RESTRICT secret)
{
    return XXH3_mul128_fold64(
               acc[0] ^ XXH_readLE64(secret),
               acc[1] ^ XXH_readLE64(secret+8) );
}

static XXH64_hash_t
XXH3_mergeAccs(const xxh_u64* XXH_RESTRICT acc, const xxh_u8* XXH_RESTRICT secret, xxh_u64 start)
{
    xxh_u64 result64 = start;
    size_t i = 0;

    for (i = 0; i < 4; i++) {
        result64 += XXH3_mix2Accs(acc+2*i, secret + 16*i);
#if defined(__clang__)                                /* Clang */ \
    && (defined(__arm__) || defined(__thumb__))       /* ARMv7 */ \
    && (defined(__ARM_NEON) || defined(__ARM_NEON__)) /* NEON */  \
    && !defined(XXH_ENABLE_AUTOVECTORIZE)             /* Define to disable */
        /*
         * UGLY HACK:
         * Prevent autovectorization on Clang ARMv7-a. Exact same problem as
         * the one in XXH3_len_129to240_64b. Speeds up shorter keys > 240b.
         * XXH3_64bits, len == 256, Snapdragon 835:
         *   without hack: 2063.7 MB/s
         *   with hack:    2560.7 MB/s
         */
        __asm__("" : "+r" (result64));
#endif // corresponds to #if (#if defined(__clang__)                                /* Clang */ \)
    }

    return XXH3_avalanche(result64);
}

#define XXH3_INIT_ACC { XXH_PRIME32_3, XXH_PRIME64_1, XXH_PRIME64_2, XXH_PRIME64_3, \
                        XXH_PRIME64_4, XXH_PRIME32_2, XXH_PRIME64_5, XXH_PRIME32_1 }


#define XXH_SECRET_MERGEACCS_START 11

/*
 * It's important for performance that XXH3_hashLong is not inlined.
 */



typedef XXH64_hash_t (*XXH3_hashLong64_f)(const void* XXH_RESTRICT, size_t,
                                          XXH64_hash_t, const xxh_u8* XXH_RESTRICT, size_t);


/* ===   Public entry point   === */







static void
XXH3_64bits_reset_internal(XXH3_state_t* statePtr,
                           XXH64_hash_t seed,
                           const void* secret, size_t secretSize)
{
    size_t const initStart = offsetof(XXH3_state_t, bufferedSize);
    size_t const initLength = offsetof(XXH3_state_t, nbStripesPerBlock) - initStart;
    XXH_ASSERT(offsetof(XXH3_state_t, nbStripesPerBlock) > initStart);
    XXH_ASSERT(statePtr != NULL);
    /* set members from bufferedSize to nbStripesPerBlock (excluded) to 0 */
    memset((char*)statePtr + initStart, 0, initLength);
    statePtr->acc[0] = XXH_PRIME32_3;
    statePtr->acc[1] = XXH_PRIME64_1;
    statePtr->acc[2] = XXH_PRIME64_2;
    statePtr->acc[3] = XXH_PRIME64_3;
    statePtr->acc[4] = XXH_PRIME64_4;
    statePtr->acc[5] = XXH_PRIME32_2;
    statePtr->acc[6] = XXH_PRIME64_5;
    statePtr->acc[7] = XXH_PRIME32_1;
    statePtr->seed = seed;
    statePtr->extSecret = (const unsigned char*)secret;
    XXH_ASSERT(secretSize >= XXH3_SECRET_SIZE_MIN);
    statePtr->secretLimit = secretSize - XXH_STRIPE_LEN;
    statePtr->nbStripesPerBlock = statePtr->secretLimit / XXH_SECRET_CONSUME_RATE;
}






/* Note : when XXH3_consumeStripes() is invoked,
 * there must be a guarantee that at least one more byte must be consumed from input
 * so that the function can blindly consume all stripes using the "normal" secret segment */
XXH_FORCE_INLINE void
XXH3_consumeStripes(xxh_u64* XXH_RESTRICT acc,
                    size_t* XXH_RESTRICT nbStripesSoFarPtr, size_t nbStripesPerBlock,
                    const xxh_u8* XXH_RESTRICT input, size_t nbStripes,
                    const xxh_u8* XXH_RESTRICT secret, size_t secretLimit,
                    XXH3_f_accumulate_512 f_acc512,
                    XXH3_f_scrambleAcc f_scramble)
{
    XXH_ASSERT(nbStripes <= nbStripesPerBlock);  /* can handle max 1 scramble per invocation */
    XXH_ASSERT(*nbStripesSoFarPtr < nbStripesPerBlock);
    if (nbStripesPerBlock - *nbStripesSoFarPtr <= nbStripes) {
        /* need a scrambling operation */
        size_t const nbStripesToEndofBlock = nbStripesPerBlock - *nbStripesSoFarPtr;
        size_t const nbStripesAfterBlock = nbStripes - nbStripesToEndofBlock;
        XXH3_accumulate(acc, input, secret + nbStripesSoFarPtr[0] * XXH_SECRET_CONSUME_RATE, nbStripesToEndofBlock, f_acc512);
        f_scramble(acc, secret + secretLimit);
        XXH3_accumulate(acc, input + nbStripesToEndofBlock * XXH_STRIPE_LEN, secret, nbStripesAfterBlock, f_acc512);
        *nbStripesSoFarPtr = nbStripesAfterBlock;
    } else {
        XXH3_accumulate(acc, input, secret + nbStripesSoFarPtr[0] * XXH_SECRET_CONSUME_RATE, nbStripes, f_acc512);
        *nbStripesSoFarPtr += nbStripes;
    }
}

/*
 * Both XXH3_64bits_update and XXH3_128bits_update use this routine.
 */
XXH_FORCE_INLINE XXH_errorcode
XXH3_update(XXH3_state_t* state,
            const xxh_u8* input, size_t len,
            XXH3_f_accumulate_512 f_acc512,
            XXH3_f_scrambleAcc f_scramble)
{
    if (input==NULL)
#if defined(XXH_ACCEPT_NULL_INPUT_POINTER) && (XXH_ACCEPT_NULL_INPUT_POINTER>=1)
        return XXH_OK;
#else
        return XXH_ERROR;
#endif // corresponds to #if (#if defined(XXH_ACCEPT_NULL_INPUT_POINTER) && (XXH_ACCEPT_NULL_INPUT_POINTER>=1))

    {   const xxh_u8* const bEnd = input + len;
        const unsigned char* const secret = (state->extSecret == NULL) ? state->customSecret : state->extSecret;

        state->totalLen += len;

        if (state->bufferedSize + len <= XXH3_INTERNALBUFFER_SIZE) {  /* fill in tmp buffer */
            XXH_memcpy(state->buffer + state->bufferedSize, input, len);
            state->bufferedSize += (XXH32_hash_t)len;
            return XXH_OK;
        }
        /* total input is now > XXH3_INTERNALBUFFER_SIZE */

        #define XXH3_INTERNALBUFFER_STRIPES (XXH3_INTERNALBUFFER_SIZE / XXH_STRIPE_LEN)
        XXH_STATIC_ASSERT(XXH3_INTERNALBUFFER_SIZE % XXH_STRIPE_LEN == 0);   /* clean multiple */

        /*
         * Internal buffer is partially filled (always, except at beginning)
         * Complete it, then consume it.
         */
        if (state->bufferedSize) {
            size_t const loadSize = XXH3_INTERNALBUFFER_SIZE - state->bufferedSize;
            XXH_memcpy(state->buffer + state->bufferedSize, input, loadSize);
            input += loadSize;
            XXH3_consumeStripes(state->acc,
                               &state->nbStripesSoFar, state->nbStripesPerBlock,
                                state->buffer, XXH3_INTERNALBUFFER_STRIPES,
                                secret, state->secretLimit,
                                f_acc512, f_scramble);
            state->bufferedSize = 0;
        }
        XXH_ASSERT(input < bEnd);

        /* Consume input by a multiple of internal buffer size */
        if (input+XXH3_INTERNALBUFFER_SIZE < bEnd) {
            const xxh_u8* const limit = bEnd - XXH3_INTERNALBUFFER_SIZE;
            do {
                XXH3_consumeStripes(state->acc,
                                   &state->nbStripesSoFar, state->nbStripesPerBlock,
                                    input, XXH3_INTERNALBUFFER_STRIPES,
                                    secret, state->secretLimit,
                                    f_acc512, f_scramble);
                input += XXH3_INTERNALBUFFER_SIZE;
            } while (input<limit);
            /* for last partial stripe */
            memcpy(state->buffer + sizeof(state->buffer) - XXH_STRIPE_LEN, input - XXH_STRIPE_LEN, XXH_STRIPE_LEN);
        }
        XXH_ASSERT(input < bEnd);

        /* Some remaining input (always) : buffer it */
        XXH_memcpy(state->buffer, input, (size_t)(bEnd-input));
        state->bufferedSize = (XXH32_hash_t)(bEnd-input);
    }

    return XXH_OK;
}



XXH_FORCE_INLINE void
XXH3_digest_long (XXH64_hash_t* acc,
                  const XXH3_state_t* state,
                  const unsigned char* secret)
{
    /*
     * Digest on a local copy. This way, the state remains unaltered, and it can
     * continue ingesting more input afterwards.
     */
    memcpy(acc, state->acc, sizeof(state->acc));
    if (state->bufferedSize >= XXH_STRIPE_LEN) {
        size_t const nbStripes = (state->bufferedSize - 1) / XXH_STRIPE_LEN;
        size_t nbStripesSoFar = state->nbStripesSoFar;
        XXH3_consumeStripes(acc,
                           &nbStripesSoFar, state->nbStripesPerBlock,
                            state->buffer, nbStripes,
                            secret, state->secretLimit,
                            XXH3_accumulate_512, XXH3_scrambleAcc);
        /* last stripe */
        XXH3_accumulate_512(acc,
                            state->buffer + state->bufferedSize - XXH_STRIPE_LEN,
                            secret + state->secretLimit - XXH_SECRET_LASTACC_START);
    } else {  /* bufferedSize < XXH_STRIPE_LEN */
        xxh_u8 lastStripe[XXH_STRIPE_LEN];
        size_t const catchupSize = XXH_STRIPE_LEN - state->bufferedSize;
        XXH_ASSERT(state->bufferedSize > 0);  /* there is always some input buffered */
        memcpy(lastStripe, state->buffer + sizeof(state->buffer) - catchupSize, catchupSize);
        memcpy(lastStripe + catchupSize, state->buffer, state->bufferedSize);
        XXH3_accumulate_512(acc,
                            lastStripe,
                            secret + state->secretLimit - XXH_SECRET_LASTACC_START);
    }
}


#define XXH_MIN(x, y) (((x) > (y)) ? (y) : (x))



XXH_FORCE_INLINE XXH128_hash_t
XXH3_len_1to3_128b(const xxh_u8* input, size_t len, const xxh_u8* secret, XXH64_hash_t seed)
{
    /* A doubled version of 1to3_64b with different constants. */
    XXH_ASSERT(input != NULL);
    XXH_ASSERT(1 <= len && len <= 3);
    XXH_ASSERT(secret != NULL);
    /*
     * len = 1: combinedl = { input[0], 0x01, input[0], input[0] }
     * len = 2: combinedl = { input[1], 0x02, input[0], input[1] }
     * len = 3: combinedl = { input[2], 0x03, input[0], input[1] }
     */
    {   xxh_u8 const c1 = input[0];
        xxh_u8 const c2 = input[len >> 1];
        xxh_u8 const c3 = input[len - 1];
        xxh_u32 const combinedl = ((xxh_u32)c1 <<16) | ((xxh_u32)c2 << 24)
                                | ((xxh_u32)c3 << 0) | ((xxh_u32)len << 8);
        xxh_u32 const combinedh = XXH_rotl32(XXH_swap32(combinedl), 13);
        xxh_u64 const bitflipl = (XXH_readLE32(secret) ^ XXH_readLE32(secret+4)) + seed;
        xxh_u64 const bitfliph = (XXH_readLE32(secret+8) ^ XXH_readLE32(secret+12)) - seed;
        xxh_u64 const keyed_lo = (xxh_u64)combinedl ^ bitflipl;
        xxh_u64 const keyed_hi = (xxh_u64)combinedh ^ bitfliph;
        XXH128_hash_t h128;
        h128.low64  = XXH64_avalanche(keyed_lo);
        h128.high64 = XXH64_avalanche(keyed_hi);
        return h128;
    }
}

XXH_FORCE_INLINE XXH128_hash_t
XXH3_len_4to8_128b(const xxh_u8* input, size_t len, const xxh_u8* secret, XXH64_hash_t seed)
{
    XXH_ASSERT(input != NULL);
    XXH_ASSERT(secret != NULL);
    XXH_ASSERT(4 <= len && len <= 8);
    seed ^= (xxh_u64)XXH_swap32((xxh_u32)seed) << 32;
    {   xxh_u32 const input_lo = XXH_readLE32(input);
        xxh_u32 const input_hi = XXH_readLE32(input + len - 4);
        xxh_u64 const input_64 = input_lo + ((xxh_u64)input_hi << 32);
        xxh_u64 const bitflip = (XXH_readLE64(secret+16) ^ XXH_readLE64(secret+24)) + seed;
        xxh_u64 const keyed = input_64 ^ bitflip;

        /* Shift len to the left to ensure it is even, this avoids even multiplies. */
        XXH128_hash_t m128 = XXH_mult64to128(keyed, XXH_PRIME64_1 + (len << 2));

        m128.high64 += (m128.low64 << 1);
        m128.low64  ^= (m128.high64 >> 3);

        m128.low64   = XXH_xorshift64(m128.low64, 35);
        m128.low64  *= 0x9FB21C651E98DF25ULL;
        m128.low64   = XXH_xorshift64(m128.low64, 28);
        m128.high64  = XXH3_avalanche(m128.high64);
        return m128;
    }
}

XXH_FORCE_INLINE XXH128_hash_t
XXH3_len_9to16_128b(const xxh_u8* input, size_t len, const xxh_u8* secret, XXH64_hash_t seed)
{
    XXH_ASSERT(input != NULL);
    XXH_ASSERT(secret != NULL);
    XXH_ASSERT(9 <= len && len <= 16);
    {   xxh_u64 const bitflipl = (XXH_readLE64(secret+32) ^ XXH_readLE64(secret+40)) - seed;
        xxh_u64 const bitfliph = (XXH_readLE64(secret+48) ^ XXH_readLE64(secret+56)) + seed;
        xxh_u64 const input_lo = XXH_readLE64(input);
        xxh_u64       input_hi = XXH_readLE64(input + len - 8);
        XXH128_hash_t m128 = XXH_mult64to128(input_lo ^ input_hi ^ bitflipl, XXH_PRIME64_1);
        /*
         * Put len in the middle of m128 to ensure that the length gets mixed to
         * both the low and high bits in the 128x64 multiply below.
         */
        m128.low64 += (xxh_u64)(len - 1) << 54;
        input_hi   ^= bitfliph;
        /*
         * Add the high 32 bits of input_hi to the high 32 bits of m128, then
         * add the long product of the low 32 bits of input_hi and XXH_PRIME32_2 to
         * the high 64 bits of m128.
         *
         * The best approach to this operation is different on 32-bit and 64-bit.
         */
        if (sizeof(void *) < sizeof(xxh_u64)) { /* 32-bit */
            /*
             * 32-bit optimized version, which is more readable.
             *
             * On 32-bit, it removes an ADC and delays a dependency between the two
             * halves of m128.high64, but it generates an extra mask on 64-bit.
             */
            m128.high64 += (input_hi & 0xFFFFFFFF00000000ULL) + XXH_mult32to64((xxh_u32)input_hi, XXH_PRIME32_2);
        } else {
            m128.high64 += input_hi + XXH_mult32to64((xxh_u32)input_hi, XXH_PRIME32_2 - 1);
        }
        /* m128 ^= XXH_swap64(m128 >> 64); */
        m128.low64  ^= XXH_swap64(m128.high64);

        {   /* 128x64 multiply: h128 = m128 * XXH_PRIME64_2; */
            XXH128_hash_t h128 = XXH_mult64to128(m128.low64, XXH_PRIME64_2);
            h128.high64 += m128.high64 * XXH_PRIME64_2;

            h128.low64   = XXH3_avalanche(h128.low64);
            h128.high64  = XXH3_avalanche(h128.high64);
            return h128;
    }   }
}

/*
 * Assumption: `secret` size is >= XXH3_SECRET_SIZE_MIN
 */
XXH_FORCE_INLINE XXH128_hash_t
XXH3_len_0to16_128b(const xxh_u8* input, size_t len, const xxh_u8* secret, XXH64_hash_t seed)
{
    XXH_ASSERT(len <= 16);
    {   if (len > 8) return XXH3_len_9to16_128b(input, len, secret, seed);
        if (len >= 4) return XXH3_len_4to8_128b(input, len, secret, seed);
        if (len) return XXH3_len_1to3_128b(input, len, secret, seed);
        {   XXH128_hash_t h128;
            xxh_u64 const bitflipl = XXH_readLE64(secret+64) ^ XXH_readLE64(secret+72);
            xxh_u64 const bitfliph = XXH_readLE64(secret+80) ^ XXH_readLE64(secret+88);
            h128.low64 = XXH64_avalanche(seed ^ bitflipl);
            h128.high64 = XXH64_avalanche( seed ^ bitfliph);
            return h128;
    }   }
}

/*
 * A bit slower than XXH3_mix16B, but handles multiply by zero better.
 */
XXH_FORCE_INLINE XXH128_hash_t
XXH128_mix32B(XXH128_hash_t acc, const xxh_u8* input_1, const xxh_u8* input_2,
              const xxh_u8* secret, XXH64_hash_t seed)
{
    acc.low64  += XXH3_mix16B (input_1, secret+0, seed);
    acc.low64  ^= XXH_readLE64(input_2) + XXH_readLE64(input_2 + 8);
    acc.high64 += XXH3_mix16B (input_2, secret+16, seed);
    acc.high64 ^= XXH_readLE64(input_1) + XXH_readLE64(input_1 + 8);
    return acc;
}


XXH_FORCE_INLINE XXH128_hash_t
XXH3_len_17to128_128b(const xxh_u8* XXH_RESTRICT input, size_t len,
                      const xxh_u8* XXH_RESTRICT secret, size_t secretSize,
                      XXH64_hash_t seed)
{
    XXH_ASSERT(secretSize >= XXH3_SECRET_SIZE_MIN); (void)secretSize;
    XXH_ASSERT(16 < len && len <= 128);

    {   XXH128_hash_t acc;
        acc.low64 = len * XXH_PRIME64_1;
        acc.high64 = 0;
        if (len > 32) {
            if (len > 64) {
                if (len > 96) {
                    acc = XXH128_mix32B(acc, input+48, input+len-64, secret+96, seed);
                }
                acc = XXH128_mix32B(acc, input+32, input+len-48, secret+64, seed);
            }
            acc = XXH128_mix32B(acc, input+16, input+len-32, secret+32, seed);
        }
        acc = XXH128_mix32B(acc, input, input+len-16, secret, seed);
        {   XXH128_hash_t h128;
            h128.low64  = acc.low64 + acc.high64;
            h128.high64 = (acc.low64    * XXH_PRIME64_1)
                        + (acc.high64   * XXH_PRIME64_4)
                        + ((len - seed) * XXH_PRIME64_2);
            h128.low64  = XXH3_avalanche(h128.low64);
            h128.high64 = (XXH64_hash_t)0 - XXH3_avalanche(h128.high64);
            return h128;
        }
    }
}

XXH_NO_INLINE XXH128_hash_t
XXH3_len_129to240_128b(const xxh_u8* XXH_RESTRICT input, size_t len,
                       const xxh_u8* XXH_RESTRICT secret, size_t secretSize,
                       XXH64_hash_t seed)
{
    XXH_ASSERT(secretSize >= XXH3_SECRET_SIZE_MIN); (void)secretSize;
    XXH_ASSERT(128 < len && len <= XXH3_MIDSIZE_MAX);

    {   XXH128_hash_t acc;
        int const nbRounds = (int)len / 32;
        int i;
        acc.low64 = len * XXH_PRIME64_1;
        acc.high64 = 0;
        for (i=0; i<4; i++) {
            acc = XXH128_mix32B(acc,
                                input  + (32 * i),
                                input  + (32 * i) + 16,
                                secret + (32 * i),
                                seed);
        }
        acc.low64 = XXH3_avalanche(acc.low64);
        acc.high64 = XXH3_avalanche(acc.high64);
        XXH_ASSERT(nbRounds >= 4);
        for (i=4 ; i < nbRounds; i++) {
            acc = XXH128_mix32B(acc,
                                input + (32 * i),
                                input + (32 * i) + 16,
                                secret + XXH3_MIDSIZE_STARTOFFSET + (32 * (i - 4)),
                                seed);
        }
        /* last bytes */
        acc = XXH128_mix32B(acc,
                            input + len - 16,
                            input + len - 32,
                            secret + XXH3_SECRET_SIZE_MIN - XXH3_MIDSIZE_LASTOFFSET - 16,
                            0ULL - seed);

        {   XXH128_hash_t h128;
            h128.low64  = acc.low64 + acc.high64;
            h128.high64 = (acc.low64    * XXH_PRIME64_1)
                        + (acc.high64   * XXH_PRIME64_4)
                        + ((len - seed) * XXH_PRIME64_2);
            h128.low64  = XXH3_avalanche(h128.low64);
            h128.high64 = (XXH64_hash_t)0 - XXH3_avalanche(h128.high64);
            return h128;
        }
    }
}

XXH_FORCE_INLINE XXH128_hash_t
XXH3_hashLong_128b_internal(const void* XXH_RESTRICT input, size_t len,
                            const xxh_u8* XXH_RESTRICT secret, size_t secretSize,
                            XXH3_f_accumulate_512 f_acc512,
                            XXH3_f_scrambleAcc f_scramble)
{
    XXH_ALIGN(XXH_ACC_ALIGN) xxh_u64 acc[XXH_ACC_NB] = XXH3_INIT_ACC;

    XXH3_hashLong_internal_loop(acc, (const xxh_u8*)input, len, secret, secretSize, f_acc512, f_scramble);

    /* converge into final hash */
    XXH_STATIC_ASSERT(sizeof(acc) == 64);
    XXH_ASSERT(secretSize >= sizeof(acc) + XXH_SECRET_MERGEACCS_START);
    {   XXH128_hash_t h128;
        h128.low64  = XXH3_mergeAccs(acc,
                                     secret + XXH_SECRET_MERGEACCS_START,
                                     (xxh_u64)len * XXH_PRIME64_1);
        h128.high64 = XXH3_mergeAccs(acc,
                                     secret + secretSize
                                            - sizeof(acc) - XXH_SECRET_MERGEACCS_START,
                                     ~((xxh_u64)len * XXH_PRIME64_2));
        return h128;
    }
}


/*
 * It's important for performance that XXH3_hashLong is not inlined.
 */
XXH_NO_INLINE XXH128_hash_t
XXH3_hashLong_128b_withSecret(const void* XXH_RESTRICT input, size_t len,
                              XXH64_hash_t seed64,
                              const void* XXH_RESTRICT secret, size_t secretLen)
{
    (void)seed64;
    return XXH3_hashLong_128b_internal(input, len, (const xxh_u8*)secret, secretLen,
                                       XXH3_accumulate_512, XXH3_scrambleAcc);
}


/*
 * It's important for performance that XXH3_hashLong is not inlined.
 */

typedef XXH128_hash_t (*XXH3_hashLong128_f)(const void* XXH_RESTRICT, size_t,
                                            XXH64_hash_t, const void* XXH_RESTRICT, size_t);

XXH_FORCE_INLINE XXH128_hash_t
XXH3_128bits_internal(const void* input, size_t len,
                      XXH64_hash_t seed64, const void* XXH_RESTRICT secret, size_t secretLen,
                      XXH3_hashLong128_f f_hl128)
{
    XXH_ASSERT(secretLen >= XXH3_SECRET_SIZE_MIN);
    /*
     * If an action is to be taken if `secret` conditions are not respected,
     * it should be done here.
     * For now, it's a contract pre-condition.
     * Adding a check and a branch here would cost performance at every hash.
     */
    if (len <= 16)
        return XXH3_len_0to16_128b((const xxh_u8*)input, len, (const xxh_u8*)secret, seed64);
    if (len <= 128)
        return XXH3_len_17to128_128b((const xxh_u8*)input, len, (const xxh_u8*)secret, secretLen, seed64);
    if (len <= XXH3_MIDSIZE_MAX)
        return XXH3_len_129to240_128b((const xxh_u8*)input, len, (const xxh_u8*)secret, secretLen, seed64);
    return f_hl128(input, len, seed64, secret, secretLen);
}


/* ===   Public XXH128 API   === */



XXH128_hash_t
XXH3_128bits_withSecret(const void* input, size_t len, const void* secret, size_t secretSize)
{
   return XXH3_128bits_internal(input, len, 0,
                                 (const xxh_u8*)secret, secretSize,
                                 XXH3_hashLong_128b_withSecret);
}



/* ===   XXH3 128-bit streaming   === */

/*
 * All the functions are actually the same as for 64-bit streaming variant.
 * The only difference is the finalizatiom routine.
 */

static void
XXH3_128bits_reset_internal(XXH3_state_t* statePtr,
                            XXH64_hash_t seed,
                            const void* secret, size_t secretSize)
{
    XXH3_64bits_reset_internal(statePtr, seed, secret, secretSize);
}

XXH_errorcode
XXH3_128bits_reset(XXH3_state_t* statePtr)
{
    if (statePtr == NULL) return XXH_ERROR;
    XXH3_128bits_reset_internal(statePtr, 0, XXH3_kSecret, XXH_SECRET_DEFAULT_SIZE);
    return XXH_OK;
}

XXH_errorcode
XXH3_128bits_update(XXH3_state_t* state, const void* input, size_t len)
{
    return XXH3_update(state, (const xxh_u8*)input, len,
                       XXH3_accumulate_512, XXH3_scrambleAcc);
}

XXH128_hash_t XXH3_128bits_digest (const XXH3_state_t* state)
{
    const unsigned char* const secret = (state->extSecret == NULL) ? state->customSecret : state->extSecret;
    if (state->totalLen > XXH3_MIDSIZE_MAX) {
        XXH_ALIGN(XXH_ACC_ALIGN) XXH64_hash_t acc[XXH_ACC_NB];
        XXH3_digest_long(acc, state, secret);
        XXH_ASSERT(state->secretLimit + XXH_STRIPE_LEN >= sizeof(acc) + XXH_SECRET_MERGEACCS_START);
        {   XXH128_hash_t h128;
            h128.low64  = XXH3_mergeAccs(acc,
                                         secret + XXH_SECRET_MERGEACCS_START,
                                         (xxh_u64)state->totalLen * XXH_PRIME64_1);
            h128.high64 = XXH3_mergeAccs(acc,
                                         secret + state->secretLimit + XXH_STRIPE_LEN
                                                - sizeof(acc) - XXH_SECRET_MERGEACCS_START,
                                         ~((xxh_u64)state->totalLen * XXH_PRIME64_2));
            return h128;
        }
    }
    /* len <= XXH3_MIDSIZE_MAX : short code */
    if (state->seed)
	{
		myprintf("00010! GURU XXH NO SEED!\n");
		seppuku();
	}
    return XXH3_128bits_withSecret(state->buffer, (size_t)(state->totalLen),
                                   secret, state->secretLimit + XXH_STRIPE_LEN);
}

/* 128-bit utility functions */


/*======   Canonical representation   ======*/

/* Pop our optimization override from above */
#if XXH_VECTOR == XXH_AVX2 /* AVX2 */ \
  && defined(__GNUC__) && !defined(__clang__) /* GCC, not Clang */ \
  && defined(__OPTIMIZE__) && !defined(__OPTIMIZE_SIZE__) /* respect -O0 and -Os */
#  pragma GCC pop_options
#endif // corresponds to #if (#if XXH_VECTOR == XXH_AVX2 /* AVX2 */ \)

/// LICENSE_END.14


/// incapsulate Yann's xxhash like Brumme's (not BIG ENDIAN compatible)
class XXHash64
{
public:
	explicit XXHash64(uint64_t seed)
	{
		XXH64_hash_t seme=seed;
		state = XXH64_createState();
		assert(state != NULL && "Out of memory!");
		XXH64_reset(state,seme);
	}
	bool add(const void* input, uint64_t length)
	{
		if (!input || length == 0)
			return false;
		XXH64_update(state, input,length);
        return true;
	}
	uint64_t hash() const
	{
		return XXH64_digest(state);
	}
	string getHash()
	{
		return bin2hex_64(XXH64_digest(state));
	}
	~XXHash64()
    {
		
        if (state != NULL)
        {
			///myprintf("23865: DESTROY XXHASH64\n");
            franz_free(state);
            state=NULL;
        }
    }


private:
	XXH64_state_t*	state;
};



XXHash64 	g_franzhash_file(0);
int64_t  	g_franzhash_file_bytes=0;
XXHash64 	g_franzhash_index(0);
char		g_franzhash_104[104];

int b64invs[] = { 62, -1, -1, -1, 63, 52, 53, 54, 55, 56, 57, 58,
	59, 60, 61, -1, -1, -1, -1, -1, -1, -1, 0, 1, 2, 3, 4, 5,
	6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20,
	21, 22, 23, 24, 25, -1, -1, -1, -1, -1, -1, 26, 27, 28,
	29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42,
	43, 44, 45, 46, 47, 48, 49, 50, 51 };
int ismime(char i_c)
{
	if ((i_c>='0') && (i_c<='9'))
		return 1;
	if ((i_c >='A') && (i_c<='Z'))
		return 1;
	if ((i_c>='a') && (i_c <= 'z'))
		return 1;
	if ((i_c=='+') || (i_c=='/') || (i_c =='='))
		return 1;
	return 0;
}
size_t mimesize(const char *i_input)
{
	if (i_input==NULL)
		return 0;
	size_t len;
	size_t ret;
	size_t i;
	len=strlen(i_input); // risky!
	ret=len/4*3;
	for (i=len; i-->0;)
		if (i_input[i] == '=')
			ret--;
		else
			break;
	return ret;
}
int mime2binary(const char *i_in, unsigned char *o_out, size_t outlen)
{
	if (i_in==NULL)
		return 0;
	if (o_out==NULL)
		return 0;
	size_t lunghezza=strlen(i_in);
	if ((outlen<mimesize(i_in)) || (lunghezza % 4 != 0))
		return 0;
	for (unsigned int i=0; i<lunghezza; i++)
		if (!ismime(i_in[i]))
			return 0;
	size_t i;
	size_t j;
	int    temp;
	for (i=0,j=0;i<lunghezza;i+=4,j+=3)
	{
		temp= b64invs[i_in[i]-43];
		temp= (temp << 6) | b64invs[i_in[i+1]-43];
		temp= i_in[i+2]=='=' ? temp << 6 : (temp << 6) | b64invs[i_in[i+2]-43];
		temp= i_in[i+3]=='=' ? temp << 6 : (temp << 6) | b64invs[i_in[i+3]-43];
		o_out[j] = (temp >> 16) & 0xFF;
		if (i_in[i+2] != '=')
			o_out[j+1] = (temp >> 8) & 0xFF;
		if (i_in[i+3] != '=')
			o_out[j+2] = temp & 0xFF;
	}
	return 1;
}


// Handle errors in libzpaq and elsewhere
void libzpaq::error(const char* msg) {
	g_exec_text=msg;
  if (strstr(msg, "ut of memory")) throw std::bad_alloc();
  throw std::runtime_error(msg);
}
using libzpaq::error;
// Portable thread types and functions for Windows and Linux. Use like this:
//
// // Create mutex for locking thread-unsafe code
// Mutex mutex;            // shared by all threads
// init_mutex(mutex);      // initialize in unlocked state
// Semaphore sem(n);       // n >= 0 is initial state
//
// // Declare a thread function
// ThreadReturn thread(void *arg) {  // arg points to in/out parameters
//   lock(mutex);          // wait if another thread has it first
//   release(mutex);       // allow another waiting thread to continue
//   sem.wait();           // wait until n>0, then --n
//   sem.signal();         // ++n to allow waiting threads to continue
//   return 0;             // must return 0 to exit thread
// }
//
// // Start a thread
// ThreadID tid;
// run(tid, thread, &arg); // runs in parallel
// join(tid);              // wait for thread to return
// destroy_mutex(mutex);   // deallocate resources used by mutex
// sem.destroy();          // deallocate resources used by semaphore
#ifdef unix
typedef void* ThreadReturn;                                // job return type
typedef pthread_t ThreadID;                                // job ID type
void run(ThreadID& tid, ThreadReturn(*f)(void*), void* arg)// start job
  {pthread_create(&tid, NULL, f, arg);}
void join(ThreadID tid) {pthread_join(tid, NULL);}         // wait for job
typedef pthread_mutex_t Mutex;                             // mutex type
void init_mutex(Mutex& m) {pthread_mutex_init(&m, 0);}     // init mutex
void lock(Mutex& m) {pthread_mutex_lock(&m);}              // wait for mutex
void release(Mutex& m) {pthread_mutex_unlock(&m);}         // release mutex
void destroy_mutex(Mutex& m) {pthread_mutex_destroy(&m);}  // destroy mutex
class Semaphore {
public:
  Semaphore() {sem=-1;}
  void init(int n) {
    assert(n>=0);
    assert(sem==-1);
    pthread_cond_init(&cv, 0);
    pthread_mutex_init(&mutex, 0);
    sem=n;
  }
  void destroy() {
    assert(sem>=0);
    pthread_mutex_destroy(&mutex);
    pthread_cond_destroy(&cv);
  }
  int wait() {
    assert(sem>=0);
    pthread_mutex_lock(&mutex);
    int r=0;
    if (sem==0) r=pthread_cond_wait(&cv, &mutex);
    assert(sem>0);
    --sem;
    pthread_mutex_unlock(&mutex);
    return r;
  }
  void signal() {
    assert(sem>=0);
    pthread_mutex_lock(&mutex);
    ++sem;
    pthread_cond_signal(&cv);
    pthread_mutex_unlock(&mutex);
  }
private:
  pthread_cond_t cv;  // to signal FINISHED
  pthread_mutex_t mutex; // protects cv
  int sem;  // semaphore count
};

#else  // Windows
typedef DWORD ThreadReturn;
typedef HANDLE ThreadID;
void run(ThreadID& tid, ThreadReturn(*f)(void*), void* arg) {
  tid=CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)f, arg, 0, NULL);
  if (tid==NULL) error("CreateThread failed");
}
void join(ThreadID& tid) {WaitForSingleObject(tid, INFINITE);}
typedef HANDLE Mutex;
void init_mutex(Mutex& m) {m=CreateMutex(NULL, FALSE, NULL);}
void lock(Mutex& m) {WaitForSingleObject(m, INFINITE);}
void release(Mutex& m) {ReleaseMutex(m);}
void destroy_mutex(Mutex& m) {CloseHandle(m);}
class Semaphore {
public:
  enum {MAXCOUNT=2000000000};
  Semaphore(): h(NULL) {}
  void init(int n) {assert(!h); h=CreateSemaphore(NULL, n, MAXCOUNT, NULL);}
  void destroy() {assert(h); CloseHandle(h);}
  int wait() {assert(h); return WaitForSingleObject(h, INFINITE);}
  void signal() {assert(h); ReleaseSemaphore(h, 1, NULL);}
private:
  HANDLE h;  // Windows semaphore
};
#endif // corresponds to #ifdef (#ifdef unix)

string stringtolower(string i_stringa)
{
	for (unsigned int i=0;i<i_stringa.size();i++)
		i_stringa[i]=tolower(i_stringa[i]);
	return i_stringa;
}

string decode_command(const char i_command)
{
	if (i_command=='a')
		return "add (updating/creating archive)";
	else
	if (i_command=='Z')
		return "backup command is running";
#ifdef ZPAQFULL ///NOSFTPSTART
	else
	if (i_command=='A')
		return "zfsadd";
	else
	if (i_command=='$')
		return "zfsbackup";
	else
	if (i_command=='=')
		return "zfsproxbackup";
#endif ///NOSFTPEND
	else
		return "";
}


bool theonlyone(const char i_command,string i_archive)
{
#ifdef unix
	return true;
#endif // corresponds to #ifdef (#ifdef unix)


	if (i_archive=="")
		return true;
	
	string decodedcommand=decode_command(i_command);
	if (decodedcommand=="")
		return true;
#ifdef _WIN32
	i_archive=stringtolower(i_archive);
#endif // corresponds to #ifdef (#ifdef _WIN32)

	uint64_t myseed = 0;
	XXHash64 myhash(myseed);
	myhash.add(i_archive.c_str(),i_archive.size());
	string hashato=bin2hex_64(myhash.hash());

#ifdef _WIN32
	std::wstring baseName = L"Global\\ZPAQFRANZ_";
	std::wstring hashWstr(hashato.begin(), hashato.end());
	std::wstring eventName = baseName + hashWstr;
	HANDLE myevent=CreateEventW(NULL,FALSE,FALSE,eventName.c_str());
	if(myevent==NULL)
	{
		CloseHandle(myevent); 
		return false;
	}
	if (GetLastError()==ERROR_ALREADY_EXISTS) 
	{
		CloseHandle(myevent); 
		myprintf("17264$ Running %s on (%s) <<%Z>>\n",decodedcommand.c_str(),hashato.c_str(),i_archive.c_str());
		myprintf("17276! Sorry, another zpaqfranz is running, we need to abort\n");
		exit(0);
		return false;
	}
#endif // corresponds to #ifdef (#ifdef _WIN32)
	return true;
}



#ifdef _WIN32
int64_t mtime()
{
  int64_t t=GetTickCount();
  if (t<g_start) t+=0x100000000LL;
  return t;
}

#ifdef _WIN32
HRESULT ModifyPrivilege(
    IN LPCTSTR szPrivilege,
    IN BOOL fEnable)
{
    HRESULT hr = S_OK;
    TOKEN_PRIVILEGES NewState;
    LUID             luid;
    HANDLE hToken    = NULL;
    if (!OpenProcessToken(GetCurrentProcess(),
                          TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
                          &hToken ))
    {
        myprintf("00011! Failed OpenProcessToken\n");
        return ERROR_FUNCTION_FAILED;
    }
    if ( !LookupPrivilegeValue( NULL,
                                szPrivilege,
                                &luid ))
    {
        CloseHandle( hToken );
        myprintf("00012!		Failed LookupPrivilegeValue\n");
        return ERROR_FUNCTION_FAILED;
    }
    NewState.PrivilegeCount = 1;
    NewState.Privileges[0].Luid = luid;
    NewState.Privileges[0].Attributes =
              (fEnable ? SE_PRIVILEGE_ENABLED : 0);
    if (!AdjustTokenPrivileges(hToken,
                               FALSE,
                               &NewState,
                               0,
                               NULL,
                               NULL))
    {
        myprintf("00013! Failed AdjustTokenPrivileges\n");
        hr = ERROR_FUNCTION_FAILED;
    }
    CloseHandle(hToken);
    return hr;
}
/* NTFS reparse point definitions */
/* Constants from http://msdn.microsoft.com/en-us/library/dd541667.aspx */
/* Some, but not all, of them also defined in recent versions of winnt.h. */
/* All seem to come from NT DDK's ntifs.h, for installable file system drivers. */
/* Since the list varies a lot, redefine them one by one as needed */
/* Bit 31 = Tag owned by Microsoft
   Bit 30 = Reserved for Microsoft. Must be 0 for non-MS tags.
   Bit 29 = Surrogate bit. Points to another file of directory.
   Bit 28 = Directory bit. Any directory with this reparse tag can have children.
   Bits 16-27: Invalid and must be 0. */
/* Reparse tags, with the exception of IO_REPARSE_TAG_SYMLINK,
   are processed on the server and are not processed by a client after transmission over the wire. */
/* See https://github.com/prsyahmi/GpuRamDrive/blob/master/GpuRamDrive/3rdparty/inc/imdisk/ntumapi.h
   for a list of non-Microsoft reparse tags */
typedef struct _REPARSE_SYMLINK_READ_BUFFER { // For tag IO_REPARSE_TAG_SYMLINK
  DWORD  ReparseTag;
  WORD   ReparseDataLength;
  WORD   Reserved;
  WORD   SubstituteNameOffset;
  WORD   SubstituteNameLength;
  WORD   PrintNameOffset;
  WORD   PrintNameLength;
  ULONG  Flags;
  WCHAR  PathBuffer[1];
} SYMLINK_READ_BUFFER, *PSYMLINK_READ_BUFFER;
typedef struct _REPARSE_MOUNTPOINT_READ_BUFFER { // For tag IO_REPARSE_TAG_MOUNT_POINT, aka. junctions
  DWORD  ReparseTag;
  WORD   ReparseDataLength;
  WORD   Reserved;
  WORD   SubstituteNameOffset;
  WORD   SubstituteNameLength;
  WORD   PrintNameOffset;
  WORD   PrintNameLength;
  WCHAR  PathBuffer[1];
} MOUNTPOINT_READ_BUFFER, *PMOUNTPOINT_READ_BUFFER;
typedef struct _REPARSE_MOUNTPOINT_WRITE_BUFFER {
  DWORD  ReparseTag;
  DWORD  ReparseDataLength;
  WORD   Reserved;
  WORD   ReparseTargetLength;
  WORD   ReparseTargetMaximumLength;
  WORD   Reserved1;
  WCHAR  ReparseTarget[1];
} MOUNTPOINT_WRITE_BUFFER, *PMOUNTPOINT_WRITE_BUFFER;
// Universal Windows Platform (UWP) Application Execution Links
// Ref: https://www.tiraniddo.dev/2019/09/overview-of-windows-execution-aliases.html
typedef struct _REPARSE_APPEXECLINK_READ_BUFFER { // For tag IO_REPARSE_TAG_APPEXECLINK
  DWORD  ReparseTag;
  WORD   ReparseDataLength;
  WORD   Reserved;
  ULONG  Version;	// Currently version 3
  WCHAR  StringList[1];	// Multistring (Consecutive strings each ending with a NUL)
  /* There are normally 4 strings here. Ex:
	Package ID:	L"Microsoft.WindowsTerminal_8wekyb3d8bbwe"
	Entry Point:	L"Microsoft.WindowsTerminal_8wekyb3d8bbwe!App"
	Executable:	L"C:\Program Files\WindowsApps\Microsoft.WindowsTerminal_1.4.3243.0_x64__8wekyb3d8bbwe\wt.exe"
	Applic. Type:	l"0"	// Integer as ASCII. "0" = Desktop bridge application; Else sandboxed UWP application
  */
} APPEXECLINK_READ_BUFFER, *PAPPEXECLINK_READ_BUFFER;
// LinuX Sub-System (LXSS) Symbolic Links
typedef struct _REPARSE_LX_SYMLINK_BUFFER {
  DWORD  ReparseTag;
  WORD	 ReparseDataLength;
  WORD	 Reserved;
  DWORD  FileType; 	// Value is apparently always 2 for symlinks.
  char   PathBuffer[1];	// POSIX path of symlink. UTF-8. Not \0 terminated.
} LX_SYMLINK_READ_BUFFER, *PLX_SYMLINK_READ_BUFFER;
#endif // corresponds to #ifdef (#ifdef _WIN32)

	#ifndef ENABLE_VIRTUAL_TERMINAL_PROCESSING
		#define ENABLE_VIRTUAL_TERMINAL_PROCESSING  0x0004
	#endif // corresponds to #ifndef (#ifndef ENABLE_VIRTUAL_TERMINAL_PROCESSING)
static HANDLE stdoutHandle;
static DWORD outModeInit;
void setupConsole(void)
{
	if (flagnoconsole)
		return;
	DWORD outMode 	= 0;
	stdoutHandle 	= GetStdHandle(STD_OUTPUT_HANDLE);
	if(stdoutHandle == INVALID_HANDLE_VALUE)
		exit(GetLastError());
	if(!GetConsoleMode(stdoutHandle, &outMode))
		exit(GetLastError());
	outModeInit = outMode;
	outMode |= ENABLE_VIRTUAL_TERMINAL_PROCESSING;
	if(!SetConsoleMode(stdoutHandle, outMode))
		exit(GetLastError());
}
void restoreConsole(void)
{
	if (flagnoconsole)
		return;
	if (flagsilent)
		return;
	printf("\x1b[0m");
	if(!SetConsoleMode(stdoutHandle, outModeInit))
		exit(GetLastError());
}
// In Windows, convert 16-bit wide string to UTF-8 and \ to /
bool windows7_or_above=false; //windows version (for using FindFirstFileExW)
string wtou(const wchar_t* s) {
  assert(sizeof(wchar_t)==2);  // Not true in Linux
  assert((wchar_t)(-1)==65535);
  string r;
  if (!s) return r;
  for (; *s; ++s) {
    if (*s=='\\') r+='/';
    else if (*s<128) r+=*s;
    else if (*s<2048) r+=192+*s/64, r+=128+*s%64;
    else r+=224+*s/4096, r+=128+*s/64%64, r+=128+*s%64;
  }
  return r;
}
/*
string get_good_filename(string i_filename) 
{
	WIN32_FIND_DATA ffd;
	if ( (i_filename.size()>0) && (isdirectory(i_filename)))
	i_filename+="/";
	
	HANDLE h=FindFirstFile(utow(i_filename.c_str()).c_str(), &ffd);
	if (h!=INVALID_HANDLE_VALUE)
	{
		string kz=wtou(ffd.cFileName);
		myprintf("kkkkk %s\n",kz.c_str());
		FindClose(h);
		return wtou(ffd.cFileName);
	}
	return i_filename;
}
*/
string win_getcomputername()
{
	wchar_t buffer[256];
	DWORD 	size=256;
	string risultato="";
	if (GetComputerName(buffer,&size))
		risultato=wtou(buffer);
	return risultato;
}
string win_getusername()
{
	wchar_t buffer[256];
	DWORD 	size=256;
	string risultato="";
	if (GetUserName(buffer,&size))
		risultato=wtou(buffer);
	return risultato;
}
string my_realpath(std::string const& i_path)
{
	if (i_path=="")
			return "";
	char linkbuffer[66000]={0};
	size_t	linksize=66000;
    HANDLE h = CreateFileW(utow(i_path.c_str()).c_str(), 0, 0, NULL, OPEN_EXISTING, FILE_FLAG_OPEN_REPARSE_POINT, NULL);
    char buffer[MAXIMUM_REPARSE_DATA_BUFFER_SIZE];
    DWORD dwBytesReturned = 0;
    DeviceIoControl(h, FSCTL_GET_REPARSE_POINT, NULL, 0, buffer, sizeof(buffer), &dwBytesReturned, 0);
    typedef struct
    {
        ULONG ReparseTag;
        USHORT ReparseDataLength;
        USHORT Reserved;
        union
        {
            struct
            {
                USHORT SubstituteNameOffset;
                USHORT SubstituteNameLength;
                USHORT PrintNameOffset;
                USHORT PrintNameLength;
                ULONG Flags;
                WCHAR PathBuffer[1];
            } SymbolicLinkReparseBuffer;
            struct
            {
                USHORT SubstituteNameOffset;
                USHORT SubstituteNameLength;
                USHORT PrintNameOffset;
                USHORT PrintNameLength;
                WCHAR PathBuffer[1];
            } MountPointReparseBuffer;
            struct
            {
                UCHAR  DataBuffer[1];
            } GenericReparseBuffer;
        };
    } REPARSE_DATA_BUFFER;
    REPARSE_DATA_BUFFER* pRDB = reinterpret_cast<REPARSE_DATA_BUFFER*>(buffer);
    if (pRDB->ReparseTag == IO_REPARSE_TAG_SYMLINK)
    {
        int nameLength = pRDB->SymbolicLinkReparseBuffer.SubstituteNameLength / sizeof(wchar_t);
        wchar_t* pName = (wchar_t*)((char*)pRDB->SymbolicLinkReparseBuffer.PathBuffer + pRDB->SymbolicLinkReparseBuffer.SubstituteNameOffset);
        WideCharToMultiByte(CP_UTF8, 0, pName, nameLength, linkbuffer, linksize, NULL, NULL);
        return linkbuffer;
    }
    CloseHandle(h);
    return "";
}
uint32_t convert_unicode_to_ansi_string(std::string& ansi,const wchar_t* unicode,const size_t unicode_size)
	{
		uint32_t error = 0;
		do
		{
			if ((nullptr == unicode) || (0 == unicode_size))
			{
				error = ERROR_INVALID_PARAMETER;
				break;
			}
			ansi.clear();
			int required_cch=::WideCharToMultiByte(
									CP_ACP,
									0,
									unicode, static_cast<int>(unicode_size),
									nullptr, 0,
									nullptr, nullptr
									);
			if (required_cch==0)
			{
				error=::GetLastError();
				break;
			}
			ansi.resize(required_cch);
			if (0 == ::WideCharToMultiByte(
						CP_ACP,
						0,
						unicode, static_cast<int>(unicode_size),
						const_cast<char*>(ansi.c_str()), static_cast<int>(ansi.size()),
						nullptr, nullptr
						))
			{
				error =::GetLastError();
				break;
			}
		}
		while (false);
		return error;
	}
uint32_t convert_utf8_to_unicode_string(std::wstring& unicode,const char* utf8,const size_t utf8_size)
	{
		uint32_t error = 0;
		do
		{
			if ((nullptr == utf8) || (0 == utf8_size))
			{
				error = ERROR_INVALID_PARAMETER;
				break;
			}
			unicode.clear();
			int required_cch = ::MultiByteToWideChar(
				CP_UTF8,
				MB_ERR_INVALID_CHARS,
				utf8, static_cast<int>(utf8_size),
				nullptr, 0
			);
			if (required_cch==0)
			{
				error = ::GetLastError();
				break;
			}
			unicode.resize(required_cch);
			if (0 == ::MultiByteToWideChar(
						CP_UTF8,
						MB_ERR_INVALID_CHARS,
						utf8, static_cast<int>(utf8_size),
						const_cast<wchar_t*>(unicode.c_str()), static_cast<int>(unicode.size())
						))
			{
				error=::GetLastError();
				break;
			}
		}
		while (false);
		return error;
	}
// Windows: double converison
	std::string utf8toansi(const std::string & utf8)
	{
		std::wstring unicode = L"";
		convert_utf8_to_unicode_string(unicode, utf8.c_str(), utf8.size());
		std::string ansi = "";
		convert_unicode_to_ansi_string(ansi, unicode.c_str(), unicode.size());
		return ansi;
	}
int erredbarras(const std::wstring &wi_path)
{
	std::wstring wpattern = wi_path+L"\\*.*";
	const std::string s_pattern(wpattern.begin(),wpattern.end());
	if (flagdebug)
		myprintf("00014: get handle FOR %s\n",s_pattern.c_str());
	int secondi=(mtime()-g_startrd)/1000;
	if (secondi!=g_rd_ultimotempo)
	{
		g_rd_ultimotempo=secondi;
		if (g_rd_expected)
			myprintf("00015: Deleted objects %12s of (~) %12s @ %s/s\r",migliaia(g_rd),migliaia2(g_rd_expected),migliaia3(g_rd/secondi));
		else
			myprintf("00016: Deleted objects %12s\r",migliaia(g_rd));
	}
	WIN32_FIND_DATAW findfiledata;
	HANDLE myhandle=FindFirstFileW(wpattern.c_str(),&findfiledata);
	if (myhandle==INVALID_HANDLE_VALUE)
	{
		if (flagdebug)
			myprintf("00017: Invalid handle %s\n",s_pattern.c_str());
		return 0;
	}
	do
	{
		std::string t=wtou(findfiledata.cFileName);
		if ((t!=".") && (t!=".."))
		{
			std::wstring wfilepath=wi_path+L"\\"+findfiledata.cFileName;
			const std::string s_wfilepath(wfilepath.begin(),wfilepath.end());
			if (flagdebug3)
				myprintf("00018: Working on %s\n",s_wfilepath.c_str());
			if (findfiledata.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
			{
				if (flagdebug3)
				{
					myprintf("\n");
					myprintf("00019: recurse on %s\n",s_wfilepath.c_str());
				}
				int myresult=erredbarras(wfilepath);
				if (myresult)
					return myresult;
			}
			else
			{
				if (flagdebug3)
					myprintf("00020: set attribute on file %s\n",s_wfilepath.c_str());
				if (SetFileAttributesW(wfilepath.c_str(),FILE_ATTRIBUTE_NORMAL) == FALSE)
				{
					if (flagdebug)
						myprintf("00021! ERROR cannot change attr of %s\n",s_wfilepath.c_str());
					return GetLastError();
				}
				if (flagdebug3)
					myprintf("00022: try to delete file %s\n",s_wfilepath.c_str());
				if (DeleteFileW(wfilepath.c_str())==FALSE)
				{
					if (flagdebug)
						myprintf("00023! ERROR highlander file %s\n",s_wfilepath.c_str());
					return GetLastError();
				}
				else
					g_rd++;
			}
		}
	} while(FindNextFile(myhandle,&findfiledata)==TRUE);
	if (myhandle)
		FindClose(myhandle);
	DWORD myerror=GetLastError();
	if (myerror==ERROR_NO_MORE_FILES)
	{
		const std::string s_wipath(wi_path.begin(), wi_path.end());
		if (flagdebug3)
			myprintf("00024: Change folder attr  %s\n",s_wipath.c_str());
		if (SetFileAttributesW(wi_path.c_str(),FILE_ATTRIBUTE_NORMAL)==FALSE)
		{
			if (flagdebug)
				myprintf("00025! ERROR cannot change folder attr %s\n",s_wipath.c_str());
			return GetLastError();
		}
		if (flagdebug3)
			myprintf("00026: RemoveDirectory  %s\n",s_wipath.c_str());
		if (RemoveDirectoryW(wi_path.c_str())==FALSE)
		{
			if (flagdebug)
				myprintf("00027! ERROR highlander dir %s\n",s_wipath.c_str());
			return GetLastError();
		}
		else
		g_rd++;
	}
	else
		return myerror;
	return 0;
}





 

int64_t	getwinattributes(string i_filename)
{
	WIN32_FIND_DATA ffd;
    if ( (i_filename.size()>0) && (isdirectory(i_filename)))
		i_filename+="*";
	HANDLE h=FindFirstFile(utow(i_filename.c_str()).c_str(), &ffd);
	if (h!=INVALID_HANDLE_VALUE)
	{
		FindClose(h);
		return ffd.dwFileAttributes;
	}
	return 0;
}
/// reworked https://github.com/JFLarvoire/SysToolsLib/blob/master/C/MsvcLibX/src/readlink.c
typedef struct _REPARSE_READ_BUFFER
{
	DWORD  ReparseTag;
	WORD   ReparseDataLength;
	WORD   Reserved;
	UCHAR  DataBuffer[1];
} REPARSE_READ_BUFFER, *PREPARSE_READ_BUFFER;
bool getreparsepointW(bool i_flagdebug,const string i_path, char *i_buf, size_t i_bufsize,size_t& o_byteletti,DWORD& o_tag,string& o_type)
{
	o_byteletti	=0;
	o_tag		=0;
	o_type		="";
	myprintf("00028: REPPAAA\n");
	return true;
	wstring wi_path=utow(i_path.c_str());
	PREPARSE_READ_BUFFER pIoctlBuf;
	DWORD attributi = GetFileAttributesW(wi_path.c_str());
	if (attributi==INVALID_FILE_ATTRIBUTES)
	{
		myprintf("00029! failed GetFileAttributesW\n");
		return false;
	}
	if (!(attributi & FILE_ATTRIBUTE_REPARSE_POINT))
	{
		myprintf("00030! fake file is not a reparse point\n");
		return false;
	}
	DWORD flag=FILE_FLAG_OPEN_REPARSE_POINT;
	if (attributi & FILE_ATTRIBUTE_DIRECTORY)
		flag|=FILE_FLAG_BACKUP_SEMANTICS;
	HANDLE h=CreateFileW(wi_path.c_str(),0,FILE_SHARE_READ | FILE_SHARE_WRITE,NULL,OPEN_EXISTING,flag,NULL);
	if (h==INVALID_HANDLE_VALUE)
	{
		myprintf("00031! cannot createfile on reparse point\n");
		return false;
	}
	DWORD byteletti;
 	BOOL fattoio=DeviceIoControl(h,FSCTL_GET_REPARSE_POINT,NULL,0,i_buf,(DWORD)i_bufsize,&byteletti,NULL);
	CloseHandle(h);
	if (!fattoio)
	{
		myprintf("00032! DeviceIoControl kaputt\n");
		return false;
	}
	if (byteletti<8)
	{
		myprintf("00033! something wrong\n");
		return false;
	}
	pIoctlBuf 	= (PREPARSE_READ_BUFFER)i_buf;
	o_tag		=pIoctlBuf->ReparseTag;
	o_byteletti	=pIoctlBuf->ReparseDataLength;
    switch (o_tag)
	{
		case 0x00000000: 	o_type="Reserved0"; break;
		case 0x00000001: 	o_type="Reserved1"; break;
		case 0x00000002: 	o_type="Reserved2"; break;
		case 0xA0000003: 	o_type="Mount point or junction"; break;
		case 0xC0000004: 	o_type="Hierarchical Storage Manager"; break;
		case 0x80000005: 	o_type="Home server drive extender"; break;
		case 0x80000006: 	o_type="Hierarchical Storage Manager Product #2"; break;
		case 0x80000007: 	o_type="Single-instance storage filter driver"; break;
		case 0x80000008: 	o_type="Windows boot Image File"; break;
		case 0x80000009: 	o_type="Cluster Shared Volume"; break;
		case 0x8000000A: 	o_type="Distributed File System"; break;
		case 0x8000000B: 	o_type="Filter manager test harness"; break;
		case 0xA000000C: 	o_type="Symbolic link"; break;
		case 0xA0000010: 	o_type="Internet Information Services cache"; break;
		case 0x80000012: 	o_type="Distributed File System R filter"; break;
		case 0x80000013: 	o_type="Deduplicated file"; break;
		case 0x80000014: 	o_type="NFS symbolic link"; break;
		case 0xC0000014: 	o_type="APPXSTREAM (Not used?)"; break;
		case 0x80000015: 	o_type="Placeholder for a OneDrive file"; break;
		case 0x80000016: 	o_type="Dynamic File filter"; break;
		case 0x80000017: 	o_type="Windows Overlay Filesystem compressed file"; break;
		case 0x80000018: 	o_type="Windows Container Isolation filter"; break;
		case 0xA0000019: 	o_type="NPFS server silo named pipe symbolic link into the host silo"; break;
		case 0x9000001A: 	o_type="Cloud Files filter"; break;
		case 0x8000001B: 	o_type="Application Execution link"; break;
		case 0x9000001C: 	o_type="Projected File System VFS filter, ex for git"; break;
		case 0xA000001D: 	o_type="Linux Sub-System Symbolic Link"; break;
		case 0x8000001E: 	o_type="Azure File Sync (AFS) filter"; break;
		case 0xA000001F: 	o_type="Windows Container Isolation filter tombstone"; break;
		case 0xA0000020: 	o_type="Unhandled Windows Container Isolation filter"; break;
		case 0xA0000021: 	o_type="One Drive (Not used?)"; break;
		case 0xA0000022: 	o_type="Projected File System VFS filter tombstone, ex for git"; break;
		case 0xA0000023: 	o_type="Linux Sub-System Socket"; break;
		case 0xA0000024: 	o_type="Linux Sub-System FIFO"; break;
		case 0xA0000025: 	o_type="Linux Sub-System Character Device"; break;
		case 0xA0000026: 	o_type="Linux Sub-System Block Device"; break;
		case 0xA0000027: 	o_type="Windows Container Isolation filter Link"; break;
		default:			o_type="35701: Microsoft strikes back!"; break;
    }
	if (!i_flagdebug)
		return true;
    unsigned int ul;
    unsigned int u;
    unsigned int uMax;
	for (ul = 0; ul < (unsigned)(pIoctlBuf->ReparseDataLength); ul += 16)
	{
		myprintf("%08X ", ul);
		uMax = (unsigned)(pIoctlBuf->ReparseDataLength) - ul;
		if (uMax > 16)
			uMax = 16;
      /* Display the hex dump */
		for (u=0; u<16; u++)
		{
			if (!(u&3))
				myprintf(" ");
			if (u < uMax)
				myprintf("%2.2X ", ((unsigned char *)pIoctlBuf->DataBuffer)[ul + u]);
			else
				myprintf("   ");
		}
      /* Display the ASCII characters dump */
		for (u=0; u<16; u++)
		{
			char c = ((char *)pIoctlBuf->DataBuffer)[ul + u];
			if (!(u&7))
				myprintf(" ");
			if (c < ' ')
				c = ' ';
			if ((unsigned char)c > '\x7F')
				c = ' ';
			myprintf("%c", c);
		}
		myprintf("\n");
    }
	return true;
}
#else // Houston, we have Unix
int64_t mtime()
{
  timeval tv;
  gettimeofday(&tv, 0);
  return tv.tv_sec*1000LL+tv.tv_usec/1000;
}
std::string utf8toansi(const std::string & utf8)
{
	return utf8;
}
void setupConsole(void)
{
}
void restoreConsole(void)
{
	if (flagnoconsole)
		return;
	if (flagsilent)
		return;
	printf("\x1b[0m");
}
#endif // corresponds to #ifdef (#ifdef _WIN32)

int terminalwidth()
{
#if defined(_WIN32)
    CONSOLE_SCREEN_BUFFER_INFO csbi;
    GetConsoleScreenBufferInfo(GetStdHandle(STD_OUTPUT_HANDLE), &csbi);
    return (int) csbi.srWindow.Right - csbi.srWindow.Left + 1;
#else
    struct winsize w;
    int colonna=80;
	if (ioctl(fileno(stdout), TIOCGWINSZ, &w)==0)
		colonna=(w.ws_col);
	if (colonna>200)
		colonna=200;
    return colonna;
#endif // corresponds to #if (#if defined(_WIN32))
}
int terminalheight()
{
#if defined(_WIN32)
    CONSOLE_SCREEN_BUFFER_INFO csbi;
    GetConsoleScreenBufferInfo(GetStdHandle(STD_OUTPUT_HANDLE), &csbi);
	return (int)csbi.srWindow.Bottom - csbi.srWindow.Top + 1;
#else
    struct winsize w;
    int riga=30;
	if (ioctl(fileno(stdout), TIOCGWINSZ, &w)==0)
		riga=(w.ws_row);
	if (riga>200)
		riga=30;
    return riga;
#endif // corresponds to #if (#if defined(_WIN32))
}
bool iskeypressed(int i_thekey)
{
#ifdef _WIN32
    if (kbhit())
    {
		int keypressed=::getch();
		if (flagdebug)
			printf("21029: WIN32 getch %d %c\n",keypressed,keypressed);
        if (i_thekey==0)
			return true;
		else
			return (i_thekey==keypressed);
    }
	return false;
#else
	struct termios old_t;
	struct termios new_t;
	tcgetattr (0,&old_t);
	new_t = old_t;
	new_t.c_lflag &= ~( ICANON | ECHO );
	new_t.c_cc[VMIN] = 0;
	new_t.c_cc[VTIME] = 0;
	tcsetattr(0,TCSANOW,&new_t);
	char ch;
	int letti=read(0,&ch,1);
	tcsetattr(0,TCSANOW,&old_t);
	if (i_thekey==0)
		return (letti!=0);
	else
		return ((letti!=0) && (i_thekey==ch));
#endif // corresponds to #ifdef (#ifdef _WIN32)
}
int mygetch(bool i_flagmore)
{
	int mychar=0;
#if defined(_WIN32)
	mychar=::getch();
#endif // corresponds to #if (#if defined(_WIN32))
#ifdef unix
/// BSD Unix
	struct termios oldt, newt;
	tcgetattr ( STDIN_FILENO, &oldt );
	newt = oldt;
	newt.c_lflag &= ~( ICANON | ECHO );
	tcsetattr ( STDIN_FILENO, TCSANOW, &newt );
	mychar = getchar();
	tcsetattr ( STDIN_FILENO, TCSANOW, &oldt );
#endif // corresponds to #ifdef (#ifdef unix)
	if (!i_flagmore)
		return mychar;
	if ((mychar==113) || (mychar==81) || (mychar==3))  /// q, Q, control-C
	{
#ifdef unix
		myprintf("\n\n");
#endif // corresponds to #ifdef (#ifdef unix)
		seppuku();
	}
	return mychar;
}

// Function to check if the output is redirected
bool isOutputRedirected() 
{
#ifdef _WIN32
    // Windows: use GetFileType 
	HANDLE hStdout = GetStdHandle(STD_OUTPUT_HANDLE);
    if (hStdout == INVALID_HANDLE_VALUE) 
	    return true; // Error, we assume redirection
    
    DWORD fileType = GetFileType(hStdout);
    
    // FILE_TYPE_CHAR console
	// If it's not FILE_TYPE_CHAR, then it's redirected
    return (fileType != FILE_TYPE_CHAR);
    
#else
    // Unix/Linux: use isatty
    return !isatty(STDOUT_FILENO);
#endif
}

// Alternative version that also checks stderr
bool isStderrRedirected() 
{
#ifdef _WIN32
    HANDLE hStderr = GetStdHandle(STD_ERROR_HANDLE);
    if (hStderr == INVALID_HANDLE_VALUE) 
	    return true;
    
    DWORD fileType = GetFileType(hStderr);
    return (fileType != FILE_TYPE_CHAR);
    
#else
    return !isatty(STDERR_FILENO);
#endif
}

// Function that checks both stdout and stderr
bool isAnyOutputRedirected() 
{
    return (isOutputRedirected() || isStderrRedirected());
}


void printbar(char i_carattere,bool i_printbarraenne=true)
{
	if (flagpakka)
		return;
	int twidth=terminalwidth();
	if (isAnyOutputRedirected())
		twidth=80;

	if (twidth<10)
		twidth=100;
	for (int i=0;i<twidth-4;i++)
		myprintf("%c",i_carattere);
	if (i_printbarraenne)
		myprintf("\n");
}
void moreprint(const char* i_stringa,bool i_nocr=false,int i_spaces=0)
{
	if (!i_stringa) return;  // Early return if string is null
	
	std::string spaces(i_spaces, ' ');
			
	if (g_output_handle)
	{
		if (i_nocr)
			fprintf(g_output_handle,"%s",i_stringa);
		else
			fprintf(g_output_handle,"%s\n",i_stringa);
	}
	if (flagsilent)
		return;
	int larghezzaconsole=terminalwidth()-2;
	int altezzaconsole=terminalheight();
	static int righestampate=0;
	if (flagnomore)
	{
		if (i_nocr)
			printf("%s%s",spaces.c_str(),i_stringa);
		else
			printf("%s%s\n",spaces.c_str(),i_stringa);
		return;
	}
		
	if ((larghezzaconsole<0) || (altezzaconsole<0))
	{
		if (i_nocr)
			printf("%s%s",spaces.c_str(),i_stringa);
		else
			printf("%s%s\n",spaces.c_str(),i_stringa);
		return;
	}
	if (!i_nocr)
		if (!strcmp(i_stringa,"\n"))
		{
			printf("\n");
			righestampate++;
			if (righestampate>(altezzaconsole-2))
			{
				printf("-- More (q, Q or control C to exit) --\r");
				mygetch(true);
				for (int i=0;i<altezzaconsole;i++)
					printf("\n");
				righestampate=0;
			}
			return;
		}
	int lunghezzastringa=strlen(i_stringa);
	if (!larghezzaconsole)
		return;
	int righe	=(lunghezzastringa/larghezzaconsole)+1;
	int massimo	=lunghezzastringa-(larghezzaconsole*(righe-1));
	for (int riga=1; riga<=righe;riga++)
	{
		int currentmax=larghezzaconsole;
		if (riga==righe)
			currentmax=massimo;
		int startcarattere=(riga-1)*larghezzaconsole;
		printf("%s",spaces.c_str());
		for (int i=startcarattere;i<startcarattere+currentmax;i++)
			printf("%c",i_stringa[i]);
		if (!i_nocr)
		{
			printf("\n");
			righestampate++;
			if (righestampate>(altezzaconsole-2))
			{
				printf("-- More (q, Q or control C to exit) --\r");
				mygetch(true);
				for (int i=0;i<altezzaconsole;i++)
					printf("\n");
				righestampate=0;
			}
		}
	}
}
void morebar(const char i_carattere)
{
	int twidth=terminalwidth();
	if (twidth<10)
		twidth=100; // redirect
	if (twidth>100)
		twidth=100;
	std::string temp(twidth-4, i_carattere);
	moreprint(temp.c_str());
}
bool getcaptcha(const string& i_captcha,const string& i_reason)
{
	if (flagnocaptcha)
		return true;
	if (i_captcha=="")
		return false;
	if (i_reason=="")
		return false;
	printf("\nTo confirm a dangerous command\n");
	printf(">>> %s\n",i_reason.c_str());
	printf("enter EXACTLY the capcha, then press CR (return)\n");
	printf("Entering anything else will quit\n");
	printf("\nCaptcha to continue:     %s\n",i_captcha.c_str());
	char myline[81];
    int dummy=scanf("%80s", myline);
	if (dummy==888888)	// compiler be quiet!
		printf("no-warning-please\n");
	if (myline!=i_captcha)
	{
		printf("Wrong captcha\n");
		return false;
	}
	myprintf("00034: Captcha OK\n");
	return true;
}



void scrivi(unsigned int i_spazio,string i_header, string i_desc)
{
	if (i_spazio<=10)
		i_spazio=10;
	
	string header_padded = i_header;
    
    if (header_padded.length() > i_spazio)
        header_padded = header_padded.substr(0, i_spazio - 1);
    
    while (header_padded.length() < i_spazio) 
	    header_padded += " ";
    
    // Check if the header starts exactly with "CMD "
    if (i_header.substr(0, 4) == "CMD ") 
		color_cyan();
    else 
	    color_green();
    
    moreprint(header_padded.c_str(), true); 
    if (i_header.substr(0, 4) != "CMD ") 
	    color_restore(); 
    
	moreprint(i_desc.c_str());
	if (i_header.substr(0, 4) == "CMD ") 
	    color_restore(); 
    
	
	/*
	static int maxlen=0;
	if (i_desc.size()>maxlen)
	{
		maxlen=i_desc.size();
		printf("----------------------------------- %d\n",maxlen);
	}
	*/
}


void scrivi_examples()
{
	color_yellow(); 
	moreprint("Examples:"); 
	color_restore();
}
void scrivi_riga(string i_header, string i_desc)
{
	scrivi(20,i_header,i_desc);
}
void scrivi_esempio(string i_header, string i_desc)
{
	scrivi(38,i_header,i_desc);
}


class franz_flags
{
	public:
	MAPPAFLAGS 	mappaflags;
	HELPFLAGS 	helpflags;
	HELPFLAGS 	helpflagsscope;

	bool get(const string& i_name)
	{
		MAPPAFLAGS::iterator p=mappaflags.find(i_name);
		if (p==mappaflags.end())
		{
			printf("42098: guru doing getflag %s \n",i_name.c_str());
			seppuku();
		}
		if (p->second==NULL)
		{
			printf("42913: guru empty pointer flag%s\n",i_name.c_str());
			seppuku();
		}
		return (*p->second);
	}
	bool exists(const string& i_name)
	{
		return (mappaflags.find(i_name)!=mappaflags.end());
	}
	void set(string i_name, bool i_value)
	{

		MAPPAFLAGS::iterator p=mappaflags.find(i_name);
		if (p==mappaflags.end())
		{
		}
		if (p==mappaflags.end())
		{
			printf("42923: GURU doing setflag %s \n",i_name.c_str());
			seppuku();
		}
		if (p->second==NULL)
		{
			printf("42928: guru empty pointer flag%s\n",i_name.c_str());
			seppuku();
		}

		(*p->second)=i_value;
	}
	void settrue(const string& i_name)
	{
		set(i_name,true);
	}
	void debugga()
	{
///		printf("48149: array franz flag size %s\n",migliaia(mappaflags.size()));

		for (MAPPAFLAGS::iterator p=mappaflags.begin(); p!=mappaflags.end(); ++p)
		{
			myprintf("48150: %-20s   %d ",p->first.c_str(),(int)*p->second);
			HELPFLAGS::iterator a=helpflags.find(p->first);
			if (p!=mappaflags.end())
				myprintf(" <<%s>>",a->second.c_str());
			myprintf("\n");
		}
	}
	void tutti()
	{
		for (MAPPAFLAGS::iterator p=mappaflags.begin(); p!=mappaflags.end(); ++p)
		{
			char buffer[200];
			HELPFLAGS::iterator a=helpflags.find(p->first);
			if (p!=mappaflags.end())
			{
				color_green();
				snprintf(buffer,sizeof(buffer),"%-20s",p->first.c_str());
				moreprint(buffer,true);
				color_restore();
				snprintf(buffer,sizeof(buffer)," %s",a->second.c_str());
				moreprint(buffer);
			}
		}
	}

	string compact()
	{

		string risultato="";
		for (MAPPAFLAGS::iterator p=mappaflags.begin(); p!=mappaflags.end(); ++p)
			if (*p->second)
				risultato+=p->first+' ';
		return risultato;
	}

	void add(bool* i_thebool,string i_name,string i_help,string i_helpscope,bool i_default=false)
	{
		if (i_name=="")
		{
			printf("48125: GURU i_name empty\n");
			seppuku();
		}
		if (i_thebool==NULL)
		{
			printf("09778: GURU thebool NULL\n");
			seppuku();
		}

		MAPPAFLAGS::iterator p=mappaflags.find(i_name);
		if (p==mappaflags.end())
		{
			*(i_thebool)=i_default;
			mappaflags.insert(std::pair<std::string, bool*>(i_name, i_thebool));
			if (i_help!="")
				helpflags.insert(std::pair<std::string, std::string>(i_name, i_help));
			if (i_helpscope!="")
				helpflags.insert(std::pair<std::string, std::string>(i_name, i_helpscope));
		}
	}

};

franz_flags	g_programflags;


char* stristr(const char* str1,const char* str2)
{
    const char* p1 = str1;
    const char* p2 = str2;
    const char* r = *p2 == 0 ? str1 : 0 ;
    while((*p1!=0) && (*p2!=0))
    {
        if( tolower((unsigned char)*p1)==tolower((unsigned char)*p2))
        {
            if(r==0)
                r=p1;
            p2++;
        }
        else
        {
            p2=str2;
            if(r!=0)
                p1=r+1;
            if(tolower((unsigned char)*p1)==tolower((unsigned char)*p2))
            {
                r=p1;
                p2++;
            }
            else
                r=0;
        }
        p1++;
    }
    return *p2 == 0 ? (char*)r : 0 ;
}
bool havedoublequote(const string i_filename)
{
	if (i_filename.length()==0)
		return false;
	else
	return i_filename[i_filename.size()-1]=='"';
}
string mypopback(const string& i_string)
{
	if (i_string=="")
		return "";
	return i_string.substr(i_string.size() - 1);
}
string cutdoublequote(const string& i_string)
{
	if (i_string=="")
		return "";
	string temp=i_string;
	if (havedoublequote(i_string))
		  temp=i_string.substr(i_string.size() - 1);
	return temp;
}
bool isextension(const char* i_filename,const char* i_ext)
{
	if (!i_filename)
		return false;
	if (!i_ext)
		return false;
	if (isdirectory(i_filename))
		return false;
	const char * posizione=stristr(i_filename, i_ext);
	if (!posizione)
		return false;
	return (posizione-i_filename)+strlen(i_ext)==strlen(i_filename);
}
bool iszpaq(const string i_filename)
{
	return isextension(i_filename.c_str(), ".zpaq");
}
#ifdef _WIN32
bool isexe(const string i_filename)
{
	return isextension(i_filename.c_str(), ".exe");
}
#endif // corresponds to #ifdef (#ifdef _WIN32)
bool isxls(const string i_filename)
{
	return (isextension(i_filename.c_str(), ".xls") || isextension(i_filename.c_str(), ".ppt") || isextension(i_filename.c_str(), ".pps"));
}
bool isads(const string i_filename)
{
	if (i_filename.length()==0)
		return false;
	else
		return strstr(i_filename.c_str(), ":$DATA")!=0;
}
bool iszfs(const string i_filename)
{
	if (i_filename.length()==0)
		return false;
	else
		return strstr(i_filename.c_str(), ".zfs")!=0;
}
bool replaceinsensitive(std::string& str, const std::string& from, const std::string& to) {
    if (from.empty()) return false;
    
    std::string str_lower = str;
    std::string from_lower = from;
    
    for (size_t i = 0; i < str_lower.length(); ++i) {
        if (str_lower[i] >= 'A' && str_lower[i] <= 'Z') {
            str_lower[i] = str_lower[i] + ('a' - 'A');
        }
    }
    
    for (size_t i = 0; i < from_lower.length(); ++i) {
        if (from_lower[i] >= 'A' && from_lower[i] <= 'Z') {
            from_lower[i] = from_lower[i] + ('a' - 'A');
        }
    }
    
    size_t start_pos = str_lower.find(from_lower);
    if (start_pos == std::string::npos)
        return false;
    
    str.replace(start_pos, from.length(), to);
    return true;
}
bool replace(std::string& str, const std::string& from, const std::string& to) {
    size_t start_pos = str.find(from);
    if(start_pos == std::string::npos)
        return false;
    str.replace(start_pos, from.length(), to);
    return true;
}
void myreplaceall(std::string& str, const std::string& from, const std::string& to) {
    if(from.empty())
        return;
    size_t start_pos = 0;
    while((start_pos = str.find(from, start_pos)) != std::string::npos) {
        str.replace(start_pos, from.length(), to);
        start_pos += to.length(); // In case 'to' contains 'from', like replacing 'x' with 'yx'
    }
}


string format_datetime(string i_formato,tm* t=NULL)
{
	char	temp[12];
	if (t==NULL)
	{
		time_t nowz=time(NULL);
		t=localtime(&nowz);
	}
	snprintf(temp,sizeof(temp),"%02d",t->tm_hour);
	string hour=temp;
	snprintf(temp,sizeof(temp),"%02d",t->tm_min);
	string min=temp;
	snprintf(temp,sizeof(temp),"%02d",t->tm_sec);
	string sec=temp;
	snprintf(temp,sizeof(temp),"%d",t->tm_wday);
	string weekday=temp;
	snprintf(temp,sizeof(temp),"%04d",t->tm_year+1900);
	string	year=temp;
	snprintf(temp,sizeof(temp),"%02d",t->tm_mon+1);
	string month=temp;
	snprintf(temp,sizeof(temp),"%02d",t->tm_mday);
	string day=temp;
	snprintf(temp,sizeof(temp),"%02d",(t->tm_yday-t->tm_wday+7)/7);
	string	week=temp;
	string date=year+'-'+month+'-'+day;
	string time=hour+'-'+min+'-'+sec;
	string datetime=date+'_'+time;
	myreplaceall(i_formato,"%hour",hour);
	myreplaceall(i_formato,"%min",min);
	myreplaceall(i_formato,"%sec",sec);
	myreplaceall(i_formato,"%weekday",weekday);
	myreplaceall(i_formato,"%year",year);
	myreplaceall(i_formato,"%month",month);
	myreplaceall(i_formato,"%day",day);
	myreplaceall(i_formato,"%week",week);
	myreplaceall(i_formato,"%timestamp",datetime);
	myreplaceall(i_formato,"%datetime",datetime);
	myreplaceall(i_formato,"%date",date);
	myreplaceall(i_formato,"%time",time);
	
	myreplaceall(i_formato,"$hour",hour);
	myreplaceall(i_formato,"$min",min);
	myreplaceall(i_formato,"$sec",sec);
	myreplaceall(i_formato,"$weekday",weekday);
	myreplaceall(i_formato,"$year",year);
	myreplaceall(i_formato,"$month",month);
	myreplaceall(i_formato,"$day",day);
	myreplaceall(i_formato,"$week",week);
	myreplaceall(i_formato,"$timestamp",datetime);
	myreplaceall(i_formato,"$datetime",datetime);
	myreplaceall(i_formato,"$date",date);
	myreplaceall(i_formato,"$time",time);

#ifdef _WIN32	
	string pcname=stringtolower(win_getcomputername());
	myreplaceall(i_formato,"$pcname",pcname);
	myreplaceall(i_formato,"$computername",pcname);
	string username=stringtolower(win_getusername());
	myreplaceall(i_formato,"$username",username);
#endif // corresponds to #ifdef (#ifdef _WIN32	)

	return i_formato;
}
bool myreplace(string& i_str, const string& i_from, const string& i_to)
{
    size_t start_pos = i_str.find(i_from);
    if(start_pos == std::string::npos)
        return false;
    i_str.replace(start_pos, i_from.length(), i_to);
    return true;
}
std::string myright(std::string const& source, size_t const length)
{
  if (length >= source.size())
 	return source;
  return source.substr(source.size() - length);
}
std::string myleft(std::string const& source, size_t const length)
{
  if (length >= source.size())
 	return source;
  return source.substr(0,length);
}
string mytrim(const string& i_str)
{
	size_t first = i_str.find_first_not_of(' ');
	if (string::npos == first)
		return i_str;
	size_t last = i_str.find_last_not_of(' ');
	return i_str.substr(first, ((last-first)+1));
}
void explode(std::string i_string,char i_delimiter,std::vector<std::string>& array)
{
	unsigned int i=0;
	while(i<i_string.size())
	{
		string temp="";
		while ((i<i_string.size()) && (i_string[i]!=i_delimiter))
        {
			temp+=i_string[i];
			i++;
		}
		array.push_back(temp);
		i++;
		if (i>=i_string.size())
			break;
    }
}
struct s_fileandsize
{
	string	filename;
	uint64_t size;
	int64_t attr;
	int64_t date;
	int64_t data;
	bool 	isdir;
	string 	hashhex;
	string 	hashtype;
	bool 	flaghashstored;
	string	writtenfilename;
	bool	hashok;
	bool	filenotfound;
	s_fileandsize(): filename(""),size(0),attr(0),date(0),data(-1),isdir(false),hashhex(""),hashtype(""),flaghashstored(false),writtenfilename(""),hashok(false),filenotfound(false) {}
};

const std::string WHITESPACE = " \n\r\t\f\v";
std::string myltrim(const std::string &s)
{
    size_t start = s.find_first_not_of(WHITESPACE);
    return (start == std::string::npos) ? "" : s.substr(start);
}
std::string myrtrim(const std::string &s)
{
    size_t end = s.find_last_not_of(WHITESPACE);
    return (end == std::string::npos) ? "" : s.substr(0, end + 1);
}
std::string mytrim2(const std::string &s)
{
    return myrtrim(myltrim(s));
}
string extractfilename(const std::string& i_string)
{
	size_t i = i_string.rfind('/', i_string.length());
	if (i != string::npos)
		return(i_string.substr(i+1, i_string.length() - i));
	return(i_string);
}
string prendiestensione(const string& s)
{
	if (isdirectory(s))
		return ("");
	string nomefile=extractfilename(s);
	size_t i = nomefile.rfind('.', nomefile.length());
	if (i != string::npos)
	{
		size_t lunghezzaestensione=nomefile.length() - i;
/// sometimes it is hard to get the extension: pippo.plutopaperino
		if (lunghezzaestensione>20)
			return("");
		return(nomefile.substr(i+1, lunghezzaestensione));
	}
   return("");
}
string extractfilepath(const string& i_string)
{
	size_t i = i_string.rfind('/', i_string.length());
	if (i != string::npos)
		return(i_string.substr(0, i+1));

	i = i_string.rfind('\\', i_string.length());
	if (i != string::npos)
		return(i_string.substr(0, i+1));
	return("");
}
string prendinomefileebasta(const string& s)
{
	string nomefile=extractfilename(s);
	size_t i = nomefile.rfind('.', nomefile.length());
	if (i != string::npos)
		return(nomefile.substr(0,i));
	return(nomefile);
}
string path(const string& fn)
{
	int n=0;
	for (int i=0; fn[i]; ++i)
		if (fn[i]=='/' || fn[i]=='\\')
			n=i+1;
	return fn.substr(0, n);
}
string purgeansi(string i_string,bool i_keeppath=false)
{
	if (i_string=="")
		return ("");
	string purged;
	for (unsigned int i=0;i<i_string.length();i++)
	{
		if (i_keeppath)
		{
			if ((i_string[i]==':') || (i_string[i]=='/') || (i_string[i]=='\\'))
			{
				purged+=i_string[i];
				continue;
			}
		}
		if (isalnum(i_string[i]))
			purged+=i_string[i];
		else
		{
			switch (i_string[i])
			{
/*
very forbiden
< (less than)
> (greater than)
: (colon)
" (double quote)
/ (forward slash)
\ (backslash)
| (vertical bar or pipe)
? (question mark)
* (asterisk)
*/
				case ' ':
				case '-':
				case '#':
				case '~':
				case '%':
				case '^':
				case '_':
				case '.':
				case '+':
				case '=':
				purged+=i_string[i];
				break;
				case '&':
				purged+="_and_";
				break;
				case ',':
				case '`':
				case '@':
				case '$':
				case '*':
				case '|':
				case ':':
				case ';':
				case '"':
				case '\'':
				case '<':
				case '>':
				case '\n':
				case '\r':
				case '\t':
				purged+='_';
				break;
				case '(':
				case '{':
				purged+='(';
				break;
				case ')':
				case '}':
				purged+=')';
				break;
				default:
				purged+='_';

			}
		}
	}
	return purged;
}
string forcelatinansi(string i_string)
{
	return i_string;
}
string purgedouble(const string& i_string,const string& i_from,const string& i_to)
{
	if (i_string=="")
		return("");
	if (i_from=="")
		return("");
	if (i_to=="")
		return("");
	string purged=i_string;
	myreplaceall(purged,i_from,i_to);
	return purged;
}
string compressemlfilename(const string& i_string)
{
	if (i_string=="")
		return("");
	string uniqfilename=extractfilename(i_string);
	string percorso=extractfilepath(i_string);
	for (int k=0;k<10;k++)
		uniqfilename=purgedouble(uniqfilename,"  "," ");
	for (int k=0;k<10;k++)
		uniqfilename=purgedouble(uniqfilename,"..",".");
	for (int k=0;k<10;k++)
		uniqfilename=purgedouble(uniqfilename,"Fw ","Fwd ");
	for (int k=0;k<10;k++)
		uniqfilename=purgedouble(uniqfilename,"Fwd Fwd ","Fwd ");
	for (int k=0;k<10;k++)
		uniqfilename=purgedouble(uniqfilename," R "," Re ");
	for (int k=0;k<10;k++)
		uniqfilename=purgedouble(uniqfilename,"R Fwd ","Re Fwd");
	for (int k=0;k<10;k++)
		uniqfilename=purgedouble(uniqfilename," RE "," Re ");
	for (int k=0;k<10;k++)
		uniqfilename=purgedouble(uniqfilename,"Re Re ","Re ");
	for (int k=0;k<10;k++)
		uniqfilename=purgedouble(uniqfilename,"Fwd Re Fwd Re ","Fwd Re ");
	for (int k=0;k<10;k++)
		uniqfilename=purgedouble(uniqfilename,"Re Fwd Re Fwd ","Re Fwd ");
	for (int k=0;k<10;k++)
		uniqfilename=purgedouble(uniqfilename," SV SV "," SV ");
	for (int k=0;k<10;k++)
		uniqfilename=purgedouble(uniqfilename,"Fwd FW ","Fwd ");
	for (int k=0;k<10;k++)
		uniqfilename=purgedouble(uniqfilename,"Fwd I ","Fwd ");
	for (int k=0;k<10;k++)
		uniqfilename=purgedouble(uniqfilename,"I Fwd ","Fwd ");
	for (int k=0;k<10;k++)
			uniqfilename=purgedouble(uniqfilename,"R Re ","Re ");
	for (int k=0;k<10;k++)
		uniqfilename=purgedouble(uniqfilename,"__","_");
	for (int k=0;k<10;k++)
		uniqfilename=purgedouble(uniqfilename," _ ","_");
	for (int k=0;k<10;k++)
		uniqfilename=purgedouble(uniqfilename,"  "," ");
	for (int k=uniqfilename.length()-1;k>0;k--)
	{
		if ((uniqfilename[k]=='-') || (uniqfilename[k]=='.') || (uniqfilename[k]==' '))
		{
			uniqfilename=mypopback(uniqfilename);
		}
		else
		{
			break;
		}
	}
	uniqfilename=mytrim2(uniqfilename);
	uniqfilename=percorso+uniqfilename;
	return uniqfilename;
}
FILE* freadopen(const char* i_filename)
{
#ifdef _WIN32
	wstring widename=utow(i_filename);
	FILE* myfp=_wfopen(widename.c_str(), L"rb" );
#else
	FILE* myfp=fopen(i_filename, "rb" );
#endif // corresponds to #ifdef (#ifdef _WIN32)
	if (myfp==NULL)
	{
		if (flagdebug)
		{
			myprintf("\n");
			myprintf("00035! freadopen cannot open: %Z\n",i_filename);
		}
		return 0;
	}
	return myfp;
}
int64_t prendidimensionehandle(FILE* i_handle)
{
	if (i_handle==0)
		return 0;
	fseeko(i_handle, 0, SEEK_END);
	int64_t dimensione=ftello(i_handle);
	fseeko(i_handle, 0, SEEK_SET);
	return dimensione;
}
/*
/// faster, but do not like emojis
int64_t prendidimensionefile(const char* i_filename)
{
    if (!i_filename)
        return -1; // Ritorna -1 per indicare errore invece di 0
    
#ifdef _WIN32
    // Usa le API native Windows per migliori prestazioni e supporto Unicode
    HANDLE hFile = CreateFileA(
        i_filename,
        GENERIC_READ,
        FILE_SHARE_READ | FILE_SHARE_WRITE,
        NULL,
        OPEN_EXISTING,
        FILE_ATTRIBUTE_NORMAL,
        NULL
    );
    
    if (hFile == INVALID_HANDLE_VALUE)
        return -1;
    
    LARGE_INTEGER fileSize;
    if (!GetFileSizeEx(hFile, &fileSize))
    {
        CloseHandle(hFile);
        return -1;
    }
    CloseHandle(hFile);
    return fileSize.QuadPart;
    
#else
    // Usa stat() per sistemi Unix-like (più efficiente di fopen/fseek/ftell)
    struct stat st;
    if (stat(i_filename, &st) == 0)
    {
        return st.st_size;
    }
    
    // Fallback al metodo originale se stat() fallisce
    FILE* myfile = freadopen(i_filename);
    if (myfile)
    {
        if (fseeko(myfile, 0, SEEK_END) != 0)
        {
            fclose(myfile);
            return -1;
        }
        
        int64_t dimensione = ftello(myfile);
        fclose(myfile);
        
        if (dimensione == -1)
            return -1;
            
        return dimensione;
    }
    
    return -1;
#endif
}
*/

/// slower, but gets more files (emoji)
int64_t prendidimensionefile(const char* i_filename)
{
	if (!i_filename)
		return 0;
	///myprintf("29583: i_filename %s\n",i_filename);
	FILE* myfile = freadopen(i_filename);
	if (myfile)
    {
		fseeko(myfile, 0, SEEK_END);
		int64_t dimensione=ftello(myfile);
		fclose(myfile);
		return dimensione;
	}
	else
	return 0;
}

#ifdef _WIN32
bool islonguncpath(string i_filename)
{
	if (i_filename.size()<8)
		return false;
	if (i_filename[0]=='/')
		if (i_filename[1]=='/')
			if (i_filename[2]=='?')
				if (i_filename[3]=='/')
					if (toupper(i_filename[4])=='U')
						if (toupper(i_filename[5])=='N')
							if (toupper(i_filename[6])=='C')
								if (i_filename[7]=='/')
									return true;
	return false;
}
#endif // corresponds to #ifdef (#ifdef _WIN32)
bool islongpath(string i_filename)
{
	if (i_filename.size()<8)
		return false;
	if (i_filename[0]=='/')
		if (i_filename[1]=='/')
			if (i_filename[2]=='?')
				if (i_filename[3]=='/')
					if (isalpha(i_filename[4]))
						if (i_filename[5]==':')
							if (i_filename[6]=='/')
								return true;
	return false;
}
bool comparechar(char c1, char c2)
{
    if (c1 == c2)
        return true;
    else if (std::toupper(c1) == std::toupper(c2))
        return true;
    return false;
}
string stringtoupper(string i_stringa)
{
	for (unsigned int i=0;i<i_stringa.size();i++)
		i_stringa[i]=toupper(i_stringa[i]);
	return i_stringa;
}

int myposi(string i_substring,string i_string)
{
	// not very quick...
	i_substring=stringtolower(i_substring);
	i_string=stringtolower(i_string);
    size_t start_pos = i_string.find(i_substring);
    if	(start_pos==std::string::npos)
        return -1;
	else
		return start_pos;
}
bool stringcomparei(std::string str1, std::string str2)
{
    return ( (str1.size() == str2.size() ) &&
             std::equal(str1.begin(), str1.end(), str2.begin(), &comparechar) );
}
string timetohuman(int32_t i_seconds,int32_t i_fixedlength=0)
{
	if (i_seconds<=0)
	{
		if (i_fixedlength>=4)
			return "0000:00:00";
		else
		if (i_fixedlength==3)
			return "000:00:00";
		else
			return "00:00:00";
	}
	int h=(i_seconds/3600);
	int m=(i_seconds -(3600*h))/60;
	int s=(i_seconds -(3600*h)-(m*60));
	char	temporaneo[20];
	if ((h<=99) || (i_fixedlength==2))
		snprintf(temporaneo,sizeof(temporaneo),"%02d:%02d:%02d",h,m,s);
	else
	if ((h<=999) || (i_fixedlength==3))
		snprintf(temporaneo,sizeof(temporaneo),"%03d:%02d:%02d",h,m,s);
	else
		snprintf(temporaneo,sizeof(temporaneo),"%d:%02d:%02d",h,m,s);
	return temporaneo;
}

char* mytohuman(int64_t i_bytes,char* i_buffer,int i_buffersize)
{
	if (i_buffer==NULL)
	{
		myprintf("00037! guru i_buffer null\n");
		seppuku();
	}
	if (i_buffersize<5)
	{
		myprintf("00038! guru buffer too small\n");
		seppuku();
	}
	if (i_bytes<0)
	{
		snprintf(i_buffer,5,"neg");
		return i_buffer;
	}
	char 	const *myappend[] = {" B","KB","MB","GB","TB","PB"};
	char 	length = sizeof(myappend)/sizeof(myappend[0]);
	double 	mybytes=i_bytes;
	int i=0;
	if (i_bytes>1024)
		for (i=0;(i_bytes/1024)> 0 && (i<length-1); i++,i_bytes/=1024)
			mybytes=i_bytes/1024.0;
///	snprintf(i_buffer,sizeof(i_buffer),"%.02lf %s",mybytes,myappend[i]);
	snprintf(i_buffer,i_buffersize,"%.02f %s",mybytes,myappend[i]);
	return i_buffer;
}

inline char* tohuman(int64_t i_bytes)
{
	static char io_buf[30];
	return mytohuman(i_bytes,io_buf,30);
}
inline char* tohuman2(int64_t i_bytes)
{
	static char io_buf[30];
	return mytohuman(i_bytes,io_buf,30);
}
inline char* tohuman3(int64_t i_bytes)
{
	static char io_buf[30];
	return mytohuman(i_bytes,io_buf,30);
}
inline char* tohuman4(int64_t i_bytes)
{
	static char io_buf[30];
	return mytohuman(i_bytes,io_buf,30);
}
inline char* tohuman5(int64_t i_bytes)
{
	static char io_buf[30];
	return mytohuman(i_bytes,io_buf,30);
}
// fix for Mac PowerPC (yes, no strlen here)
size_t mystrnlen(const char *i_string, size_t maxlen)
{
	if (i_string==NULL)
	{
		if (flagdebug)
			myprintf("00039! GURU null string\n");
		seppuku();  //safer to die
		exit(0);
		return 0;
	}
	if (maxlen==0)
	{
		if (flagdebug)
			myprintf("00040! GURU maxlen 0\n");
		seppuku();  //safer to die
		exit(0);
		return 0;
	}
	size_t len;
	for (len=0;len<maxlen;len++,i_string++) 
		if (!*i_string)
			break;
	return len;
}

int64_t myatoll(const char * i_str)
{
	if (i_str==NULL)
		return 0;
	
	if (mystrnlen(i_str,20)==20) /// this should be 21, 9999999...TB
	{
		myprintf("00041! GURU on very long number (longer than 20 chars)\n");
		seppuku();
		exit(0);
	}
	string	stringa=i_str;
	string	thedigit;
	string	thestring;
	for (unsigned int i=0;i<stringa.length();i++)
		if (isdigit(stringa[i]))
			thedigit+=stringa[i];
		else
		{
			if (isalpha(stringa[i]))
				thestring+=stringa[i];
		}
	int64_t	risultato=atoll(thedigit.c_str());
	if (flagdebug3)
	{
		myprintf("00042: integer (string) |%s| %s\n",thedigit.c_str(),migliaia(thedigit.size()));
		myprintf("00043: integer          |%lld|\n",risultato);
		myprintf("00044: text part        |%s|\n",thestring.c_str());
	}
	thestring=stringtoupper(thestring);

	if (thestring.size()==1)
	{
		if (toupper(thestring[0])=='K')
			risultato*=1000;
		else
		if (toupper(thestring[0])=='M')
			risultato*=1000000;
		else
		if (toupper(thestring[0])=='G')
			risultato*=1000000000;
		else
		if (toupper(thestring[0])=='T')
			risultato*=1000000000000LL;
	}
	else
	if (thestring.size()==2)
	{
		if (thestring=="KB")
			risultato*=1024;
		else
		if (thestring=="MB")
			risultato*=1048576;
		else
		if (thestring=="GB")
			risultato*=1073741824;
		else
		if (thestring=="TB")
			risultato*=1099511627776LL;
	}
	else
	{
///		if (flagdebug)
	///		myprintf("00045! ERROR string size not 1 or 2, ignoring [%s]\n",migliaia(thestring.size()));
	}
	
	if (flagdebug)
		myprintf("00046: final from %s to %s (%s)\n",i_str,migliaia(risultato),tohuman(risultato));
	
	if (risultato<0)
	{
		myprintf("00047! GURU NEGATIVE! final from %s to %s (%s)\n",i_str,migliaia(risultato),tohuman(risultato));
		seppuku();
		exit(0);
		return 0;
	}
	return risultato;
}
/// no stoi() on old compiler
int mystoi(string i_string)
{
	if (i_string=="")
		return 0;
    int risultato=0;
    for (unsigned int i=0; i<i_string.size();i++)
		if (isdigit(i_string[i]))
			risultato=risultato*10+i_string[i]-'0';
	return risultato;
}
int64_t encodestringdate(string i_date,bool i_flagfrom)
{
	i_date=format_datetime(i_date);
	string purged;
	for (unsigned int i=0;i<i_date.length();i++)
		if (isdigit(i_date[i]))
			purged+=i_date[i];
	int lunghezza=purged.length();
	if ((lunghezza>14))
	{
		myprintf("00048! datelength >14 (%d) |%s|\n",lunghezza,purged.c_str());
		return -1;
	}
	if (lunghezza%2!=0)
	{
		myprintf("00049! datelength must be even (use leading zeros) (%d) |%s|\n",lunghezza,purged.c_str());
		return -1;
	}

	int year	=0;
	int month	=0;
	int day		=0;
	int hour	=0;
	int minute	=0;
	int second	=0;
	if (lunghezza>=4)
		year	=mystoi(purged.substr(0,4));
	if (lunghezza>=6)
		month	=mystoi(purged.substr(4,2));
	if (lunghezza>=8)
		day		=mystoi(purged.substr(6,2));
	if (lunghezza>=10)
		hour	=mystoi(purged.substr(8,2));
	if (lunghezza>=12)
		minute	=mystoi(purged.substr(10,2));
	if (lunghezza>=14)
		second	=mystoi(purged.substr(12,2));

	if (i_flagfrom)
	{
		if (lunghezza==4) /// 2022
		{
			month	=1;
			day		=1;
		}
		if (lunghezza==6) /// 202209
			day		=1;
	}
	else
	{
		if (lunghezza==4) /// 2022
		{
			month	=12;
			day		=31;
		}
		if (lunghezza==6) /// 202209
		{
			if (month==2)
				day=28;
			else
			if ((month==4) || (month==6) || (month==9) || (month==11))
				day	=30;
			else
				day=31;
		}
	}
	if (flagdebug2)
		myprintf("00050: date   %04d-%02d-%02d %02d:%02d:%02d\n",year,month,day,hour,minute,second);
	if ((year<1970) || (year>2070))
	{
		myprintf("00051! year not from 1970 to 2070\n");
		return -1;
	}
	if ((month<1) || (month>12))
	{
		myprintf("00052! month not in [01..12]. Use leading zero (not 3 but 03)\n");
		return -1;
	}
	if ((day<1) || (day>31))
	{
		myprintf("00053! day not in [01..31]. Use leading zero (not 4 but 04)\n");
		return -1;
	}
	if (hour>24)
	{
		myprintf("00054! hour >24\n");
		return -1;
	}
	if (minute>60)
	{
		myprintf("00055! minute >60\n");
		return -1;
	}
	if (second>60)
	{
		myprintf("00056! second >60\n");
		return -1;
	}
	bool isleap= (((year % 4 == 0) &&
         (year % 100 != 0)) ||
         (year % 400 == 0));

    if (month == 2)
    {
        if (isleap)
		{
			if (!(day <=29))
			{
				myprintf("00057! leap year, feb must be <=29\n");
				return -1;
			}
		}
        else
			if (!(day <=28))
			{
				myprintf("00058! NO leap year, feb must be <=28\n");
				return -1;
			}
    }
    if ((month==4) || (month==6) || (month==9) || (month==11))
		if (!(day <= 30))
		{
			myprintf("00059! this month (%d) cannot have more than 30 days\n",month);
			return -1;
		}

	return 	year	*10000000000LL
		+	month	*100000000LL
		+	day		*1000000
		+	hour	*10000
		+	minute	*100
		+	second;
}


// Convert non-negative decimal number x to string of at least n digits
string itos(int64_t x, int n=1) {
  assert(x>=0);
  assert(n>=0);
  string r;
  for (; x || n>0; x/=10, --n) r=string(1, '0'+x%10)+r;
  return r;
}
// Replace * and ? in fn with part or digits of part
string subpart(string fn, int part) {
  for (int j=fn.size()-1; j>=0; --j) {
    if (fn[j]=='?')
      fn[j]='0'+part%10, part/=10;
    else if (fn[j]=='*')
      fn=fn.substr(0, j)+itos(part)+fn.substr(j+1), part=0;
  }
  return fn;
}
// Return relative time in milliseconds
/// Slow, working on string instead of char *. But who cares?
#define NO_WARNING_PLEASE 36

string internalutctolocal(const string& i_date)
{
	if (flagdebug3)
	{
		myprintf("\n");
		myprintf("00060: converting to localtime %s\n",i_date.c_str());
	}
	
	if (i_date.length()!=19)
	{
		myprintf("25854$ i_date is not 19 chars long |%s|\n",i_date.c_str());
		return i_date;
	}

	struct tm t;
	memset(&t,0,sizeof(t));
	t.tm_year 	= atoi(i_date.c_str())-1900;
	t.tm_mon 	= atoi(i_date.c_str()+5)-1;
	t.tm_mday 	= atoi(i_date.c_str()+8);
	t.tm_hour 	= atoi(i_date.c_str()+11);
	t.tm_min 	= atoi(i_date.c_str()+14);
	t.tm_sec 	= atoi(i_date.c_str()+17);


#ifdef _WIN32
//
#ifdef _WIN64
	time_t tt = _mkgmtime64(&t);
#else

time_t tt =-1;
///	time_t tt = _mkgmtime32(&t);
#endif // corresponds to #ifdef (#ifdef _WIN64)
	if (tt==-1)
		return i_date;
	struct tm* t2=NULL;
	t2 = &t;
	*t2 = *localtime(&tt);
#else
	/// not Windows
	time_t utcTime = timegm(&t); // converte in UTC
	const struct tm* t2 = localtime(&utcTime);
	if (t2==NULL)
	{
		myprintf("25871$ ERROR in localtime!\n");
		return i_date;
	}
#endif // corresponds to #ifdef (#ifdef _WIN32)
	char ds[NO_WARNING_PLEASE];
	memset(ds,0,NO_WARNING_PLEASE);
	
	snprintf(ds,NO_WARNING_PLEASE, "%04d-%02d-%02d %02d:%02d:%02d",
         t2->tm_year + 1900,
         t2->tm_mon + 1,
         t2->tm_mday,
         t2->tm_hour,
         t2->tm_min,
         t2->tm_sec);
		 
	///snprintf(ds,sizeof(ds),"%.4d-%.2d-%.2d %.2d:%.2d:%.2d", t2->tm_year + 1900,t2->tm_mon + 1, t2->tm_mday, t2->tm_hour, t2->tm_min, t2->tm_sec);
	if (flagdebug)
		myprintf("00061: localtime is %s\n",ds);
	return ds;
}

string ConvertUtcToLocalTime(const string& i_date)
{
	if (iswindowsxp()) 	/// Windows XP, Windows Server 2003
	{
		if (flagdebug3)
		{
			color_cyan();
			printbar('+');
			myprintf("29643: WARNING: XP or 2003, do not convert to local time!\n");
			color_restore();
		}
		return i_date;
	}
	return internalutctolocal(i_date);
}

// Convert 64 bit decimal YYYYMMDDHHMMSS to "YYYY-MM-DD HH:MM:SS"
// where -1 = unknown date, 0 = deleted.
string dateToString(bool i_flagutc,int64_t date,bool i_mylocal=false)
{
  if (date<=0) return "                   ";
  string s="0000-00-00 00:00:00";
  static const int t[]={18,17,15,14,12,11,9,8,6,5,3,2,1,0};
  for (int i=0; i<14; ++i) s[t[i]]+=int(date%10), date/=10;
  if (!i_flagutc)
  {
	s=ConvertUtcToLocalTime(s);
  }
  if (i_mylocal)
  {
	///string "0000-00-00 00:00:00";
		///	0123 56 89 12345
	char mylocal[30];
	mylocal[ 0]=s.at(8);
	mylocal[ 1]=s.at( 9);
	mylocal[ 2]='/';
	mylocal[ 3]=s.at( 5);
	mylocal[ 4]=s.at( 6);
	mylocal[ 5]='/';
	mylocal[ 6]=s.at( 0);
	mylocal[ 7]=s.at( 1);
	mylocal[ 8]=s.at( 2);
	mylocal[ 9]=s.at( 3);
	mylocal[10]=' ';
	mylocal[11]=' ';
	mylocal[12]=s.at(11);
	mylocal[13]=s.at(12);
	mylocal[14]=s.at(13);
	mylocal[15]=s.at(14);
	mylocal[16]=s.at(15);
	mylocal[17]=0;
	s=mylocal;
  }
  return s;
}

string dateToString_forcedlocal(bool i_flagutc,int64_t date)
{
  if (date<=0) 
	  return "                   ";
  string s="0000-00-00 00:00:00";
  static const int t[]={18,17,15,14,12,11,9,8,6,5,3,2,1,0};
  for (int i=0; i<14; ++i) s[t[i]]+=int(date%10), date/=10;
  if (!i_flagutc)
  {
		s=internalutctolocal(s);
		///myprintf("Converted to local %s\n",s.c_str());
  }
  return s;
}


int64_t nowutc()
{
	time_t 	mynow=time(NULL);
	const tm* 	t=gmtime(&mynow);  // <-- gmtime invece di localtime
	if (t==NULL)
		return 0;
	return	(t->tm_year+1900)	*10000000000LL
		+	(t->tm_mon+1)		*100000000LL
		+	t->tm_mday			*1000000
		+	t->tm_hour			*10000
		+	t->tm_min			*100
		+	t->tm_sec;
}

int64_t now()
{
	time_t 	mynow=time(NULL);
	const tm* 	t=localtime(&mynow);
	if (t==NULL)
		return 0;
	return	(t->tm_year+1900)	*10000000000LL
		+	(t->tm_mon+1)		*100000000LL
		+	t->tm_mday			*1000000
		+	t->tm_hour			*10000
		+	t->tm_min			*100
		+	t->tm_sec;
}

string attrToString(int64_t attrib) {
  string r="     ";
  if ((attrib&255)=='u') {
    r[0]="0pc3d5b7 9lBsDEF"[(attrib>>20)&15];
    for (int i=0; i<4; ++i)
      r[4-i]=(attrib>>(8+3*i))%8+'0';
  }
  else if ((attrib&255)=='w') {
    for (int i=0, j=0; i<32; ++i) {
      if ((attrib>>(i+8))&1) {
        char c="RHS DAdFTprCoIEivs89012345678901"[i];
        if (j<5) r[j]=c;
        else r+=c;
        ++j;
      }
    }
  }
  return r;
}
// Convert seconds since 0000 1/1/1970 to 64 bit decimal YYYYMMDDHHMMSS
// Valid from 1970 to 2099.
int64_t decimal_time(time_t tt) {
  if (tt==-1) tt=0;
  int64_t t=(sizeof(tt)==4) ? unsigned(tt) : tt;
  const int second=t%60;
  const int minute=t/60%60;
  const int hour=t/3600%24;
  t/=86400;  // days since Jan 1 1970
  const int term=t/1461;  // 4 year terms since 1970
  t%=1461;
  t+=(t>=59);  // insert Feb 29 on non leap years
  t+=(t>=425);
  t+=(t>=1157);
  const int year=term*4+t/366+1970;  // actual year
  t%=366;
  t+=(t>=60)*2;  // make Feb. 31 days
  t+=(t>=123);   // insert Apr 31
  t+=(t>=185);   // insert June 31
  t+=(t>=278);   // insert Sept 31
  t+=(t>=340);   // insert Nov 31
  const int month=t/31+1;
  const int day=t%31+1;
  return year*10000000000LL+month*100000000+day*1000000
         +hour*10000+minute*100+second;
}
// Convert decimal date to time_t - inverse of decimal_time()
time_t unix_time(int64_t date) {
  if (date<=0) return -1;
  static const int days[12]={0,31,59,90,120,151,181,212,243,273,304,334};
  const int year=date/10000000000LL%10000;
  const int month=(date/100000000%100-1)%12;
  const int day=date/1000000%100;
  const int hour=date/10000%100;
  const int min=date/100%100;
  const int sec=date%100;
  if (month<0)
	  return 0;
  return (day-1+days[month]+(year%4==0 && month>1)+((year-1970)*1461+1)/4)
    *86400+hour*3600+min*60+sec;
}
/*
	section: errors
*/
#ifdef BSD
int64_t fsbtoblk(int64_t num, uint64_t fsbs, u_long bs)
{
	return (num * (intmax_t) fsbs / (int64_t) bs);
}
#endif // corresponds to #ifdef (#ifdef BSD)

#ifdef _WIN32
bool isdospath(const string& i_filename)
{
	if (i_filename.size()>3)
		if (isalpha(i_filename[0]))
			if (i_filename[1]==':')
					return true;
	return false;
}
#endif // corresponds to #ifdef (#ifdef _WIN32)


bool iswindowspath(const string& i_filename)
{
///	printf("Y1 |%s|\n",i_filename.c_str());
	if (i_filename.size()>3)
		if (isalpha(i_filename[0]))
			if (i_filename[1]==':')
				if ((i_filename[2]=='\\') || (i_filename[2]=='/'))
				{
				//	printf("trueeeeeeeeeeeeeee\n");
					return true;
				} 
	return false;
}
bool iswindowsunc(const string& i_filename)
{
	if (i_filename=="")
			return false;
	if (i_filename.size()<3)
			return false;
	if (i_filename[0]!='/')
			return false;
	if (i_filename[2]=='?') // longpath
	{
		if (i_filename.size()>5) 
			if (i_filename[5]==':')
				return false;
		return true;
	}
	bool	foundslash=false;
	for (unsigned int i=3;i<i_filename.size();i++)
		if (i_filename[i]=='/')
		{
			foundslash=true;
			break;
		}

	return foundslash;
}
#ifdef _WIN32
string getfirstwindowsuncdir(const string& i_filename)
{
	if (i_filename=="")
			return "";
	if (i_filename[0]!='/')
			return "";
	if (i_filename[1]!='/')
			return "";
	string	theserver="";
	string 	theshare="";
	string 	firstshare="";
	for (unsigned int i=3;i<i_filename.size();i++)
		if (i_filename[i]=='/')
		{
			theserver=i_filename.substr(0,i+1);
			theshare=i_filename.substr(i+1,i_filename.size());
			break;
		}
	for (unsigned int i=0;i<theshare.size();i++)
		if (theshare[i]=='/')
		{
			firstshare=theshare.substr(0,i);
			break;
		}
	return theserver+firstshare;
}
#endif // corresponds to #ifdef (#ifdef _WIN32)


#ifdef _WIN32

// Function to prepare the path for long paths
std::wstring preparelongpath(const std::wstring& path) 
{
    if (path.empty()) 
		return path;
    // Do not modify if it is already a long path or UNC
    if (path.substr(0, 4) == L"\\\\?\\" || path.substr(0, 2) == L"\\\\") 
        return path;
    // Aggiungi \\?\ per percorsi assoluti
    if (path[0] == L'\\' || (path.length() > 1 && path[1] == L':')) 
        return L"\\\\?\\" + path;
    return path;
}
#endif

bool direxists(const std::string& i_directory) {
#ifdef unix
    struct stat sb;
    return (stat(i_directory.c_str(), &sb) == 0 && S_ISDIR(sb.st_mode));
#endif
#ifdef _WIN32
    if (i_directory.empty()) return false;

    // Convert the path to wstring
    std::wstring wdirectory = utow(i_directory.c_str());
    wdirectory = preparelongpath(wdirectory);

    // Use GetFileAttributesW to check for the existence of the directory
    DWORD attrib = GetFileAttributesW(wdirectory.c_str());
    if (attrib == INVALID_FILE_ATTRIBUTES) 
        return false; // Directorydoes not exist or error
    return (attrib & FILE_ATTRIBUTE_DIRECTORY) != 0; // Verifica che sia a directory
#endif
    return false; // Fallback for unsupported systems
}

#ifdef _WIN32
string	trimbarra(string i_path)
{
	if (isdirectory(i_path))
		return i_path.substr(0, i_path.size()-1);
	return i_path;
}
string	makeshortpath(string i_path)
{
	if (islongpath(i_path))
		return myright(i_path,i_path.size()-4);
	return i_path;
}
#endif // corresponds to #ifdef (#ifdef _WIN32)
string makelongpath(string i_path)
{
#ifdef _WIN32
	if (flaglongpath)
	{
		if (flagdebug3)
			myprintf("00062: makelongpath of %s\n",i_path.c_str());

		if (iswindowspath(i_path))
		{
			if (flagdebug3)
				myprintf("00063: it is a windows path |%s|\n",i_path.c_str());

			if (!islongpath(i_path))
			{
				if (flagdebug3)
					myprintf("00064: this is NOT a longpath |%s|\n",i_path.c_str());
				return "//?/"+i_path;
			}
		}
		else
		{
			if (flagdebug3)
				myprintf("00065: NOT a iswindowspath |%s|\n",i_path.c_str());
		}
	}
#endif // corresponds to #ifdef (#ifdef _WIN32)
	if (flagdebug2)
		myprintf("00066: return makelongpath i_path |%s|\n",i_path.c_str());
	return i_path;
}
/// it is not easy, at all, to take *nix free filesystem space
int64_t getfreespace(string i_path)
{
#ifndef _WIN32
	if (i_path!="")
		if (!direxists(i_path))
		{
			myprintf("00067! Path does not exists %Z\n",i_path.c_str());
			
			vector<string> pezzi;
			explode(i_path,'/',pezzi);
			if (pezzi.size()>=2)
			{
				string percorso="/";
				for (unsigned int i=1;i<pezzi.size()-1;i++)
					percorso+=pezzi[i]+"/";
				if (percorso!="/")
				{
					
					if (direxists(percorso))
						myprintf("00071: Getting free space for %Z\n",percorso.c_str());
					else
						myprintf("00072! Sorry: cannot find the path heuristically %Z\n",percorso.c_str());
										
				}
			}
		}
#endif // corresponds to #ifndef (#ifndef _WIN32)

#ifdef BSD

#ifdef __NetBSD__
	if (flagdebug)
		myprintf("26116: NetBSD: getfreespace\n");
    struct statvfs stat;
	if (statvfs(i_path.c_str(), &stat) != 0) 
	{
        myprintf("26122$ NetBSD statvfs KAPUTT\n");
        return 0;
    }
	return (int64_t)stat.f_frsize * (int64_t)stat.f_bfree;
		
	///return (int64_t)stat.f_bsize * (int64_t)stat.f_bfree;
#else
	if (flagdebug)
		myprintf("00073: BSD: getfreespace\n");
	struct statfs stat;
	if (statfs(i_path.c_str(),&stat)!=0)
		return 0;
	static long blocksize = 0;
	int dummy;
	if (blocksize == 0)
		getbsize(&dummy, &blocksize);
	return  fsbtoblk(stat.f_bavail,stat.f_bsize, blocksize)*1024;
#endif // corresponds to #ifdef (#ifdef __NetBSD__)
	
	
#else
#if defined(__linux__) || (defined(__APPLE__) && defined(__MACH__) && (!defined(__ppc__))) || defined(SOLARIS)
	if (flagdebug)
		myprintf("00074: LINUX: getfreespace\n");
	struct statvfs stat;
	if (statvfs(i_path.c_str(),&stat)!=0)
		return 0;
	return stat.f_bsize * stat.f_bavail;
#endif // corresponds to #if (#if defined(__linux__) || (defined(__APPLE__) && defined(__MACH__) && (!defined(__ppc__))) || defined(SOLARIS))
#endif // corresponds to #ifdef (#ifdef BSD)
#ifdef _WIN32
	uint64_t spazio=0;
	i_path=makeshortpath(i_path);
	if (iswindowsunc(i_path))
	{
		string mydir=getfirstwindowsuncdir(i_path);
		i_path=mydir;
	}
	BOOL  fResult;
	unsigned __int64 i64FreeBytesToCaller,i64TotalBytes,i64FreeBytes;
	WCHAR  *pszDrive  = NULL, szDrive[4];
	const size_t WCHARBUF = 512;
	wchar_t  wszDest[WCHARBUF];
	MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, i_path.c_str(), -1, wszDest, WCHARBUF);
	pszDrive = wszDest;
	if (i_path[1] == ':')
	{
		szDrive[0] = pszDrive[0];
		szDrive[1] = ':';
        szDrive[2] = '\\';
        szDrive[3] = '\0';
		pszDrive = szDrive;
	}
	fResult = GetDiskFreeSpaceEx ((LPCTSTR)pszDrive,
                                 (PULARGE_INTEGER)&i64FreeBytesToCaller,
                                 (PULARGE_INTEGER)&i64TotalBytes,
                                 (PULARGE_INTEGER)&i64FreeBytes);
	if (fResult)
		spazio=i64FreeBytes;
	return spazio; // Windows
#endif // corresponds to #ifdef (#ifdef _WIN32)
	myprintf("00075! WARNING CANNOT GET FREE DISK SPACE!\n");
	return 0;
}
#ifdef unix
void printerr(const char* i_where,const char* filename,int32_t i_fileattr)
{
	if (flagquiet)
		return;
	string lasterror=i_where;
	string lasterror2=filename;
	string risultato=lasterror+"!"+lasterror2;
	if (i_fileattr==777442)
		lasterror="COMPILER_BE_QUIET";
	perror(risultato.c_str());
}
#else
string decodewinattribute(int32_t i_attribute)
{
	string risultato="";
	if (i_attribute & FILE_ATTRIBUTE_ARCHIVE)
		risultato+="ARCHIVE;";
	if (i_attribute & FILE_ATTRIBUTE_COMPRESSED)
		risultato+="COMPRESSED;";
	if (i_attribute & FILE_ATTRIBUTE_DEVICE)
		risultato+="DEVICE;";
	if (i_attribute & FILE_ATTRIBUTE_DIRECTORY)
		risultato+="DIRECTORY;";
	if (i_attribute & FILE_ATTRIBUTE_ENCRYPTED)
		risultato+="ENCRYPTED;";
	if (i_attribute & FILE_ATTRIBUTE_HIDDEN)
		risultato+="HIDDEN;";
	if (i_attribute & 32768)
		risultato+="INTEGRITY_STREAM;";
	if (i_attribute & FILE_ATTRIBUTE_NORMAL)
		risultato+="NORMAL;";
	if (i_attribute & FILE_ATTRIBUTE_NOT_CONTENT_INDEXED)
		risultato+="NOT_CONTENT_INDEXED;";
	if (i_attribute & 131072)
		risultato+="NO_SCRUB_DATA;";
	if (i_attribute & FILE_ATTRIBUTE_OFFLINE)
		risultato+="OFFLINE;";
	if (i_attribute & FILE_ATTRIBUTE_READONLY)
		risultato+="READONY;";
	if (i_attribute & 4194304 )
		risultato+="RECALL_ON_DATA_ACCESS;";
	if (i_attribute & 262144 )
		risultato+="RECALL_ON_OPEN;";
	if (i_attribute & FILE_ATTRIBUTE_REPARSE_POINT)
		risultato+="REPARSE_POINT;";
	if (i_attribute & FILE_ATTRIBUTE_SPARSE_FILE)
		risultato+="SPARSE_FILE;";
	if (i_attribute & FILE_ATTRIBUTE_SYSTEM)
		risultato+="SYSTEM;";
	if (i_attribute & FILE_ATTRIBUTE_TEMPORARY)
		risultato+="TEMPORARY;";
	if (i_attribute & FILE_ATTRIBUTE_VIRTUAL)
		risultato+="VIRTUAL;";
	return risultato;
}
string decodewinerror(DWORD i_error, const char* i_filename)
{
    string risultato = "";
    char buffer[100];
    
    // Use FormatMessage to automatically get the error description
    LPSTR messageBuffer = nullptr;
    size_t size = FormatMessageA(
        FORMAT_MESSAGE_ALLOCATE_BUFFER | 
        FORMAT_MESSAGE_FROM_SYSTEM | 
        FORMAT_MESSAGE_IGNORE_INSERTS,
        NULL,
        i_error,
        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
        (LPSTR)&messageBuffer,
        0,
        NULL
    );
    
    if (size > 0 && messageBuffer != nullptr) 
	{
        // Converti il messaggio in string e rimuovi eventuali \r\n finali
        risultato = string(messageBuffer, size);
        LocalFree(messageBuffer);
        
        // Remove end-of-line characters
        while (!risultato.empty() && (risultato.back() == '\n' || risultato.back() == '\r')) 
		    risultato.pop_back();
        
        
        // Sanitize non-ASCII characters and replace spaces with underscores
        string sanitized = "";
        for (char c : risultato) 
		{
			if (c=='.')
			{
			}
			else
            if (static_cast<unsigned char>(c) >= 128) 
			{
                // Non-ASCII character - replace with ASCII equivalent
                switch (static_cast<unsigned char>(c)) 
				{
                    case 0xC0: case 0xC1: case 0xC2: case 0xC3: case 0xC4: case 0xC5: //  Á Â Ã Ä Å
                        sanitized += 'A'; break;
                    case 0xE0: case 0xE1: case 0xE2: case 0xE3: case 0xE4: case 0xE5: //  á â ã ä å
                        sanitized += 'A'; break;
                    case 0xC8: case 0xC9: case 0xCA: case 0xCB: //  É Ê Ë
                        sanitized += 'E'; break;
                    case 0xE8: case 0xE9: case 0xEA: case 0xEB: //  é ê ë
                        sanitized += 'E'; break;
                    case 0xCC: case 0xCD: case 0xCE: case 0xCF: //  Í Î Ï
                        sanitized += 'I'; break;
                    case 0xEC: case 0xED: case 0xEE: case 0xEF: //  í î ï
                        sanitized += 'I'; break;
                    case 0xD2: case 0xD3: case 0xD4: case 0xD5: case 0xD6: case 0xD8: //  Ó Ô Õ Ö Ø
                        sanitized += 'O'; break;
                    case 0xF2: case 0xF3: case 0xF4: case 0xF5: case 0xF6: case 0xF8: //  ó ô õ ö ø
                        sanitized += 'O'; break;
                    case 0xD9: case 0xDA: case 0xDB: case 0xDC: //  Ú Û Ü
                        sanitized += 'U'; break;
                    case 0xF9: case 0xFA: case 0xFB: case 0xFC: //  ú û ü
                        sanitized += 'U'; break;
                    case 0xD1: // Ñ
                        sanitized += 'N'; break;
                    case 0xF1: // ñ
                        sanitized += 'N'; break;
                    case 0xC7: // Ç
                        sanitized += 'C'; break;
                    case 0xE7: // ç
                        sanitized += 'C'; break;
                    default:
                        sanitized += '?'; // Unknown character
                        break;
				}
			} 
			else 
			if (c == ' ') 
			{
                sanitized += '_';
            } 
			else 
			{
                sanitized += c;
            }
        }
        risultato = sanitized;
        
        // Convert to uppercase to maintain the original style
        transform(risultato.begin(), risultato.end(), risultato.begin(), ::toupper);
    } 
	else 
	{
        // Fallback for errors not recognized by the system
        snprintf(buffer, sizeof(buffer), "WINDOWS_ERROR_#_%ld", i_error);
        risultato = buffer;
    }
    
    // Special handling for ERROR_PATH_NOT_FOUND (code 3)

	if ((i_error == 3L) && (i_filename)) 
	{
		if (strlen(i_filename) > 255) 
		{
			snprintf(buffer, sizeof(buffer), "%08d", (int)strlen(i_filename));
			string lunghezza = buffer;
			risultato += "_:_MAYBE_LENGTH_" + lunghezza + "_>255?";
			g_255++;
		}
	}

	while (!risultato.empty() && (risultato.back() == '.'))
	    risultato.pop_back();
        
	unsigned int error_len=30;
    // Padding per mantenere lunghezza minima di 25 caratteri come nell'originale
    if (risultato.size() > error_len) 
	{
       risultato = risultato.substr(0,error_len);
    } 
	else 
	{
        while (risultato.size()<error_len) 
            risultato += " ";
    }
    
    return risultato;
}


void	enumerateerrors()
{
	if (g_errors.size()==0)
	{
		myprintf("00076: no file errors tracked\n");
		return;
	}
	myprintf("\n");
	myprintf("00077: File errors report\n");
	for (MAPPAERRORS::iterator p=g_errors.begin(); p!=g_errors.end(); ++p)
	{
		myprintf("00078! Error %08d # %8s |%s| \n",p->first,migliaia((int64_t)p->second.counter),decodewinerror(p->first,NULL).c_str());
		if (flagdebug2)
		{
			for (unsigned int i=0;i<p->second.filenames.size();i++)
			{
				printUTF8(p->second.filenames[i].c_str());
				myprintf(">>\n");
				myprintf("%08X %s\n",p->second.attrs[i],decodewinattribute(p->second.attrs[i]).c_str());
			}
			printbar('-');
		}
	}
}
void printerr(const char* i_where,const char* filename,int32_t i_fileattr)
{
	if (flagignore)
		return;
	int err=GetLastError();
	MAPPAERRORS::iterator a=g_errors.find(err);
	if (a!=g_errors.end())
	{
		a->second.counter++;
		if (filename)
		{
			a->second.filenames.push_back(filename);
			a->second.attrs.push_back(i_fileattr);
		}
	}
	else
	{
		s_error myblock;
		myblock.counter=1;
		if (filename)
		{
			myblock.filenames.push_back(filename);
			myblock.attrs.push_back(i_fileattr);
		}
		g_errors.insert(std::pair<int,s_error>(err,myblock));
	}
	string swhere=i_where;

	unsigned int error_len=7;
	if (swhere.size() > error_len) 
	{
        swhere=swhere.substr(0,error_len);
    } 
	else 
	{
        while (swhere.size()<error_len) 
            swhere+= " ";
    }
   
	g_exec_text=swhere+": "+decodewinerror(err,filename);
	if (!flagquiet)
	{
		myprintf("\r");
		printbar(' ',false);
		myprintf("\r");
		color_red();
		myprintf("%s %Z\n",g_exec_text.c_str(),filename);
		color_restore();
	}
	g_exec_text=g_exec_text+" "+filename;
	if (filename)
	{
		uint64_t spazio=getfreespace(filename);
		if (spazio<16384)
		{
			string mypath=filename;
			if (direxists(mypath))
			{
				myprintf("\n\n");
				myprintf("00080! MAYBE OUT OF FREE SPACE? %s\n",i_where);
			}
			else
			{
				myprintf("\n\n");
				myprintf("00081! MAYBE OUT OF FREE SPACE OR INVALID PATH? %s\n",i_where);
			}
		}
	}
}
#endif // corresponds to #ifdef (#ifdef unix)
void ioerr(const char* msg)
{
  printerr("ioerr",msg,0);
  throw std::runtime_error(msg);
}
/*
	checksum section
*/

/// LICENSE_START.10
/////////////////// calculate CRC32
// //////////////////////////////////////////////////////////
// Crc32.h
// Copyright (c) 2011-2019 Stephan Brumme. All rights reserved.
// Slicing-by-16 contributed by Bulat Ziganshin
// Tableless bytewise CRC contributed by Hagai Gold
// see http://create.stephan-brumme.com/disclaimer.html
//
uint32_t crc32_combine (uint32_t crcA, uint32_t crcB, size_t lengthB);
uint32_t crc32_16bytes (const void* data, size_t length, uint32_t previousCrc32 = 0);
///  #include <sys/param.h>
  #ifdef __GNUC__
    #define PREFETCH(location) __builtin_prefetch(location)
  #else
    #define PREFETCH(location) ;
  #endif // corresponds to #ifdef (#ifdef __GNUC__)
///#endif
namespace
{
  const uint32_t Polynomial = 0xEDB88320;

  /// Slicing-By-16
  const size_t MaxSlice = 16;
} // anonymous namespace
extern const uint32_t Crc32Lookup[MaxSlice][256]; // extern is needed to keep compiler happy

#define POLYNOMIAL 0xEDB88320

uint32_t crc32_16bytes(const void* data, size_t length, uint32_t previousCrc32)
{
#ifdef ALIGNMALLOC
{
    const uint8_t* bytes = (const uint8_t*) data;
    uint32_t crc = ~previousCrc32;
    while (length--) 
	{
        crc ^= *bytes++;
        for (int i = 0; i < 8; i++) 
		if (crc & 1) 
		  crc = (crc >> 1) ^ POLYNOMIAL;
		else 
			crc >>= 1;
    }
    return ~crc;
}

#else

  uint32_t crc = ~previousCrc32; // same as previousCrc32 ^ 0xFFFFFFFF
  const uint32_t* current = (const uint32_t*) data;
  // enabling optimization (at least -O2) automatically unrolls the inner for-loop
  const size_t Unroll = 4;
  const size_t BytesAtOnce = 16 * Unroll;
  while (length >= BytesAtOnce)
  {
    for (size_t unrolling = 0; unrolling < Unroll; unrolling++)
    {
#if __BYTE_ORDER == __BIG_ENDIAN
    uint32_t one   = *current++ ^ swap(crc);
    uint32_t two   = *current++;
    uint32_t three = *current++;
    uint32_t four  = *current++;
    crc  = Crc32Lookup[ 0][ four         & 0xFF] ^
           Crc32Lookup[ 1][(four  >>  8) & 0xFF] ^
           Crc32Lookup[ 2][(four  >> 16) & 0xFF] ^
           Crc32Lookup[ 3][(four  >> 24) & 0xFF] ^
           Crc32Lookup[ 4][ three        & 0xFF] ^
           Crc32Lookup[ 5][(three >>  8) & 0xFF] ^
           Crc32Lookup[ 6][(three >> 16) & 0xFF] ^
           Crc32Lookup[ 7][(three >> 24) & 0xFF] ^
           Crc32Lookup[ 8][ two          & 0xFF] ^
           Crc32Lookup[ 9][(two   >>  8) & 0xFF] ^
           Crc32Lookup[10][(two   >> 16) & 0xFF] ^
           Crc32Lookup[11][(two   >> 24) & 0xFF] ^
           Crc32Lookup[12][ one          & 0xFF] ^
           Crc32Lookup[13][(one   >>  8) & 0xFF] ^
           Crc32Lookup[14][(one   >> 16) & 0xFF] ^
           Crc32Lookup[15][(one   >> 24) & 0xFF];
#else
    uint32_t one   = *current++ ^ crc;
    uint32_t two   = *current++;
    uint32_t three = *current++;
    uint32_t four  = *current++;
    crc  = Crc32Lookup[ 0][(four  >> 24) & 0xFF] ^
           Crc32Lookup[ 1][(four  >> 16) & 0xFF] ^
           Crc32Lookup[ 2][(four  >>  8) & 0xFF] ^
           Crc32Lookup[ 3][ four         & 0xFF] ^
           Crc32Lookup[ 4][(three >> 24) & 0xFF] ^
           Crc32Lookup[ 5][(three >> 16) & 0xFF] ^
           Crc32Lookup[ 6][(three >>  8) & 0xFF] ^
           Crc32Lookup[ 7][ three        & 0xFF] ^
           Crc32Lookup[ 8][(two   >> 24) & 0xFF] ^
           Crc32Lookup[ 9][(two   >> 16) & 0xFF] ^
           Crc32Lookup[10][(two   >>  8) & 0xFF] ^
           Crc32Lookup[11][ two          & 0xFF] ^
           Crc32Lookup[12][(one   >> 24) & 0xFF] ^
           Crc32Lookup[13][(one   >> 16) & 0xFF] ^
           Crc32Lookup[14][(one   >>  8) & 0xFF] ^
           Crc32Lookup[15][ one          & 0xFF];
#endif // corresponds to #if (#if __BYTE_ORDER == __BIG_ENDIAN)
    }
    length -= BytesAtOnce;
  }
  const uint8_t* currentChar = (const uint8_t*) current;
  // remaining 1 to 63 bytes (standard algorithm)
  while (length-- != 0)
    crc = (crc >> 8) ^ Crc32Lookup[0][(crc & 0xFF) ^ *currentChar++];
  return ~crc; // same as crc ^ 0xFFFFFFFF
#endif // corresponds to #ifdef (#ifdef ALIGNMALLOC)
}
/// merge two CRC32 such that result = crc32(dataB, lengthB, crc32(dataA, lengthA))
uint32_t crc32_combine(uint32_t crcA, uint32_t crcB, size_t lengthB)
{
  // degenerated case
  if (lengthB == 0)
    return crcA;
  /// CRC32 => 32 bits
  const uint32_t CrcBits = 32;
  uint32_t odd [CrcBits]; // odd-power-of-two  zeros operator
  uint32_t even[CrcBits]; // even-power-of-two zeros operator
  // put operator for one zero bit in odd
  odd[0] = Polynomial;    // CRC-32 polynomial
  for (unsigned int i = 1; i < CrcBits; i++)
    odd[i] = 1 << (i - 1);
  // put operator for two zero bits in even
  // same as gf2_matrix_square(even, odd);
  for (unsigned int i = 0; i < CrcBits; i++)
  {
    uint32_t vec = odd[i];
    even[i] = 0;
    for (int j = 0; vec != 0; j++, vec >>= 1)
      if (vec & 1)
        even[i] ^= odd[j];
  }
  // put operator for four zero bits in odd
  // same as gf2_matrix_square(odd, even);
  for (unsigned int i = 0; i < CrcBits; i++)
  {
    uint32_t vec = even[i];
    odd[i] = 0;
    for (int j = 0; vec != 0; j++, vec >>= 1)
      if (vec & 1)
        odd[i] ^= even[j];
  }
  // the following loop becomes much shorter if I keep swapping even and odd
  uint32_t* a = even;
  uint32_t* b = odd;
  // apply secondLength zeros to firstCrc32
  for (; lengthB > 0; lengthB >>= 1)
  {
    // same as gf2_matrix_square(a, b);
    for (unsigned int i = 0; i < CrcBits; i++)
    {
      uint32_t vec = b[i];
      a[i] = 0;
      for (int j = 0; vec != 0; j++, vec >>= 1)
        if (vec & 1)
          a[i] ^= b[j];
    }
    // apply zeros operator for this bit
    if (lengthB & 1)
    {
      // same as firstCrc32 = gf2_matrix_times(a, firstCrc32);
      uint32_t sum = 0;
      for (int i = 0; crcA != 0; i++, crcA >>= 1)
        if (crcA & 1)
          sum ^= a[i];
      crcA = sum;
    }
    // switch even and odd
    uint32_t* t = a; a = b; b = t;
  }
  // return combined crc
  return crcA ^ crcB;
}
// //////////////////////////////////////////////////////////
// constants
/// look-up table, already declared above
const uint32_t Crc32Lookup[MaxSlice][256] =
{
  {
    // note: the first number of every second row corresponds to the half-byte look-up table !
    0x00000000,0x77073096,0xEE0E612C,0x990951BA,0x076DC419,0x706AF48F,0xE963A535,0x9E6495A3,
    0x0EDB8832,0x79DCB8A4,0xE0D5E91E,0x97D2D988,0x09B64C2B,0x7EB17CBD,0xE7B82D07,0x90BF1D91,
    0x1DB71064,0x6AB020F2,0xF3B97148,0x84BE41DE,0x1ADAD47D,0x6DDDE4EB,0xF4D4B551,0x83D385C7,
    0x136C9856,0x646BA8C0,0xFD62F97A,0x8A65C9EC,0x14015C4F,0x63066CD9,0xFA0F3D63,0x8D080DF5,
    0x3B6E20C8,0x4C69105E,0xD56041E4,0xA2677172,0x3C03E4D1,0x4B04D447,0xD20D85FD,0xA50AB56B,
    0x35B5A8FA,0x42B2986C,0xDBBBC9D6,0xACBCF940,0x32D86CE3,0x45DF5C75,0xDCD60DCF,0xABD13D59,
    0x26D930AC,0x51DE003A,0xC8D75180,0xBFD06116,0x21B4F4B5,0x56B3C423,0xCFBA9599,0xB8BDA50F,
    0x2802B89E,0x5F058808,0xC60CD9B2,0xB10BE924,0x2F6F7C87,0x58684C11,0xC1611DAB,0xB6662D3D,
    0x76DC4190,0x01DB7106,0x98D220BC,0xEFD5102A,0x71B18589,0x06B6B51F,0x9FBFE4A5,0xE8B8D433,
    0x7807C9A2,0x0F00F934,0x9609A88E,0xE10E9818,0x7F6A0DBB,0x086D3D2D,0x91646C97,0xE6635C01,
    0x6B6B51F4,0x1C6C6162,0x856530D8,0xF262004E,0x6C0695ED,0x1B01A57B,0x8208F4C1,0xF50FC457,
    0x65B0D9C6,0x12B7E950,0x8BBEB8EA,0xFCB9887C,0x62DD1DDF,0x15DA2D49,0x8CD37CF3,0xFBD44C65,
    0x4DB26158,0x3AB551CE,0xA3BC0074,0xD4BB30E2,0x4ADFA541,0x3DD895D7,0xA4D1C46D,0xD3D6F4FB,
    0x4369E96A,0x346ED9FC,0xAD678846,0xDA60B8D0,0x44042D73,0x33031DE5,0xAA0A4C5F,0xDD0D7CC9,
    0x5005713C,0x270241AA,0xBE0B1010,0xC90C2086,0x5768B525,0x206F85B3,0xB966D409,0xCE61E49F,
    0x5EDEF90E,0x29D9C998,0xB0D09822,0xC7D7A8B4,0x59B33D17,0x2EB40D81,0xB7BD5C3B,0xC0BA6CAD,
    0xEDB88320,0x9ABFB3B6,0x03B6E20C,0x74B1D29A,0xEAD54739,0x9DD277AF,0x04DB2615,0x73DC1683,
    0xE3630B12,0x94643B84,0x0D6D6A3E,0x7A6A5AA8,0xE40ECF0B,0x9309FF9D,0x0A00AE27,0x7D079EB1,
    0xF00F9344,0x8708A3D2,0x1E01F268,0x6906C2FE,0xF762575D,0x806567CB,0x196C3671,0x6E6B06E7,
    0xFED41B76,0x89D32BE0,0x10DA7A5A,0x67DD4ACC,0xF9B9DF6F,0x8EBEEFF9,0x17B7BE43,0x60B08ED5,
    0xD6D6A3E8,0xA1D1937E,0x38D8C2C4,0x4FDFF252,0xD1BB67F1,0xA6BC5767,0x3FB506DD,0x48B2364B,
    0xD80D2BDA,0xAF0A1B4C,0x36034AF6,0x41047A60,0xDF60EFC3,0xA867DF55,0x316E8EEF,0x4669BE79,
    0xCB61B38C,0xBC66831A,0x256FD2A0,0x5268E236,0xCC0C7795,0xBB0B4703,0x220216B9,0x5505262F,
    0xC5BA3BBE,0xB2BD0B28,0x2BB45A92,0x5CB36A04,0xC2D7FFA7,0xB5D0CF31,0x2CD99E8B,0x5BDEAE1D,
    0x9B64C2B0,0xEC63F226,0x756AA39C,0x026D930A,0x9C0906A9,0xEB0E363F,0x72076785,0x05005713,
    0x95BF4A82,0xE2B87A14,0x7BB12BAE,0x0CB61B38,0x92D28E9B,0xE5D5BE0D,0x7CDCEFB7,0x0BDBDF21,
    0x86D3D2D4,0xF1D4E242,0x68DDB3F8,0x1FDA836E,0x81BE16CD,0xF6B9265B,0x6FB077E1,0x18B74777,
    0x88085AE6,0xFF0F6A70,0x66063BCA,0x11010B5C,0x8F659EFF,0xF862AE69,0x616BFFD3,0x166CCF45,
    0xA00AE278,0xD70DD2EE,0x4E048354,0x3903B3C2,0xA7672661,0xD06016F7,0x4969474D,0x3E6E77DB,
    0xAED16A4A,0xD9D65ADC,0x40DF0B66,0x37D83BF0,0xA9BCAE53,0xDEBB9EC5,0x47B2CF7F,0x30B5FFE9,
    0xBDBDF21C,0xCABAC28A,0x53B39330,0x24B4A3A6,0xBAD03605,0xCDD70693,0x54DE5729,0x23D967BF,
    0xB3667A2E,0xC4614AB8,0x5D681B02,0x2A6F2B94,0xB40BBE37,0xC30C8EA1,0x5A05DF1B,0x2D02EF8D,
  }
  // beyond this point only relevant for Slicing-by-4, Slicing-by-8 and Slicing-by-16
  ,{
    0x00000000,0x191B3141,0x32366282,0x2B2D53C3,0x646CC504,0x7D77F445,0x565AA786,0x4F4196C7,
    0xC8D98A08,0xD1C2BB49,0xFAEFE88A,0xE3F4D9CB,0xACB54F0C,0xB5AE7E4D,0x9E832D8E,0x87981CCF,
    0x4AC21251,0x53D92310,0x78F470D3,0x61EF4192,0x2EAED755,0x37B5E614,0x1C98B5D7,0x05838496,
    0x821B9859,0x9B00A918,0xB02DFADB,0xA936CB9A,0xE6775D5D,0xFF6C6C1C,0xD4413FDF,0xCD5A0E9E,
    0x958424A2,0x8C9F15E3,0xA7B24620,0xBEA97761,0xF1E8E1A6,0xE8F3D0E7,0xC3DE8324,0xDAC5B265,
    0x5D5DAEAA,0x44469FEB,0x6F6BCC28,0x7670FD69,0x39316BAE,0x202A5AEF,0x0B07092C,0x121C386D,
    0xDF4636F3,0xC65D07B2,0xED705471,0xF46B6530,0xBB2AF3F7,0xA231C2B6,0x891C9175,0x9007A034,
    0x179FBCFB,0x0E848DBA,0x25A9DE79,0x3CB2EF38,0x73F379FF,0x6AE848BE,0x41C51B7D,0x58DE2A3C,
    0xF0794F05,0xE9627E44,0xC24F2D87,0xDB541CC6,0x94158A01,0x8D0EBB40,0xA623E883,0xBF38D9C2,
    0x38A0C50D,0x21BBF44C,0x0A96A78F,0x138D96CE,0x5CCC0009,0x45D73148,0x6EFA628B,0x77E153CA,
    0xBABB5D54,0xA3A06C15,0x888D3FD6,0x91960E97,0xDED79850,0xC7CCA911,0xECE1FAD2,0xF5FACB93,
    0x7262D75C,0x6B79E61D,0x4054B5DE,0x594F849F,0x160E1258,0x0F152319,0x243870DA,0x3D23419B,
    0x65FD6BA7,0x7CE65AE6,0x57CB0925,0x4ED03864,0x0191AEA3,0x188A9FE2,0x33A7CC21,0x2ABCFD60,
    0xAD24E1AF,0xB43FD0EE,0x9F12832D,0x8609B26C,0xC94824AB,0xD05315EA,0xFB7E4629,0xE2657768,
    0x2F3F79F6,0x362448B7,0x1D091B74,0x04122A35,0x4B53BCF2,0x52488DB3,0x7965DE70,0x607EEF31,
    0xE7E6F3FE,0xFEFDC2BF,0xD5D0917C,0xCCCBA03D,0x838A36FA,0x9A9107BB,0xB1BC5478,0xA8A76539,
    0x3B83984B,0x2298A90A,0x09B5FAC9,0x10AECB88,0x5FEF5D4F,0x46F46C0E,0x6DD93FCD,0x74C20E8C,
    0xF35A1243,0xEA412302,0xC16C70C1,0xD8774180,0x9736D747,0x8E2DE606,0xA500B5C5,0xBC1B8484,
    0x71418A1A,0x685ABB5B,0x4377E898,0x5A6CD9D9,0x152D4F1E,0x0C367E5F,0x271B2D9C,0x3E001CDD,
    0xB9980012,0xA0833153,0x8BAE6290,0x92B553D1,0xDDF4C516,0xC4EFF457,0xEFC2A794,0xF6D996D5,
    0xAE07BCE9,0xB71C8DA8,0x9C31DE6B,0x852AEF2A,0xCA6B79ED,0xD37048AC,0xF85D1B6F,0xE1462A2E,
    0x66DE36E1,0x7FC507A0,0x54E85463,0x4DF36522,0x02B2F3E5,0x1BA9C2A4,0x30849167,0x299FA026,
    0xE4C5AEB8,0xFDDE9FF9,0xD6F3CC3A,0xCFE8FD7B,0x80A96BBC,0x99B25AFD,0xB29F093E,0xAB84387F,
    0x2C1C24B0,0x350715F1,0x1E2A4632,0x07317773,0x4870E1B4,0x516BD0F5,0x7A468336,0x635DB277,
    0xCBFAD74E,0xD2E1E60F,0xF9CCB5CC,0xE0D7848D,0xAF96124A,0xB68D230B,0x9DA070C8,0x84BB4189,
    0x03235D46,0x1A386C07,0x31153FC4,0x280E0E85,0x674F9842,0x7E54A903,0x5579FAC0,0x4C62CB81,
    0x8138C51F,0x9823F45E,0xB30EA79D,0xAA1596DC,0xE554001B,0xFC4F315A,0xD7626299,0xCE7953D8,
    0x49E14F17,0x50FA7E56,0x7BD72D95,0x62CC1CD4,0x2D8D8A13,0x3496BB52,0x1FBBE891,0x06A0D9D0,
    0x5E7EF3EC,0x4765C2AD,0x6C48916E,0x7553A02F,0x3A1236E8,0x230907A9,0x0824546A,0x113F652B,
    0x96A779E4,0x8FBC48A5,0xA4911B66,0xBD8A2A27,0xF2CBBCE0,0xEBD08DA1,0xC0FDDE62,0xD9E6EF23,
    0x14BCE1BD,0x0DA7D0FC,0x268A833F,0x3F91B27E,0x70D024B9,0x69CB15F8,0x42E6463B,0x5BFD777A,
    0xDC656BB5,0xC57E5AF4,0xEE530937,0xF7483876,0xB809AEB1,0xA1129FF0,0x8A3FCC33,0x9324FD72,
  },
  {
    0x00000000,0x01C26A37,0x0384D46E,0x0246BE59,0x0709A8DC,0x06CBC2EB,0x048D7CB2,0x054F1685,
    0x0E1351B8,0x0FD13B8F,0x0D9785D6,0x0C55EFE1,0x091AF964,0x08D89353,0x0A9E2D0A,0x0B5C473D,
    0x1C26A370,0x1DE4C947,0x1FA2771E,0x1E601D29,0x1B2F0BAC,0x1AED619B,0x18ABDFC2,0x1969B5F5,
    0x1235F2C8,0x13F798FF,0x11B126A6,0x10734C91,0x153C5A14,0x14FE3023,0x16B88E7A,0x177AE44D,
    0x384D46E0,0x398F2CD7,0x3BC9928E,0x3A0BF8B9,0x3F44EE3C,0x3E86840B,0x3CC03A52,0x3D025065,
    0x365E1758,0x379C7D6F,0x35DAC336,0x3418A901,0x3157BF84,0x3095D5B3,0x32D36BEA,0x331101DD,
    0x246BE590,0x25A98FA7,0x27EF31FE,0x262D5BC9,0x23624D4C,0x22A0277B,0x20E69922,0x2124F315,
    0x2A78B428,0x2BBADE1F,0x29FC6046,0x283E0A71,0x2D711CF4,0x2CB376C3,0x2EF5C89A,0x2F37A2AD,
    0x709A8DC0,0x7158E7F7,0x731E59AE,0x72DC3399,0x7793251C,0x76514F2B,0x7417F172,0x75D59B45,
    0x7E89DC78,0x7F4BB64F,0x7D0D0816,0x7CCF6221,0x798074A4,0x78421E93,0x7A04A0CA,0x7BC6CAFD,
    0x6CBC2EB0,0x6D7E4487,0x6F38FADE,0x6EFA90E9,0x6BB5866C,0x6A77EC5B,0x68315202,0x69F33835,
    0x62AF7F08,0x636D153F,0x612BAB66,0x60E9C151,0x65A6D7D4,0x6464BDE3,0x662203BA,0x67E0698D,
    0x48D7CB20,0x4915A117,0x4B531F4E,0x4A917579,0x4FDE63FC,0x4E1C09CB,0x4C5AB792,0x4D98DDA5,
    0x46C49A98,0x4706F0AF,0x45404EF6,0x448224C1,0x41CD3244,0x400F5873,0x4249E62A,0x438B8C1D,
    0x54F16850,0x55330267,0x5775BC3E,0x56B7D609,0x53F8C08C,0x523AAABB,0x507C14E2,0x51BE7ED5,
    0x5AE239E8,0x5B2053DF,0x5966ED86,0x58A487B1,0x5DEB9134,0x5C29FB03,0x5E6F455A,0x5FAD2F6D,
    0xE1351B80,0xE0F771B7,0xE2B1CFEE,0xE373A5D9,0xE63CB35C,0xE7FED96B,0xE5B86732,0xE47A0D05,
    0xEF264A38,0xEEE4200F,0xECA29E56,0xED60F461,0xE82FE2E4,0xE9ED88D3,0xEBAB368A,0xEA695CBD,
    0xFD13B8F0,0xFCD1D2C7,0xFE976C9E,0xFF5506A9,0xFA1A102C,0xFBD87A1B,0xF99EC442,0xF85CAE75,
    0xF300E948,0xF2C2837F,0xF0843D26,0xF1465711,0xF4094194,0xF5CB2BA3,0xF78D95FA,0xF64FFFCD,
    0xD9785D60,0xD8BA3757,0xDAFC890E,0xDB3EE339,0xDE71F5BC,0xDFB39F8B,0xDDF521D2,0xDC374BE5,
    0xD76B0CD8,0xD6A966EF,0xD4EFD8B6,0xD52DB281,0xD062A404,0xD1A0CE33,0xD3E6706A,0xD2241A5D,
    0xC55EFE10,0xC49C9427,0xC6DA2A7E,0xC7184049,0xC25756CC,0xC3953CFB,0xC1D382A2,0xC011E895,
    0xCB4DAFA8,0xCA8FC59F,0xC8C97BC6,0xC90B11F1,0xCC440774,0xCD866D43,0xCFC0D31A,0xCE02B92D,
    0x91AF9640,0x906DFC77,0x922B422E,0x93E92819,0x96A63E9C,0x976454AB,0x9522EAF2,0x94E080C5,
    0x9FBCC7F8,0x9E7EADCF,0x9C381396,0x9DFA79A1,0x98B56F24,0x99770513,0x9B31BB4A,0x9AF3D17D,
    0x8D893530,0x8C4B5F07,0x8E0DE15E,0x8FCF8B69,0x8A809DEC,0x8B42F7DB,0x89044982,0x88C623B5,
    0x839A6488,0x82580EBF,0x801EB0E6,0x81DCDAD1,0x8493CC54,0x8551A663,0x8717183A,0x86D5720D,
    0xA9E2D0A0,0xA820BA97,0xAA6604CE,0xABA46EF9,0xAEEB787C,0xAF29124B,0xAD6FAC12,0xACADC625,
    0xA7F18118,0xA633EB2F,0xA4755576,0xA5B73F41,0xA0F829C4,0xA13A43F3,0xA37CFDAA,0xA2BE979D,
    0xB5C473D0,0xB40619E7,0xB640A7BE,0xB782CD89,0xB2CDDB0C,0xB30FB13B,0xB1490F62,0xB08B6555,
    0xBBD72268,0xBA15485F,0xB853F606,0xB9919C31,0xBCDE8AB4,0xBD1CE083,0xBF5A5EDA,0xBE9834ED,
  },
  {
    0x00000000,0xB8BC6765,0xAA09C88B,0x12B5AFEE,0x8F629757,0x37DEF032,0x256B5FDC,0x9DD738B9,
    0xC5B428EF,0x7D084F8A,0x6FBDE064,0xD7018701,0x4AD6BFB8,0xF26AD8DD,0xE0DF7733,0x58631056,
    0x5019579F,0xE8A530FA,0xFA109F14,0x42ACF871,0xDF7BC0C8,0x67C7A7AD,0x75720843,0xCDCE6F26,
    0x95AD7F70,0x2D111815,0x3FA4B7FB,0x8718D09E,0x1ACFE827,0xA2738F42,0xB0C620AC,0x087A47C9,
    0xA032AF3E,0x188EC85B,0x0A3B67B5,0xB28700D0,0x2F503869,0x97EC5F0C,0x8559F0E2,0x3DE59787,
    0x658687D1,0xDD3AE0B4,0xCF8F4F5A,0x7733283F,0xEAE41086,0x525877E3,0x40EDD80D,0xF851BF68,
    0xF02BF8A1,0x48979FC4,0x5A22302A,0xE29E574F,0x7F496FF6,0xC7F50893,0xD540A77D,0x6DFCC018,
    0x359FD04E,0x8D23B72B,0x9F9618C5,0x272A7FA0,0xBAFD4719,0x0241207C,0x10F48F92,0xA848E8F7,
    0x9B14583D,0x23A83F58,0x311D90B6,0x89A1F7D3,0x1476CF6A,0xACCAA80F,0xBE7F07E1,0x06C36084,
    0x5EA070D2,0xE61C17B7,0xF4A9B859,0x4C15DF3C,0xD1C2E785,0x697E80E0,0x7BCB2F0E,0xC377486B,
    0xCB0D0FA2,0x73B168C7,0x6104C729,0xD9B8A04C,0x446F98F5,0xFCD3FF90,0xEE66507E,0x56DA371B,
    0x0EB9274D,0xB6054028,0xA4B0EFC6,0x1C0C88A3,0x81DBB01A,0x3967D77F,0x2BD27891,0x936E1FF4,
    0x3B26F703,0x839A9066,0x912F3F88,0x299358ED,0xB4446054,0x0CF80731,0x1E4DA8DF,0xA6F1CFBA,
    0xFE92DFEC,0x462EB889,0x549B1767,0xEC277002,0x71F048BB,0xC94C2FDE,0xDBF98030,0x6345E755,
    0x6B3FA09C,0xD383C7F9,0xC1366817,0x798A0F72,0xE45D37CB,0x5CE150AE,0x4E54FF40,0xF6E89825,
    0xAE8B8873,0x1637EF16,0x048240F8,0xBC3E279D,0x21E91F24,0x99557841,0x8BE0D7AF,0x335CB0CA,
    0xED59B63B,0x55E5D15E,0x47507EB0,0xFFEC19D5,0x623B216C,0xDA874609,0xC832E9E7,0x708E8E82,
    0x28ED9ED4,0x9051F9B1,0x82E4565F,0x3A58313A,0xA78F0983,0x1F336EE6,0x0D86C108,0xB53AA66D,
    0xBD40E1A4,0x05FC86C1,0x1749292F,0xAFF54E4A,0x322276F3,0x8A9E1196,0x982BBE78,0x2097D91D,
    0x78F4C94B,0xC048AE2E,0xD2FD01C0,0x6A4166A5,0xF7965E1C,0x4F2A3979,0x5D9F9697,0xE523F1F2,
    0x4D6B1905,0xF5D77E60,0xE762D18E,0x5FDEB6EB,0xC2098E52,0x7AB5E937,0x680046D9,0xD0BC21BC,
    0x88DF31EA,0x3063568F,0x22D6F961,0x9A6A9E04,0x07BDA6BD,0xBF01C1D8,0xADB46E36,0x15080953,
    0x1D724E9A,0xA5CE29FF,0xB77B8611,0x0FC7E174,0x9210D9CD,0x2AACBEA8,0x38191146,0x80A57623,
    0xD8C66675,0x607A0110,0x72CFAEFE,0xCA73C99B,0x57A4F122,0xEF189647,0xFDAD39A9,0x45115ECC,
    0x764DEE06,0xCEF18963,0xDC44268D,0x64F841E8,0xF92F7951,0x41931E34,0x5326B1DA,0xEB9AD6BF,
    0xB3F9C6E9,0x0B45A18C,0x19F00E62,0xA14C6907,0x3C9B51BE,0x842736DB,0x96929935,0x2E2EFE50,
    0x2654B999,0x9EE8DEFC,0x8C5D7112,0x34E11677,0xA9362ECE,0x118A49AB,0x033FE645,0xBB838120,
    0xE3E09176,0x5B5CF613,0x49E959FD,0xF1553E98,0x6C820621,0xD43E6144,0xC68BCEAA,0x7E37A9CF,
    0xD67F4138,0x6EC3265D,0x7C7689B3,0xC4CAEED6,0x591DD66F,0xE1A1B10A,0xF3141EE4,0x4BA87981,
    0x13CB69D7,0xAB770EB2,0xB9C2A15C,0x017EC639,0x9CA9FE80,0x241599E5,0x36A0360B,0x8E1C516E,
    0x866616A7,0x3EDA71C2,0x2C6FDE2C,0x94D3B949,0x090481F0,0xB1B8E695,0xA30D497B,0x1BB12E1E,
    0x43D23E48,0xFB6E592D,0xE9DBF6C3,0x516791A6,0xCCB0A91F,0x740CCE7A,0x66B96194,0xDE0506F1,
  }
  // beyond this point only relevant for Slicing-by-8 and Slicing-by-16
  ,{
    0x00000000,0x3D6029B0,0x7AC05360,0x47A07AD0,0xF580A6C0,0xC8E08F70,0x8F40F5A0,0xB220DC10,
    0x30704BC1,0x0D106271,0x4AB018A1,0x77D03111,0xC5F0ED01,0xF890C4B1,0xBF30BE61,0x825097D1,
    0x60E09782,0x5D80BE32,0x1A20C4E2,0x2740ED52,0x95603142,0xA80018F2,0xEFA06222,0xD2C04B92,
    0x5090DC43,0x6DF0F5F3,0x2A508F23,0x1730A693,0xA5107A83,0x98705333,0xDFD029E3,0xE2B00053,
    0xC1C12F04,0xFCA106B4,0xBB017C64,0x866155D4,0x344189C4,0x0921A074,0x4E81DAA4,0x73E1F314,
    0xF1B164C5,0xCCD14D75,0x8B7137A5,0xB6111E15,0x0431C205,0x3951EBB5,0x7EF19165,0x4391B8D5,
    0xA121B886,0x9C419136,0xDBE1EBE6,0xE681C256,0x54A11E46,0x69C137F6,0x2E614D26,0x13016496,
    0x9151F347,0xAC31DAF7,0xEB91A027,0xD6F18997,0x64D15587,0x59B17C37,0x1E1106E7,0x23712F57,
    0x58F35849,0x659371F9,0x22330B29,0x1F532299,0xAD73FE89,0x9013D739,0xD7B3ADE9,0xEAD38459,
    0x68831388,0x55E33A38,0x124340E8,0x2F236958,0x9D03B548,0xA0639CF8,0xE7C3E628,0xDAA3CF98,
    0x3813CFCB,0x0573E67B,0x42D39CAB,0x7FB3B51B,0xCD93690B,0xF0F340BB,0xB7533A6B,0x8A3313DB,
    0x0863840A,0x3503ADBA,0x72A3D76A,0x4FC3FEDA,0xFDE322CA,0xC0830B7A,0x872371AA,0xBA43581A,
    0x9932774D,0xA4525EFD,0xE3F2242D,0xDE920D9D,0x6CB2D18D,0x51D2F83D,0x167282ED,0x2B12AB5D,
    0xA9423C8C,0x9422153C,0xD3826FEC,0xEEE2465C,0x5CC29A4C,0x61A2B3FC,0x2602C92C,0x1B62E09C,
    0xF9D2E0CF,0xC4B2C97F,0x8312B3AF,0xBE729A1F,0x0C52460F,0x31326FBF,0x7692156F,0x4BF23CDF,
    0xC9A2AB0E,0xF4C282BE,0xB362F86E,0x8E02D1DE,0x3C220DCE,0x0142247E,0x46E25EAE,0x7B82771E,
    0xB1E6B092,0x8C869922,0xCB26E3F2,0xF646CA42,0x44661652,0x79063FE2,0x3EA64532,0x03C66C82,
    0x8196FB53,0xBCF6D2E3,0xFB56A833,0xC6368183,0x74165D93,0x49767423,0x0ED60EF3,0x33B62743,
    0xD1062710,0xEC660EA0,0xABC67470,0x96A65DC0,0x248681D0,0x19E6A860,0x5E46D2B0,0x6326FB00,
    0xE1766CD1,0xDC164561,0x9BB63FB1,0xA6D61601,0x14F6CA11,0x2996E3A1,0x6E369971,0x5356B0C1,
    0x70279F96,0x4D47B626,0x0AE7CCF6,0x3787E546,0x85A73956,0xB8C710E6,0xFF676A36,0xC2074386,
    0x4057D457,0x7D37FDE7,0x3A978737,0x07F7AE87,0xB5D77297,0x88B75B27,0xCF1721F7,0xF2770847,
    0x10C70814,0x2DA721A4,0x6A075B74,0x576772C4,0xE547AED4,0xD8278764,0x9F87FDB4,0xA2E7D404,
    0x20B743D5,0x1DD76A65,0x5A7710B5,0x67173905,0xD537E515,0xE857CCA5,0xAFF7B675,0x92979FC5,
    0xE915E8DB,0xD475C16B,0x93D5BBBB,0xAEB5920B,0x1C954E1B,0x21F567AB,0x66551D7B,0x5B3534CB,
    0xD965A31A,0xE4058AAA,0xA3A5F07A,0x9EC5D9CA,0x2CE505DA,0x11852C6A,0x562556BA,0x6B457F0A,
    0x89F57F59,0xB49556E9,0xF3352C39,0xCE550589,0x7C75D999,0x4115F029,0x06B58AF9,0x3BD5A349,
    0xB9853498,0x84E51D28,0xC34567F8,0xFE254E48,0x4C059258,0x7165BBE8,0x36C5C138,0x0BA5E888,
    0x28D4C7DF,0x15B4EE6F,0x521494BF,0x6F74BD0F,0xDD54611F,0xE03448AF,0xA794327F,0x9AF41BCF,
    0x18A48C1E,0x25C4A5AE,0x6264DF7E,0x5F04F6CE,0xED242ADE,0xD044036E,0x97E479BE,0xAA84500E,
    0x4834505D,0x755479ED,0x32F4033D,0x0F942A8D,0xBDB4F69D,0x80D4DF2D,0xC774A5FD,0xFA148C4D,
    0x78441B9C,0x4524322C,0x028448FC,0x3FE4614C,0x8DC4BD5C,0xB0A494EC,0xF704EE3C,0xCA64C78C,
  },
  {
    0x00000000,0xCB5CD3A5,0x4DC8A10B,0x869472AE,0x9B914216,0x50CD91B3,0xD659E31D,0x1D0530B8,
    0xEC53826D,0x270F51C8,0xA19B2366,0x6AC7F0C3,0x77C2C07B,0xBC9E13DE,0x3A0A6170,0xF156B2D5,
    0x03D6029B,0xC88AD13E,0x4E1EA390,0x85427035,0x9847408D,0x531B9328,0xD58FE186,0x1ED33223,
    0xEF8580F6,0x24D95353,0xA24D21FD,0x6911F258,0x7414C2E0,0xBF481145,0x39DC63EB,0xF280B04E,
    0x07AC0536,0xCCF0D693,0x4A64A43D,0x81387798,0x9C3D4720,0x57619485,0xD1F5E62B,0x1AA9358E,
    0xEBFF875B,0x20A354FE,0xA6372650,0x6D6BF5F5,0x706EC54D,0xBB3216E8,0x3DA66446,0xF6FAB7E3,
    0x047A07AD,0xCF26D408,0x49B2A6A6,0x82EE7503,0x9FEB45BB,0x54B7961E,0xD223E4B0,0x197F3715,
    0xE82985C0,0x23755665,0xA5E124CB,0x6EBDF76E,0x73B8C7D6,0xB8E41473,0x3E7066DD,0xF52CB578,
    0x0F580A6C,0xC404D9C9,0x4290AB67,0x89CC78C2,0x94C9487A,0x5F959BDF,0xD901E971,0x125D3AD4,
    0xE30B8801,0x28575BA4,0xAEC3290A,0x659FFAAF,0x789ACA17,0xB3C619B2,0x35526B1C,0xFE0EB8B9,
    0x0C8E08F7,0xC7D2DB52,0x4146A9FC,0x8A1A7A59,0x971F4AE1,0x5C439944,0xDAD7EBEA,0x118B384F,
    0xE0DD8A9A,0x2B81593F,0xAD152B91,0x6649F834,0x7B4CC88C,0xB0101B29,0x36846987,0xFDD8BA22,
    0x08F40F5A,0xC3A8DCFF,0x453CAE51,0x8E607DF4,0x93654D4C,0x58399EE9,0xDEADEC47,0x15F13FE2,
    0xE4A78D37,0x2FFB5E92,0xA96F2C3C,0x6233FF99,0x7F36CF21,0xB46A1C84,0x32FE6E2A,0xF9A2BD8F,
    0x0B220DC1,0xC07EDE64,0x46EAACCA,0x8DB67F6F,0x90B34FD7,0x5BEF9C72,0xDD7BEEDC,0x16273D79,
    0xE7718FAC,0x2C2D5C09,0xAAB92EA7,0x61E5FD02,0x7CE0CDBA,0xB7BC1E1F,0x31286CB1,0xFA74BF14,
    0x1EB014D8,0xD5ECC77D,0x5378B5D3,0x98246676,0x852156CE,0x4E7D856B,0xC8E9F7C5,0x03B52460,
    0xF2E396B5,0x39BF4510,0xBF2B37BE,0x7477E41B,0x6972D4A3,0xA22E0706,0x24BA75A8,0xEFE6A60D,
    0x1D661643,0xD63AC5E6,0x50AEB748,0x9BF264ED,0x86F75455,0x4DAB87F0,0xCB3FF55E,0x006326FB,
    0xF135942E,0x3A69478B,0xBCFD3525,0x77A1E680,0x6AA4D638,0xA1F8059D,0x276C7733,0xEC30A496,
    0x191C11EE,0xD240C24B,0x54D4B0E5,0x9F886340,0x828D53F8,0x49D1805D,0xCF45F2F3,0x04192156,
    0xF54F9383,0x3E134026,0xB8873288,0x73DBE12D,0x6EDED195,0xA5820230,0x2316709E,0xE84AA33B,
    0x1ACA1375,0xD196C0D0,0x5702B27E,0x9C5E61DB,0x815B5163,0x4A0782C6,0xCC93F068,0x07CF23CD,
    0xF6999118,0x3DC542BD,0xBB513013,0x700DE3B6,0x6D08D30E,0xA65400AB,0x20C07205,0xEB9CA1A0,
    0x11E81EB4,0xDAB4CD11,0x5C20BFBF,0x977C6C1A,0x8A795CA2,0x41258F07,0xC7B1FDA9,0x0CED2E0C,
    0xFDBB9CD9,0x36E74F7C,0xB0733DD2,0x7B2FEE77,0x662ADECF,0xAD760D6A,0x2BE27FC4,0xE0BEAC61,
    0x123E1C2F,0xD962CF8A,0x5FF6BD24,0x94AA6E81,0x89AF5E39,0x42F38D9C,0xC467FF32,0x0F3B2C97,
    0xFE6D9E42,0x35314DE7,0xB3A53F49,0x78F9ECEC,0x65FCDC54,0xAEA00FF1,0x28347D5F,0xE368AEFA,
    0x16441B82,0xDD18C827,0x5B8CBA89,0x90D0692C,0x8DD55994,0x46898A31,0xC01DF89F,0x0B412B3A,
    0xFA1799EF,0x314B4A4A,0xB7DF38E4,0x7C83EB41,0x6186DBF9,0xAADA085C,0x2C4E7AF2,0xE712A957,
    0x15921919,0xDECECABC,0x585AB812,0x93066BB7,0x8E035B0F,0x455F88AA,0xC3CBFA04,0x089729A1,
    0xF9C19B74,0x329D48D1,0xB4093A7F,0x7F55E9DA,0x6250D962,0xA90C0AC7,0x2F987869,0xE4C4ABCC,
  },
  {
    0x00000000,0xA6770BB4,0x979F1129,0x31E81A9D,0xF44F2413,0x52382FA7,0x63D0353A,0xC5A73E8E,
    0x33EF4E67,0x959845D3,0xA4705F4E,0x020754FA,0xC7A06A74,0x61D761C0,0x503F7B5D,0xF64870E9,
    0x67DE9CCE,0xC1A9977A,0xF0418DE7,0x56368653,0x9391B8DD,0x35E6B369,0x040EA9F4,0xA279A240,
    0x5431D2A9,0xF246D91D,0xC3AEC380,0x65D9C834,0xA07EF6BA,0x0609FD0E,0x37E1E793,0x9196EC27,
    0xCFBD399C,0x69CA3228,0x582228B5,0xFE552301,0x3BF21D8F,0x9D85163B,0xAC6D0CA6,0x0A1A0712,
    0xFC5277FB,0x5A257C4F,0x6BCD66D2,0xCDBA6D66,0x081D53E8,0xAE6A585C,0x9F8242C1,0x39F54975,
    0xA863A552,0x0E14AEE6,0x3FFCB47B,0x998BBFCF,0x5C2C8141,0xFA5B8AF5,0xCBB39068,0x6DC49BDC,
    0x9B8CEB35,0x3DFBE081,0x0C13FA1C,0xAA64F1A8,0x6FC3CF26,0xC9B4C492,0xF85CDE0F,0x5E2BD5BB,
    0x440B7579,0xE27C7ECD,0xD3946450,0x75E36FE4,0xB044516A,0x16335ADE,0x27DB4043,0x81AC4BF7,
    0x77E43B1E,0xD19330AA,0xE07B2A37,0x460C2183,0x83AB1F0D,0x25DC14B9,0x14340E24,0xB2430590,
    0x23D5E9B7,0x85A2E203,0xB44AF89E,0x123DF32A,0xD79ACDA4,0x71EDC610,0x4005DC8D,0xE672D739,
    0x103AA7D0,0xB64DAC64,0x87A5B6F9,0x21D2BD4D,0xE47583C3,0x42028877,0x73EA92EA,0xD59D995E,
    0x8BB64CE5,0x2DC14751,0x1C295DCC,0xBA5E5678,0x7FF968F6,0xD98E6342,0xE86679DF,0x4E11726B,
    0xB8590282,0x1E2E0936,0x2FC613AB,0x89B1181F,0x4C162691,0xEA612D25,0xDB8937B8,0x7DFE3C0C,
    0xEC68D02B,0x4A1FDB9F,0x7BF7C102,0xDD80CAB6,0x1827F438,0xBE50FF8C,0x8FB8E511,0x29CFEEA5,
    0xDF879E4C,0x79F095F8,0x48188F65,0xEE6F84D1,0x2BC8BA5F,0x8DBFB1EB,0xBC57AB76,0x1A20A0C2,
    0x8816EAF2,0x2E61E146,0x1F89FBDB,0xB9FEF06F,0x7C59CEE1,0xDA2EC555,0xEBC6DFC8,0x4DB1D47C,
    0xBBF9A495,0x1D8EAF21,0x2C66B5BC,0x8A11BE08,0x4FB68086,0xE9C18B32,0xD82991AF,0x7E5E9A1B,
    0xEFC8763C,0x49BF7D88,0x78576715,0xDE206CA1,0x1B87522F,0xBDF0599B,0x8C184306,0x2A6F48B2,
    0xDC27385B,0x7A5033EF,0x4BB82972,0xEDCF22C6,0x28681C48,0x8E1F17FC,0xBFF70D61,0x198006D5,
    0x47ABD36E,0xE1DCD8DA,0xD034C247,0x7643C9F3,0xB3E4F77D,0x1593FCC9,0x247BE654,0x820CEDE0,
    0x74449D09,0xD23396BD,0xE3DB8C20,0x45AC8794,0x800BB91A,0x267CB2AE,0x1794A833,0xB1E3A387,
    0x20754FA0,0x86024414,0xB7EA5E89,0x119D553D,0xD43A6BB3,0x724D6007,0x43A57A9A,0xE5D2712E,
    0x139A01C7,0xB5ED0A73,0x840510EE,0x22721B5A,0xE7D525D4,0x41A22E60,0x704A34FD,0xD63D3F49,
    0xCC1D9F8B,0x6A6A943F,0x5B828EA2,0xFDF58516,0x3852BB98,0x9E25B02C,0xAFCDAAB1,0x09BAA105,
    0xFFF2D1EC,0x5985DA58,0x686DC0C5,0xCE1ACB71,0x0BBDF5FF,0xADCAFE4B,0x9C22E4D6,0x3A55EF62,
    0xABC30345,0x0DB408F1,0x3C5C126C,0x9A2B19D8,0x5F8C2756,0xF9FB2CE2,0xC813367F,0x6E643DCB,
    0x982C4D22,0x3E5B4696,0x0FB35C0B,0xA9C457BF,0x6C636931,0xCA146285,0xFBFC7818,0x5D8B73AC,
    0x03A0A617,0xA5D7ADA3,0x943FB73E,0x3248BC8A,0xF7EF8204,0x519889B0,0x6070932D,0xC6079899,
    0x304FE870,0x9638E3C4,0xA7D0F959,0x01A7F2ED,0xC400CC63,0x6277C7D7,0x539FDD4A,0xF5E8D6FE,
    0x647E3AD9,0xC209316D,0xF3E12BF0,0x55962044,0x90311ECA,0x3646157E,0x07AE0FE3,0xA1D90457,
    0x579174BE,0xF1E67F0A,0xC00E6597,0x66796E23,0xA3DE50AD,0x05A95B19,0x34414184,0x92364A30,
  },
  {
    0x00000000,0xCCAA009E,0x4225077D,0x8E8F07E3,0x844A0EFA,0x48E00E64,0xC66F0987,0x0AC50919,
    0xD3E51BB5,0x1F4F1B2B,0x91C01CC8,0x5D6A1C56,0x57AF154F,0x9B0515D1,0x158A1232,0xD92012AC,
    0x7CBB312B,0xB01131B5,0x3E9E3656,0xF23436C8,0xF8F13FD1,0x345B3F4F,0xBAD438AC,0x767E3832,
    0xAF5E2A9E,0x63F42A00,0xED7B2DE3,0x21D12D7D,0x2B142464,0xE7BE24FA,0x69312319,0xA59B2387,
    0xF9766256,0x35DC62C8,0xBB53652B,0x77F965B5,0x7D3C6CAC,0xB1966C32,0x3F196BD1,0xF3B36B4F,
    0x2A9379E3,0xE639797D,0x68B67E9E,0xA41C7E00,0xAED97719,0x62737787,0xECFC7064,0x205670FA,
    0x85CD537D,0x496753E3,0xC7E85400,0x0B42549E,0x01875D87,0xCD2D5D19,0x43A25AFA,0x8F085A64,
    0x562848C8,0x9A824856,0x140D4FB5,0xD8A74F2B,0xD2624632,0x1EC846AC,0x9047414F,0x5CED41D1,
    0x299DC2ED,0xE537C273,0x6BB8C590,0xA712C50E,0xADD7CC17,0x617DCC89,0xEFF2CB6A,0x2358CBF4,
    0xFA78D958,0x36D2D9C6,0xB85DDE25,0x74F7DEBB,0x7E32D7A2,0xB298D73C,0x3C17D0DF,0xF0BDD041,
    0x5526F3C6,0x998CF358,0x1703F4BB,0xDBA9F425,0xD16CFD3C,0x1DC6FDA2,0x9349FA41,0x5FE3FADF,
    0x86C3E873,0x4A69E8ED,0xC4E6EF0E,0x084CEF90,0x0289E689,0xCE23E617,0x40ACE1F4,0x8C06E16A,
    0xD0EBA0BB,0x1C41A025,0x92CEA7C6,0x5E64A758,0x54A1AE41,0x980BAEDF,0x1684A93C,0xDA2EA9A2,
    0x030EBB0E,0xCFA4BB90,0x412BBC73,0x8D81BCED,0x8744B5F4,0x4BEEB56A,0xC561B289,0x09CBB217,
    0xAC509190,0x60FA910E,0xEE7596ED,0x22DF9673,0x281A9F6A,0xE4B09FF4,0x6A3F9817,0xA6959889,
    0x7FB58A25,0xB31F8ABB,0x3D908D58,0xF13A8DC6,0xFBFF84DF,0x37558441,0xB9DA83A2,0x7570833C,
    0x533B85DA,0x9F918544,0x111E82A7,0xDDB48239,0xD7718B20,0x1BDB8BBE,0x95548C5D,0x59FE8CC3,
    0x80DE9E6F,0x4C749EF1,0xC2FB9912,0x0E51998C,0x04949095,0xC83E900B,0x46B197E8,0x8A1B9776,
    0x2F80B4F1,0xE32AB46F,0x6DA5B38C,0xA10FB312,0xABCABA0B,0x6760BA95,0xE9EFBD76,0x2545BDE8,
    0xFC65AF44,0x30CFAFDA,0xBE40A839,0x72EAA8A7,0x782FA1BE,0xB485A120,0x3A0AA6C3,0xF6A0A65D,
    0xAA4DE78C,0x66E7E712,0xE868E0F1,0x24C2E06F,0x2E07E976,0xE2ADE9E8,0x6C22EE0B,0xA088EE95,
    0x79A8FC39,0xB502FCA7,0x3B8DFB44,0xF727FBDA,0xFDE2F2C3,0x3148F25D,0xBFC7F5BE,0x736DF520,
    0xD6F6D6A7,0x1A5CD639,0x94D3D1DA,0x5879D144,0x52BCD85D,0x9E16D8C3,0x1099DF20,0xDC33DFBE,
    0x0513CD12,0xC9B9CD8C,0x4736CA6F,0x8B9CCAF1,0x8159C3E8,0x4DF3C376,0xC37CC495,0x0FD6C40B,
    0x7AA64737,0xB60C47A9,0x3883404A,0xF42940D4,0xFEEC49CD,0x32464953,0xBCC94EB0,0x70634E2E,
    0xA9435C82,0x65E95C1C,0xEB665BFF,0x27CC5B61,0x2D095278,0xE1A352E6,0x6F2C5505,0xA386559B,
    0x061D761C,0xCAB77682,0x44387161,0x889271FF,0x825778E6,0x4EFD7878,0xC0727F9B,0x0CD87F05,
    0xD5F86DA9,0x19526D37,0x97DD6AD4,0x5B776A4A,0x51B26353,0x9D1863CD,0x1397642E,0xDF3D64B0,
    0x83D02561,0x4F7A25FF,0xC1F5221C,0x0D5F2282,0x079A2B9B,0xCB302B05,0x45BF2CE6,0x89152C78,
    0x50353ED4,0x9C9F3E4A,0x121039A9,0xDEBA3937,0xD47F302E,0x18D530B0,0x965A3753,0x5AF037CD,
    0xFF6B144A,0x33C114D4,0xBD4E1337,0x71E413A9,0x7B211AB0,0xB78B1A2E,0x39041DCD,0xF5AE1D53,
    0x2C8E0FFF,0xE0240F61,0x6EAB0882,0xA201081C,0xA8C40105,0x646E019B,0xEAE10678,0x264B06E6,
  }
  // beyond this point only relevant for Slicing-by-16
  ,{
    0x00000000,0x177B1443,0x2EF62886,0x398D3CC5,0x5DEC510C,0x4A97454F,0x731A798A,0x64616DC9,
    0xBBD8A218,0xACA3B65B,0x952E8A9E,0x82559EDD,0xE634F314,0xF14FE757,0xC8C2DB92,0xDFB9CFD1,
    0xACC04271,0xBBBB5632,0x82366AF7,0x954D7EB4,0xF12C137D,0xE657073E,0xDFDA3BFB,0xC8A12FB8,
    0x1718E069,0x0063F42A,0x39EEC8EF,0x2E95DCAC,0x4AF4B165,0x5D8FA526,0x640299E3,0x73798DA0,
    0x82F182A3,0x958A96E0,0xAC07AA25,0xBB7CBE66,0xDF1DD3AF,0xC866C7EC,0xF1EBFB29,0xE690EF6A,
    0x392920BB,0x2E5234F8,0x17DF083D,0x00A41C7E,0x64C571B7,0x73BE65F4,0x4A335931,0x5D484D72,
    0x2E31C0D2,0x394AD491,0x00C7E854,0x17BCFC17,0x73DD91DE,0x64A6859D,0x5D2BB958,0x4A50AD1B,
    0x95E962CA,0x82927689,0xBB1F4A4C,0xAC645E0F,0xC80533C6,0xDF7E2785,0xE6F31B40,0xF1880F03,
    0xDE920307,0xC9E91744,0xF0642B81,0xE71F3FC2,0x837E520B,0x94054648,0xAD887A8D,0xBAF36ECE,
    0x654AA11F,0x7231B55C,0x4BBC8999,0x5CC79DDA,0x38A6F013,0x2FDDE450,0x1650D895,0x012BCCD6,
    0x72524176,0x65295535,0x5CA469F0,0x4BDF7DB3,0x2FBE107A,0x38C50439,0x014838FC,0x16332CBF,
    0xC98AE36E,0xDEF1F72D,0xE77CCBE8,0xF007DFAB,0x9466B262,0x831DA621,0xBA909AE4,0xADEB8EA7,
    0x5C6381A4,0x4B1895E7,0x7295A922,0x65EEBD61,0x018FD0A8,0x16F4C4EB,0x2F79F82E,0x3802EC6D,
    0xE7BB23BC,0xF0C037FF,0xC94D0B3A,0xDE361F79,0xBA5772B0,0xAD2C66F3,0x94A15A36,0x83DA4E75,
    0xF0A3C3D5,0xE7D8D796,0xDE55EB53,0xC92EFF10,0xAD4F92D9,0xBA34869A,0x83B9BA5F,0x94C2AE1C,
    0x4B7B61CD,0x5C00758E,0x658D494B,0x72F65D08,0x169730C1,0x01EC2482,0x38611847,0x2F1A0C04,
    0x6655004F,0x712E140C,0x48A328C9,0x5FD83C8A,0x3BB95143,0x2CC24500,0x154F79C5,0x02346D86,
    0xDD8DA257,0xCAF6B614,0xF37B8AD1,0xE4009E92,0x8061F35B,0x971AE718,0xAE97DBDD,0xB9ECCF9E,
    0xCA95423E,0xDDEE567D,0xE4636AB8,0xF3187EFB,0x97791332,0x80020771,0xB98F3BB4,0xAEF42FF7,
    0x714DE026,0x6636F465,0x5FBBC8A0,0x48C0DCE3,0x2CA1B12A,0x3BDAA569,0x025799AC,0x152C8DEF,
    0xE4A482EC,0xF3DF96AF,0xCA52AA6A,0xDD29BE29,0xB948D3E0,0xAE33C7A3,0x97BEFB66,0x80C5EF25,
    0x5F7C20F4,0x480734B7,0x718A0872,0x66F11C31,0x029071F8,0x15EB65BB,0x2C66597E,0x3B1D4D3D,
    0x4864C09D,0x5F1FD4DE,0x6692E81B,0x71E9FC58,0x15889191,0x02F385D2,0x3B7EB917,0x2C05AD54,
    0xF3BC6285,0xE4C776C6,0xDD4A4A03,0xCA315E40,0xAE503389,0xB92B27CA,0x80A61B0F,0x97DD0F4C,
    0xB8C70348,0xAFBC170B,0x96312BCE,0x814A3F8D,0xE52B5244,0xF2504607,0xCBDD7AC2,0xDCA66E81,
    0x031FA150,0x1464B513,0x2DE989D6,0x3A929D95,0x5EF3F05C,0x4988E41F,0x7005D8DA,0x677ECC99,
    0x14074139,0x037C557A,0x3AF169BF,0x2D8A7DFC,0x49EB1035,0x5E900476,0x671D38B3,0x70662CF0,
    0xAFDFE321,0xB8A4F762,0x8129CBA7,0x9652DFE4,0xF233B22D,0xE548A66E,0xDCC59AAB,0xCBBE8EE8,
    0x3A3681EB,0x2D4D95A8,0x14C0A96D,0x03BBBD2E,0x67DAD0E7,0x70A1C4A4,0x492CF861,0x5E57EC22,
    0x81EE23F3,0x969537B0,0xAF180B75,0xB8631F36,0xDC0272FF,0xCB7966BC,0xF2F45A79,0xE58F4E3A,
    0x96F6C39A,0x818DD7D9,0xB800EB1C,0xAF7BFF5F,0xCB1A9296,0xDC6186D5,0xE5ECBA10,0xF297AE53,
    0x2D2E6182,0x3A5575C1,0x03D84904,0x14A35D47,0x70C2308E,0x67B924CD,0x5E341808,0x494F0C4B,
  },
  {
    0x00000000,0xEFC26B3E,0x04F5D03D,0xEB37BB03,0x09EBA07A,0xE629CB44,0x0D1E7047,0xE2DC1B79,
    0x13D740F4,0xFC152BCA,0x172290C9,0xF8E0FBF7,0x1A3CE08E,0xF5FE8BB0,0x1EC930B3,0xF10B5B8D,
    0x27AE81E8,0xC86CEAD6,0x235B51D5,0xCC993AEB,0x2E452192,0xC1874AAC,0x2AB0F1AF,0xC5729A91,
    0x3479C11C,0xDBBBAA22,0x308C1121,0xDF4E7A1F,0x3D926166,0xD2500A58,0x3967B15B,0xD6A5DA65,
    0x4F5D03D0,0xA09F68EE,0x4BA8D3ED,0xA46AB8D3,0x46B6A3AA,0xA974C894,0x42437397,0xAD8118A9,
    0x5C8A4324,0xB348281A,0x587F9319,0xB7BDF827,0x5561E35E,0xBAA38860,0x51943363,0xBE56585D,
    0x68F38238,0x8731E906,0x6C065205,0x83C4393B,0x61182242,0x8EDA497C,0x65EDF27F,0x8A2F9941,
    0x7B24C2CC,0x94E6A9F2,0x7FD112F1,0x901379CF,0x72CF62B6,0x9D0D0988,0x763AB28B,0x99F8D9B5,
    0x9EBA07A0,0x71786C9E,0x9A4FD79D,0x758DBCA3,0x9751A7DA,0x7893CCE4,0x93A477E7,0x7C661CD9,
    0x8D6D4754,0x62AF2C6A,0x89989769,0x665AFC57,0x8486E72E,0x6B448C10,0x80733713,0x6FB15C2D,
    0xB9148648,0x56D6ED76,0xBDE15675,0x52233D4B,0xB0FF2632,0x5F3D4D0C,0xB40AF60F,0x5BC89D31,
    0xAAC3C6BC,0x4501AD82,0xAE361681,0x41F47DBF,0xA32866C6,0x4CEA0DF8,0xA7DDB6FB,0x481FDDC5,
    0xD1E70470,0x3E256F4E,0xD512D44D,0x3AD0BF73,0xD80CA40A,0x37CECF34,0xDCF97437,0x333B1F09,
    0xC2304484,0x2DF22FBA,0xC6C594B9,0x2907FF87,0xCBDBE4FE,0x24198FC0,0xCF2E34C3,0x20EC5FFD,
    0xF6498598,0x198BEEA6,0xF2BC55A5,0x1D7E3E9B,0xFFA225E2,0x10604EDC,0xFB57F5DF,0x14959EE1,
    0xE59EC56C,0x0A5CAE52,0xE16B1551,0x0EA97E6F,0xEC756516,0x03B70E28,0xE880B52B,0x0742DE15,
    0xE6050901,0x09C7623F,0xE2F0D93C,0x0D32B202,0xEFEEA97B,0x002CC245,0xEB1B7946,0x04D91278,
    0xF5D249F5,0x1A1022CB,0xF12799C8,0x1EE5F2F6,0xFC39E98F,0x13FB82B1,0xF8CC39B2,0x170E528C,
    0xC1AB88E9,0x2E69E3D7,0xC55E58D4,0x2A9C33EA,0xC8402893,0x278243AD,0xCCB5F8AE,0x23779390,
    0xD27CC81D,0x3DBEA323,0xD6891820,0x394B731E,0xDB976867,0x34550359,0xDF62B85A,0x30A0D364,
    0xA9580AD1,0x469A61EF,0xADADDAEC,0x426FB1D2,0xA0B3AAAB,0x4F71C195,0xA4467A96,0x4B8411A8,
    0xBA8F4A25,0x554D211B,0xBE7A9A18,0x51B8F126,0xB364EA5F,0x5CA68161,0xB7913A62,0x5853515C,
    0x8EF68B39,0x6134E007,0x8A035B04,0x65C1303A,0x871D2B43,0x68DF407D,0x83E8FB7E,0x6C2A9040,
    0x9D21CBCD,0x72E3A0F3,0x99D41BF0,0x761670CE,0x94CA6BB7,0x7B080089,0x903FBB8A,0x7FFDD0B4,
    0x78BF0EA1,0x977D659F,0x7C4ADE9C,0x9388B5A2,0x7154AEDB,0x9E96C5E5,0x75A17EE6,0x9A6315D8,
    0x6B684E55,0x84AA256B,0x6F9D9E68,0x805FF556,0x6283EE2F,0x8D418511,0x66763E12,0x89B4552C,
    0x5F118F49,0xB0D3E477,0x5BE45F74,0xB426344A,0x56FA2F33,0xB938440D,0x520FFF0E,0xBDCD9430,
    0x4CC6CFBD,0xA304A483,0x48331F80,0xA7F174BE,0x452D6FC7,0xAAEF04F9,0x41D8BFFA,0xAE1AD4C4,
    0x37E20D71,0xD820664F,0x3317DD4C,0xDCD5B672,0x3E09AD0B,0xD1CBC635,0x3AFC7D36,0xD53E1608,
    0x24354D85,0xCBF726BB,0x20C09DB8,0xCF02F686,0x2DDEEDFF,0xC21C86C1,0x292B3DC2,0xC6E956FC,
    0x104C8C99,0xFF8EE7A7,0x14B95CA4,0xFB7B379A,0x19A72CE3,0xF66547DD,0x1D52FCDE,0xF29097E0,
    0x039BCC6D,0xEC59A753,0x076E1C50,0xE8AC776E,0x0A706C17,0xE5B20729,0x0E85BC2A,0xE147D714,
  },
  {
    0x00000000,0xC18EDFC0,0x586CB9C1,0x99E26601,0xB0D97382,0x7157AC42,0xE8B5CA43,0x293B1583,
    0xBAC3E145,0x7B4D3E85,0xE2AF5884,0x23218744,0x0A1A92C7,0xCB944D07,0x52762B06,0x93F8F4C6,
    0xAEF6C4CB,0x6F781B0B,0xF69A7D0A,0x3714A2CA,0x1E2FB749,0xDFA16889,0x46430E88,0x87CDD148,
    0x1435258E,0xD5BBFA4E,0x4C599C4F,0x8DD7438F,0xA4EC560C,0x656289CC,0xFC80EFCD,0x3D0E300D,
    0x869C8FD7,0x47125017,0xDEF03616,0x1F7EE9D6,0x3645FC55,0xF7CB2395,0x6E294594,0xAFA79A54,
    0x3C5F6E92,0xFDD1B152,0x6433D753,0xA5BD0893,0x8C861D10,0x4D08C2D0,0xD4EAA4D1,0x15647B11,
    0x286A4B1C,0xE9E494DC,0x7006F2DD,0xB1882D1D,0x98B3389E,0x593DE75E,0xC0DF815F,0x01515E9F,
    0x92A9AA59,0x53277599,0xCAC51398,0x0B4BCC58,0x2270D9DB,0xE3FE061B,0x7A1C601A,0xBB92BFDA,
    0xD64819EF,0x17C6C62F,0x8E24A02E,0x4FAA7FEE,0x66916A6D,0xA71FB5AD,0x3EFDD3AC,0xFF730C6C,
    0x6C8BF8AA,0xAD05276A,0x34E7416B,0xF5699EAB,0xDC528B28,0x1DDC54E8,0x843E32E9,0x45B0ED29,
    0x78BEDD24,0xB93002E4,0x20D264E5,0xE15CBB25,0xC867AEA6,0x09E97166,0x900B1767,0x5185C8A7,
    0xC27D3C61,0x03F3E3A1,0x9A1185A0,0x5B9F5A60,0x72A44FE3,0xB32A9023,0x2AC8F622,0xEB4629E2,
    0x50D49638,0x915A49F8,0x08B82FF9,0xC936F039,0xE00DE5BA,0x21833A7A,0xB8615C7B,0x79EF83BB,
    0xEA17777D,0x2B99A8BD,0xB27BCEBC,0x73F5117C,0x5ACE04FF,0x9B40DB3F,0x02A2BD3E,0xC32C62FE,
    0xFE2252F3,0x3FAC8D33,0xA64EEB32,0x67C034F2,0x4EFB2171,0x8F75FEB1,0x169798B0,0xD7194770,
    0x44E1B3B6,0x856F6C76,0x1C8D0A77,0xDD03D5B7,0xF438C034,0x35B61FF4,0xAC5479F5,0x6DDAA635,
    0x77E1359F,0xB66FEA5F,0x2F8D8C5E,0xEE03539E,0xC738461D,0x06B699DD,0x9F54FFDC,0x5EDA201C,
    0xCD22D4DA,0x0CAC0B1A,0x954E6D1B,0x54C0B2DB,0x7DFBA758,0xBC757898,0x25971E99,0xE419C159,
    0xD917F154,0x18992E94,0x817B4895,0x40F59755,0x69CE82D6,0xA8405D16,0x31A23B17,0xF02CE4D7,
    0x63D41011,0xA25ACFD1,0x3BB8A9D0,0xFA367610,0xD30D6393,0x1283BC53,0x8B61DA52,0x4AEF0592,
    0xF17DBA48,0x30F36588,0xA9110389,0x689FDC49,0x41A4C9CA,0x802A160A,0x19C8700B,0xD846AFCB,
    0x4BBE5B0D,0x8A3084CD,0x13D2E2CC,0xD25C3D0C,0xFB67288F,0x3AE9F74F,0xA30B914E,0x62854E8E,
    0x5F8B7E83,0x9E05A143,0x07E7C742,0xC6691882,0xEF520D01,0x2EDCD2C1,0xB73EB4C0,0x76B06B00,
    0xE5489FC6,0x24C64006,0xBD242607,0x7CAAF9C7,0x5591EC44,0x941F3384,0x0DFD5585,0xCC738A45,
    0xA1A92C70,0x6027F3B0,0xF9C595B1,0x384B4A71,0x11705FF2,0xD0FE8032,0x491CE633,0x889239F3,
    0x1B6ACD35,0xDAE412F5,0x430674F4,0x8288AB34,0xABB3BEB7,0x6A3D6177,0xF3DF0776,0x3251D8B6,
    0x0F5FE8BB,0xCED1377B,0x5733517A,0x96BD8EBA,0xBF869B39,0x7E0844F9,0xE7EA22F8,0x2664FD38,
    0xB59C09FE,0x7412D63E,0xEDF0B03F,0x2C7E6FFF,0x05457A7C,0xC4CBA5BC,0x5D29C3BD,0x9CA71C7D,
    0x2735A3A7,0xE6BB7C67,0x7F591A66,0xBED7C5A6,0x97ECD025,0x56620FE5,0xCF8069E4,0x0E0EB624,
    0x9DF642E2,0x5C789D22,0xC59AFB23,0x041424E3,0x2D2F3160,0xECA1EEA0,0x754388A1,0xB4CD5761,
    0x89C3676C,0x484DB8AC,0xD1AFDEAD,0x1021016D,0x391A14EE,0xF894CB2E,0x6176AD2F,0xA0F872EF,
    0x33008629,0xF28E59E9,0x6B6C3FE8,0xAAE2E028,0x83D9F5AB,0x42572A6B,0xDBB54C6A,0x1A3B93AA,
  },
  {
    0x00000000,0x9BA54C6F,0xEC3B9E9F,0x779ED2F0,0x03063B7F,0x98A37710,0xEF3DA5E0,0x7498E98F,
    0x060C76FE,0x9DA93A91,0xEA37E861,0x7192A40E,0x050A4D81,0x9EAF01EE,0xE931D31E,0x72949F71,
    0x0C18EDFC,0x97BDA193,0xE0237363,0x7B863F0C,0x0F1ED683,0x94BB9AEC,0xE325481C,0x78800473,
    0x0A149B02,0x91B1D76D,0xE62F059D,0x7D8A49F2,0x0912A07D,0x92B7EC12,0xE5293EE2,0x7E8C728D,
    0x1831DBF8,0x83949797,0xF40A4567,0x6FAF0908,0x1B37E087,0x8092ACE8,0xF70C7E18,0x6CA93277,
    0x1E3DAD06,0x8598E169,0xF2063399,0x69A37FF6,0x1D3B9679,0x869EDA16,0xF10008E6,0x6AA54489,
    0x14293604,0x8F8C7A6B,0xF812A89B,0x63B7E4F4,0x172F0D7B,0x8C8A4114,0xFB1493E4,0x60B1DF8B,
    0x122540FA,0x89800C95,0xFE1EDE65,0x65BB920A,0x11237B85,0x8A8637EA,0xFD18E51A,0x66BDA975,
    0x3063B7F0,0xABC6FB9F,0xDC58296F,0x47FD6500,0x33658C8F,0xA8C0C0E0,0xDF5E1210,0x44FB5E7F,
    0x366FC10E,0xADCA8D61,0xDA545F91,0x41F113FE,0x3569FA71,0xAECCB61E,0xD95264EE,0x42F72881,
    0x3C7B5A0C,0xA7DE1663,0xD040C493,0x4BE588FC,0x3F7D6173,0xA4D82D1C,0xD346FFEC,0x48E3B383,
    0x3A772CF2,0xA1D2609D,0xD64CB26D,0x4DE9FE02,0x3971178D,0xA2D45BE2,0xD54A8912,0x4EEFC57D,
    0x28526C08,0xB3F72067,0xC469F297,0x5FCCBEF8,0x2B545777,0xB0F11B18,0xC76FC9E8,0x5CCA8587,
    0x2E5E1AF6,0xB5FB5699,0xC2658469,0x59C0C806,0x2D582189,0xB6FD6DE6,0xC163BF16,0x5AC6F379,
    0x244A81F4,0xBFEFCD9B,0xC8711F6B,0x53D45304,0x274CBA8B,0xBCE9F6E4,0xCB772414,0x50D2687B,
    0x2246F70A,0xB9E3BB65,0xCE7D6995,0x55D825FA,0x2140CC75,0xBAE5801A,0xCD7B52EA,0x56DE1E85,
    0x60C76FE0,0xFB62238F,0x8CFCF17F,0x1759BD10,0x63C1549F,0xF86418F0,0x8FFACA00,0x145F866F,
    0x66CB191E,0xFD6E5571,0x8AF08781,0x1155CBEE,0x65CD2261,0xFE686E0E,0x89F6BCFE,0x1253F091,
    0x6CDF821C,0xF77ACE73,0x80E41C83,0x1B4150EC,0x6FD9B963,0xF47CF50C,0x83E227FC,0x18476B93,
    0x6AD3F4E2,0xF176B88D,0x86E86A7D,0x1D4D2612,0x69D5CF9D,0xF27083F2,0x85EE5102,0x1E4B1D6D,
    0x78F6B418,0xE353F877,0x94CD2A87,0x0F6866E8,0x7BF08F67,0xE055C308,0x97CB11F8,0x0C6E5D97,
    0x7EFAC2E6,0xE55F8E89,0x92C15C79,0x09641016,0x7DFCF999,0xE659B5F6,0x91C76706,0x0A622B69,
    0x74EE59E4,0xEF4B158B,0x98D5C77B,0x03708B14,0x77E8629B,0xEC4D2EF4,0x9BD3FC04,0x0076B06B,
    0x72E22F1A,0xE9476375,0x9ED9B185,0x057CFDEA,0x71E41465,0xEA41580A,0x9DDF8AFA,0x067AC695,
    0x50A4D810,0xCB01947F,0xBC9F468F,0x273A0AE0,0x53A2E36F,0xC807AF00,0xBF997DF0,0x243C319F,
    0x56A8AEEE,0xCD0DE281,0xBA933071,0x21367C1E,0x55AE9591,0xCE0BD9FE,0xB9950B0E,0x22304761,
    0x5CBC35EC,0xC7197983,0xB087AB73,0x2B22E71C,0x5FBA0E93,0xC41F42FC,0xB381900C,0x2824DC63,
    0x5AB04312,0xC1150F7D,0xB68BDD8D,0x2D2E91E2,0x59B6786D,0xC2133402,0xB58DE6F2,0x2E28AA9D,
    0x489503E8,0xD3304F87,0xA4AE9D77,0x3F0BD118,0x4B933897,0xD03674F8,0xA7A8A608,0x3C0DEA67,
    0x4E997516,0xD53C3979,0xA2A2EB89,0x3907A7E6,0x4D9F4E69,0xD63A0206,0xA1A4D0F6,0x3A019C99,
    0x448DEE14,0xDF28A27B,0xA8B6708B,0x33133CE4,0x478BD56B,0xDC2E9904,0xABB04BF4,0x3015079B,
    0x428198EA,0xD924D485,0xAEBA0675,0x351F4A1A,0x4187A395,0xDA22EFFA,0xADBC3D0A,0x36197165,
  },
  {
    0x00000000,0xDD96D985,0x605CB54B,0xBDCA6CCE,0xC0B96A96,0x1D2FB313,0xA0E5DFDD,0x7D730658,
    0x5A03D36D,0x87950AE8,0x3A5F6626,0xE7C9BFA3,0x9ABAB9FB,0x472C607E,0xFAE60CB0,0x2770D535,
    0xB407A6DA,0x69917F5F,0xD45B1391,0x09CDCA14,0x74BECC4C,0xA92815C9,0x14E27907,0xC974A082,
    0xEE0475B7,0x3392AC32,0x8E58C0FC,0x53CE1979,0x2EBD1F21,0xF32BC6A4,0x4EE1AA6A,0x937773EF,
    0xB37E4BF5,0x6EE89270,0xD322FEBE,0x0EB4273B,0x73C72163,0xAE51F8E6,0x139B9428,0xCE0D4DAD,
    0xE97D9898,0x34EB411D,0x89212DD3,0x54B7F456,0x29C4F20E,0xF4522B8B,0x49984745,0x940E9EC0,
    0x0779ED2F,0xDAEF34AA,0x67255864,0xBAB381E1,0xC7C087B9,0x1A565E3C,0xA79C32F2,0x7A0AEB77,
    0x5D7A3E42,0x80ECE7C7,0x3D268B09,0xE0B0528C,0x9DC354D4,0x40558D51,0xFD9FE19F,0x2009381A,
    0xBD8D91AB,0x601B482E,0xDDD124E0,0x0047FD65,0x7D34FB3D,0xA0A222B8,0x1D684E76,0xC0FE97F3,
    0xE78E42C6,0x3A189B43,0x87D2F78D,0x5A442E08,0x27372850,0xFAA1F1D5,0x476B9D1B,0x9AFD449E,
    0x098A3771,0xD41CEEF4,0x69D6823A,0xB4405BBF,0xC9335DE7,0x14A58462,0xA96FE8AC,0x74F93129,
    0x5389E41C,0x8E1F3D99,0x33D55157,0xEE4388D2,0x93308E8A,0x4EA6570F,0xF36C3BC1,0x2EFAE244,
    0x0EF3DA5E,0xD36503DB,0x6EAF6F15,0xB339B690,0xCE4AB0C8,0x13DC694D,0xAE160583,0x7380DC06,
    0x54F00933,0x8966D0B6,0x34ACBC78,0xE93A65FD,0x944963A5,0x49DFBA20,0xF415D6EE,0x29830F6B,
    0xBAF47C84,0x6762A501,0xDAA8C9CF,0x073E104A,0x7A4D1612,0xA7DBCF97,0x1A11A359,0xC7877ADC,
    0xE0F7AFE9,0x3D61766C,0x80AB1AA2,0x5D3DC327,0x204EC57F,0xFDD81CFA,0x40127034,0x9D84A9B1,
    0xA06A2517,0x7DFCFC92,0xC036905C,0x1DA049D9,0x60D34F81,0xBD459604,0x008FFACA,0xDD19234F,
    0xFA69F67A,0x27FF2FFF,0x9A354331,0x47A39AB4,0x3AD09CEC,0xE7464569,0x5A8C29A7,0x871AF022,
    0x146D83CD,0xC9FB5A48,0x74313686,0xA9A7EF03,0xD4D4E95B,0x094230DE,0xB4885C10,0x691E8595,
    0x4E6E50A0,0x93F88925,0x2E32E5EB,0xF3A43C6E,0x8ED73A36,0x5341E3B3,0xEE8B8F7D,0x331D56F8,
    0x13146EE2,0xCE82B767,0x7348DBA9,0xAEDE022C,0xD3AD0474,0x0E3BDDF1,0xB3F1B13F,0x6E6768BA,
    0x4917BD8F,0x9481640A,0x294B08C4,0xF4DDD141,0x89AED719,0x54380E9C,0xE9F26252,0x3464BBD7,
    0xA713C838,0x7A8511BD,0xC74F7D73,0x1AD9A4F6,0x67AAA2AE,0xBA3C7B2B,0x07F617E5,0xDA60CE60,
    0xFD101B55,0x2086C2D0,0x9D4CAE1E,0x40DA779B,0x3DA971C3,0xE03FA846,0x5DF5C488,0x80631D0D,
    0x1DE7B4BC,0xC0716D39,0x7DBB01F7,0xA02DD872,0xDD5EDE2A,0x00C807AF,0xBD026B61,0x6094B2E4,
    0x47E467D1,0x9A72BE54,0x27B8D29A,0xFA2E0B1F,0x875D0D47,0x5ACBD4C2,0xE701B80C,0x3A976189,
    0xA9E01266,0x7476CBE3,0xC9BCA72D,0x142A7EA8,0x695978F0,0xB4CFA175,0x0905CDBB,0xD493143E,
    0xF3E3C10B,0x2E75188E,0x93BF7440,0x4E29ADC5,0x335AAB9D,0xEECC7218,0x53061ED6,0x8E90C753,
    0xAE99FF49,0x730F26CC,0xCEC54A02,0x13539387,0x6E2095DF,0xB3B64C5A,0x0E7C2094,0xD3EAF911,
    0xF49A2C24,0x290CF5A1,0x94C6996F,0x495040EA,0x342346B2,0xE9B59F37,0x547FF3F9,0x89E92A7C,
    0x1A9E5993,0xC7088016,0x7AC2ECD8,0xA754355D,0xDA273305,0x07B1EA80,0xBA7B864E,0x67ED5FCB,
    0x409D8AFE,0x9D0B537B,0x20C13FB5,0xFD57E630,0x8024E068,0x5DB239ED,0xE0785523,0x3DEE8CA6,
  },
  {
    0x00000000,0x9D0FE176,0xE16EC4AD,0x7C6125DB,0x19AC8F1B,0x84A36E6D,0xF8C24BB6,0x65CDAAC0,
    0x33591E36,0xAE56FF40,0xD237DA9B,0x4F383BED,0x2AF5912D,0xB7FA705B,0xCB9B5580,0x5694B4F6,
    0x66B23C6C,0xFBBDDD1A,0x87DCF8C1,0x1AD319B7,0x7F1EB377,0xE2115201,0x9E7077DA,0x037F96AC,
    0x55EB225A,0xC8E4C32C,0xB485E6F7,0x298A0781,0x4C47AD41,0xD1484C37,0xAD2969EC,0x3026889A,
    0xCD6478D8,0x506B99AE,0x2C0ABC75,0xB1055D03,0xD4C8F7C3,0x49C716B5,0x35A6336E,0xA8A9D218,
    0xFE3D66EE,0x63328798,0x1F53A243,0x825C4335,0xE791E9F5,0x7A9E0883,0x06FF2D58,0x9BF0CC2E,
    0xABD644B4,0x36D9A5C2,0x4AB88019,0xD7B7616F,0xB27ACBAF,0x2F752AD9,0x53140F02,0xCE1BEE74,
    0x988F5A82,0x0580BBF4,0x79E19E2F,0xE4EE7F59,0x8123D599,0x1C2C34EF,0x604D1134,0xFD42F042,
    0x41B9F7F1,0xDCB61687,0xA0D7335C,0x3DD8D22A,0x581578EA,0xC51A999C,0xB97BBC47,0x24745D31,
    0x72E0E9C7,0xEFEF08B1,0x938E2D6A,0x0E81CC1C,0x6B4C66DC,0xF64387AA,0x8A22A271,0x172D4307,
    0x270BCB9D,0xBA042AEB,0xC6650F30,0x5B6AEE46,0x3EA74486,0xA3A8A5F0,0xDFC9802B,0x42C6615D,
    0x1452D5AB,0x895D34DD,0xF53C1106,0x6833F070,0x0DFE5AB0,0x90F1BBC6,0xEC909E1D,0x719F7F6B,
    0x8CDD8F29,0x11D26E5F,0x6DB34B84,0xF0BCAAF2,0x95710032,0x087EE144,0x741FC49F,0xE91025E9,
    0xBF84911F,0x228B7069,0x5EEA55B2,0xC3E5B4C4,0xA6281E04,0x3B27FF72,0x4746DAA9,0xDA493BDF,
    0xEA6FB345,0x77605233,0x0B0177E8,0x960E969E,0xF3C33C5E,0x6ECCDD28,0x12ADF8F3,0x8FA21985,
    0xD936AD73,0x44394C05,0x385869DE,0xA55788A8,0xC09A2268,0x5D95C31E,0x21F4E6C5,0xBCFB07B3,
    0x8373EFE2,0x1E7C0E94,0x621D2B4F,0xFF12CA39,0x9ADF60F9,0x07D0818F,0x7BB1A454,0xE6BE4522,
    0xB02AF1D4,0x2D2510A2,0x51443579,0xCC4BD40F,0xA9867ECF,0x34899FB9,0x48E8BA62,0xD5E75B14,
    0xE5C1D38E,0x78CE32F8,0x04AF1723,0x99A0F655,0xFC6D5C95,0x6162BDE3,0x1D039838,0x800C794E,
    0xD698CDB8,0x4B972CCE,0x37F60915,0xAAF9E863,0xCF3442A3,0x523BA3D5,0x2E5A860E,0xB3556778,
    0x4E17973A,0xD318764C,0xAF795397,0x3276B2E1,0x57BB1821,0xCAB4F957,0xB6D5DC8C,0x2BDA3DFA,
    0x7D4E890C,0xE041687A,0x9C204DA1,0x012FACD7,0x64E20617,0xF9EDE761,0x858CC2BA,0x188323CC,
    0x28A5AB56,0xB5AA4A20,0xC9CB6FFB,0x54C48E8D,0x3109244D,0xAC06C53B,0xD067E0E0,0x4D680196,
    0x1BFCB560,0x86F35416,0xFA9271CD,0x679D90BB,0x02503A7B,0x9F5FDB0D,0xE33EFED6,0x7E311FA0,
    0xC2CA1813,0x5FC5F965,0x23A4DCBE,0xBEAB3DC8,0xDB669708,0x4669767E,0x3A0853A5,0xA707B2D3,
    0xF1930625,0x6C9CE753,0x10FDC288,0x8DF223FE,0xE83F893E,0x75306848,0x09514D93,0x945EACE5,
    0xA478247F,0x3977C509,0x4516E0D2,0xD81901A4,0xBDD4AB64,0x20DB4A12,0x5CBA6FC9,0xC1B58EBF,
    0x97213A49,0x0A2EDB3F,0x764FFEE4,0xEB401F92,0x8E8DB552,0x13825424,0x6FE371FF,0xF2EC9089,
    0x0FAE60CB,0x92A181BD,0xEEC0A466,0x73CF4510,0x1602EFD0,0x8B0D0EA6,0xF76C2B7D,0x6A63CA0B,
    0x3CF77EFD,0xA1F89F8B,0xDD99BA50,0x40965B26,0x255BF1E6,0xB8541090,0xC435354B,0x593AD43D,
    0x691C5CA7,0xF413BDD1,0x8872980A,0x157D797C,0x70B0D3BC,0xEDBF32CA,0x91DE1711,0x0CD1F667,
    0x5A454291,0xC74AA3E7,0xBB2B863C,0x2624674A,0x43E9CD8A,0xDEE62CFC,0xA2870927,0x3F88E851,
  },
  {
    0x00000000,0xB9FBDBE8,0xA886B191,0x117D6A79,0x8A7C6563,0x3387BE8B,0x22FAD4F2,0x9B010F1A,
    0xCF89CC87,0x7672176F,0x670F7D16,0xDEF4A6FE,0x45F5A9E4,0xFC0E720C,0xED731875,0x5488C39D,
    0x44629F4F,0xFD9944A7,0xECE42EDE,0x551FF536,0xCE1EFA2C,0x77E521C4,0x66984BBD,0xDF639055,
    0x8BEB53C8,0x32108820,0x236DE259,0x9A9639B1,0x019736AB,0xB86CED43,0xA911873A,0x10EA5CD2,
    0x88C53E9E,0x313EE576,0x20438F0F,0x99B854E7,0x02B95BFD,0xBB428015,0xAA3FEA6C,0x13C43184,
    0x474CF219,0xFEB729F1,0xEFCA4388,0x56319860,0xCD30977A,0x74CB4C92,0x65B626EB,0xDC4DFD03,
    0xCCA7A1D1,0x755C7A39,0x64211040,0xDDDACBA8,0x46DBC4B2,0xFF201F5A,0xEE5D7523,0x57A6AECB,
    0x032E6D56,0xBAD5B6BE,0xABA8DCC7,0x1253072F,0x89520835,0x30A9D3DD,0x21D4B9A4,0x982F624C,
    0xCAFB7B7D,0x7300A095,0x627DCAEC,0xDB861104,0x40871E1E,0xF97CC5F6,0xE801AF8F,0x51FA7467,
    0x0572B7FA,0xBC896C12,0xADF4066B,0x140FDD83,0x8F0ED299,0x36F50971,0x27886308,0x9E73B8E0,
    0x8E99E432,0x37623FDA,0x261F55A3,0x9FE48E4B,0x04E58151,0xBD1E5AB9,0xAC6330C0,0x1598EB28,
    0x411028B5,0xF8EBF35D,0xE9969924,0x506D42CC,0xCB6C4DD6,0x7297963E,0x63EAFC47,0xDA1127AF,
    0x423E45E3,0xFBC59E0B,0xEAB8F472,0x53432F9A,0xC8422080,0x71B9FB68,0x60C49111,0xD93F4AF9,
    0x8DB78964,0x344C528C,0x253138F5,0x9CCAE31D,0x07CBEC07,0xBE3037EF,0xAF4D5D96,0x16B6867E,
    0x065CDAAC,0xBFA70144,0xAEDA6B3D,0x1721B0D5,0x8C20BFCF,0x35DB6427,0x24A60E5E,0x9D5DD5B6,
    0xC9D5162B,0x702ECDC3,0x6153A7BA,0xD8A87C52,0x43A97348,0xFA52A8A0,0xEB2FC2D9,0x52D41931,
    0x4E87F0BB,0xF77C2B53,0xE601412A,0x5FFA9AC2,0xC4FB95D8,0x7D004E30,0x6C7D2449,0xD586FFA1,
    0x810E3C3C,0x38F5E7D4,0x29888DAD,0x90735645,0x0B72595F,0xB28982B7,0xA3F4E8CE,0x1A0F3326,
    0x0AE56FF4,0xB31EB41C,0xA263DE65,0x1B98058D,0x80990A97,0x3962D17F,0x281FBB06,0x91E460EE,
    0xC56CA373,0x7C97789B,0x6DEA12E2,0xD411C90A,0x4F10C610,0xF6EB1DF8,0xE7967781,0x5E6DAC69,
    0xC642CE25,0x7FB915CD,0x6EC47FB4,0xD73FA45C,0x4C3EAB46,0xF5C570AE,0xE4B81AD7,0x5D43C13F,
    0x09CB02A2,0xB030D94A,0xA14DB333,0x18B668DB,0x83B767C1,0x3A4CBC29,0x2B31D650,0x92CA0DB8,
    0x8220516A,0x3BDB8A82,0x2AA6E0FB,0x935D3B13,0x085C3409,0xB1A7EFE1,0xA0DA8598,0x19215E70,
    0x4DA99DED,0xF4524605,0xE52F2C7C,0x5CD4F794,0xC7D5F88E,0x7E2E2366,0x6F53491F,0xD6A892F7,
    0x847C8BC6,0x3D87502E,0x2CFA3A57,0x9501E1BF,0x0E00EEA5,0xB7FB354D,0xA6865F34,0x1F7D84DC,
    0x4BF54741,0xF20E9CA9,0xE373F6D0,0x5A882D38,0xC1892222,0x7872F9CA,0x690F93B3,0xD0F4485B,
    0xC01E1489,0x79E5CF61,0x6898A518,0xD1637EF0,0x4A6271EA,0xF399AA02,0xE2E4C07B,0x5B1F1B93,
    0x0F97D80E,0xB66C03E6,0xA711699F,0x1EEAB277,0x85EBBD6D,0x3C106685,0x2D6D0CFC,0x9496D714,
    0x0CB9B558,0xB5426EB0,0xA43F04C9,0x1DC4DF21,0x86C5D03B,0x3F3E0BD3,0x2E4361AA,0x97B8BA42,
    0xC33079DF,0x7ACBA237,0x6BB6C84E,0xD24D13A6,0x494C1CBC,0xF0B7C754,0xE1CAAD2D,0x583176C5,
    0x48DB2A17,0xF120F1FF,0xE05D9B86,0x59A6406E,0xC2A74F74,0x7B5C949C,0x6A21FEE5,0xD3DA250D,
    0x8752E690,0x3EA93D78,0x2FD45701,0x962F8CE9,0x0D2E83F3,0xB4D5581B,0xA5A83262,0x1C53E98A,
  },
  {
    0x00000000,0xAE689191,0x87A02563,0x29C8B4F2,0xD4314C87,0x7A59DD16,0x539169E4,0xFDF9F875,
    0x73139F4F,0xDD7B0EDE,0xF4B3BA2C,0x5ADB2BBD,0xA722D3C8,0x094A4259,0x2082F6AB,0x8EEA673A,
    0xE6273E9E,0x484FAF0F,0x61871BFD,0xCFEF8A6C,0x32167219,0x9C7EE388,0xB5B6577A,0x1BDEC6EB,
    0x9534A1D1,0x3B5C3040,0x129484B2,0xBCFC1523,0x4105ED56,0xEF6D7CC7,0xC6A5C835,0x68CD59A4,
    0x173F7B7D,0xB957EAEC,0x909F5E1E,0x3EF7CF8F,0xC30E37FA,0x6D66A66B,0x44AE1299,0xEAC68308,
    0x642CE432,0xCA4475A3,0xE38CC151,0x4DE450C0,0xB01DA8B5,0x1E753924,0x37BD8DD6,0x99D51C47,
    0xF11845E3,0x5F70D472,0x76B86080,0xD8D0F111,0x25290964,0x8B4198F5,0xA2892C07,0x0CE1BD96,
    0x820BDAAC,0x2C634B3D,0x05ABFFCF,0xABC36E5E,0x563A962B,0xF85207BA,0xD19AB348,0x7FF222D9,
    0x2E7EF6FA,0x8016676B,0xA9DED399,0x07B64208,0xFA4FBA7D,0x54272BEC,0x7DEF9F1E,0xD3870E8F,
    0x5D6D69B5,0xF305F824,0xDACD4CD6,0x74A5DD47,0x895C2532,0x2734B4A3,0x0EFC0051,0xA09491C0,
    0xC859C864,0x663159F5,0x4FF9ED07,0xE1917C96,0x1C6884E3,0xB2001572,0x9BC8A180,0x35A03011,
    0xBB4A572B,0x1522C6BA,0x3CEA7248,0x9282E3D9,0x6F7B1BAC,0xC1138A3D,0xE8DB3ECF,0x46B3AF5E,
    0x39418D87,0x97291C16,0xBEE1A8E4,0x10893975,0xED70C100,0x43185091,0x6AD0E463,0xC4B875F2,
    0x4A5212C8,0xE43A8359,0xCDF237AB,0x639AA63A,0x9E635E4F,0x300BCFDE,0x19C37B2C,0xB7ABEABD,
    0xDF66B319,0x710E2288,0x58C6967A,0xF6AE07EB,0x0B57FF9E,0xA53F6E0F,0x8CF7DAFD,0x229F4B6C,
    0xAC752C56,0x021DBDC7,0x2BD50935,0x85BD98A4,0x784460D1,0xD62CF140,0xFFE445B2,0x518CD423,
    0x5CFDEDF4,0xF2957C65,0xDB5DC897,0x75355906,0x88CCA173,0x26A430E2,0x0F6C8410,0xA1041581,
    0x2FEE72BB,0x8186E32A,0xA84E57D8,0x0626C649,0xFBDF3E3C,0x55B7AFAD,0x7C7F1B5F,0xD2178ACE,
    0xBADAD36A,0x14B242FB,0x3D7AF609,0x93126798,0x6EEB9FED,0xC0830E7C,0xE94BBA8E,0x47232B1F,
    0xC9C94C25,0x67A1DDB4,0x4E696946,0xE001F8D7,0x1DF800A2,0xB3909133,0x9A5825C1,0x3430B450,
    0x4BC29689,0xE5AA0718,0xCC62B3EA,0x620A227B,0x9FF3DA0E,0x319B4B9F,0x1853FF6D,0xB63B6EFC,
    0x38D109C6,0x96B99857,0xBF712CA5,0x1119BD34,0xECE04541,0x4288D4D0,0x6B406022,0xC528F1B3,
    0xADE5A817,0x038D3986,0x2A458D74,0x842D1CE5,0x79D4E490,0xD7BC7501,0xFE74C1F3,0x501C5062,
    0xDEF63758,0x709EA6C9,0x5956123B,0xF73E83AA,0x0AC77BDF,0xA4AFEA4E,0x8D675EBC,0x230FCF2D,
    0x72831B0E,0xDCEB8A9F,0xF5233E6D,0x5B4BAFFC,0xA6B25789,0x08DAC618,0x211272EA,0x8F7AE37B,
    0x01908441,0xAFF815D0,0x8630A122,0x285830B3,0xD5A1C8C6,0x7BC95957,0x5201EDA5,0xFC697C34,
    0x94A42590,0x3ACCB401,0x130400F3,0xBD6C9162,0x40956917,0xEEFDF886,0xC7354C74,0x695DDDE5,
    0xE7B7BADF,0x49DF2B4E,0x60179FBC,0xCE7F0E2D,0x3386F658,0x9DEE67C9,0xB426D33B,0x1A4E42AA,
    0x65BC6073,0xCBD4F1E2,0xE21C4510,0x4C74D481,0xB18D2CF4,0x1FE5BD65,0x362D0997,0x98459806,
    0x16AFFF3C,0xB8C76EAD,0x910FDA5F,0x3F674BCE,0xC29EB3BB,0x6CF6222A,0x453E96D8,0xEB560749,
    0x839B5EED,0x2DF3CF7C,0x043B7B8E,0xAA53EA1F,0x57AA126A,0xF9C283FB,0xD00A3709,0x7E62A698,
    0xF088C1A2,0x5EE05033,0x7728E4C1,0xD9407550,0x24B98D25,0x8AD11CB4,0xA319A846,0x0D7139D7,
  }
};
/// LICENSE_END.10

/*
	File-funtions section
*/

string wintolinuxpath(const string& i_path)
{
	string risultato=i_path;
	myreplaceall(risultato,"\\","/");
	return risultato;
}

string includetrailingbackslash(string i_dir)
{
	/// fix for altered-string (!)
	string mydir=i_dir;
	if (mydir.size()==2)
		if (isalpha(mydir[0]))
			if (mydir[1]==':')
				return mydir+"/";
	if (!isdirectory(i_dir))
		return i_dir+"/";
	else
		return i_dir;
}

#ifdef _WIN32
bool eol() 
{
    CONSOLE_SCREEN_BUFFER_INFO csbi;
    HANDLE hConsole = GetStdHandle(STD_OUTPUT_HANDLE);
    
    if (hConsole == INVALID_HANDLE_VALUE) 
	    return false;
    
    if (!GetConsoleScreenBufferInfo(hConsole, &csbi)) 
	    return false;
    
    DWORD chars_to_clear = csbi.dwSize.X - csbi.dwCursorPosition.X;
    DWORD written;
    
    if (!FillConsoleOutputCharacterA(hConsole, ' ', chars_to_clear, csbi.dwCursorPosition, &written)) 
	    return false;
    
    if (!SetConsoleCursorPosition(hConsole, csbi.dwCursorPosition)) 
	    return false;
    return true;
}
#else
/*
bool eol() 
{
    int result = printf("\033[K");
    if (result < 0) {
        return false;
    }
    
    if (fflush(stdout) != 0) {
        return false;
    }
    
    return true;
}
*/

bool eol() 
{
    if (!isatty(STDOUT_FILENO)) 
        return false;
    
    struct winsize w;
    if (ioctl(STDOUT_FILENO, TIOCGWINSZ, &w) == -1)
        return false;
    
    printf("\033[K");
    fflush(stdout);
    
    return true;
}
#endif


// Windows/Linux compatible file type
#ifdef unix
typedef FILE* FP;
const FP FPNULL=NULL;
const char* const RB="rb";
const char* const WB="wb";
const char* const RBPLUS="rb+";
const char* const ABPLUS="ab+";
const char* const AB="ab";
vector<FP> 		g_write_fp;
vector<string> 	g_write_filename;
FP myfopen(const char* filename, const char* mode,int64_t i_date=0)
{
	if (g_control_c)
	{
		myprintf("\n\nThe house is closed by control-c!\n");
		return FPNULL;
	}
	FP risultato=fopen(filename,mode);
	if (risultato!=FPNULL)
	{
#if (!defined(SOLARIS))
		if (i_date!=0)
			if (strcmp(mode, WB) == 0 || strcmp(mode, AB) == 0 || strcmp(mode, ABPLUS) == 0) 
			{
				struct timeval times[2];
				time_t nowz;
				time(&nowz);
				const struct tm *local = localtime(&nowz);
				if (local == NULL) 
				{
					myprintf("40525! guru on tm\n");
				} 
				else 
				{
					times[0].tv_sec 	= unix_time(i_date) - local->tm_gmtoff;  // atime
					times[0].tv_usec 	= 0;
					times[1].tv_sec 	= unix_time(i_date) - - local->tm_gmtoff;  // mtime
					times[1].tv_usec 	= 0;
					if (futimes(fileno(risultato),times)!=0)
						myprintf("39787! WARN Linux myfopen futimes error!\n");
					else
					{
						if (flagverbose)
							myprintf("39791: Linux setting times OK at %s\n",migliaia(i_date));
					}
				}
			}
#endif // corresponds to #if (#if (!defined(SOLARIS)))
		if (g_chunk_size>0)
			if (strcmp(mode,RB)!=0)
			{
				g_write_fp.push_back(risultato);
				g_write_filename.push_back(filename);
#ifndef ESX
				if (flagdebug3)
					myprintf("00082: write on               (pool %s)         |%s|         %s\n",migliaia(g_write_fp.size()),migliaia(int64_t(risultato)),filename);
#endif
			}
	}
	return risultato;
}

int myfclose(FP* fp)
{
	if ((*fp)==FPNULL)
	{	
		if (flagdebug)
			myprintf("00083: fclose on unix FPNULL ignored\n");
		return EOF;
	}

	if (g_chunk_size>0)
	{
		for (unsigned int i=0;i<g_write_fp.size();i++)
			if ((*fp)==g_write_fp[i])
			{
				g_write_fp.erase(g_write_fp.begin()+i);
				g_write_filename.erase(g_write_filename.begin()+i);
				if (flagdebug3)
					myprintf("00084: ***********=============== [3] %d EUREKONAAA %s\n",i,g_write_filename[i].c_str());
				break;
			}
#ifndef ESX
		if (flagdebug3)
			myprintf("00085: EXIT da eliminazione fp %s\n",migliaia(int64_t(*fp)));
#endif
	}
#ifndef ESX
	if (flagdebug3)
		myprintf("00086: pre closing fp %s\n",migliaia(int64_t(*fp)));
#endif
	int risultato=fclose(*fp);
#ifndef ESX	
	if (flagdebug3)
		myprintf("00087: post closing fp %s result %d\n",migliaia(int64_t(*fp)),risultato);
#endif
	*fp=FPNULL;
#ifndef ESX
	if (flagdebug3)
		myprintf("00088: fp now %s\n",migliaia(int64_t(*fp)));
#endif
	return risultato;
}

void tocca_now(FP i_fp)
{
	if (i_fp==FPNULL)
		return;
	int64_t date=now();
#if (!defined(SOLARIS))
	struct timeval times[2];
	time_t nowz;
	time(&nowz);
	const struct tm *local = localtime(&nowz);
	if (local == NULL) 
	{
		myprintf("48735! guru on tm  (2)\n");
	} 
	else 
	{
		times[0].tv_sec = unix_time(date) - local->tm_gmtoff;  // atime
		times[0].tv_usec = 0;
		times[1].tv_sec = unix_time(date) - local->tm_gmtoff;  // mtime 
		times[1].tv_usec = 0;
		if (futimes(fileno(i_fp), times) != 0) 
			myprintf("48744! WARN Linux tocca_now futimes error!\n");
	}
#endif

}

#else // Windows
typedef HANDLE FP;
const FP FPNULL=INVALID_HANDLE_VALUE;
vector<FP> 		g_write_fp;
vector<string> 	g_write_filename;



void tocca_now(FP i_fp)
{
	
	if (i_fp==FPNULL)
		return;
	
	if (flagdebug)
		myprintf("48718: Windows tocca_now %s\n",migliaia(int64_t(i_fp)));
	SYSTEMTIME st;
	GetLocalTime(&st);
	FILETIME ft,ftutc;
	SystemTimeToFileTime(&st, &ft);
	LocalFileTimeToFileTime(&ft, &ftutc);
	
	// Debug: converti il FILETIME UTC in SYSTEMTIME per visualizzare la data/ora
	SYSTEMTIME st_utc;  // <-- Questa riga mancava!
	FileTimeToSystemTime(&ftutc, &st_utc);
/*
	color_cyan(); // o un altro colore per distinguere
	myprintf("DEBUG: Impostando file time UTC: %04d-%02d-%02d %02d:%02d:%02d.%03d\n",
		st_utc.wYear, st_utc.wMonth, st_utc.wDay,
		st_utc.wHour, st_utc.wMinute, st_utc.wSecond, st_utc.wMilliseconds);
	color_restore();
*/	
	if (!SetFileTime(i_fp, NULL, NULL, &ftutc))
		myprintf("48725! WARN tocca_now cannot set filetime (error %s) su fp %s\n",migliaia((int64_t)GetLastError()),migliaia2(int64_t(i_fp)));
}

typedef enum {RB, WB, RBPLUS, WBPLUS} MODE;  // fopen modes



// Open file. Only modes "rb", "wb", "rb+" and "wb+" are supported on WINDOWS
FP myfopen(const char* filename, MODE mode, int64_t i_date=0)
{
	
	if (g_control_c)
	{
		myprintf("\n\nThe house is closed by control-c!\n");
		return FPNULL;
	}
	if (filename==NULL)
	{
		myprintf("39836$ myfopen with NULL filename!\n");
		return FPNULL;
	}
	DWORD access=0;
	if (mode!=WB) access=GENERIC_READ;
	if (mode!=RB) access|=GENERIC_WRITE;
	DWORD disp=OPEN_ALWAYS;  // wb or wb+
	if (mode==RB || mode==RBPLUS) disp=OPEN_EXISTING;
	DWORD share=FILE_SHARE_READ;
	if (mode==RB) share|=FILE_SHARE_WRITE|FILE_SHARE_DELETE;
///	kludge: we are doing a "C:" backup, bypass ACLS
	if (command=='q')
	{
		if (flagdebug3)
			myprintf("39851: fopen with command 'q' CreateFile\n");
		return CreateFile(utow(filename).c_str(), access, share,NULL, disp, FILE_FLAG_BACKUP_SEMANTICS, NULL);
	}
	if (flagdebug3)
		myprintf("00089: CreateFile\n");
	
	
	FP risultato=CreateFile(utow(filename).c_str(), access, share,NULL, disp, FILE_ATTRIBUTE_NORMAL , NULL);
	if (flagdebug3)
		myprintf("00090: Createfile risultato %s\n",migliaia(int64_t(risultato)));
	
#if _WIN32
	if (risultato!=FPNULL)
		if ((mode==WB) || (mode==WBPLUS))
			if (flagsparse)
			{
				DWORD bytesReturned;
				if (!DeviceIoControl(risultato, FSCTL_SET_SPARSE, NULL, 0, NULL, 0, &bytesReturned, NULL))
					myprintf("39875! failed to set sparse attribute (error %s) on %Z\n",migliaia((int64_t)GetLastError()),filename);
				else
				{
					if (flagdebug)
					{
						color_green();
						myprintf("39876: file successfully set as sparse: %Z\n",filename);
						eol();
						color_restore();
					}
				}
			}
#endif
	if ((mode==WB) || (mode==WBPLUS))
		if (i_date!=0)
		{
			SYSTEMTIME st;
			st.wYear			=i_date/10000000000LL%10000;
			st.wMonth			=i_date/100000000%100;
			st.wDayOfWeek		=0;  // ignored
			st.wDay				=i_date/1000000%100;
			st.wHour			=i_date/10000%100;
			st.wMinute			=i_date/100%100;
			st.wSecond			=i_date%100;
			st.wMilliseconds	=0;
			FILETIME ft;
			SystemTimeToFileTime(&st, &ft);
			if (flagdebug3)
				myprintf("39874: setting filetime on myfopen at %s\n",migliaia(i_date));
			if (!SetFileTime(risultato, NULL, NULL, &ft))
				myprintf("39387! failed settime (error %s) on %Z\n",migliaia((int64_t)GetLastError()),filename);
		}
	if (g_chunk_size>0)
		if ((mode==WB) || (mode==WBPLUS))
		{
			g_write_fp.push_back(risultato);
			g_write_filename.push_back(filename);
			if (flagdebug3)
				myprintf("00091: write on               (pool %s)         |%s|         %s\n",migliaia(g_write_fp.size()),migliaia(int64_t(risultato)),filename);
		}
	return risultato;
	
}
int myfclose(FP* fp)
{
	if ((*fp)==FPNULL)
	{	
		if (flagdebug)
			myprintf("00092: win fclose on FPNULL ignored\n");
		return EOF;
	}
		
	if (g_chunk_size>0)
	{
		for (unsigned int i=0;i<g_write_fp.size();i++)
			if ((*fp)==g_write_fp[i])
			{
				g_write_fp.erase(g_write_fp.begin()+i);
				g_write_filename.erase(g_write_filename.begin()+i);
				if (flagdebug3)
					myprintf("00093: ***********=============== [4] %d EUREKONAAA %s\n",i,g_write_filename[i].c_str());
				break;
			}
		if (flagdebug3)
			myprintf("00094: EXIT da eliminazione fp %s\n",migliaia(int64_t(*fp)));
	}

	if (flagdebug3)
		myprintf("00095: pre closing fp %s\n",migliaia(int64_t(*fp)));
	int risultato=CloseHandle(*fp) ? 0 : EOF;
	if (flagdebug3)
		myprintf("00096: post closing fp %s result %d\n",migliaia(int64_t(*fp)),risultato);
	*fp=FPNULL;
	if (flagdebug3)
		myprintf("00097: fp now %s\n",migliaia(int64_t(*fp)));
	return risultato;
}
// Read nobj objects of size size into ptr. Return number of objects read.
size_t fread(void* ptr, size_t size, size_t nobj, FP fp) {
  DWORD r=0;
  ReadFile(fp, ptr, size*nobj, &r, NULL);
  if (size>1) r/=size;
  return r;
}
// Get file position
int64_t ftello(FP fp) {
	if ((int64_t)fp==0)
	{
		myprintf("00098! ftello on FP zero\n");
		return 0;
	}
  LONG h=0;
  DWORD r=SetFilePointer(fp, 0, &h, FILE_CURRENT);
  return r+(uint64_t(h)<<32);
}


// Move file pointer by offset. origin is SEEK_SET (from start), SEEK_CUR,
// (from current position), or SEEK_END (from end).
int fseeko(FP fp, int64_t offset, int origin) {
  if (origin==SEEK_SET) origin=FILE_BEGIN;
  else if (origin==SEEK_CUR) origin=FILE_CURRENT;
  else if (origin==SEEK_END) origin=FILE_END;
  LONG h=uint64_t(offset)>>32;
  SetFilePointer(fp, offset&0xffffffffull, &h, origin);
  return GetLastError()!=NO_ERROR;
}

#endif // corresponds to #ifdef (#ifdef unix)

FP 			g_fp_zpaq				=0;
int			g_crc32_sequence_data	=0;
int			g_crc32_sequence_index	=0;
uint32_t  	g_crc32_index			=0;
			


#ifdef _WIN32
std::string getwinexedir() 
{
    char fullPath[MAX_PATH];
    DWORD result = GetModuleFileNameA(NULL, fullPath, MAX_PATH); // Use ANSI version
    
    if (result == 0 || result == MAX_PATH) 
	{
		myprintf("\n");
		myprintf("51348! getwinexedir() KO => seppuku\n");
		seppuku();
        return std::string(); // Error or buffer too small
    }
    // Convert to std::string for easier manipulation
    std::string path(fullPath);
    
    // Find last backslash
    size_t lastBackslash = path.find_last_of('\\');
    if (lastBackslash == std::string::npos) 
	    return std::string(); // No separator found
    // Return only the directory (without the file name)
    return includetrailingbackslash(wintolinuxpath(path.substr(0, lastBackslash)));
}
#endif



std::string generaterandomstring(unsigned int i_length) 
{
    if (i_length == 0) 
	{
        myprintf("03168: i_length in C5\n");
        seppuku();
    }

    static const char characters[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
    const size_t charset_size = sizeof(characters) - 1;

    char* randomstring = (char*)franz_malloc(i_length + 1);
    if (randomstring == NULL) 
	{
        myprintf("03169: C5 on malloc\n");
        seppuku();
    }

#ifdef __OpenBSD__
    // OpenBSD: use arc4random_uniform 
    for (unsigned int i = 0; i < i_length; ++i) 
	    randomstring[i] = characters[arc4random_uniform(charset_size)];
#else
    // Other platforms: keep rand and srand
    srand((unsigned)time(NULL));
    for (unsigned int i = 0; i < i_length; ++i) 
	    randomstring[i] = characters[rand() % charset_size];
#endif

    randomstring[i_length] = '\0';
    std::string risultato = randomstring;
    franz_free(randomstring);
    return risultato;
}

#ifdef _WIN64

class downcallback : public IBindStatusCallback
{
private:
    LONG m_cRef; // Reference counting for COM

public:
    downcallback() : m_cRef(1) {}
    virtual ~downcallback() {}

    // IUnknown methods
    STDMETHODIMP QueryInterface(REFIID, void**)
    {
        return E_NOINTERFACE; // We do not support other interfaces in this minimal implementation
    }

    STDMETHODIMP_(ULONG) AddRef()
    {
        return InterlockedIncrement(&m_cRef);
    }

    STDMETHODIMP_(ULONG) Release()
    {
        LONG cRef = InterlockedDecrement(&m_cRef);
        if (cRef == 0)
        {
            delete this;
            return 0;
        }
        return cRef;
    }

    // IBindStatusCallback methods
    STDMETHODIMP OnStartBinding(DWORD, IBinding*)
    {
        return S_OK;
    }

    STDMETHODIMP GetPriority(LONG*)
    {
        return E_NOTIMPL; // Priority not implemented
    }

    STDMETHODIMP OnLowResource(DWORD)
    {
        return S_OK;
    }

	STDMETHODIMP OnProgress(ULONG, ULONG, ULONG, LPCWSTR)
	{
	    // Example of minimal logic: use ulProgress and ulProgressMax
        // You can add logic here to update a progress bar
    	return S_OK;
	}
    
    STDMETHODIMP OnStopBinding(HRESULT, LPCWSTR)
    {
        return S_OK;
    }

    STDMETHODIMP GetBindInfo(DWORD*, BINDINFO*)
    {
        return S_OK;
    }

    STDMETHODIMP OnDataAvailable(DWORD, DWORD, FORMATETC*, STGMEDIUM*)
    {
        return S_OK;
    }

    STDMETHODIMP OnObjectAvailable(REFIID, IUnknown*)
    {
        return S_OK;
    }
};
#endif // corresponds to #ifdef (#ifdef _WIN64)

bool downloadfile(string i_verurl, string i_verfile, bool i_showupdate)
{
#if defined(SOLARIS) || defined(__HAIKU__)
    return false;
#else
    if (i_verurl == "")
    {
        myprintf("03170: i_verurl empty\n");
        return false;
    }
    if (i_verfile == "")
    {
        myprintf("03171: i_verfile empty\n");
        return false;
    }
    
    if (flagverbose)
    {
        myprintf("03172: Download from URL %s\n", i_verurl.c_str());
        myprintf("03173: to file           %s\n", i_verfile.c_str());
    }

#ifdef _WIN32
    if (flagdebug3)
        myprintf("03174: WIN32 version of filedownload\n");

#ifdef _WIN64
    downcallback thecallback;
    downcallback* p_thecallback = NULL;
    
    if (i_showupdate)
        p_thecallback = &thecallback;
    
    if (S_OK != URLDownloadToFileW(NULL, utow(i_verurl.c_str()).c_str(), utow(i_verfile.c_str()).c_str(), 0, p_thecallback))
#else
    if (S_OK != URLDownloadToFileW(NULL, utow(i_verurl.c_str()).c_str(), utow(i_verfile.c_str()).c_str(), 0, 0))
#endif
    {
        myprintf("03175: Download failed C5 (no internet?)  %s\n",i_verurl.c_str());
        return false;
    }
#else
#define INTERNET_BUFFER_SIZE 1024

	if (i_showupdate)
		if (i_verurl=="be quiet")
			myprintf("be quiet\n");

    if (flagdebug)
        myprintf("03176: starting *nix download\n");
    
    char buffer[INTERNET_BUFFER_SIZE];
    char *hostname, *path;
    const char *url = i_verurl.c_str();
    if (flagdebug3)
        myprintf("03177: before test1\n");
    
    if (strncmp(url, "http://", 7) == 0) 
        hostname = strdup(url + 7);
    else 
    {
        myprintf("03178: Download work only on http\n");
        return false;
    }
    if (flagdebug3)
        myprintf("03179: before test2\n");
    
    path = strchr(hostname, '/');
    if (path == NULL) 
    {
        myprintf("03180: cannot strchr / in hostname!\n");
        free(hostname);
        return false;
    }
    else 
    {
        *path = '\0';
        path++;
    }
    if (flagdebug3)
        myprintf("03181: path |%s|\n", path);

#ifndef IPV6
    int sockfd = socket(AF_INET, SOCK_STREAM, 0);
    if (sockfd < 0)
    {
        myprintf("03182: Error C5: socket kaputt\n");
        free(hostname);
        return false;
    }

    struct hostent *server = gethostbyname(hostname);
    if (server == NULL) 
    {
        myprintf("03183$ cannot resolve %s\n", hostname);
        free(hostname);
        return false;
    }

    struct sockaddr_in serv_addr;
    memset((char *) &serv_addr, 0, sizeof(serv_addr));
    serv_addr.sin_family = AF_INET;
    bcopy((char *)server->h_addr, (char *)&serv_addr.sin_addr.s_addr, server->h_length);
    serv_addr.sin_port = htons(80);

    if (connect(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) 
    {
        myprintf("03184$ C5 on connect\n");
        free(hostname);
        return false;
    }
#else
    struct addrinfo hints;
    memset(&hints, 0, sizeof(hints));
    hints.ai_flags = AI_ADDRCONFIG | AI_NUMERICSERV;
    hints.ai_family = AF_UNSPEC;
    hints.ai_socktype = SOCK_STREAM;
    hints.ai_protocol = 0;
    hints.ai_addrlen = 0;
    hints.ai_addr = NULL;
    hints.ai_canonname = NULL;
    hints.ai_next = NULL;

    struct addrinfo *addresses = NULL;
    int ret = getaddrinfo(hostname, "80", &hints, &addresses);
    if (ret) 
    {
        myprintf("03183$ IPV6 cannot resolve %s: %s\n", hostname, gai_strerror(ret));
        free(hostname); // Added free here
        return false;
    }

    int sockfd;
    struct addrinfo *address;
    for (address = addresses; address; address = address->ai_next) 
    {
        sockfd = socket(address->ai_family, address->ai_socktype, address->ai_protocol);
        if (sockfd == -1)
            continue;
        if (!connect(sockfd, address->ai_addr, address->ai_addrlen))
            break;
        close(sockfd);
    }
    freeaddrinfo(addresses);
    if (address == NULL) 
    {
        myprintf("39345$ IPV6 C5 on connect\n");
        free(hostname); // Added free here
        return false;
    }
#endif

    snprintf(buffer, INTERNET_BUFFER_SIZE, "GET /%s HTTP/1.1\r\nHost: %s\r\nConnection: close\r\n\r\n", path, hostname);
    
    free(hostname);
    if (write(sockfd, buffer, strlen(buffer)) < 0) 
    {
        myprintf("03185: kaputt writing on socket\n");
        close(sockfd); // Added close here
        return false;
    }

    FILE *file = fopen(i_verfile.c_str(), "wb");
    if (file == NULL) 
    {
        myprintf("03186: cannot open file to write %s\n", i_verfile.c_str());
        close(sockfd); // Added close here
        return false;
    }
    ssize_t n;
    while ((n = read(sockfd, buffer, INTERNET_BUFFER_SIZE)) > 0) 
    {
        if (flagdebug3)
            myprintf("03187: read %s from socket\n", migliaia(n));
        fwrite(buffer, 1, n, file);
    }
    if (n < 0) 
    {
        myprintf("03188: socket negative!\n");
        fclose(file);
        close(sockfd);
        return false;
    }
    fclose(file);
    close(sockfd);
    return (prendidimensionefile(i_verfile.c_str()) > 0);
#endif
#endif
	return true;
}



/// LICENSE_START.12
/* crc32c.c -- compute CRC-32C using the Intel crc32 instruction
 * Copyright (C) 2013, 2015, 2021 Mark Adler
 * Version 1.4  31 May 2021  Mark Adler

  This software is provided 'as-is', without any express or implied
  warranty.  In no event will the author be held liable for any damages
  arising from the use of this software.
  Permission is granted to anyone to use this software for any purpose,
  including commercial applications, and to alter it and redistribute it
  freely, subject to the following restrictions:
  1. The origin of this software must not be misrepresented; you must not
     claim that you wrote the original software. If you use this software
     in a product, an acknowledgment in the product documentation would be
     appreciated but is not required.
  2. Altered source versions must be plainly marked as such, and must not be
     misrepresented as being the original software.
  3. This notice may not be removed or altered from any source distribution.
  Mark Adler
  madler@alumni.caltech.edu

 Reworked and fixed by me
*/
#define POLY 0x82f63b78

#ifdef __WIN64

/* Hardware CRC-32C for Intel and compatible processors. */
static inline uint32_t gf2_matrix_times(uint32_t *mat, uint32_t vec) {
    uint32_t sum = 0;
    while (vec) {
        if (vec & 1)
            sum ^= *mat;
        vec >>= 1;
        mat++;
    }
    return sum;
}
static inline void gf2_matrix_square(uint32_t *square, uint32_t *mat) {
    for (unsigned n = 0; n < 32; n++)
        square[n] = gf2_matrix_times(mat, mat[n]);
}
static void crc32c_zeros_op(uint32_t *even, size_t len) {
    uint32_t odd[32];       /* odd-power-of-two zeros operator */

    /* put operator for one zero bit in odd */
    odd[0] = POLY;              /* CRC-32C polynomial */
    uint32_t row = 1;
    for (unsigned n = 1; n < 32; n++) {
        odd[n] = row;
        row <<= 1;
    }

    /* put operator for two zero bits in even */
    gf2_matrix_square(even, odd);

    /* put operator for four zero bits in odd */
    gf2_matrix_square(odd, even);

    /* first square will put the operator for one zero byte (eight zero bits),
       in even -- next square puts operator for two zero bytes in odd, and so
       on, until len has been rotated down to zero */
    do {
        gf2_matrix_square(even, odd);
        len >>= 1;
        if (len == 0)
            return;
        gf2_matrix_square(odd, even);
        len >>= 1;
    } while (len);

    /* answer ended up in odd -- copy to even */
    for (unsigned n = 0; n < 32; n++)
        even[n] = odd[n];
}

/* Take a length and build four lookup tables for applying the zeros operator
   for that length, byte-by-byte on the operand. */
static void crc32c_zeros(uint32_t zeros[][256], size_t len) {
    uint32_t op[32];

    crc32c_zeros_op(op, len);
    for (unsigned n = 0; n < 256; n++) {
        zeros[0][n] = gf2_matrix_times(op, n);
        zeros[1][n] = gf2_matrix_times(op, n << 8);
        zeros[2][n] = gf2_matrix_times(op, n << 16);
        zeros[3][n] = gf2_matrix_times(op, n << 24);
    }
}

/* Apply the zeros operator table to crc. */
static inline uint32_t crc32c_shift(uint32_t zeros[][256], uint32_t crc) {
    return zeros[0][crc & 0xff] ^ zeros[1][(crc >> 8) & 0xff] ^
           zeros[2][(crc >> 16) & 0xff] ^ zeros[3][crc >> 24];
}

/* Block sizes for three-way parallel crc computation.  LONG and MYSHORT must
   both be powers of two.  The associated string constants must be set
   accordingly, for use in constructing the assembler instructions. */
#define MYLONG 8192
#define LONGx1 "8192"
#define LONGx2 "16384"
#define MYSHORT 256
#define SHORTx1 "256"
#define SHORTx2 "512"

/* Tables for hardware crc that shift a crc by LONG and MYSHORT zeros. */
static pthread_once_t crc32c_once_hw = PTHREAD_ONCE_INIT;
static uint32_t crc32c_long[4][256];
static uint32_t crc32c_short[4][256];

/* Initialize tables for shifting crcs. */
static void crc32c_init_hw(void) {
    crc32c_zeros(crc32c_long, MYLONG);
    crc32c_zeros(crc32c_short, MYSHORT);
}

/* Compute CRC-32C using the Intel hardware instruction. */
static uint32_t crc32c_hw(uint32_t crc, unsigned char const *buf, size_t len) {
    /* populate shift tables the first time through */
    pthread_once(&crc32c_once_hw, crc32c_init_hw);

    /* pre-process the crc */
    crc = ~crc;
    uint64_t crc0 = crc;            /* 64-bits for crc32q instruction */

    /* compute the crc for up to seven leading bytes to bring the data pointer
       to an eight-byte boundary */
    unsigned char const *next =  buf;
    while (len && ((uintptr_t)next & 7) != 0) {
        __asm__("crc32b\t" "(%1), %0"
                : "=r"(crc0)
                : "r"(next), "0"(crc0));
        next++;
        len--;
    }

    /* compute the crc on sets of LONG*3 bytes, executing three independent crc
       instructions, each on LONG bytes -- this is optimized for the Nehalem,
       Westmere, Sandy Bridge, and Ivy Bridge architectures, which have a
       throughput of one crc per cycle, but a latency of three cycles */
    while (len >= MYLONG*3) {
        uint64_t crc1 = 0;
        uint64_t crc2 = 0;
        unsigned char const * const end = next + MYLONG;
        do {
            __asm__("crc32q\t" "(%3), %0\n\t"
                    "crc32q\t" LONGx1 "(%3), %1\n\t"
                    "crc32q\t" LONGx2 "(%3), %2"
                    : "=r"(crc0), "=r"(crc1), "=r"(crc2)
                    : "r"(next), "0"(crc0), "1"(crc1), "2"(crc2));
            next += 8;
        } while (next < end);
        crc0 = crc32c_shift(crc32c_long, crc0) ^ crc1;
        crc0 = crc32c_shift(crc32c_long, crc0) ^ crc2;
        next += MYLONG*2;
        len -= MYLONG*3;
    }

    /* do the same thing, but now on MYSHORT*3 blocks for the remaining data less
       than a LONG*3 block */
    while (len >= MYSHORT*3) {
        uint64_t crc1 = 0;
        uint64_t crc2 = 0;
        unsigned char const * const end = next + MYSHORT;
        do {
            __asm__("crc32q\t" "(%3), %0\n\t"
                    "crc32q\t" SHORTx1 "(%3), %1\n\t"
                    "crc32q\t" SHORTx2 "(%3), %2"
                    : "=r"(crc0), "=r"(crc1), "=r"(crc2)
                    : "r"(next), "0"(crc0), "1"(crc1), "2"(crc2));
            next += 8;
        } while (next < end);
        crc0 = crc32c_shift(crc32c_short, crc0) ^ crc1;
        crc0 = crc32c_shift(crc32c_short, crc0) ^ crc2;
        next += MYSHORT*2;
        len -= MYSHORT*3;
    }

    /* compute the crc on the remaining eight-byte units less than a MYSHORT*3
       block */
    {
        unsigned char const * const end = next + (len - (len & 7));
        while (next < end) {
            __asm__("crc32q\t" "(%1), %0"
                    : "=r"(crc0)
                    : "r"(next), "0"(crc0));
            next += 8;
        }
        len &= 7;
    }

    /* compute the crc for up to seven trailing bytes */
    while (len) {
        __asm__("crc32b\t" "(%1), %0"
                : "=r"(crc0)
                : "r"(next), "0"(crc0));
        next++;
        len--;
    }

    /* return a post-processed crc */
    return ~crc0;
}

/* Check for SSE 4.2.  SSE 4.2 was first supported in Nehalem processors
   introduced in November, 2008.  This does not check for the existence of the
   cpuid instruction itself, which was introduced on the 486SL in 1992, so this
   will fail on earlier x86 processors.  cpuid works on all Pentium and later
   processors. */
#define SSE42(have) \
    do { \
        uint32_t eax, ecx; \
        eax = 1; \
        __asm__("cpuid" \
                : "=c"(ecx) \
                : "a"(eax) \
                : "%ebx", "%edx"); \
        (have) = (ecx >> 20) & 1; \
    } while (0)
#endif // corresponds to #ifdef (#ifdef __WIN64)
static pthread_once_t crc32c_once_little = PTHREAD_ONCE_INIT;
static uint32_t crc32c_table_little[8][256];
static void crc32c_init_sw_little(void) {
    for (unsigned n = 0; n < 256; n++) {
        uint32_t crc = n;
        crc = crc & 1 ? (crc >> 1) ^ POLY : crc >> 1;
        crc = crc & 1 ? (crc >> 1) ^ POLY : crc >> 1;
        crc = crc & 1 ? (crc >> 1) ^ POLY : crc >> 1;
        crc = crc & 1 ? (crc >> 1) ^ POLY : crc >> 1;
        crc = crc & 1 ? (crc >> 1) ^ POLY : crc >> 1;
        crc = crc & 1 ? (crc >> 1) ^ POLY : crc >> 1;
        crc = crc & 1 ? (crc >> 1) ^ POLY : crc >> 1;
        crc = crc & 1 ? (crc >> 1) ^ POLY : crc >> 1;
        crc32c_table_little[0][n] = crc;
    }
    for (unsigned n = 0; n < 256; n++) {
        uint32_t crc = crc32c_table_little[0][n];
        for (unsigned k = 1; k < 8; k++) {
            crc = crc32c_table_little[0][crc & 0xff] ^ (crc >> 8);
            crc32c_table_little[k][n] = crc;
        }
    }
}
uint32_t crc32c_sw_little(uint32_t crc, unsigned char const *buf, size_t len) {
    unsigned char const *next = buf;

    pthread_once(&crc32c_once_little, crc32c_init_sw_little);
    crc = ~crc;
    while (len && ((uintptr_t)next & 7) != 0) {
        crc = crc32c_table_little[0][(crc ^ *next++) & 0xff] ^ (crc >> 8);
        len--;
    }
    if (len >= 8) {
        uint64_t crcw = crc;
        do {
            crcw ^= *(uint64_t const *)next;
            crcw = crc32c_table_little[7][crcw & 0xff] ^
                   crc32c_table_little[6][(crcw >> 8) & 0xff] ^
                   crc32c_table_little[5][(crcw >> 16) & 0xff] ^
                   crc32c_table_little[4][(crcw >> 24) & 0xff] ^
                   crc32c_table_little[3][(crcw >> 32) & 0xff] ^
                   crc32c_table_little[2][(crcw >> 40) & 0xff] ^
                   crc32c_table_little[1][(crcw >> 48) & 0xff] ^
                   crc32c_table_little[0][crcw >> 56];
            next += 8;
            len -= 8;
        } while (len >= 8);
        crc = crcw;
    }
    while (len) {
        crc = crc32c_table_little[0][(crc ^ *next++) & 0xff] ^ (crc >> 8);
        len--;
    }
    return ~crc;
}


#ifdef BIG
/* Swap the bytes in a uint64_t.  (Only for big-endian.) */
static inline uint64_t swap_crc32c(uint64_t x)
{
	x = 			((x <<  8) & (uint64_t)0xff00ff00ff00ff00ULL)
	| 				((x >>  8) & (uint64_t)0xff00ff00ff00ffULL);

	x = 			((x << 16) & (uint64_t)0xffff0000ffff0000ULL)
	|
					((x >> 16) & (uint64_t)0xffff0000ffffULL);
    return (x << 32) | (x >> 32);
}
static pthread_once_t crc32c_once_big = PTHREAD_ONCE_INIT;
static uint32_t crc32c_table_big_byte[256];
static uint64_t crc32c_table_big[8][256];
static void crc32c_init_sw_big(void) {
    for (unsigned n = 0; n < 256; n++) {
        uint32_t crc = n;
        crc = crc & 1 ? (crc >> 1) ^ POLY : crc >> 1;
        crc = crc & 1 ? (crc >> 1) ^ POLY : crc >> 1;
        crc = crc & 1 ? (crc >> 1) ^ POLY : crc >> 1;
        crc = crc & 1 ? (crc >> 1) ^ POLY : crc >> 1;
        crc = crc & 1 ? (crc >> 1) ^ POLY : crc >> 1;
        crc = crc & 1 ? (crc >> 1) ^ POLY : crc >> 1;
        crc = crc & 1 ? (crc >> 1) ^ POLY : crc >> 1;
        crc = crc & 1 ? (crc >> 1) ^ POLY : crc >> 1;
        crc32c_table_big_byte[n] = crc;
    }
    for (unsigned n = 0; n < 256; n++) {
        uint32_t crc = crc32c_table_big_byte[n];
        crc32c_table_big[0][n] = swap_crc32c(crc);
        for (unsigned k = 1; k < 8; k++) {
            crc = crc32c_table_big_byte[crc & 0xff] ^ (crc >> 8);
            crc32c_table_big[k][n] = swap_crc32c(crc);
        }
    }
}
uint32_t crc32c_sw_big(uint32_t crc, unsigned char const *buf, size_t len) {
    unsigned char const *next = buf;

    pthread_once(&crc32c_once_big, crc32c_init_sw_big);
    crc = ~crc;
    while (len && ((uintptr_t)next & 7) != 0) {
        crc = crc32c_table_big_byte[(crc ^ *next++) & 0xff] ^ (crc >> 8);
        len--;
    }
    if (len >= 8) {
        uint64_t crcw = swap_crc32c(crc);
        do {
            crcw ^= *(uint64_t const *)next;
            crcw = crc32c_table_big[0][crcw & 0xff] ^
                   crc32c_table_big[1][(crcw >> 8) & 0xff] ^
                   crc32c_table_big[2][(crcw >> 16) & 0xff] ^
                   crc32c_table_big[3][(crcw >> 24) & 0xff] ^
                   crc32c_table_big[4][(crcw >> 32) & 0xff] ^
                   crc32c_table_big[5][(crcw >> 40) & 0xff] ^
                   crc32c_table_big[6][(crcw >> 48) & 0xff] ^
                   crc32c_table_big[7][(crcw >> 56)];
            next += 8;
            len -= 8;
        } while (len >= 8);
        crc = swap_crc32c(crcw);
    }
    while (len) {
        crc = crc32c_table_big_byte[(crc ^ *next++) & 0xff] ^ (crc >> 8);
        len--;
    }
    return ~crc;
}
#endif // corresponds to #ifdef (#ifdef BIG)

uint32_t crc32c(uint32_t crc, const unsigned char *buf, size_t len)
{
/// this is faster the checking global variable
#if  defined(_WIN64)
	int sse42;
    SSE42(sse42);
	return sse42 ? crc32c_hw(crc, buf, len) : crc32c_sw_little(crc, buf, len);
#else

#ifdef BIG
        return crc32c_sw_big(crc, buf, len);
#else
        return crc32c_sw_little(crc, buf, len);
#endif // corresponds to #ifdef (#ifdef BIG)

#endif // corresponds to #if (#if  defined(_WIN64))
}
/// LICENSE_END.12

bool myavanzamentoby1sec(int64_t i_lavorati,int64_t i_totali,int64_t i_inizio,bool i_barran=true)
{
	bool	hostampato=false;
	static int ultimotempo=0;
	int secondi=(mtime()-i_inizio)/1000;
	int percentuale=int(i_lavorati*100.0/(i_totali+0.5));
	
	
	///printf("i_lavorati %s i_totali %s percentuale %d\n",migliaia(i_lavorati),migliaia2(i_totali),percentuale);
	
	if (percentuale>100)
		percentuale=100;
	if (secondi!=ultimotempo)
	{
		ultimotempo=secondi;
		double eta=0.001*(mtime()-i_inizio)*(i_totali-i_lavorati)/(i_lavorati+1.0);
		if (secondi==0)
			secondi=1;
		if (eta<356000)
		{
			if (flagwriteonconsole)
			{
			fprintf(stderr,"%03d%% %02d:%02d:%02d (%10s) of (%10s) %20s/s", percentuale,
		int(eta/3600), int(eta/60)%60, int(eta)%60, tohuman(i_lavorati), tohuman2(i_totali),migliaia3(i_lavorati/secondi));
			if (i_barran)
				fprintf(stderr,"\n");
			else
				fprintf(stderr,"\r");
			}
		else
		{
			if (!flagnoeta)
			{
			
			myprintf("%03d%% %02d:%02d:%02d (%10s) of (%10s) %10s/s", percentuale,
		int(eta/3600), int(eta/60)%60, int(eta)%60, tohuman(i_lavorati), tohuman2(i_totali),tohuman3(i_lavorati/secondi));
			if (i_barran)
				myprintf("\n");
			else
				myprintf("\r");
			hostampato=true;
			}
		}
			
			
		}
		fflush(stdout);
	}
	return hostampato;
}

string mm_hash_calc_file(int i_algo,const char * i_filename,bool i_flagcalccrc32,uint32_t& o_crc32,const int64_t i_inizio,const int64_t i_totali,int64_t& io_lavorati,int64_t& o_thefilesize)
{
	o_thefilesize=0;
	o_crc32=0;
	char buffer[256];
	string risultato	="26304:ERROR";
	int64_t lunghezza	=prendidimensionefile(i_filename);
	char* data	=NULL;
	char zero			=0; /// my zerobytelong "file"
#ifdef unix
	int myfilehandle=0; // for unix
#else
	HANDLE mapping		=0;
	HANDLE myfile		=0;
#endif // corresponds to #ifdef (#ifdef unix)
	if (lunghezza==0)
	{	// 0 length file. Fix to get same results as "normal" hash
		data=&zero;
	}
	else
	{
#ifdef unix
		myfilehandle=open(i_filename,O_RDONLY);
		if (myfilehandle<=0)
			return "26364: ERROR IN OPEN";
		data=(char *)mmap(0,lunghezza,PROT_READ,MAP_PRIVATE,myfilehandle,0);
		if (data==MAP_FAILED)
		{
			close(myfilehandle);
			return "26369: map failed";
		}
#else
		wstring wfilename=utow(i_filename);
		myfile=CreateFile(wfilename.c_str(),GENERIC_READ,FILE_SHARE_READ | FILE_SHARE_WRITE,0,OPEN_EXISTING,FILE_ATTRIBUTE_NORMAL,0);
		if (myfile==INVALID_HANDLE_VALUE)
		{
			myprintf("00769: Invalid handle for %s\n",i_filename);
			return "26311:ERROR";
		}
		mapping=CreateFileMapping(myfile,0,PAGE_READONLY, 0, 0, 0);
		if (mapping==0)
		{
			if (myfile!=0)
				CloseHandle(myfile);
			return "26322:ERROR";
		}
		data=(char*)MapViewOfFile(mapping,FILE_MAP_READ,0,0,0);
#endif // corresponds to #ifdef (#ifdef unix)
	}
	if (data)
	{
		if (i_algo==ALGO_NILSIMSA)
		{
			nilsimsa_compute(data,lunghezza,buffer);
			risultato=binarytohex((const unsigned char*)buffer,64);
		}
		else
		if (i_algo==ALGO_WYHASH)
		{
			uint64_t _wyp[4];
			make_secret(0,_wyp);
			uint64_t mywyhash=wyhash(data,lunghezza,0,_wyp);
			risultato=bin2hex_64(mywyhash);
		}
		else
		if ((i_algo==FRANZO_XXHASH64) || (i_algo==FRANZO_WINHASH64) || (i_algo==FRANZO_XXHASH64B))
		{
			uint64_t myseed = 0;
			XXHash64 myhash(myseed);
			myhash.add(data,lunghezza);
			risultato=bin2hex_64(myhash.hash());
		}
		else
		if ((i_algo==FRANZO_SHA_1)||(i_algo==FRANZO_SHA_1B))
		{
			libzpaq::SHA1 sha1;
			for (int64_t i=0;i<lunghezza;i++)
				sha1.put(*(data+i));
			char sha1result[20];
			memcpy(sha1result, sha1.result(), 20);
			risultato=binarytohex((const unsigned char*)sha1result,20);
		}
		else
		if ((i_algo==FRANZO_SHA_256)||(i_algo==FRANZO_SHA_256B))
		{
			libzpaq::SHA256 sha256;
			for (int64_t i=0;i<lunghezza;i++)
				sha256.put(*(data+i));
			char sha256result[32];
			memcpy(sha256result, sha256.result(), 32);
			risultato=binarytohex((const unsigned char*)sha256result,32);
		}
		else
		if ((i_algo==FRANZO_BLAKE3)||(i_algo==FRANZO_BLAKE3B))
		{
			blake3_hasher hasher;
			blake3_hasher_init(&hasher);
			blake3_hasher_update(&hasher,data,lunghezza);
			uint8_t output[BLAKE3_OUT_LEN];
			blake3_hasher_finalize(&hasher, output, BLAKE3_OUT_LEN);
			risultato=binarytohex((const unsigned char*)output,BLAKE3_OUT_LEN);
		}
		else
		if (i_algo==FRANZO_WHIRLPOOL)
		{
			NESSIEstruct hasher;
			NESSIEinit(&hasher);
			/// note: a bigger numbit. Will it works?
			NESSIEadd64((const unsigned char*)data,lunghezza*8,&hasher); /// <-- whirlpool works on BITS, so *8
			NESSIEfinalize(&hasher,(unsigned char*)buffer);
			risultato=binarytohex((const unsigned char*)buffer,64);
		}
		else
		if ((i_algo==FRANZO_MD5) || (i_algo==FRANZO_MD5B))
		{
			MD5 md5;
			md5.add(data,lunghezza);
			string mymd5 = md5.getHash();
			risultato=mymd5;
		}
		else
		if ((i_algo==FRANZO_SHA3)||(i_algo==FRANZO_SHA3B))
		{
			SHA3 sha3;
			sha3.add(data,lunghezza);
			string mysha3 = sha3.getHash();
			risultato=mysha3;
		}
		else
		if ((i_algo==FRANZO_XXH3)||(i_algo==FRANZO_XXH3B))
		{
			XXH3_state_t state128;
			(void)XXH3_128bits_reset(&state128);
			(void)XXH3_128bits_update(&state128,data,lunghezza);
			XXH128_hash_t myhash=XXH3_128bits_digest(&state128);
			risultato=bin2hex_128(myhash.high64,myhash.low64);
		}
		else
		if (i_algo==ALGO_CRC32C)
		{
			uint32_t crc=0;
			crc=crc32c(crc, (const unsigned char*)data,lunghezza);
			char buffer[33];
			snprintf(buffer,sizeof(buffer),"%08X",crc);
			risultato=buffer;
		}
		else
		if ((i_algo==FRANZO_CRC_32) || (i_flagcalccrc32))
		{
			o_crc32=crc32_16bytes(data,lunghezza,o_crc32);
			char buffer[33];
			snprintf(buffer,sizeof(buffer),"%08X",o_crc32);
			risultato=buffer;
		}
		else
		{
			perror("25087: unknown algo");
		}
		io_lavorati+=lunghezza;
		if ((flagnoeta==false) && (i_inizio>0))
			myavanzamentoby1sec(io_lavorati,i_totali,i_inizio,false);
	}
#ifdef unix
	if (myfilehandle!=0)
		close(myfilehandle);
	if (lunghezza>0)
	{
		int errore=munmap(data,lunghezza);
		if (errore!=0)
			return "26506: unmapping guru";
	}
#else
	else
	{
		myprintf("00770: data empty\n");
		if (mapping!=0)
			CloseHandle(mapping);
		if (myfile!=0)
			CloseHandle(myfile);
		return "26441: ERROR";
	}
	if (lunghezza>0)
		UnmapViewOfFile(data);
	if (mapping!=0)
		CloseHandle(mapping);
	if (myfile!=0)
		CloseHandle(myfile);
#endif // corresponds to #ifdef (#ifdef unix)
	o_thefilesize=lunghezza;

	return risultato;
}


double custom_log2(double x) 
{
#ifndef NOLM
	return log2(x);
#else
	double risultato=custom_log(x) * 1.4426950408889634; // 1/ln(2)
	double check=log2(x);
	myprintf("51123: log2 delta %f\n",risultato-check);

#endif
}

double custom_exp(double x) 
{
#ifndef NOLM
	return exp(x);
#else
    if (x == 0.0) return 1.0;
    if (x > 700.0) return __builtin_huge_valf();  // Avoid overflow
    if (x < -700.0) return 0.0;  // Avoid underflow
    
    // Reduce x using exp(x) = exp(x/2)^2
    int power = 0;
    while (x > 1.0) { x /= 2.0; power++; }
    while (x < -1.0) { x /= 2.0; power--; }
    
    // Taylor series
    double result = 1.0;
    double term = 1.0;
    for (int n = 1; n <= MAX_ITERATIONS; n++) {
        term *= x / n;
        result += term;
        if (term < MYEPSILON) break;
    }
    
    // Recompose the result
    while (power > 0) { result *= result; power--; }
    while (power < 0) { result = result * result; power++; }
    
	double check=exp(x);
	myprintf("51124: exp delta %f\n",result-check);

    return result;
#endif
}

///fiko




class franz_do_hash
{
/*
	do you think this is kind of "weird" C/C++/Delphi?
	Well, we need to compile on gcc 3.4
	therefore no C++20, no C++14, no... nothing

	franz_do_hash hashfrombuffer(par->algo[i]);
	hashfrombuffer.init();
	hashfrombuffer.update(par->data[i],par->filesize[i]);
	hashstringato=hashfrombuffer.finalize();


	franz_do_hash dummy(tmpalgo[i]);
	string risu=dummy.filehash(work,false,par->inizio,par->dimensione);

*/

	private:
	bool			isinit;
	bool			isfinalized;
	XXHash64 		*p_xxhash64;
	libzpaq::SHA1 	*p_sha1;
	libzpaq::SHA256 *p_sha256;
	SHA3			*p_sha3;
	XXH3_state_t	*p_xxh3;
	MD5				*p_md5;
	blake3_hasher 	*p_blake3;
	NESSIEstruct 	*p_whihasher;
	HighwayHashCat 	*p_highway64state;
	uint32_t		*p_crc32;
	uint32_t		*p_crc32c;

	finalize_function	ffinalize;

	public:
	string		i_hashtype2;
	int			ihashtype;
	bool		flagcalccrc32;

	bool		i_filehash;		// if false, do a RAM hash

	///string		i_filename;
	bool		i_flagmm;
	int64_t		i_inizio;
	int64_t		i_totali;

	int 		i_chunksize;
	uint32_t* 	i_buffer8bit;

	string		o_status;
	string		o_hexhash;
	int64_t		o_thefilesize;
	uint32_t	o_crc32;
	string		o_hexcrc32;
	uint32_t	o_crc32c;
	string		o_hexcrc32c;

	void		init();
	void		update(char *i_buffer,const int i_buflen);
	string		finalize();

	franz_do_hash(string i_type):
	ihashtype(-1),
	flagcalccrc32(false),
	i_filehash(true),
	i_flagmm(false),
	i_inizio(0),
	i_totali(0),
	i_chunksize(0),
	i_buffer8bit(NULL),
	o_thefilesize(0),
	o_crc32(0),
	o_crc32c(0)
	{
		ffinalize	=NULL;
		if (i_type=="")
		{
///			myprintf("00771: i_type empty\n");
///			seppuku();
			return;
		}
		myreplace(i_type,"WINXXHASH64","XXHASH64");

		for (MAPPATIPOHASH::iterator p=g_mappatipohash.begin(); p!=g_mappatipohash.end(); ++p)
			if (stringtoupper(i_type)==(p->second.hashname))
			{
				ffinalize=p->second.ffinalize;
				ihashtype=p->first;
				///printf("stopme %d\n",p->first);
				///exit(0);
			}
		if (ffinalize==NULL)
		{
			myprintf("00772! GURU cannot find finalize for %s\n",i_type.c_str());
			seppuku();
			return;
		}
		i_hashtype2			=i_type;
		o_status			="";
		o_hexhash			="";
		o_hexcrc32			="";
		o_hexcrc32c			="";
		isinit				=false;
		isfinalized			=false;
	}

	franz_do_hash(int i_franzotype):
	ihashtype(-1),
	flagcalccrc32(false),
	i_filehash(true),
	i_flagmm(false),
	i_inizio(0),
	i_totali(0),
	i_chunksize(0),
	i_buffer8bit(NULL),
	o_thefilesize(0),
	o_crc32(0),
	o_crc32c(0)
	{
		MAPPATIPOHASH::iterator p=g_mappatipohash.find(i_franzotype);
		if (p==g_mappatipohash.end())
		{
			myprintf("00773! GURU, cannot convert int %d to ASCII!\n",i_franzotype);
			seppuku();
			return;
		}

		i_hashtype2			=p->second.hashname;
		ihashtype			=i_franzotype;
		o_status			="";
		o_hexhash			="";
		o_hexcrc32			="";
		o_hexcrc32c			="";
		isinit				=false;
		isfinalized			=false;
	}
	string	filehash(int64_t i_offset,string i_filename,bool i_flagcalccrc32,int64_t i_inizio,int64_t i_totali,int64_t i_lunghezza);
};


void franz_do_hash::init()
{
	p_crc32			=NULL;
	p_crc32c		=NULL;
	p_xxhash64		=NULL;
	p_sha1			=NULL;
	p_sha256		=NULL;
	p_sha3			=NULL;
	p_xxh3			=NULL;
	p_md5			=NULL;
	p_blake3		=NULL;
	p_whihasher		=NULL;
	p_highway64state=NULL;
	if (ihashtype==-1)
	{
		myprintf("00774: GURU hashtype empty\n");
		seppuku();
		return;
	}

	if (i_hashtype2=="NONE")
		return;

	if ((ihashtype==FRANZO_XXHASH64) || (ihashtype==FRANZO_WINHASH64) || (ihashtype==FRANZO_XXHASH64B))
	{
		p_xxhash64=new XXHash64(0);
		g_allocatedram+=sizeof(XXHash64);

	}
	else
	if ((ihashtype==FRANZO_SHA_1)||(ihashtype==FRANZO_SHA_1B))
	{
		p_sha1=new libzpaq::SHA1; ///You get this warning before C++17
		g_allocatedram+=sizeof(libzpaq::SHA1);

	}
	else
	if ((ihashtype==FRANZO_SHA_256)||(ihashtype==FRANZO_SHA_256B))
	{
		p_sha256=new libzpaq::SHA256; ///You get this warning before C++17
		g_allocatedram+=sizeof(libzpaq::SHA256);

	}
	else
	if ((ihashtype==FRANZO_XXH3)||(ihashtype==FRANZO_XXH3B))
	{
		p_xxh3=(XXH3_state_t*)aligned_malloc(64, sizeof(XXH3_state_t));
		(void)XXH3_128bits_reset(p_xxh3);
		g_allocatedram+=sizeof(XXH3_state_t);
	}
	else
	if ((ihashtype==FRANZO_MD5) || (ihashtype==FRANZO_MD5B))
	{
		p_md5=new MD5;
		g_allocatedram+=sizeof(MD5);
	}
	else
	if ((ihashtype==FRANZO_SHA3)||(ihashtype==FRANZO_SHA3B))
	{
		p_sha3=new SHA3;
		g_allocatedram+=sizeof(SHA3);
		
	}
	else
	if ((ihashtype==FRANZO_BLAKE3)||(ihashtype==FRANZO_BLAKE3B))
	{
		p_blake3=(blake3_hasher*)franz_malloc(sizeof(blake3_hasher));
		blake3_hasher_init(p_blake3);
		g_allocatedram+=sizeof(blake3_hasher);
	}
	else
	if (ihashtype==FRANZO_WHIRLPOOL)
	{
		p_whihasher=new NESSIEstruct;
		NESSIEinit(p_whihasher);
		g_allocatedram+=sizeof(NESSIEstruct);

	}
	else
	if ((ihashtype==FRANZO_HIGHWAY64) || (ihashtype==FRANZO_HIGHWAY128) || (ihashtype==FRANZO_HIGHWAY256))
	{
		p_highway64state=new HighwayHashCat;
		uint64_t key[4] = {1, 2, 3, 4};
		HighwayHashCatStart(key,p_highway64state);
		g_allocatedram+=sizeof(HighwayHashCat);

	}
	else
	if (ihashtype==FRANZO_CRC_32)
	{
	}
	else
	if (ihashtype==ALGO_CRC32C)
	{
	}
	else
	{
		myprintf("00775: GURU hashtype unknown |%s| %d\n",i_hashtype2.c_str(),ihashtype);
		seppuku();
		return;
	}
	isinit 			=true;
	isfinalized		=false;
}

string franz_do_hash::finalize()
{
	if (ihashtype==-1)
	{
		myprintf("00776: GURU hashtype empty\n");
		seppuku();
		return "47302: GURU hashtype empty";
	}
	if (!isinit)
	{
		myprintf("00777: GURU not init!\n");
		seppuku();
		return "47308: GURU not init!";
	}
	if (isfinalized)
	{
		myprintf("00778: already finalized!\n");
		seppuku();
		return "47314: already finalized!";
	}
	if ((ihashtype==FRANZO_XXHASH64) || (ihashtype==FRANZO_WINHASH64) || (ihashtype==FRANZO_XXHASH64B))
		o_hexhash=ffinalize(p_xxhash64);
	else
	if ((ihashtype==FRANZO_SHA_1)||(ihashtype==FRANZO_SHA_1B))
		o_hexhash=ffinalize(p_sha1);
	else
	if ((ihashtype==FRANZO_SHA_256)||(ihashtype==FRANZO_SHA_256B))
		o_hexhash=ffinalize(p_sha256);
	else
	if ((ihashtype==FRANZO_XXH3)||(ihashtype==FRANZO_XXH3B))
		o_hexhash=ffinalize(p_xxh3);
	else
	if ((ihashtype==FRANZO_MD5) || (ihashtype==FRANZO_MD5B))
		o_hexhash=ffinalize(p_md5);
	else
	if ((ihashtype==FRANZO_SHA3)||(ihashtype==FRANZO_SHA3B))
		o_hexhash=ffinalize(p_sha3);
	else
	if ((ihashtype==FRANZO_BLAKE3)||(ihashtype==FRANZO_BLAKE3B))
		o_hexhash=ffinalize(p_blake3);
	else
	if (ihashtype==FRANZO_WHIRLPOOL)
		o_hexhash=ffinalize(p_whihasher);
	else
	if (ihashtype==FRANZO_HIGHWAY64)
		o_hexhash=ffinalize(p_highway64state);
	else
	if (ihashtype==FRANZO_HIGHWAY128)
		o_hexhash=ffinalize(p_highway64state);
	else
	if (ihashtype==FRANZO_HIGHWAY256)
		o_hexhash=ffinalize(p_highway64state);
	else
	if (ihashtype==FRANZO_CRC_32)
	{
		o_hexhash	=ffinalize(p_crc32);
		o_hexcrc32	=o_hexhash;
	}
	else
	if (ihashtype==ALGO_CRC32C)
		o_hexhash	=ffinalize(p_crc32c);
	else
	{
		myprintf("00779: GURU hashtype unknown |%s|\n",i_hashtype2.c_str());
		seppuku();
		return "47453: GURU hashtype unknown |%s|";
	}
	isinit 			=false;
	isfinalized		=true;
	return o_hexhash;

}

void franz_do_hash::update(char *i_buffer,const int i_buflen)
{
//	(*p_xxhash64).add(i_buffer,i_buflen);
	///return;
	/*
	if (!isinit)
	{
		myprintf("00780: GURU hash not init\n");
		seppuku();
		return;
	}

	if (isfinalized)
	{
		myprintf("00781: GURU hash finalized, cannot update\n");
		seppuku();
		return;
	}
*/
	if ((ihashtype==FRANZO_XXHASH64) || (ihashtype==FRANZO_WINHASH64) || (ihashtype==FRANZO_XXHASH64B))
	{
	/*
		if (p_xxhash64==NULL)
		{
			myprintf("00782: guru pointer null %s\n",i_hashtype2.c_str());
			seppuku();
			return;
		}
	*/
		(*p_xxhash64).add(i_buffer,i_buflen);
		return;
	}
	else
	if ((ihashtype==FRANZO_SHA_1)||(ihashtype==FRANZO_SHA_1B))
	{
		/*
		if (p_sha1==NULL)
		{
			myprintf("00783: guru pointer null %s\n",i_hashtype2.c_str());
			seppuku();
			return;
		}
		*/
		(*p_sha1).write(i_buffer,i_buflen);
		return;
	}
	else
	if ((ihashtype==FRANZO_SHA_256)||(ihashtype==FRANZO_SHA_256B))
	{
		/*
		if (p_sha256==NULL)
		{
			myprintf("00784: guru pointer null %s\n",i_hashtype2.c_str());
			seppuku();
			return;
		}
		*/
		(*p_sha256).write(i_buffer,i_buflen);

///		for (int i=0;i<i_buflen;i++)
	///		(*p_sha256).put(*(i_buffer+i));
		return;
	}
	else
	if ((ihashtype==FRANZO_XXH3)||(ihashtype==FRANZO_XXH3B))
	{
		/*
		if (p_xxh3==NULL)
		{
			myprintf("00785: guru pointer null %s\n",i_hashtype2.c_str());
			seppuku();
			return;
		}
*/
		(void)XXH3_128bits_update(p_xxh3,i_buffer,i_buflen);
		return;
	}
	else
	if ((ihashtype==FRANZO_MD5) || (ihashtype==FRANZO_MD5B))
	{
		/*
		if (p_md5==NULL)
		{
			myprintf("00786: guru pointer null %s\n",i_hashtype2.c_str());
			seppuku();
			return;
		}
		*/
		(*p_md5).add(i_buffer,i_buflen);
		return;
	}
	else
	if ((ihashtype==FRANZO_SHA3)||(ihashtype==FRANZO_SHA3B))
	{
		/*
		if (p_sha3==NULL)
		{
			myprintf("00787: guru pointer null %s\n",i_hashtype2.c_str());
			seppuku();
			return;
		}
		*/
		(*p_sha3).add(i_buffer,i_buflen);
		return;
	}
	else
	if ((ihashtype==FRANZO_BLAKE3)||(ihashtype==FRANZO_BLAKE3B))
	{
		/*
		if (p_blake3==NULL)
		{
			myprintf("00788: guru pointer null %s\n",i_hashtype2.c_str());
			seppuku();
			return;
		}
		*/
		blake3_hasher_update(p_blake3,i_buffer,i_buflen);
		return;
	}
	else
	if (ihashtype==FRANZO_WHIRLPOOL)
	{
		/*
		if (p_whihasher==NULL)
		{
			myprintf("00789: guru pointer null %s\n",i_hashtype2.c_str());
			seppuku();
			return;
		}
		*/
		NESSIEadd((unsigned char*)i_buffer,i_buflen*8,p_whihasher);
		return;
	}
	else
	if ((ihashtype==FRANZO_HIGHWAY64) || (ihashtype==FRANZO_HIGHWAY128) || (ihashtype==FRANZO_HIGHWAY256))
	{
		/*
		if (p_highway64state==NULL)
		{
			myprintf("00790: guru pointer null %s\n",i_hashtype2.c_str());
			seppuku();
			return;
		}
		*/
		HighwayHashCatAppend((const uint8_t*)i_buffer,i_buflen,p_highway64state);
		return;
	}
	else
	if (ihashtype==FRANZO_CRC_32)
	{
		(*p_crc32)=crc32_16bytes(i_buffer,i_buflen,(*p_crc32));
	}
	else
	if (ihashtype==ALGO_CRC32C)
	{
		///thecrc32c=crc32c(thecrc32c, (const unsigned char*)i_buffer+off,i_buflen);
		(*p_crc32c)=crc32c((*p_crc32c), (const unsigned char*)i_buffer,i_buflen);
	}
	else
	{
		myprintf("00791: GURU hashtype unknown in update |%s|\n",i_hashtype2.c_str());
		seppuku();
		return;
	}
}

string	franz_do_hash::filehash(int64_t i_offset,string i_filename,bool i_flagcalccrc32,int64_t i_inizio,int64_t i_totali,int64_t i_lunghezza=0)
{
///	if (ihashtype==FRANZO_BLAKE3B)
		///myprintf("$$$$$$$$$$$$$$$$$ BLAKE3 filehash ihashtype %d\n",ihashtype);
	o_thefilesize	=0;
	o_crc32			=0;
	o_hexhash		="";
	o_status		="";
	if (ihashtype==-1)
	{
		myprintf("00792: GURU EMPTY HASHTYPE\n");
		o_status="62696: EMPTY HASHTYPE";
		return "";
	}
	if (ihashtype==0)
	{
		myprintf("00793: NONE HASHER\n");
		o_status="62703: NONE HASHER";
		return "";
	}
	if (i_filename=="")
	{
		myprintf("00794: error empty filename\n");
		o_status="62969: ERROR EMPTY FILENAME";
		return "";
	}
	if  ((isdirectory(i_filename)) || (i_filename==".") || (i_filename==".."))
	{
		myprintf("00795! cannot hash a folder <<%Z>>\n",i_filename.c_str());
		o_status="62703: CANNOT HASH A FOLDER";
		return "";
	}
	char temp[128];


	if (ihashtype==ALGO_NILSIMSA)
	{
		o_hexhash=mm_hash_calc_file(ALGO_NILSIMSA,i_filename.c_str(),i_flagcalccrc32,o_crc32,i_inizio,i_totali,g_dimensione,o_thefilesize);
		return o_hexhash;
	}

	if (ihashtype==ALGO_WYHASH)
	{
		o_hexhash=mm_hash_calc_file(ALGO_WYHASH,i_filename.c_str(),i_flagcalccrc32,o_crc32,i_inizio,i_totali,g_dimensione,o_thefilesize);
		return o_hexhash;
	}

	FILE* myfilez = freadopen(i_filename.c_str());
#ifndef ESX
	if (flagdebug3)
		myprintf("00797: myfilez FILE* is %s\n",migliaia(int64_t(myfilez)));
#endif
	if	(myfilez==NULL)
	{
		if (!flagignore)
		{
#ifdef _WIN32
			int err=GetLastError();
			string codice=decodewinerror(err,NULL);
			myprintf("00798! error kind %d %s opening <<%Z>>\n",err,codice.c_str(),i_filename.c_str());
#else
			int err=1;
			myprintf("00799! error kind %d opening <<%Z>>\n",err,i_filename.c_str());
			
#endif // corresponds to #ifdef (#ifdef _WIN32)
		}
		o_status="62697: ERROR OPENING FILE";
		return "";
	}

	int64_t lunghezza	=prendidimensionefile(i_filename.c_str());//prendidimensionehandle(myfilez);
		
		
	if (i_lunghezza>0)
		lunghezza=i_lunghezza;
	
	if (flagdebug3)
		myprintf("00801: hashing lunghezza [prendidimensionefile] %s\n",migliaia(lunghezza));
	int64_t	letti		=0;

#ifdef __HAIKU__
	const int BUFSIZE	=16384;
#else
#ifdef ANCIENT
	const int BUFSIZE	=16384;
#else
	const int BUFSIZE	=65536*8;
#endif // corresponds to #ifdef (#ifdef ANCIENT)
#endif // corresponds to #ifdef (#ifdef __HAIKU__)

	unsigned char 		unzBuf[BUFSIZE];
	int 				n=BUFSIZE;

	uint64_t myseed = 0;
	XXHash64 myhash(myseed);

	int mytype=ihashtype;

	if ((ihashtype==ALGO_ZETA) || (ihashtype==ALGO_ZETAENC))
	{
		if (prendidimensionefile(i_filename.c_str())<104+32)
		{
			fclose(myfilez);
			return "0000000000000000";
		}
		if (ihashtype==ALGO_ZETAENC)
		{
		///	myprintf("57714: ALGO ZETAENC ATTIVATA\n");
			n=32;
			int r=fread(unzBuf,1,n,myfilez);
			if (r!=n)
			{
				myprintf("01802: Error reading head of ZETA\n");
				fclose(myfilez);
				o_hexhash		="";
				o_thefilesize	=0;
				return "";
			}
			myhash.add(unzBuf,r);
			letti+=r;
		}
	///	else
		///myprintf("57714: ALGO ZETA\n");

		fseeko(myfilez,104,SEEK_CUR);

		n=BUFSIZE;
		while (1)
		{
			int r=fread(unzBuf, 1, n, myfilez);
			myhash.add(unzBuf,r);
			g_dimensione+=r;
			if (g_dimensione>i_totali)
				i_totali=g_dimensione;
			letti+=r;
			if (r!=n)
				break;
			if ((flagnoeta==false) && (i_inizio>0) && (i_totali>0))
				myavanzamentoby1sec(g_dimensione,i_totali,i_inizio,false);
		}
		fclose(myfilez);
		if ((flagnoeta==false) && (i_inizio>0) && (i_totali>0))
			myavanzamentoby1sec(g_dimensione,i_totali,i_inizio,false);

///		myhash.add(g_franzhash_104,104);
///		letti+=104;

		o_hexhash		=bin2hex_64(myhash.hash());
		o_thefilesize	=lunghezza;
		g_dimensione	+=lunghezza;
		o_thefilesize	=letti;
		return o_hexhash;
	}
	

/// just an extimate. If <64K get xxhash64
//  otherwise get 16K head +16KB mid, +16KB tail =>xxhash64

	if (ihashtype==ALGO_QUICK)
	{
		if (lunghezza<65536)
		{
			mytype=FRANZO_XXHASH64;
		}
		else
		{
			n=16384;
			int r=0;

			r=fread(unzBuf,1,n,myfilez);
			if (r!=n)
			{
				myprintf("00802: Error reading head\n");
				fclose(myfilez);
				o_hexhash		="";
				o_thefilesize	=0;
				return "";
			}
			myhash.add(unzBuf,r);

			int64_t off=lunghezza/2;
			///myprintf("Faccio seek a %s\n",migliaia(off));
			
			fseeko(myfilez,off,SEEK_SET);
			r=fread(unzBuf,1,n, myfilez);
			if (r!=n)
			{
				myprintf("00803: Error reading mid\n");
				fclose(myfilez);
				o_hexhash		="";
				o_thefilesize	=0;
				return "";
			}
			myhash.add(unzBuf,r);

			fseeko(myfilez,lunghezza-n,SEEK_SET);

			///fseeko(myfilez,-n,SEEK_END);
			r=fread(unzBuf,1,n,myfilez);
			if (r!=n)
			{
				myprintf("00804: Error reading tail\n");
				fclose(myfilez);
				o_hexhash		="";
				o_thefilesize	=0;
				return "";
			}
			myhash.add(unzBuf,r);

			fclose(myfilez);

			if ((flagnoeta==false) && (i_inizio>0) && (i_totali>0))
				myavanzamentoby1sec(g_dimensione,i_totali,i_inizio,false);

			o_hexhash		=bin2hex_64(myhash.hash());
			o_thefilesize	=lunghezza;
			g_dimensione	+=lunghezza;
			return o_hexhash;
		}
	}


	libzpaq::SHA1 sha1;
	MD5 md5;
	libzpaq::SHA256 mysha256;
	XXH3_state_t state128;
	if ((mytype==FRANZO_XXH3)||(mytype==FRANZO_XXH3B))
		(void)XXH3_128bits_reset(&state128);

	blake3_hasher hasher;
	if ((mytype==FRANZO_BLAKE3)||(mytype==FRANZO_BLAKE3B))
		blake3_hasher_init(&hasher);

	SHA3 sha3;

	NESSIEstruct whihasher;
	if (mytype==FRANZO_WHIRLPOOL)
		NESSIEinit(&whihasher);

	size_t f[256] = { 0 };

	HighwayHashCat state;
	uint64_t hash;
	uint64_t key[4] = {1, 2, 3, 4};
	if ((mytype==FRANZO_HIGHWAY64) || (mytype==FRANZO_HIGHWAY128) || (mytype==FRANZO_HIGHWAY256))
		HighwayHashCatStart(key, &state);

	if (mytype==FRANZO_CRC_32)
		i_flagcalccrc32=true;

	if (i_offset>0)
		if (lunghezza>i_offset)
			fseeko(myfilez,i_offset,SEEK_SET);
	
	if (mytype==ALGO_CRC32C)
	{
		size_t off, n;
		uint32_t crc=0;
		size_t got;
		while (!feof(myfilez) && !ferror(myfilez))
		{
			got = fread(unzBuf, sizeof(char), BUFSIZE, myfilez);
			if (got == 0)
				break;
				
			off = 0;
			do
			{
				n = got - off;
				if (n > BUFSIZE)
					n = BUFSIZE;
				crc = crc32c(crc, (const unsigned char*)unzBuf + off, n);
				off += n;
			} while (off < got);
			
			if (i_flagcalccrc32)
				o_crc32 = crc32_16bytes(unzBuf, got, o_crc32);
				
			g_dimensione += got;
			letti += got;
			
			if ((flagnoeta == false) && (i_inizio > 0) && (i_totali > 0))
				myavanzamentoby1sec(g_dimensione, i_totali, i_inizio, false);
		}

		snprintf(temp,sizeof(temp),"%08X",crc);
		o_hexhash=temp;
	}
	else
	while (1)
	{
		int r=fread(unzBuf, 1, n, myfilez);
#ifdef _WIN32
		if (flagdebug3)
		{
			myprintf("00805: hash fread %08d bytes returned r %08d\n",n,r);
			if (r==0)
			{
				DWORD situation=GetLastError();
				string lasterror=decodewinerror(situation,i_filename.c_str());
				myprintf("00806: fread returned 0 bytes! situation %08d lasterror %s\n",situation,lasterror.c_str());
			}
		}
#endif // corresponds to #ifdef (#ifdef _WIN32)
		if (mytype==FRANZO_XXHASH64B)
			myhash.add(unzBuf,r);
		else
		if (mytype==FRANZO_XXHASH64)
			myhash.add(unzBuf,r);
		else
		if ((mytype==FRANZO_SHA_1)||(mytype==FRANZO_SHA_1B))
			sha1.write((const char*)unzBuf,r);
		else
		if ((mytype==FRANZO_SHA_256)||(mytype==FRANZO_SHA_256B))
			mysha256.write((const char*)unzBuf,r);
		else
		if ((mytype==FRANZO_XXH3)||(mytype==FRANZO_XXH3B))
		{
			///myprintf("00807: update XXH3!!!\n");
			(void)XXH3_128bits_update(&state128,unzBuf,r);
			///myprintf("00808: update XXH3 done!!!\n");
		}
		else
		if ((mytype==FRANZO_BLAKE3)||(mytype==FRANZO_BLAKE3B))
		{
///			myprintf("00809: update BLAKE3!!!\n");
			blake3_hasher_update(&hasher,unzBuf,r);
		}
		else
		if ((mytype==FRANZO_MD5) || (mytype==FRANZO_MD5B))
			md5.add(unzBuf,r);
		else
		if ((mytype==FRANZO_SHA3)||(mytype==FRANZO_SHA3B))
			sha3.add(unzBuf,r);
		else
		if (mytype==FRANZO_WHIRLPOOL)
			NESSIEadd(unzBuf,r*8,&whihasher);
		else
		if (mytype==ALGO_ENTROPY)
		{
			for(int i=0;i<r;i++)
				f[unzBuf[i]]++;
		}
		else
		if ((mytype==FRANZO_HIGHWAY64) || (mytype==FRANZO_HIGHWAY128) || (mytype==FRANZO_HIGHWAY256))
			HighwayHashCatAppend((const uint8_t*)unzBuf,r,&state);

		if (i_flagcalccrc32)
			o_crc32=crc32_16bytes(unzBuf,r,o_crc32);

		g_dimensione+=r;
		if (g_dimensione>i_totali)
			i_totali=g_dimensione;
		letti+=r;
		if (r!=n)
			break;
//////bool myavanzamentoby1sec(int64_t i_lavorati,int64_t i_totali,int64_t i_inizio,bool i_barran=true)

		if (flagwriteonconsole)
		{
			if ((i_inizio>0) && (i_totali>0))
				myavanzamentoby1sec(g_dimensione,i_totali,i_inizio,false);
		}
		else
		{
			
///			myprintf("g dimensione %s i_totali %s\n",migliaia(g_dimensione),migliaia2(i_totali));
	
			if ((flagnoeta==false) && (i_inizio>0) && (i_totali>0))
				myavanzamentoby1sec(g_dimensione,i_totali,i_inizio,false);
		}
	}
	if (myfilez!=NULL)
		fclose(myfilez);

	if (flagwriteonconsole)
	{
		fprintf(stderr,"\r");
		fprintf(stderr,"                                                                 \r");
	}

	if (i_flagcalccrc32)
	{
		snprintf(temp,sizeof(temp),"%08X",o_crc32);
		o_hexcrc32 =temp;
	}

	if (mytype==FRANZO_CRC_32)
	{
		snprintf(temp,sizeof(temp),"%08X",o_crc32);
		o_hexhash	=temp;
	}
	if (mytype==FRANZO_XXHASH64B)
		o_hexhash=bin2hex_64(myhash.hash());
	if (mytype==FRANZO_XXHASH64)
		o_hexhash=bin2hex_64(myhash.hash());
	if ((mytype==FRANZO_SHA_1)||(mytype==FRANZO_SHA_1B))
	{
		char sha1result[20];
		memcpy(sha1result, sha1.result(), 20);
		o_hexhash=binarytohex((const unsigned char*)sha1result,20);
	}
	if ((mytype==FRANZO_SHA_256)||(mytype==FRANZO_SHA_256B))
	{
		char sha256result[32];
		memcpy(sha256result,mysha256.result(),32);
		o_hexhash=binarytohex((const unsigned char*)sha256result,32);
	}
	if ((mytype==FRANZO_XXH3)||(mytype==FRANZO_XXH3B))
	{
		XXH128_hash_t myhash=XXH3_128bits_digest(&state128);
		o_hexhash=bin2hex_128(myhash.high64,myhash.low64);
	}
	if ((mytype==FRANZO_BLAKE3)||(mytype==FRANZO_BLAKE3B))
	{

		uint8_t output[BLAKE3_OUT_LEN];
		blake3_hasher_finalize(&hasher, output, BLAKE3_OUT_LEN);
		o_hexhash=binarytohex((const unsigned char*)output,BLAKE3_OUT_LEN);
		///myprintf("00810: finalizzo BLAKE3!!! %s\n",o_hexhash.c_str());
	}
	if ((mytype==FRANZO_MD5) || (mytype==FRANZO_MD5B))
		o_hexhash=md5.getHash();
	if ((mytype==FRANZO_SHA3)||(mytype==FRANZO_SHA3B))
		o_hexhash=sha3.getHash();
	if (mytype==FRANZO_WHIRLPOOL)
	{
		unsigned char output[512]={0};
		NESSIEfinalize(&whihasher,output);
		o_hexhash=binarytohex(output,64);
	}
	if (mytype==ALGO_ENTROPY)
	{
		double entropy=0.0;
		double byteletti=letti;
		if (letti>0)
			for(size_t i=0;i<256; i++)
				if (f[i])
				{
					double prob=(double)f[i]/byteletti;
					entropy += prob * custom_log2(prob);
				}
		if (entropy)
			snprintf(temp,sizeof(temp), "%8.4f", (float)-entropy);
		else
			snprintf(temp,sizeof(temp), "%8.4f", (float)0); ///quick "fix" for -0.0000
		o_hexhash=temp;
	}

	if (mytype==FRANZO_HIGHWAY64)
	{
		hash=HighwayHashCatFinish64(&state);
		o_hexhash=bin2hex_64(hash);
	}
	if (mytype==FRANZO_HIGHWAY128)
	{
		uint64_t hash[2];
		HighwayHashCatFinish128(&state,hash);
		o_hexhash=binarytohex((const unsigned char*)hash,16);
	}
	if (mytype==FRANZO_HIGHWAY256)
	{
		uint64_t hash[4];
		HighwayHashCatFinish256(&state,hash);
		o_hexhash=binarytohex((const unsigned char*)hash,32);
	}

	if (!flagignore)
		if ((lunghezza-i_offset)!=letti)
		{
			myprintf("\n");
			myprintf("00811: *** CORRUPTED FILE DETECTED! expected %s readed %s bytes *** %Z\n",migliaia(lunghezza),migliaia2(letti),i_filename.c_str());
		}
	o_thefilesize=letti;
	///myprintf("00813: ****************************** ritorno lunghezza %s\n",migliaia(lunghezza));
	return o_hexhash;
}



#ifdef ZPAQFULL ///NOSFTPSTART
#ifdef _WIN32
struct risorse 
{
    WORD number; 
	std::string package;
    std::string filename;
    uint64_t extractedsize;
    std::string extractedhash;

    risorse(WORD n, const std::string& p, const std::string& f, uint64_t ch, const std::string& eh)
        : number(n), package(p), filename(f), extractedsize(ch), extractedhash(eh)
	{
        // Validazione
        if (filename.empty() || filename.find_first_of("/\\:") != std::string::npos) 
		{
            myprintf("01400: Invalid filename %Z in risorse\n", filename.c_str());
            filename = "";
        }
        if (eh.length() != 64 || eh.find_first_not_of("0123456789ABCDEF") != std::string::npos) 
		{
            myprintf("01401: Invalid SHA-256 hash (uppercase HEX) %Z in resources %s\n", filename.c_str(),eh.c_str());
            extractedhash = "";
        }
    }
};

bool controllaHash( std::string& i_filename, const std::string& expectedHash) 
{
    if (i_filename.empty()) 
	{
        myprintf("01402: Invalid filename %Z in controllaHash\n", i_filename.c_str());
        return false;
    }

	i_filename=includetrailingbackslash(getwinexedir())+extractfilename(i_filename);

    int64_t dimensione = prendidimensionefile(i_filename.c_str());
    if (dimensione <= 0) 
	{
        if (flagdebug) 
		    myprintf("01403: File %Z not found or empty in controllaHash\n", i_filename.c_str());
        return false;
    }
    franz_do_hash dummy("SHA-256");
    std::string hashreloaded = dummy.filehash(0, i_filename, false, mtime(), dimensione);
    if (hashreloaded.empty()) 
	{
        myprintf("01404: Failed to compute hash for %Z\n", i_filename.c_str());
        return false;
    }

    return hashreloaded == expectedHash;
	return true;
}

int getdllfrominternet(std::string& i_filename, const std::string& i_sha256) 
{
    if (i_filename.empty()) 
	{
        myprintf("01406: Invalid filename %Z\n", i_filename.c_str());
        return 2;
    }
	i_filename=extractfilename(i_filename);

    if (i_sha256.length() != 64 || i_sha256.find_first_not_of("0123456789ABCDEF") != std::string::npos) 
	{
        myprintf("01407: Invalid SHA-256 hash %Z\n", i_sha256.c_str());
        return 2;
    }

    std::string filepath = includetrailingbackslash(getwinexedir()) + i_filename;
    const std::string base_url = "http://www.francocorbelli.it/zpaqfranz/win64/"; // Configurabile
	

	for (int attempt = 0; attempt < 2; ++attempt) 
	{
		if (controllaHash(filepath, i_sha256)) 
		{
            if (flagdebug) 
			{
                color_green();
                myprintf("01408: Verified successfully %Z\n", filepath.c_str());
                color_restore();
            }
			break;
        }
        if (attempt == 0) 
		{
            int64_t dimensione = prendidimensionefile(filepath.c_str());
            if (dimensione > 0) 
			{
                color_yellow();
                myprintf("01409: %Z corrupted, attempting to download\n", filepath.c_str());
                color_restore();
                if (!delete_file(filepath.c_str())) 
				{
                    myprintf("01410: Failed to delete corrupted file %Z\n", filepath.c_str());
                    return 2;
                }
            } 
			else 
				if (flagverbose) 
				{
					color_yellow();
					myprintf("01411: File %Z not found or empty\n", filepath.c_str());
					color_restore();
				}
			std::string randnocache = "?" + generaterandomstring(10);
            std::string dllurl = base_url + i_filename + randnocache;

            color_cyan();
            myprintf("01412: Download %20s from %s\n", i_filename.c_str(), dllurl.c_str());
            color_restore();

            if (!downloadfile(dllurl, filepath, true)) 
			{
				/// error already printed
                ///myprintf("01413: Something wrong downloading %Z, sorry (no Internet?)\n", filepath.c_str());
                return 2;
            }
            if (flagverbose) 
                myprintf("01414: Downloaded, checking again %Z\n", i_filename.c_str());
        } else 
		{
            myprintf("01415: %Z still corrupted or not found after download\n", filepath.c_str());
            return 2;
        }
    }

	
	myprintf("%29s:",i_filename.c_str());
	color_green();
	myprintf("OK\n");
	color_restore();
    return 0;
}


/// this is a very quick and very dirty unzpaq from memory to file
/// very slow, but we can get optional SHA-256
struct Mymemreader: public libzpaq::Reader
{
	unsigned char*	thememory;
	size_t			memorysize;
	size_t			currentbyte;
	Mymemreader(unsigned char* i_memory,size_t i_memorysize): thememory(i_memory),memorysize(i_memorysize),currentbyte(0) {}
  	int get()
	{
		if (thememory)
			if (memorysize)
				return currentbyte<memorysize ? uint8_t(thememory[currentbyte++]) : -1;
		return -1;
 	}
};
struct Myfilewriter: public libzpaq::Writer
{
	FILE* 	f;
	size_t	tobewritten;
	size_t	written;
	bool	dosha256;
	libzpaq::SHA256 thehash256;
	int64_t	inizio;
	Myfilewriter(FILE* f_,size_t i_tobewritten=0,bool i_dosha256=false): f(f_),tobewritten(i_tobewritten),written(0),dosha256(i_dosha256) {}
  	void put(int c)
	{
		if(f)
			if (putc(c, f)!=EOF)
			{
				if (dosha256)
				{
					uint8_t carattere=c & 0xFF;
					thehash256.write((const char*)&carattere,1);
				}
				written++;
				if (tobewritten)
				{
					myavanzamentoby1sec(written,tobewritten,inizio,false);
/*
					
					if (written % 1000==0)
						myprintf("02365: Extracted so far %12s/%s\r",migliaia(written),migliaia2(tobewritten));
*/
				}
				else
				{
					if (written % 1000==0)
						myprintf("02366: Extracted so far %12s\r",migliaia(written));
				}
			}
	}
};

bool estrairisorsa(const risorse& r) 
{
    std::string filelocale=includetrailingbackslash(getwinexedir())+extractfilename(r.filename);

    myprintf("01416: Checking %20s:", filelocale.c_str());
///mika

    if (controllaHash(filelocale, r.extractedhash)) 
	{
        color_green();
        myprintf("OK\n");
        color_restore();
        return true;
    }

	

    FILE* f = std::fopen(filelocale.c_str(), "rb");
    if (f != nullptr) 
	{
        std::fclose(f);
        color_yellow();
        myprintf("different hash (not good)\n");
        color_restore();
    } 
	else 
	{
        color_yellow();
        myprintf("Not found");
        color_restore();
    }

    HMODULE hExe = GetModuleHandle(nullptr);
    if (!hExe) 
	{
        color_yellow();
        myprintf(" => get from internet (no module handle)!\n");
        color_restore();
        return getdllfrominternet(filelocale, r.extractedhash) == 0;
    }

    HRSRC hRes = FindResource(hExe, MAKEINTRESOURCE(r.number), RT_RCDATA);
    if (!hRes) 
	{
        color_yellow();
        myprintf(" => get from internet (resource not found)!\n");
        color_restore();
        return getdllfrominternet(filelocale, r.extractedhash) == 0;
    }

    color_yellow();
    myprintf(" => extraction\n");
    color_restore();

    HGLOBAL hData = LoadResource(hExe, hRes);
    if (!hData) 
	{
        myprintf("01417: Failed to load resource %u\n", r.number);
        return false;
    }

    DWORD size = SizeofResource(hExe, hRes);
    if (size == 0) 
	{
        myprintf("01418: Resource %u has zero size\n", r.number);
        return false;
    }

    void* data = LockResource(hData);
    if (!data) 
	{
        myprintf("01419: Failed to lock resource %u\n", r.number);
        return false;
    }

    f = std::fopen(filelocale.c_str(), "wb");
    if (!f) 
	{
        color_red();
        myprintf("01420: Cannot write %Z\n", filelocale.c_str());
        color_restore();
        return false;
    }

    Mymemreader in((unsigned char*)data, size);
    Myfilewriter out(f, r.extractedsize, true);
    out.inizio = mtime();

    try 
	{
        libzpaq::decompress(&in, &out);
    } 
	catch (const std::exception& e) 
	{
        std::fclose(f);
        myprintf("01421: Decompression failed for %Z\n", filelocale.c_str());
        return false;
    }

    if (std::fclose(f) != 0) 
	{
        myprintf("01422: Failed to close file %Z\n", filelocale.c_str());
        return false;
    }
	eol();
    unsigned char sha256result[32];
    memcpy(sha256result, out.thehash256.result(), 32);
    std::string calculatedhash = binarytohex(sha256result, 32);

    if (calculatedhash == r.extractedhash) 
	{
        color_green();
        myprintf("01423: %20Z: OK\n", filelocale.c_str());
        color_restore();
        return true;
    } 
	else 
	{
        color_red();
        myprintf("01424: %20Z: Hash mismatch (expected: %Z, got: %Z)\n",
                 filelocale.c_str(), r.extractedhash.c_str(), calculatedhash.c_str());
        color_restore();
        delete_file(filelocale.c_str());
        return false;
    }
}

int kickstart_resources(std::string i_package)
{
	if (flagdebug)
		myprintf("01014: Starting kickstart of |%s|\n",i_package.c_str());
    bool allok = true;

    std::vector<risorse> elenco_risorse;
    elenco_risorse.push_back(risorse(1, "LIBSSH",	"libcrypto-3-x64.dll", 	5130880, 	"C0674A225D30F1642CA1DA45AC040A9C1885D8F23883532B42987BAE458EDC4D"));
    elenco_risorse.push_back(risorse(4, "LIBSSH",	"libgcc_s_seh-1.dll", 	150707,		"B22B954397A52703579D92DB64B57812AF70F2AFCAFE2E742A009C1640B9EC1A"));
	elenco_risorse.push_back(risorse(6, "LIBSSH",	"libssh.dll", 			513146,		"7385986FFA0BDDB95CAEB835A8118E96099A91CB3AD5B42A3009A6E0EDFC6B7F"));
	elenco_risorse.push_back(risorse(7, "LIBSSH",	"libwinpthread-1.dll", 	60798,		"5091B85A2A73B82AA3CF433F51AF338F6245319D1C041BC26B42A61CBDB2F880"));
	elenco_risorse.push_back(risorse(9, "LIBSSH",	"zlib1.dll", 			120814,		"CB7AB3788D10940DF874ACD97B1821BBB5EE4A91F3EEC11982BB5BF7A3C96443"));
	elenco_risorse.push_back(risorse(5, "LIBSODIUM","libsodium.dll", 		312928,		"C61B8E230C86AADBF79368DA30B616DAFB05B81F5AECB4A6857C14AB23493125"));
	elenco_risorse.push_back(risorse(8, "LIBSODIUM","vcruntime140.dll", 	124544,		"D5E4D9A3E835FA679450145D6A7D94E36573A509317111904D9B3712C30D9066"));
	elenco_risorse.push_back(risorse(2, "LIBCURL",	"libcurl-x64.dll", 		3193960,	"2EA8DBCA33DE476B23497A10ACE1A76C54DDCEF061E866771BF737A376DDC882"));
	elenco_risorse.push_back(risorse(3, "LIBCURL",	"mailsend.exe", 		1253888,	"0E23BD1214D687DC2B2E28D4FEA12BC1C197BC85B5FFE90BB8888C43746B6F21"));
	elenco_risorse.push_back(risorse(10, "MYSQL",	"mysql.exe", 			4809640,	"65DCBF7897E062A02B6018FFDE4635183E75DBCC075F21D3BE7CC5A27C45FD12"));
	elenco_risorse.push_back(risorse(11, "MYSQL",	"mysqldump.exe", 		4875064,	"F2114A565E8A4D23FC62FD190B59BFFF56C71B8E06B2F9308D246875708A0091"));

    std::vector<std::string> failed_resources;

    for (unsigned int i = 0; i < elenco_risorse.size(); ++i)
	{
		if (flagdebug3)
			myprintf("01490: Testing %03d %s hash %s\n",i,elenco_risorse[i].filename.c_str(),elenco_risorse[i].extractedhash.c_str());
        if (i_package.empty() || elenco_risorse[i].package == i_package) 
            if (!controllaHash(elenco_risorse[i].filename, elenco_risorse[i].extractedhash)) 
			{
                allok = false;
			}
	}
	if (allok)
		return 0;
	color_cyan();
	myprintf("01425: Kickstart %s in zpaqfranz's folder\n",i_package.c_str());
	color_restore();

    for (unsigned int i = 0; i < elenco_risorse.size(); ++i) 
	{
		if (flagdebug3)
			myprintf("01492: Second round %03d %s hash %s\n",i,elenco_risorse[i].filename.c_str(),elenco_risorse[i].extractedhash.c_str());
        if (i_package.empty() || elenco_risorse[i].package == i_package) 
		{
            if (!estrairisorsa(elenco_risorse[i])) 
			{
				if (flagdebug3)
					myprintf("01512: estrairisorsa failed for %s\n",elenco_risorse[i].filename.c_str());
                allok = false;
                failed_resources.push_back(elenco_risorse[i].filename);
            }
			else
			{
				if (flagdebug3)
					myprintf("01511: estrairisorsa OK %s\n",elenco_risorse[i].filename.c_str());
                
			}
				
		}
	}
    if (!failed_resources.empty()) 
	{
        color_red();
        myprintf("01426: Failed to prepare the following resources:\n");
        for (unsigned int i=0;i<failed_resources.size();i++)
			myprintf("  - %s\n", failed_resources[i].c_str());
        color_restore();
    } 
	else 
	{
        color_green();
        myprintf("01427: All resources OK\n");
        color_restore();
		return 0;
    }

    return allok ? 0 : 1;
}

#endif
#endif ///NOSFTPEND


// Binary compare, slow but steady
bool compare_files_binary(const char* file1, const char* file2)
{
    // Confronta le dimensioni
    int64_t size1 = prendidimensionefile(file1);
    if (size1 == -1) return false;
    int64_t size2 = prendidimensionefile(file2);
    if (size2 == -1) return false;
    if (size1 != size2) return false;

    FILE* f1 = fopen(file1, "rb");
    FILE* f2 = fopen(file2, "rb");
    if (!f1 || !f2) 
    {
        if (f1) fclose(f1);
        if (f2) fclose(f2);
        return false;
    }

    const size_t buffer_size = 65536;
    char* buf1 = (char*)malloc(buffer_size);
    char* buf2 = (char*)malloc(buffer_size);
    if (!buf1 || !buf2)
    {
        if (buf1) free(buf1);
        if (buf2) free(buf2);
        fclose(f1);
        fclose(f2);
        return false;
    }

    int64_t inizio = mtime();
    uint64_t bytes_processed = 0;

    while (true)
    {
        size_t read1 = fread(buf1, 1, buffer_size, f1);
        size_t read2 = fread(buf2, 1, buffer_size, f2);

        // Controllo errori di lettura
        if (ferror(f1) || ferror(f2))
        {
            free(buf1);
            free(buf2);
            fclose(f1);
            fclose(f2);
            return false;
        }

        if (read1 != read2 || (read1 > 0 && memcmp(buf1, buf2, read1) != 0))
        {
            free(buf1);
            free(buf2);
            fclose(f1);
            fclose(f2);
            return false;
        }

        if (read1 == 0) break; // fine file

        bytes_processed += read1;
        if (!flagnoeta)
            myavanzamentoby1sec(bytes_processed, size1, inizio, false);
    }

    free(buf1);
    free(buf2);
    fclose(f1);
    fclose(f2);

    return true;
}


bool comparecrc32block(s_crc32block a, s_crc32block b)
{
    // First sort by filename
    if (a.filename != b.filename) 
	    return a.filename < b.filename;
    // If the filenames are the same, sort by crc32start
    return a.crc32start < b.crc32start;
}


string nomefileseesistegia(const string i_nomefile)
{
	if (!fileexists(i_nomefile))
		return i_nomefile;
	string percorso=extractfilepath(i_nomefile);
	string estensione=prendiestensione(i_nomefile);
	string nomefile=prendinomefileebasta(i_nomefile);
	char	numero[10];
	for (int i=1;i<99999;i++)
	{
		snprintf(numero,sizeof(numero),"%05d",i);
		string snumero=numero;
		string candidato=percorso+nomefile+"_"+snumero+"."+estensione;
		if (!fileexists(candidato))
			return candidato;
	}
	return ("");
}



#ifdef ZPAQFULL ///NOSFTPSTART	

#define MAGIC_BYTES "FRANZEN\x1a"
#define MAGIC_BYTES_LEN 8
bool flagmemzero	=false; 

// Costanti basate su libsodium
const int CRYPTO_PWHASH_ALG_DEFAULT 						= 2; // Argon2id
const unsigned long long CRYPTO_PWHASH_OPSLIMIT_INTERACTIVE = 2;
const size_t CRYPTO_PWHASH_MEMLIMIT_INTERACTIVE 			= 67108864; // 64MB
const unsigned long long CRYPTO_PWHASH_OPSLIMIT_MODERATE 	= 3;
const size_t CRYPTO_PWHASH_MEMLIMIT_MODERATE 				= 268435456; // 256MB
const unsigned long long CRYPTO_PWHASH_OPSLIMIT_SENSITIVE 	= 4;
const size_t CRYPTO_PWHASH_MEMLIMIT_SENSITIVE 				= 1073741824; // 1GB

#define G_FRANZEN_SIZE 65536

// Variabili globali parametriche
uint64_t g_sodio_block_size 								= G_FRANZEN_SIZE;
unsigned long long g_sodio_pwhash_opslimit 					= CRYPTO_PWHASH_OPSLIMIT_MODERATE;
size_t g_sodio_pwhash_memlimit 								= CRYPTO_PWHASH_MEMLIMIT_MODERATE;



struct sodium_functions 
{
	
#ifdef _WIN32
    HINSTANCE handle;
#else
    void *handle;
#endif
    int 	(*sodium_init)(void);
    void 	(*sodium_memzero)(void *const, const size_t);
    void 	(*randombytes_buf)(void *const buf, const size_t size);
    int 	(*crypto_pwhash)(unsigned char *const out, unsigned long long outlen,
				const char *const passwd, unsigned long long passwdlen,
				const unsigned char *const salt,
				unsigned long long opslimit, size_t memlimit, int alg);
    size_t 	(*crypto_aead_chacha20poly1305_ietf_keybytes)(void);
    size_t 	(*crypto_aead_chacha20poly1305_ietf_npubbytes)(void);
    size_t 	(*crypto_aead_chacha20poly1305_ietf_abytes)(void);
    int 	(*crypto_aead_chacha20poly1305_ietf_encrypt)(
				unsigned char *c, unsigned long long *clen_p,
				const unsigned char *m, unsigned long long mlen,
				const unsigned char *ad, unsigned long long adlen,
				const unsigned char *nsec, const unsigned char *npub,
				const unsigned char *k);
    int 	(*crypto_aead_chacha20poly1305_ietf_decrypt)(
				unsigned char *m, unsigned long long *mlen_p,
				unsigned char *nsec,
				const unsigned char *c, unsigned long long clen,
				const unsigned char *ad, unsigned long long adlen,
				const unsigned char *npub, const unsigned char *k);
};


#define SIZEOF_AUTH_TAG      16
#define SIZEOF_SALT          16
#define SIZEOF_KEY_CHECK_TAG 16
#define SIZEOF_ONCE          12

#pragma pack(push, 1)
struct file_header
{
    // --- Identification & Authentication (56 bytes) ---
    char            magic			[MAGIC_BYTES_LEN];		// Offset  0  (0x00) | Size:  8 | Range: [0x00..0x07]
    unsigned char   auth_tag		[SIZEOF_AUTH_TAG];		// Offset  8  (0x08) | Size: 16 | Range: [0x08..0x17] (Main header tag)
    unsigned char   salt			[SIZEOF_SALT];			// Offset 24  (0x18) | Size: 16 | Range: [0x18..0x27] (Salt for key derivation)
    unsigned char   key_check_tag	[SIZEOF_KEY_CHECK_TAG];	// Offset 40  (0x28) | Size: 16 | Range: [0x28..0x37] (Password check tag)

    // --- Main Metadata (40 bytes) ---
    uint64_t        block_size;     						// Offset 56  (0x38) | Size:  8 | Range: [0x38..0x3F] (Data block size)
    uint64_t        file_data_size; 						// Offset 64  (0x40) | Size:  8 | Range: [0x40..0x47] (Total logical data size)
    uint64_t        crc32;          						// Offset 72  (0x48) | Size:  8 | Range: [0x48..0x4F] (Full non-crypto CRC32)
    uint64_t        quickhash;      						// Offset 80  (0x50) | Size:  8 | Range: [0x50..0x57] (Fast non-crypto hash)
    uint64_t        version;        						// Offset 88  (0x58) | Size:  8 | Range: [0x58..0x5F] (File format version)

    // --- Key Derivation Parameters (16 bytes) ---
    uint64_t        pwhash_opslimit;               			// Offset 96  (0x60) | Size:  8 | Range: [0x60..0x67] (Argon2id parameter)
    uint64_t        pwhash_memlimit;               			// Offset 104 (0x68) | Size:  8 | Range: [0x68..0x6F] (Argon2id parameter)

    // --- Fast Append Metadata (16 bytes) ---
    uint64_t        prefix_crc32;           				// Offset 112 (0x70) | Size:  8 | Range: [0x70..0x77] (CRC32 of all blocks except the last one)
    uint64_t        prefix_size;            				// Offset 120 (0x78) | Size:  8 | Range: [0x78..0x7F] (Size in bytes of the prefix)

    // --- Final Padding (4 bytes) ---
    uint8_t         pad[4];                           		// Offset 128 (0x80) | Size:  4 | Range: [0x80..0x83] (Padding to align struct to 132 bytes)
};
#pragma pack(pop)

// Total struct size: 132 bytes.
// Followed by the 12-byte header nonce, bringing the total header section to 144 bytes (9*16)
class franzcri 
{
private:
	size_t 						password_len;
	unsigned char 				password_buf[256];
    
	std::vector<s_crc32block> 	blocks_crc32;
	pthread_mutex_t 			blocks_crc32_mutex;  
	pthread_mutex_t 			worked_mutex;  
	
	FILE 						*file_handle;
    std::string 				password;
    size_t 						io_buffer_size;
    uint64_t 					block_size;
    bool 						is_file_open;
	bool						is_file_new;
    bool 						is_libsodium_loaded;
	bool 						is_libsodium_initialized;  // Flag per sodium_init() called successfully
    bool 						file_was_modified;
    struct 						file_header header;
    unsigned char 				header_nonce[SIZEOF_ONCE];
    struct 						sodium_functions sodium;
    unsigned char 				key[32];
    unsigned long long 			pwhash_opslimit;
    size_t 						pwhash_memlimit;
    int 						pwhash_alg;
	uint64_t 					crc32;

    uint64_t host_to_le64(uint64_t val) 
	{
        // Endianness
        uint16_t test = 1;
        if (*((uint8_t *)&test) == 1) { // Little-endian
            return val;
        }
        // Big-endian
        return (((val >> 56) & 0x00000000000000FF) | ((val >> 40) & 0x000000000000FF00) |
                ((val >> 24) & 0x0000000000FF0000) | ((val >>  8) & 0x00000000FF000000) |
                ((val <<  8) & 0x000000FF00000000) | ((val << 24) & 0x0000FF0000000000) |
                ((val << 40) & 0x00FF000000000000) | ((val << 56) & 0xFF00000000000000));
    }

    uint64_t le64_to_host(uint64_t val) 
	{
        return host_to_le64(val);
    }

/*
    void print_nonce(const unsigned char *nonce, size_t len, const char *context) 
	{
		if (!flagdebug) 
			return;
		myprintf("DEBUG: %s Nonce: ", context);
        for (size_t i = 0; i < len; ++i) 
			myprintf("%02x", nonce[i]);
		myprintf("\n");
    }

    void print_key() 
	{
        if (!flagdebug) 
			return;
		myprintf("DEBUG: Key: ");
        for (size_t i = 0; i < sizeof(key); ++i) 
			myprintf("%02x", key[i]);
		myprintf("\n");
    }
*/


#ifndef RTLD_LAZY
#define RTLD_LAZY 1
#endif

bool load_library() 
{
    // No multiple
    if (is_libsodium_loaded) 
    {
        if (flagdebug)
            myprintf("DEBUG: libsodium already loaded, skipping\n");
        return true;
    }

    // Ensure clean state
    memset(&sodium,0,sizeof(sodium));
    sodium.handle 		= NULL;

    int init_result 	= -1;
    bool tried_local 	= false;

#ifdef _WIN32
#ifdef _WIN64
    const char *local_lib_name = "./libsodium.dll";
    const char *generic_lib_name = "libsodium.dll";

    // Try local resource first
    if (kickstart_resources("LIBSODIUM") == 0) 
    {
        sodium.handle = LoadLibraryA(local_lib_name);
        tried_local = true;
        
        if (sodium.handle) 
        {
            if (flagdebug)
            {
                color_green();
                myprintf("38280: libsodium loaded from local\n");
                color_restore();
            }
        }
    }

    // Fallback to system library
    if (!sodium.handle) 
    {
        if (tried_local && flagdebug)
        {
            color_yellow();
            myprintf("38281: Cannot load local libsodium, trying system library\n");
            color_restore();
        }
        sodium.handle = LoadLibraryA(generic_lib_name);
    }
    
    if (!sodium.handle) 
    {
        myprintf("38087! Cannot load libsodium.dll from any location\n");
        return false;
    }

#else // 32-bit Windows
    myprintf("41604: libsodium not supported on 32-bit Windows\n");
    return false;
#endif

#else // Unix/Linux
    const char *lib_names[] = {"libsodium.so", "libsodium.so.23", "libsodium.so.4", NULL};
    
    for (unsigned int i=0;lib_names[i]!=NULL;++i)
    {
        sodium.handle = dlopen(lib_names[i], RTLD_LAZY | RTLD_LOCAL);
        if (sodium.handle)
        {
            if (flagdebug)
                myprintf("DEBUG: Linux loaded %s\n", lib_names[i]);
            break;
        }
    }

    if (!sodium.handle) 
    {
        myprintf("38104! Unable to load libsodium: %s\n", dlerror());
        return false;
    }

    // Clear any existing error
    dlerror();
#endif

    // Platform-specific symbol loading macros
#ifdef _WIN32
#define LOAD_SYM(handle, name, type) (type)GetProcAddress(handle, #name)
#define CHECK_SYM(sym, name) if (!sym) { \
    myprintf("38121! Function " #name " not found in libsodium\n"); \
    goto cleanup_and_fail; \
}
#else
#define LOAD_SYM(handle, name, type) (type)dlsym(handle, #name)
#define CHECK_SYM(sym, name) { \
    const char* err = dlerror(); \
    if (err != NULL) { \
        myprintf("38121! Function " #name " not found: %s\n", err); \
        goto cleanup_and_fail; \
    } \
}
#endif

    // Load all functions with proper error checking (uniform across platforms)
    sodium.sodium_init = LOAD_SYM(sodium.handle, sodium_init, int(*)(void));
    CHECK_SYM(sodium.sodium_init, sodium_init);

    sodium.sodium_memzero = LOAD_SYM(sodium.handle, sodium_memzero, void(*)(void *const, const size_t));
    CHECK_SYM(sodium.sodium_memzero, sodium_memzero);

    sodium.randombytes_buf = LOAD_SYM(sodium.handle, randombytes_buf, void(*)(void *const, const size_t));
    CHECK_SYM(sodium.randombytes_buf, randombytes_buf);

    sodium.crypto_pwhash = LOAD_SYM(sodium.handle, crypto_pwhash, int(*)(unsigned char *const, unsigned long long, 
                                                                          const char *const, unsigned long long, 
                                                                          const unsigned char *const, unsigned long long, 
                                                                          size_t, int));
    CHECK_SYM(sodium.crypto_pwhash, crypto_pwhash);

    sodium.crypto_aead_chacha20poly1305_ietf_keybytes = LOAD_SYM(sodium.handle, crypto_aead_chacha20poly1305_ietf_keybytes, size_t(*)(void));
    CHECK_SYM(sodium.crypto_aead_chacha20poly1305_ietf_keybytes, crypto_aead_chacha20poly1305_ietf_keybytes);

    sodium.crypto_aead_chacha20poly1305_ietf_npubbytes = LOAD_SYM(sodium.handle, crypto_aead_chacha20poly1305_ietf_npubbytes, size_t(*)(void));
    CHECK_SYM(sodium.crypto_aead_chacha20poly1305_ietf_npubbytes, crypto_aead_chacha20poly1305_ietf_npubbytes);

    sodium.crypto_aead_chacha20poly1305_ietf_abytes = LOAD_SYM(sodium.handle, crypto_aead_chacha20poly1305_ietf_abytes, size_t(*)(void));
    CHECK_SYM(sodium.crypto_aead_chacha20poly1305_ietf_abytes, crypto_aead_chacha20poly1305_ietf_abytes);

    sodium.crypto_aead_chacha20poly1305_ietf_encrypt = LOAD_SYM(sodium.handle, crypto_aead_chacha20poly1305_ietf_encrypt, 
                                                                int(*)(unsigned char *, unsigned long long *, 
                                                                       const unsigned char *, unsigned long long, 
                                                                       const unsigned char *, unsigned long long, 
                                                                       const unsigned char *, const unsigned char *, 
                                                                       const unsigned char *));
    CHECK_SYM(sodium.crypto_aead_chacha20poly1305_ietf_encrypt, crypto_aead_chacha20poly1305_ietf_encrypt);

    sodium.crypto_aead_chacha20poly1305_ietf_decrypt = LOAD_SYM(sodium.handle, crypto_aead_chacha20poly1305_ietf_decrypt, 
                                                                int(*)(unsigned char *, unsigned long long *, unsigned char *, 
                                                                       const unsigned char *, unsigned long long, 
                                                                       const unsigned char *, unsigned long long, 
                                                                       const unsigned char *, const unsigned char *));
    CHECK_SYM(sodium.crypto_aead_chacha20poly1305_ietf_decrypt, crypto_aead_chacha20poly1305_ietf_decrypt);

#undef LOAD_SYM
#undef CHECK_SYM

    // Verify all critical functions loaded
    if (!sodium.sodium_init || !sodium.sodium_memzero || 
        !sodium.randombytes_buf || !sodium.crypto_pwhash || 
        !sodium.crypto_aead_chacha20poly1305_ietf_encrypt || 
        !sodium.crypto_aead_chacha20poly1305_ietf_decrypt ||
        !sodium.crypto_aead_chacha20poly1305_ietf_keybytes ||
        !sodium.crypto_aead_chacha20poly1305_ietf_npubbytes ||
        !sodium.crypto_aead_chacha20poly1305_ietf_abytes)
    {
        myprintf("38121! Critical libsodium functions missing\n");
        goto cleanup_and_fail;
    }

    init_result = sodium.sodium_init();
    if (init_result < 0) 
    {
        myprintf("38127! libsodium initialization failed (error code: %d)\n", init_result);
        goto cleanup_and_fail;
    }

    // Success - mark as loaded ONLY after full initialization
    is_libsodium_loaded 		= true;
    is_libsodium_initialized 	= true;

    if (flagdebug)
    {
        color_green();
        myprintf("DEBUG: libsodium successfully loaded and initialized\n");
        color_restore();
    }

    return true;

cleanup_and_fail:
    // Yep, the mighty goto!
	unload_library();
    
    // Reset all state
    memset(&sodium, 0, sizeof(sodium));
    is_libsodium_loaded 		= false;
    is_libsodium_initialized 	= false;
    return false;
}
    

    void unload_library() 
	{
        if (!sodium.handle) 
			return;
#ifdef _WIN32
        FreeLibrary(sodium.handle);
#else
        dlclose(sodium.handle);
#endif
        sodium.handle = NULL;
    }

	bool derive_key(const unsigned char *salt) 
	{
		if (sodium.crypto_pwhash(key, sizeof(key), (const char*)password_buf, password_len,
								 salt, pwhash_opslimit, pwhash_memlimit, pwhash_alg) != 0) 
		{
			myprintf("38150! CRITIC: derive_key KO - crypto_pwhash failed\n");
			if (flagmemzero) 
				sodium.sodium_memzero(key, sizeof(key));
			return false;
		}

		// Verifica aggiuntiva: Assicurati che la key non sia vuota/zero (paranoia per edge cases)
		bool key_valid = false;
		for (size_t i = 0; i < sizeof(key); ++i) 
			if (key[i] != 0) 
			{
				key_valid = true;
				break;
			}
		if (!key_valid) 
		{
			myprintf("38155! CRITIC: derive_key KO - Generated key is all zeros (possible param error)\n");
			if (flagmemzero) 
				sodium.sodium_memzero(key, sizeof(key));
			return false;
		}

///		print_key();
		return true;
	}
	
    int fseek64(FILE *f, int64_t offset, int origin) 
	{
#ifdef _WIN32
        return _fseeki64(f, offset, origin);
#else
        return fseeko(f, offset, origin);
#endif
    }

    int64_t get_block_file_offset(uint64_t block_idx) 
	{
        size_t tag_len   	= 	sodium.crypto_aead_chacha20poly1305_ietf_abytes();
        size_t nonce_len 	= 	sodium.crypto_aead_chacha20poly1305_ietf_npubbytes();

		if (block_idx > UINT64_MAX / (nonce_len + block_size + tag_len)) 
			return -1;

        int64_t offset 		= 	sizeof(file_header) + (int64_t)sizeof(header_nonce);
        offset 				+= 	(int64_t)block_idx * (int64_t)(nonce_len + block_size + tag_len);
        return offset;
    }

bool write_header()
{
	header.version=1;
	if (flagdebug3)
        myprintf("32660: *************** WRITE HEADER %d\n",blocks_crc32.size());
	if (!file_handle)
    {
        myprintf("41741! file_handle KO in write_header\n");
        return false;
    }
	pthread_mutex_lock(&blocks_crc32_mutex);
    // No CRC blocks (empty file)
	if (blocks_crc32.empty())
    {
        header.crc32 		= 0;
        header.prefix_crc32 = 0;
        header.prefix_size 	= 0;
    }
    else
    {
		if (!blocks_crc32.empty())
		{
			uint32_t calculated_crc32 				= 0;
			uint64_t total_encrypted_size_covered 	= 0;
			bool has_holes 							= false;

			sort(blocks_crc32.begin(), blocks_crc32.end(), comparecrc32block);
			// First block just after header+nonce
			uint64_t expected_start = sizeof(file_header) + sizeof(header_nonce);
			if (blocks_crc32[0].crc32start != expected_start)
			{
				myprintf("41762! HOLE DETECTED: Missing data at the beginning of the file %d vs %d\n",blocks_crc32[0].crc32start,expected_start);
				has_holes = true;
			}

			for (size_t i = 0; i < blocks_crc32.size(); ++i)
			{
				// Checking something strange
				if (i > 0)
				{
					uint64_t prev_end 	= blocks_crc32[i-1].crc32start + blocks_crc32[i-1].crc32size;
					uint64_t curr_start = blocks_crc32[i].crc32start;
					if (prev_end > curr_start)
					{
						myprintf("41782! OVERLAP DETECTED between block %zu and %zu\n", i-1, i);
						has_holes = true;
					}
					else
						if (prev_end < curr_start)
					{
						myprintf("41789! HOLE DETECTED between block %zu and %zu\n", i-1, i);
						has_holes = true;
					}
				}

				calculated_crc32 				= crc32_combine(calculated_crc32, blocks_crc32[i].crc32, blocks_crc32[i].crc32size);
				total_encrypted_size_covered += blocks_crc32[i].crc32size;
			}

			// Total size
			size_t nonce_len 						= sodium.crypto_aead_chacha20poly1305_ietf_npubbytes();
			size_t tag_len 							= sodium.crypto_aead_chacha20poly1305_ietf_abytes();
			uint64_t num_expected_blocks 			= (header.file_data_size > 0) ? (header.file_data_size + block_size - 1) / block_size : 0;
			uint64_t expected_total_encrypted_size 	= num_expected_blocks * (block_size + nonce_len + tag_len);
			if (total_encrypted_size_covered != expected_total_encrypted_size)
			{
				myprintf("41806! HOLE DETECTED: Mismatch in total encrypted size.\n");
				myprintf("       Covered by CRC blocks: %s, Expected from file size: %s\n",
					migliaia(total_encrypted_size_covered), migliaia2(expected_total_encrypted_size));
				has_holes = true;
			}
			if (has_holes)
			{
				myprintf("41831! File has holes or overlaps in CRC32 blocks!\n");
				calculated_crc32=0;
			}
			// New prefix
			uint32_t myprefix_crc32 	= 0;
			uint64_t myprefix_size 		= 0;
			if (blocks_crc32.size() > 1) // we need more than 1 blocks
			{
				// Everything, but not the very last one
				for (size_t i = 0; i < blocks_crc32.size() - 1; ++i)
				{
					myprefix_crc32 = crc32_combine(myprefix_crc32, blocks_crc32[i].crc32, blocks_crc32[i].crc32size);
					myprefix_size += blocks_crc32[i].crc32size;
				}
			}
			header.crc32 		= calculated_crc32;
			header.prefix_crc32 = myprefix_crc32;
			header.prefix_size 	= myprefix_size;
		}
	}
	pthread_mutex_unlock(&blocks_crc32_mutex);

    // Genera la nonce per l'header (usata sia per il key check che per l'auth tag)
	sodium.randombytes_buf(header_nonce, sizeof(header_nonce));

    // --- NUOVO: Creazione del Key Check Value ---
    // Cifriamo un messaggio nullo per generare un tag. Questo permette una verifica
    // rapidissima della correttezza della chiave (e quindi della password).
    unsigned long long dummy_len;
    if (sodium.crypto_aead_chacha20poly1305_ietf_encrypt(header.key_check_tag, &dummy_len,
                                                         NULL, 0, // Messaggio nullo
                                                         NULL, 0, // Dati addizionali nulli
                                                         NULL, header_nonce, key) != 0)
    {
        myprintf("42501! CRITICAL: Key Check Tag generation failed\n");
        return false;
    }

    // --- LOGICA DI AUTENTICAZIONE PRINCIPALE ---
    // Prepara i dati addizionali (AD) per il tag di autenticazione principale.
    // L'integrità di questi dati sarà protetta da 'header.auth_tag'.
    std::vector<unsigned char> header_data;
    // Includiamo il key_check_tag nei dati protetti per impedire manomissioni.
    header_data.insert(header_data.end(), header.key_check_tag, header.key_check_tag + sizeof(header.key_check_tag));
    header_data.insert(header_data.end(), header.salt, header.salt + sizeof(header.salt));
    uint64_t block_size_le = host_to_le64(header.block_size);
    header_data.insert(header_data.end(), (unsigned char *)&block_size_le, (unsigned char *)&block_size_le + sizeof(block_size_le));
    uint64_t file_data_size_le = host_to_le64(header.file_data_size);
    header_data.insert(header_data.end(), (unsigned char *)&file_data_size_le, (unsigned char *)&file_data_size_le + sizeof(file_data_size_le));
    uint64_t crc32_le = host_to_le64(header.crc32);
    header_data.insert(header_data.end(), (unsigned char *)&crc32_le, (unsigned char *)&crc32_le + sizeof(crc32_le));
    uint64_t quickhash_le = host_to_le64(header.quickhash);
    header_data.insert(header_data.end(), (unsigned char *)&quickhash_le, (unsigned char *)&quickhash_le + sizeof(quickhash_le));
    uint64_t version_le = host_to_le64(header.version);
    header_data.insert(header_data.end(), (unsigned char *)&version_le, (unsigned char *)&version_le + sizeof(version_le));
    header_data.insert(header_data.end(), header.pad, header.pad + sizeof(header.pad));

    // Genera il tag di autenticazione principale
    unsigned long long ciphertext_len;
    if (sodium.crypto_aead_chacha20poly1305_ietf_encrypt(header.auth_tag, &ciphertext_len, NULL, 0,
            &header_data[0], header_data.size(), NULL, header_nonce, key) != 0)
    {
        myprintf("38201! Header auth KO\n");
        return false;
    }

    // --- SCRITTURA SU DISCO ---
    // Prepara una copia dell'header con i campi in formato little-endian per la scrittura.
    file_header writable_header 	= header;
    writable_header.block_size 		= host_to_le64(header.block_size);
    writable_header.file_data_size 	= host_to_le64(header.file_data_size);
    writable_header.crc32 			= host_to_le64(header.crc32);
    writable_header.quickhash 		= host_to_le64(header.quickhash);
    writable_header.version 		= host_to_le64(header.version);
    writable_header.pwhash_opslimit = host_to_le64(header.pwhash_opslimit);
    writable_header.pwhash_memlimit = host_to_le64(header.pwhash_memlimit);
    writable_header.prefix_crc32 	= host_to_le64(header.prefix_crc32);
    writable_header.prefix_size 	= host_to_le64(header.prefix_size);
    unsigned char tempbuf[sizeof(file_header) + sizeof(header_nonce)];
	memcpy(tempbuf, &writable_header, sizeof(file_header));
	memcpy(tempbuf + sizeof(file_header), header_nonce, sizeof(header_nonce));

	if (fseek64(file_handle, 0, SEEK_SET)!=0)
		return false;
	if (fwrite(tempbuf, 1, sizeof(tempbuf), file_handle) != sizeof(tempbuf))
	{
		perror("CRITICAL HEADER WRITING ERROR");
		return false;
	}

    fflush(file_handle);
    return true;
}

bool read_header()
{
    if (!file_handle)
        return false;

    // Salva la posizione corrente per ripristinarla alla fine
    long long original_pos = -1;
    #ifdef _WIN32
        original_pos = _ftelli64(file_handle);
    #else
        original_pos = ftello(file_handle);
    #endif

    if (fseek64(file_handle, 0, SEEK_SET)!=0)
        return false;
    if (fread(&header, 1, sizeof(file_header), file_handle) != sizeof(file_header))
    {
        myprintf("38233! Error: Header read fail or file too short\n");
        return false;
    }
    if (fread(header_nonce, 1, sizeof(header_nonce), file_handle) != sizeof(header_nonce))
    {
        myprintf("38239! Error: auth nonce KO\n");
        return false;
    }

    // Converti i campi da little-endian (su disco) a host-endian (in memoria)
    header.block_size 			= le64_to_host(header.block_size);
    header.file_data_size 		= le64_to_host(header.file_data_size);
    header.crc32 				= le64_to_host(header.crc32);
    header.quickhash 			= le64_to_host(header.quickhash);
    header.version 				= le64_to_host(header.version);
    header.pwhash_opslimit 		= le64_to_host(header.pwhash_opslimit);
    header.pwhash_memlimit 		= le64_to_host(header.pwhash_memlimit);
    header.prefix_crc32 		= le64_to_host(header.prefix_crc32);
    header.prefix_size 			= le64_to_host(header.prefix_size);

    // Esegui controlli di sanità di base (magic bytes, versione, etc.)
    if (!validate_header_integrity())
    {
        myprintf("38253! Error: header is not good!\n");
        return false;
    }

    // Imposta i parametri per la derivazione della chiave
    this->pwhash_opslimit = header.pwhash_opslimit;
    this->pwhash_memlimit = header.pwhash_memlimit;

    // Deriva la chiave dalla password fornita e dal salt letto dall'header
    if (!derive_key(header.salt))
        return false;

    // --- NUOVO: Verifica Immediata della Password tramite Key Check Value ---
    unsigned char dummy_output[1];
    unsigned long long dummy_len;
    if (sodium.crypto_aead_chacha20poly1305_ietf_decrypt(dummy_output, &dummy_len, NULL,
                                                        header.key_check_tag, sizeof(header.key_check_tag),
                                                        NULL, 0, // Nessun dato addizionale per questo check
                                                        header_nonce, key) != 0)
    {
        myprintf("42550! Corrupted file or wrong password (key check failed)\n");
        return false;
    }

    // --- VERIFICA DEL TAG DI AUTENTICAZIONE PRINCIPALE ---
    // Ricostruisci il buffer dei dati addizionali esattamente come è stato creato in write_header
    std::vector<unsigned char> header_data;
    header_data.insert(header_data.end(), header.key_check_tag, header.key_check_tag + sizeof(header.key_check_tag));
    header_data.insert(header_data.end(), header.salt, header.salt + sizeof(header.salt));
    uint64_t block_size_le = host_to_le64(header.block_size);
    header_data.insert(header_data.end(), (unsigned char *)&block_size_le, (unsigned char *)&block_size_le + sizeof(block_size_le));
    uint64_t file_data_size_le = host_to_le64(header.file_data_size);
    header_data.insert(header_data.end(), (unsigned char *)&file_data_size_le, (unsigned char *)&file_data_size_le + sizeof(file_data_size_le));
    uint64_t crc32_le = host_to_le64(header.crc32);
    header_data.insert(header_data.end(), (unsigned char *)&crc32_le, (unsigned char *)&crc32_le + sizeof(crc32_le));
    uint64_t quickhash_le = host_to_le64(header.quickhash);
    header_data.insert(header_data.end(), (unsigned char *)&quickhash_le, (unsigned char *)&quickhash_le + sizeof(quickhash_le));
    uint64_t version_le = host_to_le64(header.version);
    header_data.insert(header_data.end(), (unsigned char *)&version_le, (unsigned char *)&version_le + sizeof(version_le));
    header_data.insert(header_data.end(), header.pad, header.pad + sizeof(header.pad));

    // Ora verifica il tag principale; se fallisce, l'header è stato manomesso.
    if (sodium.crypto_aead_chacha20poly1305_ietf_decrypt(
            dummy_output, &dummy_len, NULL,
            header.auth_tag, sizeof(header.auth_tag),
            &header_data[0], header_data.size(),
            header_nonce, key) != 0)
    {
        myprintf("38293! Header is corrupted (main auth tag failed)\n");
        return false;
    }

    // --- Caricamento dei metadati CRC (logica originale ripristinata) ---
    if (!is_file_new)
    {
        blocks_crc32.clear();

        // Ricostruisci il blocco CRC del prefisso, se esiste
        if (header.prefix_size > 0)
        {
            uint64_t prefix_start_offset = sizeof(file_header) + sizeof(header_nonce);
            pthread_mutex_lock(&blocks_crc32_mutex);
            blocks_crc32.push_back(s_crc32block(header.prefix_crc32, prefix_start_offset, header.prefix_size));
            pthread_mutex_unlock(&blocks_crc32_mutex);
        }

        size_t nonce_len 						= sodium.crypto_aead_chacha20poly1305_ietf_npubbytes();
        size_t tag_len 							= sodium.crypto_aead_chacha20poly1305_ietf_abytes();
        uint64_t single_block_disk_size 		= block_size + nonce_len + tag_len;
        
        uint64_t num_blocks 					= (header.file_data_size > 0) ? (header.file_data_size + block_size - 1) / block_size : 0;
        uint64_t total_encrypted_payload_size 	= num_blocks * single_block_disk_size;

        // Se la dimensione totale dei dati criptati è maggiore del prefisso,
        // significa che c'è un ultimo blocco (parziale o intero) da calcolare.
        if (total_encrypted_payload_size > header.prefix_size)
        {
            uint64_t last_block_start_offset = sizeof(file_header) + sizeof(header_nonce) + header.prefix_size;
            uint64_t last_block_size_on_disk = single_block_disk_size;

            std::vector<unsigned char> last_block_data(last_block_size_on_disk);
            if (fseek64(file_handle, last_block_start_offset, SEEK_SET)!=0)
                return false;

            if (fread(last_block_data.data(), 1, last_block_size_on_disk, file_handle) == last_block_size_on_disk)
            {
                uint32_t last_block_crc = crc32_16bytes(last_block_data.data(), last_block_data.size());

                pthread_mutex_lock(&blocks_crc32_mutex);
                blocks_crc32.push_back(s_crc32block(last_block_crc, last_block_start_offset, last_block_size_on_disk));
                pthread_mutex_unlock(&blocks_crc32_mutex);
            }
            else
            {
                myprintf("34463! Error reading back last partial block!\n");
            }
        }
    }

    // Ripristina la posizione originale del puntatore nel file
    if (original_pos != -1)
        if (fseek64(file_handle, original_pos, SEEK_SET)!=0)
            return false;
            
    return true;
}
public:
	uint64_t worked_so_far;

public:
    // Funzione rapida per verificare se la password è corretta per un dato file,
    // senza aprire completamente il file o modificare lo stato dell'istanza.


bool is_password_ok(const char* filename)
{
    if (!is_libsodium_loaded) {
        myprintf("42600! Libsodium not loaded, cannot check password\n");
        return false;
    }
    if (!filename || *filename == '\0') return false;

    FILE* f = fopen(filename, "rb");
    if (!f) return false;

    // --- NUOVO E FONDAMENTALE: Verifica i magic bytes prima di tutto ---
    char magic[MAGIC_BYTES_LEN];
    if (fread(magic, 1, MAGIC_BYTES_LEN, f) != MAGIC_BYTES_LEN) {
        fclose(f); // File troppo corto
        return false;
    }
    if (memcmp(magic, MAGIC_BYTES, MAGIC_BYTES_LEN) != 0) {
        myprintf("Error: Not a valid franzen file (magic bytes mismatch).\n");
        fclose(f);
        return false;
    }
    // --- FINE CONTROLLO MAGIC BYTES ---

    unsigned char salt[SIZEOF_SALT];
    unsigned char key_check_tag[SIZEOF_KEY_CHECK_TAG];
    unsigned char nonce[SIZEOF_ONCE];
    uint64_t file_opslimit = 0, file_memlimit = 0;

  const size_t offset_opslimit=MAGIC_BYTES_LEN+SIZEOF_AUTH_TAG+SIZEOF_SALT+SIZEOF_KEY_CHECK_TAG
	+ sizeof(uint64_t)  // block_size
	+ sizeof(uint64_t)  // file_data_size
	+ sizeof(uint64_t)  // crc32
	+ sizeof(uint64_t)  // quickhash
	+ sizeof(uint64_t); // version
	///printf("opslimit %d  %d\n",offset_opslimit,sizeof(file_header));
    // Ora possiamo leggere gli altri campi con più sicurezza
    // Posizionati al salt (offset 24)
    if (fseek(f, MAGIC_BYTES_LEN+SIZEOF_AUTH_TAG, SEEK_SET) != 0 || 
        fread(salt, 1, sizeof(salt), f) != sizeof(salt) ||
        fread(key_check_tag, 1, sizeof(key_check_tag), f) != sizeof(key_check_tag)) {
        fclose(f);
        return false;
    }

    // Leggi i parametri di derivazione (offset 96 per opslimit, poi +8 per memlimit)
    if (fseek(f, offset_opslimit, SEEK_SET) != 0 ||
        fread(&file_opslimit, 1, sizeof(file_opslimit), f) != sizeof(file_opslimit) ||
        fread(&file_memlimit, 1, sizeof(file_memlimit), f) != sizeof(file_memlimit)) {
        fclose(f);
        return false;
    }
    
    file_opslimit = le64_to_host(file_opslimit);
    file_memlimit = le64_to_host(file_memlimit);

    // Leggi la nonce (offset sizeof(file_header) = 144)
    if (fseek(f, sizeof(file_header), SEEK_SET) != 0 ||
        fread(nonce, 1, sizeof(nonce), f) != sizeof(nonce)) {
        fclose(f);
        return false;
    }
    fclose(f);

    // Valida i parametri letti (gestisce la corruzione)
    if (!validate_argon2_params(file_opslimit, file_memlimit)) {
        myprintf("Error: Invalid Argon2 parameters found in file header.\n");
        return false;
    }

    // Ora procedi con la derivazione della chiave
    unsigned char temp_key[32];
    if (sodium.crypto_pwhash(temp_key, sizeof(temp_key), (const char*)password_buf, password_len,
                             salt, file_opslimit, file_memlimit, CRYPTO_PWHASH_ALG_DEFAULT) != 0)
    {
        if (flagmemzero) sodium.sodium_memzero(temp_key, sizeof(temp_key));
        return false;
    }
    
    unsigned char dummy_output[1];
    unsigned long long dummy_len;
    bool ok = sodium.crypto_aead_chacha20poly1305_ietf_decrypt(
                  dummy_output, &dummy_len, NULL,
                  key_check_tag, sizeof(key_check_tag),
                  NULL, 0, nonce, temp_key) == 0;

    if (flagmemzero) sodium.sodium_memzero(temp_key, sizeof(temp_key));
    return ok;
}


uint32_t get_crc32(const char *input_filename)
{
    // Is input OK?
	if (input_filename == NULL || strlen(input_filename) == 0) 
	{
        myprintf("41870! Error: input filename is NULL or empty\n");
        return 0;
    }

    // Open file
	file_handle = fopen(input_filename, "rb");
    if (!file_handle) 
	{
        myprintf("41871! Error: cannot open file '%s' (%s)\n", input_filename, strerror(errno));
        return 0;
    }

    // Seek start
	if (fseek(file_handle, 0, SEEK_SET) != 0) 
	{
        myprintf("41872! Error: cannot seek to beginning of file '%s'\n", input_filename);
        fclose(file_handle);
        file_handle = NULL;
        return 0;
    }

    // Take the header
	size_t read_size = fread(&header, 1, sizeof(header), file_handle);
    if (read_size != sizeof(header)) 
	{
        myprintf("41879! Error: header read failed or file too short (read %zu / expected %zu)\n",
                 read_size, sizeof(header));
        fclose(file_handle);
        file_handle = NULL;
        return 0;
    }
	
	
    // The nonce
	read_size = fread(header_nonce, 1, sizeof(header_nonce), file_handle);
    if (read_size != sizeof(header_nonce)) 
	{
        myprintf("41885! Error: nonce read failed (read %zu / expected %zu)\n",
                 read_size, sizeof(header_nonce));
        fclose(file_handle);
        file_handle = NULL;
        return 0;
    }

    ///print_nonce(header_nonce, sizeof(header_nonce), "header_auth");
	
	if (flagdebug3)
		myprintf("32943: Ready to decode CRC32\n");
	
    // The CRC32
	uint64_t raw_crc = le64_to_host(header.crc32);
	if (flagdebug3)
		myprintf("32970: raw_crc %s\n",migliaia(raw_crc));
    if (raw_crc > UINT32_MAX) 
	{
        myprintf("41890! Warning: CRC32 value (0x%llx) exceeds 32-bit range\n",(unsigned long long)raw_crc);
    }

    // Cleanup
    fclose(file_handle);
    file_handle = NULL;

    return (uint32_t)(raw_crc & 0xFFFFFFFFu);
}

franzcri(const char *p, size_t p_len, 
			 size_t blk_sz = 0,
			 unsigned long long opslimit = 0,
			 size_t memlimit = 0,
			 int alg = CRYPTO_PWHASH_ALG_DEFAULT) 
			 : file_handle(NULL), 
				block_size(blk_sz == 0 ? g_sodio_block_size : blk_sz),
				is_file_open(false), is_file_new(false),is_libsodium_loaded(false), is_libsodium_initialized(false),
				file_was_modified(false),
				pwhash_opslimit(opslimit == 0 ? g_sodio_pwhash_opslimit : opslimit), 
				pwhash_memlimit(memlimit == 0 ? g_sodio_pwhash_memlimit : memlimit), 
				pwhash_alg(alg),
				crc32(0),
				worked_so_far(0)
	{
			// --- Gestione della password ---
			// Validazione della password e della sua lunghezza
			if (p == NULL || p_len == 0 || p_len > 255) 
			{
				// Gestisci l'errore in modo appropriato, ad es. lanciando un'eccezione
				// o impostando uno stato di errore interno. Per ora, azzeriamo.
				myprintf("42100! Errore: password non valida o troppo lunga nel costruttore.\n");
				memset(password_buf, 0, sizeof(password_buf));
				password_len = 0;
			}
			else
			{
				// Copia la password nel buffer interno
				memcpy(password_buf, p, p_len);
				password_len = p_len;
				// Azzera il resto del buffer per sicurezza
				if (p_len < sizeof(password_buf))
				{
					memset(password_buf + p_len, 0, sizeof(password_buf) - p_len);
				}
			}

			blocks_crc32.clear();
			memset(&sodium, 0, sizeof(sodium));
			memset(&header, 0, sizeof(header));
			memset(header_nonce, 0, sizeof(header_nonce));
			memset(key, 0, sizeof(key));
			is_libsodium_loaded = load_library();
			pthread_mutex_init(&blocks_crc32_mutex, NULL);
			pthread_mutex_init(&worked_mutex, NULL);
	}
	
	void wipesecrets()
	{
		// Fallback se libsodium non loaded
		password_len=0;
		memset(password_buf, 	0, sizeof(password_buf));	
		memset(key, 			0, sizeof(key));
		memset(&header, 		0, sizeof(header));
		memset(header_nonce, 	0, sizeof(header_nonce));
		if (flagmemzero && is_libsodium_loaded) 
		{
			sodium.sodium_memzero(password_buf, sizeof(password_buf));	
			sodium.sodium_memzero(key, sizeof(key));
			sodium.sodium_memzero(&header, sizeof(header));
			sodium.sodium_memzero(header_nonce, sizeof(header_nonce));
		} 
		password_len = 0; // Azzera anche la lunghezza
	}
	
    ~franzcri() 
	{
		if (flagdebug3)
			myprintf("32984: franzen distruttore!\n");
        close();
        if (is_libsodium_loaded)
		{
			wipesecrets();
			unload_library();
			is_libsodium_loaded 		= false;
			is_libsodium_initialized 	= false;  
		}
		pthread_mutex_destroy(&blocks_crc32_mutex);
		pthread_mutex_destroy(&worked_mutex);
    }

    bool open(const char *filename, bool create_new) 
	{
        if (is_file_open) 
		{
            myprintf("38340! File already open!\n");
            return false;
        }
        if (!is_libsodium_loaded) 
		{
            myprintf("38345! Error: libsodium not loaded\n");
            return false;
        }

        file_was_modified = false;
        if (flagdebug) 
			myprintf("DEBUG: Attempting to open '%s' (create_new=%s)\n", filename, create_new ? "true" : "false");

        file_handle = fopen(filename, create_new ? "w+b" : "r+b");
        if (!file_handle) 
		{
            perror("fopen error");
            return false;
        }

        if (create_new) 
		{
            if (flagdebug) 
				myprintf("DEBUG: Creating new file\n");
            memset(&header, 0, sizeof(header));
            memcpy(header.magic, MAGIC_BYTES, MAGIC_BYTES_LEN);
            header.block_size 		= block_size;
            header.file_data_size 	= 0;
			header.pwhash_opslimit 	= this->pwhash_opslimit;
			header.pwhash_memlimit 	= this->pwhash_memlimit;
        
            sodium.randombytes_buf(header.salt, sizeof(header.salt));
            
            if (!derive_key(header.salt)) 
			{
                fclose(file_handle);
                file_handle = NULL;
                return false;
            }
            if (!write_header()) 
			{
                myprintf("38381! Initial header writing failed\n");
                fclose(file_handle);
                file_handle = NULL;
                return false;
            }
            file_was_modified = true;
			is_file_new=true;
        } 
		else 
		{
            if (!read_header()) 
			{
                fclose(file_handle);
                file_handle = NULL;
                return false;
            }
			is_file_new=false;
        }

        is_file_open = true;
        if (flagdebug) 
			myprintf("DEBUG: File '%s' opened\n", filename);
        return true;
    }

    void close() 
	{
		if (flagdebug3)
			myprintf("33071: franzenclose\n");
		
        if (!is_file_open) 
			return;
        
        if (file_was_modified) 
		{
            if (flagdebug) 
				myprintf("DEBUG: File changed, updating header\n");
            if (!write_header()) 
			{
                myprintf("38415! CRITICAL ERROR: Header update failed!\n");
            }
        }
        fclose(file_handle);
        file_handle 	= NULL;
        is_file_open 	= false;
		wipesecrets();
		if (flagdebug) 
			myprintf("DEBUG: File closed\n");
    }

public:
void	dumpblocks(string i_intestazione)
{
	if (!flagdebug)
		return;
	pthread_mutex_lock(&blocks_crc32_mutex);
	myprintf("34731:  %s --- Current blocks_crc32.size() %d\n",i_intestazione.c_str(),blocks_crc32.size());
	for (unsigned int i=0;i<blocks_crc32.size();i++)
		myprintf("34735: %08d Start %21s  size %21s value %08X\n",i,migliaia(blocks_crc32[i].crc32start),migliaia2(blocks_crc32[i].crc32size),blocks_crc32[i].crc32);
	pthread_mutex_unlock(&blocks_crc32_mutex);
}			


bool write(const char *buffer, size_t size) 
    {
        if (flagdebug3)
            myprintf("34258: franzen write size %s\n", migliaia(size));
        
        if (!is_file_open || size == 0) 
            return true;
        
        if (header.file_data_size > UINT64_MAX - size) 
        {
            myprintf("40046! Error: Adding data would cause file size overflow\n");
            return false;
        }

        uint64_t new_size = header.file_data_size + size;
        if (!validate_file_size(new_size)) 
            return false;

        size_t tag_len = sodium.crypto_aead_chacha20poly1305_ietf_abytes();
        size_t nonce_len = sodium.crypto_aead_chacha20poly1305_ietf_npubbytes();
        
        uint64_t start_block_index = header.file_data_size / block_size;
        uint64_t offset_in_start_block = header.file_data_size % block_size;

        size_t bytes_to_process = size;
        const char* current_buffer = buffer;

        // Alloca buffer UNA VOLTA per riutilizzo
        unsigned char* plaintext = new unsigned char[block_size];
        unsigned char* ciphertext_nonce = new unsigned char[nonce_len];
        unsigned char* ciphertext_data = new unsigned char[block_size + tag_len];
        unsigned char* temp_encrypted = new unsigned char[block_size + tag_len];

        bool success = true;

        // Handle first block (potentially partial)
        if (offset_in_start_block > 0) 
        {
            size_t space_in_block = block_size - offset_in_start_block;
            size_t bytes_to_add = (bytes_to_process < space_in_block) ? bytes_to_process : space_in_block;
            
            if (!read_modify_write_block(start_block_index, offset_in_start_block, 
                                        current_buffer, bytes_to_add,
                                        plaintext, ciphertext_nonce, ciphertext_data, temp_encrypted))
            {
                myprintf("Error modifying partial first block\n");
                success = false;
                goto cleanup;
            }
            
            current_buffer += bytes_to_add;
            bytes_to_process -= bytes_to_add;
            start_block_index++;
        }

        // Process full blocks - OTTIMIZZATO: niente allocazioni nel loop
        while (bytes_to_process > 0) 
        {
            size_t chunk_size = (block_size < bytes_to_process) ? block_size : bytes_to_process;
            
            // Riusa plaintext buffer
            memcpy(plaintext, current_buffer, chunk_size);
            if (chunk_size < block_size)
                memset(plaintext + chunk_size, 0, block_size - chunk_size);
            
            // Riusa nonce e ciphertext buffer
            if (!encrypt_block(plaintext, block_size, ciphertext_nonce, ciphertext_data, NULL))
            {
                myprintf("Error encrypting block\n");
                success = false;
                goto cleanup;
            }
            
            if (!write_encrypted_block_at(start_block_index, ciphertext_nonce, ciphertext_data, block_size + tag_len))
            {
                myprintf("Error writing encrypted block\n");
                success = false;
                goto cleanup;
            }
            
            current_buffer += chunk_size;
            bytes_to_process -= chunk_size;
            start_block_index++;
        }

        header.file_data_size = new_size;
        fflush(file_handle);
        file_was_modified = true;

cleanup:
        if (flagmemzero)
        {
            sodium.sodium_memzero(plaintext, block_size);
            sodium.sodium_memzero(ciphertext_nonce, nonce_len);
            sodium.sodium_memzero(ciphertext_data, block_size + tag_len);
            sodium.sodium_memzero(temp_encrypted, block_size + tag_len);
        }
        
        delete[] plaintext;
        delete[] ciphertext_nonce;
        delete[] ciphertext_data;
        delete[] temp_encrypted;
        
        return success;
    }

    bool writeat(int64_t offset, const char *buffer, size_t size) 
    {
        if (!is_file_open || offset < 0 || size == 0)
            return false;
        
        if ((uint64_t)(offset + size) > header.file_data_size) 
        {
            myprintf("38431! Error: write at beyond file size\n");
            return false;
        }
        
        if ((uint64_t)offset + size > UINT64_MAX) 
        {
            myprintf("34975! Overflow error in writeat\n");
            return false;
        }

        if (flagdebug3)
            dumpblocks("Blocchi prima del writeat");
        
        if (!validate_actual_file_size()) 
        {
            myprintf("writeat: File size mismatch - Possible truncation or corruption\n");
            return false;
        }

        size_t tag_len = sodium.crypto_aead_chacha20poly1305_ietf_abytes();
        size_t nonce_len = sodium.crypto_aead_chacha20poly1305_ietf_npubbytes();
        
        uint64_t start_block_idx = offset / block_size;
        uint64_t end_block_idx = (offset + size - 1) / block_size;

        size_t bytes_remaining = size;
        const char *src_ptr = buffer;

        // Alloca buffer UNA VOLTA
        unsigned char* work_plaintext = new unsigned char[block_size];
        unsigned char* work_nonce = new unsigned char[nonce_len];
        unsigned char* work_ciphertext = new unsigned char[nonce_len];
        unsigned char* work_encrypted = new unsigned char[block_size + tag_len];
        
        bool success = true;

        for (uint64_t block_idx = start_block_idx; block_idx <= end_block_idx; ++block_idx) 
        {
            size_t start_in_block = (block_idx == start_block_idx) ? (offset % block_size) : 0;
            size_t bytes_here = (bytes_remaining < (block_size - start_in_block)) ? 
                                bytes_remaining : (block_size - start_in_block);
            
            if (!read_modify_write_block(block_idx, start_in_block, src_ptr, bytes_here,
                                        work_plaintext, work_nonce, work_ciphertext, work_encrypted))
            {
                myprintf("38486! Error rewriting block #%s\n", migliaia(block_idx));
                success = false;
                break;
            }
            
            bytes_remaining -= bytes_here;
            src_ptr += bytes_here;
        }

        if (flagmemzero)
        {
            sodium.sodium_memzero(work_plaintext, block_size);
            sodium.sodium_memzero(work_nonce, nonce_len);
            sodium.sodium_memzero(work_ciphertext, nonce_len);
            sodium.sodium_memzero(work_encrypted, block_size + tag_len);
        }
        
        delete[] work_plaintext;
        delete[] work_nonce;
        delete[] work_ciphertext;
        delete[] work_encrypted;

        if (success)
        {
            fflush(file_handle);
            file_was_modified = true;

            if (flagdebug3)
                dumpblocks("Blocchi dopo il writeat");
        }

        return success;
    }
	

bool fulltest(const char* input_file, const char* output_file, const std::string& password, int num_threads) 
{
    int64_t input_size = prendidimensionefile(input_file);
    if (input_size < 0) 
	{
        myprintf("38563! ERROR: Input file '%s' not found or not readable\n", input_file);
        return false;
    }
    
	myprintf("Starting long test with %d threads\n",num_threads);
    myprintf("Input file     : %s (%s) => %s\n", input_file,tohuman(input_size),output_file);
    printbar('=');
	
    int64_t step_start;
    bool all_ok = true;
    
    // Costruzione nomi file
    std::string output_par 	= std::string(output_file) + ".franzen.enc";
    std::string decoded_par = std::string(output_file) + ".franzen.dec";
	output_par	=nomefileseesistegia(output_par);
	decoded_par	=nomefileseesistegia(decoded_par);
	
	bool success;
	double step_time;
	
	int64_t multi_start=mtime();
	color_cyan();
	myprintf("1) Encoding\n");
	color_restore();
	step_start = mtime();
	franzcri fc5(password.c_str(),password.length());
	success = fc5.encode_parallela(input_file, output_par.c_str(), num_threads);
	eol();
	step_time = (mtime() - step_start) / 1000.0;
	if (success) 
	{
		color_green();
		myprintf("   OK (%10.2fs @ %10s/s) %s\n", step_time, tohuman2(input_size / step_time),output_par.c_str());
	} 
	else 
	{
		color_red();
		myprintf(" FAILED\n");
		all_ok = false;
	}
	color_restore();

    color_cyan();
	myprintf("2) Decoding\n");
	color_restore();
	step_start = mtime();
	
	franzcri fc6(password.c_str(),password.length());
	success = fc6.decode_parallela(output_par.c_str(), decoded_par.c_str(), num_threads);
	eol();
	step_time = (mtime() - step_start) / 1000.0;
	if (success) 
	{
		color_green();
		myprintf("   OK (%10.2fs @ %10s/s) %s\n", step_time, tohuman2(input_size / step_time),decoded_par.c_str());
	} 
	else 
	{
		color_red();
		myprintf(" FAILED\n");
		all_ok = false;
	}
	color_restore();
    
	color_cyan();
	myprintf("3) Verify\n");
	color_restore();
    step_start = mtime();
	franzcri fc8(password.c_str(),password.length());
    success = fc8.decode_parallela(output_par.c_str(), NULL, num_threads);  // NULL = verify only
    eol();    
    step_time = (mtime() - step_start) / 1000.0;
	if (success) 
	{
		color_green();
		myprintf("   OK (%10.2fs @ %10s/s) %s\n", step_time, tohuman2(input_size / step_time),output_par.c_str());
	} 
	else 
	{
		color_red();
		myprintf(" FAILED\n");
		all_ok = false;
	}
	color_restore();
    int64_t multi_end=mtime();
	
	color_cyan();
	myprintf("4) Binary comparison %s vs %s...\n", decoded_par.c_str(), input_file);
    color_restore();
	step_start = mtime();
    success = compare_files_binary(decoded_par.c_str(), input_file);
	eol();
    step_time = (mtime() - step_start) / 1000.0;
	if (success) 
	{
		color_green();
		myprintf("   OK (%10.2fs @ %10s/s)\n", step_time,tohuman2(input_size / step_time));
	}
	else 
	{
		myprintf(" FAILED - Files differ!\n");
		all_ok = false;
	}
	color_restore();
    
    // Pulizia file temporanei
    remove(output_par.c_str());
    remove(decoded_par.c_str());
    
    double multi_time = (multi_end-multi_start) / 1000.0;
    
	myprintf("Time/throughput %10.2fs @ %12s/s\n",multi_time,tohuman(3*input_size/multi_time));
	myprintf("sodio_block_size     %s\n",tohuman(g_sodio_block_size));
	myprintf("opslimit             %d\n",g_sodio_pwhash_opslimit);
	myprintf("memlimit             %s\n",tohuman(g_sodio_pwhash_memlimit));
	
    if (all_ok) 
	{
		color_green();
		myprintf("*** ALL TESTS PASSED ***\n");
	}
	else
	{
		color_red();
        myprintf("*** SOME TESTS FAILED ***\n");
	}
   	color_restore();
	
    return all_ok;
}
bool criautotest() 
{
    myprintf("38820: Starting advanced autotest...\n");
    if (!is_libsodium_loaded) 
    {
        myprintf("38823! AUTOTEST FAILED: libsodium not loaded\n");
        return false;
    }

    bool all_tests_passed = true;
    const char* test_filename = "test_file.franz";
    const std::string correct_password = "password123";
    const std::string wrong_password = "wrongpass";
    const size_t block_size_default = G_FRANZEN_SIZE;
    const size_t block_size_min = 4096;
    const size_t block_size_max = 1024 * 1024;
    const size_t small_data_size = 1024;
    const size_t large_data_size = 2 * 1024 * 1024;

    auto print_result = [&all_tests_passed](const char* test_name, bool passed) 
    {
        myprintf("%s: %s\n", test_name, passed ? "PASSED" : "FAILED");
        if (!passed) 
            all_tests_passed = false;
    };

    // TEST 1: Create, write, rewrite (writeat), and verify
    myprintf("\nTEST 1: Creating, write, rewrite, verify...\n");
    {
        // Create and write initial data
        {
            franzcri fc(correct_password.c_str(), correct_password.length(), block_size_default);
            if (!fc.open(test_filename, true)) 
            {
                print_result("TEST 1 - Creation opening", false);
                goto cleanup;
            }
            std::vector<char> data(small_data_size, 'A');
            if (!fc.write(&data[0], data.size())) 
            {
                print_result("TEST 1 - Initial writing", false);
                fc.close();
                goto cleanup;
            }
            fc.close(); // This wipes the password
        }
        
        // Reopen with NEW instance for writeat
        {
            franzcri fc2(correct_password.c_str(), correct_password.length(), block_size_default);
            if (!fc2.open(test_filename, false)) 
            {
                print_result("TEST 1 - Reopening for writeat", false);
                goto cleanup;
            }
            std::string overwrite_data(104, 'B');
            if (!fc2.writeat(200, overwrite_data.c_str(), overwrite_data.size())) 
            {
                print_result("TEST 1 - Writeat call", false);
                fc2.close();
                goto cleanup;
            }
            fc2.close();
        }
        
        // Reopen with ANOTHER new instance for verification
        {
            franzcri fc3(correct_password.c_str(), correct_password.length(), block_size_default);
            if (!fc3.open(test_filename, false)) 
            {
                print_result("TEST 1 - Reopening for verification", false);
                goto cleanup;
            }
            std::vector<char> decrypted(small_data_size);
            if (!fc3.decrypt_to_buffer(&decrypted[0], decrypted.size())) 
            {
                print_result("TEST 1 - Decryption", false);
                fc3.close();
                goto cleanup;
            }
            fc3.close();

            bool correct = true;
            for (size_t i = 0; i < small_data_size; ++i) 
            {
                char expected = (i >= 200 && i < 304) ? 'B' : 'A';
                if (decrypted[i] != expected) 
                {
                    myprintf("TEST 1 - Error: Incorrect data at position %zu. Expected '%c', found '%c'\n", 
                             i, expected, decrypted[i]);
                    correct = false;
                    break;
                }
            }
            print_result("TEST 1 - Content verification", correct);
        }
    }

    // TEST 2: Empty file
    myprintf("\nTEST 2: Creating empty file...\n");
    {
        {
            franzcri fc(correct_password.c_str(), correct_password.length(), block_size_default);
            if (!fc.open(test_filename, true)) 
            {
                print_result("TEST 2 - Opening creation of empty file", false);
                goto cleanup;
            }
            fc.close();
        }
        
        {
            franzcri fc2(correct_password.c_str(), correct_password.length(), block_size_default);
            if (!fc2.open(test_filename, false)) 
            {
                print_result("TEST 2 - Reopening empty file", false);
                goto cleanup;
            }
            if (!fc2.is_not_changed()) 
            {
                print_result("TEST 2 - Empty file integrity verification", false);
                fc2.close();
                goto cleanup;
            }
            std::vector<char> decrypted(0);
            bool success = fc2.decrypt_to_buffer(&decrypted[0], 0);
            fc2.close();
            print_result("TEST 2 - Empty file decryption", success && decrypted.empty());
        }
    }

    // TEST 3: Large file
    myprintf("\nTEST 3: Big file...\n");
    {
        {
            franzcri fc(correct_password.c_str(), correct_password.length(), block_size_default);
            if (!fc.open(test_filename, true)) 
            {
                print_result("TEST 3 - Opening creation of large file", false);
                goto cleanup;
            }
            std::vector<char> data(large_data_size, 'C');
            if (!fc.write(&data[0], data.size())) 
            {
                print_result("TEST 3 - Writing large file", false);
                fc.close();
                goto cleanup;
            }
            fc.close();
        }
        
        {
            franzcri fc2(correct_password.c_str(), correct_password.length(), block_size_default);
            if (!fc2.open(test_filename, false)) 
            {
                print_result("TEST 3 - Reopening large file", false);
                goto cleanup;
            }
            std::vector<char> decrypted(large_data_size);
            if (!fc2.decrypt_to_buffer(&decrypted[0], decrypted.size())) 
            {
                print_result("TEST 3 - Decryption of large file", false);
                fc2.close();
                goto cleanup;
            }
            fc2.close();
            
            bool correct = true;
            for (size_t i = 0; i < large_data_size; ++i) 
            {
                if (decrypted[i] != 'C') 
                {
                    myprintf("TEST 3 - Error: Incorrect data at position %zu. Expected 'C', found '%c'\n", 
                             i, decrypted[i]);
                    correct = false;
                    break;
                }
            }
            print_result("TEST 3 - Large file content verification", correct);
        }
    }

    // TEST 4: Wrong password
    myprintf("\nTEST 4: Test with wrong password...\n");
    {
        {
            franzcri fc(correct_password.c_str(), correct_password.length(), block_size_default);
            if (!fc.open(test_filename, true)) 
            {
                print_result("TEST 4 - File creation", false);
                goto cleanup;
            }
            std::vector<char> data(small_data_size, 'D');
            if (!fc.write(&data[0], data.size())) 
            {
                print_result("TEST 4 - Initial writing", false);
                fc.close();
                goto cleanup;
            }
            fc.close();
        }
        
        {
            franzcri fc_wrong(wrong_password.c_str(), wrong_password.length(), block_size_default);
            bool should_fail = !fc_wrong.open(test_filename, false);
            print_result("TEST 4 - Opening with incorrect password", should_fail);
        }
    }

    // TEST 5: Corrupted file
    myprintf("\nTEST 5: Corrupted file...\n");
    {
        {
            franzcri fc(correct_password.c_str(), correct_password.length(), block_size_default);
            if (!fc.open(test_filename, true)) 
            {
                print_result("TEST 5 - File creation", false);
                goto cleanup;
            }
            std::vector<char> data(small_data_size, 'E');
            if (!fc.write(&data[0], data.size())) 
            {
                print_result("TEST 5 - Initial writing", false);
                fc.close();
                goto cleanup;
            }
            fc.close();
        }
        
        // Corrupt the file
        {
            FILE* f = fopen(test_filename, "r+b");
            if (f) 
            {
                size_t offset = sizeof(file_header) + sizeof(header_nonce) + 
                               sodium.crypto_aead_chacha20poly1305_ietf_npubbytes() + 10;
                fseek(f, offset, SEEK_SET);
                unsigned char corrupt_byte = 0xFF;
                fwrite(&corrupt_byte, 1, 1, f);
                fclose(f);
            }
        }
        
        {
            franzcri fc2(correct_password.c_str(), correct_password.length(), block_size_default);
            if (!fc2.open(test_filename, false)) 
            {
                print_result("TEST 5 - Opening corrupted file", false);
                goto cleanup;
            }
            bool should_fail = !fc2.is_not_changed();
            fc2.close();
            print_result("TEST 5 - Corruption detection", should_fail);
        }
    }

    // TEST 6: Extreme block sizes
    myprintf("\nTEST 6: Min/max block_size...\n");
    {
        // Minimum block size
        {
            franzcri fc_min(correct_password.c_str(), correct_password.length(), block_size_min);
            if (!fc_min.open(test_filename, true)) 
            {
                print_result("TEST 6 - Opening with minimum block_size", false);
                goto cleanup;
            }
            std::vector<char> data(small_data_size, 'F');
            if (!fc_min.write(&data[0], data.size())) 
            {
                print_result("TEST 6 - Writing with minimum block_size", false);
                fc_min.close();
                goto cleanup;
            }
            fc_min.close();
        }
        
        {
            franzcri fc_min2(correct_password.c_str(), correct_password.length(), block_size_min);
            if (!fc_min2.open(test_filename, false)) 
            {
                print_result("TEST 6 - Reopening with minimum block_size", false);
                goto cleanup;
            }
            std::vector<char> decrypted(small_data_size);
            bool success = fc_min2.decrypt_to_buffer(&decrypted[0], decrypted.size());
            fc_min2.close();
            
            bool correct = true;
            if (success) 
            {
                for (size_t i = 0; i < small_data_size; ++i) 
                {
                    if (decrypted[i] != 'F') 
                    {
                        myprintf("TEST 6 - Error: Incorrect data at position %zu with minimum block_size. "
                                "Expected 'F', found '%c'\n", i, decrypted[i]);
                        correct = false;
                        break;
                    }
                }
            }
            print_result("TEST 6 - Minimum block_size verification", success && correct);
        }
        
        // Maximum block size
        {
            franzcri fc_max(correct_password.c_str(), correct_password.length(), block_size_max);
            if (!fc_max.open(test_filename, true)) 
            {
                print_result("TEST 6 - Opening with maximum block_size", false);
                goto cleanup;
            }
            std::vector<char> data(small_data_size, 'G');
            if (!fc_max.write(&data[0], data.size())) 
            {
                print_result("TEST 6 - Writing with maximum block_size", false);
                fc_max.close();
                goto cleanup;
            }
            fc_max.close();
        }
        
        {
            franzcri fc_max2(correct_password.c_str(), correct_password.length(), block_size_max);
            if (!fc_max2.open(test_filename, false)) 
            {
                print_result("TEST 6 - Reopening with maximum block_size", false);
                goto cleanup;
            }
            std::vector<char> decrypted(small_data_size);
            bool success = fc_max2.decrypt_to_buffer(&decrypted[0], decrypted.size());
            fc_max2.close();
            
            bool correct = true;
            if (success) 
            {
                for (size_t i = 0; i < small_data_size; ++i) 
                {
                    if (decrypted[i] != 'G') 
                    {
                        myprintf("TEST 6 - Error: Incorrect data at position %zu with maximum block_size. "
                                "Expected 'G', found '%c'\n", i, decrypted[i]);
                        correct = false;
                        break;
                    }
                }
            }
            print_result("TEST 6 - Maximum block_size verification", success && correct);
        }
    }

cleanup:
    remove(test_filename);
    
    if (all_tests_passed)
        color_green();
    else
        color_red();
    
    myprintf("\nAutotest done. Result: %s\n", all_tests_passed ? "PASSED" : "SOME FAILED");
    color_restore();
    
    return all_tests_passed;
}
/// keeping for easy debug
bool encode(const char *input_filename, const char *output_filename) 
{
    FILE *input_file = fopen(input_filename, "rb");
    if (!input_file) 
	{
        perror("Error opening input file");
        return false;
    }

    fseek(input_file, 0, SEEK_END);
    long long total_size = -1;
    #ifdef _WIN32
        total_size = _ftelli64(input_file);
    #else
        total_size = ftello(input_file);
    #endif
    fseek(input_file, 0, SEEK_SET);
    long long bytes_processed = 0;

    if (!open(output_filename, true)) 
	{
        fclose(input_file);
        return false;
    }

    std::vector<char> buffer(io_buffer_size);
    size_t bytes_read;
    bool success = true;
	int64_t inizio=mtime();
    while ((bytes_read = fread(&buffer[0], 1, io_buffer_size, input_file)) > 0) 
	{
        if (!write(&buffer[0], bytes_read)) 
		{
            myprintf("\n");
			myprintf("39145! Error during writing of encrypted data\n");
            success = false;
            break;
        }
        bytes_processed += bytes_read;
        // Stampa l'avanzamento

		if (!flagnoeta)
			myavanzamentoby1sec(bytes_processed,total_size,inizio);
		
    }

    if (ferror(input_file)) 
	{
        perror("\nError reading from input file");
        success = false;
    }
    
    if(flagmemzero) 
	    sodium.sodium_memzero(buffer.data(), buffer.size());
    
    fclose(input_file);
    close();

    if (success) 
	    myprintf("Encoding completed\n");
    
    return success;
}

/// this is the real one
bool encode_parallela(const char *input_filename, const char *output_filename, int num_threads) 
{
    if (num_threads <= 0) 
	{
        myprintf("39184! Error: The number of threads must be greater than zero\n");
        return false;
    }

    FILE *input_file = fopen(input_filename, "rb");
    if (!input_file) 
	{
        perror("Error opening input file");
        return false;
    }

    if (fseek64(input_file, 0, SEEK_END) != 0) 
	{
        perror("Error positioning to the end of the input file");
        fclose(input_file);
        return false;
    }

    long long total_size = -1;
#ifdef _WIN32
        total_size = _ftelli64(input_file);
#else
        total_size = ftello(input_file);
#endif
    fclose(input_file);

    if (total_size < 0) 
	{
        myprintf("39212! CRITICAL ERROR: Unable to determine the size of file '%s'\n", input_filename);
        // Non lasciare un file di output vuoto e corrotto
        // open() non è stato ancora chiamato, quindi non c'è nulla da pulire.
        return false;
    }

    if (total_size == 0) 
	{
        open(output_filename, true);
        close();
        return true;
    }
    
    if (!open(output_filename, true)) 
	{
        // Se l'apertura fallisce, il file non esiste, non c'è bisogno di cancellarlo.
        return false;
    }
    
    if (total_size < 0) 
	{
        myprintf("39233! CRITIC: cannot get total_size of '%s'\n", input_filename);
        close();
        remove(output_filename); // Rimuove il file vuoto creato da open()
        return false;
    }


    header.file_data_size = total_size;
    if (!write_header()) 
	{
        myprintf("39243! Error: Initial header writing failed\n");
        close();
        remove(output_filename); // Rimuove il file corrotto
        return false;
    }

    uint64_t total_blocks = (total_size + block_size - 1) / block_size;
    if ((int)num_threads > (int)total_blocks) 
        num_threads = total_blocks > 0 ? (int)total_blocks : 1;
    if (num_threads == 0 && total_blocks > 0) 
		num_threads = 1;


    ///pthread_t* threads 	= new pthread_t[num_threads];
    ///thread_data* t_data = new thread_data[num_threads];
	
	std::vector<pthread_t> threads(num_threads);
	std::vector<thread_data> t_data(num_threads);		
    pthread_mutex_t file_mutex;
    pthread_mutex_init(&file_mutex, NULL);
    
    uint64_t blocks_per_thread 	= total_blocks / num_threads;
    uint64_t remaining_blocks 	= total_blocks % num_threads;
    uint64_t current_block_idx 	= 0;
    bool all_threads_ok 		= true;

	if (flagverbose)
		if (num_threads > 0) 
			myprintf("Encoding threads %d on %s blocks of %s for %s...\n", num_threads, migliaia(total_blocks),tohuman(block_size),tohuman2(total_size));

    for (int i = 0; i < num_threads; ++i) 
	{
        t_data[i].instance 					= this;
        t_data[i].input_filename 			= input_filename;
        t_data[i].file_mutex 				= &file_mutex;
        t_data[i].start_block_idx 			= current_block_idx;
        t_data[i].total_input_size 			= total_size;
		t_data[i].starttime	 				= mtime();

        uint64_t blocks_for_this_thread 	= blocks_per_thread;
        if (remaining_blocks > 0) 
		{
            blocks_for_this_thread++;
            remaining_blocks--;
        }
        t_data[i].num_blocks_to_process 	= blocks_for_this_thread;

        if (pthread_create(&threads[i], NULL, encryption_worker, &t_data[i]) != 0) 
		{
            perror("Error creating thread");
            all_threads_ok = false;
            break; 
        }

        current_block_idx += blocks_for_this_thread;
    }

    if (all_threads_ok) 
        for (int i = 0; i < num_threads; ++i) 
		{
            pthread_join(threads[i], NULL);
            if (!t_data[i].success) 
                all_threads_ok = false;
        }

    pthread_mutex_destroy(&file_mutex);
    ///delete[] threads;
    ///delete[] t_data;
    
    close();

    if (!all_threads_ok) 
	{
        myprintf("39311! One or more threads encountered an error. The output file may be incomplete or corrupted\n");
        return false;
    }
    
    return true;
}
bool decode_parallela(const char *input_filename, const char *output_filename, int num_threads) 
{
    if (num_threads <= 0) 
	{
        myprintf("39321! Error: The number of threads must be greater than zero\n");
        return false;
    }

    // Apre il file criptato e legge/verifica l'header. La chiave viene derivata qui.
    if (!open(input_filename, false)) 
	    return false;
    
    // Determina la modalità: se output_filename è nullo o vuoto, è una verifica.
	// Mahoney's trick
    bool verify_only_mode = (output_filename == NULL || *output_filename == '\0');
    
    FILE* output_file = NULL;
    if (!verify_only_mode) 
	{
        output_file = fopen(output_filename, "wb");
        if (!output_file) 
		{
            perror("Error creating output file");
            close(); // Chiude il file di input
            return false;
        }
    } 
	else 
	{
		if (flagverbose)
			myprintf("Starting parallel verification (no disk writing)...\n");
    }

    uint64_t total_blocks = (header.file_data_size + block_size - 1) / block_size;
    if ((total_blocks > 0) && ((int)num_threads > (int)total_blocks))
	    num_threads = (int)total_blocks;
    if (num_threads == 0 && total_blocks > 0) 
		num_threads = 1;
    
    // Se il file è vuoto (0 blocchi), il lavoro è già finito.
    if (total_blocks == 0) 
	{
        if (output_file) 
			fclose(output_file);
        close();
        return true;
    }

  ///  pthread_t* threads 				= new pthread_t[num_threads];
    ///decode_thread_data* t_data 		= new decode_thread_data[num_threads];
	
	std::vector<pthread_t> 			threads(num_threads);
	std::vector<decode_thread_data> t_data(num_threads);		
    
    pthread_mutex_t file_io_mutex;
    pthread_mutex_init(&file_io_mutex, NULL);
    
    uint64_t blocks_per_thread 		= total_blocks / num_threads;
    uint64_t remaining_blocks 		= total_blocks % num_threads;
    uint64_t current_block_idx 		= 0;
    bool all_threads_ok 			= true;

	if (flagverbose)
	{
		if (!verify_only_mode) 
			myprintf("Decoding threads %d on %s blocks of %s for %s...\n", num_threads, migliaia(total_blocks),tohuman(block_size),tohuman2(total_blocks*block_size));
		else
			myprintf("Verifying threads %d on %s blocks of %s for %s...\n", num_threads, migliaia(total_blocks),tohuman(block_size),tohuman2(total_blocks*block_size));
	}
	
    for (int i = 0; i < num_threads; ++i) 
	{
        t_data[i].instance 			= this;
        t_data[i].output_file 		= output_file;
        t_data[i].file_io_mutex 	= &file_io_mutex;
        t_data[i].start_block_idx 	= current_block_idx;
		t_data[i].total_input_size 	= total_blocks*block_size;
		t_data[i].starttime			= mtime();

        uint64_t blocks_for_this_thread = blocks_per_thread;
        if (remaining_blocks > 0) 
		{
            blocks_for_this_thread++;
            remaining_blocks--;
        }
        t_data[i].num_blocks_to_process = blocks_for_this_thread;

        if (pthread_create(&threads[i], NULL, decryption_worker, &t_data[i]) != 0) 
		{
            perror("Error creating thread");
            all_threads_ok = false;
            break; 
        }
        current_block_idx += blocks_for_this_thread;
    }

    if (all_threads_ok) 
        for (int i = 0; i < num_threads; ++i) 
		{
            pthread_join(threads[i], NULL);
            if (!t_data[i].success) 
			    all_threads_ok = false;
        }

    pthread_mutex_destroy(&file_io_mutex);
    ///delete[] threads;
    ///delete[] t_data;

    if (output_file) fclose(output_file);
    close(); // Chiude il file di input

    if (!all_threads_ok) 
	{
        // Se c'è stato un errore e stavamo scrivendo un file, lo cancelliamo per non lasciare output corrotti.
        if (!verify_only_mode) 
			remove(output_filename);
        return false;
    }

    return true;
}
private:
// Helper: Encrypt a block of plaintext (usa buffer pre-allocati)
    bool encrypt_block(const unsigned char* plaintext_data, 
                      size_t plaintext_len,
                      unsigned char* out_nonce,
                      unsigned char* out_ciphertext,
                      size_t* out_ciphertext_len)
    {
        size_t nonce_len = sodium.crypto_aead_chacha20poly1305_ietf_npubbytes();
        
        sodium.randombytes_buf(out_nonce, nonce_len);
        
        unsigned long long ciphertext_len = 0;
        if (sodium.crypto_aead_chacha20poly1305_ietf_encrypt(
                out_ciphertext, &ciphertext_len,
                plaintext_data, plaintext_len,
                NULL, 0, NULL, out_nonce, key) != 0)
        {
            return false;
        }
        
        if (out_ciphertext_len)
            *out_ciphertext_len = (size_t)ciphertext_len;
        
        return true;
    }
    
    // Helper: Decrypt a block (usa buffer pre-allocato)
    bool decrypt_block(const unsigned char* ciphertext_data,
                      size_t ciphertext_len,
                      const unsigned char* nonce_data,
                      unsigned char* out_plaintext,
                      size_t* out_plaintext_len)
    {
        unsigned long long decrypted_len = 0;
        if (sodium.crypto_aead_chacha20poly1305_ietf_decrypt(
                out_plaintext, &decrypted_len, NULL,
                ciphertext_data, ciphertext_len,
                NULL, 0, nonce_data, key) != 0)
        {
            if (flagmemzero)
                sodium.sodium_memzero(out_plaintext, block_size);
            return false;
        }
        
        if (out_plaintext_len)
            *out_plaintext_len = (size_t)decrypted_len;
        
        return true;
    }
    
    // Helper: Write encrypted block to file at specific block index
    bool write_encrypted_block_at(uint64_t block_idx,
                                   const unsigned char* nonce,
                                   const unsigned char* ciphertext,
                                   size_t ciphertext_len)
    {
        size_t nonce_len = sodium.crypto_aead_chacha20poly1305_ietf_npubbytes();
        
        int64_t file_pos = get_block_file_offset(block_idx);
        if (file_pos < 0)
        {
            myprintf("write_encrypted_block_at: Invalid block offset\n");
            return false;
        }
        
        if (fseek64(file_handle, file_pos, SEEK_SET) != 0)
            return false;
        
        if (fwrite(nonce, 1, nonce_len, file_handle) != nonce_len ||
            fwrite(ciphertext, 1, ciphertext_len, file_handle) != ciphertext_len)
        {
            perror("Error writing encrypted block");
            return false;
        }
        
        // Update CRC32 tracking
        uint32_t blockcrc = crc32_16bytes(nonce, nonce_len);
        blockcrc = crc32_16bytes(ciphertext, ciphertext_len, blockcrc);
        
        pthread_mutex_lock(&blocks_crc32_mutex);
        
        // Check if block already exists in CRC tracking
        bool block_found = false;
        for (size_t i = 0; i < blocks_crc32.size(); ++i)
        {
            if ((uint64_t)blocks_crc32[i].crc32start == (uint64_t)file_pos)
            {
                blocks_crc32[i].crc32 = blockcrc;
                block_found = true;
                break;
            }
        }
        
        if (!block_found)
        {
            blocks_crc32.push_back(s_crc32block(blockcrc, file_pos, nonce_len + ciphertext_len));
        }
        
        pthread_mutex_unlock(&blocks_crc32_mutex);
        
        return true;
    }
    
    // Helper: Read, modify, and rewrite a partial block
    bool read_modify_write_block(uint64_t block_idx,
                                  size_t offset_in_block,
                                  const char* new_data,
                                  size_t new_data_len,
                                  unsigned char* work_plaintext,
                                  unsigned char* work_nonce,
                                  unsigned char* work_ciphertext,
                                  unsigned char* work_encrypted)
    {
        size_t tag_len = sodium.crypto_aead_chacha20poly1305_ietf_abytes();
        size_t nonce_len = sodium.crypto_aead_chacha20poly1305_ietf_npubbytes();
        
        int64_t file_pos = get_block_file_offset(block_idx);
        if (file_pos < 0)
            return false;
        
        if (fseek64(file_handle, file_pos, SEEK_SET) != 0)
            return false;
        
        // Read existing block
        if (fread(work_nonce, 1, nonce_len, file_handle) != nonce_len ||
            fread(work_encrypted, 1, block_size + tag_len, file_handle) != block_size + tag_len)
        {
            perror("Error reading existing block for modification");
            return false;
        }
        
        // Decrypt existing block
        if (!decrypt_block(work_encrypted, block_size + tag_len, work_nonce, work_plaintext, NULL))
        {
            myprintf("Error decrypting existing block for modification\n");
            return false;
        }
        
        // Modify the plaintext
        memcpy(work_plaintext + offset_in_block, new_data, new_data_len);
        
        // Re-encrypt
        if (!encrypt_block(work_plaintext, block_size, work_ciphertext, work_encrypted, NULL))
        {
            myprintf("Error re-encrypting modified block\n");
            if (flagmemzero)
                sodium.sodium_memzero(work_plaintext, block_size);
            return false;
        }
        
        if (flagmemzero)
            sodium.sodium_memzero(work_plaintext, block_size);
        
        // Write back
        return write_encrypted_block_at(block_idx, work_ciphertext, work_encrypted, block_size + tag_len);
    }
	

	bool decrypt_and_write_stream(FILE *output_file) 
	{
		if (!is_file_open || !output_file) 
			return false;
		
		size_t tag_len   			= sodium.crypto_aead_chacha20poly1305_ietf_abytes();
		size_t nonce_len 			= sodium.crypto_aead_chacha20poly1305_ietf_npubbytes();
		uint64_t total_blocks 		= (header.file_data_size + block_size - 1) / block_size;
		uint64_t bytes_processed 	= 0;

		std::vector<unsigned char> encrypted(block_size + tag_len);
		std::vector<unsigned char> plaintext(block_size);

		for (uint64_t block_idx = 0; block_idx < total_blocks; ++block_idx) 
		{
			int64_t block_file_offset = get_block_file_offset(block_idx);
			if (fseek64(file_handle, block_file_offset, SEEK_SET) != 0) 
			{
				perror("\nError positioning in input file");
				return false;
			}

			// Leggi nonce e blocco cifrato
			std::vector<unsigned char> block_nonce(nonce_len);
			if (fread(&block_nonce[0], 1, nonce_len, file_handle) != nonce_len) 
				return false;
			if (fread(&encrypted[0], 1, encrypted.size(), file_handle) != encrypted.size()) 
				return false;
			
			// Decifra il blocco
			unsigned long long decrypted_len = 0;
			if (sodium.crypto_aead_chacha20poly1305_ietf_decrypt(
					&plaintext[0], &decrypted_len, NULL,
					&encrypted[0], encrypted.size(),
					NULL, 0, &block_nonce[0], key) != 0) 
					{
						myprintf("\n");
						myprintf("39464! Error: Decryption of block #%s failed. File corrupted or incorrect password\n", migliaia(block_idx));
						if (flagmemzero) 
							sodium.sodium_memzero(plaintext.data(), plaintext.size());
						return false;
					}

			// Calcola quanti byte scrivere (gestisce l'ultimo blocco)
			uint64_t remaining_in_file 	= header.file_data_size - bytes_processed;
			size_t bytes_to_write = ((size_t)remaining_in_file < (size_t)decrypted_len) ? 
						   (size_t)remaining_in_file : (size_t)decrypted_len;
			
			// Scrivi il blocco decifrato nel file di output
			if (fwrite(&plaintext[0], 1, bytes_to_write, output_file) != bytes_to_write) 
			{
				perror("\nError writing to output file");
				if (flagmemzero) 
					sodium.sodium_memzero(plaintext.data(), plaintext.size());
				return false;
			}

			bytes_processed += bytes_to_write;

			// Stampa l'avanzamento
			/*
			if (header.file_data_size > 0) {
				int percent = (int)(100.0 * bytes_processed / header.file_data_size);
				printf("\rDecifratura in corso: %d%%", percent);
				fflush(stdout);
			}
			*/
		}

		if(flagmemzero) 
		{
			sodium.sodium_memzero(plaintext.data(), plaintext.size());
			sodium.sodium_memzero(encrypted.data(), encrypted.size());
		}
		
		myprintf("Decryption completed\n");
		return true;
	}

    // Validazione parametri Argon2id
    bool validate_argon2_params(uint64_t opslimit, uint64_t memlimit) 
	{
        // Controlla limiti minimi e massimi ragionevoli
        const uint64_t min_opslimit = CRYPTO_PWHASH_OPSLIMIT_INTERACTIVE;
        const uint64_t max_opslimit = CRYPTO_PWHASH_OPSLIMIT_SENSITIVE * 10; // Permetti fino a 10x sensitive
        const uint64_t min_memlimit = CRYPTO_PWHASH_MEMLIMIT_INTERACTIVE;
        const uint64_t max_memlimit = 4ULL * 1024 * 1024 * 1024; // Max 4GB
        
        if (opslimit < min_opslimit || opslimit > max_opslimit) 
		{
            myprintf("39516! Error: opslimit (%s) outside allowed limits (%%s-%s)\n", 
                   migliaia(opslimit), migliaia2(min_opslimit), migliaia3(max_opslimit));
            return false;
        }
        
        if (memlimit < min_memlimit || memlimit > max_memlimit) 
		{
            myprintf("39523! Error: memlimit (%s) outside allowed limits (%s-%s)\n", 
                   migliaia(memlimit), migliaia2(min_memlimit), migliaia3(max_memlimit));
            return false;
        }
        
        return true;
    }
    
    // Controlla overflow negli offset dei blocchi
    // Verifica che block_idx * block_size non causi overflow
    bool check_offset_overflow(uint64_t block_idx, uint64_t block_size) 
	{
        if (block_idx > 0 && block_size > UINT64_MAX / block_idx) 
		{
            myprintf("39537! Error: Overflow in block offset %s with block_size %s\n", 
                   migliaia(block_idx), migliaia(block_size));
            return false;
        }
        return true;
    }
    
    // Validazione dimensione file ragionevole
    bool validate_file_size(uint64_t file_size) 
	{
        const uint64_t max_file_size = 100ULL * (1024ULL * 1024 * 1024 * 1024);
        if (file_size > max_file_size) 
		{
            myprintf("39550! Error: File size (%s bytes) exceeds the maximum limit (%s bytes)\n", 
                   migliaia(file_size), migliaia2(max_file_size));
            return false;
        }
        return true;
    }
    
	
bool validate_header_integrity() 
{
    // 1. Magic bytes (fondamentale)
    if (memcmp(header.magic, MAGIC_BYTES, MAGIC_BYTES_LEN) != 0) 
    {
        myprintf("39570! Error: Invalid magic bytes\n");
        return false;
    }

    // 2. Version field con range valido
    const uint64_t MIN_VERSION = 1;
    const uint64_t MAX_VERSION = 100; // Lascia spazio per future versioni
    if (header.version < MIN_VERSION || header.version > MAX_VERSION) 
    {
        myprintf("39571! Error: Invalid version %s (expected %s-%s)\n", 
                 migliaia(header.version), migliaia2(MIN_VERSION), migliaia3(MAX_VERSION));
        return false;
    }

    // 3. Block size validation (più rigorosa)
    const uint64_t min_block_size = 4096;
    const uint64_t max_block_size = 16 * 1024 * 1024;
    
    if (header.block_size < min_block_size || header.block_size > max_block_size) 
    {
        myprintf("39570! Error: block_size %s outside limits (%s-%s)\n", 
                 migliaia(header.block_size), migliaia2(min_block_size), 
                 migliaia3(max_block_size));
        return false;
    }
    
    // Verifica potenza di 2 (efficienza)
    if ((header.block_size & (header.block_size - 1)) != 0) 
    {
        myprintf("39578! Error: block_size %s is not a power of 2\n", 
                 migliaia(header.block_size));
        return false;
    }

    // Verifica allineamento (performance crypto)
    if (header.block_size % 16 != 0) 
    {
        myprintf("39579! Warning: block_size %s not aligned to 16 bytes\n", 
                 migliaia(header.block_size));
        // Non fatale, ma subottimale
    }

    // 4. Argon2id parameters validation
    if (!validate_argon2_params(header.pwhash_opslimit, header.pwhash_memlimit)) 
        return false;

    // Verifica prodotto opslimit * memlimit per overflow
    if (header.pwhash_opslimit > 0 && 
        header.pwhash_memlimit > UINT64_MAX / header.pwhash_opslimit)
    {
        myprintf("39580! Error: opslimit * memlimit would overflow\n");
        return false;
    }

    // 5. File size validation
    if (!validate_file_size(header.file_data_size)) 
        return false;

    // 6. Verifica overflow nel calcolo dei blocchi
    if (header.file_data_size > 0) 
    {
        // Check: (file_data_size + block_size - 1) non overflow
        if (header.file_data_size > UINT64_MAX - header.block_size + 1)
        {
            myprintf("39581! Error: file_data_size causes overflow in block calculation\n");
            return false;
        }

        uint64_t num_blocks = (header.file_data_size + header.block_size - 1) / header.block_size;
        
        // Verifica che num_blocks sia ragionevole
        const uint64_t MAX_BLOCKS = 1000000000ULL; // 1 miliardo
        if (num_blocks > MAX_BLOCKS)
        {
            myprintf("39582! Error: Too many blocks: %s (max %s)\n",
                     migliaia(num_blocks), migliaia2(MAX_BLOCKS));
            return false;
        }

        if (!check_offset_overflow(num_blocks - 1, header.block_size)) 
            return false;
    }

    // 7. Salt validation (non deve essere tutto zero)
    bool salt_is_zero = true;
    for (size_t i = 0; i < sizeof(header.salt); ++i)
    {
        if (header.salt[i] != 0)
        {
            salt_is_zero = false;
            break;
        }
    }
    if (salt_is_zero)
    {
        myprintf("39583! Error: Salt is all zeros (invalid)\n");
        return false;
    }

    // 8. Prefix validation (coerenza con file_data_size)
    if (header.file_data_size > 0)
    {
        size_t nonce_len = sodium.crypto_aead_chacha20poly1305_ietf_npubbytes();
        size_t tag_len = sodium.crypto_aead_chacha20poly1305_ietf_abytes();
        uint64_t single_block_size = header.block_size + nonce_len + tag_len;
        
        // Verifica overflow in single_block_size
        if (header.block_size > UINT64_MAX - nonce_len - tag_len)
        {
            myprintf("39584! Error: block_size causes overflow with nonce+tag\n");
            return false;
        }

        uint64_t num_blocks = (header.file_data_size + header.block_size - 1) / header.block_size;
        
        // Verifica overflow in total_encrypted_size
        if (num_blocks > UINT64_MAX / single_block_size)
        {
            myprintf("39585! Error: num_blocks * single_block_size would overflow\n");
            return false;
        }
        
        uint64_t total_encrypted_size = num_blocks * single_block_size;

        // prefix_size deve essere < total_encrypted_size
        if (header.prefix_size > total_encrypted_size)
        {
            myprintf("39586! Error: prefix_size %s > total_encrypted_size %s\n",
                     migliaia(header.prefix_size), migliaia2(total_encrypted_size));
            return false;
        }

        // prefix_size deve essere multiplo di single_block_size (o 0)
        if (header.prefix_size > 0 && header.prefix_size % single_block_size != 0)
        {
            myprintf("39587! Error: prefix_size %s not multiple of block size %s\n",
                     migliaia(header.prefix_size), migliaia2(single_block_size));
            return false;
        }

        // Se prefix_size > 0, prefix_crc32 dovrebbe essere != 0
        // (statisticamente improbabile che sia esattamente 0)
        if (header.prefix_size > 0 && header.prefix_crc32 == 0)
        {
            if (flagdebug)
                myprintf("DEBUG: Warning: prefix_size > 0 but prefix_crc32 == 0 (suspicious)\n");
        }

        // Se prefix_size == 0, prefix_crc32 dovrebbe essere 0
        if (header.prefix_size == 0 && header.prefix_crc32 != 0)
        {
            myprintf("39588! Error: prefix_size == 0 but prefix_crc32 != 0\n");
            return false;
        }
    }
    else // file_data_size == 0
    {
        // File vuoto: tutto deve essere zero
        if (header.prefix_size != 0 || header.prefix_crc32 != 0 || header.crc32 != 0)
        {
            myprintf("39589! Error: Empty file but non-zero prefix/crc fields\n");
            return false;
        }
    }

    // 9. CRC32 validation (deve essere nel range uint32)
    if (header.crc32 > 0xFFFFFFFFULL)
    {
        myprintf("39590! Error: crc32 value %s exceeds 32-bit range\n", 
                 migliaia(header.crc32));
        return false;
    }

    if (header.prefix_crc32 > 0xFFFFFFFFULL)
    {
        myprintf("39591! Error: prefix_crc32 value %s exceeds 32-bit range\n", 
                 migliaia(header.prefix_crc32));
        return false;
    }

    // 10. Quickhash validation (opzionale, dipende da come lo usi)
    // Se quickhash == 0 e file_data_size > 0, potrebbe essere sospetto
    if (header.file_data_size > 0 && header.quickhash == 0)
    {
        if (flagdebug)
            myprintf("DEBUG: Warning: non-empty file but quickhash == 0\n");
    }

    // 11. Controllo dimensione file effettiva su disco
    if (!validate_actual_file_size()) 
        return false;

    // 12. Padding verification (dovrebbe essere tutto zero per sicurezza)
    bool pad_is_zero = true;
    for (size_t i = 0; i < sizeof(header.pad); ++i)
    {
        if (header.pad[i] != 0)
        {
            pad_is_zero = false;
            break;
        }
    }
    if (!pad_is_zero)
    {
        if (flagdebug)
            myprintf("DEBUG: Warning: header padding not zeroed (potential data leak)\n");
        // Non fatale, ma indica implementazione non pulita
    }

    if (flagdebug)
        myprintf("DEBUG: Header integrity validation passed\n");

    return true;
}

	bool validate_actual_file_size() 
	{
		// Salva la posizione corrente
		long long current_pos = -1;
		#ifdef _WIN32
			current_pos = _ftelli64(file_handle);
		#else
			current_pos = ftello(file_handle);
		#endif
		
		if (current_pos < 0) 
		{
			myprintf("39617! Error: Unable to determine the current position in the file\n");
			return false;
		}

		// Vai alla fine del file per determinarne la dimensione
		if (fseek64(file_handle, 0, SEEK_END) != 0) 
		{
			myprintf("39624! Error: Unable to position to the end of the file\n");
			return false;
		}

		long long actual_file_size = -1;
		#ifdef _WIN32
			actual_file_size = _ftelli64(file_handle);
		#else
			actual_file_size = ftello(file_handle);
		#endif

		// Ripristina la posizione originale
		if (fseek64(file_handle, current_pos, SEEK_SET) != 0) 
		{
			myprintf("39638! Error: Unable to restore the position in the file\n");
			return false;
		}

		if (actual_file_size < 0) 
		{
			myprintf("39644! Error: Unable to determine the actual file size\n");
			return false;
		}

		// Calcola la dimensione attesa basata sull'header
		size_t nonce_len 	= sodium.crypto_aead_chacha20poly1305_ietf_npubbytes();
		size_t tag_len 		= sodium.crypto_aead_chacha20poly1305_ietf_abytes();
		
		// Calcola il numero di blocchi di dati
		uint64_t num_data_blocks = 0;
		if (header.file_data_size > 0) 
			num_data_blocks = (header.file_data_size + header.block_size - 1) / header.block_size;
		
		// Dimensione attesa:
		// - Header fisso
		// - Nonce dell'header 
		// - Per ogni blocco di dati: nonce + dati cifrati + tag di autenticazione
		uint64_t expected_size = sizeof(file_header) + 
								sizeof(header_nonce) + 
								num_data_blocks * (nonce_len + header.block_size + tag_len);
		
		if (flagdebug) 
		{
			myprintf("DEBUG: Actual file size      : %s bytes\n", migliaia(actual_file_size));
			myprintf("DEBUG: Expected size         : %s bytes\n", migliaia(expected_size));
			myprintf("DEBUG: Number of data blocks : %s\n", migliaia(num_data_blocks));
			myprintf("DEBUG: Size per block        : %s (nonce) + %s (data) + %s (tag) = %s bytes\n", 
				   migliaia(nonce_len), migliaia2(header.block_size), migliaia3(tag_len), migliaia4(nonce_len + header.block_size + tag_len));
		}
		
		if ((uint64_t)actual_file_size != expected_size) 
		{
			color_red();
			myprintf("39656!Error: File size does not match the expected size\n");
			myprintf("39677:       Actual file: %s bytes, expected: %s bytes\n", migliaia(actual_file_size), migliaia2(expected_size));
			
			if ((uint64_t)actual_file_size < expected_size) 
				myprintf("         The file appears truncated or incomplete\n");
			else 
				myprintf("         The file contains unexpected extra data\n");
			color_restore();
			return false;
		}
		
		if (flagdebug) 
		   myprintf("DEBUG: File size verification passed\n");
		
		return true;
	}


	/// semplice per debug
	bool decode(const char *input_filename, const char *output_filename) 
	{
		if (!open(input_filename, false)) 
		{
			// L'errore specifico gia stampato da open()
			return false;
		}

		FILE *output_file = fopen(output_filename, "wb");
		if (!output_file) 
		{
			perror("Error creating output file");
			close();
			return false;
		}

		// Chiama la nuova funzione di streaming
		bool success = decrypt_and_write_stream(output_file);
		
		fclose(output_file);
		close(); // Chiude il file di input e resetta lo stato
		
		return success;
	}
	bool is_not_changed() 
	{
		if (!is_file_open) 
		{
			myprintf("39725! Error: No file open for integrity check\n");
			return false;
		}

		// The header integrity has already been verified by open().
		size_t tag_len   		= sodium.crypto_aead_chacha20poly1305_ietf_abytes();
		size_t nonce_len 		= sodium.crypto_aead_chacha20poly1305_ietf_npubbytes();
		uint64_t total_blocks 	= (header.file_data_size + block_size - 1) / block_size;

		// If the file is empty (only header), it is intact by definition.
		if (total_blocks == 0) 
			return true;

		if (flagdebug) 
			myprintf("DEBUG: Checking integrity of %s data blocks...\n", migliaia(total_blocks));

		std::vector<unsigned char> dummy_plaintext(block_size);
		unsigned long long dummy_decrypted_len = 0;

		for (uint64_t block_idx = 0; block_idx < total_blocks; ++block_idx) 
		{
			int64_t block_file_offset = get_block_file_offset(block_idx);
			if (fseek64(file_handle, block_file_offset, SEEK_SET) != 0) 
			{
				myprintf("39750! ERROR: Unable to position to block #%s\n", migliaia(block_idx));
				return false;
			}

			std::vector<unsigned char> block_nonce(nonce_len);
			if (fread(&block_nonce[0], 1, nonce_len, file_handle) != nonce_len) 
			{
				myprintf("39757! ERROR: Nonce reading failed for block #%s\n",migliaia(block_idx));
				return false;
			}

			std::vector<unsigned char> encrypted(block_size + tag_len);
			if (fread(&encrypted[0], 1, encrypted.size(), file_handle) != encrypted.size()) 
			{
				myprintf("39764! ERROR: Reading encrypted data failed for block #%s\n", migliaia(block_idx));
				return false;
			}

			// Attempts to decrypt: this is the real block integrity check.
			//  If the authentication tag does not match, the function will fail.
			if (sodium.crypto_aead_chacha20poly1305_ietf_decrypt(
					&dummy_plaintext[0], &dummy_decrypted_len, NULL,
					&encrypted[0], encrypted.size(),
					NULL, 0, &block_nonce[0], key) != 0) {
				// Adds a newline to not overwrite the progress line
				myprintf("39775! ERROR: Integrity check failed on block #s The block is corrupted (good)\n", migliaia(block_idx));
				if (flagmemzero) 
					sodium.sodium_memzero(dummy_plaintext.data(), dummy_plaintext.size());
				return false;
			}
			
	/*
			int percent = (int)(100.0 * (block_idx + 1) / total_blocks);
			printf("\rVerification in progress: %d%%", percent);
			fflush(stdout);
			*/
		}
		
		if (flagmemzero) 
			sodium.sodium_memzero(dummy_plaintext.data(), dummy_plaintext.size());
		
		myprintf("Verification completed\n");
		return true;
	}

private: 
    
struct thread_data 
{
    franzcri* 			instance;
    const char* 		input_filename;
    pthread_mutex_t* 	file_mutex;
    uint64_t 			start_block_idx;
    uint64_t 			num_blocks_to_process;
    uint64_t 			total_input_size;
    uint64_t			starttime;
    bool 				success;
};

// Nuova struct per il worker di decodifica
struct decode_thread_data 
{
    franzcri* 			instance;
    FILE* 				output_file;
    pthread_mutex_t* 	file_io_mutex;
    uint64_t 			start_block_idx;
    uint64_t 			num_blocks_to_process;
    uint64_t 			total_input_size;
    uint64_t			starttime;
    bool 				success;
};

static void* encryption_worker(void* arg) 
{
    thread_data* data = (thread_data*)arg;
    data->success = false;

    FILE* input_file = fopen(data->input_filename, "rb");
    if (!input_file) 
    {
        perror("WORKER: Error opening input file");
        return NULL;
    }

    size_t tag_len = data->instance->sodium.crypto_aead_chacha20poly1305_ietf_abytes();
    size_t nonce_len = data->instance->sodium.crypto_aead_chacha20poly1305_ietf_npubbytes();
    const uint64_t block_size = data->instance->block_size;

    // OTTIMIZZAZIONE: Alloca buffer UNA SOLA VOLTA fuori dal loop
    unsigned char* plaintext = new unsigned char[block_size];
    unsigned char* ciphertext = new unsigned char[block_size + tag_len];
    unsigned char* block_nonce = new unsigned char[nonce_len];

    for (uint64_t i = 0; i < data->num_blocks_to_process; ++i) 
    {
        uint64_t current_block_idx = data->start_block_idx + i;
        int64_t input_offset = (int64_t)(current_block_idx * block_size);

        if (data->instance->fseek64(input_file, input_offset, SEEK_SET) != 0) 
        {
            perror("WORKER: Error fseek64 on input file");
            goto cleanup_and_exit;
        }

        // Calcola quanti byte leggere per questo blocco
        uint64_t bytes_remaining_in_file = data->total_input_size - input_offset;
        size_t bytes_to_read = ((uint64_t)block_size < bytes_remaining_in_file) ? 
                              (uint64_t)block_size : (size_t)bytes_remaining_in_file;

        size_t bytes_read = fread(plaintext, 1, bytes_to_read, input_file);
        if (bytes_read != bytes_to_read) 
        {
            if (flagmemzero)
                data->instance->sodium.sodium_memzero(plaintext, block_size);
            myprintf("39858! WORKER: Error reading block #%s from input file\n", 
                     migliaia(current_block_idx));
            goto cleanup_and_exit;
        }

        // Padding se necessario
        if (bytes_read < block_size) 
            memset(plaintext + bytes_read, 0, block_size - bytes_read);
        
        // Genera nonce
        data->instance->sodium.randombytes_buf(block_nonce, nonce_len);

        // Cifra il blocco (CPU intensive - fuori dal mutex)
        unsigned long long ciphertext_len = 0;
        if (data->instance->sodium.crypto_aead_chacha20poly1305_ietf_encrypt(
                ciphertext, &ciphertext_len,
                plaintext, block_size,
                NULL, 0, NULL, block_nonce, data->instance->key) != 0) 
        {
            myprintf("39874! WORKER: Encryption error for block #%s\n", migliaia(current_block_idx));
            goto cleanup_and_exit;
        }
        
        // OTTIMIZZAZIONE: Mutex solo per I/O e CRC update, non per crypto
        pthread_mutex_lock(data->file_mutex);
        
        int64_t block_file_offset = data->instance->get_block_file_offset(current_block_idx);
        
        if (flagdebug3)
            myprintf("43521: block file offset ******** %21s\n", migliaia(block_file_offset));
        
        if (data->instance->fseek64(data->instance->file_handle, block_file_offset, SEEK_SET) != 0) 
        {
            perror("WORKER: Error fseek64 on output file");
            pthread_mutex_unlock(data->file_mutex);
            goto cleanup_and_exit;
        }

        if (fwrite(block_nonce, 1, nonce_len, data->instance->file_handle) != nonce_len ||
            fwrite(ciphertext, 1, block_size + tag_len, data->instance->file_handle) != block_size + tag_len) 
        {
            perror("WORKER: Error writing block data");
            pthread_mutex_unlock(data->file_mutex);
            goto cleanup_and_exit;
        }
        
        // CRC update
        uint32_t blockcrc = crc32_16bytes(block_nonce, nonce_len);
        blockcrc = crc32_16bytes(ciphertext, block_size + tag_len, blockcrc);
        
        pthread_mutex_lock(&data->instance->blocks_crc32_mutex);
        data->instance->blocks_crc32.push_back(
            s_crc32block(blockcrc, block_file_offset, nonce_len + block_size + tag_len));
        pthread_mutex_unlock(&data->instance->blocks_crc32_mutex);

        // OTTIMIZZAZIONE: Aggiorna statistiche senza mutex aggiuntivo
        // (già dentro file_mutex, è sufficiente)
        data->instance->worked_so_far += bytes_read;
        if (!flagnoeta)
            myavanzamentoby1sec(data->instance->worked_so_far, data->total_input_size, 
                               data->starttime, false);
        
        pthread_mutex_unlock(data->file_mutex);
    }

    data->success = true;

cleanup_and_exit:
    if (flagmemzero)
    {
        data->instance->sodium.sodium_memzero(plaintext, block_size);
        data->instance->sodium.sodium_memzero(ciphertext, block_size + tag_len);
        data->instance->sodium.sodium_memzero(block_nonce, nonce_len);
    }
    
    delete[] plaintext;
    delete[] ciphertext;
    delete[] block_nonce;
    
    fclose(input_file);
    return NULL;
}

static void* decryption_worker(void* arg) 
{
    decode_thread_data* data = (decode_thread_data*)arg;
    data->success = false;

    franzcri* instance = data->instance;
    const uint64_t block_size = instance->block_size;
    const size_t tag_len = instance->sodium.crypto_aead_chacha20poly1305_ietf_abytes();
    const size_t nonce_len = instance->sodium.crypto_aead_chacha20poly1305_ietf_npubbytes();

    // OTTIMIZZAZIONE: Alloca buffer UNA SOLA VOLTA fuori dal loop
    unsigned char* encrypted = new unsigned char[block_size + tag_len];
    unsigned char* plaintext = new unsigned char[block_size];
    unsigned char* block_nonce = new unsigned char[nonce_len];

    for (uint64_t i = 0; i < data->num_blocks_to_process; ++i) 
    {
        uint64_t current_block_idx = data->start_block_idx + i;

        // Leggi blocco cifrato (con mutex per I/O)
        pthread_mutex_lock(data->file_io_mutex);

        int64_t block_file_offset = instance->get_block_file_offset(current_block_idx);
        if (instance->fseek64(instance->file_handle, block_file_offset, SEEK_SET) != 0) 
        {
            perror("\nWORKER: Error fseek64 on input file");
            pthread_mutex_unlock(data->file_io_mutex);
            goto cleanup_and_exit;
        }

        bool read_ok = (fread(block_nonce, 1, nonce_len, instance->file_handle) == nonce_len &&
                       fread(encrypted, 1, block_size + tag_len, instance->file_handle) == block_size + tag_len);

        pthread_mutex_unlock(data->file_io_mutex);
        
        if (!read_ok) 
        {
            myprintf("39942! WORKER: Error reading block #%s from input file\n", 
                     migliaia(current_block_idx));
            goto cleanup_and_exit;
        }

        // OTTIMIZZAZIONE: Decifra FUORI dal mutex (CPU intensive, parallelo)
        unsigned long long decrypted_len = 0;
        if (instance->sodium.crypto_aead_chacha20poly1305_ietf_decrypt(
                plaintext, &decrypted_len, NULL,
                encrypted, block_size + tag_len,
                NULL, 0, block_nonce, instance->key) != 0) 
        {
            myprintf("39953: WORKER: ERROR: Decryption failed on block #%s "
                    "File corrupted or incorrect password\n", migliaia(current_block_idx));
            goto cleanup_and_exit;
        }

        // Se non in 'verify' mode, scrivi su output file
        if (data->output_file != NULL) 
        {
            uint64_t bytes_processed_so_far = current_block_idx * block_size;
            uint64_t remaining_in_file = instance->header.file_data_size - bytes_processed_so_far;
            size_t bytes_to_write = ((uint64_t)block_size < remaining_in_file) ? 
                                   (uint64_t)block_size : (size_t)remaining_in_file;

            pthread_mutex_lock(data->file_io_mutex);

            int64_t output_offset = (int64_t)(current_block_idx * block_size);
            if (instance->fseek64(data->output_file, output_offset, SEEK_SET) != 0) 
            {
                perror("\nWORKER: Error fseek64 on output file");
                pthread_mutex_unlock(data->file_io_mutex);
                goto cleanup_and_exit;
            }
            
            bool write_ok = (fwrite(plaintext, 1, bytes_to_write, data->output_file) == bytes_to_write);

            // OTTIMIZZAZIONE: Aggiorna statistiche dentro stesso mutex
            data->instance->worked_so_far += (block_size + tag_len);
            if (!flagnoeta)
                myavanzamentoby1sec(data->instance->worked_so_far, data->total_input_size,
                                   data->starttime, false);

            pthread_mutex_unlock(data->file_io_mutex);

            if (!write_ok) 
            {
                perror("\nWORKER: Error writing to output file");
                goto cleanup_and_exit;
            }
        }
        else
        {
            // Verify mode: solo aggiorna statistiche (niente I/O)
            if (!flagnoeta)
            {
                pthread_mutex_lock(data->file_io_mutex);
                data->instance->worked_so_far += (block_size + tag_len);
                myavanzamentoby1sec(data->instance->worked_so_far, data->total_input_size,
                                   data->starttime, false);
                pthread_mutex_unlock(data->file_io_mutex);
            }
        }
    }

    data->success = true;

cleanup_and_exit:
    if (flagmemzero)
    {
        instance->sodium.sodium_memzero(plaintext, block_size);
        instance->sodium.sodium_memzero(encrypted, block_size + tag_len);
        instance->sodium.sodium_memzero(block_nonce, nonce_len);
    }
    
    delete[] plaintext;
    delete[] encrypted;
    delete[] block_nonce;
    
    return NULL;
}

bool decrypt_to_buffer(char *out_buffer, size_t buffer_size) 
{
    if (!is_file_open || buffer_size < header.file_data_size) 
	    return false;
    
    size_t tag_len   		= sodium.crypto_aead_chacha20poly1305_ietf_abytes();
    size_t nonce_len 		= sodium.crypto_aead_chacha20poly1305_ietf_npubbytes();
    uint64_t total_blocks 	= (header.file_data_size + block_size - 1) / block_size;
    uint64_t bytes_written 	= 0;

    std::vector<unsigned char> encrypted(block_size + tag_len);
    std::vector<unsigned char> plaintext(block_size);

    for (uint64_t block_idx = 0; block_idx < total_blocks; ++block_idx) 
	{
        int64_t block_file_offset = get_block_file_offset(block_idx);
        if (fseek64(file_handle, block_file_offset, SEEK_SET) != 0) 
			return false;

        std::vector<unsigned char> block_nonce(nonce_len);
        if (fread(&block_nonce[0], 1, nonce_len, file_handle) != nonce_len) 
			return false;
        if (fread(&encrypted[0], 1, encrypted.size(), file_handle) != encrypted.size()) 
			return false;
        
        unsigned long long decrypted_len = 0;
        if (sodium.crypto_aead_chacha20poly1305_ietf_decrypt(
                &plaintext[0], &decrypted_len, NULL,
                &encrypted[0], encrypted.size(),
                NULL, 0, &block_nonce[0], key) != 0) 
				{
					myprintf("40021! Decryption of block #%s failed\n", migliaia(block_idx));
					if (flagmemzero) 
						sodium.sodium_memzero(plaintext.data(), plaintext.size());
					return false;
				}

        size_t remaining 	= header.file_data_size - bytes_written;
        size_t to_copy = ((size_t)remaining < (size_t)decrypted_len) ? 
                (size_t)remaining : (size_t)decrypted_len;
        memcpy(out_buffer + bytes_written, &plaintext[0], to_copy);
        bytes_written 		+= to_copy;
    }

    if (flagmemzero) 
		sodium.sodium_memzero(plaintext.data(), plaintext.size());
    return true;
}

}; // Fine classe franzcri

franzcri*	g_p_franzenfile			=0;
int64_t		g_franzen_jidacheader	=-1;

#endif ///NOSFTPEND









// Write nobj objects of size size from ptr to fp. Return number written.
// "overloaded" from fwrite() for flagfasttxt
size_t myfwrite(const void* ptr, size_t size, size_t nobj, FP fp)
{
	if (fp==0)
	{
		if (flagdebug3)
			myprintf("00099! FP NOT POSITIVE\n");
		return 0;
	}
	if ((nobj*size)==0)
		return 0;
	
/*
	char mynomefile[100];
	uint32_t crc=crc32_16bytes(ptr,nobj*size);

	if ((fp==g_fp_zpaq) || (g_fp_zpaq==0))
		snprintf(mynomefile,sizeof(mynomefile),"z:\\d_%08d_start_%11s_size_%7s_%08X",g_crc32_sequence_data,migliaia3(ftello(fp)),migliaia2(nobj*size),crc);
	else
		snprintf(mynomefile,sizeof(mynomefile),"z:\\i_%08d_start_%11s_size_%7s_%08X",g_crc32_sequence_index,migliaia3(ftello(fp)),migliaia2(nobj*size));

	FILE* myfile=fopen(mynomefile, "wb");
	if (myfile==NULL)
	{
		myprintf("00100: cannot write on %s\n",mynomefile);
		exit(0);
	}
	fwrite(ptr,size*nobj,1,myfile);
	fclose(myfile);
*/

#ifdef _WIN32
	DWORD r=0;
	if (flagdebug3)
		myprintf("00101: WriteFile FP %s size %s nobj %s r= %08d FTELLO %s\n",migliaia(int64_t(fp)),migliaia3(int64_t(size)),migliaia4(int64_t(nobj)),r,migliaia2(ftello(fp)));

	if (r==104)
		myprintf("r 104 ftello %s PPPPPPPPPPPPPPPPPPPPPPPPPPPP\n",migliaia2(ftello(fp)));

	WriteFile(fp, ptr, size*nobj, &r, NULL);

#else
	size_t r=fwrite(ptr, size, nobj, fp);
#endif // corresponds to #ifdef (#ifdef _WIN32)
	g_fexpected+=(size*nobj);
	g_fwritten+=r;
	
#ifdef ZPAQFULL ///NOSFTPSTART
	if (g_p_franzenfile)
	{
		
		if (r==104)
		{
			if (flagdebug3)
				myprintf("r is %s g_franzen_jidacheader %s \n",migliaia(r),migliaia2(g_franzen_jidacheader));
		
			if (g_franzen_jidacheader>=0)
			{
				int64_t myoffsettino=g_franzen_jidacheader;
				if (g_password)
				{
					if (g_franzen_jidacheader==32)
						myoffsettino=32;
				}
				if (g_p_franzenfile->writeat(myoffsettino,(const char*)ptr,size*nobj))
				{
					if (flagdebug3)
						myprintf("111111111111111 fatto writeat del jidacheader %s myoffsettino %s di %d\n",
					migliaia(g_franzen_jidacheader),migliaia2(myoffsettino),size*nobj);
					
				}
			}
			else
				myprintf("34912: skippo 104 su ((((((((((-------)))))))))) franzenfile\n");
		}
		else
		{
			if (g_p_franzenfile->write((const char*)ptr,size*nobj))
			{
				if (flagdebug3)
					myprintf("31679: writted on franzenfile %21s %21s\n",migliaia(size*nobj),migliaia(int64_t(g_p_franzenfile)));
			}
		}
	}
#endif ///NOSFTPEND	
	
	
	if (flagfasttxt || flagbackupzeta)
	{
		if ((fp==g_fp_zpaq) || (g_fp_zpaq==0))
		{
			if (flagdebug3)
			{
				myprintf("00102: fwrite |%08d| pos %9s g_hep %s r=|%d| ",int(g_crc32_sequence_data),migliaia(ftello(fp)),migliaia2(g_header_pos),r);
				myprintf("00103: g_crc_get_header %d\n",int(g_crc_getheader));
			}

			if (g_crc32_sequence_data==0) // this is the header of an encrypted piece
			{
				if (r==32)
				{
					g_crc_header=crc32_16bytes(ptr,r);
					if (flagdebug3)
						myprintf("00104: HEADER  r=%08d %08X\n",r,g_crc_header);
					
					g_franzhash_file.add(ptr,r);
					g_franzhash_file_bytes+=r;
					if (flagdebug3)
						myprintf("00106$ FRANZ-HEADER  r=%08d %s\n",r,bin2hex_64(g_franzhash_file.hash()).c_str());
				}
				else
				{
					uint32_t crc=0;
					crc=crc32_16bytes((char*)ptr+104,r-104);
					g_crc_body=crc32_combine(g_crc_body,crc,r-104);
					if (flagdebug3)
						myprintf(" SKIPPOZ 104 [1] ");
					g_veryfirst=false;

					g_franzhash_file.add((char*)ptr+104,r-104);
					g_franzhash_file_bytes+=r-104;
					if (flagdebug3)
						myprintf("00101$ FRANZ-SKIPPO 104 [1]  r=%08d %s\n",r-104,bin2hex_64(g_franzhash_file.hash()).c_str());

				}
			}
			else
			{
				if (r==104)
				{
					g_crc_jidac=crc32_16bytes(ptr,r);
					if (flagdebug3)
						myprintf("00105: JIDAC r=%08d %08X\n",r,g_crc_jidac);
					memcpy(g_franzhash_104,ptr,r);
				}
				else
				{
					uint32_t crc=0;
					if (g_veryfirst)
					{
						if (flagdebug3)
							myprintf(" SKIPPO 104 [2] ");
						crc=crc32_16bytes((char*)ptr+104,r-104);
						g_crc_body=crc32_combine(g_crc_body,crc,r-104);
						g_veryfirst=false;
						
						g_franzhash_file.add((char*)ptr+104,r-104);
						g_franzhash_file_bytes+=r-104;
				
						if (flagdebug3)
							myprintf("00106$ FRANZ-SKIPPO 104 [2]  r=%08d %s\n",r-104,bin2hex_64(g_franzhash_file.hash()).c_str());
		
					}
					else
					{
						crc=crc32_16bytes(ptr,r);
						g_crc_body=crc32_combine(g_crc_body,crc,r);
						
						g_franzhash_file.add(ptr,r);
						g_franzhash_file_bytes+=r;
				
						if (flagdebug3)
							myprintf("00108$ FRANZ-BODY r=%08d %s\n",r,bin2hex_64(g_franzhash_file.hash()).c_str());
					}
					if (flagdebug3)
						myprintf("00106: BODY  %08X\n",g_crc_body);
				}
			}
			g_crc32_sequence_data++;
		}
		else
		{
			if (flagdebug2)
				myprintf("00107: Doing CRC-32 on index for bytes %s\n",migliaia(r));
			uint32_t crc	=crc32_16bytes(ptr,r);
			g_crc32_index	=crc32_combine(g_crc32_index,crc,r);
			g_crc32_sequence_index++;
		}
	}
	

  if (flagdebug)
		if ((size*nobj)!=r)
			myprintf("00108! expected bytes != written (media full?)  %s vs  %s\n",migliaia((int64_t)(size*nobj)),migliaia2((int64_t)r));
  if (size>1) r/=size;
  
  
	if (flagdebug3)
		myprintf("34097: fwrite %s\n",migliaia(r));
	


  return r;
}











// a bit different: check only for "real" files
bool realfileexists(const string& i_filename)
{
#ifdef unix
  struct stat buffer;
  if (stat(i_filename.c_str(),&buffer)==0)
	if (!S_ISDIR(buffer.st_mode))
		return true;
#endif // corresponds to #ifdef (#ifdef unix)
#ifdef _WIN32
	HANDLE	myhandle;
	WIN32_FIND_DATA findfiledata;
	std::wstring wpattern=utow(i_filename.c_str());
	myhandle=FindFirstFile(wpattern.c_str(),&findfiledata);
	if (myhandle!=INVALID_HANDLE_VALUE)
	{
		FindClose(myhandle);
		if (findfiledata.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
			return false;
		else
			return true;
	}
#endif // corresponds to #ifdef (#ifdef _WIN32)
	return false;
}
/// return size, date and attr
bool getfileinfo(string i_filename,int64_t& o_size,int64_t& o_date,int64_t& o_attr)
{
	o_size=0;
	o_date=0;
	o_attr=0;
#ifdef unix
	while (i_filename.size()>1 && i_filename[i_filename.size()-1]=='/')
		i_filename=i_filename.substr(0, i_filename.size()-1);
	struct stat sb;
	if (!lstat(i_filename.c_str(), &sb))
	{
		if (S_ISREG(sb.st_mode))
		{
			o_date=decimal_time(sb.st_mtime);
			o_size=sb.st_size;
			o_attr='u'+(sb.st_mode<<8);
			return true;
		}
	}
#endif // corresponds to #ifdef (#ifdef unix)
#ifdef _WIN32
	WIN32_FIND_DATA ffd;
	string t=i_filename;
	if (t.size()>0 && t[t.size()-1]=='/')
		t+="*";
	HANDLE h=FindFirstFile(utow(t.c_str()).c_str(), &ffd);
	if (h==INVALID_HANDLE_VALUE && GetLastError()!=ERROR_FILE_NOT_FOUND && GetLastError()!=ERROR_PATH_NOT_FOUND)
			printerr("getinfo",t.c_str(),0);
	if (h!=INVALID_HANDLE_VALUE)
	{
		SYSTEMTIME st;
		if (FileTimeToSystemTime(&ffd.ftLastWriteTime, &st))
			o_date=st.wYear*10000000000LL+st.wMonth*100000000LL+st.wDay*1000000
				+st.wHour*10000+st.wMinute*100+st.wSecond;
		o_size=ffd.nFileSizeLow+(int64_t(ffd.nFileSizeHigh)<<32);
		o_attr=ffd.dwFileAttributes;
		FindClose(h);
		return true;
    }
	FindClose(h);
#endif // corresponds to #ifdef (#ifdef _WIN32)
	return false;
}

bool getdirinfo(string i_folder,int64_t& o_date,int64_t& o_attr)
{
	o_date=0;
	o_attr=0;
	if (!isdirectory(i_folder))
	{
		myprintf("00111! This is not a folder <<%Z>>\n",i_folder.c_str());
		return false;
	}
#ifdef unix
	struct stat sb;
	if (!lstat(i_folder.c_str(), &sb))
		if (S_ISDIR(sb.st_mode))
		{
			/*
				time_t    st_atime;   // time of last access
				time_t    st_mtime;   // time of last modification
				time_t    st_ctime;   // time of last status change
			*/
			o_date=decimal_time(sb.st_mtime);
			o_attr='u'+(sb.st_mode<<8);
			return true;
		}
#endif // corresponds to #ifdef (#ifdef unix)
#ifdef _WIN32
	i_folder+="*.*";
	WIN32_FIND_DATA ffd;
	HANDLE h=FindFirstFile(utow(i_folder.c_str()).c_str(), &ffd);
	if (h==INVALID_HANDLE_VALUE)
	{
		myprintf("00113! INVALID_HANDLE for <<%s>>\n",i_folder.c_str());
		return false;
	}
	SYSTEMTIME st;
	if (FileTimeToSystemTime(&ffd.ftLastWriteTime, &st))
		o_date=st.wYear*10000000000LL+st.wMonth*100000000LL+st.wDay*1000000
			+st.wHour*10000+st.wMinute*100+st.wSecond;


/*
	if (FileTimeToSystemTime(&ffd.ftCreationTime, &st))
			creationdate=st.wYear*10000000000LL+st.wMonth*100000000LL+st.wDay*1000000
				+st.wHour*10000+st.wMinute*100+st.wSecond;
	if (FileTimeToSystemTime(&ffd.ftLastAccessTime, &st))
			accessdate=st.wYear*10000000000LL+st.wMonth*100000000LL+st.wDay*1000000
				+st.wHour*10000+st.wMinute*100+st.wSecond;
*/

	o_attr=ffd.dwFileAttributes;
	FindClose(h);
	return true;
#endif // corresponds to #ifdef (#ifdef _WIN32)
	return false;
}


bool delete_file_no_mercy(const char* filename) 
{
#ifdef unix
	return remove(filename)==0;
#else
	return DeleteFile(utow(filename).c_str());
#endif // corresponds to #ifdef (#ifdef unix)

}
bool delete_dir(const char* i_directory) {
#ifdef unix
  return remove(i_directory)==0;
#else
	SetFileAttributesW(utow(i_directory).c_str(),FILE_ATTRIBUTE_NORMAL);
  return RemoveDirectoryW(utow(i_directory).c_str());
#endif // corresponds to #ifdef (#ifdef unix)
}
/// risky command to make a rd folder /s (or rm -r)
#ifdef unix
int erredbarras(const std::string &i_path)
{
		bool 	risultato=false;
		DIR *d=opendir(i_path.c_str());
		if (d)
		{
			const struct dirent *p;
			risultato=true;
			while (risultato && (p=readdir(d)))
			{
				if (!strcmp(p->d_name, ".") || !strcmp(p->d_name, ".."))
					continue;
				bool risultato2=false;
				struct stat statbuf;
				std::string temp;
				if (isdirectory(i_path))
					temp=i_path+p->d_name;
				else
					temp=i_path+"/"+p->d_name;
				if (!stat(temp.c_str(), &statbuf))
				{
					if (S_ISDIR(statbuf.st_mode))
						risultato2=erredbarras(temp);
					else
					{
						if (flagdebug)
							myprintf("00114: delete file %s\n",temp.c_str());
						risultato2=delete_file(temp.c_str());
					}
				}
				risultato=risultato2;
			}
			closedir(d);
		}
		if (risultato)
		{
			if (flagdebug)
				myprintf("00115: delete dir  %s\n\n",i_path.c_str());
			delete_dir(i_path.c_str());
		}
	   return risultato;
}
#endif // corresponds to #ifdef (#ifdef unix)
bool stermina(string i_path,int32_t i_expectedfile=0)
{
	if (i_path=="")
		return false;
	if (flagdebug2)
		myprintf("00116: PRE  ------------------ %s ----------\n",i_path.c_str());
#ifdef _WIN32
	if (flaglongpath)
		if (iswindowspath(i_path))
			if (!islongpath(i_path))
				i_path="//?/"+i_path;
#endif // corresponds to #ifdef (#ifdef _WIN32)
	if (isdirectory(i_path))
		i_path=i_path.substr(0, i_path.size()-1);
	if (flagdebug2)
		myprintf("00117: POST ------------------ %s ----------\n",i_path.c_str());
	g_rd=0; // global file counter for huge dirs on slow media
	g_rd_expected=i_expectedfile;
	g_startrd=mtime();
	g_rd_ultimotempo=0;
#ifdef _WIN32
		erredbarras(utow(i_path.c_str()));
#else
	erredbarras(i_path);
#endif // corresponds to #ifdef (#ifdef _WIN32)
	return (!direxists(i_path));
}

string forbiddenstring[] = {"CON","PRN","AUX","NUL","COM1","COM2","COM3","COM4","COM5","COM6","COM7","COM8","COM9","LPT1","LPT2","LPT3","LPT4","LPT5","LPT6","LPT7","LPT8","LPT9"};
size_t forbiddenstringsize = sizeof(forbiddenstring)/sizeof(forbiddenstring[0]);
char forbiddenchar[] = {'<','>','"','|','?','*'};
size_t forbiddencharsize = sizeof(forbiddenchar)/sizeof(forbiddenchar[0]);
bool isreserved(const string& i_filename,string& o_fixed)
{
	o_fixed=i_filename;
	bool risultato=false;
#ifdef _WIN32
		bool isfolder=isdirectory(i_filename);
		vector<string> pezzi;
		explode(i_filename,'/',pezzi);
		for (unsigned int i=0;i<pezzi.size();i++)
		{
			string porzione=stringtoupper(pezzi[i]);
			for (unsigned int j=0;j<forbiddenstringsize;j++)
				if ((porzione==forbiddenstring[j]) || (mypos(forbiddenstring[j]+".",porzione)==0))
				{
					pezzi[i]="_"+pezzi[i];
					risultato=true;
				}
		}
		if (risultato)
		{
			o_fixed="";
			for (unsigned int i=0;i<pezzi.size();i++)
				o_fixed=o_fixed+pezzi[i]+'/';
			if (!isfolder)
				o_fixed=myleft(o_fixed,o_fixed.length()-1);
		}
		for (unsigned int i=0;i<o_fixed.size();i++)
			for (unsigned int j=0;j<forbiddencharsize;j++)
				if (o_fixed[i]==forbiddenchar[j])
				{
					o_fixed[i]='_';
					risultato=true;
				}
		if (risultato)
			o_fixed=nomefileseesistegia(o_fixed);
#endif // corresponds to #ifdef (#ifdef _WIN32)
	return risultato;
}
#ifdef _WIN32
string linuxtowinpath(const string& i_path)
{
	string risultato=i_path;
	myreplaceall(risultato,"/","\\");
	return risultato;
}
#endif // corresponds to #ifdef (#ifdef _WIN32)

#ifdef ZPAQFULL ///NOSFTPSTART
void xcommand(string i_command,string i_parameter)
{
	if (flagdebug2)
	{
		myprintf("00118: Entering xcommand()\n");
		myprintf("00119: i_command   |%s|\n",i_command.c_str());
		myprintf("00120: i_parameter |%s|\n",i_parameter.c_str());
	}
	if (i_command=="")
	{
		if (flagdebug)
			myprintf("00121: Exit because empty i_command\n");
		return;
	}
	if (!fileexists(i_command))
	{
		if (flagdebug)
			myprintf("00122! Exit because not fileexists  |%s|\n",i_command.c_str());
		return;
	}
	int dummy;
#if defined (_WIN32)
	if (flagdebug3)
			myprintf("00123: WIN32: Replacing before |%s|\n",i_command.c_str());
	myreplaceall(i_command,"/","\\");
	if (flagdebug3)
			myprintf("00124: WIN32: After            |%s|\n",i_command.c_str());
#endif // corresponds to #if (#if defined (_WIN32))
	string mycommand="";
	if (i_parameter=="")
	{
		if (flagdebug)
				myprintf("00125! i_parameter is empty\n");
#if defined (_WIN32)
		if (flagdebug3)
			myprintf("00126: On Windows insert double-double quote for cmd /c\n");
		mycommand="\"\""+i_command+"\""+"\"";
#else
		if (flagdebug3)
			myprintf("00127: On *unix insert single double quote\n");
		mycommand="\""+i_command+"\"";
#endif // corresponds to #if (#if defined (_WIN32))
	}
	else
	{
		if (flagdebug2)
			myprintf("00128: i_parameter is NOT empty\n");
#if defined (_WIN32)
		if (flagdebug3)
			myprintf("00129: On Windows insert double-double quote\n");
		mycommand="\"\""+i_command+"\""+" \""+i_parameter+"\"\"";
#else
		if (flagdebug3)
			myprintf("00130: On *unix insert single double quote for cmd /c\n");
		mycommand="\""+i_command+"\""+" \""+i_parameter+"\"";
#endif // corresponds to #if (#if defined (_WIN32))
	}
	if (flagdebug)
		myprintf("00131: Do system on mycommand |%s|\n",mycommand.c_str());
	dummy=system(mycommand.c_str());
	if (dummy==888888)
		myprintf("00132: no-warning-please\n");
}
#endif ///NOSFTPEND
#if defined(_WIN32)
bool win32_writeads_buffer(string i_filename,string i_adsname,unsigned char* i_buffer,int i_len)
{
	if (i_filename=="")
	{
		myprintf("00133! cannot ADS on ''\n");
		return false;
	}
	if (i_adsname=="")
	{
		myprintf("00134! ADS cannot be empty\n");
		return false;
	}
	if (i_buffer==NULL)
	{
		myprintf("00135! ADS payload empty\n");
		return false;
	}
	if (i_len<=0)
	{
		myprintf("00136! len <=0\n");
		return false;
	}
	string thepath=i_filename+":"+i_adsname;
	HANDLE hFile = CreateFileW((utow(thepath.c_str()).c_str()), GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
	if (hFile==INVALID_HANDLE_VALUE)
	{
		myprintf("00137! invalid file handle on %Z\n",i_filename.c_str());
		return false;
	}
	DWORD bw;
	if (WriteFile(hFile,i_buffer,i_len,&bw,NULL))
	{
		CloseHandle(hFile);
		return true;
	}
	CloseHandle(hFile);
	return false;
}
bool win32_writeads(string i_filename,string i_adsname,string i_thepayload)
{
	if (i_filename=="")
	{
		myprintf("00139! cannot ADS on ''\n");
		return false;
	}
	if (i_adsname=="")
	{
		myprintf("00140! ADS cannot be empty\n");
		return false;
	}
	if (i_thepayload=="")
	{
		myprintf("00141! ADS payload empty\n");
		return false;
	}
	if  (i_thepayload.size()>4096)
	{
		myprintf("00142! payload too big (>4KB)\n");
		return false;
	}
	string thepath=i_filename+":"+i_adsname;
	HANDLE hFile = CreateFileW((utow(thepath.c_str()).c_str()), GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
	if (hFile==INVALID_HANDLE_VALUE)
	{
		myprintf("00143! invalid file handle on %Z\n",i_filename.c_str());
		return false;
	}
	DWORD bw;
	if (WriteFile(hFile,i_thepayload.c_str(),i_thepayload.size(),&bw,NULL))
	{
		CloseHandle(hFile);
		return true;
	}
	CloseHandle(hFile);
	return false;
}
bool win32_readads(string i_filename,string i_adsname,string& o_thepayload)
{
	if (i_filename=="")
	{
		myprintf("00145! cannot ADS on ''\n");
		return false;
	}
	if (i_adsname=="")
	{
		myprintf("00146! ADS cannot be empty\n");
		return false;
	}
	o_thepayload="";
	string thepath=i_filename+":"+i_adsname;
	HANDLE hFile = CreateFileW((utow(thepath.c_str()).c_str()), GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
	if (hFile==INVALID_HANDLE_VALUE)
	{
		myprintf("00147! invalid file handle on %Z\n",i_filename.c_str());
		return false;
	}
	unsigned char buffer[4096]={0};
	DWORD br;
	if (ReadFile(hFile,buffer,sizeof(buffer),&br,NULL))
	{
		string temp((char*)buffer);
		o_thepayload=temp;
		CloseHandle(hFile);
		return true;
	}
	CloseHandle(hFile);
	return false;
}
bool win32_readads_sb(string i_filename,string i_adsname,StringBuffer* o_stringbuffer)
{
	if (i_filename=="")
	{
		myprintf("00149! cannot ADS on ''\n");
		return false;
	}
	if (i_adsname=="")
	{
		myprintf("00150! ADS cannot be empty\n");
		return false;
	}
	if (o_stringbuffer==NULL)
	{
		myprintf("00151! stringbuffer null\n");
		return false;
	}
	
	string thepath=i_filename+":"+i_adsname;
	HANDLE hFile = CreateFileW((utow(thepath.c_str()).c_str()), GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
	if (hFile==INVALID_HANDLE_VALUE)
	{
		myprintf("00152! invalid file handle on %Z\n",i_filename.c_str());
		return false;
	}
	unsigned char buffer[4096]={0};
	DWORD br;
	
	while (ReadFile(hFile,buffer,sizeof(buffer),&br,NULL))
	{
		///myprintf("00154: chunkino %s\n",migliaia(br));
		if (br==0)
			break;
		(*o_stringbuffer).write((const char*)buffer,br);
	}
	
	CloseHandle(hFile);
	return true;
}

#ifdef ZPAQFULL ///NOSFTPSTART
/// something to get VSS done via batch file
void waitexecute(string i_filename,string i_parameters,int i_show)
{
	SHELLEXECUTEINFOA ShExecInfo =SHELLEXECUTEINFOA();
	ShExecInfo.cbSize = sizeof(SHELLEXECUTEINFOA);
	ShExecInfo.fMask = SEE_MASK_NOCLOSEPROCESS;
	ShExecInfo.hwnd = NULL;
	ShExecInfo.lpVerb = NULL;
	ShExecInfo.lpFile = i_filename.c_str();
	ShExecInfo.lpParameters = i_parameters.c_str();
	ShExecInfo.lpDirectory = NULL;
	ShExecInfo.nShow = i_show;
	ShExecInfo.hInstApp = NULL;
	ShellExecuteExA(&ShExecInfo);
	WaitForSingleObject(ShExecInfo.hProcess, INFINITE);
	CloseHandle(ShExecInfo.hProcess);
}


void waitexecutepadre(const std::string& i_filename, const std::string& i_parameters) 
{
    SECURITY_ATTRIBUTES saAttr;
    saAttr.nLength = sizeof(SECURITY_ATTRIBUTES);
    saAttr.bInheritHandle = TRUE;
    saAttr.lpSecurityDescriptor = NULL;

    // Create pipe for output
    HANDLE hChildStdoutRd, hChildStdoutWr;
    if (!CreatePipe(&hChildStdoutRd, &hChildStdoutWr, &saAttr, 0)) 
        return;

    // Ensure that the write handle is not inherited
    SetHandleInformation(hChildStdoutRd, HANDLE_FLAG_INHERIT, 0);

    STARTUPINFOA si;
    PROCESS_INFORMATION pi;
    ZeroMemory(&si, sizeof(si));
    si.cb = sizeof(si);
    si.hStdError = hChildStdoutWr;
    si.hStdOutput = hChildStdoutWr;
    si.dwFlags |= STARTF_USESTDHANDLES;
    ZeroMemory(&pi, sizeof(pi));

    std::string cmdLine = "\"" + i_filename + "\" " + i_parameters;

    // Create the process
    if (!CreateProcessA(
        NULL,               // No module name (use command line)
        const_cast<LPSTR>(cmdLine.c_str()),  // Command line
        NULL,               // Process handle not inheritable
        NULL,               // Thread handle not inheritable
        TRUE,               // Set handle inheritance to TRUE
        0,                  // No creation flags
        NULL,               // Use parent's environment block
        NULL,               // Use parent's starting directory 
        &si,                // Pointer to STARTUPINFO structure
        &pi)                // Pointer to PROCESS_INFORMATION structure
    ) 
	{
        CloseHandle(hChildStdoutWr);
        CloseHandle(hChildStdoutRd);
        return;
    }

    CloseHandle(hChildStdoutWr);

    // Read the output
    char buffer[4096];
    DWORD bytesRead;
    while (ReadFile(hChildStdoutRd, buffer, sizeof(buffer) - 1, &bytesRead, NULL) && bytesRead != 0) 
	{
        buffer[bytesRead] = '\0';  // Null-terminate
        WriteConsoleA(GetStdHandle(STD_OUTPUT_HANDLE), buffer, bytesRead, NULL, NULL);
    }
    // Wait for the process to terminate
    WaitForSingleObject(pi.hProcess, INFINITE);
    CloseHandle(pi.hProcess);
    CloseHandle(pi.hThread);
    CloseHandle(hChildStdoutRd);
}
#endif ///NOSFTPEND


bool isadmin()
{
	BOOL fIsElevated = FALSE;
	HANDLE hToken = NULL;
	TOKEN_ELEVATION elevation;
	DWORD dwSize;
	if (!OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &hToken))
	{
		myprintf("\n");
		myprintf("00155! Failed to get Process Token\n");
		goto Cleanup; /// yessss!!! the migthy GOTO!!!!
	}
	if (!GetTokenInformation(hToken, TokenElevation, &elevation, sizeof(elevation), &dwSize))
	{
		myprintf("\n");
		myprintf("00156! Failed to get Token Information\n");
		goto Cleanup;
	}
	fIsElevated = elevation.TokenIsElevated;
Cleanup:
	if (hToken)
	{
		CloseHandle(hToken);
		hToken = NULL;
	}
	return fIsElevated;
}

#endif // corresponds to #if (#if defined(_WIN32))
// Return true if a file or directory (UTF-8 without trailing /) exists.
bool exists(string filename) {
  int len=filename.size();
  if (len<1) return false;
  if (filename[len-1]=='/') filename=filename.substr(0, len-1);
#ifdef unix
  struct stat sb;
  return !lstat(filename.c_str(), &sb);
#else
  return GetFileAttributes(utow(filename.c_str()).c_str())
         !=INVALID_FILE_ATTRIBUTES;
#endif // corresponds to #ifdef (#ifdef unix)
}
#ifdef _WIN32
bool wintouch(string i_filename, int64_t i_date, int64_t i_creationdate)
{
	if ((i_creationdate==0) && (i_date==0))
		return true;
	if (i_filename=="")
		return false;
	if (strstr(i_filename.c_str(), ":$DATA")!=0)
		return true;

	FP fp=CreateFile(utow(i_filename.c_str()).c_str(),
                    FILE_WRITE_ATTRIBUTES,
                    FILE_SHARE_READ|FILE_SHARE_WRITE|FILE_SHARE_DELETE,
                    NULL, OPEN_EXISTING, FILE_FLAG_BACKUP_SEMANTICS, NULL);
	if (fp==FPNULL)
	{
		myprintf("00157! WARN cannot open %Z\n",i_filename.c_str());
		return false;
	}

	if (i_date>0)
	{
		SYSTEMTIME st;
		st.wYear			=i_date/10000000000LL%10000;
		st.wMonth			=i_date/100000000%100;
		st.wDayOfWeek		=0;  // ignored
		st.wDay				=i_date/1000000%100;
		st.wHour			=i_date/10000%100;
		st.wMinute			=i_date/100%100;
		st.wSecond			=i_date%100;
		st.wMilliseconds	=0;
		FILETIME ft;
		SystemTimeToFileTime(&st, &ft);
		if (!SetFileTime(fp, NULL, NULL, &ft))
		{
			myprintf("00159! WARN cannot set filetime (error %s) on %Z\n",migliaia((int64_t)GetLastError()),i_filename.c_str());
			CloseHandle(fp);
			return false;
		}
	}

	if (i_creationdate>0)
	{
		SYSTEMTIME creation_st;
		creation_st.wYear			=i_creationdate/10000000000LL%10000;
		creation_st.wMonth			=i_creationdate/100000000%100;
		creation_st.wDayOfWeek		=0;  // ignored
		creation_st.wDay			=i_creationdate/1000000%100;
		creation_st.wHour			=i_creationdate/10000%100;
		creation_st.wMinute			=i_creationdate/100%100;
		creation_st.wSecond			=i_creationdate%100;
		creation_st.wMilliseconds	=0;
		FILETIME creation_ft;
		SystemTimeToFileTime(&creation_st, &creation_ft);

		if (!SetFileTime(fp, &creation_ft, NULL, NULL))
		{
			myprintf("00161! WARN cannot set creation/filetime (error %s) on %Z\n",migliaia((int64_t)GetLastError()),i_filename.c_str());
			CloseHandle(fp);
			return false;
		}
	}


	CloseHandle(fp);
	return true;
}
#endif // corresponds to #ifdef (#ifdef _WIN32)

// Close fp if open. Set date and attributes unless 0
bool close(const char* filename, int64_t date, int64_t attr, FP fp=FPNULL) {
  assert(filename);
  if (fp==stdout)
	  return true;
#ifdef unix
  if (fp!=FPNULL) myfclose(&fp);
  if (date>0) {
    struct utimbuf ub;
    ub.actime=time(NULL);
    ub.modtime=unix_time(date);
    utime(filename, &ub);
  }
  if ((attr&255)=='u')
    chmod(filename, attr>>8); ///(CWE-362). Use fchmod( ) instead.
	return true;
#else
	const bool ads=strstr(filename, ":$DATA")!=0;  // alternate data stream?
	bool allok=true;
	if (date>0 && !ads)
	{
		if (fp==FPNULL)		// Windows require HANDLE
			fp=CreateFile(utow(filename).c_str(),
                    FILE_WRITE_ATTRIBUTES,
                    FILE_SHARE_READ|FILE_SHARE_WRITE|FILE_SHARE_DELETE,
                    NULL, OPEN_EXISTING, FILE_FLAG_BACKUP_SEMANTICS, NULL);
		if (fp!=FPNULL)
		{
			SYSTEMTIME st;
			st.wYear=date/10000000000LL%10000;
			st.wMonth=date/100000000%100;
			st.wDayOfWeek=0;  // ignored
			st.wDay=date/1000000%100;
			st.wHour=date/10000%100;
			st.wMinute=date/100%100;
			st.wSecond=date%100;
			st.wMilliseconds=0;
			FILETIME ft;
			SystemTimeToFileTime(&st, &ft);
			if (!SetFileTime(fp, NULL, NULL, &ft))
			{
				myprintf("00163! WARN cannot set filetime (error %s) on %Z\n",migliaia((int64_t)GetLastError()),filename);
				allok=false;
			}
		}
	}
	if (fp!=FPNULL)
		CloseHandle(fp);
	if ((attr&255)=='w' && !ads)
		if (fileexists(filename))
		if (!SetFileAttributes(utow(filename).c_str(), attr>>8))
		{
#ifdef _WIN32
		DWORD err=GetLastError();
#else
		int err=1;
#endif // corresponds to #ifdef (#ifdef _WIN32)
			myprintf("00165! WARN kind %s cannot set attributes on %Z\n",migliaia((int64_t)err),filename);
			allok=false;
		}
	return allok;
#endif // corresponds to #ifdef (#ifdef unix)
}

bool filetouchnow(const char* filename)
{
	if (filename==NULL)
		return true;
#ifdef unix
/*
	int64_t date=now();
#if (!defined(SOLARIS))
	
	struct timeval times[2];
	time_t nowz;
	time(&nowz);
	const struct tm *local = localtime(&nowz);
	if (local == NULL) 
	{
		myprintf("47034! guru on tm (3)\n");
	} 
	else 
	{
		times[0].tv_sec = unix_time(date) - local->tm_gmtoff;  // atime
		times[0].tv_usec = 0;
		times[1].tv_sec = unix_time(date) - local->tm_gmtoff;  // mtime 
		times[1].tv_usec = 0;
		if (futimes(fileno(fp), times) != 0) 
			myprintf("47043! WARN Linux tocca_now futimes error!\n");
	}
#endif
*/
	return true;
#else
	bool allok=true;
	if (strstr(filename,":$DATA")==0)
	{
		FP fp=CreateFile(utow(filename).c_str(),
                    FILE_WRITE_ATTRIBUTES,
                    FILE_SHARE_READ|FILE_SHARE_WRITE|FILE_SHARE_DELETE,
                    NULL, OPEN_EXISTING, FILE_FLAG_BACKUP_SEMANTICS, NULL);
		if (fp!=FPNULL)
		{
			SYSTEMTIME st;
			GetLocalTime(&st);
			FILETIME ft,ftutc;
			SystemTimeToFileTime(&st, &ft);
			LocalFileTimeToFileTime(&ft, &ftutc);
			if (!SetFileTime(fp, NULL, NULL, &ftutc))
				myprintf("48725! WARN WIN filetouchnow set filetime (error %s) su fp %s\n",migliaia((int64_t)GetLastError()),migliaia2(int64_t(fp)));
			CloseHandle(fp);
		}
	}
	return allok;
#endif // corresponds to #ifdef (#ifdef unix)
	return true;
}

bool touch(const char* filename, int64_t date, int64_t attr)
{
	if (filename==NULL)
		return true;
#ifdef unix
	if (date>0)
	{
		struct utimbuf ub;
		ub.actime=time(NULL);
		ub.modtime=unix_time(date);
		utime(filename, &ub);
	}
	if (attr!=-1)
		if ((attr&255)=='u')
			chmod(filename, attr>>8);
	return true;
#else
	bool allok=true;
	if (strstr(filename,":$DATA")==0)
	{
		FP fp=CreateFile(utow(filename).c_str(),
                    FILE_WRITE_ATTRIBUTES,
                    FILE_SHARE_READ|FILE_SHARE_WRITE|FILE_SHARE_DELETE,
                    NULL, OPEN_EXISTING, FILE_FLAG_BACKUP_SEMANTICS, NULL);
		if (fp!=FPNULL)
		{
			SYSTEMTIME st;
			st.wYear			=date/10000000000LL%10000;
			st.wMonth			=date/100000000%100;
			st.wDayOfWeek		=0;  // ignored
			st.wDay				=date/1000000%100;
			st.wHour			=date/10000%100;
			st.wMinute			=date/100%100;
			st.wSecond			=date%100;
			st.wMilliseconds	=0;
			FILETIME ft;
			SystemTimeToFileTime(&st, &ft);
			if (!SetFileTime(fp, NULL, NULL, &ft))
			{
				myprintf("00167! WARN cannot set filetime (error %s) on %Z\n",migliaia((int64_t)GetLastError()),filename);
				allok=false;
			}
			CloseHandle(fp);
			if (attr!=-1)
				if (!SetFileAttributes(utow(filename).c_str(), attr>>8))
				{
					myprintf("00169! WARN kind %s cannot set attributes on %Z\n",migliaia((int64_t)GetLastError()),filename);
					allok=false;
				}
		}
	}
	return allok;
#endif // corresponds to #ifdef (#ifdef unix)
	return true;
}

string excludetrailingbackslash(string i_dir)
{
	if (i_dir=="")
		return "";
	if ((i_dir[i_dir.size()-1]=='\\') || (i_dir[i_dir.size()-1]=='/'))
		 return i_dir.substr(0,i_dir.size()-1);
	return "";
}

// Create directories as needed. For example if path="/tmp/foo/bar"
// then create directories /, /tmp, and /tmp/foo unless they exist.
// Set date and attributes if not 0.
void makepath(string path, int64_t date=0, int64_t attr=0) {
  for (unsigned i=0; i<path.size(); ++i) {
    if (path[i]=='\\' || path[i]=='/') {
      path[i]=0;	//very dirty trick
#ifdef unix
      mkdir(path.c_str(), 0777);
#else
      CreateDirectory(utow(path.c_str()).c_str(), 0);
#endif // corresponds to #ifdef (#ifdef unix)
      path[i]='/';
    }
  }

  // Set date and attributes
  string filename=path;
  if (filename!="" && filename[filename.size()-1]=='/')
    filename=filename.substr(0, filename.size()-1);  // remove trailing slash
  close(filename.c_str(), date, attr);
}
#ifndef unix
// Truncate filename to length. Return -1 if error, else 0.
int truncate(const char* filename, int64_t length) {
  std::wstring w=utow(filename);
  HANDLE out=CreateFile(w.c_str(), GENERIC_READ | GENERIC_WRITE,
                        0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
  if (out!=INVALID_HANDLE_VALUE) {
    //// LONG
	long hi=length>>32;
    if (SetFilePointer(out, length, &hi, FILE_BEGIN)
             !=INVALID_SET_FILE_POINTER
        && SetEndOfFile(out)
        && CloseHandle(out))
      return 0;
  }
  return -1;
}
#endif // corresponds to #ifndef (#ifndef unix)
bool saggiascrivibilitacartella(string i_cartella)
{
	if (i_cartella=="")
	{
		if (flagdebug)
			myprintf("00171! empty folder to be checked\n");
		return false;
	}
	if (flagdebug3)
		myprintf("00172: i_cartella %s\n",i_cartella.c_str());
	i_cartella=extractfilepath(i_cartella);
	if (flagdebug3)
		myprintf("00173: i_cartella %s\n",i_cartella.c_str());
	if (!isdirectory(i_cartella))
			i_cartella+="/";
	if (flagdebug3)
		myprintf("00174: Folder %s\n",i_cartella.c_str());
	string	percorso=extractfilepath(i_cartella);
	if (flagdebug2)
		myprintf("00175: Percorso %s\n",percorso.c_str());
	if  (percorso=="")
	{
		if (flagdebug)
			myprintf("00176: percorso empty\n");
		return false;
	}
	if (flagdebug3)
		myprintf("00177: makepath of |%s|\n",percorso.c_str());
	makepath(percorso);
	string	testfile;
	testfile=percorso+"test$$$.txt.me";
	if (flagdebug3)
		myprintf("00178: TEST FILE PRE  <<%s>>\n",testfile.c_str());
	testfile=nomefileseesistegia(testfile);
	if (flagdebug2)
	myprintf("00179: TEST FILE POST <<%s>>\n",testfile.c_str());
	FILE* testbyte=fopen(testfile.c_str(), "wb");
	if (testbyte!=NULL)
	{
		fprintf(testbyte,"this-file-can-be-deleted");
		fclose(testbyte);
	}
	bool risultato=fileexists(testfile);
	delete_file(testfile.c_str());
	return risultato;
}

#ifdef _WIN32
string g_realtemp()
{
	string temppath="";
	wchar_t charpath[MAX_PATH];
	if (GetTempPathW(MAX_PATH, charpath))
	{
		wstring ws(charpath);
		string str(ws.begin(), ws.end());
		return str;
	}
	return temppath;
}
#endif // corresponds to #ifdef (#ifdef _WIN32)

#ifdef ZPAQFULL ///NOSFTPSTART

string g_gettempdirectory()
{
#if defined(_WIN32) || defined(_WIN64)
	string temppath="";
	wchar_t charpath[MAX_PATH];
	if (GetTempPathW(MAX_PATH, charpath))
	{
		wstring ws(charpath);
		string str(ws.begin(), ws.end());
		string randomfolder=str+"_zpaqfranz\\"+std::to_string(g_start)+'\\';
		myreplaceall(randomfolder,"\\","/");
		if (flagdebug3)
			myprintf("00180: ********************** randomfolder [1] |%s|\n",randomfolder.c_str());
	///	randomfolder="y:/";
		if (!saggiascrivibilitacartella(randomfolder))
		{
			myprintf("00181! Guru, cannot write inside randomfolder %s\n",randomfolder.c_str());
			seppuku();
		}
		
		return randomfolder;
	}
	return temppath;
#else
	
#if defined(ESX) || defined(ANCIENT)
	string randomfolder="/tmp/_zpaqfranz/";
#else

	///string temporaneo=migliaia(mtime());
///	string randomfolder="/tmp/_zpaqfranz/"+temporaneo+'/';
	string randomfolder="/tmp/_zpaqfranz/"+std::to_string(mtime())+'/';
#endif // corresponds to #if (#if defined(ESX) || defined(ANCIENT))

	if (flagdebug3)
		myprintf("00182: LinuX ********************** randomfolder [1] |%s|\n",randomfolder.c_str());
	if (!saggiascrivibilitacartella(randomfolder))
	{
		myprintf("00183! Guru, cannot write inside randomfolder %s\n",randomfolder.c_str());
		seppuku();
	}

	return randomfolder;
#endif // corresponds to #if (#if defined(_WIN32) || defined(_WIN64))
}

#endif ///NOSFTPEND

/*
	some zpaq functions
*/

void remove_dir_if_empty(string i_path)
{
	if (i_path=="")
		return;
	if (i_path==".")
		return;
	if (i_path=="..")
		return;
#ifdef _WIN32
	i_path=linuxtowinpath(i_path);
	RemoveDirectoryW(utow(i_path.c_str()).c_str());
#else
	rmdir(i_path.c_str());
#endif // corresponds to #ifdef (#ifdef _WIN32)
}

void remove_temp_file(string i_thefile)
{
	if (i_thefile=="")
	{
		if (flagdebug3)
			myprintf("00184! temp file empty\n");
		return;
	}
	if (fileexists(i_thefile)==false)
	{
		if (flagdebug3)
			myprintf("00185! remove_temp_file not found %s\n",i_thefile.c_str());
		return;
	}
	string percorso=extractfilepath(i_thefile);
	if (flagdebug3)
		myprintf("00186: percorso %s\n",percorso.c_str());
	delete_file(i_thefile.c_str());
	remove_dir_if_empty(percorso);
}

#ifdef _WIN32
#ifdef ZPAQFULL ///NOSFTPSTART

//// VSS on Windows by... batchfile
//// delete all kind of shadows copies (if any)
void vss_deleteshadows(string i_cartella)
{
	if (flagvss)
	{
		i_cartella=linuxtowinpath(i_cartella);
		string	filebatch	=g_gettempdirectory()+"vsz.bat";
		filebatch=nomefileseesistegia(filebatch);
		print_datetime();
		myprintf("00187: VSS: starting release\n");
		if (fileexists(filebatch))
			if (remove(filebatch.c_str())!=0)
			{
				myprintf("00188! Highlander batch  %s\n", filebatch.c_str());
				return;
			}
		FILE* batch=fopen(filebatch.c_str(), "wb");
		if (batch==NULL)
		{
			myprintf("00189! cannot write on %s\n",filebatch.c_str());
			exit(0);
		}
		fprintf(batch,"@echo OFF\n");
		if (i_cartella!="")
			fprintf(batch,"rmdir %s\n",i_cartella.c_str());
		fprintf(batch,"@wmic shadowcopy delete /nointeractive\n");
		fclose(batch);
		waitexecute(filebatch,"",SW_HIDE);
		print_datetime();
		myprintf("00190: VSS: end releasing\n");
		remove_temp_file(filebatch);
	}
}
#endif ///NOSFTPEND
string relativetolongpath(string i_filename)
{
///https://googleprojectzero.blogspot.com/2016/02/the-definitive-guide-on-win32-to-nt.html
	if (i_filename=="")
		return "";
#ifdef _WIN32
	if (uint64_t len=GetFullPathNameW(utow(i_filename.c_str()).c_str(),0,0,0))
	{
		wchar_t* buf= (wchar_t*)franz_malloc((len)*sizeof(WCHAR));
		///g_allocatedram+=(len)*sizeof(WCHAR);
		if (buf==NULL)
		{
			myprintf("00191! guru in malloc\n");
			seppuku();
			return "";
		}
		uint64_t len2=GetFullPathNameW(utow(i_filename.c_str()).c_str(),len,buf,0);
		if (len2>0)
		{
			string risultato=wtou(buf);
			if (flagdebug || flagverbose)
			{
				myprintf("00192$ WARNING converted RELATIVE to FULL path |%Z| => |%Z|\n",i_filename.c_str(),risultato.c_str());
			}
			franz_free(buf);
			g_allocatedram-=(len)*sizeof(WCHAR);
	
			return risultato;
		}
	}
#endif // corresponds to #ifdef (#ifdef _WIN32)
	return i_filename;
}
#endif // corresponds to #ifdef (#ifdef _WIN32)

string getuname()
{
#ifdef _WIN64
	return "WIN64";
#endif // corresponds to #ifdef (#ifdef _WIN64)
#ifdef _WIN32
	return "WIN32";
#endif // corresponds to #ifdef (#ifdef _WIN32)
#ifdef unix
	struct utsname uts;
	int err=uname(&uts);
	if (err!=0)
	{
		myprintf("00194! getuname error %d\n", err);
		return "UNAME-ERROR";
	}
	if (flagdebug2)
	{
		myprintf("00195: sysname : %s\n",uts.sysname);
		myprintf("00196: nodename: %s\n",uts.nodename);
		myprintf("00197: release : %s\n",uts.release);
		myprintf("00198: version : %s\n",uts.version);
		myprintf("00199: machine : %s\n",uts.machine);
	}
	return uts.machine;
#endif // corresponds to #ifdef (#ifdef unix)
	return "";
}

// Guess number of cores. In 32 bit mode, max is 2.
int numberOfProcessors() 
{

#ifdef __HAIKU__
	system_info haikuinfo;
	get_system_info(&haikuinfo);
	return haikuinfo.cpu_count;
#endif // corresponds to #ifdef (#ifdef __HAIKU__)

#ifdef ESX
	return 1;
#endif // corresponds to #ifdef (#ifdef ESX)

  int rc=0;  // result
  
#ifdef SOLARIS
	if (flagdebug3)
		myprintf("41105: SOLARIS number of processors\n");
	if (flaght)
	{
	}
	else
	{
		/// decoding non-HT in SOLARIS is hard, sorry...
		kstat_ctl_t *kc;
		kstat_t *ksp;
		kstat_named_t *knp;
		int logical_cpu_count = 0;

		kc = kstat_open();
		if (kc == NULL) 
		{
			myprintf("41214! ktstat_open KAPUTT\n");
			return 1;
		}
		char cpu_info[] = "cpu_info";
		for (ksp = kc->kc_chain; ksp != NULL; ksp = ksp->ks_next) 
			if (strcmp(ksp->ks_module, cpu_info) == 0) 
				logical_cpu_count++;
		kstat_close(kc);
		
		rc=logical_cpu_count;
	}
#endif // corresponds to #ifdef (#ifdef SOLARIS)


#if (defined(__APPLE__))
	size_t len 			= sizeof(rc);
	if (sysctlbyname("hw.physicalcpu", &rc, &len, NULL, 0) < 0) 
	{
		myprintf("41210! hw.physicalcpu KAPUTT\n");
		return 1;
	}
#endif // corresponds to #if (#if (defined(__APPLE__)))

#ifdef BSD  // BSD or Mac OS/X
	size_t rclen=sizeof(rc);
	if (flaght)
	{
///OpenBSD fix
#ifdef HW_NCPUONLINE
		int mib[2]={CTL_HW, HW_NCPUONLINE};
#else
		int mib[2]={CTL_HW, HW_NCPU};
#endif // corresponds to #ifdef (#ifdef HW_NCPUONLINE)
		if (sysctl(mib, 2, &rc, &rclen, 0, 0)!=0)
			perror("sysctl");
	}
	else
	{
	
#if defined(__FreeBSD__) || defined(__OpenBSD__)
	#if defined(__FreeBSD__)
		if (sysctlbyname("hw.ncpu", &rc, &rclen, NULL, 0) < 0) 
		{
			myprintf("41220! hw.ncpu KAPUTT\n");
			return 1;
		}
	#endif // corresponds to #if (#if defined(__FreeBSD__))
	
	#if defined(__OpenBSD__)
		int mib[2]={CTL_HW, HW_NCPUONLINE};
		if (sysctl(mib, 2, &rc, &rclen, NULL, 0) < 0)
		{
			myprintf("41296! HW_NCPUONLINE (OPENBSD) KAPUTT\n");
			return 1;
		}
	#endif // corresponds to #if (#if defined(__OpenBSD__))

#endif // corresponds to #if (#if defined(__FreeBSD__) || defined(__OpenBSD__))

	}

#endif //BSD // corresponds to #ifdef (#ifdef BSD  // BSD or Mac OS/X)


#if defined(__linux__) 
	if (flaght)
	{
		  // Count lines of the form "processor\t: %d\n" in /proc/cpuinfo
		  // where %d is 0, 1, 2,..., rc-1
		  FILE *in=fopen("/proc/cpuinfo", "r");
		  if (!in) return 1;
		  std::string s;
		  int c;
		  while ((c=getc(in))!=EOF) {
			if (c>='A' && c<='Z') c+='a'-'A';  // convert to lowercase
			if (c>' ') s+=c;  // remove white space
			if (c=='\n') {  // end of line?
			  if (s.size()>10 && s.substr(0, 10)=="processor:") {
				c=atoi(s.c_str()+10);
				if (c==rc) ++rc;
			  }
			  s="";
			}
		  }
		  fclose(in);
	}
	else
	{
		FILE *cpuinfo = fopen("/proc/cpuinfo", "r");
		if (cpuinfo == NULL) 
		{
			myprintf("41229: /proc/cpuinfo KAPUTT\n");
			return 1;
		}

		char line[1024];
		int cpu_cores = 0;
		int siblings = 0;
		int logical_cores=0;

		while (fgets(line, sizeof(line), cpuinfo) != NULL) 
			if (strncmp(line, "processor", 9) == 0) 
				logical_cores++;
			else if (strncmp(line, "cpu cores", 9) == 0) 
				sscanf(line, "cpu cores : %d", &cpu_cores);
			else if (strncmp(line, "siblings", 8) == 0) 
				sscanf(line, "siblings : %d", &siblings);
		fclose(cpuinfo);

		rc=cpu_cores;
    
	}
#endif // corresponds to #if (#if defined(__linux__) )

#ifdef _WIN32
  // In Windows return %NUMBER_OF_PROCESSORS%

	if (flaght)
	{
		SYSTEM_INFO si= SYSTEM_INFO();
		GetSystemInfo(&si);
		rc=si.dwNumberOfProcessors;
	}
	else
	{
		
		int physical_cores 	= 0;
		///int logical_cores 	= 0;

		SYSTEM_INFO sysInfo;
		GetSystemInfo(&sysInfo);
		///logical_cores = sysInfo.dwNumberOfProcessors;

		DWORD length = 0;
		GetLogicalProcessorInformation(NULL, &length);
		if (length == 0) 
		{
			myprintf("41244! GetLogicalProcessorInformation KAPUTT\n");
			return 1;
		}

		PSYSTEM_LOGICAL_PROCESSOR_INFORMATION buffer = (PSYSTEM_LOGICAL_PROCESSOR_INFORMATION)malloc(length);
		if (buffer == NULL) 
		{
			myprintf("41251! malloc KAPUTT\n");
			return 1;
		}

		if (GetLogicalProcessorInformation(buffer, &length) == FALSE) 
		{
			myprintf("41257: GetLogical (2) kaputt!\n");
			free(buffer);
			return 1;
		}

		for (DWORD i = 0; i < length / sizeof(SYSTEM_LOGICAL_PROCESSOR_INFORMATION); i++) 
			if (buffer[i].Relationship == RelationProcessorCore)
				physical_cores++;

		free(buffer);
		rc=physical_cores;
	}
#endif // corresponds to #ifdef (#ifdef _WIN32)
  if (rc<1) rc=1; /// numero massimo core 32bit
  if (sizeof(char*)==4 && rc>2) rc=2;
  return rc;
}
// In Windows convert upper case to lower case.
inline int tolowerW(int c) {
#ifndef unix
  if (c>='A' && c<='Z') return c-'A'+'a';
#endif // corresponds to #ifndef (#ifndef unix)
  return c;
}
// Return true if strings a == b or a+"/" is a prefix of b
// or a ends in "/" and is a prefix of b.
// Match ? in a to any char in b.
// Match * in a to any string in b.
// In Windows, not case sensitive.
bool ispath(const char* a, const char* b) {
  for (; *a; ++a, ++b) {
    const int ca=tolowerW(*a);
    const int cb=tolowerW(*b);
    if (ca=='*') {
      while (true) {
        if (ispath(a+1, b)) return true;
        if (!*b) return false;
        ++b;
      }
    }
    else if (ca=='?') {
      if (*b==0) return false;
    }
    else if (ca==cb && ca=='/' && a[1]==0)
      return true;
    else if (ca!=cb)
      return false;
  }
  return *b==0 || *b=='/';
}
// Read 4 byte little-endian int and advance s
unsigned btoi(const char* &s) {
  s+=4;
  return (s[-4]&255)|((s[-3]&255)<<8)|((s[-2]&255)<<16)|((s[-1]&255)<<24);
}
// Read 8 byte little-endian int and advance s
int64_t btol(const char* &s) {
  uint64_t r=btoi(s);
  return r+(uint64_t(btoi(s))<<32);
}
// return a/b such that there is exactly one "/" in between, and
// in Windows, any drive letter in b the : is removed and there
// is a "/" after.
string append_path(string a, string b) {
  int na=a.size();
  int nb=b.size();
#ifndef unix
  if (nb>1 && b[1]==':') {  // remove : from drive letter
    if (nb>2 && b[2]!='/') b[1]='/';
    else b=b[0]+b.substr(2), --nb;
  }
#endif // corresponds to #ifndef (#ifndef unix)
  if (nb>0 && b[0]=='/') b=b.substr(1);
  if (na>0 && a[na-1]=='/') a=a.substr(0, na-1);
  return a+"/"+b;
}
bool	iswildcards(const string& i_string)
{
	bool 	stars=strstr(i_string.c_str(), "*")!=0;			// for debug reason no "collapse"
	bool 	questionmark=strstr(i_string.c_str(), "?")!=0;
	return 	stars+questionmark;
}
bool check_if_password(string i_filename)
{
	if (flagdebug)
		myprintf("00200: check_if_password of %s\n",i_filename.c_str());
	if (iswildcards(i_filename))
	{
		if (flagdebug2)
			myprintf("00201: wildcard detected, no password check\n");
		return	false;
	}
	if (!fileexists(i_filename))
		return false;
	FILE* inFile = freadopen(i_filename.c_str());
	if (inFile==NULL)
	{
#ifdef _WIN32
		DWORD err=GetLastError();
#else
		int err=1;
#endif // corresponds to #ifdef (#ifdef _WIN32)
		myprintf("\n");
		myprintf("00202! ERR <%s> kind %s\n",i_filename.c_str(),migliaia((int64_t)err));
		seppuku();
		exit(0);
	}
    char s[4]={0};
    const int nr=fread(s,1,4,inFile);
///	for (int i=0;i<4;i++)
///		myprintf("%d  %c  %d\n",(int)i,s[i],s[i]);
	fclose(inFile);
    if (nr>0 && memcmp(s, "7kSt", 4) && (memcmp(s, "zPQ", 3) || s[3]<1))
		return true;
	return false;
}
/*
	Sort section
*/
bool comparecrc32(s_fileandsize a, s_fileandsize b)
{
	return a.hashhex>b.hashhex;
}
bool comparesizehash(s_fileandsize a, s_fileandsize b)
{
	return (a.size < b.size) ||
           ((a.size == b.size) && (a.hashhex > b.hashhex)) ||
           ((a.size == b.size) && (a.hashhex == b.hashhex) &&
              (a.filename<b.filename));
			  ///(strcmp(a.filename.c_str(), b.filename.c_str()) <0));
}
bool comparefilename(s_fileandsize a, s_fileandsize b)
{
	return a.filename<b.filename;
}
bool comparefilenamesize(s_fileandsize a, s_fileandsize b)
{
	return myulltoa(a.size,18)+a.filename<myulltoa(b.size,18)+b.filename;
}
bool comparefilenamedate(s_fileandsize a, s_fileandsize b)
{
	return myulltoa(a.date,18)+a.filename<myulltoa(b.date,18)+b.filename;
}
// this seems weird, but try to compile something with gcc 4.0.1
struct s_stringpair
{
	int				index;
	string			first;
	string			second;
	s_stringpair(): index(0),first(""),second("") {}
};
bool pairsortbyindex(	const s_stringpair &a,
					const s_stringpair &b)
{
	return (a.index < b.index);
}
bool pairsortbyval(	const s_stringpair &a,
					const s_stringpair &b)
{
	if (a.second==b.second)
		return (a.first < b.first);
	return (a.second < b.second);
}
bool stringpairsortbyfirst(	const s_stringpair &a,
					const s_stringpair &b)
{
	if (a.first==b.first)
		return (a.second < b.second);
	return (a.first < b.first);
}

struct s_pair_intstring
{
	uint64_t		first;
	string			second;
	s_pair_intstring(): first(0),second("") {}
};
bool pairsortbyfirst(const s_pair_intstring &a,
               const s_pair_intstring &b)
{
    return (a.first < b.first);
}
/*
bool pairsortbysecond(const s_pair_intstring &a,
               const s_pair_intstring &b)
{
    return (b.first < a.first);
}
bool sortbysize(const std::pair<uint64_t, string> &a,
               const std::pair<uint64_t, string> &b)
{
    return (a.first < b.first);
}
*/
/// possible problems with unsigned to calculate the differences. We do NOT want to link abs()
int64_t myabs(int64_t i_first,int64_t i_second)
{
	if (i_first>i_second)
		return i_first-i_second;
	else
		return i_second-i_first;
}
/*
	random section
*/
struct xorshift128plus_key_s
{
    uint64_t part1;
    uint64_t part2;
};
typedef struct xorshift128plus_key_s xorshift128plus_key_t;
static inline void xorshift128plus_init(uint64_t key1, uint64_t key2, xorshift128plus_key_t *key)
{
  key->part1 = key1;
  key->part2 = key2;
}
uint64_t xorshift128plus(xorshift128plus_key_t * key)
{
    uint64_t s1 = key->part1;
    const uint64_t s0 = key->part2;
    key->part1 = s0;
    s1 ^= s1 << 23; // a
    key->part2 = s1 ^ s0 ^ (s1 >> 18) ^ (s0 >> 5); // b, c
    return key->part2 + s0;
}
void populateRandom_xorshift128plus(uint32_t *answer, uint32_t size,uint64_t i_key1, uint64_t i_key2)
{
	xorshift128plus_key_t mykey; /// nowarning
	mykey.part1 = i_key1;
	mykey.part2 = i_key2;
  xorshift128plus_init(i_key1, i_key2, &mykey);
  uint32_t i = size;
  while (i > 2) {
    *(uint64_t *)(answer + size - i) = xorshift128plus(&mykey);
    i -= 2;
  }
  if (i != 0)
    answer[size - i] = (uint32_t)xorshift128plus(&mykey);
}




#define MAX_PWD_LEN 32000

void disable_terminal_echo() 
{
#ifndef _WIN32
	struct termios term;
	tcgetattr(STDIN_FILENO, &term);
	term.c_lflag &= ~(ECHO | ICANON);
	tcsetattr(STDIN_FILENO, TCSANOW, &term);
#endif // corresponds to #ifndef (#ifndef _WIN32)
}

void restore_terminal_echo() 
{
#ifndef _WIN32
	struct termios term;
	tcgetattr(STDIN_FILENO, &term);
	term.c_lflag |= ECHO | ICANON;
	tcsetattr(STDIN_FILENO, TCSANOW, &term);
#endif // corresponds to #ifndef (#ifndef _WIN32)
}

int read_char() 
{
#ifdef _WIN32
	return _getch();
#else
	return getchar();
#endif // corresponds to #ifdef (#ifdef _WIN32)
}
bool iscontrolsomething(int i_char)
{
	return 
	(
#ifdef _WIN32
		(i_char==27) || 
#endif // corresponds to #ifdef (#ifdef _WIN32)
		((i_char>=0) && (i_char<=7)) || 
		(i_char==9) || 
		(i_char==11) || 
		(i_char==12) || 
		((i_char>=14) && (i_char<=26)) || 
		((i_char>=28) && (i_char<=31)) || 
		(i_char==45)
	);
}

typedef struct 
{
    char buffer[MAX_PWD_LEN];
    int cursor_pos;
    int length;
} sinputstate;


#ifdef _WIN32
void enable_raw_mode() 
{
    HANDLE hStdin = GetStdHandle(STD_INPUT_HANDLE);
    SetConsoleMode(hStdin, ENABLE_PROCESSED_INPUT);
}

void disable_raw_mode() 
{
    HANDLE hStdin = GetStdHandle(STD_INPUT_HANDLE);
    SetConsoleMode(hStdin, ENABLE_ECHO_INPUT | ENABLE_LINE_INPUT | ENABLE_PROCESSED_INPUT);
}

int read_key() 
{
    int ch=_getch();
    if (iscontrolsomething(ch)) ///ESC, control-C
	{
		restore_terminal_echo();
		myprintf("\n");
		myprintf("42262: Win: exiting due to strange key pressed |%d|\n",ch&255);
		seppuku();
	}
	
    if ((ch==224) || (ch==0)) 
	{  
        ch=_getch();
        switch (ch) 
		{
            case 75: return 1000;  // left
			case 77: return 1001;  // right
			case 72: return 1002;  // up
			case 80: return 1003;  // down
			case 83: return 1004;  // Del
            case 82: return 1005;  // Ins
            default: return ch;
        }
    }
    return ch;
}

#else
struct termios orig_termios;

void enable_raw_mode() 
{
    struct termios raw;
    tcgetattr(STDIN_FILENO, &orig_termios);
    raw = orig_termios;
    raw.c_lflag &= ~(ECHO | ICANON);
    raw.c_cc[VMIN] = 1;
    raw.c_cc[VTIME] = 0;
    tcsetattr(STDIN_FILENO, TCSAFLUSH, &raw);
}

void disable_raw_mode() 
{
    tcsetattr(STDIN_FILENO, TCSAFLUSH, &orig_termios);
}

int read_key() 
{
    int ch=getchar();
    if (iscontrolsomething(ch)) ///ESC, control-C
	{
		restore_terminal_echo();
		myprintf("\n");
		myprintf("42099: *nix exiting due to strange key pressed |%d|\n",ch&255);
		seppuku();
	}

    if (ch==27) 
        if (getchar()=='[') 
            switch (getchar()) 
			{
                case 'D': return 1000;  // left
				case 'C': return 1001;  // right
				case 'A': return 1002;  // up
				case 'B': return 1003;  // down
				case '3': // Del (longer escape)
						  getchar();  // final ~
						  return 1004;
                case '2': //  Ins
						  getchar();  // final ~
						  return 1005;
            }
    return ch;
}
#endif // corresponds to #ifdef (#ifdef _WIN32)

// Generic input handling functions
void insert_char(sinputstate *state, char ch) 
{
    if (state->length < MAX_PWD_LEN - 1) 
	{
        // move to right
		memmove(state->buffer + state->cursor_pos + 1, 
                state->buffer + state->cursor_pos, 
                state->length - state->cursor_pos);
        state->buffer[state->cursor_pos] = ch;
        state->cursor_pos++;
        state->length++;
        state->buffer[state->length] = '\0';
    }
}

void delete_char(sinputstate *state) 
{
    // backspace
    if (state->cursor_pos > 0) 
    {
        // move to left
		memmove(state->buffer + state->cursor_pos - 1, 
                state->buffer + state->cursor_pos, 
                state->length - state->cursor_pos + 1);  // +1 per includere il terminatore
        state->cursor_pos--;
        state->length--;
    }
}

void delete_char_forward(sinputstate *state)
{
    // Del
    if (state->cursor_pos < state->length)
    {
        // move to left from current pos
		memmove(state->buffer + state->cursor_pos, 
                state->buffer + state->cursor_pos + 1,
                state->length - state->cursor_pos);
        
        state->length--;
    }
}

void move_cursor(sinputstate *state, int direction) 
{
    switch (direction) 
	{
        case 1000:  // left
					if (state->cursor_pos > 0) 
						state->cursor_pos--;
					break;
        case 1001:  // right
		
					if (state->cursor_pos < state->length) 
						state->cursor_pos++;
					break;
    }
}

void redraw_input(sinputstate *state,string i_testo) 
{
	printf("\r");

    setupConsole();
    printf("\033[K");  // clear up to end
	restoreConsole();
	
    color_yellow();
    myprintf("%s", i_testo.c_str());
    color_restore();

    // Print the contents of the buffer
    for (int i = 0; i < state->length; i++) 
		if (flagdebug)
			printf("%c", state->buffer[i]);
		else
			printf("*");
    
    printf("\r");
    setupConsole();
    for (int unsigned i=0;i<i_testo.size()+state->cursor_pos;i++)
        printf("\033[C");  // toright
	
    restoreConsole();
    fflush(stdout);
}

string internal_password_withcursor(string i_default)
{
	if (flagsilent)
		return "";
    string myresult	="";
	sinputstate state;
	memset(&state,0,sizeof(state));
    int ch;

	myprintf("\n");
	if (i_default=="")
		i_default="Enter password :";
	redraw_input(&state,i_default);
    enable_raw_mode();

    while (1) 
	{
        ch = read_key();
		
		if ((ch=='\n') || (ch== '\r'))
			break;  // CR
		
		if ((ch==127) || (ch=='\b') || (ch==8))   // Backspace
			delete_char(&state);
		else if ((ch==1000)|| (ch== 1001))   // left/right
			move_cursor(&state, ch);
		else if (ch==1004)   // Del
			delete_char_forward(&state);
		else if (isprint(ch))   // goodchar
			insert_char(&state, ch);
        redraw_input(&state,i_default);
    }

    disable_raw_mode();
    myprintf("\n");
    myresult=state.buffer;
	if (flagdebug)
		myprintf("42074: Password |%s|\n",myresult.c_str());
	return myresult;
}


string internal_password_nocursor(const string i_default)
{
	if (flagsilent)
		return "";
	string myresult="";
	myprintf("\n");
	color_yellow();
	if (i_default!="")
		myprintf("42040: %s :",i_default.c_str());	
	else
		myprintf("42025: Enter password :");
	color_restore();
	
    char password[MAX_PWD_LEN];
	memset(password,0,MAX_PWD_LEN);
    int pos=0;
    int ch;

    disable_terminal_echo();

    while (1)
	{
		ch=read_char();
		
		if ((ch=='\n') || (ch== '\r'))
			break;  // CR

///		printf(" |%03d| \n",ch&255);
        // backspace
        if ((ch==127) || (ch=='\b') || (ch==8)) 
		{ 
            if (pos>0) 
			{
                pos--;
                password[pos] = '\0';
                printf("\b \b");  // Delete the last asterisk
                fflush(stdout);
            }
        }
        // Normal characters
        else
		if (iscontrolsomething(ch)) ///ESC, control-C
		{
			restore_terminal_echo();
			myprintf("\n");
			myprintf("02053: Exiting due to strange key pressed |%d|\n",ch&255);
			seppuku();
		}
		else
		if (isprint(ch))
			if (pos<MAX_PWD_LEN-1) 
			{
				password[pos] = ch;
				pos++;
				printf("*");
				fflush(stdout);
			}
    }

    restore_terminal_echo();
    myprintf("\n");
    myresult=password;
	if (flagdebug)
		myprintf("42074: Password |%s|\n",myresult.c_str());
	return myresult;
}



string mygetpasswordblind(const string i_default)
{
	string risultato;
	
	if (flagnocolor)
		risultato=internal_password_nocursor(i_default);
	else
		risultato=internal_password_withcursor(i_default);
	if (g_keyfilehash!="")
		risultato+=g_keyfilehash;
	return risultato;
}
FP 		g_archivefp;
FP 		g_archivefp_first;

//////////////////// zpaq stuff
// Base of InputArchive and OutputArchive
class ArchiveBase {
protected:
  libzpaq::AES_CTR* aes;  // NULL if not encrypted
  FP fp;          // currently open file or FPNULL
public:
  ArchiveBase(): aes(0), fp(FPNULL) {}
  ~ArchiveBase() {
    if (aes) delete aes;
    if (fp!=FPNULL) myfclose(&fp);
  }
  bool isopen() {return fp!=FPNULL;}
  FP	getthefp() { return fp;}
};
// An InputArchive supports encrypted reading
class InputArchive: public ArchiveBase, public libzpaq::Reader {
  vector<int64_t> sz;  // part sizes
  int64_t		total_sz;
  int64_t off;  // current offset
  string fn;  // filename, possibly multi-part with wildcards
public:
  vector<string> filepartnames;
  string		 lastfilename;
  // Open filename. If password then decrypt input.
  InputArchive(const char* filename);
  // Read and return 1 byte or -1 (EOF)
  int get() {
    error("get() not implemented");
    return -1;
  }
  int get_chunknumber()
  {
	return sz.size();
  }
  int64_t get_totalsize()
  {
	return total_sz;
  }
  // Read up to len bytes into obuf at current offset. Return 0..len bytes
  // actually read. 0 indicates EOF.
  int read(char* obuf, int len) {
    int nr=fread(obuf, 1, len, fp);
	///printf("n1 %s\n",migliaia(nr));
    if (nr==0) {
      seek(0, SEEK_CUR);
      nr=fread(obuf, 1, len, fp);
    }
    if (nr==0) return 0;
    if (aes) aes->encrypt(obuf, nr, off);
    off+=nr;
///	myprintf("00204: BLOKKO len %d\n",len);
    return nr;
  }
  // Like fseeko()
  void seek(int64_t p, int whence);
  // Like ftello()
  int64_t tell() {
    return off;
  }
	int64_t totalsize()
	{
		int64_t temp=0;
		for (unsigned i=0; i<sz.size(); ++i)
			temp+=sz[i];
		return temp;
	}
};
// Like fseeko. If p is out of range then close file.
void InputArchive::seek(int64_t p, int whence) {
  if (!isopen()) return;
  // Compute new offset
  if (whence==SEEK_SET) off=p;
  else if (whence==SEEK_CUR) off+=p;
  else if (whence==SEEK_END) {
    off=p;
    for (unsigned i=0; i<sz.size(); ++i) off+=sz[i];
  }
  // Optimization for single file to avoid close and reopen
  if (sz.size()==1) {
    fseeko(fp, off, SEEK_SET);
    return;
  }
  // Seek across multiple files
  assert(sz.size()>1);
  int64_t sum=0;
  unsigned i;
  for (i=0;; ++i) {
    sum+=sz[i];
    if (sum>off || i+1>=sz.size()) break;
  }
  const string next=subpart(fn, i+1);
  myfclose(&fp);
  fp=myfopen(next.c_str(), RB);
  if (fp==FPNULL) ioerr(next.c_str());
  fseeko(fp, off-sum, SEEK_END);
}
// Open for input. Decrypt with password and using the salt in the
// first 32 bytes. If filename has wildcards then assume multi-part
// and read their concatenation.
InputArchive::InputArchive(const char* filename):fn(filename) 
{
	assert(filename);
	lastfilename="";
	off=0;
	total_sz=0;
	// Get file sizes
	const string part0=subpart(filename, 0);
	for (unsigned i=1; ; ++i) 
	{
		const string parti=subpart(filename, i);
		if (i>1 && parti==part0) 
			break;
	    fp=myfopen(parti.c_str(), RB);
		if (fp==FPNULL) 
			break;
		filepartnames.push_back(parti);
		lastfilename=parti;
		fseeko(fp, 0, SEEK_END);
		sz.push_back(ftello(fp));
		total_sz+=sz.back();
		if (fp!=NULL)
			myfclose(&fp);
	}
  // Open first part
	const string part1=subpart(filename,1);

	///	bypass the password, use the global one
	if (g_password==NULL)
		if (check_if_password(part1))
		{
			myprintf("00205$ Archive seems encrypted (or corrupted)");
			string spassword=mygetpasswordblind("");
			if (spassword!="")
			{
				libzpaq::SHA256 sha256;
				for (unsigned int i=0;i<spassword.size();i++)
					sha256.put(spassword[i]);

				memcpy(g_password_string, sha256.result(), 32);
				g_password=g_password_string;
			}
		}
		
	fp=myfopen(part1.c_str(), RB);
	if (!isopen()) 
		ioerr(part1.c_str());
	assert(fp!=FPNULL);
  
	if (g_password) 
	{
		char salt[32], key[32];
		if (fread(salt, 1, 32, fp)!=32) 
			error("37992: cannot read salt");
		libzpaq::stretchKey(key,g_password, salt);
		aes=new libzpaq::AES_CTR(key, 32, salt);
		g_allocatedram+=sizeof(libzpaq::AES_CTR);
		off=32;
	}
}

int inttoarray(int64_t i_number, char* i_buffer, int i_size)
{
	if (i_buffer==NULL)
	{
		myprintf("00206! GURU buffer NULL!\n");
		seppuku();
		return 0;
	}
	if (i_size<=0)
	{
		myprintf("00207! GURU i_size not positive!\n");
		seppuku();
		return 0;
	}

	for (int i=0;i<i_size;i++)
	{
		uint8_t numerino=(i_number&255);
		*i_buffer++ =numerino;
		i_number>>=8;
	}
	return i_size;
}

int32_t arraytoint32(const char* i_buffer)
{
	if (i_buffer==NULL)
	{
		myprintf("00208! i_buffer is NULL\n");
		seppuku();
		return -1;
	}
	int64_t	risultato=0;
	for (int i=3;i>=0;i--)
	{
		uint8_t numerino=*(i_buffer+i);
		risultato=risultato+numerino;
		if (i>0)
		risultato<<=8;
	}
	return risultato;
}

int64_t arraytoint64(const char* i_buffer)
{
	if (i_buffer==NULL)
	{
		myprintf("00209! i_buffer is NULL\n");
		seppuku();
		return -1;
	}
	int64_t	risultato=0;
	for (int i=7;i>=0;i--)
	{
		uint8_t numerino=*(i_buffer+i);
	///	printf("Letto %d  %02X\n",(int)i,numerino);
		risultato=risultato+numerino;
		if (i>0)
		risultato<<=8;
	}

	return risultato;
}


	
// An Archive is a file supporting encryption
class OutputArchive: public ArchiveBase, public libzpaq::Writer {
	int64_t off;    // preceding multi-part bytes
	unsigned ptr;   // write pointer in buf: 0 <= ptr <= BUFSIZE
	enum {BUFSIZE=1<<16};
	char buf[BUFSIZE];  // I/O buffer
	string thefilename;
	bool	flagindex;

	FP 				firstfp;
	uint64_t 		chunksize;
	int64_t			writtensofar;
	unsigned int 	chunknumber;
	string			firstfilename;
	int64_t			writtenonlastchunk;
	int64_t			previoussize;
public:
	bool			firstchunk;
	vector<string> 	filepartnames;
	
  // Open. If password then encrypt output.
  OutputArchive(string i_thearchive,const char* filename, const char* password=0,
                const char* salt_=0, int64_t off_=0);
	string lastfilename()
	{
		return thefilename;
	}
  // Write pending output
	void flush() 
	{
		if (flagdebug3)
			myprintf("00210: flush k1\n");
		assert(fp!=FPNULL);
		string nomefile=prendinomefileebasta(thefilename);
		
		g_archivefp=fp;
		if (flagdebug3)
			myprintf("00211: flush k2\n");
#ifndef ESX		
		if (ptr==104)
			if (flagdebug4)
				myprintf("00212: =============== g_write_on_first %d firstp %s\n",int(g_write_on_first),migliaia(int64_t(firstfp)));
#endif
		if (flagdebug3)
			myprintf("00213: flush k3\n");
		
		if (g_write_on_first && (ptr==104) && (firstfp!=FPNULL))
		{
#ifndef ESX
			if (flagdebug3)
				myprintf("00214: ################ fixing on firstfp %s size %d @ %s\n",migliaia3(int64_t(firstfp)),ptr,migliaia(g_write_on_seek));
#endif
			fseeko(firstfp,g_write_on_seek,SEEK_SET);
		
			if (flagdebug3)
				myprintf("00215: ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ write on first, 104  ftello %s off %s encrypt @%s\n",migliaia(ftello(firstfp)),migliaia2(off),migliaia3(ftello(firstfp)+off));
#ifndef ESX
			if (flagdebug3)
				myprintf("00216: HERE WE ARE @ %12s on fp %12s  size %s\n",migliaia3(ftello(firstfp)),migliaia(int64_t(firstfp)),migliaia2(ptr));
#endif
			char debugfilename[100];
#ifndef ESX
			FP debugoutf;
			if (flagdebug4)
			{
				snprintf(debugfilename,sizeof(debugfilename),"z:\\fp_%04d,%04d_u_%08d_size_%06d_%s.bin",(int)g_debug_sequence++,(int)int64_t(firstfp),(int)int64_t(ftello(firstfp)),ptr,nomefile.c_str());
				debugoutf=myfopen(debugfilename,WB);
				myfwrite(buf,1,ptr,debugoutf);
				myfclose(&debugoutf);
			}
#endif
			if (firstchunk)
			{
				if (flagdebug3)
					myprintf("00217: i am first chunk => off to zero\n");
				off=0;
			}
			else
			{
				if (flagdebug3)
					myprintf("00218: not first chunk, off to %s\n",migliaia(off));
			}
			int64_t criptoposition=ftello(firstfp)+off;
			
			if (flagdebug4)
				myprintf("00219: write104 at %s (fetello %s + off %s)  on file %s should thefilename %s\n",migliaia(ftello(firstfp)+off),migliaia2(ftello(firstfp)),migliaia3(off),debugfilename,thefilename.c_str());

			if (aes) 
			{
				if (flagdebug3)
					myprintf("00220: aes crypt size %s criptoposition %s\n",migliaia(ptr),migliaia2(criptoposition));
				aes->encrypt(buf, ptr,criptoposition);
			}
#ifndef ESX
			if (flagdebug4)
			{
				snprintf(debugfilename,sizeof(debugfilename),"z:\\enc_%04d,%04d_u_%08d_size_%06d_%s_at_%08d_due.bin",(int)g_debug_sequence++,(int)int64_t(fp),(int)int64_t(ftello(fp)),ptr,nomefile.c_str(),(int)criptoposition);
				debugoutf=myfopen(debugfilename,WB);
				myfwrite(buf,1,ptr,debugoutf);
				myfclose(&debugoutf);
			}
			if (flagdebug3)
				myprintf("00221: realfwrite104 on firstfp %s @ftello %s\n",migliaia(int64_t(firstfp)),migliaia2(int64_t(ftello(firstfp))));
#endif
			myfwrite(buf, 1, ptr, firstfp);
#ifndef ESX
			if (flagdebug3)
				myprintf("00222: closing the firstp %s\n",migliaia(int64_t(firstfp)));
#endif
			tocca_now(firstfp);
			myfclose(&firstfp);
			firstfp=FPNULL;
			fp=FPNULL;
			ptr=0;
			return;
		}

		if (flagdebug3)
			myprintf("00223: flush k4\n");
		
#ifndef ESX
		if (flagdebug3)
		{
			if ((int64_t)fp!=0)
			{
				myprintf("00224: -pre fp %s\n",migliaia((int64_t)fp));
				myprintf("00225: write @ %12s on fp %12s (%d) size %s\n",migliaia3(ftello(fp)),migliaia(int64_t(fp)),int64_t(fp),migliaia2(ptr));
				myprintf("00226: -post\n");
			}
		}
#endif
		if (flagdebug3)
			myprintf("00227: flush k4bis\n");


#ifndef ESX
		char debugfilename[100];
		FP debugoutf;		
		if (flagdebug4)
		{
			snprintf(debugfilename,sizeof(debugfilename),"z:\\fp_%04d,%04d_u_%08d_size_%06d_%s.bin",(int)g_debug_sequence++,(int)int64_t(fp),(int)int64_t(ftello(fp)),ptr,nomefile.c_str());
			debugoutf=myfopen(debugfilename,WB);
			myfwrite(buf,1,ptr,debugoutf);
			myfclose(&debugoutf);
		}
		if (flagdebug3)
			if ((int64_t)fp!=0)
				myprintf("00228: !!!!!!!!!!!!!!!!!!!!!! unecrypted on [ENCRYPT @ %s] %s\n",migliaia(ftello(fp)+off),debugfilename);
#endif
	
		if (flagdebug3)
			myprintf("00229: flush k5\n");
	
#ifndef ESX
		if (ptr==104)
			if (flagdebug3)
				if ((int64_t)fp!=0)
					myprintf("00230:-------------------------------------- regular 104 encrypt @%s\n",migliaia(int64_t(ftello(fp)+off)));
#endif
		if (flagdebug3)
			myprintf("00231: MMMMMMMMMMMMMMMMMMMMMMMMMMM off %s writtensofar %s onlast %s|\n",migliaia3(off),migliaia(writtensofar),migliaia2(writtenonlastchunk));
	
  
		if (flagdebug3)
			myprintf("00232: flush k6\n");
	
		int64_t cryptoffset;
		if (g_chunk_size>0)
		{
			cryptoffset=writtensofar+previoussize; ///va primo run
			if ((aes) && (previoussize==0))
				cryptoffset+=32; ///primo run
		}
		else
		{
			if ((int64_t)fp!=0)
				cryptoffset=ftello(fp)+off;
			else
				cryptoffset=0;
		}
		if (flagdebug3)
			myprintf("00233: flush k7\n");
	
		if (aes) 
		{
#ifndef ESX
			if (flagdebug4)
				if ((int64_t)fp!=0)
					myprintf("00234: AES seq %08d [size %6s] crypt %10s (ftello %10s + off %10s + written %10s) %s\n",
							g_debug_sequence,
							migliaia5(ptr),
							migliaia(cryptoffset),
							migliaia2(ftello(fp)),
							migliaia3(off),
							migliaia4(writtensofar),
							nomefile.c_str());
#endif
			aes->encrypt(buf, ptr, cryptoffset);
		}
#ifndef ESX
		if (flagdebug4)
		{
			if (fp!=NULL)
			{
				snprintf(debugfilename,sizeof(debugfilename),"z:\\enc_%04d,%04d_u_%08d_size_%06d_%s_at_%08d.bin",(int)g_debug_sequence++,(int)int64_t(fp),(int)int64_t(ftello(fp)),ptr,nomefile.c_str(),(int)cryptoffset);
				debugoutf=myfopen(debugfilename,WB);
				myfwrite(buf,1,ptr,debugoutf);
				myfclose(&debugoutf);
			}
		}
#endif
		myfwrite(buf, 1, ptr, fp);
		writtensofar	+=ptr;
		chunksize		+=ptr;

		if (flagdebug3)
			myprintf("00235: flush k8\n");
		
		if (g_chunk_size>0)
			if (chunksize>g_chunk_size)
			{
				if ((fp!=firstfp) && (fp!=FPNULL))
				{
#ifndef ESX
					if (flagdebug3)
					{
						myprintf("\r                                                                                \r");
						myprintf("\r");
						myprintf("00236: closing __________________________ %s |%s|\n",migliaia(int64_t(fp)),thefilename.c_str());
					}
#endif
					tocca_now(fp);
					myfclose(&fp);
				}
				thefilename=format_filename(++chunknumber);
				if (flagdebug3)
					myprintf("00237: the (new) filename %s\n",thefilename.c_str());
				fp=myfopen(thefilename.c_str(), WB,DATE_1980);
				if (!isopen()) 
					ioerr(thefilename.c_str());
#ifndef ESX
				if (flagdebug3)
					myprintf("00238: file open and ready on fp %s!\n",migliaia(int64_t(fp)));
#endif
				chunksize=0;
				writtenonlastchunk=writtensofar;
				g_addedchunklist.push_back(thefilename);
				///g_addedchunklist_fp.push_back(fp);
				

			}
		ptr=0;
	}
  // Position the next read or write offset to p.
  void seek(int64_t p, int whence)
  {
		if (g_fakewrite)  /// ransomware
		{
			if (whence==SEEK_SET)
				off=p;
			else
			off+=p;  // assume at end
		}


    if (fp!=FPNULL) 
	{
#ifndef ESX
		if (flagdebug3)
			myprintf("00239: calling flush from seek fp %s\n",migliaia(int64_t(fp)));
#endif
		flush();
#ifndef ESX
		if (flagdebug3)
			myprintf("00240: calling fseeko for fp %s to %s\n",migliaia(int64_t(fp)),migliaia2(int64_t(p)));
#endif
		fseeko(fp, p, whence);
    }
    else if (whence==SEEK_SET) off=p;
    else off+=p;  // assume at end
  }
  // Return current file offset.
  int64_t tell() const
  {
	if (g_fakewrite)  /// ransomware
		return off;

    if (fp!=FPNULL)
		return ftello(fp)+ptr;
    else
		return off;
  }
  int64_t tellwritten() const
  {
	if (g_fakewrite)  /// ransomware
		return off;
	return writtensofar+ptr;
  }
  
  

  // Write one byte
  void put(int c)
  {
	if (g_fakewrite)  /// ransomware
	{
		++off;	//we do not flush
		return;
	}
    if (fp==FPNULL) ++off;
    else {
      if (ptr>=BUFSIZE) flush();
      buf[ptr++]=c;
    }
  }
  // Write buf[0..n-1]
	void write(const char* ibuf, int len)
	{
		if (g_fakewrite) /// ransomware
		{
			off+=len;
			return;
		}

    if (fp==FPNULL)
		off+=len;
    else
		while (len-->0) put(*ibuf++);
  }
  // Flush output and close
  void close() 
  {
	  
    if (fp!=FPNULL) 
	{
#ifndef ESX
		if (flagdebug3)
			myprintf("00241: calling flush on fp=%s\n",migliaia(int64_t(fp)));
#endif
		flush();
		if (fp!=FPNULL)
		{ 
			tocca_now(fp);
#ifndef ESX
			if (flagdebug3)
				myprintf("00242: calling close %s\n",migliaia(int64_t(fp)));
#endif
			myfclose(&fp);
		}
		if (flagdebug3)
			myprintf("37816: ho fatto close su file\n");
		
#ifdef ZPAQFULL ///NOSFTPSTART
		if (g_p_franzenfile)
		{
			if (flagdebug3)
				myprintf("-------------------- chiudo davvero %21s\n",migliaia(int64_t(g_p_franzenfile)));
			g_p_franzenfile->close();
			g_p_franzenfile=0;
		}
		
		else
			myprintf("DEBUG: nofranzen zero!\n");
		
#endif ///NOSFTPEND
    }
    fp=FPNULL;
	
	  
	}
  	string format_filename(unsigned int i_number)
	{
		if (g_chunk_size==0)
			return firstfilename;
		int64_t maxpart=10;
		for (unsigned int i=0;i<firstfilename.size();i++)
			if (firstfilename[i]=='?')
				maxpart*=10;
		maxpart/=10;
		///myprintf("00243: maxpart can be %s\n",migliaia(maxpart));
		if (i_number>(maxpart-1))
		{
			myprintf("00244! GURU: the number %s cannot be stored in maxpart %s\n",migliaia(i_number),migliaia2(maxpart-1));
			myprintf("00245! maybe you need a longer ? pattern <<%s>>\n",firstfilename.c_str());
			seppuku();
			return "";
		}
		string part0=subpart(firstfilename, 0);
		if (flagdebug3)
			myprintf("00246: i_number %d part0 %s   firstfilename %s\n",i_number,part0.c_str(),firstfilename.c_str());
		
		if (part0!=firstfilename) 
		{	
			string temp=subpart(firstfilename,i_number);
			if (flagdebug2)
				myprintf("00247: created by subpart %s\n",temp.c_str());
			filepartnames.push_back(temp);
			return temp;
		}
		
		return firstfilename;
	}
};


// this is for SMALL list of parameters
int listfiles(string i_path,const string& i_extension,bool i_fullname,vector<string>* o_thelist)
{
	if (o_thelist==NULL)
	{
		myprintf("00248! GURU o_thelist is null\n");
		return 0;
	}
#ifndef unix
	vector<string> tobesorted;
	if (flagdebug3)
	{
		myprintf("00249: i_path      %s\n",i_path.c_str());
		myprintf("00250: i_extension %s\n",i_extension.c_str());
	}
	i_path=extractfilepath(i_path);
	std::wstring wpattern = utow(i_path.c_str())+utow("*.")+utow(i_extension.c_str());
	const std::string s_pattern(wpattern.begin(),wpattern.end());
	if (flagdebug)
		myprintf("00251: get handle for w pattern %s\n",wtou(wpattern.c_str()).c_str());

	WIN32_FIND_DATAW findfiledata;
	HANDLE myhandle=FindFirstFileW(wpattern.c_str(),&findfiledata);
	if (myhandle==INVALID_HANDLE_VALUE)
	{
		if (flagdebug)
			myprintf("00252! Invalid handle %s\n",s_pattern.c_str());
		return 0;
	}
	do
	{
		std::string t=wtou(findfiledata.cFileName);
		if ((t!=".") && (t!=".."))
		{
			std::wstring wfilepath;
			if (i_fullname)
				wfilepath=utow(i_path.c_str())/*+L"\\"*/+findfiledata.cFileName;
			else
				wfilepath=findfiledata.cFileName;

			const std::string s_wfilepath(wfilepath.begin(),wfilepath.end());
			if (flagdebug)
				myprintf("00253: Working on %s ",s_wfilepath.c_str());
			if (findfiledata.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
			{
				if (flagdebug)
					myprintf(": DO NOTHING\n");
			}
			else
			{
				if (flagdebug)
					myprintf(": OK PUSH BACK\n");
				tobesorted.push_back(wtou(wfilepath.c_str()));
			}
		}
	} while(FindNextFile(myhandle,&findfiledata)==TRUE);
	if (myhandle)
		FindClose(myhandle);
	if (flagdebug3)
		for (unsigned int i=0;i<tobesorted.size();i++)
			myprintf("00254: %03d  %s\n",(int)i,tobesorted[i].c_str());

	std::sort(tobesorted.begin(),tobesorted.end());
	for (unsigned int i=0;i<tobesorted.size();i++)
		(*o_thelist).push_back(tobesorted[i]);

	return tobesorted.size();
#else
	if (!isdirectory(i_path))
		i_path+="/";

	DIR 	*dir;
	const struct 	dirent *ent;
	if ((dir=opendir(i_path.c_str()))==NULL)
	{
		myprintf("00255! cannot scan in <<%s>>\n",i_path.c_str());
		return 0;
	}

	vector<string> tobesorted;
	while ((ent=readdir(dir))!=NULL)
	{
		string thename=ent->d_name;
		if ((thename!=".") && (thename!="..") && (!isdirectory(thename)))
		{
			string fullname;
			if (i_fullname)
				fullname=i_path+thename;
			else
				fullname=thename;

			string estensione	=prendiestensione(thename);
			if (flagdebug3)
			{
				myprintf("00256: i_path     %s\n",i_path.c_str());
				myprintf("00257: thename    %s\n",thename.c_str());
				myprintf("00258: fullname   %s\n",fullname.c_str());
				myprintf("00259: estensione %s\n",estensione.c_str());
			}
			bool flagaggiungi=true;

			if (i_extension!="")
				flagaggiungi=(estensione==i_extension);

			if (flagaggiungi)
			{
				if (flagdebug2)
					myprintf("00260: ZZZZ %s\n", fullname.c_str());
				tobesorted.push_back(fullname);
			}
		}

	}
	closedir (dir);

	std::sort(tobesorted.begin(),tobesorted.end());
	for (unsigned int i=0;i<tobesorted.size();i++)
		(*o_thelist).push_back(tobesorted[i]);

	return tobesorted.size();
#endif // corresponds to #ifndef (#ifndef unix)
}

// just a bit of recursion
bool jollymatch(const char* i_pattern, const char* i_thestring)
{
    if ( (*i_pattern=='\0') && (*i_thestring=='\0'))
        return true;
    if (*i_pattern=='*')
	{
        while (*(i_pattern+1)=='*')
            i_pattern++;
	}
	if ((*i_pattern=='*') && (*(i_pattern+1)!='\0') && (*i_thestring=='\0'))
        return false;
	if ((*i_pattern=='?') || (*i_pattern==*i_thestring))
        return jollymatch(i_pattern+1,i_thestring+1);
	if (*i_pattern=='*')
		return jollymatch(i_pattern+1,i_thestring) || jollymatch(i_pattern,i_thestring+1);
	return false;
}

int	getpartnumber(string i_thefilename)
{
	if (i_thefilename.size()<14)
	{
		if (flagdebug)
			myprintf("00261! return -1 because size <14 |%s|\n",i_thefilename.c_str());
		return -1;
	}
#ifdef _WIN32
	i_thefilename=stringtolower(i_thefilename);
#endif // corresponds to #ifdef (#ifdef _WIN32)
	int		risultato	=-1;
	bool fileok			=true;
	string candidato	=extractfilename(i_thefilename);

	if (candidato[candidato.size()-14]=='_')
	{
		unsigned int resto=candidato.size()-13;
		fileok=fileok && (isdigit(candidato[resto++]));
		fileok=fileok && (isdigit(candidato[resto++]));
		fileok=fileok && (isdigit(candidato[resto++]));
		fileok=fileok && (isdigit(candidato[resto++]));
		fileok=fileok && (isdigit(candidato[resto++]));
		fileok=fileok && (isdigit(candidato[resto++]));
		fileok=fileok && (isdigit(candidato[resto++]));
		fileok=fileok && (isdigit(candidato[resto++]));
		fileok=fileok && (candidato[resto++]=='.');
		fileok=fileok && (candidato[resto++]=='z');
		fileok=fileok && (candidato[resto++]=='p');
		fileok=fileok && (candidato[resto++]=='a');
		fileok=fileok && (candidato[resto++]=='q');
		if (fileok)
		{
			string numerini=candidato.substr(candidato.size()-13,8);
			if (numerini.size()>0)
				risultato=atoi(numerini.c_str());
			if (flagdebug3)
				myprintf("00262: numerini |%s| int %s\n",numerini.c_str(),migliaia(risultato));
		}
	}
	else
	{
		if (flagdebug)
			myprintf("00263! -14 is not '_' for |%s|\n",candidato.c_str());
	}
	return risultato;
}

typedef int (*callback_issomething)(int);
string stringtosomething(const string& i_input,callback_issomething i_check)
{
	string onlysomething="";
	for (unsigned int i=0;i<i_input.size();i++)
		if (i_check((int)i_input[i]))
			onlysomething+=i_input[i];
	return onlysomething;
}



class easymultipart
{
	private:
	string			thefilename;

	public:
	vector<s_fileandsize> 	filenamearray;
	vector<s_fileandsize> 	partarray;

	string	lastpart;
	string	nextpart;
	
	int		howmanychunks;
	bool	ismultipart;
	bool	isgood;
	int		howmanyjolly;
	int64_t	totalchunksize;
	int		nextpart_integer;
	int64_t	maxpart;
	
	easymultipart(string i_filename):
	howmanychunks(0),
	ismultipart(false),
	isgood(false),
	howmanyjolly(0),
	totalchunksize(0),
	nextpart_integer(0),
	maxpart(0)
	{
		if (!iszpaq(i_filename))
			i_filename+=".zpaq";
#ifdef _WIN32
	///	i_filename=stringtolower(i_filename);
#endif // corresponds to #ifdef (#ifdef _WIN32)
///	we really want a path, even relative
		thefilename	=i_filename;
		lastpart	="";
		nextpart	="";

		if (i_filename=="")
		{
			myprintf("00264! multipartfilename is empty\n");
			return;
		}
		maxpart=10;
		for (unsigned int i=0;i<i_filename.size();i++)
			if (i_filename[i]=='?')
			{
				howmanyjolly++;
				maxpart*=10;
			}
		maxpart/=10;
		ismultipart=howmanyjolly>0;
		if (howmanyjolly>9)
		{
			myprintf("00265! too many jolly '?' (max 9), founded %d in %s\n",howmanyjolly,i_filename.c_str());
			seppuku();
			return;
		}
		if (!ismultipart)
			return;
		enumerate();

		partarray.clear();
		int parts	=0;  // number of existing parts in multipart
		string part0=subpart(i_filename,0);
		string thehole	="";
		totalchunksize=0;
		for (int i=1;; ++i)
		{
			string partname=subpart(i_filename,i);
			if (partname==part0)
				error("84285: too many archive parts");
			if (!fileexists(partname))
			{
				thehole=partname;
				if (flagdebug3)
					myprintf("00266: filenamearraysize %08d partname %08d does not exists\n",filenamearray.size(),i,partname.c_str());
				if (i==1)
					thehole="";
				else
				if ((filenamearray.size()>0) && (i>0))
				{
					if (flagdebug3)
					{
						myprintf("00267: last filenamearraysize %s\n",filenamearray[filenamearray.size()-1].filename.c_str());
						myprintf("00268: i-1                    %s\n",subpart(i_filename,i-1).c_str());
					}
					if (filenamearray[filenamearray.size()-1].filename==subpart(i_filename,i-1)) 
						thehole="";
				}
				break;
			}
			else
			{
				s_fileandsize myblock;
				myblock.filename=partname;
				int64_t tempsize=prendidimensionefile(partname.c_str());
				totalchunksize+=tempsize;
				myblock.size=tempsize;
				myblock.attr=0;
				myblock.date=0;
				myblock.isdir=isdirectory(partname);
				myblock.flaghashstored=false;
				partarray.push_back(myblock);
			}
			++parts;
		}
		std::sort(partarray.begin(),partarray.end(),comparefilename);
		isgood=(thehole==""); //filenamearray.size()==partarray.size();

		if (thehole!="")
		{
		///	myprintf("00269: PART NUMBER MISMATCH: disk %s vs part %s (HOLE IN %s)\n",migliaia(filenamearray.size()),migliaia2(partarray.size()),thehole.c_str());
			
			myprintf("00270! [2] AT LEAST ONE HOLE DETECTED! <<%Z>>\n",thehole.c_str());
			if (filenamearray.size()>partarray.size()) // this should be
				for (unsigned int i=0;i<filenamearray.size();i++)
				{
					bool trovato=false;
					for (unsigned int j=0;j<partarray.size();j++)
						if (filenamearray[i].filename==partarray[j].filename)
						{
							trovato=true;
							break;
						}
					if (!trovato)
						if (flagdebug2)
							myprintf("00272: Filename not matched %s\n",filenamearray[i].filename.c_str());
				}
		}
		
		if (flagdebug3)
		{
			for (unsigned int i=0;i<filenamearray.size();i++)
				myprintf("00273: filenamearray %08d %s\n",i,filenamearray[i].filename.c_str());
				
			for (unsigned int i=0;i<partarray.size();i++)
				myprintf("00274: partarray %08d %s\n",i,partarray[i].filename.c_str());
		}	
			
		if (partarray.size()>0)
		{
			if (fileexists(subpart(i_filename, parts)))
				lastpart=subpart(i_filename, parts);
			nextpart=subpart(i_filename, parts+1);
			nextpart_integer=parts+1;
		}
		else
		{
			nextpart=subpart(i_filename, 1);
			nextpart_integer=1;
		}
	}

	string enumerate()
	{
		vector<string> candidate;
		listfiles(extractfilepath(thefilename),"zpaq",true,&candidate);
		for (unsigned int i=0;i<candidate.size();i++)
		{
			if (flagdebug3)
				myprintf("00275: candidate %08d %s\n",i,candidate[i].c_str());
			
			s_fileandsize myblock;
			string currentfilename=candidate[i];
#ifdef _WIN32
		///	currentfilename=stringtolower(currentfilename);
#endif // corresponds to #ifdef (#ifdef _WIN32)

			if (jollymatch(thefilename.c_str(),candidate[i].c_str()))
			{
				if (flagdebug3)
					myprintf("00276: jolly match filename %s candidate %08d %s\n",thefilename.c_str(),i,candidate[i].c_str());
				
				string onlydigit	=stringtosomething(currentfilename,isdigit);
				if (onlydigit!="")
				{
					myblock.filename		=currentfilename;
					myblock.size			=prendidimensionefile(currentfilename.c_str());
					myblock.attr			=0;
					myblock.date			=0;
					myblock.isdir			=false;
					myblock.flaghashstored	=false;
					filenamearray.push_back(myblock);
					if (flagdebug3)
						myprintf("00277: added %s\n",currentfilename.c_str());
				}
			}
			else
			{
				if (flagdebug2)
					myprintf("00278: Not jolly part %s\n",currentfilename.c_str());
			}
		}
		std::sort(filenamearray.begin(),filenamearray.end(),comparefilename);
		if (filenamearray.size()==0)
			return "";
		else
		{
			if (flagdebug3)
				for (int unsigned i=0;i<filenamearray.size();i++)
					myprintf("00279: filenamearray %08d %s\n",(int)i,filenamearray[i].filename.c_str());
			return filenamearray[filenamearray.size()-1].filename;
		}
	}
};


////////////////////////////// misc ///////////////////////////////////
//zpaq
// For libzpaq output to a string less than 64K chars
struct StringWriter: public libzpaq::Writer {
  string s;
  void put(int c) {
    if (s.size()>=65535) error("string too long");
    s+=char(c);
  }
};
// enum for version
///static const int64_t HT_BAD=   -0x7FFFFFFFFFFFFFFALL;  // no such frag
static const int64_t DEFAULT_VERSION=99999999999999LL; // unless -until
// fragment hash table entry
struct HT
{
	uint32_t crc32;			// new: take the CRC-32 of the fragment
	uint32_t crc32size;
	unsigned char sha1[20]; // fragment hash
	int usize;      		// uncompressed size, -1 if unknown, -2 if not init
	int64_t csize;  		// if >=0 then block offset else -fragment number
	double estimatedratio;
	HT(const char* s=0, int u=-2)
	{
		crc32=0;
		crc32size=0;
		csize=0;
		estimatedratio=0;
		if (s)
			memcpy(sha1, s, 20);
		else
			memset(sha1, 0, 20);
		usize=u;
	}
};

/// a "fake" class to mimic normal filesystem write, reducing coding complexity
class franzfs
{
	private:
	public:
	char*		data;
	char		space[16];
	uint64_t	filesize;
	uint64_t 	position;
	
	void seekstart()
	{
		if (!data)
		{
			myprintf("00304! Guru data is null in seek start\n");
			return;
		}
		if (filesize==0)
		{
			myprintf("00305! Guru filesize is zero seek start\n");
			return;
		}
		position=0;
	}

	size_t ramread(size_t i_size,char* o_ptr)
	{
		if (o_ptr==NULL)
			return 0;
		if (i_size==0)
			return 0;
		if (!data)
		{
			myprintf("00306! Guru data is null\n");
			return 0;
		}
		
		if ((position+i_size)>filesize)
			i_size=filesize-position;
		memcpy(o_ptr,data+position,i_size);
		position+=i_size;
	///	myprintf("00307: letti %21s posizione %21s\n",migliaia(i_size),migliaia2(position));
		return i_size;
	}
	size_t ramwrite(uint64_t i_offset,const char* i_ptr, size_t i_size)
	{	
		if (i_offset>filesize)
		{
			myprintf("00308: i_offset greater then filesize %s %s\n",migliaia((int64_t)i_offset),migliaia2((int64_t)filesize));
			return 0;
		}
		if (i_ptr==NULL)
			return 0;
		
		if (i_size==0)
			return 0;
		
		if (!data)
		{
			myprintf("00309! Guru data is null\n");
			seppuku();
			return 0;
		}
		position=i_offset;
		if (position+i_size>filesize)
		{
			myprintf("00310! cannot write beyond size %s %s %s\n",migliaia((int64_t)position),migliaia2((int64_t)i_size),migliaia3((int64_t)filesize));
			return 0;
		}
		memcpy(data+position,i_ptr,i_size);
		position+=i_size;
		return i_size;
	}
	franzfs(){data=NULL;position=0;}
	bool init(int64_t i_size)
	{
///		myprintf("00311: init1\n");
		data=(char*)franz_malloc(i_size);
		///g_allocatedram+=i_size;
	///	myprintf("00312: init2\n");
		if (data==NULL)
		{
			myprintf("00313! GURU on malloc\n");
			return false;
		}
		///myprintf("00314: init3\n");
		memset(data,0,i_size); // required by zpaq extraction method
		///myprintf("00315: init4\n");
		
		g_ramdisksize+=i_size;
		filesize=i_size;
#ifndef ESX
		if (flagdebug2)
			myprintf("00316: allocated %21s data %s\n",migliaia(i_size),migliaia2(int64_t(data)));
#endif
		return true;
	}
	bool reset()
	{
		if (data==NULL)
		{
			myprintf("00317! GURU on reset\n");
			return false;
		}
		if (filesize==0)
		{
			myprintf("00318! GURU on filesize\n");
			return false;
		}
		franz_free(data);
		g_ramdisksize-=filesize;
		filesize=0;
#ifndef ESX
		if (flagdebug2)
			myprintf("00319: Deallocated  %s\n",migliaia((int64_t)filesize));
#endif
		return true;
	}
	
	size_t append(const char* i_ptr, size_t i_size)
	{	
		if (i_ptr==NULL)
			return 0;
		
		if (i_size==0)
			return 0;
		
		if (!data)
		{
			myprintf("00332! Guru data is null\n");
			seppuku();
			return 0;
		}
		if (position+i_size>filesize)
		{
			myprintf("50052! cannot write beyond size %s %s %s\n",migliaia((int64_t)position),migliaia2((int64_t)i_size),migliaia3((int64_t)filesize));
			return 0;
		}
		///myprintf("50050: Ready to copy with filesize %s on position %s with size %s\n",migliaia3(filesize),migliaia(position),migliaia2(i_size));
		
		memcpy(data+position,i_ptr,i_size);
		position+=i_size;
		return i_size;
	}
};

#define	FIX_TOOLONG 	1;
#define	FIX_ADS 		2;
#define	FIX_UTF8		4;
#define FIX_RESERVED 	8;
#define FIX_WINDOWSPATH	16;
#define	FIX_WINDOWSUNC	32;
#define	FIX_RELATIVE	64;

#define WORK_NONE		0
#define	WORK_UPDATED	1
#define	WORK_ADDED		2
#define	WORK_REMOVED	3

// filename entry
struct DT   // if you get some warning here, update your compiler!
{
	int64_t date;          	// if you get some warning here, update your compiler!
	// decimal YYYYMMDDHHMMSS (UT) or 0 if deleted
	int64_t size;          	// size or -1 if unknown
	int64_t attr;          	// first 8 attribute bytes
	int64_t data;          	// sort key or frags written. -1 = do not write
	int64_t creationdate; 	// on windows, linux/freebsd/mac... maybe
	int64_t accessdate; 	// on windows
	vector<unsigned> ptr;  	// fragment list
	int 	written;		// 0..ptr.size() = fragments output. -1=ignore
	bool	isordered;		//	fragments in a single ordered chunk
	bool	isselected;
	string 	hexhash;		// for new functions, not for add
	string 	hashtype;		// for paranoid()
	string	hexcrc32;
/// guilist
	string 			outputname;		// written filename

	int				franz_block_size;
	char 			*franz_block;//[FRANZOFFSETV3];
	uint32_t 		file_crc32;
	int64_t			hashedsize;
	int				chunk;
	int64_t			expectedsize;
	int				version;
	bool			forceadd;

	bool			is4;
	uint64_t 		red_total;
	int		 		red_count;
	int				red_min;
	int				red_max;
	int				red_avg;
	uint64_t 		red_candidate;

	bool			isedt;
/// now using pointer to shrink DT from more then 1K to 296 bytes
	XXH3_state_t	*pfile_xxh3;  // this is the problem: XXH3's 64-byte align not always work with too old-too new compilers
    XXHash64 		*pfile_xxhash64;
	libzpaq::SHA256 *pfile_sha256;
	libzpaq::SHA1 	*pfile_sha1;
	SHA3			*pfile_sha3;
	MD5				*pfile_md5;
	blake3_hasher 	*pfile_blake3;
	NESSIEstruct	*pfile_whirlpool;
	HighwayHashCat 	*pfile_highway64;


	franzfs			*pramfile;
	int64_t 	kompressedsize;
	int		filework; //0 = nothing; 1=updated; 2=added, 3=removed
	DT(): date(0), size(0), attr(0), data(0),creationdate(0),accessdate(0),written(-1),isordered(false),isselected(false),/*franz_block_size(FRANZOFFSETV3),*/file_crc32(0),hashedsize(0),chunk(-1),expectedsize(0),version(0),forceadd(false),is4(false),red_total(0),red_count(0),red_min(256),red_max(0),red_avg(0),red_candidate(0),isedt(false),kompressedsize(0),filework(0)
	{
///	let's save a bit of RAM (during compression)
		franz_block_size=FRANZOFFSETV3;

		if (command=='a')
			if (flagfrugal)
			{
				franz_block_size=FRANZOFFSETV2;
				if ((g_franzotype==FRANZO_CRC_32) || (g_franzotype==FRANZO_XXHASH64) || (g_franzotype==FRANZO_XXHASH64B)||(g_franzotype==FRANZO_MD5B)||(g_franzotype==FRANZO_BLAKE3B)||
				(g_franzotype==FRANZO_SHA_256B)||(g_franzotype==FRANZO_SHA3B)||(g_franzotype==FRANZO_XXH3B)||(g_franzotype==FRANZO_SHA_1B))
					franz_block_size=FRANZOFFSETV1;
				else
				if (flagtar)
					franz_block_size=FRANZOFFSETV3;
				if (flagnochecksum)
					franz_block_size=0;
			}
			
///		myprintf("00320: franz_block_size %d  franzo_type %d |%c|\n",franz_block_size,g_franzotype,command);
		
		franz_block=NULL;
		if (franz_block_size>0)
		{
			franz_block=(char*)franz_malloc(franz_block_size);
			if (franz_block==NULL)
			{
				myprintf("00321! cannot franz_malloc\n");
				seppuku();
			}
			memset(franz_block,0,franz_block_size);
			g_dt_ram+=franz_block_size;
			g_allocatedram-=franz_block_size; // (updated in franz_malloc)
		}
		//g_dt_ram+=franz_block_size+sizeof(DT);
		
		hexhash			="";
		hexcrc32		="";
		///specificmethod	='Z';
		hashtype		="";
		outputname		="";
		///listtext		="";
		///fragmentlisthash="";
		pfile_highway64=NULL;
		if ((g_franzotype==FRANZO_HIGHWAY64) || (g_franzotype==FRANZO_HIGHWAY128) || (g_franzotype==FRANZO_HIGHWAY256))
		{
			pfile_highway64=new HighwayHashCat;
			uint64_t key[4] = {1, 2, 3, 4};
			HighwayHashCatStart(key,pfile_highway64);
			g_dt_ram+=sizeof(HighwayHashCat);
		
		}
		pfile_xxhash64=NULL;
		if ((g_franzotype==FRANZO_XXHASH64) || (g_franzotype==FRANZO_WINHASH64) || (g_franzotype==FRANZO_XXHASH64B))
		{
			pfile_xxhash64=new XXHash64(0);
			g_dt_ram+=sizeof(XXHash64);
		}
		pfile_md5=NULL;
		if ((g_franzotype==FRANZO_MD5) || (g_franzotype==FRANZO_MD5B))
		{
			pfile_md5=new MD5;
			g_dt_ram+=sizeof(MD5);
		}
		pfile_sha1=NULL;
		if ((g_franzotype==FRANZO_SHA_1)||(g_franzotype==FRANZO_SHA_1B))
		{
			pfile_sha1=new libzpaq::SHA1; ///You get this warning before C++17
			g_dt_ram+=sizeof(libzpaq::SHA1);	
		}
		pfile_sha256=NULL;
		if ((g_franzotype==FRANZO_SHA_256)||(g_franzotype==FRANZO_SHA_256B))
		{
			pfile_sha256=new libzpaq::SHA256; ///You get this warning before C++17
			g_dt_ram+=sizeof(libzpaq::SHA256);	
		}
		pfile_sha3=NULL;
		if ((g_franzotype==FRANZO_SHA3)||(g_franzotype==FRANZO_SHA3B))
		{
			pfile_sha3=new SHA3;
			g_dt_ram+=sizeof(SHA3);	
		}
	/// beware of time and space, but now we are sure to maintain 64 byte alignment
		pfile_whirlpool=NULL;
		if (g_franzotype==FRANZO_WHIRLPOOL)
		{
			pfile_whirlpool=new NESSIEstruct;
			NESSIEinit(pfile_whirlpool);
			g_dt_ram+=sizeof(NESSIEstruct);	
		}
		pfile_xxh3=NULL;
		if ((g_franzotype==FRANZO_XXH3)||(g_franzotype==FRANZO_XXH3B))
		{
			pfile_xxh3=(XXH3_state_t*)aligned_malloc(64, sizeof(XXH3_state_t));
			(void)XXH3_128bits_reset(pfile_xxh3);
			g_dt_ram+=sizeof(XXH3_state_t);
		}
		pfile_blake3=NULL;
		if ((g_franzotype==FRANZO_BLAKE3)||(g_franzotype==FRANZO_BLAKE3B))
		{
			pfile_blake3=(blake3_hasher*)franz_malloc(sizeof(blake3_hasher));
			blake3_hasher_init(pfile_blake3);
			g_dt_ram+=sizeof(blake3_hasher);	
		}
		pramfile=NULL;
	}
	/* too slow
	~DT() 
	{
		if (pfile_highway64)
		{
			delete pfile_highway64;
			pfile_highway64=NULL;
		}
		if (pfile_xxhash64)
		{
			delete pfile_xxhash64;
			pfile_xxhash64=NULL;
		}
		if (pfile_md5)
		{
			delete pfile_md5;
			pfile_md5=NULL;
		}
		if (pfile_sha1)
		{
			delete pfile_sha1;
			pfile_sha1=NULL;
		}
		if (pfile_sha256)
		{
			delete pfile_sha256;
			pfile_sha256=NULL;
		}
		if (pfile_sha3)
		{
			delete pfile_sha3;
			pfile_sha3=NULL;
		}
		if (pfile_whirlpool)
		{
			delete pfile_whirlpool;
			pfile_whirlpool=NULL;
		}
		if (pfile_xxh3)
		{
			aligned_free(pfile_xxh3);
			pfile_xxh3=NULL;
		}
		if (pfile_blake3)
		{
			franz_free(pfile_blake3);
			pfile_blake3=NULL;
		}
	}
	*/
};
typedef std::map<string, DT> DTMap;


// list of blocks to extract
struct Block
{
  int64_t offset;       // location in archive
  int64_t usize;        // uncompressed size, -1 if unknown (streaming)
  int64_t bsize;        // compressed size
  vector<DTMap::iterator> files;  // list of files pointing here
  unsigned start;       // index in ht of first fragment
  unsigned size;        // number of fragments to decompress
  unsigned frags;       // number of fragments in block
  unsigned extracted;   // number of fragments decompressed OK
  enum {READY, WORKING, GOOD, BAD} state;
  Block(unsigned s, int64_t o): offset(o), usize(-1), bsize(0), start(s),
      size(0), frags(0), extracted(0), state(READY) {}
};
// Version info
struct VER
{
  int64_t date;          // Date of C block, 0 if streaming
  int64_t lastdate;      // Latest date of any block
  int64_t offset;        // start of transaction C block
  int64_t data_offset;   // start of first D block
  int64_t csize;         // size of compressed data, -1 = no index
  int updates;           // file updates
  int deletes;           // file deletions
  unsigned firstFragment;// first fragment ID
  int64_t usize;         // uncompressed size of files
  VER() {memset(this, 0, sizeof(*this));}
};
// Windows API functions not in Windows XP to be dynamically loaded
#ifndef unix
typedef HANDLE (WINAPI* FindFirstStreamW_t)
                   (LPCWSTR, STREAM_INFO_LEVELS, LPVOID, DWORD);
FindFirstStreamW_t findFirstStreamW=0;
typedef BOOL (WINAPI* FindNextStreamW_t)(HANDLE, LPVOID);
FindNextStreamW_t findNextStreamW=0;
typedef BOOL (WINAPI* GetFinalPathNameByHandleW_t)(HANDLE, LPWSTR,DWORD,DWORD);
GetFinalPathNameByHandleW_t getFinalPathNameByHandleW=0;
#endif // corresponds to #ifndef (#ifndef unix)
typedef std::map<int64_t,string> int64tstringmap;
typedef std::map<string,string> stringstringmap;
class CompressJob;


typedef void (*callback_function)(char*); // type for conciseness


/*

Portion to list the contents of zpaq files in the most concise way possible, 
to reduce the time necessary for subsequent uses (e.g. from GUIs written in other languages),
on Windows.

Like this https://github.com/fcorbelli/zpaqlist

A classic method for an extracting GUI for zpaq is to redirect the output of the command
zpaq l (list) to a temporary file, read it, parse and then process, but it takes time.

The output of zpaqlist (or zpaqfranz with the brand-new pakka command) is composed by

- version #
!1266

- version list
|      1 2019-05-12 15:42:22
|      2 2019-05-13 09:22:49
|      3 2019-05-14 17:18:06
|      4 2019-05-16 14:17:25
|      5 2019-05-16 15:30:17
|      6 2019-05-16 23:30:17
(...)

- total row number (with +)
+38915424

- sorted by version and file name (for a time machine-like use) 
- and, by default, does not duplicate identical file names.
- version_number
- datetime (or D for deleted)
- size (with dots)
- filename or ? (if not changed from previous)
Example (two record)
The file f:/zarc/ihsv/pakka/30_3/zpaqfranz.exe is 3.089.462 bytes long,
and was found in the 946 version, @ 02/10/2020 14:25:34  (European-style date format)
In the version 959 the file result deleted (not present)

-946
02/10/2020 14:25:34
3.089.462
f:/zarc/ihsv/pakka/30_3/zpaqfranz.exe
-959
D
0
?

When the size of the output is large (and can even be hundreds of MB) 
the savings both in writing (on magnetic disks), reading and parsing 
can be considerable. 

For small archives (KB) there is obviously no difference compared to zpaq
*/

int64_t list_global_start=0;  // set to mtime() at start of main()


#ifdef _WIN32
namespace libzpaq2 {
	
/*
This is similar, but NOT equal, to newer libzpaq
A bit of Frankenstein, to incorporate older 6.60 inside 7.15-based source
*/

// Symbolic constants, instruction size, and names
typedef enum {LIST_NONE,LIST_CONS,LIST_CM,ILIST_CM,LIST_MATCH,LIST_AVG,LIST_LIST_MIX2,
LIST_MIX,LIST_ILIST_SSE,LIST_SSE} list_CompType;

///////////////////////// Predictor //////////////////////////


// Decoder decompresses using an arithmetic code
class list_Decoder {
public:
  libzpaq::Reader* in;        // destination
  list_Decoder(libzpaq::ZPAQL& z);
  int decompress();  // return a byte or EOF
  int skip();        // skip to the end of the segment, return next byte
  void init();       // initialize at start of block
  int stat(int x) {return pr.stat(x);}
private:
  U32 low, high;     // range
  U32 curr;          // last 4 bytes of archive
  libzpaq::Predictor pr;      // to get p
  enum {BUFSIZE=1<<16};
  libzpaq::Array<char> buf;   // input buffer of size BUFSIZE bytes
    // of unmodeled data. buf[low..high-1] is input with curr
    // remaining in sub-block.
  int decode(int p); // return decoded bit (0..1) with prob. p (0..65535)
  void loadbuf();    // read unmodeled data into buf to EOS
};


//////////////////////// list_Decompresser ////////////////////////

// For decompression and listing archive contents
class list_Decompresser {
public:
  list_Decompresser(): z(), dec(z), pp(), state(BLOCK), decode_state(FIRSTSEG) {}
  void setInput(libzpaq::Reader* in) {dec.in=in;}
  bool findBlock(double* memptr = 0);
  void hcomp(libzpaq::Writer* out2) {z.write(out2, false);}
  bool findFilename(libzpaq::Writer* = 0);
  void readComment(libzpaq::Writer* = 0);
  void setOutput(libzpaq::Writer* out) {pp.setOutput(out);}
  void setSHA1(libzpaq::SHA1* sha1ptr) {pp.setSHA1(sha1ptr);}
  bool decompress(int n = -1);  // n bytes, -1=all, return true until done
  bool pcomp(libzpaq::Writer* out2) {return pp.z.write(out2, true);}
  void readSegmentEnd(char* sha1string = 0);
  int stat(int x) {return dec.stat(x);}
private:
  libzpaq::ZPAQL z;
  list_Decoder dec;
  libzpaq::PostProcessor pp;
  enum {BLOCK, FILENAME, COMMENT, DATA, SEGEND} state;  // expected next
  enum {FIRSTSEG, SEG, SKIP} decode_state;  // which segment in block?
};
/////////////////////// Decoder ///////////////////////

list_Decoder::list_Decoder(libzpaq::ZPAQL& z):
    in(0), low(1), high(0xFFFFFFFF), curr(0), pr(z), buf(BUFSIZE) {
}

void list_Decoder::init() {
  pr.init();
  if (pr.isModeled()) low=1, high=0xFFFFFFFF, curr=0;
  else low=high=curr=0;
}

// Read un-modeled input into buf[low=0..high-1]
// with curr remaining in subblock to read.
void list_Decoder::loadbuf() {
 
  if (curr==0) {
    for (int i=0; i<4; ++i) {
      int c=in->get();
      if (c<0) libzpaq::error("unexpected end of input");
      curr=curr<<8|c;
    }
  }
  U32 n=buf.size();
  if (n>curr) n=curr;
  high=in->read(&buf[0], n);
  curr-=high;
  low=0;
}

// Return next bit of decoded input, which has 16 bit probability p of being 1
int list_Decoder::decode(int p) {

  if (curr<low || curr>high) libzpaq::error("archive corrupted");

  U32 mid=low+U32(((high-low)*U64(U32(p)))>>16);  // split range
 
  int y;
  if (curr<=mid) y=1, high=mid;  // pick half
  else y=0, low=mid+1;
  while ((high^low)<0x1000000) { // shift out identical leading bytes
    high=high<<8|255;
    low=low<<8;
    low+=(low==0);
    int c=in->get();
    if (c<0) libzpaq::error("unexpected end of file");
    curr=curr<<8|c;
  }
  return y;
}

// Decompress 1 byte or -1 at end of input
int list_Decoder::decompress() {
  if (pr.isModeled()) {  // n>0 components?
    if (curr==0) {  // segment initialization
      for (int i=0; i<4; ++i)
        curr=curr<<8|in->get();
    }
    if (decode(0)) {
      if (curr!=0) libzpaq::error("decoding end of stream");
      return -1;
    }
    else {
      int c=1;
      while (c<256) {  // get 8 bits
        int p=pr.predict()*2+1;
        c+=c+decode(p);
        pr.update(c&1);
      }
      return c-256;
    }
  }
  else {
    if (low==high) loadbuf();
    if (low==high) return -1;
    return buf[low++]&255;
  }
}

// Find end of compressed data and return next byte
int list_Decoder::skip() {
  int c=-1;
  if (pr.isModeled()) {
    while (curr==0)  // at start?
      curr=in->get();
    while (curr && (c=in->get())>=0)  // find 4 zeros
      curr=curr<<8|c;
    while ((c=in->get())==0) ;  // might be more than 4
    return c;
  }
  else {
    if (curr==0)  // at start?
      for (int i=0; i<4 && (c=in->get())>=0; ++i) curr=curr<<8|c;
    while (curr>0) {
      U32 n=BUFSIZE;
      if (n>curr) n=curr;
      U32 n1=in->read(&buf[0], n);
      curr-=n1;
      if (n1<1) return -1;
      if (curr==0)
        for (int i=0; i<4 && (c=in->get())>=0; ++i) curr=curr<<8|c;
    }
    if (c>=0) c=in->get();
    return c;
  }
}


// Find the start of a block and return true if found. Set memptr
// to memory used.
bool list_Decompresser::findBlock(double* memptr) {
  ///printf("08116: findblock\n");

  // Find start of block
  U32 h1=0x3D49B113, h2=0x29EB7F93, h3=0x2614BE13, h4=0x3828EB13;
  // Rolling hashes initialized to hash of first 13 bytes
  int c;
  ///int64_t startct=0;
  while ((c=dec.in->get())!=-1) {
///	printf("08122: getted c %03d startct %08d\n",c,startct++);
    h1=h1*12+c;
    h2=h2*20+c;
    h3=h3*28+c;
    h4=h4*44+c;
    if (h1==0xB16B88F1 && h2==0xFF5376F1 && h3==0x72AC5BF1 && h4==0x2F909AF1)
      break;  // hash of 16 byte string
  }
  if (c==-1) return false;

  // Read header
  if ((c=dec.in->get())!=1 && c!=2) libzpaq::error("unsupported ZPAQ level");
  if (dec.in->get()!=1) libzpaq::error("unsupported list_ZPAQL type");
  z.read(dec.in);
  if (c==1 && z.header.isize()>6 && z.header[6]==0)
    libzpaq::error("ZPAQ level 1 requires at least 1 component");
  if (memptr) *memptr=z.memory();
  state=FILENAME;
  decode_state=FIRSTSEG;
  ///printf("08144: dec %08d\n",dec.in->ftell());
    ///printf("08144: dec %08d\n",dec.in->tell());
  return true;
}

// Read the start of a segment (1) or end of block code (255).
// If a segment is found, write the filename and return true, else false.
bool list_Decompresser::findFilename(libzpaq::Writer* filename) {

  int c=dec.in->get();
  if (c==1) {  // segment found
    while (true) {
      c=dec.in->get();
      if (c==-1) libzpaq::error("unexpected EOF");
      if (c==0) {
        state=COMMENT;
        return true;
      }
      if (filename) filename->put(c);
    }
  }
  else if (c==255) {  // end of block found
    state=BLOCK;
    return false;
  }
  else
    libzpaq::error("missing segment or end of block");
  return false;
}

// Read the comment from the segment header
void list_Decompresser::readComment(libzpaq::Writer* comment) {
 
  state=DATA;
  while (true) {
    int c=dec.in->get();
    if (c==-1) libzpaq::error("unexpected EOF");
    if (c==0) break;
    if (comment) comment->put(c);
  }
  if (dec.in->get()!=0) libzpaq::error("missing reserved byte");
}

// Decompress n bytes, or all if n < 0. Return false if done
bool list_Decompresser::decompress(int n) {
  

  // Initialize models to start decompressing block
  if (decode_state==FIRSTSEG) {
    dec.init();
   
    pp.init(z.header[4], z.header[5]);
    decode_state=SEG;
  }

  // Decompress and load PCOMP into postprocessor
  while ((pp.getState()&3)!=1)
    pp.write(dec.decompress());

  // Decompress n bytes, or all if n < 0
  while (n) {
    int c=dec.decompress();
    pp.write(c);
    if (c==-1) {
      state=SEGEND;
      return false;
    }
    if (n>0) --n;
  }
  return true;
}

// Read end of block. If a SHA1 checksum is present, write 1 and the
// 20 byte checksum into sha1string, else write 0 in first byte.
// If sha1string is 0 then discard it.
void list_Decompresser::readSegmentEnd(char* sha1string) {
  // Skip remaining data if any and get next byte
  int c=0;
  if (state==DATA) {
    c=dec.skip();
    decode_state=SKIP;
  }
  else if (state==SEGEND)
    c=dec.in->get();
  state=FILENAME;

  // Read checksum
  if (c==254) {
    if (sha1string) sha1string[0]=0;  // no checksum
  }
  else if (c==253) {
    if (sha1string) sha1string[0]=1;
    for (int i=1; i<=20; ++i) {
      c=dec.in->get();
      if (sha1string) sha1string[i]=c;
    }
  }
  else
    libzpaq::error("missing end of segment marker");
}
}  // end namespace libzpaq2





// Global variables
int64_t list_g_dimensione=0;

FILE* list_outputlog=stdout;
FILE* list_con=stdout;    // log output, can be stderr
static const int64_t LIST_MAX_QUIET=0x7FFFFFFFFFFFFFFFLL;  // no output but errors

// signed size of a string or vector
template <typename T> int list_size(const T& x) {
  return x.size();
}

// In Windows, convert 16-bit wide string to UTF-8 and \ to /
string list_wtou(const wchar_t* s) {

  string r;
  if (!s) return r;
  for (; *s; ++s) {
    if (*s=='\\') r+='/';
    else if (*s<128) r+=*s;
    else if (*s<2048) r+=192+*s/64, r+=128+*s%64;
    else r+=224+*s/4096, r+=128+*s/64%64, r+=128+*s%64;
  }
  return r;
}

// In Windows, convert UTF-8 string to wide string ignoring
// invalid UTF-8 or >64K. If doslash then convert "/" to "\".
std::wstring list_utow(const char* ss, bool doslash=false) {


  std::wstring r;
  if (!ss) return r;
  const unsigned char* s=(const unsigned char*)ss;
  for (; s && *s; ++s) {
    if (s[0]=='/' && doslash) r+='\\';
    else if (s[0]<128) r+=s[0];
    else if (s[0]>=192 && s[0]<224 && s[1]>=128 && s[1]<192)
      r+=(s[0]-192)*64+s[1]-128, ++s;
    else if (s[0]>=224 && s[0]<240 && s[1]>=128 && s[1]<192
             && s[2]>=128 && s[2]<192)
      r+=(s[0]-224)*4096+(s[1]-128)*64+s[2]-128, s+=2;
  }
  return r;
}

// Print a UTF-8 string to f (stdout, stderr) so it displays properly
void list_printutf8(const char* s, FILE* f) {

  const HANDLE h=(HANDLE)_get_osfhandle(_fileno(f));
  DWORD ft=GetFileType(h);
  if (ft==FILE_TYPE_CHAR) {
    fflush(f);
    std::wstring w=list_utow(s);  // Windows console: convert to UTF-16
    DWORD n=0;
    WriteConsole(h, w.c_str(), w.size(), &n, 0);
  }
  else  // stdout redirected to file
    fprintf(f, "%s", s);
}

// Convert 64 bit decimal YYYYMMDDHHMMSS to "YYYY-MM-DD HH:MM:SS"
// where -1 = unknown date, 0 = deleted.
string list_dateToString(int64_t date) {
  if (date<=0) return "                   ";
  string s="0000-00-00 00:00:00";
  static const int t[]={18,17,15,14,12,11,9,8,6,5,3,2,1,0};
  for (int i=0; i<14; ++i) s[t[i]]+=int(date%10), date/=10;
  return s;
}
string list_mydateToString(int64_t date) {
  if (date<=0) return "                   ";
  ///        0123456789012345678
  string  s="0000-00-00 00:00:00";
  string s2="00/00/0000 00:00:00";
  
  
  static const int t[]={18,17,15,14,12,11,9,8,6,5,3,2,1,0};
  for (int i=0; i<14; ++i) s[t[i]]+=int(date%10), date/=10;

/// convert in european date format dd/mm/yyyy hh:mm:ss
  s2[0]=s[8];
  s2[1]=s[9];
  s2[3]=s[5];
  s2[4]=s[6];
  s2[6]=s[0];
  s2[7]=s[1];
  s2[8]=s[2];
  s2[9]=s[3];
  
  s2[11]=s[11];
  s2[12]=s[12];
  
  s2[14]=s[14];
  s2[15]=s[15];
  
  s2[17]=s[17];
  s2[18]=s[18];
  return s2;
}



/////////////////////////////// File //////////////////////////////////

// Convert non-negative decimal number x to string of at least n digits
string list_itos(int64_t x, int n=1) {

  string r;
  for (; x || n>0; x/=10, --n) r=string(1, '0'+x%10)+r;
  return r;
}

// Replace * and ? in fn with part or digits of part
string list_subpart(string fn, int part) {
  for (int j=fn.size()-1; j>=0; --j) {
    if (fn[j]=='?')
      fn[j]='0'+part%10, part/=10;
    else if (fn[j]=='*')
      fn=fn.substr(0, j)+list_itos(part)+fn.substr(j+1), part=0;
  }
  return fn;
}

// Return true if a file or directory (UTF-8 without trailing /) list_exists.
// If part>0 then replace * and ? in filename with part or its digits.
bool list_exists(string filename, int part=0) 
{
  if (part>0) filename=list_subpart(filename, part);
  int len=filename.size();
  if (len<1) return false;
  if (filename[len-1]=='/') filename=filename.substr(0, len-1);
  return GetFileAttributes(list_utow(filename.c_str(), true).c_str())
         !=INVALID_FILE_ATTRIBUTES;
}


// Print error message
void list_printerr(const char* filename) 
{
#ifdef _WIN32
  int err=GetLastError();
  list_printutf8(filename, stderr);
  if (err==ERROR_FILE_NOT_FOUND)
    fprintf(stderr, ": file not found\n");
  else if (err==ERROR_PATH_NOT_FOUND)
    fprintf(stderr, ": path not found\n");
  else if (err==ERROR_ACCESS_DENIED)
    fprintf(stderr, ": access denied\n");
  else if (err==ERROR_SHARING_VIOLATION)
    fprintf(stderr, ": sharing violation\n");
  else if (err==ERROR_BAD_PATHNAME)
    fprintf(stderr, ": bad pathname\n");
  else if (err==ERROR_INVALID_NAME)
    fprintf(stderr, ": invalid name\n");
  else
    fprintf(stderr, ": Windows error %d\n", err);
#else
    fprintf(stderr, ": nix error\n");
	
#endif // corresponds to #ifdef (#ifdef _WIN32)
}

// Base class of InputFile and list_OutputFile (OS independent)
class list_File {
protected:
  enum {BUFSIZE=1<<16};  // buffer size
  int ptr;  // next byte to read or write in buf
  libzpaq::Array<char> buf;  // I/O buffer
  libzpaq::AES_CTR *aes;  // if not NULL then encrypt
  int64_t eoff;  // extra offset for multi-file encryption
  list_File(): ptr(0), buf(BUFSIZE), aes(0), eoff(0) {}
};

// list_File types accepting UTF-8 filenames

class list_InputFile: public list_File, public libzpaq::Reader {
  HANDLE in;  // input file handle
  DWORD n;    // buffer size
public:
  list_InputFile():
    in(INVALID_HANDLE_VALUE), n(0) {}

  // Open for reading. Return true if successful.
  // Encrypt with aes+e if aes.
  bool open(const char* filename, libzpaq::AES_CTR* a=0, int64_t e=0) {

    n=ptr=0;
    std::wstring w=list_utow(filename, true);
    in=CreateFile(w.c_str(), GENERIC_READ, FILE_SHARE_READ, NULL,
                  OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
    if (in==INVALID_HANDLE_VALUE) list_printerr(filename);
    aes=a;
    eoff=e;
    return in!=INVALID_HANDLE_VALUE;
  }

  bool isopen() {return in!=INVALID_HANDLE_VALUE;}

  // Read 1 byte
  int get() {
    if (ptr>=int(n)) {

      ptr=0;
      ReadFile(in, &buf[0], BUFSIZE, &n, NULL);
      if (n==0) return EOF;
      if (aes) {
        int64_t off=tell()+eoff;
        if (off<32) libzpaq::error("attempt to read salt");
        aes->encrypt(&buf[0], n, off);
      }
    }

    return buf[ptr++]&255;
  }

  // set file pointer
  void seek(int64_t pos, int whence) {
    if (whence==SEEK_SET) whence=FILE_BEGIN;
    else if (whence==SEEK_END) whence=FILE_END;
    else if (whence==SEEK_CUR) {
      whence=FILE_BEGIN;
      pos+=tell();
    }
    long offhigh=pos>>32;
    SetFilePointer(in, pos, &offhigh, whence);
    n=ptr=0;
  }

  // get file pointer
  int64_t tell() {
    long offhigh=0;
    DWORD r=SetFilePointer(in, 0, &offhigh, FILE_CURRENT);
    return (int64_t(offhigh)<<32)+r+ptr-n;
  }

  // Close handle if open
  void close() {
    if (in!=INVALID_HANDLE_VALUE) {
      CloseHandle(in);
      in=INVALID_HANDLE_VALUE;
    }
  }
  ~list_InputFile() {close();}
};


/////////////////////////////// list_Archive ///////////////////////////////

// An list_Archive is a multi-part file that supports encrypted input
class list_Archive: public libzpaq::Reader, public libzpaq::Writer {
  libzpaq::AES_CTR* aes;  // NULL if not encrypted
  struct FE {  // list_File element for multi-part archives
    string fn;    // file name
    int64_t end;  // size of previous and current files
    FE(): end(0) {}
    FE(const string& s, int64_t e): fn(s), end(e) {}
  };
  vector<FE> files;  // list of parts. only last part is writable.
  int fi;  // current file in files
  int64_t listoff;  // total offset over all files
  int mode;     // 'r' or 'w' for reading or writing or 0 if closed
  list_InputFile in; // currently open input file
///  list_OutputFile out;  // currently open output file
public:

  // Constructor
  list_Archive(): aes(0), fi(0), listoff(0), mode(0) {}

  // Destructor
  ~list_Archive() {close();}

  // Open filename for read and write. If filename contains wildards * or ?
  // then replace * with part number 1, 2, 3... or ? with single digits
  // up to the last existing file. Return true if at least one file is found.
  // If password is not NULL then assume the concatenation of the files
  // is in encrypted format. mode_ is 'r' for reading or 'w' for writing.
  // If the filename contains wildcards then output is to the first
  // non-existing file, else to filename. If newsize>=0 then truncate
  // the output to newsize bytes. If password and offset>0 then encrypt
  // output as if previous parts had size offset and salt salt.
  bool open(bool i_quiet,const char* filename, const char* password=0, int mode_='r',
            int64_t newsize=-1, int64_t offset=0, const char* salt=0);

  // True if archive is open
  bool isopen() const {return files.size()>0;}

  // Position the next read or write offset to p.
  void seek(int64_t p, int whence);

  // Return current file offset.
  int64_t tell() const {return listoff;}

  // Read up to n bytes into buf at current offset. Return 0..n bytes
  // actually read. 0 indicates EOF.
  int read(char* buf, int n) {

    if (fi>=list_size(files)) return 0;
    if (!in.isopen()) return 0;
    n=in.read(buf, n);
    seek(n, SEEK_CUR);
    return n;
  }

  // Read and return 1 byte or -1 (EOF)
  int get() {

    if (fi>=list_size(files)) return -1;
    while (listoff==files[fi].end) {
      in.close();
      if (++fi>=list_size(files)) return -1;
      if (!in.open(files[fi].fn.c_str(), aes, fi>0 ? files[fi-1].end : 0))
        libzpaq::error("cannot read next archive part");
    }
    ++listoff;
    return in.get();
  }

  // Write one byte
  void put(int c) {
    c+=3; /// nowarning please
	++listoff;
  }

  // Write buf[0..n-1]

  // Close any open part
  void close() {
    if (in.isopen()) in.close();
    if (aes) {
      delete aes;
      aes=0;
    }
    files.clear();
    fi=0;
    listoff=0;
    mode=0;
  }
};


void list_print_datetime(void)
{
	int hours, minutes, seconds, day, month, year;

	time_t now;
	time(&now);
	struct tm *local = localtime(&now);

	hours = local->tm_hour;			// get hours since midnight	(0-23)
	minutes = local->tm_min;		// get minutes passed after the hour (0-59)
	seconds = local->tm_sec;		// get seconds passed after the minute (0-59)

	day = local->tm_mday;			// get day of month (1 to 31)
	month = local->tm_mon + 1;		// get month of year (0 to 11)
	year = local->tm_year + 1900;	// get year since 1900

	printf("%02d/%02d/%d %02d:%02d:%02d ", day, month, year, hours,minutes,seconds);

}

bool list_Archive::open(bool i_quiet,const char* filename, const char* password, int mode_,
                   int64_t newsize, int64_t offset, const char* salt) {

  mode=mode_;

  list_g_dimensione=0;
  
  // Read part files and get sizes. Get salt from the first part.
  string next;

  int64_t startscan=mtime();
  int i;
  for (i=1; !offset; ++i) 
  {
    next=list_subpart(filename, i);
    
	if (!list_exists(next)) break;
    if (files.size()>0 && files[0].fn==next) break; // part overflow
	
    // set up key from salt in first file
    if (!in.open(next.c_str())) libzpaq::error("cannot read archive");
    if (i==1 && password && newsize!=0) {
      char slt[32], key[32];
      if (in.read(slt, 32)!=32) libzpaq::error("no salt");
      libzpaq::stretchKey(key, password, slt);
      aes=new libzpaq::AES_CTR(key, 32, slt);
	  g_allocatedram+=sizeof(libzpaq::AES_CTR);
		
    }

	
    // Get file size
    in.seek(0, SEEK_END);
    files.push_back(FE(next,
        in.tell()+(files.size() ? files[files.size()-1].end : 0)));
    
	list_g_dimensione+=in.tell();
	in.close();
    if (next==filename) break;  // no wildcards
  }
	if (!i_quiet)
	{
		list_print_datetime();
		printf("Multipart scan %f s chunks %d\n",(mtime()-startscan)/1000.0,i);
 	}
  // If offset is not 0 then use it for the part sizes and use
  // salt as the salt of the first part.
  if (offset>0) {
    files.push_back(FE("", offset));
    files.push_back(FE(filename, offset));
    if (password) {

      char key[32]={0};
      libzpaq::stretchKey(key, password, salt);
      aes=new libzpaq::AES_CTR(key, 32, salt);
	  g_allocatedram+=sizeof(libzpaq::AES_CTR);
		
    }
  }

  // Open file for reading
  fi=files.size();
  if (mode=='r') {
    seek(32*(password!=0), SEEK_SET);  // open first input file
    return files.size()>0;
  }
	return false;
}

void list_Archive::seek(int64_t p, int whence) {
  if (whence==SEEK_SET) listoff=p;
  else if (whence==SEEK_CUR) listoff+=p;
  else if (whence==SEEK_END) listoff=(files.size() ? files.back().end : 0)+p;
  else exit(0);
  if (mode=='r') {
    int oldfi=fi;
    for (fi=0; fi<list_size(files) && listoff>=files[fi].end; ++fi);
    if (fi!=oldfi) {
      in.close();
      if (fi<list_size(files) && !in.open(files[fi].fn.c_str(), aes,
          fi>0 ? files[fi-1].end : 0))
        libzpaq::error("cannot reopen archive after seek");
    }
    if (fi<list_size(files)) in.seek(listoff-files[fi].end, SEEK_END);
  }
}
#endif // corresponds to #ifdef (#ifdef _WIN32)

///////////////////////// NumberOfProcessors ///////////////////////////

// Guess number of cores. In 32 bit mode, max is 2.
int list_numberOfProcessors() {
  int rc=0;  // result
  // In Windows return %NUMBER_OF_PROCESSORS%
  const char* p=getenv("NUMBER_OF_PROCESSORS");
  if (p) rc=atoi(p);
  if (rc<1) rc=1;
  if (sizeof(char*)==4 && rc>2) rc=2;
  return rc;
}

////////////////////////////// StringBuffer //////////////////////////

// For libzpaq output to a string
struct list_StringWriter: public libzpaq::Writer {
  string s;
  void put(int c) {s+=char(c);}
};



// For (de)compressing to/from a string. Writing appends bytes
// which can be later read.
class list_StringBuffer: public libzpaq::Reader, public libzpaq::Writer {
  unsigned char* p;  // allocated memory, not NUL terminated, may be NULL
  size_t al;         // number of bytes allocated, 0 iff p is NULL
  size_t wpos;       // index of next byte to write, wpos <= al
  size_t rpos;       // index of next byte to read, rpos < wpos or return EOF.
  size_t limit;      // max size, default = -1
  const size_t init; // initial size on first use after reset

  // Increase capacity to a without changing size
  void reserve(size_t a) {

    if (a<=al) return;
    unsigned char* q=0;
	g_allocatedram+=a;
    if (a>0) q=(unsigned char*)(p ? realloc(p, a) : malloc(a));
    if (a>0 && !q) 
	{
#ifndef ESX
      myprintf("50937$ list_StringBuffer realloc %1.0f to %1.0f at %s failed\n",double(al), double(a), migliaia(int64_t(p)));
#endif
      libzpaq::error("Out of memory");
    }
    p=q;
    al=a;
  }

  // Enlarge al to make room to write at least n bytes.
  void lengthen(unsigned n) {

    if (wpos+n>limit) libzpaq::error("list_StringBuffer overflow");
    if (wpos+n<=al) return;
    size_t a=al;
    while (wpos+n>=a) a=a*2+init;
    reserve(a);
  }

  // No assignment or copy
  void operator=(const list_StringBuffer&);
  list_StringBuffer(const list_StringBuffer&);

public:

  // Direct access to data
  unsigned char* data() {return p;}

  // Allocate no memory initially
  list_StringBuffer(size_t n=0):
      p(0), al(0), wpos(0), rpos(0), limit(size_t(-1)), init(n>128?n:128) {}

  // Set output limit
  void setLimit(size_t n) {limit=n;}

  // Free memory
  ~list_StringBuffer() {if (p) free(p);}

  // Return number of bytes written.
  size_t size() const {return wpos;}

  // Return number of bytes left to read
  size_t remaining() const {return wpos-rpos;}

  // Reset size to 0.
  void reset() {
    if (p) free(p);
    p=0;
    al=rpos=wpos=0;
  }

  // Write a single byte.
  void put(int c) {  // write 1 byte
    lengthen(1);

    p[wpos++]=c;
  }

  // Write buf[0..n-1]
  void write(const char* buf, int n) {
    if (n<1) return;
    lengthen(n);
    memcpy(p+wpos, buf, n);
    wpos+=n;
  }

  // Read a single byte. Return EOF (-1) and reset at end of string.
  int get() {

    return rpos<wpos ? p[rpos++] : (reset(),-1);
  }

  // Read up to n bytes into buf[0..] or fewer if EOF is first.
  // Return the number of bytes actually read.
  int read(char* buf, int n) {

    if (rpos+n>wpos) n=wpos-rpos;
    if (n>0) memcpy(buf, p+rpos, n);
    rpos+=n;
    return n;
  }

  // Return the entire string as a read-only array.
  const char* c_str() const {return (const char*)p;}

  // Truncate the string to size i.
  void resize(size_t i) {wpos=i;}

  // Write a string.
  void operator+=(const string& t) {write(t.data(), t.size());}

  // Swap efficiently (init is not swapped)
  void swap(list_StringBuffer& s) {
    std::swap(p, s.p);
    std::swap(al, s.al);
    std::swap(wpos, s.wpos);
    std::swap(rpos, s.rpos);
    std::swap(limit, s.limit);
  }
};

////////////////////////////// misc ///////////////////////////////////


// Read 4 byte little-endian int and advance s
int list_btoi(const char* &s) {
  s+=4;
  return (s[-4]&255)|((s[-3]&255)<<8)|((s[-2]&255)<<16)|((s[-1]&255)<<24);
}

// Read 8 byte little-endian int and advance s
int64_t list_btol(const char* &s) {
  int64_t r=unsigned(list_btoi(s));
  return r+(int64_t(list_btoi(s))<<32);
}



#define MAX_ITERATIONS 50
#define MYEPSILON 1e-10

double custom_log(double x) 
{
#ifndef NOLM
	return log(x);
#else
    // Input checks
    if (x <= 0) return -__builtin_huge_valf(); // Handling invalid inputs
    if (x == 1.0) return 0.0; // Special case

    // Interval reduction
    int exponent = 0;
    double normalized = x;

    // Normalizza il numero tra 1 e 2
    while (normalized > 2.0) {
        normalized /= 2.0;
        exponent++;
    }
    while (normalized < 1.0) {
        normalized *= 2.0;
        exponent--;
    }

    // Logarithm calculation using Taylor series
    // ln(x) = 2 * [ (x-1)/(x+1) + (1/3)((x-1)/(x+1))³ + (1/5)((x-1)/(x+1))⁵ + ... ]
    double y = (normalized - 1.0) / (normalized + 1.0);
    double y2 = y * y;
    double result = 0.0;
    double term = y;
    
    for (int n = 1; n <= MAX_ITERATIONS; n += 2) {
        result += term / n;
        term *= y2;
        
        // Interruption criterion
        if (term < MYEPSILON && term > -MYEPSILON) break;
    }
	 // Multiply by 2 and add the exponent's contribution
    double risultato= 2.0 * result + exponent * 0.69314718056; // 0.69314718056  ln(2)
	
	double check=log(x);
	myprintf("51122: log delta %f\n",risultato-check);
	
	return risultato;

#endif
}







#ifdef ZPAQFULL ///NOSFTPSTART
#ifdef SFTP
// Helper function for wildcard matching
static bool matchWildcard(const std::string& pattern, const std::string& text) 
{
    size_t p = 0, t = 0;
    size_t starIdx = std::string::npos, match = 0;
    
    while (t < text.length()) 
	{
        if (p < pattern.length() && (pattern[p] == '?' || pattern[p] == text[t])) 
		{
            // Corresponding character or '?'
            p++;
            t++;
        } 
		else if (p < pattern.length() && pattern[p] == '*') 
		{
            // Wildcard '*'
            starIdx = p;
            match = t;
            p++;
        } 
		else if (starIdx != std::string::npos) 
		{
            // Backtrack dopo '*'
            p = starIdx + 1;
            match++;
            t = match;
        } 
		else 
		    return false;
        
    }
    
    // Consume any remaining '*' at the end of the pattern
    while (p < pattern.length() && pattern[p] == '*') 
	    p++;
    return p == pattern.length();
}
#endif
#endif ///NOSFTPEND

#ifdef _WIN32

void gotoxy(int x, int y) 
{
    COORD coord;
    coord.X = x;
    coord.Y = y;
    SetConsoleCursorPosition(GetStdHandle(STD_OUTPUT_HANDLE), coord);
}

void clear_line() 
{
    CONSOLE_SCREEN_BUFFER_INFO csbi;
    HANDLE hConsole = GetStdHandle(STD_OUTPUT_HANDLE);
    GetConsoleScreenBufferInfo(hConsole, &csbi);
    
    COORD coord = csbi.dwCursorPosition;
    coord.X = 0;
    SetConsoleCursorPosition(hConsole, coord);
    
    DWORD written;
    FillConsoleOutputCharacterA(hConsole, ' ', csbi.dwSize.X, coord, &written);
    SetConsoleCursorPosition(hConsole, coord);
}

int get_console_height() 
{
    CONSOLE_SCREEN_BUFFER_INFO csbi;
    GetConsoleScreenBufferInfo(GetStdHandle(STD_OUTPUT_HANDLE), &csbi);
    return csbi.srWindow.Bottom - csbi.srWindow.Top + 1;
}

void hide_cursor() 
{
    CONSOLE_CURSOR_INFO cursorInfo;
    GetConsoleCursorInfo(GetStdHandle(STD_OUTPUT_HANDLE), &cursorInfo);
    cursorInfo.bVisible = false;
    SetConsoleCursorInfo(GetStdHandle(STD_OUTPUT_HANDLE), &cursorInfo);
}

void show_cursor() 
{
    CONSOLE_CURSOR_INFO cursorInfo;
    GetConsoleCursorInfo(GetStdHandle(STD_OUTPUT_HANDLE), &cursorInfo);
    cursorInfo.bVisible = true;
    SetConsoleCursorInfo(GetStdHandle(STD_OUTPUT_HANDLE), &cursorInfo);
}

#else
#include <sys/ioctl.h>
#include <unistd.h>
#include <termios.h>

void gotoxy(int x, int y) 
{
    printf("\033[%d;%dH", y + 1, x + 1);
}

void clear_line() 
{
    printf("\033[2K\033[0G");
}

int get_console_height() 
{
    struct winsize w;
    ioctl(STDOUT_FILENO, TIOCGWINSZ, &w);
    return w.ws_row;
}

void hide_cursor() 
{
    printf("\033[?25l");
}

void show_cursor() 
{
    printf("\033[?25h");
}

void move_cursor_up(int lines) 
{
    printf("\033[%dA", lines);
}

void save_cursor() 
{
    printf("\033[s");
}

void restore_cursor() 
{
    printf("\033[u");
}
#endif


// Function to move the cursor (Windows)
void moveCursor(int x, int y) {
#ifdef _WIN32
    COORD coord;
    coord.X = x;
    coord.Y = y;
    SetConsoleCursorPosition(GetStdHandle(STD_OUTPUT_HANDLE), coord);
#else
    printf("\033[%d;%dH", y + 1, x + 1); // ANSI escape codes per Linux/Unix
#endif
}

// Function to get the current cursor position (Windows)
void getCurrentCursorPos(int& x, int& y) {
#ifdef _WIN32
    CONSOLE_SCREEN_BUFFER_INFO csbi;
    GetConsoleScreenBufferInfo(GetStdHandle(STD_OUTPUT_HANDLE), &csbi);
    x = csbi.dwCursorPosition.X;
    y = csbi.dwCursorPosition.Y;
#else
    // Per Linux, manteniamo traccia manualmente o usiamo una posizione fissa
    x = 0;
    y = 0;
#endif
}


/////////////////////////////// Jidac /////////////////////////////////

// A Jidac object represents an archive contents: a list of file
// fragments with hash, size, and archive offset, and a list of
// files with date, attributes, and list of fragment pointers.
// Methods add to, extract from, compare, and list the archive.

// enum for list_HT::csize and version
#ifdef _WIN32
static const int64_t LIST_DEFAULT_VERSION=99999999999999LL; // unless -until
#endif

// fragment hash table entry
struct list_HT {
  unsigned char sha1[20];  // fragment hash
  int usize;      // uncompressed size, -1 if unknown
  int64_t csize;  // if >=0 then block offset else -fragment number
  list_HT(const char* s=0, int u=-1, int64_t c=LIST_HT_BAD) {
    if (s) memcpy(sha1, s, 20);
    else memset(sha1, 0, 20);
    usize=u; csize=c;
  }
};

// filename version entry
struct list_DTV {
  int64_t date;          // decimal YYYYMMDDHHMMSS (UT) or 0 if deleted
  int64_t size;          // size or -1 if unknown
  int64_t attr;          // first 8 attribute bytes
  double csize;          // approximate compressed size
  vector<unsigned> ptr;  // list of fragment indexes to list_HT
  int version;           // which transaction was it added?
  list_DTV(): date(0), size(0), attr(0), csize(0), version(0) {}
};

// filename entry
struct list_DT {
  int64_t edate;         // date of external file, 0=not found
  int64_t esize;         // size of external file
  int64_t eattr;         // external file attributes ('u' or 'w' in low byte)
  uint64_t sortkey;      // determines sort order for compression
  vector<unsigned> eptr; // fragment list of external file to add
  vector<list_DTV> dtv;       // list of versions
  int written;           // 0..ptr.size() = fragments output. -1=ignore
  list_DT(): edate(0), esize(0), eattr(0), sortkey(0), written(-1) {}
};
typedef std::map<string, list_DT> list_DTMap;

// Version info
struct list_VER {
  int64_t date;          // 0 if not JIDAC
  int64_t usize;         // uncompressed size of files
  int64_t offset;        // start of transaction
  int64_t csize;         // size of compressed data, -1 = no index
  int updates;           // file updates
  int deletes;           // file deletions
  unsigned firstFragment;// first fragment ID
  list_VER() {memset(this, 0, sizeof(*this));}
};

#ifdef _WIN32	
inline void list_progress(int i_list_ver,int i_list_dt,int64_t ts, int64_t td) 
{
	static int ultimotempo=0;
	int secondi=(mtime()-list_global_start)/1000;
	if (td>ts) td=ts;
	if (secondi!=ultimotempo)
	{
		ultimotempo=secondi;
		list_print_datetime();
		printf("V %06d (%08d) %5.2f%%  %s / %s\n",i_list_ver,i_list_dt,td*100.0/(ts+0.5),migliaia(td),migliaia2(ts));
	}
}
#endif // corresponds to #ifdef (#ifdef _WIN32	)

#define LIST_NORMAL 0
#define LIST_ERR 1
#define LIST_RECOVER 2 


///////////////////////////
#ifdef _WIN32
#define METAMAGIC 	0x494D4D41474543
#define IMGMAGIC 	0x494D4D41474544

// Structures (unchanged)
#pragma pack(push, 1)
struct ClusterData {
    ULONGLONG cluster_number;    // Cluster number
    ULONGLONG disk_offset;       // Offset of the cluster on the disk
    ULONGLONG image_offset;      // Offset of the cluster in the image
    DWORD size;                  // Cluster size
};

struct ImageMetadata 
{
    ULONGLONG 	magic;             		// 0x4652414E5A494D47 = "FRANZIMG"
    ULONGLONG	revision;          		// build (of imager)
	int64_t		datetime;				// timestamp
	int64_t		version;				// of the zpaqfranz's version
    DWORD		letter;					// A...F 
    DWORD 		sectors_per_cluster;   	// Sectors per cluster
    DWORD 		bytes_per_sector;      	// Byte per settore
	DWORD		bytes_per_cluster;		// Byte per cluster
	char 		filesystem[16];         // Filesystem name
	char 		backup_uuid[16];		// uuid
	ULONGLONG 	total_size;        		// Total disk size
    ULONGLONG 	total_clusters;    		// Total clusters number
    ULONGLONG 	used_clusters;     		// Used clusters
    ULONGLONG 	image_size;        		// Image size
	char		hash_data[32];			// hash of datablocks
	char		hash_clusters[32];		// hash of clusters map
	char		hash_bitmap[32];		// hash of bitmap
	int64_t		data_start;				// datablock offset (future)
	int64_t		data_end;				// datablock end
	int64_t		clusters_start;			// clusters offset (future)
	int64_t		clusters_end;			// clusters end
	int64_t		bitmap_start;			// bitmap start
	int64_t		bitmap_end;				// bitmap end
	char		reserved[64];			// future expansion
	char		comment[192];			// optional plain text
};

#pragma pack(pop)

// Context to share state between functions
struct ImagingContext 
{
    HANDLE device;
    HANDLE backup_file;
    HANDLE metadata_file; // Changed from std::ofstream
    ImageMetadata metadata;
    std::vector<BYTE> bitmap_buffer;
    std::vector<ClusterData> clusters;
    ULONGLONG cluster_size;
    ULONGLONG total_done;
    ULONGLONG g_scritti;
    ULONGLONG startstream;
    BYTE* buffer;
    DWORD buffer_size;
    ULONGLONG processed_clusters;
    bool flagnoeta;
    ULONGLONG current_cluster;
	ULONGLONG total_size;
	char      lettera;
	
	void clear() 
	{
        device = nullptr;
        backup_file = nullptr;
        metadata_file = nullptr;
        // metadata.clear(); // Se ImageMetadata ha un metodo clear(), usalo
        bitmap_buffer.clear();
        clusters.clear();
        cluster_size = 0;
        total_done = 0;
        g_scritti = 0;
        startstream = 0;
        buffer = nullptr;
        buffer_size = 0;
        processed_clusters = 0;
        flagnoeta = false;
        current_cluster = 0;
        total_size = 0;
        lettera = '\0';
    }
};

#ifndef ZPAQ_VERSION
ImagingContext context;
#endif

#endif

int64_t count_of_map(DTMap* i_thedt)
{	
	if (i_thedt==NULL)
		return 0;
	return (*i_thedt).size();
}

int64_t ram_of_map(DTMap* i_thedt)
{
	if (i_thedt==NULL)
		return 0;
	int64_t totale=0;
	for (DTMap::iterator p=(*i_thedt).begin(); p!=(*i_thedt).end(); ++p)
	{
		totale+=sizeof(DT);
		totale+=p->second.ptr.size()*sizeof(unsigned);
		totale+=p->second.hexhash.size()+1;
		totale+=p->second.hashtype.size()+1;
		totale+=p->second.hexcrc32.size()+1;
		totale+=p->second.outputname.size()+1;
		totale+=p->second.franz_block_size;
	}
	return totale;
}

struct conteggio_file 
{
    std::string percorso;
    int numero_file;
    int numero_directory;
    int numero_complessivo;
    int64_t dimensione_totale;
};


// Do everything.
// Very weird approach, this is about plain-old C, almost zero ++
class Jidac
{
public:
	DTMap dt;                 			// set of files in archive
	vector<string> tofiles;   			// -to option
	vector<string> 		files;     		// filename args
	int extract();            			// extract, return 1 if error else 0
	void		jidacreset();
	
	int		loadparameters(int argc, const char** argv);
	int 	doCommand();
	friend 	ThreadReturn decompressThread(void* arg);
	friend 	ThreadReturn decompressthreadramdisk(void* arg);
	friend 	struct ExtractJob;
	void usageall		(string i_command); // verbose help
	string 	archive;           			// archive name

	bool 		isselected(const char* filename, bool rn,int64_t i_size);// files, -only, -not
///	void 		internal_listpaqlevel();
private:

	bool 	ntfs_ok;
	int64_t ntfs_total_size;
	int64_t ntfs_data_written;
	int64_t ntfs_zero_written;
#ifdef _WIN32
	ImagingContext context;
#endif
				
#ifdef _WIN32  
	vector<list_HT> 	list_ht;            // list of fragments
	list_DTMap 		list_dt;                 // set of files
	vector<list_VER> 	list_ver;          // version info
	int64_t pakka_read_archive(const char* arc);  // read arc
	int 	pakkalist();
#endif // corresponds to #ifdef (#ifdef _WIN32  )

	string				fullcommandline;
	std::vector<string> 		results;     	// warning and errors
	string	zpaqfranzexename;
	MAPPAHELP help_map;					/// maps: string command, helpfunctions(bool,bool)
	MAPPAHELP switches_map;
	string	fullarchive;
	vector<int64_t> 	files_size;		// instead of a struct many vectors
	vector<uint64_t> 	files_count;	// why? a bit faster
	vector<uint64_t> 	files_time;
	vector<DTMap> 		files_edt;
	vector<string>		iblock_files;
	int all;                  			// -all option
	int fragment;             			// -fragment option
	int summary;              			// do summary if >0, else brief. OLD 7.15 summary option if > 0, detailed if -1
	unsigned int menoenne;
	int64_t date;             			// now as decimal YYYYMMDDHHMMSS (UT)
	int64_t version;          			// version number or 14 digit date
	string method;            			// default "1"
	 const char* index;        			// index option
	string	plainpassword;
	string	plainpassword2;
	char new_password_string[32]; 		// -repack hashed password
	char* new_password; 				// points to new_password_string or NULL
	string nottype;           			// -not =...
#ifdef ZPAQFULL ///NOSFTPSTART
	string sfxnottype;           		// -not =...
#endif ///NOSFTPEND
	vector<string> level0;  			// list of m0
	vector<string> level1;  			// list of m1
	vector<string> level2;  			// list of m2
	vector<string> level3;  			// list of m3
	vector<string> level4;  			// list of m4
	vector<string> level5;  			// list of m5
	
	vector<string> notfiles;  			// list of prefixes to exclude
#ifdef ZPAQFULL ///NOSFTPSTART
	vector<string> sfxnotfiles;  		// list of prefixes to exclude
#endif ///NOSFTPEND
	vector<string> onlyfiles; 			// list of prefixes to include
	vector<string> chunkfiles; 			// list of prefixes to include
#ifdef ZPAQFULL ///NOSFTPSTART
	vector<string> sfxonlyfiles; 		// list of prefixes to include
#endif ///NOSFTPEND
	vector<string> alwaysfiles; 		// list of prefixes to pack ALWAYS
	string repack;       				// -repack output file
	string	checktxt;					// check txt
	string	backuptxt;
	string	backupindex;
	string	fasttxt;
	string	indexfasttxt;
	map<int, string> mappacommenti;
	string versioncomment;
	///bool flagnoattributes;        		// -noattributes option
	///bool flagforce;               		// -force option
	///bool flagcomment;
	bool flagtest;
	///bool flagskipzfs;
	///bool flagnoqnap;					// exclude @Recently-Snapshot and @Recycle
	///bool flagforcewindows;        		// force alterate data stream $DATA$, system volume information
	///bool flagnopath;					// do not store path
	///bool flagnosort;              		// do not sort files std::sort(vf.begin(), vf.end(), compareFilename);
	uint32_t filelength;
	uint32_t dirlength;
	string	snapmark;
	string searchfrom;					// search something in path
	string replaceto;					// replace (something like awk)
	string searchhash;
	// Archive state
	int64_t dhsize;           			// total size of D blocks according to H blocks
	int64_t dcsize;           			// total size of D blocks according to C blocks
	vector<HT> ht;            			// list of fragments
	DTMap edt;                			// set of external files to add or compare
	vector<Block> block;      			// list of data blocks to extract
	vector<VER> ver;          			// version info
	int64tstringmap sha1collision;
  // Commands
	int redu();                			// check redundancy
	int add();                			// add, return 1 if error else 0
	int addhome();                		// add, return 1 if error else 0
	int list();               			// list (one parameter) / check (more than one)
#ifndef ANCIENT
	int ls();
	int tui();
#endif
	int list715();
	int collision(bool i_flagall);      // check for SHA-1 collisions
	int fzf();
	int ecommand();						// extract on ./
	int append();						// anti-ramsomware (slow)
	int multisomething();            	// extract/test with "*"
	int setpassword();					// set or change password
	int checkpassword();				// check if password is OK
	int extractw();            			// chunked-extract, return 1 if error else 0
	int info();							// wrap for list
	int findj();						// find files
	int zpaqdirsize();               	// get size of a folder
	int testverify();					// check
	int sync();							// check
	int kill();							// align to archive
	int utf();							// check-sanitize strange filename
	int test();           				// test, return 1 if error else 0
	int verify(bool i_readfile);        // verify onfilesystem, return 1 if error else 0
	int consolidate(string i_archive);	// concat files into one
	int summa();						// get hash / or sum
	int hasha();						// get hash / or sum
#ifdef ZPAQFULL ///NOSFTPSTART
	int decimation();					// get only the newest file
#endif ///NOSFTPEND
	int deduplicate();					// get hash / or sum
	int paranoid();						// paranoid test by unz. Really slow & lot of RAM
	int fillami();						// media check
	int dir();							// Windows-like dir command
	int robocopy();						// Like robocopy, but with XLS
	int mycopy();						// Like copy, but with progress
	int zero();							// Delete empty directory
	int trim();							// Trim incomplete transaction
	int crop();							// Truncate
#ifdef ZPAQFULL ///NOSFTPSTART
	int rd();							// Remove dir (rd /s or rm-f)
#endif ///NOSFTPEND
	int purgersync();					// Purge rsync temporary file
#ifdef ZPAQFULL ///NOSFTPSTART
	int sfx();							// Write autoextract module
#endif ///NOSFTPEND
	int oneonone();
	int fix(string i_thearchive);
	///int dd();
#ifdef ZPAQFULL ///NOSFTPSTART
	int	zfsproxbackup();
	int	zfsproxrestore();
	int	zfsbackup();
	int	zfsrestore();
	int	zfsreceive();
#endif ///NOSFTPEND
	int dircompare(bool i_flagonlysize,bool i_flagrobocopy);
	int homesize();
	int benchmark();
	int autotest();
	int pause();
#ifdef ZPAQFULL ///NOSFTPSTART
	int update();
	int isopen();
#endif ///NOSFTPEND
	int	versum();
	int last2();
	int last();
	int testbackup();
	int consolidatebackup();
	int comparehex();
	int work();
#ifdef ZPAQFULL ///NOSFTPSTART
#ifdef SFTP
	int sftp();
	int ssh();
#endif // corresponds to #ifdef (#ifdef SFTP)
#endif ///NOSFTPEND
	int count();
	int backup();
#ifdef ZPAQFULL ///NOSFTPSTART
	int zfslist();
	int zfspurge();
	int zfssize();
	int zfsadd();
	int zfsenumerate(const string& i_command);
	int mysql();
#endif ///NOSFTPEND
#ifdef _WIN32
#ifdef ZPAQFULL ///NOSFTPSTART
	int download();
#endif ///NOSFTPEND
	int windowsc();								// Backup (kind of) drive C:
#ifdef ZPAQFULL ///NOSFTPSTART
	int adminrun();								// Run windowsc()
#endif ///NOSFTPEND
	int 		read_archive2(int64_t i_starthere,string i_filename);
#endif // corresponds to #ifdef (#ifdef _WIN32)
	void load_help_map	();						// not in the constructor!
	void helphelp		();        				// help
	void usage			(bool i_flagdie);		// help
	void examples		(string i_command);		// some examples
  // Support functions
	void 		printsanitizeflags();
	string 		rename(string name);           // rename from -to
	int64_t 	read_archive(callback_function i_advance,const char* arc, int *errors=0, int i_myappend=0,bool i_quiet=false);  // read arc
	void 		scandir(bool i_checkifselected,DTMap& i_edt,string filename, bool i_recursive=true);        // scan dirs to dt
	void 		addfile(bool i_checkifselected,DTMap& i_edt,string filename, int64_t edate, int64_t esize,int64_t eattr,int64_t i_creationdate,int64_t i_accessdate);          // add external file to dt
	int64_t 	franzparallelscandir(bool i_flaghash,bool i_recursive,bool i_forcedir);
	int64_t 	franzparallelhashfiles(string i_hashtype,int64_t i_totalsize,vector<string> i_thefiles,bool i_silent,vector<std::pair<string,string> >& o_hashname);


	bool 		equal(DTMap::const_iterator p, const char* filename, uint32_t &o_crc32,string i_myhashtype,string i_myhash,string& o_hash);// compare file contents with p
	void 		write715attr(libzpaq::StringBuffer& i_sb, uint64_t i_data, unsigned int i_quanti);
	void 		writefranzattr(DTMap::iterator i_dtmap,libzpaq::StringBuffer& i_sb, uint64_t i_data, unsigned int i_quanti,string i_filename,uint32_t i_crc32fromfragments,uint32_t i_crc32,string i_thehash,int64_t i_creationdate,int64_t i_accessdate,const struct franz_posix* i_posix,bool i_isadded);
	int 		enumeratecomments();
	int 		searchcomments(string i_testo,vector<DTMap::iterator> &filelist);
	string 		zfs_get_snaplist(string i_header,string i_footer,vector<string>& o_array_primachiocciola,vector<string>& o_array_dopochiocciola,vector<string>& o_array_size);
	string 		sanitizzanomefile(string i_filename,int i_filelength,int& io_collisioni,MAPPAFILEHASH& io_mappacollisioni);
#ifdef ZPAQFULL ///NOSFTPSTART
	int			writesfxmodule(string i_filename);
#endif ///NOSFTPEND
#ifdef _WIN32
#ifdef ZPAQFULL ///NOSFTPSTART
	int 		decompress_sfx_to_file(FILE* i_outfile);
#endif ///NOSFTPEND
	int			ads();
#endif // corresponds to #ifdef (#ifdef _WIN32)
	int 		extractqueue2(int i_chunk,int i_chunksize);
	int 		multiverify(vector <s_fileandsize>& i_arrayfilename);
	bool 		removetempdirifempty(string i_folder,bool i_deleteifsizezero);
	void 		handleflaglongpath();
	bool 		getfoldersize(string i_folder,uint64_t& o_totalsize,uint32_t & o_totalfile,uint32_t& o_totalfolder,uint32_t& o_longfiles);
	uint64_t 	hashastringa(const string& i_string);
	uint32_t 	casekollision(DTMap& i_dtmap,vector<string>& o_collisions,bool i_fix);
	void 		changedtmapkey(string i_oldkey,string i_newkey);
	int 		removeemptydirs(string i_folder,bool i_kill);
	///int 		writeresource(string i_filename,bool i_force,const char* i_mime64);
#ifdef _WIN32
	int 		decompress_mime64_to_file(FILE* i_outfile,const char* i_mime64);
#endif // corresponds to #ifdef (#ifdef _WIN32)
	int 		hashselect();
//	string 		prepare_dd();

	bool 		getjollylist(string i_fullarchive,DTMap* o_thedt);

	bool 		cli_filesandcommand	(const string& i_opt,string i_string,char i_command,int argc,const char** argv, int* i_i);
	bool 		cli_onlystring		(const string& i_opt,string i_string,string i_alias,string& o_thefile,int argc,const char** argv, int* i_i,bool* i_theflag);
	bool 		cli_getdate			(string& i_opt,string i_string,int argc,const char** argv, int* i_i,int64_t* o_date);
	bool 		cli_getint			(const string& i_opt,string i_string,bool	i_flagoptional,const string& i_short,int argc,const char** argv, int* i_i,int i_default,int* o_thenumber);
	bool 		cli_getuint			(const string& i_opt,string i_string,bool	i_flagoptional,const string& i_short,int argc,const char** argv, int* i_i,unsigned int i_default,unsigned int* o_thenumber);
	bool 		cli_getuint64		(const string& i_opt,string i_string,bool	i_flagoptional,const string& i_short,int argc,const char** argv, int* i_i,uint64_t i_default,uint64_t* o_thenumber);
	bool 		cli_getstring		(const string& i_opt,string i_string,bool	i_flagoptional,const string& i_short,int argc,const char** argv, int* i_i,const string&  i_default,string* o_thestring);
	bool 		cli_getarray		(const string& i_opt,string i_string,int argc,const char** argv, int* i_i,vector<string>* o_files,string* o_stringtype);
	bool 		cli_getkey			(const string& i_opt,string i_string,int argc,const char** argv, int* i_i,string* o_plain,char**	o_password,char*	o_password_string);

	int 		get_filelist(callback_function i_advance,vector<DTMap::iterator>* o_filelist,int64_t& o_sizeuncompressed,int64_t& o_sizededuplicated,int64_t& o_sizecompressed,int64_t& o_sizeall,int64_t& o_dhsize,int64_t& o_dcsize);
	void 		filter_filelist(vector<DTMap::iterator>* i_filelist,vector<DTMap::iterator>* o_filtered,string i_filtro,string i_ordine,string i_crc32,string i_hash);
#ifdef _WIN32
	bool 		searchunixfile();
	bool 		fill_ads(string i_filename,int64_t i_startiblock);
	bool 		work_ads(string i_thefile,string i_adsname,string i_description);
	bool 		isonly(string i_filename);
	bool		exists_fasttxt_ads(string i_filename);
#endif // corresponds to #ifdef (#ifdef _WIN32)
	string		get_lastfilename(string i_file,int64_t& o_totalfilesize);
	int64_t		getzpaqsum(string i_archive,int64_t& o_usize,int64_t& o_allsize,int64_t& o_dtsize,int64_t& o_compressedsize);

	bool 		isbackuprunning();
	
	int			fastquicktxt();
	int 		versum_hashdeep	(FILE* i_thefile,vector<string>& o_files,vector<string>& o_filealgo,vector<string>& o_filehash,vector<int64_t>&	o_filesize,int64_t&	o_expected_size,int& o_expected_file);
	int 		versum_zpaqfranz(FILE* i_thefile,vector<string>& o_files,vector<string>& o_filealgo,vector<string>& o_filehash,vector<int64_t>& o_filesize,int64_t&	o_expected_size,int& o_expected_file);
	int 		versum_againstzpaq(vector<string> i_myfiles,vector<string> i_filealgo,vector<string> i_filehash,vector<string>& o_missing,int& o_errori,int64_t& o_total_hashed);

	int			makecrc32txt(string i_filename, string& o_initialquickhash,int64_t& o_initialzpaqsize,string& o_initialzpaqquick, string& o_initialzpaqcrc32,string& o_prezpaqcrc32,int64_t& prezpaqsize,string& o_thecrcfile);
	int			rebuildcrc32(string i_filename,string& o_prezpaqcrc32,int64_t& 	o_prezpaqsize,string& o_thecrcfile);

	void 		decodelastversion();
	bool 		acceptonlynot(string i_filename);
	int 		listfolders(string i_path,vector<string>* o_thelist);
	string secure_copy_file(
const string& i_filename,const string& i_outfilename,int64_t i_startcopy,int64_t i_totalsize,int64_t i_totalcount,int64_t& o_writtensize,int64_t& o_donesize,int64_t& o_donecount,
int64_t i_sorgente_size,
int64_t i_sorgente_date,
int64_t i_sorgente_attr,
int64_t i_destinazione_size,
int64_t i_destinazione_date,
int64_t i_destinazione_attr,
unsigned char*	i_buffer,
size_t			i_buffersize
);
	int 		checksha1collision(DTMap& i_dtmap,bool i_decodefranzblock);
	void 		updatehash(DTMap::iterator* i_p,char* i_buf,int i_buflen);
	int64_t 	get_dt(int *errors, const char* arc);
	int 		dump();

///	char 		getspecificlevel(const string& i_filename);
///	void 		loadpaqlevel();
	int			loadzfsdiff(string i_filediff,vector<string>& o_added,vector<string>& o_deleted);
	int			listfast();
	void		blockdecoder();
	void		htdecoder();
	void		dtdecoder();
	bool 		noselection();
///	int 		scan_archive(vector<uint64_t>& cblock_position,vector<uint64_t>& dblock_position,vector<uint64_t>& hblock_position,vector<uint64_t>& iblock_position);
	bool		sanitizeline(string i_filename);
	bool 		sanitizefile(string i_filename);
#ifdef _WIN32
#ifdef ZPAQFULL ///NOSFTPSTART
	void		runhigh(string i_addendum);
#endif ///NOSFTPEND
	bool 		isrealfile(const string& i_filename);

#endif // corresponds to #ifdef (#ifdef _WIN32)
public:
	string	fullzpaqexename;
	
	int howmanythreads;              	// default is number of cores
	
	int64_t		get_dt_ram() 		{ return ram_of_map(&dt);}
	int64_t		get_edt_ram() 		{ return ram_of_map(&edt);}
	int64_t		get_dt_count() 		{ return count_of_map(&dt); }
	int64_t		get_edt_count() 	{ return count_of_map(&edt); }
	///bool 		ismounted(const string i_path);
	///int64_t		fragmenttoblockoffset(int i_fragment);
	
	void list_datetime			(const int64_t i_datetime,const bool i_flagnewversion);
	void list_filesize			(const bool i_isdir,const int64_t i_filesize,int i_thesizesize);
	void list_compressedfilesize(const int64_t i_compressedfilesize,const int64_t i_filesize,const bool i_flagnewversion,const bool i_isfolder,const bool i_isdeleted);
	//void list_seconddata		(const char i_car);
	void list_creationdate		(int64_t i_mycreationtime);
	void list_attributes		(int64_t i_attributes);

	int64_t 					datacreazione(const string i_file);
	void 						rename_a_dtmap(DTMap& i_source);
	bool 						grep(const string i_filename,const string i_search);
	int							checkautotest(string i_path);
	bool 						isjitable();
	void 						tabba();
	int							external();
	string 						getbackupnameifany(string i_filename);
	int 						sumhome();
	bool 						is_incomplete_trans(const char* arc);
	bool 						onlynorecursion(string filename);
#ifdef ZPAQFULL ///NOSFTPSTART
	int 						maxcpu(int i_percent);
	int 						systemshutdown();
#endif ///NOSFTPEND
	int 						posix_count();
	string 						find_unix_command(const string& i_thecommand);
#ifdef ZPAQFULL ///NOSFTPSTART	
	int 						makefullzfsbackup(const string& poolName, const string& archiveName, const string& snapshotMarker, const string& sanitizedPoolName,const string & i_parameters);
	int 						updatezfsbackup(const string& poolName, const string& archiveName, const string& snapshotMarker, const string& sanitizedPoolName,const string & i_parameters);
#endif ///NOSFTPEND
	bool 						preparantfs(const std::string& image_path, char drive_letter);
#ifdef _WIN32
	int 						elaborantfs(char* buffer, size_t buffer_size);
    bool 						chiudintfs();
	bool 						ripristinantfs(const std::string& image_path, const std::string& raw_path);
	int							restoreimage();
	int 						NTFSEnumerateFiles(string i_path, DTMap& i_edt, bool i_checkifselected);
	int 						drive();
	std::string 				enumerate_physical_disks(int i_chosendrive);
	char 						find_drive_letter_for_partition(int diskNumber, DWORD partitionNumber);
	bool 						parsediskunit(string i_stringa, char& o_char, int& o_number);

#endif

#ifdef unix
	bool 						preparadump(const std::string& image_path);
	int 						elaboradump(char* buffer, size_t buffer_size);
	bool 						chiudidump();
#endif
	int 						getCharIndex(char c);
	void 						printDigitalString(const char* inputString); 
#ifdef ZPAQFULL ///NOSFTPSTART
#ifdef SFTP
	int 						sftp_do1on1();
	int 						sftp_dorsync();
	int 						sftp_doupload();
	int 						sftp_doquick();
	int 						sftp_dols();
	int 						sftp_dosize();
	int 						sftp_dodelete();
	int 						sftp_doverify();
	int 						sftp_domd5();
	int 						sftp_doinfo();
	int							sftp_domkdir();
	
	int							ssh_dohasha(std::string i_algo);
#endif
#endif ///NOSFTPEND
	void 						getfirstlevelfolders(const DTMap& i_filemap, 
                         const std::string& i_basepath, 
                         std::vector<conteggio_file>& o_output,
                         bool i_ordinapersize,
						 bool i_flagdesc);
						 
	void		franzreplace(string& i_filename);
	
	int 		comparefilelists(const std::vector<DTMap::iterator>& externalfilelist,
                                 const std::vector<DTMap::iterator>& internalfilelist,
								 DTMap&			thedt);
#ifdef ZPAQFULL ///NOSFTPSTART
#ifdef SFTP
	int				cloud();
#endif
#endif ///NOSFTPEND
	string 		keyfile_to_string(string i_keyfile);
	void		pc_info();
	int 		xssh(uint64_t i_timetorun,std::string i_command,std::string& o_output);
	void 		exclude_output();


};

Jidac* pjidac;


#ifdef _WIN64
BOOL CALLBACK EnumTypesProc(HMODULE, LPWSTR, LONG_PTR lParam) {
    // Se siamo qui significa che almeno una risorsa esiste
    bool* hasRes = reinterpret_cast<bool*>(lParam);
    *hasRes = true;
    // Fermiamo subito l’enumerazione
    return FALSE;
}

bool wehaveresources()
{
	if (pjidac == nullptr)
		return false;

    bool hasRes = false;

    HMODULE hModule = LoadLibraryExW(
        utow(pjidac->fullzpaqexename.c_str()).c_str(),
        NULL,
        LOAD_LIBRARY_AS_DATAFILE | LOAD_LIBRARY_AS_IMAGE_RESOURCE
    );
    if (!hModule) 
	    return false; // file non apribile
    
    EnumResourceTypesW(hModule, EnumTypesProc, reinterpret_cast<LONG_PTR>(&hasRes));
    FreeLibrary(hModule);

    return hasRes;
}
#endif





#ifdef ZPAQFULL ///NOSFTPSTART
#ifdef SFTP

///fima1

typedef void 				(*curl_easy_reset_t)		(CURL *);
typedef CURL *				(*curl_easy_init_t)			(void);
typedef CURLcode 			(*curl_easy_setopt_t)		(CURL *, CURLoption, ...);
typedef CURLcode 			(*curl_easy_perform_t)		(CURL *);
typedef CURL*				(*curl_easy_duphandle_t)	(CURL*);
typedef const char *		(*curl_easy_strerror_t)		(CURLcode);
typedef CURLcode 			(*curl_easy_getinfo_t)		(CURL *, CURLINFO, ...);
typedef struct curl_slist *	(*curl_slist_append_t)		(struct curl_slist *, const char *);
typedef void 				(*curl_slist_free_all_t)	(struct curl_slist *);
typedef void 				(*curl_easy_cleanup_t)		(CURL *);
typedef CURLcode 			(*curl_global_init_t)		(long);
typedef void 				(*curl_global_cleanup_t)	(void);
typedef curl_version_info_data* (*curl_version_info_t) (CURLversion);

struct curldynfunctions 
{
	curl_easy_reset_t 		easy_reset;
	curl_easy_init_t 		easy_init;
    curl_easy_setopt_t 		easy_setopt;
    curl_easy_perform_t 	easy_perform;
    curl_easy_strerror_t 	easy_strerror;
    curl_easy_getinfo_t 	easy_getinfo;
    curl_slist_append_t 	slist_append;
    curl_slist_free_all_t 	slist_free_all;
    curl_easy_cleanup_t 	easy_cleanup;
    curl_global_init_t 		global_init;
    curl_global_cleanup_t 	global_cleanup;
    curl_easy_duphandle_t 	easy_duphandle;
	curl_version_info_t		my_version_info;
};


#define Kurl_easy_setopt 	zpaqfranzsftp2::curldll.easy_setopt
#define Kurl_easy_init 		zpaqfranzsftp2::curldll.easy_init
#define Kurl_easy_cleanup 	zpaqfranzsftp2::curldll.easy_cleanup
#define Kurl_easy_duphandle zpaqfranzsftp2::curldll.easy_duphandle
#define Kurl_easy_perform 	zpaqfranzsftp2::curldll.easy_perform
#define Kurl_easy_getinfo 	zpaqfranzsftp2::curldll.easy_getinfo
#define Kurl_easy_strerror 	zpaqfranzsftp2::curldll.easy_strerror
#define Kurl_global_init 	zpaqfranzsftp2::curldll.global_init
#define Kurl_global_cleanup zpaqfranzsftp2::curldll.global_cleanup
#define Kurl_slist_free_all zpaqfranzsftp2::curldll.slist_free_all
#define Kurl_slist_append 	zpaqfranzsftp2::curldll.slist_append

class zpaqfranzsftp2; 

// Structure to track the statistics of each thread
struct sftp_threadstats 
{
    int 		thread_id;
    int 		completed_files;
    int64_t 	bytes_transferred;
    int64_t 	start_time;
    int64_t 	last_activity_time;
    std::string	current_file;
    bool 		is_active;
    double 		current_speed;
	int64_t		bytes_transferred_current; 
	int64_t		bytes_transferred_this_session;
	int64_t		starting_file_size;
	
	
    sftp_threadstats	() : 
	thread_id			(0), 
	completed_files		(0), 
	bytes_transferred	(0), 
    start_time			(0), 
	last_activity_time	(0), 
	current_file		(""), 
    is_active			(false), 
	current_speed		(0.0),
	bytes_transferred_current(0),
	bytes_transferred_this_session(0),
starting_file_size(0)	{}
};

// Structure to track data per thread
struct sftp_threadprogressdata 
{
    int 			thread_id;
    std::string 	current_file;
    int64_t 		current_file_size;
	int64_t 		thread_bytes_processed;
    int 			thread_files_processed;
    int64_t 		thread_start_time;
    bool 			is_active;
    std::string 	status; // DOWN WAIT DONE ERROR 
};

struct sftpfileinfo 
{
    std::string 	name;
    std::string 	fullname;
    int64_t 		size;
    time_t 			modtime;
    std::string 	permissions;
    std::string 	owner;
    std::string 	group;
    bool 			isdirectory;
	std::string		hash;
};

struct sftpget3 
{
    std::string 	i_name;
    std::string 	i_file1;
	std::string 	i_file2;
	std::string 	i_file3;
	int64_t 		o_size;
	std::string 	o_hash;
};

// Updated data structure for the worker thread
struct sftp_downloadthreaddata 
{
    zpaqfranzsftp2* 			sftp_instance;
    std::queue<sftpget3*>* 		task_queue;
    pthread_mutex_t* 			queue_mutex;
    pthread_cond_t* 			queue_cond;
    bool* 						all_tasks_added;
    bool* 						stop_threads;
    int 						thread_id;
    bool* 						success_flag;
    pthread_mutex_t* 			result_mutex;
    int* 						completed_tasks;
    int 						total_tasks;
    int* 						total_files_processed;
    int64_t* 					total_bytes_processed;
    sftp_threadprogressdata*	thread_progress;
    pthread_mutex_t* 			progress_mutex;
};

  
struct sftp_downloaddata 
{
	FILE* 						file;
	int64_t 					total_size;
	int64_t 					downloaded;
	int64_t 					start_time;
	int64_t 					last_progress_time;
	curl_off_t 					start_offset;
	curl_off_t 					end_offset;
	int64_t 					local_existing_size;
};

// Structure for the listing callback
struct sftp_listingdata 
{
    std::vector<sftpfileinfo>* 	filearray;
    std::string 				remote_path;
    std::string 				filter;
    
    sftp_listingdata(std::vector<sftpfileinfo>* fa, const std::string& path, const std::string& filt): 
		filearray(fa), 
		remote_path(path), 
		filter(filt) {}
};

static bool compareSftpFileInfo(const sftpfileinfo& a, const sftpfileinfo& b) 
{
    return a.name < b.name;
}

#ifdef __APPLE__
#include <dirent.h>
#include <sys/stat.h>

// Recursive function to search for a library in a directory
static std::string scan_directory_recursive(const std::string& dir_path, const std::string& libname) 
{
    DIR* dir = opendir(dir_path.c_str());
    if (!dir) return "";
    
    struct dirent* entry;
    while ((entry = readdir(dir)) != nullptr) 
    {
        if (strcmp(entry->d_name, ".") == 0 || strcmp(entry->d_name, "..") == 0)
            continue;
            
        std::string full_path = dir_path + "/" + entry->d_name;
        
        // If it's the file we're looking for, we've found it
        if (entry->d_name == libname) 
        {
            if (flagdebug2)
                myprintf("52649: Found <<%s>>\n", full_path.c_str());
            closedir(dir);
            return full_path;
        }
        
        // If dir, recurse
		struct stat st;
        if (stat(full_path.c_str(), &st) == 0 && S_ISDIR(st.st_mode)) 
        {
            std::string result = scan_directory_recursive(full_path, libname);
            if (!result.empty()) 
            {
                closedir(dir);
                return result;
            }
        }
    }
    closedir(dir);
    return "";
}
#endif






class zpaqfranzsftp2 
{
private:
    std::string host;
    std::string username;
    std::string password;
    std::string ssh_key_path;
    int 		port;
    bool 		use_ssh_key;
	static bool dllloaded;
   
    
    // Callback per scrivere i dati ricevuti (per remotegetfilesize)
    static size_t write_callback(void* contents, size_t size, size_t nmemb, void* userp) 
	{
		if (!contents)
			return size*nmemb; // compiler be quiet
		if (userp)
			return size*nmemb; // compiler be quiet
        // We do nothing, weare only interested in the header
        return size * nmemb;
    }
	
	
    // Callback per il progresso del download
	 static int download_progress_callback(void* clientp, curl_off_t dltotal, curl_off_t dlnow, curl_off_t ultotal, curl_off_t ulnow) 
	 {
			 
        sftp_downloaddata* data 	= (sftp_downloaddata*)clientp;
        int64_t current_time 		= mtime();
		
		if (dltotal+ultotal>ulnow)
			 current_time++; // compiler be quiet
        
        // Update every second
        if (current_time - data->last_progress_time >= 1) 
		{
            data->last_progress_time 	= current_time;
            int64_t total_downloaded 	= (int64_t)dlnow;
            double elapsed 				= (mtime()-data->start_time)/1000.0;
            
            // Calculate the total effective size to download
            int64_t effective_total 					= data->total_size;
           
            if (data->end_offset > 0) 
			{
                effective_total = data->end_offset - data->start_offset + 1;
            } 
			else 
			if (data->start_offset > 0) 
			{
                effective_total = data->total_size - data->start_offset;
            }
            
            if (elapsed > 0) 
			{
				int64_t total_downloaded_including_existing = total_downloaded + data->local_existing_size;
                double speed = total_downloaded / elapsed; // bytes/sec
                double remaining = effective_total - total_downloaded;
                double eta = (speed > 0) ? remaining / speed : 0;
                
                int eta_hours = (int)(eta / 3600);
                int eta_minutes = (int)((eta - eta_hours * 3600) / 60);
                int eta_seconds = (int)(eta - eta_hours * 3600 - eta_minutes * 60);
                
                if (flagdebug) 
				{
                    if (data->local_existing_size > 0) 
					{
                        myprintf("41030: Download (Resume): %s/%s total bytes (%5.2f%%) - now: %s - @ %s - ETA: %02d:%02d:%02d\n",
                               migliaia(total_downloaded_including_existing), migliaia2(data->total_size), 
                               (double)total_downloaded_including_existing / data->total_size * 100.0,
                               migliaia3(total_downloaded), tohuman(speed), eta_hours, eta_minutes, eta_seconds);
                    } 
					else 
					{
                        myprintf("41031: Download (full): %s/%s total bytes (%5.2f%%) - now: %s - @ %s - ETA: %02d:%02d:%02d\n",
                               migliaia(total_downloaded_including_existing), migliaia2(data->total_size), 
                               (double)total_downloaded_including_existing / data->total_size * 100.0,
                               migliaia3(total_downloaded), tohuman(speed), eta_hours, eta_minutes, eta_seconds);

                    }
                }
            }
        }
        return 0;
    }
    

    // Callback per scrivere i dati scaricati su file
    static size_t write_file_callback(void* contents, size_t size, size_t nmemb, void* userp) 
	{
        FILE* file = (FILE*)userp;
        return fwrite(contents, size, nmemb, file);
    }
	
		// Callback per processare i dati di listing
	

	static size_t listing_callback(void* contents, size_t size, size_t nmemb, void* userp) 
	{
		sftp_listingdata* data 		= (sftp_listingdata*)userp;
		size_t total_size 			= size * nmemb;
		std::string content((char*)contents, total_size);
		
		if (flagdebug3) 
			myprintf("41075: Listing data: %s\n", content.c_str());
		
		// Divide the content into lines
		std::vector<std::string> lines;
		size_t mystart 	= 0;
		size_t mypoz 		= 0;
		
		while ((mypoz = content.find('\n', mystart)) != std::string::npos) 
		{
			std::string line = content.substr(mystart, mypoz - mystart);
			if (!line.empty() && line != "\r") 
			{
				// Rimuovi \r se presente alla fine
				if (!line.empty() && line.back() == '\r') 
					line.pop_back();
				lines.push_back(line);
			}
			mystart = mypoz + 1;
		}
		
		// Aggiungi l'ultima riga se non termina con \n
		if (mystart < content.length()) 
		{
			std::string line = content.substr(mystart);
			if (!line.empty() && line != "\r") 
			{
				if (!line.empty() && line.back() == '\r') 
					line.pop_back();
				lines.push_back(line);
			}
		}
		
		// Process each line (format similar to ls -la)
		for (std::vector<std::string>::const_iterator line_it = lines.begin(); line_it != lines.end(); ++line_it) 
		{
			const std::string& line = *line_it;
			if (line.empty() || line.length() < 10) 
				continue;
			
			// Example line: drwxr-xr-x   5 franco   franco       4096 Dec 15 10:30 dirname
			// Or: -rw-r--r--   1 franco   franco    1234567 Dec 15 10:30 filename.ext
			
			sftpfileinfo fileinfo;
			std::vector<std::string> tokens;
			
			// Divide the line into tokens manually
			
			size_t pos 		= 0;
			
			while (pos < line.length()) 
			{
				// Skip leading spaces
				while (pos < line.length() && line[pos] == ' ') 
					pos++;
				if (pos >= line.length()) 
					break;
				
				size_t start = pos;
				// Find end of token
				while (pos < line.length() && line[pos] != ' ') 
					pos++;
				
				if (pos > start) 
					tokens.push_back(line.substr(start, pos - start));
			}
			
			if (tokens.size() < 9) 
				continue; // Invalid format
			
			// Parsing the fields
			fileinfo.permissions 	= tokens[0];
			fileinfo.owner 			= tokens[2];
			fileinfo.group 			= tokens[3];
			
			// Convert size manually
			fileinfo.size = 0;
			for (size_t i = 0; i < tokens[4].length(); i++) {
				char c = tokens[4][i];
				if (c >= '0' && c <= '9') 
					fileinfo.size = fileinfo.size * 10 + (c - '0');
			}
			
			fileinfo.isdirectory = (tokens[0][0] == 'd');
			
			// The file name is from the eighth token onwards (it can contain spaces)
			fileinfo.name = "";
			for (size_t i = 8; i < tokens.size(); i++) 
			{
				if (i > 8) 
					fileinfo.name += " ";
				fileinfo.name += tokens[i];
			}
			
			// Skip . and ..
			if (fileinfo.name == "." || fileinfo.name == "..") 
				continue;
			
			// Build the full path
			fileinfo.fullname = data->remote_path;
			if (!fileinfo.fullname.empty() && fileinfo.fullname.back() != '/') 
				fileinfo.fullname += "/";
			fileinfo.fullname += fileinfo.name;
			
			// Parsing the date (format: "Dec 15 10:30" or "Dec 15  2023")
			struct tm timeinfo;
			memset(&timeinfo,0,sizeof(struct tm));

			std::string month = tokens[5];
			
			// Convert day manually
			int day = 0;
			for (size_t i = 0; i < tokens[6].length(); i++) {
				char c = tokens[6][i];
				if (c >= '0' && c <= '9') 
					day = day * 10 + (c - '0');
			}
				
			std::string timeOrYear = tokens[7];
			
			// Convert month
			const char* months[] = {"Jan", "Feb", "Mar", "Apr", "May", "Jun",
								   "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"};
			for (int i = 0; i < 12; i++) 
				if (month == months[i]) 
				{
					timeinfo.tm_mon = i;
					break;
				}
			timeinfo.tm_mday = day;
			
			if (timeOrYear.find(':') != std::string::npos) 
			{
				// Time format: "10:30" - we assume the current year
				time_t now 			= time(NULL);
				const struct tm* current 	= localtime(&now);
				timeinfo.tm_year 	= current->tm_year;
				
				size_t colonPos 	= timeOrYear.find(':');
				
				// Convert hours and minutes manually
				int hour 			= 0;
				for (size_t i = 0; i < colonPos; i++) 
				{
					char c = timeOrYear[i];
					if (c >= '0' && c <= '9') 
						hour = hour * 10 + (c - '0');
				}
				
				int min = 0;
				for (size_t i = colonPos + 1; i < timeOrYear.length(); i++) 
				{
					char c = timeOrYear[i];
					if (c >= '0' && c <= '9') 
						min = min * 10 + (c - '0');
				}
				
				timeinfo.tm_hour = hour;
				timeinfo.tm_min = min;
			} 
			else 
			{
				// Year format: "2023"
				int year = 0;
				for (size_t i = 0; i < timeOrYear.length(); i++) {
					char c = timeOrYear[i];
					if (c >= '0' && c <= '9') 
						year = year * 10 + (c - '0');
				}
					
				timeinfo.tm_year 	= year - 1900;
				timeinfo.tm_hour 	= 0;
				timeinfo.tm_min 	= 0;
			}
			
			fileinfo.modtime = mktime(&timeinfo);
			
			// Apply filter if specified
			if (!data->filter.empty() && !fileinfo.isdirectory) 
			{
				if (!matchWildcard(data->filter, fileinfo.name)) 
				{
					if (flagdebug3) 
						myprintf("41249: File %s not in filter %s\n", 
										 fileinfo.name.c_str(), data->filter.c_str());
					continue;
				}
			}
			
			if (flagdebug) 
			{
				myprintf("41257: File founded: %s (%s) - %s bytes - %s\n", 
					   fileinfo.name.c_str(), 
					   fileinfo.isdirectory ? "DIR" : "FILE",
					   migliaia(fileinfo.size),
					   fileinfo.permissions.c_str());
			}
			
			data->filearray->push_back(fileinfo);
		}
		
		return total_size;
	}


public:
    CURL* 		curl;
	static 		curldynfunctions curldll;

#ifndef _WIN32
int kickstartlinux()
{
    myprintf("38151: You should get libcurl.so, for example\n");
#ifdef __APPLE__
    myprintf("38158: macOS             :brew install curl\n");
#else
#ifdef __linux__
    // apk (Alpine Package Keeper)
    myprintf("38152: Alpine            :apk add curl\n");
    
    // apt (Advanced Package Tool)
    myprintf("38153: Debian/Ubuntu     :apt install libcurl4\n");
    myprintf("38154: Debian/Ubuntu     :sudo apt install libcurl4\n");
    
    // dnf (Dandified YUM)
    myprintf("38155: Alma Linux        :dnf install curl\n");
    myprintf("38156: Alma Linux        :sudo dnf install curl\n");
    myprintf("38157: Amazon Linux (v2+):dnf install curl\n");
    myprintf("38158: Fedora            :dnf install curl\n");
    myprintf("38159: Oracle Linux (v8+):dnf install curl\n");
    myprintf("38160: Rocky Linux       :dnf install curl\n");
    
    // emerge (Portage)
    myprintf("38161: Gentoo            :emerge --ask net-misc/curl\n");
    
    // guix
    myprintf("38162: Guix              :guix install curl\n");
    
    // nix-env
    myprintf("38163: NixOS             :nix-env -i curl\n");
    
    // opkg (OpenWrt Package)
    myprintf("38164: OpenWrt           :opkg install curl\n");
    // pacman
    myprintf("38165: Arch              :pacman -S curl\n");
    // slackpkg
    myprintf("38177: Slackware         :slackpkg install curl\n");
    
    // swupd (Clear Linux)
    myprintf("38178: Clear Linux       :swupd bundle-add curl\n");
    
    // xbps-install (Void Linux)
    myprintf("38179: Void              :xbps-install -S curl\n");
    
    // yum (older RHEL/CentOS)
    myprintf("38180: Amazon Linux (v1) :yum install curl\n");
    myprintf("38181: CentOS            :yum install curl\n");
    myprintf("38182: Oracle Linux (v7-):yum install curl\n");
    myprintf("38183: RHEL              :yum install curl\n");
    myprintf("38184: SUSE              :zypper install libcurl4\n");
#else
    
    // pkg (FreeBSD/Solaris/Termux style)
    myprintf("38166: FreeBSD           :pkg install curl\n");
    myprintf("38167: OPNSense          :pkg install curl\n");
    myprintf("38168: pfSense           :pkg install curl\n");
    myprintf("38169: OpenIndiana       :pkg install library/curl\n");
    myprintf("38170: Solaris           :pkg install curl\n");
    myprintf("38171: Termux            :pkg install curl\n");
    myprintf("38172: TrueNAS           :pkg install curl\n");
    
    // pkg_add (OpenBSD)
    myprintf("38173: OpenBSD           :pkg_add curl\n");
    myprintf("38174: OpenBSD           :doas pkg_add curl\n");
    
    // pkgin (NetBSD)
    myprintf("38175: NetBSD            :pkgin install curl\n");
    
    // pkgman (Haiku)
    myprintf("38176: Haiku             :pkgman install curl\n");
    
    myprintf("38185: Conda             :conda install curl\n");
    
    myprintf("38186: Manual            :Get https://curl.se, then ");
    myprintf("./configure --disable-static && make && sudo make install\n");
#endif  // __linux__
#endif  // __APPLE__
    return 0;
}
#endif

#ifdef _WIN32
	
int kickstartwindows()
{
	///#ifdef ZPAQ_VERSION

	if (pjidac == NULL)
	{
		myprintf("39008: pjidac null\n");
		seppuku();
	}
    
    if (kickstart_resources("LIBCURL")==0) 
		myprintf("00734$ Please restart zpaqfranz\n");
	return 1;
///#endif
	return 0;
}
#endif


#ifdef __APPLE__
// Function for macOS: search for libname with .dylib extension
static std::string findso_macos(const std::string& i_libname) 
{
    std::string libname = i_libname + ".dylib"; // Add .dylib
    
    // First search in Homebrew directories (recursive search)
    const char* homebrew_paths[] = {
        "/usr/local/Cellar/curl",     // Homebrew (Intel)
        "/opt/homebrew/Cellar/curl"   // Homebrew (Apple Silicon)
    };
    
    int homebrew_count = sizeof(homebrew_paths) / sizeof(homebrew_paths[0]);
    for (int i = 0; i < homebrew_count; i++) 
    {
        const char* base_path = homebrew_paths[i];
        if (flagdebug2)
            myprintf("92649: Scanning recursively <<%s>>\n", base_path);
        std::string result = scan_directory_recursive(base_path, libname);
        if (!result.empty()) 
            return result;
    }
    
    // Then search in standard paths
    const char* standard_paths[] = {
        "/usr/local/lib/",   // Homebrew (linkato)
        "/usr/lib/",         // macOS system
    };
    
    int standard_count = sizeof(standard_paths) / sizeof(standard_paths[0]);
    for (int j = 0; j < standard_count; j++) 
    {
        const char* path = standard_paths[j];
        std::string full_path = std::string(path) + libname;
        if (flagdebug2)
            myprintf("52559: Checking <<%s>>\n", full_path.c_str());
        if (access(full_path.c_str(), F_OK) == 0) // fileexists
            return full_path;
    }
    
    return "";
}
#else
    
#endif


	static bool loadLibrary()
	{
		if (dllloaded)
			return true;

	#ifdef _WIN32
	#ifdef _WIN64
		const char *local_lib_name = "./libcurl-x64.dll";
		const char *generic_lib_name = "libcurl-x64.dll";
	#else
		const char *local_lib_name = "./libcurl.dll";
		const char *generic_lib_name = "libcurl.dll";
	#endif
	

	HMODULE hModule=NULL;

    if (kickstart_resources("LIBCURL") == 0) 
	{
        hModule = LoadLibraryA(local_lib_name);
        if (hModule) 
		{
			if (flagdebug)
			{
				color_green();
				myprintf("38280: libcurl load from local\n");
				color_restore();
			}
        } 
		else 
		{
            color_yellow();
            myprintf("38281! Cannot load local libcurl!\n");
			color_restore();
            hModule = LoadLibraryA(generic_lib_name);
        }
    } 
	else 
	{
        color_yellow();
        myprintf("38279: No libcurl in current folder, trying generic loading\n");
        color_restore();
        hModule = LoadLibraryA(generic_lib_name);
    }
    
    // Controllo finale del caricamento
    if (!hModule) 
	{
        myprintf("38087! cannot load libcurl.dll from any location\n");
        return false;
    }


		// Load all function pointers con cast intermedio a void*
		curldll.easy_reset = reinterpret_cast<curl_easy_reset_t>(
			reinterpret_cast<void*>(GetProcAddress(hModule, "curl_easy_reset")));
		curldll.easy_init = reinterpret_cast<curl_easy_init_t>(
			reinterpret_cast<void*>(GetProcAddress(hModule, "curl_easy_init")));
		curldll.easy_setopt = reinterpret_cast<curl_easy_setopt_t>(
			reinterpret_cast<void*>(GetProcAddress(hModule, "curl_easy_setopt")));
		curldll.easy_perform = reinterpret_cast<curl_easy_perform_t>(
			reinterpret_cast<void*>(GetProcAddress(hModule, "curl_easy_perform")));
		curldll.easy_strerror = reinterpret_cast<curl_easy_strerror_t>(
			reinterpret_cast<void*>(GetProcAddress(hModule, "curl_easy_strerror")));
		curldll.easy_getinfo = reinterpret_cast<curl_easy_getinfo_t>(
			reinterpret_cast<void*>(GetProcAddress(hModule, "curl_easy_getinfo")));
		curldll.slist_append = reinterpret_cast<curl_slist_append_t>(
			reinterpret_cast<void*>(GetProcAddress(hModule, "curl_slist_append")));
		curldll.slist_free_all = reinterpret_cast<curl_slist_free_all_t>(
			reinterpret_cast<void*>(GetProcAddress(hModule, "curl_slist_free_all")));
		curldll.easy_cleanup = reinterpret_cast<curl_easy_cleanup_t>(
			reinterpret_cast<void*>(GetProcAddress(hModule, "curl_easy_cleanup")));
		curldll.global_init = reinterpret_cast<curl_global_init_t>(
			reinterpret_cast<void*>(GetProcAddress(hModule, "curl_global_init")));
		curldll.global_cleanup = reinterpret_cast<curl_global_cleanup_t>(
			reinterpret_cast<void*>(GetProcAddress(hModule, "curl_global_cleanup")));
		curldll.easy_duphandle = reinterpret_cast<curl_easy_duphandle_t>(
			reinterpret_cast<void*>(GetProcAddress(hModule, "curl_easy_duphandle")));
		curldll.my_version_info = reinterpret_cast<curl_version_info_t>(
			reinterpret_cast<void*>(GetProcAddress(hModule, "curl_version_info")));

		// Verify all functions were loaded
		if (!curldll.easy_reset || !curldll.easy_init || !curldll.easy_setopt ||
			!curldll.easy_perform || !curldll.easy_strerror || !curldll.easy_getinfo ||
			!curldll.slist_append || !curldll.slist_free_all || !curldll.easy_cleanup ||
			!curldll.global_init || !curldll.global_cleanup || !curldll.easy_duphandle
			|| (!curldll.my_version_info))
		{
			myprintf("46967: Failed to load one or more libcurl functions (too old?)\n");
			FreeLibrary(hModule);
			return false;
		}

		dllloaded = true;
		return true;
	#else
		
		void *hModule 	= dlopen("libcurl.so", RTLD_LAZY); //first try
		if (!hModule)
		{
			if (flagdebug)
				myprintf("38530: second try\n");
			hModule 	= dlopen("libcurl.so.4", RTLD_LAZY); //second try
		}
#ifdef __APPLE__
		if (!hModule)
		{
			if (flagdebug)
				myprintf("38530: Apple try\n");
			hModule 	= dlopen("libcurl.dylib", RTLD_LAZY); //Apple is always different 
			if (!hModule)
			{
				if (flagdebug)
					myprintf("18530: Apple try (2nd)\n");
				string wearedesperate=findso_macos("libcurl");
				if (flagdebug)
					myprintf("38543: wearedesperate %s\n",wearedesperate.c_str());
				if (wearedesperate!="")
					hModule = dlopen(wearedesperate.c_str(), RTLD_LAZY);
			}
		}
#endif

		if (!hModule)
		{
			myprintf("46919$ Cannot load libcurl.so, sorry\n");
#ifdef _WIN32
			(void)kickstart();
#endif
			return false;
		}
		curldll.easy_reset 		= (curl_easy_reset_t)		dlsym(hModule, "curl_easy_reset");
		curldll.easy_init 		= (curl_easy_init_t)		dlsym(hModule, "curl_easy_init");
		curldll.easy_setopt 	= (curl_easy_setopt_t)		dlsym(hModule, "curl_easy_setopt");
		curldll.easy_perform 	= (curl_easy_perform_t)		dlsym(hModule, "curl_easy_perform");
		curldll.easy_strerror 	= (curl_easy_strerror_t)	dlsym(hModule, "curl_easy_strerror");
		curldll.easy_getinfo 	= (curl_easy_getinfo_t)		dlsym(hModule, "curl_easy_getinfo");
		curldll.slist_append 	= (curl_slist_append_t)		dlsym(hModule, "curl_slist_append");
		curldll.slist_free_all 	= (curl_slist_free_all_t)	dlsym(hModule, "curl_slist_free_all");
		curldll.easy_cleanup 	= (curl_easy_cleanup_t)		dlsym(hModule, "curl_easy_cleanup");
		curldll.global_init 	= (curl_global_init_t)		dlsym(hModule, "curl_global_init");
		curldll.global_cleanup 	= (curl_global_cleanup_t)	dlsym(hModule, "curl_global_cleanup");
		curldll.easy_duphandle 	= (curl_easy_duphandle_t)	dlsym(hModule, "curl_easy_duphandle");

		dllloaded = true;
		return true;
	#endif
	}

    std::string 	getHost() 		const { return host; }
    int 			getPort() 		const { return port; }
    std::string 	getUsername() 	const { return username; }
    std::string 	getPassword() 	const { return password; }
    std::string 	getKey() 		const { return ssh_key_path; }
								
	zpaqfranzsftp2() : port(22), use_ssh_key(false), curl(NULL)
    {
		if (!dllloaded)
		{	
			if (flagdebug)
				myprintf("40822: do loadLibrary()\n");
			if (!loadLibrary())
			{
				myprintf("40832: No libcurl. Doing a kickstart\n");
#ifdef _WIN32
				kickstartwindows();
#else
				kickstartlinux();
#endif
				seppuku();
			}
		}
		Kurl_global_init(CURL_GLOBAL_DEFAULT);
    }
    
    ~zpaqfranzsftp2() 
	{
        if (flagdebug3) 
			myprintf("41182: zpaqfranzsftp destructor\n");
        disconnect();
        Kurl_global_cleanup();
    }
	
    
    // Set the connection parameters with password
    void setConnection(const std::string& h, int p, const std::string& user, const std::string& pass) 
	{
        host 		= h;
        port 		= p;
        username 	= user;
        password 	= pass;
        use_ssh_key = false;
        if (flagdebug3) 
			myprintf("41192: SFTP setconnection to %s:%d user:%s\n", host.c_str(), port, username.c_str());
    }
    
    // Set the connection parameters with SSH key
    void setConnectionSSH(const std::string& h, int p, const std::string& user, const std::string& key_path) 
	{
		if (!fileexists(key_path))
		{
			myprintf("\n");
			myprintf("38331: GURU -ssh keyfile does not exists <<%Z>>\n",key_path.c_str());
			seppuku();
		}
        host 			= h;
        port 			= p;
        username 		= user;
        ssh_key_path 	= key_path;
        use_ssh_key 	= true;
        if (flagdebug3) 
			myprintf("41205: SFTP with SSH: %s:%d user:%s key:%s\n", 
                             host.c_str(), port, username.c_str(), key_path.c_str());
    }
    
    // Connection to the server
    bool connect() 
	{
        if (flagdebug3) 
			myprintf("31212: connect() to sftp server\n");
        
        curl = Kurl_easy_init();
        if (!curl) 
		{
            if (flagdebug) 
				myprintf("41218! Cannot init curl!\n");
            return false;
        }
        
        char url[1024];
        snprintf(url,sizeof(url), "sftp://%s:%d/", host.c_str(), port);
        
        Kurl_easy_setopt(curl, CURLOPT_URL, url);
        Kurl_easy_setopt(curl, CURLOPT_USERNAME, username.c_str());
        
        if (use_ssh_key) 
		    Kurl_easy_setopt(curl, CURLOPT_SSH_PRIVATE_KEYFILE, ssh_key_path.c_str());
         else 
		    Kurl_easy_setopt(curl, CURLOPT_PASSWORD, password.c_str());

        Kurl_easy_setopt(curl, CURLOPT_SSH_AUTH_TYPES, CURLSSH_AUTH_PASSWORD | CURLSSH_AUTH_PUBLICKEY);
        Kurl_easy_setopt(curl, CURLOPT_VERBOSE, flagdebug3 ? 1L : 0L);
        
        if (flagdebug3) 
			myprintf("41237: sftp connection - done\n");
        return true;
    }
    
    void disconnect() 
	{
        if (curl) 
		{
            if (flagdebug3) 
				myprintf("41254: Closing (disconenct) from SFTP\n");
            Kurl_easy_cleanup(curl);
            curl = NULL;
        }
    }
    
// Structure to count received bytes
	struct FileInfo 
	{
		int64_t size;
		bool file_exists;
	};

	// Callback che conta i bytes ricevuti (anche se sono zero)
	static size_t count_bytes_callback(void* contents, size_t size, size_t nmemb, struct FileInfo* info) 
	{
		(void)contents;
		size_t total_size = size * nmemb;
		info->size += total_size;
		info->file_exists = true;  // If the callback is called, the file exists
		return total_size;
	}

	int64_t remotegetfilesize(const std::string& remote_file) 
	{
		if (!curl) 
		{
			myprintf("41258! No curl in remotegetfilesize\n");
			return -1;
		}
		
		if (flagdebug3) 
			myprintf("41263: Getting remote file size %s\n", remote_file.c_str());
		
		CURL* curl_temp = Kurl_easy_duphandle(curl);
		if (!curl_temp) 
		{
			myprintf("41268! Impossible to duplicate handle curl\n");
			return -1;
		}
		
		char url[1024];
		snprintf(url, sizeof(url),"sftp://%s:%d%s", host.c_str(), port, remote_file.c_str());
		
		// First phase: check if the file exists using a HEAD request
		Kurl_easy_setopt(curl_temp, CURLOPT_URL, url);
		Kurl_easy_setopt(curl_temp, CURLOPT_NOBODY, 1L);
		Kurl_easy_setopt(curl_temp, CURLOPT_WRITEFUNCTION, write_callback);
		
		CURLcode res = Kurl_easy_perform(curl_temp);
		
		if (res != CURLE_OK) 
		{
			if (flagdebug3) 
				myprintf("41297! Remote file not found or error: %s\n", Kurl_easy_strerror(res));
			Kurl_easy_cleanup(curl_temp);
			return -1;
		}
		
		// The file exists, now we try to get the size
		curl_off_t size = -1;
		res = Kurl_easy_getinfo(curl_temp, CURLINFO_CONTENT_LENGTH_DOWNLOAD_T, &size);
		
		if (res == CURLE_OK && size >= 0) 
		{
			// We have obtained the size directly
			if (flagdebug3) 
				myprintf("41291: remote file size %s bytes (via CURLINFO)\n", migliaia((int64_t)size));
			Kurl_easy_cleanup(curl_temp);
			return (int64_t)size;
		}
		
		// Second phase: if we can't get the size,
		// facciamo un download completo per contare i bytes
		if (flagdebug3) 
			myprintf("41285: CURLINFO failed, trying full download to count bytes\n");
		
		struct FileInfo info = {0, false};
		
		// Reset options for full download
		Kurl_easy_setopt(curl_temp, CURLOPT_NOBODY, 0L);  // Enable body download
		Kurl_easy_setopt(curl_temp, CURLOPT_WRITEFUNCTION, count_bytes_callback);
		Kurl_easy_setopt(curl_temp, CURLOPT_WRITEDATA, &info);
		
		res = Kurl_easy_perform(curl_temp);
		
		int64_t file_size = -1;
		if (res == CURLE_OK) 
		{
			file_size = info.size;  // Can be 0 for empty files
			if (flagdebug3) 
				myprintf("41291: remote file size %s bytes (via download)\n", migliaia(file_size));
		} 
		else 
		{
			if (flagdebug3) 
				myprintf("41299! Error during file download: %s\n", Kurl_easy_strerror(res));
		}
		
		Kurl_easy_cleanup(curl_temp);
		return file_size;
	}
    
	
	bool karica(const std::string& local_file, const std::string& remote_file, bool force) 
	{
		if (!curl) 
		{
			myprintf("41253! No curl in karica\n");
			return false;
		}

		if (flagdebug3) 
			myprintf("41315: karica %s -> %s (force: %s)\n", local_file.c_str(), remote_file.c_str(), force ? "true" : "false");
		
		// Get file size locale
		int64_t local_size = prendidimensionefile(local_file.c_str());
		if (local_size < 0) 
		{
			myprintf("41322: local file not found! %s\n",local_file.c_str());
			return false;
		}
		
		if (flagdebug3) 
			myprintf("41327: Local file size %s bytes\n", migliaia(local_size));
		
	    std::vector<std::string> files_to_upload;
		files_to_upload.push_back(local_file);
		std::string remotepath=extractfilepath(remote_file);
		
		
		//rsync with 1 thread only
		if (sftp_rsync(files_to_upload,remotepath,force,1))
		{
			if (flagdebug3) 
				myprintf("41439: upload successfully done\n");
			return true;
		}
		return false;
	}

    
    // Download a file or part of a file from remote to local
    bool downfilerange(const std::string& i_remote, const std::string& i_local, curl_off_t i_start, curl_off_t i_end, bool i_append) 
	{
	    if (!curl) 
		{
            myprintf("41254! No curl in downfilerange\n");
			return false;
        }

        if (flagdebug) 
		{
            if (i_start == 0 && i_end == 0) 
			{
				myprintf("41566: down full : %s -> %s (append: %s)\n", 
                       i_remote.c_str(), i_local.c_str(), i_append ? "true" : "false");
            } 
			else 
			{
                myprintf("41571: down RANGE : %s -> %s (bytes %s-%s, append: %s)\n", 
                       i_remote.c_str(), i_local.c_str(), migliaia(i_start), migliaia2(i_end), i_append ? "true" : "false");
            }
        }
        
        // Get file size remoto
        int64_t remote_size = remotegetfilesize(i_remote);
        if (remote_size < 0) 
		{
            myprintf("41580: cannot find remote!\n");
			return false;
        }
        
        if (flagdebug3) 
			myprintf("41585: remote file size for down : %s bytes\n",migliaia(remote_size));
        
        // Handling append mode
        curl_off_t actual_start 	= i_start;
        curl_off_t actual_end 		= i_end;
        bool is_resume_mode 		= false;
        int64_t local_size 			= 0;
        
        if (i_append && (i_start == 0 && i_end == 0)) 
		{
            // Append mode: check if the local file exists
            local_size = prendidimensionefile(i_local.c_str());
            if (local_size > 0) 
			{
                if (local_size < remote_size) 
				{
                    // Partial local file: resume download
                    actual_start 	= local_size;
                    actual_end 		= 0; // Until the end
                    is_resume_mode 	= true;
                    if (flagdebug3) 
						myprintf("41606: *** RESUME *** - local: %s bytes, restarting from offset %s (%s bytes to transfer)\n", 
                                         migliaia(local_size), migliaia2(actual_start), migliaia3(remote_size - local_size));
                } 
				else if (local_size == remote_size) 
				{
                    // File already complete
                    if (flagdebug3) 
						myprintf("41613: same down size - SKIP\n");
                    return true;
                } else 
				{
                    // Local file larger than remote: error or corrupted file
                    if (flagdebug) 
						myprintf("41619! Warning: local bigger than remote (%s > %s) - Download interrupted\n", 
                                         migliaia(local_size), migliaia(remote_size));
                    // Proceed with full download overwriting
                }
            } 
			else 
			{
    			myprintf("41627! local file does not exists\n");
	        }
        }
        
        // Range validation (usa actual_start/actual_end dopo gestione append)
        if (actual_start != 0 || actual_end != 0) 
		{
            if (actual_start < 0 || actual_end < 0 || actual_start >= remote_size) 
			{
				myprintf("41636! error - invalid range\n");
                return false;
            }
            if (actual_end > 0 && actual_end >= remote_size) 
			{
                myprintf("41640: actual_end too big => to file size\n");
                actual_end = remote_size - 1;
            }
            if (actual_end > 0 && actual_start > actual_end) 
			{
                myprintf("41656: error actual_start > actual_end\n");
                return false;
            }
        }
        
        FILE* file = fopen(i_local.c_str(), is_resume_mode ? "ab" : "wb");
        if (!file) 
		{
            myprintf("41653! cannot on local file %s : %s\n", i_local.c_str(),is_resume_mode ? "open to append" : "creating");
            return false;
        }
        
        CURL* curl_download = Kurl_easy_duphandle(curl);
        if (!curl_download) 
		{
            fclose(file);
            myprintf("41661! cannot dup handle downrange\n");
            return false;
        }
        
        char url[1024];
        snprintf(url, sizeof(url),"sftp://%s:%d%s", host.c_str(), port, i_remote.c_str());
        
        sftp_downloaddata download_data;
        download_data.file 					= file;
        download_data.total_size 			= remote_size;
        download_data.downloaded 			= 0;
        download_data.start_time 			= mtime();
		download_data.last_progress_time 	= download_data.start_time;
        download_data.start_offset 			= actual_start;
        download_data.end_offset 			= actual_end;
        download_data.local_existing_size 	= is_resume_mode ? local_size : 0;
        
        Kurl_easy_setopt(curl_download, CURLOPT_URL, url);
        Kurl_easy_setopt(curl_download, CURLOPT_WRITEFUNCTION, write_file_callback);
        Kurl_easy_setopt(curl_download, CURLOPT_WRITEDATA, file);
        
        // Set range if necessary
        if (actual_start != 0 || actual_end != 0) 
		{
            std::string rangeStr;
            if (actual_end == 0) 
	            rangeStr = std::to_string(actual_start) + "-";
            else 
			    rangeStr = std::to_string(actual_start) + "-" + std::to_string(actual_end);
            Kurl_easy_setopt(curl_download, CURLOPT_RANGE, rangeStr.c_str());
            if (flagdebug3) 
				myprintf("41692: range: %s\n", rangeStr.c_str());
        }
        
		Kurl_easy_setopt(curl_download, CURLOPT_XFERINFOFUNCTION, download_progress_callback);
		Kurl_easy_setopt(curl_download, CURLOPT_XFERINFODATA, &download_data);
        Kurl_easy_setopt(curl_download, CURLOPT_NOPROGRESS, 0L);
        
        CURLcode res = Kurl_easy_perform(curl_download);
        
        fclose(file);
        Kurl_easy_cleanup(curl_download);
        
        if (res != CURLE_OK) 
		{
            myprintf("41706! error download: %s\n", Kurl_easy_strerror(res));
            remove(i_local.c_str()); // Remove partial file
            return false;
        }
        
        if (flagdebug3) 
			myprintf("41712: download done\n");
        return true;
    }
    
	struct Range 
	{
		curl_off_t 	start;
		curl_off_t 	end;
		std::string file;
	};	
	bool down3(int64_t i_remote_size, const std::string& i_remote, const std::string& i_file1, const std::string& i_file2, const std::string& i_file3)
	{
		if (!curl) 
		{
			myprintf("41721! No curl in down3\n");
			return false;
		}

		std::vector<Range> ranges; 
		if (i_remote_size >= 65536) 
		{
			if (flagdebug3) 
				myprintf("41738: File >= 64KB. 3 chunks\n");
			
			Range range1;
			range1.start = 0;
			range1.end = 16383;
			range1.file = i_file1;
			ranges.push_back(range1);
			
			Range range2;
			range2.start = i_remote_size / 2;
			range2.end = i_remote_size / 2 + 16383;
			range2.file = i_file2;
			ranges.push_back(range2);
			
			Range range3;
			range3.start = i_remote_size - 16384;
			range3.end = i_remote_size - 1;
			range3.file = i_file3;
			ranges.push_back(range3);
		} 
		else 
		{
			if (flagdebug3) 
				myprintf("41544: debug: $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$ File %s  %s < 64KB. One-chunk download\n",i_remote.c_str(),migliaia(i_remote_size));
			if (i_remote_size > 0) 
			{
				Range range;
				range.start = 0;
				range.end = i_remote_size - 1;
				range.file = i_file1;
				ranges.push_back(range);
			}
		}


		CURL* curl_download = Kurl_easy_duphandle(curl);
		if (!curl_download) 
		{
			myprintf("41756! impossible duphandle down3\n");
			return false;
		}
		char url[1024];
		snprintf(url, sizeof(url),"sftp://%s:%d%s", host.c_str(), port, i_remote.c_str());
		Kurl_easy_setopt(curl_download, CURLOPT_URL, url);
		Kurl_easy_setopt(curl_download, CURLOPT_WRITEFUNCTION, write_file_callback);
		Kurl_easy_setopt(curl_download, CURLOPT_XFERINFOFUNCTION, download_progress_callback);
		Kurl_easy_setopt(curl_download, CURLOPT_NOPROGRESS, 0L);
		bool success = true;
		for (size_t i = 0; i < ranges.size(); i++) 	
		{
			const Range& range = ranges[i];
			if (flagdebug3) 
				myprintf("41771: Download range: %s -> %s (bytes %s-%s)\n",
                          i_remote.c_str(), range.file.c_str(), migliaia(range.start), migliaia2(range.end));

			// Range validation
			if (range.start < 0 || range.end < 0 || range.start >= i_remote_size || range.end >= i_remote_size || range.start > range.end) 
			{
				if (flagdebug3) 
					myprintf("41778: invalid range (%s-%s)\n", migliaia(range.start), migliaia2(range.end));
				success = false;
				break;
			}
			FILE* file = fopen(range.file.c_str(), "wb");
			if (!file) 
			{
				myprintf("41768: cannot create local file %s\n", range.file.c_str());
				success = false;
				break;
			}
			sftp_downloaddata download_data;
			download_data.file 					= file;
			download_data.total_size 			= i_remote_size;
			download_data.downloaded 			= 0;
			download_data.start_time 			= mtime(); // time(NULL);
			download_data.last_progress_time 	= download_data.start_time;
			download_data.start_offset 			= range.start;
			download_data.end_offset 			= range.end;
			download_data.local_existing_size 	= 0; // No resume mode for these chunks
			Kurl_easy_setopt(curl_download, CURLOPT_WRITEDATA, file);
			std::string rangeStr = std::to_string(range.start) + "-" + std::to_string(range.end);
			Kurl_easy_setopt(curl_download, CURLOPT_RANGE, rangeStr.c_str());
			if (flagdebug3) 
				myprintf("41805: Range range: %s\n", rangeStr.c_str());
			Kurl_easy_setopt(curl_download, CURLOPT_PROGRESSDATA, &download_data);
			CURLcode res = Kurl_easy_perform(curl_download);
			fclose(file);
			if (res != CURLE_OK) 
			{
				myprintf("41814! Error download range %s: %s\n", range.file.c_str(), Kurl_easy_strerror(res));
				remove(range.file.c_str()); // Remove partial file
				success = false;
				break;
			}
			if (flagdebug3) 
				myprintf("41821: Download chunk completated: %s\n", range.file.c_str());
		}
		Kurl_easy_cleanup(curl_download);
		return success;
	}
    // Create remote directory recursively
	bool sftpmkdir(const std::string& i_remote) 
	{
		if (!curl) 
		{
			myprintf("41836! No curl in sftpmkdir\n");
			return false;
		}
		if (flagdebug3) 
			myprintf("41841: making directory %s\n", i_remote.c_str());
		
		std::string current_path = i_remote;
		
		// Normalizza il percorso (rimuovi / finale se presente)
		if (!current_path.empty() && current_path.back() == '/') 
			current_path.pop_back();
		
		// Create each directory in the path incrementally
		std::string cumulative_path;
		size_t start = 0;
		
		// If the path starts with /, start from the root
		if (!current_path.empty() && current_path[0] == '/') 
		{
			cumulative_path = "";
			start = 1;  // Skip the first '/'
		}
		
		size_t pos = start;
		while (pos <= current_path.length()) 
		{
			// Find the next '/' or the end of the string
			size_t next_slash = current_path.find('/', pos);
			if (next_slash == std::string::npos) 
				next_slash = current_path.length();
			
			// If we found a component
			if (next_slash > pos) 
			{
				std::string component = current_path.substr(pos, next_slash - pos);
				
				// Build the incremental path
				if (cumulative_path.empty()) 
					cumulative_path = "/" + component;
				else 
					cumulative_path += "/" + component;
				
				if (flagdebug3) 
					myprintf("41873: Attempt making : %s\n", cumulative_path.c_str());
				
				CURL* curl_mkdir = Kurl_easy_duphandle(curl);
				if (!curl_mkdir) 
				{
					myprintf("41878! impossible duplicating sftpmkdir\n");
					return false;
				}
				
				// For SFTP use CURLOPT_QUOTE with mkdir, not CURLOPT_FTP_CREATE_MISSING_DIRS
				char mkdir_command[1024];
				snprintf(mkdir_command, sizeof(mkdir_command), "mkdir %s", cumulative_path.c_str());
				
				struct curl_slist* quote_list = NULL;
				quote_list = Kurl_slist_append(quote_list, mkdir_command);
				
				char url[1024];
				snprintf(url, sizeof(url),"sftp://%s:%d/", host.c_str(), port);
				
				Kurl_easy_setopt(curl_mkdir, CURLOPT_URL, url);
				Kurl_easy_setopt(curl_mkdir, CURLOPT_QUOTE, quote_list);
				Kurl_easy_setopt(curl_mkdir, CURLOPT_NOBODY, 1L);
				
				CURLcode res = Kurl_easy_perform(curl_mkdir);
				
				Kurl_slist_free_all(quote_list);
				Kurl_easy_cleanup(curl_mkdir);
				
				if (res != CURLE_OK) 
				{
					// It might already exist, let's try to continue
					if (flagdebug3) 
						myprintf("41896: Directory %s: %s (already existent?)\n", 
								 cumulative_path.c_str(), Kurl_easy_strerror(res));
				} 
				else 
				{
					if (flagdebug) 
						myprintf("41902: Directory %s successfully created\n", cumulative_path.c_str());
				}
			}
			
			pos = next_slash + 1;
		}
		
		if (flagdebug3) 
			myprintf("41907: mkdir done\n");
		return true;
	}
    
    // Delete remote file
    bool sftpdeletefile(const std::string& i_remotefile) 
	{
        if (!curl) 
		{
            myprintf("41831! No curl in sftpdeletefile\n");
			return false;
        }
        
        if (flagdebug3) 
			myprintf("41921: deleting remote file: %s\n", i_remotefile.c_str());
        
        CURL* curl_delete = Kurl_easy_duphandle(curl);
        if (!curl_delete) 
		{
            myprintf("41926: cannot duplicate sftpdeletefile\n");
            return false;
        }
        
        char url[1024];
        snprintf(url, sizeof(url),"sftp://%s:%d%s", host.c_str(), port, i_remotefile.c_str());
        
        // Set the options for deletion
        Kurl_easy_setopt(curl_delete, CURLOPT_URL, url);
        Kurl_easy_setopt(curl_delete, CURLOPT_QUOTE, NULL);
        
        // Use POSTQUOTE to delete the file after connection
        struct curl_slist* commands 	= NULL;
        std::string rm_command 			= "rm " + i_remotefile;
        commands 						= Kurl_slist_append(commands, rm_command.c_str());
        Kurl_easy_setopt(curl_delete, CURLOPT_POSTQUOTE, commands);
        
        Kurl_easy_setopt(curl_delete, CURLOPT_NOBODY, 1L);
        CURLcode res = Kurl_easy_perform(curl_delete);
        
        Kurl_slist_free_all(commands);
        Kurl_easy_cleanup(curl_delete);
        
        if (res != CURLE_OK) 
		{
            myprintf("41951: Error deleting %s\n", Kurl_easy_strerror(res));
            return false;
        }
        
        if (flagdebug3) 
			myprintf("41956: remote file deleted OK\n");
        return true;
    }

// Structure to capture output
	struct WriteData 
	{
		std::string data;
	};

// Callback per catturare l'output
	static size_t WriteCallback(void* contents, size_t size, size_t nmemb, WriteData* userdata) 
	{
		size_t totalSize = size * nmemb;
		userdata->data.append((char*)contents, totalSize);
		return totalSize;
	}

	bool check_ssh_support() 
	{
		curl_version_info_data* version_info = curldll.my_version_info(CURLVERSION_NOW);
		
		myprintf("38765: libcurl version: %s\n", version_info->version);
		myprintf("38766: Supported protocols: ");
		
		bool ssh_supported = false;
		for (int i = 0; version_info->protocols[i]; i++) 
		{
			myprintf("%s ", version_info->protocols[i]);
			if (strcmp(version_info->protocols[i], "ssh") == 0) 
				ssh_supported = true;
		}
		myprintf("\n");
		
		if (!ssh_supported) 
		{
			myprintf("38779! SSH protocol not supported in this libcurl build!\n");
			return false;
		}
		
		myprintf("SSH protocol is supported\n");
		return true;
	}

	bool xremote_command(const std::string& command, std::string& output) 
	{
		if (!curl) 
		{
			myprintf("38747! No curl in xremote_command\n");
			return false;
		}
		
		if (flagdebug3) 
			myprintf("41923: executing remote command: %s\n", command.c_str());
		
		CURL* curl_command = Kurl_easy_duphandle(curl);
		if (!curl_command) 
		{
			myprintf("41932: cannot duplicate xremote_command\n");
			return false;
		}
		
		// Structure to capture output
		WriteData writeData;
		
		char url[1024];
		snprintf(url, sizeof(url), "sftp://%s:%d/", host.c_str(), port);
		
		Kurl_easy_setopt(curl_command, CURLOPT_URL, url);
		
		// Configure the callback to capture the output
		Kurl_easy_setopt(curl_command, CURLOPT_WRITEFUNCTION, WriteCallback);
		Kurl_easy_setopt(curl_command, CURLOPT_WRITEDATA, &writeData);
		
		// Use QUOTE to execute the command
		struct curl_slist* commands = NULL;
		commands = Kurl_slist_append(commands, command.c_str());
		Kurl_easy_setopt(curl_command, CURLOPT_QUOTE, commands);
		
		// Do not use NOBODY if you want to capture the output
		Kurl_easy_setopt(curl_command, CURLOPT_NOBODY, 0L);
		
		CURLcode res = Kurl_easy_perform(curl_command);
		
		Kurl_slist_free_all(commands);
		Kurl_easy_cleanup(curl_command);
		
		if (res != CURLE_OK) 
		{
			myprintf("31951: Error xcommand %s\n", Kurl_easy_strerror(res));
			return false;
		}
		
		output = writeData.data;
		
		if (flagdebug3) 
			myprintf("41953: remote command OK, output: %s\n", output.c_str());
		
		return true;
	}

	// Specific function for md5sum
	bool xremote_md5sum(const std::string& pattern, std::string& md5_output) 
	{
		std::string command = "md5sum " + pattern;
		return xremote_command(command, md5_output);
	}

	bool listremotedir(const std::string& i_remote, std::vector<sftpfileinfo>* o_filearray, const std::string& filter = "") 
	{
        if (!curl) 
		{
            myprintf("41831! No curl in listremotedir\n");
			return false;
        }
		
		if (!o_filearray) 
		{
			myprintf("42186: puntatore array null\n");
			return false;
		}
		
		if (flagdebug) 
			myprintf("42190: Listing directory: %s (filter: %s)\n", 
							 i_remote.c_str(), filter.empty() ? "none" : filter.c_str());
		
		// Clear the output array
		o_filearray->clear();
		
		CURL* curl_list = Kurl_easy_duphandle(curl);
		if (!curl_list) 
		{
			myprintf("42199: impossible to dup handle listremotedir\n");
			return false;
		}
		
		// Build URL for listing - SFTP simply uses the directory URL
		char url[1024];
		std::string dir_path = i_remote;
		if (!dir_path.empty() && dir_path.back() != '/') 
			dir_path += "/";
		snprintf(url,sizeof(url), "sftp://%s:%d%s", host.c_str(), port, dir_path.c_str());
		
		// Prepare data for the callback
		sftp_listingdata listing_data(o_filearray, i_remote, filter);
		
		// Configure curl for SFTP listing
		Kurl_easy_setopt(curl_list, CURLOPT_URL, url);
		Kurl_easy_setopt(curl_list, CURLOPT_WRITEFUNCTION, listing_callback);
		Kurl_easy_setopt(curl_list, CURLOPT_WRITEDATA, &listing_data);
		
		// For SFTP, use CURLOPT_DIRLISTONLY to get only the names
		// or leave it at 0 for detailed information
		Kurl_easy_setopt(curl_list, CURLOPT_DIRLISTONLY, 0L);
		
		CURLcode res = Kurl_easy_perform(curl_list);
		Kurl_easy_cleanup(curl_list);
		
		if (res != CURLE_OK) 
		{
			myprintf("42233: Error listing directory: %s\n", Kurl_easy_strerror(res));
			return false;
		}

		std::sort(o_filearray->begin(), o_filearray->end(), compareSftpFileInfo);
		/*
		// Ordina alfabeticamente il vettore risultato
		std::sort(o_filearray->begin(), o_filearray->end(), [](const sftpfileinfo& a, const sftpfileinfo& b) {
			return a.name < b.name;
		});
		*/
		if (flagdebug3) 
			myprintf("42243: listing done and sorted: %d elements\n", (int)o_filearray->size());
		
		return true;
	}

	bool sftp_down3parallela		(std::vector<sftpget3>& file_list, int i_thread);
								
	bool sftp_rsync	(	const 	std::vector<std::string>& local_files, 
										const 	std::string& remote_path, 
										bool 	force_flag, 
										int 	i_thread);
};

// Data structures for threading
struct sftp_rsync_thread_data 
{
    int 							thread_id;
    zpaqfranzsftp2* 				sftp_instance;
    std::queue<std::string>* 		file_queue;
    std::mutex* 					queue_mutex;
    std::condition_variable* 		queue_cv;
    std::string 					remote_path;
    bool 							force_flag;
    bool* 							should_stop;
	int								maxbandwidth;
    
    // Statistics per thread
    std::string 					current_file;
	int64_t 						current_file_size;
    int64_t 						current_uploaded;
    int64_t 						thread_start_time;
    int64_t 						last_update_time;
    double 							current_speed;
    enum { SFTP_IDLE, SFTP_UPLOAD, SFTP_ERROR, SFTP_DONE } status;
	int64_t							resume_from;
	int 							ultima_percentuale;
    std::string status_message;
    
    sftp_rsync_thread_data() : 
	thread_id			(0), 
	sftp_instance		(nullptr), 
	file_queue			(nullptr), 
    queue_mutex			(nullptr), 
	queue_cv			(nullptr), 
	force_flag			(false),
	should_stop			(nullptr),
	maxbandwidth		(0),
	current_file_size	(0), 
	current_uploaded	(0),
    thread_start_time	(0), 
	last_update_time	(0), 
	current_speed		(0.0),
    status				(SFTP_IDLE),
	resume_from(0),
	ultima_percentuale(0)	{}
};

struct sftp_rsync_progress_data 
{
    int 									total_files;
    int 									completed_files;
    int64_t 								total_start_time;
    std::vector<sftp_rsync_thread_data*> 	threads;
    std::mutex progress_mutex;
    
    sftp_rsync_progress_data() : 
	total_files			(0), 
	completed_files		(0), 
	total_start_time	(0) {}
};

// Callback per il progresso dell'upload

static size_t sftp_rsync_progress_callback(void* clientp, curl_off_t dltotal, curl_off_t dlnow,curl_off_t ultotal, curl_off_t ulnow) 
{
	(void)dlnow;
	(void)ultotal;
	(void)dltotal;
    sftp_rsync_thread_data* data = static_cast<sftp_rsync_thread_data*>(clientp);
    if (data) 
	{
		int64_t istante			= mtime();
        int64_t time_from_start = istante - data->thread_start_time;

		if (time_from_start>0)
			if ((istante-data->last_update_time)>1000)
			{
				int64_t bytes_diff = data->current_uploaded;
				if (bytes_diff > 0) 
				{
					data->current_speed = (double)bytes_diff / (time_from_start / 1000.0); 
					/*
					gotoxy(0,10+data->thread_id);
					printf("Thread %d: time_from_start=%d bytes_diff=%d, speed=%s/s",
                             data->thread_id, time_from_start, bytes_diff, tohuman3((int64_t)data->current_speed));
					*/
				}
				data->last_update_time = istante;
				data->current_uploaded = (int64_t)ulnow;
			}
     }
    
    return 0;
}
// Callback per la scrittura dei dati
static size_t sftp_rsync_read_callback(void* ptr, size_t size, size_t nmemb, void* userdata) 
{
    FILE* file = static_cast<FILE*>(userdata);
    return fread(ptr, size, nmemb, file);
}

// Worker function for each thread
static void* sftp_rsync_worker_thread(void* arg) 
{
    sftp_rsync_thread_data* data = static_cast<sftp_rsync_thread_data*>(arg);
    
    while (!*(data->should_stop)) 
	{
        std::string current_file;
        
        {
            std::unique_lock<std::mutex> lock(*(data->queue_mutex));
            
            // Replace the lambda with an explicit loop
            while (data->file_queue->empty() && !*(data->should_stop)) {
                data->queue_cv->wait(lock);
            }
            
            if (*(data->should_stop)) 
                break;
            
            if (!data->file_queue->empty()) 
            {
                current_file = data->file_queue->front();
                data->file_queue->pop();
            } 
            else 
                continue;
        }
        data->current_file = current_file;
		
        data->status 				= sftp_rsync_thread_data::SFTP_UPLOAD;
        data->thread_start_time		= mtime();
        data->last_update_time 		= data->thread_start_time;
        data->current_uploaded 		= 0;
        data->current_speed 		= 0.0;
        data->ultima_percentuale 	= 0;
        
        // Check if the local file exists
        if (!fileexists(current_file)) 
		{
            data->status 			= sftp_rsync_thread_data::SFTP_ERROR;
            data->status_message 	= "File not foud";
            continue;
        }
        
        // Get file size locale
        int64_t local_size = prendidimensionefile(current_file.c_str());
        if (local_size < 0) 
		{
            data->status 			= sftp_rsync_thread_data::SFTP_ERROR;
            data->status_message 	= "Size error";
            continue;
        }
///		data->local_file_size= local_size;
		
        data->current_file_size = local_size;
        
        // Build remote path
        std::string filename 	= extractfilename(current_file);
        std::string remote_file = data->remote_path;
        if (remote_file.back() != '/') remote_file += '/';
        remote_file += filename;
       
        // Check if the remote file exists and its size
        int64_t remote_size = 0;
        int64_t resume_from = 0;
        
		if (!data->force_flag) 
		{
			remote_size = data->sftp_instance->remotegetfilesize(remote_file);
			
			myprintf("DEBUG3: ********************************* %d %s\n", remote_size, remote_file.c_str());

			// If remote_size is -1, the file does not exist, proceed with full upload
			if (remote_size == -1) {
				///fikoremote_size = 0;  // Tratta come file inesistente
				resume_from = 0;
			}
			else if (remote_size > 0) 
			{
				if (remote_size >= local_size) 
				{
					data->status = sftp_rsync_thread_data::SFTP_DONE;
					data->status_message = "Already done";
					continue;
				} 
				else 
				{
					resume_from = remote_size;
				}
			}
		}
		data->resume_from=resume_from;
        // Open local file
        FILE* file = fopen(current_file.c_str(), "rb");
        if (!file) 
		{
            data->status 			= sftp_rsync_thread_data::SFTP_ERROR;
            data->status_message 	= "Error in fopen";
            continue;
        }
		// OPTIMIZATION 1: Larger buffer for reading
		const size_t BUFFER_SIZE 	= 1024 * 1024; // 1MB invece del default
		char* buffer 				= new char[BUFFER_SIZE];
		setvbuf(file, buffer, _IOFBF, BUFFER_SIZE);
        
        // If resuming, jump to the correct position
        if (resume_from > 0) 
		{
 #ifdef _WIN32
			_fseeki64(file, resume_from, SEEK_SET);
#else
			fseeko(file, resume_from, SEEK_SET);
#endif
        }
        
        // Configure CURL for upload
        CURL* curl_handle = Kurl_easy_duphandle(data->sftp_instance->curl);
        if (!curl_handle) 
		{
            fclose(file);
			delete[] buffer; // Free the buffer in case of error
            data->status 			= sftp_rsync_thread_data::SFTP_ERROR;
            data->status_message 	= "CURL Error duphandle";
            continue;
        }
        
        char url[1024];
        snprintf(url, sizeof(url),"sftp://%s:%d%s", 
                data->sftp_instance->getHost().c_str(), 
                data->sftp_instance->getPort(), 
                remote_file.c_str());
        
        Kurl_easy_setopt(curl_handle, CURLOPT_URL, url);
        Kurl_easy_setopt(curl_handle, CURLOPT_UPLOAD, 1L);
		if (data->maxbandwidth>0)
			Kurl_easy_setopt(curl_handle, CURLOPT_MAX_SEND_SPEED_LARGE,data->maxbandwidth);
        Kurl_easy_setopt(curl_handle, CURLOPT_READFUNCTION, sftp_rsync_read_callback);
        Kurl_easy_setopt(curl_handle, CURLOPT_READDATA, file);
        Kurl_easy_setopt(curl_handle, CURLOPT_INFILESIZE_LARGE, (curl_off_t)(local_size - resume_from));
        
		
		// OPTIMIZATION 2: Buffer size for libcurl
		Kurl_easy_setopt(curl_handle, CURLOPT_BUFFERSIZE, BUFFER_SIZE);
		///  experimental
		Kurl_easy_setopt(curl_handle, CURLOPT_UPLOAD_BUFFERSIZE, BUFFER_SIZE); // Or a value up to 2MB
	   // OPTIMIZATION 3: Higher timeouts to avoid disconnections
		Kurl_easy_setopt(curl_handle, CURLOPT_TIMEOUT, 0L);           // No total timeout
		Kurl_easy_setopt(curl_handle, CURLOPT_LOW_SPEED_LIMIT, 1024L); // 1KB/s minimo
		Kurl_easy_setopt(curl_handle, CURLOPT_LOW_SPEED_TIME, 30L);   // For 30 seconds
		
		// OPTIMIZATION 4: TCP options for performance
		Kurl_easy_setopt(curl_handle, CURLOPT_TCP_NODELAY, 1L);       // Disable Nagle algorithm
		Kurl_easy_setopt(curl_handle, CURLOPT_TCP_KEEPALIVE, 1L);     // Keep connection alive
		Kurl_easy_setopt(curl_handle, CURLOPT_TCP_KEEPIDLE, 60L);     // Keepalive dopo 60s
		Kurl_easy_setopt(curl_handle, CURLOPT_TCP_KEEPINTVL, 30L);    // Interval tra keepalive
		
		// OPTIMIZATION 5: Specific SSH options
		Kurl_easy_setopt(curl_handle, CURLOPT_SSH_COMPRESSION, 0L);   // Disable SSH compression
	
        if (resume_from > 0) 
		    Kurl_easy_setopt(curl_handle, CURLOPT_RESUME_FROM_LARGE, (curl_off_t)resume_from);
        
        // Callback per il progresso
        Kurl_easy_setopt(curl_handle, CURLOPT_XFERINFOFUNCTION, sftp_rsync_progress_callback);
        Kurl_easy_setopt(curl_handle, CURLOPT_XFERINFODATA, data);
        Kurl_easy_setopt(curl_handle, CURLOPT_NOPROGRESS, 0L);
        
        // Perform upload
        CURLcode res = Kurl_easy_perform(curl_handle);
        
        fclose(file);
		delete[] buffer; // Free the buffer in case of error
        Kurl_easy_cleanup(curl_handle);
        
        if (res == CURLE_OK) 
		{
            data->status 			= sftp_rsync_thread_data::SFTP_DONE;
            data->status_message 	= "Completed and OK";
        } else 
		{
            data->status 			= sftp_rsync_thread_data::SFTP_ERROR;
            data->status_message 	= Kurl_easy_strerror(res);
        }
    }
    
    return nullptr;
}

// Function to update the progress display
static void sftp_rsync_update_display(sftp_rsync_progress_data* progress) 
{
	bool	ismultithread=progress->threads.size()>1;
	
    // Calculate global statistics
    int 		completed 		= 0;
    double 		total_speed 	= 0.0;
	double 		max_eta			= 0;
	int64_t 	total_uploaded	= 0;
	int64_t 	total_remaining	= 0;
	
    for (size_t i = 0; i < progress->threads.size(); ++i) 
	{
        const sftp_rsync_thread_data* thread = progress->threads[i];
        if (thread->status == sftp_rsync_thread_data::SFTP_DONE) 
		    completed++;
        total_speed += thread->current_speed;
    }
    
	if (ismultithread)
		gotoxy(0, 1);
    
	
    for (size_t i = 0; i < progress->threads.size(); ++i) 
	{
        sftp_rsync_thread_data* thread = progress->threads[i];
		///int64_t remaining = thread->current_file_size-thread->current_uploaded;
        int64_t remaining = thread->current_file_size-thread->current_uploaded-thread->resume_from;
        
        const char* status_str;
        switch (thread->status) 
		{
            case sftp_rsync_thread_data::SFTP_IDLE:   status_str = "IDLE  "; color_yellow(); 	break;
            case sftp_rsync_thread_data::SFTP_UPLOAD: status_str = "UPLOAD"; color_cyan(); 		break;
            case sftp_rsync_thread_data::SFTP_ERROR:  status_str = "ERROR "; color_red(); 		break;
            case sftp_rsync_thread_data::SFTP_DONE:   status_str = "DONE  "; color_green(); remaining=0; 
			thread->current_uploaded	=0;
			thread->current_speed		=0;
			break;
            default: status_str = "UNKNOW"; break;
        }
        total_remaining+=remaining;
		double eta = (thread->current_speed > 0) ? remaining / thread->current_speed : 0;
                
		if (eta>max_eta)
			max_eta=eta;
		
		int eta_hours 	= (int)(eta / 3600);
		int eta_minutes = (int)((eta - eta_hours * 3600) / 60);
		int eta_seconds = (int)(eta - eta_hours * 3600 - eta_minutes * 60);
				
		if (eta_hours>99)
			eta_hours=99;
		
		total_uploaded+=thread->current_uploaded;
		
		  double percentuale = ((double)remaining / (thread->current_file_size + 1)) * 100.0;
		int percentuale_intera = (int)(percentuale); // Percentage completed (100 - remaining)


if ((percentuale_intera % 5 == 0) && (thread->ultima_percentuale != percentuale_intera)) 
{
	        thread->ultima_percentuale = percentuale_intera; // Update the last percentage
  
 myprintf("#%02d [%7s] %03d%% %12s ETA:%02d:%02d:%02d | %12s @%12s/s | %s",
                 thread->thread_id,
                 status_str,
				 percentuale_intera,
				 tohuman(remaining),
				 eta_hours, eta_minutes, eta_seconds,
                 ///tohuman2(thread->current_file_size),
                 tohuman3(thread->current_uploaded),
                 tohuman4((int64_t)thread->current_speed),
                 extractfilename(thread->current_file).c_str());
} 
else 
{
 printf("#%02d [%7s] %03d%% %12s ETA:%02d:%02d:%02d | %12s @%12s/s | %s",
                 thread->thread_id,
                 status_str,
				 percentuale_intera,
				 tohuman(remaining),
				 eta_hours, eta_minutes, eta_seconds,
                 ///tohuman2(thread->current_file_size),
                 tohuman3(thread->current_uploaded),
                 tohuman4((int64_t)thread->current_speed),
                 extractfilename(thread->current_file).c_str());
}
		color_restore();
        eol();
if ((percentuale_intera % 5 == 0) && (thread->ultima_percentuale != percentuale_intera)) 
{
		if (ismultithread)
			myprintf("\n");
		else
			myprintf("\r");
}
else
{
		if (ismultithread)
			printf("\n");
		else
			printf("\r");

}
    }

	if (ismultithread)
	{
		static int last_console_y 	= 0;
    
		gotoxy(0, 0);
		int eta_hours = (int)(max_eta / 3600);
		int eta_minutes = (int)((max_eta - eta_hours * 3600) / 60);
		int eta_seconds = (int)(max_eta - eta_hours * 3600 - eta_minutes * 60);
		if (eta_hours>99)
			eta_hours=99;
			
		myprintf("Global TODO:  %12s ETA:%02d:%02d:%02d   (%6.2f%%)    (%12s @%12s/s)",
			tohuman(total_remaining),
			eta_hours, eta_minutes, eta_seconds,
			(double)completed * 100.0 / progress->total_files,
			tohuman3(total_uploaded),
			tohuman2(total_speed));

		// Remember the last position
		int current_y = 1 + (int)progress->threads.size();
		while (last_console_y > current_y) 
		{
			clear_line();
			myprintf("\n");
			last_console_y--;
		}
		last_console_y = current_y;
	}
}

curldynfunctions 	zpaqfranzsftp2::curldll = {};
bool 				zpaqfranzsftp2::dllloaded = false;

bool zpaqfranzsftp2::sftp_rsync(const std::vector<std::string>& local_files, const std::string& remote_path, bool force_flag, int i_thread) 
{
    
	if (local_files.empty()) 
	{
		myprintf("42516: No file to transfer\n");
		return false;
	}
	
	if ((i_thread < 1) || (i_thread > 99)) 
	{
		myprintf("42522: Invalid thread number : %d (1-99)\n", i_thread);
		return false;
	}
	
	if (!curl) 
	{
		myprintf("42528! Curl SFTP not OK\n");
		return false;
	}
	
	// Initialize the data structures
	std::queue<std::string> 	file_queue;
	std::mutex 					queue_mutex;
	std::condition_variable 	queue_cv;
	bool should_stop 			= false;
	
	// Populate the queue with files
	for (std::vector<std::string>::const_iterator it = local_files.begin(); 
     it != local_files.end(); ++it) 
    file_queue.push(*it);
/*
	for (const auto& file : local_files) 
		file_queue.push(file);
*/	
	// Create progress structure
	sftp_rsync_progress_data progress;
	progress.total_files 		= (int)local_files.size();
	progress.completed_files 	= 0;
	progress.total_start_time 	= mtime();
	
	if (i_thread>(int)local_files.size())
		i_thread=local_files.size();
	
	// Create thread data
	std::vector<sftp_rsync_thread_data> thread_data(i_thread);
	std::vector<pthread_t> threads(i_thread);

	if (g_sftp_bandwidth>0)
		g_sftp_bandwidth=(g_sftp_bandwidth/i_thread);
	for (int i = 0; i < i_thread; ++i) 
	{
		thread_data[i].thread_id 		= i + 1;
		thread_data[i].sftp_instance 	= this;
		thread_data[i].file_queue 		= &file_queue;
		thread_data[i].queue_mutex 		= &queue_mutex;
		thread_data[i].queue_cv 		= &queue_cv;
		thread_data[i].remote_path 		= remote_path;
		thread_data[i].force_flag 		= force_flag;
		thread_data[i].should_stop 		= &should_stop;
		thread_data[i].maxbandwidth 	= g_sftp_bandwidth;
		
		
		progress.threads.push_back(&thread_data[i]);
		
		if (pthread_create(&threads[i], nullptr, sftp_rsync_worker_thread, &thread_data[i]) != 0) 
		{
			myprintf("42570! Error making thread  %d\n", i + 1);
			should_stop = true;
			return false;
		}
	}
	
	// Hide cursor and clear screen
	hide_cursor();
	if (i_thread>1)
	{
		setupConsole();
		printf("\033[2J"); //cls
		printf("\033[%d;0H",(int)1);
		restoreConsole();
	}
	else
		myprintf("VERBOSE: Upload one file at time (single thread)\n");
	// Loop di monitoraggio
	while (!should_stop) 
	{
		{
			std::lock_guard<std::mutex> lock(queue_mutex);
			if (file_queue.empty()) 
			{
				// Check if all threads have finished
				bool all_done = true;
				for (int i = 0; i < i_thread; ++i) 
					if (thread_data[i].status == sftp_rsync_thread_data::SFTP_UPLOAD) 
					{
						all_done = false;
						break;
					}
				if (all_done) 
					should_stop = true;
			}
		}
		
		sftp_rsync_update_display(&progress);
		
		if (!should_stop) 
#ifdef _WIN32
			Sleep(1000); // Windows: pausa in millisecondi
#else
			usleep(1000000); // Linux: pausa di 1 secondo (1000 ms = 1000000 µs)
#endif

	}
	
	// Notify all threads to stop
	queue_cv.notify_all();
	
	// Wait for all threads to finish
	for (int i = 0; i < i_thread; ++i) 
		pthread_join(threads[i], nullptr);
	
	// Final update
	sftp_rsync_update_display(&progress);
	
	// Restore cursor
	show_cursor();
	
	// Count the successes
	int successful	 = 0;
	int errors 		= 0;
	
	for (int i=0;i<i_thread;i++)
	{
		if (thread_data[i].status == sftp_rsync_thread_data::SFTP_DONE) 
		{
			successful++;
		} 
		else 
		if (thread_data[i].status == sftp_rsync_thread_data::SFTP_ERROR) 
		{
			errors++;
		}
	}
	if (i_thread>1)
		gotoxy(0,i_thread+2);
	if (errors==0)
		color_green();
	myprintf("42637: Outcome: successful %d, %d error", successful, errors);
	eol();
	myprintf("\n");
	color_restore();
	return errors == 0;
}
///finefima1

#endif
#endif ///NOSFTPEND






// Create or update an existing archive or part. If filename is ""
// then keep track of position in off but do not write to disk. Otherwise
// open and encrypt with password if not 0. If the file exists then
// read the salt from the first 32 bytes and off_ must be 0. Otherwise
// encrypt assuming off_ previous bytes, of which the first 32 are salt_.
// If off_ is 0 then write salt_ to the first 32 bytes.
OutputArchive::OutputArchive(string i_thearchive,const char* filename, const char* password,
    const char* salt_, int64_t off_): /*off(off_), */ptr(0) 
	{
  assert(filename);
	off=off_;
	thefilename="";
	flagindex=false;
	///g_p_franzenfile=0;
	
  if (!*filename) return;
  
	thefilename=filename;
	chunknumber=0;
	writtensofar=0;
	writtenonlastchunk=0;
	firstchunk=true;
	previoussize=0;
	if (g_chunk_size>0)
	{
		firstfilename=i_thearchive;
		easymultipart chunkedoutput(i_thearchive);
		if (chunkedoutput.filenamearray.size()==0)
			firstchunk=true;
		else
			firstchunk=false;
		
		if (flagdebug4)
		{
			myprintf("00280: is firstchunk %d\n",(int)firstchunk);
			myprintf("00281: chunkedoutput count %s total size %21s\n",migliaia(chunkedoutput.filenamearray.size()),migliaia2(chunkedoutput.totalchunksize));
			myprintf("00282: last %s next %s\n",chunkedoutput.lastpart.c_str(),chunkedoutput.nextpart.c_str());
		}
		if (chunkedoutput.nextpart_integer>chunkedoutput.maxpart)
		{
			myprintf("00283: proposed next_partinteger %s is > maxpart %s\n",migliaia(chunkedoutput.nextpart_integer),migliaia2(chunkedoutput.maxpart));
			seppuku();
			return;
		}
		chunknumber=chunkedoutput.nextpart_integer;
		thefilename=chunkedoutput.nextpart;
		if (flagdebug)
			myprintf("00284: changed thefilename to %s\n",thefilename.c_str());
		
		previoussize=chunkedoutput.totalchunksize;
		if (flagdebug4)
			myprintf("00285: previoussize %s\n",migliaia(previoussize));
	}	
	
	// Open existing file
  char salt[32]={0};
#ifdef BSD
	if (flagappend)
	{
		if (flagdebug2)
			myprintf("00286: try BSD ABPLUS\n");
		fp=myfopen(thefilename.c_str(), ABPLUS);
	}
	else
	fp=myfopen(thefilename.c_str(), RBPLUS);
#else
	fp=myfopen(thefilename.c_str(), RBPLUS);
#endif // corresponds to #ifdef (#ifdef BSD)

	if (flagdebug3)
		myprintf("00287: ***********************************************************\n");
	if (g_chunk_size>0)
	{
		///g_addedchunklist_fp.push_back(fp);
		g_addedchunklist.push_back(thefilename);
	}		
				
	if (isopen()) 
	{
		if (flagdebug3)
		{
			printbar('1');
			myprintf("00288: off inside isopen is %s\n",migliaia(off));
		}
		if (off!=0) 
		{
			if (flagdebug)
			{
				myprintf("00289: thefilename is %s  %s\n",thefilename.c_str(),migliaia(off));
				if (fileexists(thefilename))
					myprintf("00290: does exists\n");
				else
					myprintf("00291: does not exists\n");
			}
			error("38583$ file exists and off > 0 (maybe try to add to chunked?)");
		}
    if (password) {
		if (flagdebug2)
		myprintf("00292: password, reading salt\n");
      if (fread(salt, 1, 32, fp)!=32) 
		  error("38679: cannot read salt");
      if (salt_ && memcmp(salt, salt_, 32))
		  error("salt mismatch");
	  else
	  {
		if (flagdebug2)
		  myprintf("00293: salt done!\n");
	  }
    }

    seek(0, SEEK_END);

#ifdef ZPAQFULL ///NOSFTPSTART		
	if (g_franzen!="")
	{
		if (g_p_franzenfile)
		{
			myprintf("44386! franzenfile already setted (should not)!\n");
		}
		else
		{
			string franzenfilename=thefilename+".franzen";
			g_p_franzenfile = new franzcri(g_franzen.c_str(),g_franzen.length());
			if (g_p_franzenfile->open(franzenfilename.c_str(), false)) //false => !createnew 
			{
				color_cyan();
				printbar('*');
				if (g_password)
					myprintf("43783: Appending on already encrypted-franzen <<%Z>>\n",franzenfilename.c_str());
				else
					myprintf("43787: Appending on franzen <<%Z>>\n",franzenfilename.c_str());
				printbar('*');
				color_restore();
			} 
			else 
			{
				myprintf("43791!	 cannot open franzen <<%Z>>\n",franzenfilename.c_str());
				g_p_franzenfile=0;
			}
		}
	}
#endif ///NOSFTPEND

  }
  // Create new file
	else 
	{
		if (flagdebug3)
			myprintf("00295: not isopen\n");
#ifdef BSD
		if (flagappend)
		{
			if (flagdebug2)
				myprintf("00296: try BSD flagappend\n");
			fp=myfopen(thefilename.c_str(), AB);
		}
		else
		fp=myfopen(thefilename.c_str(), WB);
#else
		fp=myfopen(thefilename.c_str(), WB,DATE_1980);
#endif // corresponds to #ifdef (#ifdef BSD)
		if (!isopen()) 
			ioerr(thefilename.c_str());
		
		if (g_chunk_size>0)
		{
			///g_addedchunklist_fp.push_back(fp);
			g_addedchunklist.push_back(thefilename);
		}		

#ifdef ZPAQFULL ///NOSFTPSTART
		if (g_franzen!="")
		{
			if (g_p_franzenfile)
			{
				myprintf("442581 franzenfile already setted!\n");
			}
			else
			{
				string franzenfilename=thefilename+".franzen";
				g_p_franzenfile = new franzcri(g_franzen.c_str(),g_franzen.length());
				if (g_p_franzenfile->open(franzenfilename.c_str(), true)) 
				{
					color_cyan();
					printbar('*');
					if (g_password)
						myprintf("43783: Creating from already encrypted-franzen <<%Z>>\n",franzenfilename.c_str());
					else
						myprintf("43787: Creating franzen <<%Z>>\n",franzenfilename.c_str());
					printbar('*');
					color_restore();
					///g_p_franzenfile->close();
					///seppuku();
				} 
				else 
				{
					myprintf("43791!	 cannot create franzen <<%Z>>\n",franzenfilename.c_str());
					g_p_franzenfile=0;
				}
			}
		}
#endif ///NOSFTPEND

	
		if (password) 
		{
			if (!salt_)
			{
				error("38722: salt not specified");
				seppuku();
				exit(0);
			}
			memcpy(salt, salt_, 32);
			if (off==0 && myfwrite(salt, 1, 32, fp)!=32)
				ioerr(thefilename.c_str());
			if (flagdebug3)
				myprintf("00297: written SALT (32bytes) on %s\n",thefilename.c_str());
#ifndef _WIN32
			fflush(fp); /// unix fix
#endif // corresponds to #ifndef (#ifndef _WIN32)
		}
		
	}
	if (flagdebug)
		myprintf("00299: opened 1 thefilename %s\n",thefilename.c_str());
	firstfp=FPNULL;
	chunksize=0;
	
	if (g_chunk_size>0)
	{
		firstfp=fp;
		g_archivefp_first=firstfp;
#ifndef ESX
		if (flagdebug3)
			myprintf("00300: ))))))))))))))))))))  Take note: firstfp is %s\n",migliaia(int64_t(firstfp)));
#endif
	}
		
	if (thefilename!=g_indexname)
	{
		g_fp_zpaq	=fp;
		flagindex=false;
#ifndef ESX
		if (flagdebug3)
			myprintf("00301: ;;;;;;;;;;;;;;;;;;;;;;;;;; settato index %s %08d;;;;;;;;;;;;;\n",migliaia(int64_t(g_fp_zpaq)),int64_t(g_fp_zpaq));
#endif
	}

  if (flagindex)
  {
#ifndef ESX
	  if (flagdebug)
		myprintf("00302: OutputArchive ISINDEX %s %s\n",thefilename.c_str(),migliaia(int64_t(fp)));
#endif
  }
  else
  {
#ifndef ESX
	  if (flagdebug)
		myprintf("00303: OutputArchive ZPAQ    %s %s\n",thefilename.c_str(),migliaia(int64_t(fp)));
#endif
  }

  // Set up encryption
  if (password) {
    char key[32];
    libzpaq::stretchKey(key, password, salt);
    aes=new libzpaq::AES_CTR(key, 32, salt);
	g_allocatedram+=sizeof(libzpaq::AES_CTR);
		
  }


}








#ifdef unix
std::string exec(const char* cmd)
{
#ifdef ANCIENT
	(void)cmd;
	return "";
#else
///	"unfolded" for compiler "quiteness"
    char buffer[128];
	std::string result;
	FILE* pipe = popen(cmd,"r");
	if (!pipe) 
	{
		myprintf("00322! popen kaputt\n");
		return "";
    }
	while (fgets(buffer,sizeof(buffer),pipe)!=NULL) 
		result+=buffer;
    if (pclose(pipe)==-1) 
	{
		myprintf("00323! pclose failed\n");
        return "";
    }
    return result;
#endif // corresponds to #ifdef (#ifdef ANCIENT)
}
#else
// a debug function
string exec(const char* cmd)
{
	myprintf("00324: Debug function (Windows does not have ZFS!)\n");
	if (cmd==NULL) // compiler be quiet
		return "NULL";
	return "";
}
#endif // corresponds to #ifdef (#ifdef unix)
#ifdef _WIN32
string tail(string const& i_source, size_t const i_length)
{
	if (i_length>=i_source.size())
		return i_source;
	return i_source.substr(i_source.size()-i_length);
}
#endif // corresponds to #ifdef (#ifdef _WIN32)

string x_one_vector(string i_command,string i_text,vector<string>& o_line)
{
	o_line.clear();
	if (i_command=="")
		return "";

	string 	risultato=exec(i_command.c_str());
	if (i_text!="")
		if (flagverbose)
			myprintf("00325: running        %s\n",i_text.c_str());
	if (risultato=="")
	{
		if (flagverbose)
		myprintf("00326: x_one          %s\n",i_command.c_str());
		return "";
	}
	if (flagdebug2)
		myprintf("00327: x_one          %s => %s\n",i_command.c_str(),risultato.c_str());

	unsigned int i=0;
	string lineetta="";

	while (i<risultato.size())
	{
		if ((risultato[i]==10) || (risultato[i]==13))
		{
			myreplaceall(lineetta,std::string(1,10),"");
			myreplaceall(lineetta,std::string(1,13),"");

			o_line.push_back(lineetta);
			if (flagdebug2)
				myprintf("00328: Pushato |%s|\n",lineetta.c_str());
			lineetta="";
		}
		else
		{
			lineetta+=risultato[i];
		}
		i++;
	}

	return risultato;
}

#ifdef ZPAQFULL ///NOSFTPSTART
string x_one(string i_command,string i_text)
{
	if (i_command=="")
		return "";

	string 	risultato=exec(i_command.c_str());
	if (i_text!="")
		if (flagverbose)
			myprintf("00329: running        %s\n",i_text.c_str());
	if (risultato=="")
	{
		if (flagverbose)
		myprintf("00330: x_one          %s\n",i_command.c_str());
	}
	else
	{
		if (flagdebug2)
			myprintf("00331: x_one          %s => %s\n",i_command.c_str(),risultato.c_str());
	}
	return risultato;
}
#endif ///NOSFTPEND

#ifdef ZPAQFULL ///NOSFTPSTART
int Jidac::zfsreceive()
{
	myprintf("00332: zfsreceive\n",archive.c_str());
	if (files.size()!=1)
	{
		myprintf("00333: zfsreceive examples (count %d)\n",files.size());
		myprintf("00334: [1]: zfsreceive /pippo.zpaq rpool/restored -script thescript.sh\n");
		myprintf("00335: [1]: zfsreceive /pippo.zpaq rpool/restored -script thescript.sh -snapshot mymark\n");
		return 2;
	}

	if (g_script=="")
	{
		myprintf("00336! you must specify an -script thescript.sh\n");
		return 2;
	}
	string	myoutput=g_script;

	string 	themark		="franco";
	if (snapmark!="")
		themark=snapmark;

	string estensione=prendiestensione(archive);
	if (estensione!="zpaq")
	{
		myprintf("00337! please use .zpaq extension on archive name <<%Z>>\n",archive.c_str());
		return 1;
	}

	string 	thepool		=files[0];
	/// test pool for /
	int				howmanyslash=0;
	int				howmanyat	=0;
	for (unsigned int i=0;i<thepool.size();i++)
	{
		if (thepool[i]=='/')
			howmanyslash++;
		if (thepool[i]=='@')
			howmanyat++;
	}
	myprintf("00339: Pool   %s\n",thepool.c_str());
	myprintf("00340: Mark   %s\n",themark.c_str());
	if (howmanyslash!=1)
	{
		myprintf("00341! a dataset |%s| must have exactly 1 '/' instead of %d\n",thepool.c_str(),howmanyslash);
		return 2;
	}
	if (howmanyat>0)
	{
		myprintf("00342! a dataset |%s| cannot have @\n",thepool.c_str());
		return 2;
	}


	int errors=0;
	command='l';
	g_optional="versum"; //force isselected
	flagstdout=true;

	read_archive(NULL,archive.c_str(),&errors,1); /// AND NOW THE MAGIC ONE!
	vector<string> filename;
	vector<int64_t> filesize;

	for (DTMap::iterator a=dt.begin(); a!=dt.end(); ++a)
	{
		string temp=a->first.c_str();
		string estensione=prendiestensione(temp);
		if (estensione=="zfs")
		{
			if (a->second.isordered)
			{
				filesize.push_back(a->second.size);
				filename.push_back(a->first.c_str());
			}
			else
			{
				myprintf("00343! GURU file is not ordered <<%s>> \n",a->first.c_str());
				return 2;
			}
		}
	}
	char nomeatteso[20];

	for (unsigned int i=0;i<filename.size();i++)
	{
		snprintf(nomeatteso,sizeof(nomeatteso),"%08d.zfs",(int)(i+1));
		string	snomeatteso=nomeatteso;
		if (snomeatteso!=filename[i])
		{
			myprintf("00344! Expected name @ index %d |%s| found |%s| => abort\n",(int)i,snomeatteso.c_str(),filename[i].c_str());
			return 2;
		}
	}
	FILE* batch=fopen(myoutput.c_str(), "w");
	if (batch==NULL)
	{
		myprintf("00345! cannot write on script %s\n",myoutput.c_str());
		return 2;
	}
	string pv=find_unix_command("pv");
	if (pv!="")
		pv+="|";
	if (pv!="")
		myprintf("00346: Activating pv on <<%s>>\n",pv.c_str());
	
	for (unsigned int i=0;i<filename.size();i++)
	{
		if (flagverbose)
			printf("%s x %s %s -stdout |%s zfs receive %s@%s%08d\n",fullzpaqexename.c_str(),archive.c_str(),filename[i].c_str(),pv.c_str(),thepool.c_str(),themark.c_str(),(int)(i+1));
		fprintf(batch,"echo Part %8s of %8s : zfs receive %s of %s bytes\n",migliaia(i+1),migliaia2(filename.size()),filename[i].c_str(),migliaia3(filesize[i]));
		fprintf(batch,"%s x %s %s -stdout |%s zfs receive %s@%s%08d\n",fullzpaqexename.c_str(),archive.c_str(),filename[i].c_str(),pv.c_str(),thepool.c_str(),themark.c_str(),(int)(i+1));
	}
	fclose(batch);
	batch=NULL;
#ifndef _WIN32

		if (chmod(myoutput.c_str(),0700)!=0)
		{
			myprintf("00347! Error on chmod 700 on %s\n",myoutput.c_str());
			return 2;
		}
#endif // corresponds to #ifndef (#ifndef _WIN32)
	myprintf("00348: The script is <<%Z>>\n",myoutput.c_str());
	return 0;
}
int Jidac::zfsrestore()
{
	myprintf("00350: zfsrestore\n");
	if (files.size()!=2)
	{
		myprintf("00351: zfsrestore examples (count %d)\n",files.size());
		myprintf("00352: [1]: zfsrestore /restoredzfsfolder rpool/restored -script thescript.sh\n");
		myprintf("00353: [2]: zfsrestore /restoredzfsfonder rpool/restored -script thescript.sh -snapshot mymark\n");
		return 2;
	}
	if (g_script=="")
	{
		myprintf("00354! you must specify an -script thescript.sh\n");
		return 2;
	}

	string	myoutput=g_script;

	string 	themark		="franco";
	if (snapmark!="")
		themark=snapmark;

	string	thefolder	=files[0];
	string 	thepool		=files[1];
	int		howmanyslash=0;
	int		howmanyat	=0;
	for (unsigned int i=0;i<thepool.size();i++)
	{
		if (thepool[i]=='/')
			howmanyslash++;
		if (thepool[i]=='@')
			howmanyat++;
	}
	myprintf("00355: Folder %s\n",thefolder.c_str());
	myprintf("00356: Pool   %s\n",thepool.c_str());
	myprintf("00357: Mark   %s\n",themark.c_str());
	if (howmanyslash!=1)
	{
		myprintf("00358! You MUST select a dataset |%s| must have exactly 1 '/' instead of %d\n",thepool.c_str(),howmanyslash);
		return 2;
	}
	if (howmanyat>0)
	{
		myprintf("00359! a pool |%s| cannot have @\n",thepool.c_str());
		return 2;
	}
	files.resize(1);
	flagforcezfs=true;
	DTMap myblock;
	g_arraybytescanned.push_back(0);
	g_arrayfilescanned.push_back(0);
	myprintf("00360: Searching files <<%s>>\n",files[0].c_str());
	edt.clear();
	scandir(false,edt,files[0].c_str(),false);
	vector<string> filename;
	for (DTMap::iterator a=edt.begin(); a!=edt.end(); ++a)
	{
		string temp=a->first.c_str();
		string estensione=prendiestensione(temp);
		if (estensione=="zfs")
			filename.push_back(a->first.c_str());
	}
	if (filename.size()==0)
	{
		myprintf("00361! no .zfs files founded in archive\n");
		return 2;
	}
	char nomeatteso[20];
	for (unsigned int i=0;i<filename.size();i++)
	{
		snprintf(nomeatteso,sizeof(nomeatteso),"%08d.zfs",(int)(i+1));
		string	snomeatteso=nomeatteso;
		if (snomeatteso!=extractfilename(filename[i]))
		{
			myprintf("00362! Expected name @ index %d |%s| found |%s| => abort\n",(int)i,snomeatteso.c_str(),filename[i].c_str());
			return 2;
		}
	}
	FILE* batch=fopen(myoutput.c_str(), "w");
	if (batch==NULL)
	{
		myprintf("00363! cannot write on script %s\n",myoutput.c_str());
		return 2;
	}
	string pv=find_unix_command("pv");
	if (pv!="")
		pv+="|";
	if (pv!="")
		myprintf("54690: Activating pv on <<%s>>\n",pv.c_str());
		
	for (unsigned int i=0;i<filename.size();i++)
	{
		if (flagverbose)
			printf("cat %s |%s zfs receive %s@%s%08d\n",filename[i].c_str(),pv.c_str(),thepool.c_str(),themark.c_str(),(int)(i+1));
		fprintf(batch,"echo Part %8s of %8s : cat | zfs receive %s\n",migliaia(i+1),migliaia(filename.size()),filename[i].c_str());
		fprintf(batch,"cat %s |%s zfs receive %s@%s%08d\n",filename[i].c_str(),pv.c_str(),thepool.c_str(),themark.c_str(),(int)(i+1));
	}
	fclose(batch);
#ifndef _WIN32

		if (chmod(myoutput.c_str(),0700)!=0)
		{
			myprintf("00364! Error on chmod 700 on %s\n",myoutput.c_str());
			return 2;
		}
#endif // corresponds to #ifndef (#ifndef _WIN32)
	myprintf("00365: The script is <<%Z>>\n",myoutput.c_str());
	return 0;
}
#endif ///NOSFTPEND

#ifdef ZPAQFULL ///NOSFTPSTART
int Jidac::makefullzfsbackup(const string& poolName, const string& archiveName, const string& snapshotMarker, const string& sanitizedPoolName,const string & i_parameters) 
{
    myprintf("00378: The archive does not exist, checking for snapshots\n");
    vector<string> array_primachiocciola;
    vector<string> array_dopochiocciola;
    vector<string> array_size;

    // Check if snapshots exist
    (void)zfs_get_snaplist(poolName, snapshotMarker, array_primachiocciola, array_dopochiocciola, array_size);
    if (!array_primachiocciola.empty()) 
	{
        myprintf("00379! Archive does not exist, but we got %d snapshots => abort\n", array_primachiocciola.size());
        return 2;
    }

    // Create the snapshot name
    char buffer[1000];
    snprintf(buffer, sizeof(buffer), "%s%08d", snapshotMarker.c_str(), 1);
    string snapshotName = buffer;
    string fullSnapshotName = poolName + "@" + snapshotName;

    myprintf("00380: The snap |%s|\n", snapshotName.c_str());
    myprintf("00381: Fullsnap |%s|\n", fullSnapshotName.c_str());
    myprintf("00382: Exename  |%s|\n", zpaqfranzexename.c_str());
    myprintf("00383: Now preparing a brand-new archive and snapshot (starting from 00000001)\n");

    // Create the temporary script
    string scriptPath = "/tmp/newbackup_zfs_" + sanitizedPoolName + ".sh";
    scriptPath = nomefileseesistegia(scriptPath);
    myprintf("00384: CREATING script %s\n", scriptPath.c_str());

    FILE* batch = fopen(scriptPath.c_str(), "w");
    if (batch == nullptr) {
        myprintf("00385! cannot write on script %s\n", scriptPath.c_str());
        return 2;
    }

    // Writing commands into the script
    fprintf(batch, "zfs snapshot %s\n", fullSnapshotName.c_str());

    string hashFilePath;
    if (flaghashdeep) {
        string hashdeepCommand = find_unix_command("hashdeep");
        if (!hashdeepCommand.empty()) {
            hashdeepCommand += "|";
        }
        myprintf("00386: hashdeep <<%s>>\n", hashdeepCommand.c_str());
        if (hashdeepCommand.empty()) {
            myprintf("00387! Cannot locate hashdeep, abort!\n");
            fclose(batch);
            return 2;
        }

        string zfsFolder = "/" + poolName + "/.zfs/snapshot/" + snapshotName + "/";
        myprintf("00388: zfsfolder      <<%s>>\n", zfsFolder.c_str());
        hashFilePath = "/tmp/hasho_" + sanitizedPoolName + "_" + snapshotName + ".txt";
        hashFilePath = nomefileseesistegia(hashFilePath);
        myprintf("00389: Hash-o-file    <<%s>>\n", hashFilePath.c_str());

        fprintf(batch, "/sbin/zfs set snapdir=hidden %s\n", poolName.c_str());
        fprintf(batch, "%s -c md5 -r %s >%s\n", hashdeepCommand.c_str(), zfsFolder.c_str(), hashFilePath.c_str());
    }

    // Add pv if available
    string pv = find_unix_command("pv");
    if (!pv.empty()) {
        pv += "|";
        myprintf("54862: Activating pv on <<%s>>\n", pv.c_str());
    }

    // Write zfs send command
    fprintf(batch, "zfs send %s@%s00000001 |%s%s a %s 00000001.zfs -stdin %s\n",
            poolName.c_str(), snapshotMarker.c_str(), pv.c_str(), fullzpaqexename.c_str(), archiveName.c_str(),i_parameters.c_str());

    if (flaghashdeep) {
        fprintf(batch, "%s a %s %s\n", fullzpaqexename.c_str(), archiveName.c_str(), hashFilePath.c_str());
    }

    fclose(batch);

#ifndef _WIN32
    // Set permissions and run the script
    if (chmod(scriptPath.c_str(), 0700) != 0) {
        myprintf("00390! error on chmod 700 on <<%s>>\n", scriptPath.c_str());
        return 2;
    }

    myprintf("00391: RUNNING  script %s\n", scriptPath.c_str());
    string runResult = exec(scriptPath.c_str());

    if (mypos("(all OK)", runResult) != 0) {
        myprintf("00392: The run seems OK, filesize %s\n", migliaia(prendidimensionefile(archiveName.c_str())));
        if (flagkill) {
            myprintf("00393: Deleting <<%s>>\n", scriptPath.c_str());
            delete_file(scriptPath.c_str());
            if (!hashFilePath.empty()) {
                myprintf("00394: Deleting hasho <<%s>>\n", hashFilePath.c_str());
                delete_file(hashFilePath.c_str());
            }
        }
        return 0;
    } else {
        myprintf("00395! GURU, something seems wrong, filesize %s\n", migliaia(prendidimensionefile(archiveName.c_str())));
        return 2;
    }
#endif

    return 0;
}

int Jidac::updatezfsbackup(const string& poolName, const string& archiveName, const string& snapshotMarker, const string& sanitizedPoolName,const string & i_parameters) 
{
    myprintf("00396: The archive exist, checking latest snapshot\n");
    int errors = 0;
    command = 'l';
    g_optional = "versum"; // force isselected
#ifndef _WIN32
    int64_t oldsize = prendidimensionefile(archiveName.c_str());
#endif
    // Read the archive
    read_archive(NULL, archiveName.c_str(), &errors, 1);
    vector<string> filename;
    for (DTMap::iterator a = dt.begin(); a != dt.end(); ++a) 
	{
        string temp = a->first.c_str();
        string estensione = prendiestensione(temp);
        if (estensione == "zfs") 
            filename.push_back(a->first.c_str());
    }

    // Check the filenames in the archive
    char nomeatteso[40];
    for (unsigned int i = 0; i < filename.size(); i++) 
	{
        snprintf(nomeatteso, sizeof(nomeatteso), "%08d.zfs", (int)(i + 1));
        string snomeatteso = nomeatteso;
        if (snomeatteso != filename[i]) 
		{
            myprintf("00397: Expected name @ index %d |%s| found |%s| => abort\n", (int)i, snomeatteso.c_str(), filename[i].c_str());
            return 2;
        }
    }

    // Determine the name of the expected snapshot
    string snomeatteso = myulltoa(filename.size(), 8);
    string expectedsnapshot = snapshotMarker + snomeatteso;
    string fullexpectedsnapshot = poolName + '@' + snapshotMarker + snomeatteso;
    myprintf("00398: Searching for snapshot |%s|\n", fullexpectedsnapshot.c_str());

    // Get the list of snapshots
    vector<string> array_primachiocciola;
    vector<string> array_dopochiocciola;
    vector<string> array_size;
    (void)zfs_get_snaplist(poolName, snapshotMarker, array_primachiocciola, array_dopochiocciola, array_size);

    if (array_primachiocciola.empty()) 
	{
        myprintf("00399! Cannot find the expected snapshot |%s|\n", fullexpectedsnapshot.c_str());
        return 2;
    }

    // Search for the index of the expected snapshot
    int foundindex = -1;
    for (unsigned int i = 0; i < array_primachiocciola.size(); i++) 
	{
        if (flagverbose) 
		    myprintf("00400: Array %08d => %s\n", (int)i, array_dopochiocciola[i].c_str());
        if (expectedsnapshot == array_dopochiocciola[i]) 
		{
            myprintf("00401: The expected snapshot exists (this is good) index %d |%s|\n", (int)i, expectedsnapshot.c_str());
            foundindex = i;
            break;
        }
    }

    if (foundindex == -1 || ((foundindex + 1) != (int)array_primachiocciola.size())) 
	{
        myprintf("00402! The founded index %d is < snapshot size %d, cowardly abort (not the LAST snapshot)\n", foundindex, array_primachiocciola.size());
        return 2;
    }

    // Calculate the name of the new snapshot
    string ultimo = array_dopochiocciola[foundindex];
    string solocifre = "";
    for (unsigned int i = 0; i < ultimo.size(); i++) 
	    if (isdigit(ultimo[i])) 
		    solocifre += ultimo[i];
        
    int thelast = atoi(solocifre.c_str()) + 1;
    snprintf(nomeatteso, sizeof(nomeatteso), "%08d", thelast);
    string nuovonome = nomeatteso;
    string nuovonomefull = poolName + '@' + snapshotMarker + nuovonome;

    myprintf("00403: Newname      |%s|\n", nuovonome.c_str());
    myprintf("00404: Newname full |%s|\n", nuovonomefull.c_str());
    myprintf("00405: Exename      |%s|\n", zpaqfranzexename.c_str());

    // Create the temporary script
    string filebatch = "/tmp/backup_zfs_" + sanitizedPoolName + ".sh";
    filebatch = nomefileseesistegia(filebatch);
    myprintf("00406: EXECUTING script %s\n", filebatch.c_str());

    FILE* batch = fopen(filebatch.c_str(), "w");
    if (batch == NULL) 
	{
        myprintf("00407! cannot write on filebatch %s\n", filebatch.c_str());
        return 2;
    }

    // Writing commands into the script
    fprintf(batch, "zfs snapshot %s\n", nuovonomefull.c_str());

    string hashofile;
    if (flaghashdeep) 
	{
        string hashdeepposition = find_unix_command("hashdeep");
        if (!hashdeepposition.empty())
            hashdeepposition += "|";
        myprintf("54970: hashdeep <<%s>>\n", hashdeepposition.c_str());
        if (hashdeepposition.empty()) 
		{
            myprintf("00409! cannot locate hashdeep, abort!\n");
            fclose(batch);
            return 2;
        }

        string thesnap = snapshotMarker + nuovonome;
        string zfsfolder = "/" + poolName + "/.zfs/snapshot/" + thesnap + "/";
        myprintf("00410: Zfsfolder    <<%s>>\n", zfsfolder.c_str());
        hashofile = "/tmp/hasho_" + sanitizedPoolName + "_" + thesnap + ".txt";
        hashofile = nomefileseesistegia(hashofile);
        myprintf("00411: Hashofile    <<%s>>\n", hashofile.c_str());

        fprintf(batch, "/sbin/zfs set snapdir=hidden %s\n", poolName.c_str());
        fprintf(batch, "%s -c md5 -r %s >%s\n",
                hashdeepposition.c_str(), zfsfolder.c_str(), hashofile.c_str());
    }

    // Write zfs send command incrementale
	
    fprintf(batch, "zfs send -i %s %s |%s a %s %s.zfs -stdin %s\n",
            fullexpectedsnapshot.c_str(), nuovonomefull.c_str(),
            fullzpaqexename.c_str(), archiveName.c_str(), nuovonome.c_str(),i_parameters.c_str());

    if (flaghashdeep) 
	    fprintf(batch, "%s a %s %s\n",
                fullzpaqexename.c_str(), archiveName.c_str(), hashofile.c_str());
    
    if (flagkill) 
	    fprintf(batch, "zfs destroy %s\n", fullexpectedsnapshot.c_str());
    
    fclose(batch);

#ifndef _WIN32
    // Set permissions and run the script
    if (chmod(filebatch.c_str(), 0700) != 0) 
	{
        myprintf("00412! Error on chmod 700 on %s\n", filebatch.c_str());
        return 2;
    }

    myprintf("00413: RUNNING   script %s\n", filebatch.c_str());
    string runresult = exec(filebatch.c_str());

    if (mypos("(all OK)", runresult) != 0) 
	{
        int64_t newsize = prendidimensionefile(archiveName.c_str());
        myprintf("00414: Seems OK, filesize %s => %s (%s)\n",
                 migliaia(oldsize), migliaia2(newsize), migliaia3(myabs(newsize, oldsize)));
        if (flagkill) 
		{
            myprintf("00415: Deleting <<%s>>\n", filebatch.c_str());
            delete_file(filebatch.c_str());
            if (!hashofile.empty()) 
			{
                myprintf("00416: Deleting hasho <<%s>>\n", hashofile.c_str());
                delete_file(hashofile.c_str());
            }
        }
        return 0;
    } 
	else 
	{
        myprintf("00416! GURU, something seems wrong, filesize %s\n",migliaia(prendidimensionefile(archiveName.c_str())));
        return 2;
    }
#endif
    return 0;
}
int Jidac::zfsbackup() 
{
    // Initial validation
    if (!g_ifexist.empty()) 
        if (!direxists(g_ifexist)) 
		{
            myprintf("54729! Abort because -ifexist <<%Z>>\n", g_ifexist.c_str());
            return 2;
        }

    string estensione = prendiestensione(archive);
    if (estensione != "zpaq") 
	{
        myprintf("00367! please use .zpaq extension on archive name <<%Z>>\n", archive.c_str());
        return 1;
    }

    if (files.size() != 1) 
	{
        myprintf("00369! please use 1 single pool/dataset\n");
        return 1;
    }

    string poolName = files[0];
    if (isdirectory(poolName)) 
	{
        myprintf("00370! A pool-dataset |%s| cannot end with a / \n", poolName.c_str());
        myprintf("00371: Good examples     tank     tank/d\n");
        return 2;
    }

    string snapshotMarker = snapmark.empty() ? "zpaqfranz" : snapmark;

    // poolName validation
    int howmanyslash = 0, howmanyat = 0;
	for (unsigned int i = 0; i < poolName.size(); i++) 
	{
        if (poolName[i] == '/') 
			howmanyslash++;
        if (poolName[i] == '@') 
			howmanyat++;
    }

    string sanitizedPoolName = poolName;
    std::replace(sanitizedPoolName.begin(), sanitizedPoolName.end(), '/', '_');

    myprintf("00372: Archive        %s\n", archive.c_str());
    myprintf("00373: Pool           %s\n", poolName.c_str());
    myprintf("00374: Purged pool    %s\n", sanitizedPoolName.c_str());
    myprintf("00375: Mark           %s\n", snapshotMarker.c_str());

    if (howmanyslash > 1) 
	{
        myprintf("00376! A pool-dataset |%s| must have exactly 0 or 1 / instead of %d\n", poolName.c_str(), howmanyslash);
        return 2;
    }
    if (howmanyat > 0) 
	{
        myprintf("00377! A pool-dataset |%s| cannot have @\n", poolName.c_str());
        return 2;
    }

	string parametrini;
	parametrini+=" -m"+method;

	if (plainpassword!="")
		parametrini+=" -key "+plainpassword;

	if (flagverbose)
		myprintf("55081: Parameters |%s|\n",parametrini.c_str());

    // Creation or update
    if (fileexists(archive))
        return updatezfsbackup(poolName, archive, snapshotMarker, sanitizedPoolName,parametrini);
    else
		return makefullzfsbackup(poolName, archive, snapshotMarker, sanitizedPoolName,parametrini);
}
#endif ///NOSFTPEND
///	detecting case collision: xxhash64 is more than enough (fast and compact)
uint64_t Jidac::hashastringa(const string& i_string)
{
	uint64_t myseed = 0;
	XXHash64 myhash(myseed);
	myhash.add(i_string.c_str(),i_string.size());
	return myhash.hash();
}
/// change the key of a map is not so easy (slow)
/// this is something like filesystem behavior: just add and mark as deleted
/// note: this is find, not binary search. quite slow, but resilient
void Jidac::changedtmapkey(string i_oldkey,string i_newkey)
{
	DTMap::iterator myp=dt.find(i_oldkey);
	if (myp==dt.end())
		return;
	DT olddt=myp->second;
	dt[i_newkey]=olddt;
	myp->second.date=0;		///fake delete
}
uint32_t Jidac::casekollision(DTMap& i_dtmap,vector<string>& o_collisions,bool i_fix=false)
{
		int64_t	startkoll=mtime();
	if (flagverbose)
		myprintf("00417: Case-collision checks on %s files ",migliaia((int64_t)i_dtmap.size()));
	uint32_t fixed=0;
	o_collisions.clear();
	vector<uint64_t>	hashedstrings;
	for (DTMap::iterator p=i_dtmap.begin(); p!=i_dtmap.end(); ++p)
		if (all || p->second.date)
		{
			string		fn			=rename(p->first);
			string 		filename	=stringtolower(fn);
			uint64_t hashato=hashastringa(filename);
			if (binary_search(hashedstrings.begin(),hashedstrings.end(),hashato)==true)
			{
				if (i_fix)
				{
					char	buf[32];
					string 	percorso	=extractfilepath(fn);
					string	nomefile	=prendinomefileebasta(fn);
					string	estensione	=prendiestensione(fn);
					int		iterazione	=1;
					string	rifatto		="";
					do
					{
						snprintf(buf,sizeof(buf),"_%08d",iterazione++);
						if (percorso!="")
							rifatto=percorso;
						string pezzetto=buf;
						if (nomefile!="")
							rifatto+=nomefile+buf;
						if (estensione!="")
							rifatto+="."+estensione;
						hashato=hashastringa(rifatto);
						if (binary_search(hashedstrings.begin(),hashedstrings.end(),hashato)==false)
							break;
					}
					while (iterazione<1000);
					if (iterazione<1000)
					{
						changedtmapkey(p->first,rifatto);
						fixed++;
					}
					else
					{
						myprintf("00418! ERROR IMPOSSIBLE TO 'DECASE' %Z\n",filename.c_str());
					}
				}
				else
					o_collisions.push_back(fn);
			}
			else
			{
#ifndef ANCIENT
///macos

			std::vector<uint64_t>::iterator it;
			it = std::upper_bound(hashedstrings.begin(),hashedstrings.end(),hashato);
			hashedstrings.insert(it,hashato);
/*
			auto it = std::upper_bound(hashedstrings.cbegin(),hashedstrings.cend(),hashato);
			hashedstrings.insert(it,hashato);
*/
#endif // corresponds to #ifndef (#ifndef ANCIENT)
			}
		}
	int64_t	endkoll=mtime();
	if (flagverbose)
		myprintf("00420: done in %.2fs\n",(endkoll-startkoll)*0.001);
	return (fixed);
}


void Jidac::jidacreset()
{
	g_freeze="";
	files_size.clear();
	files_count.clear();
	files_time.clear();
	files_edt.clear();
	ver.clear();
	block.clear();
	dt.clear();
	ht.clear();
	edt.clear();
	ht.resize(1);  // element 0 not used
	ver.resize(1); // version 0
	dhsize=dcsize=0;
	g_crc32.clear();
///	tofiles.clear();
///	files.clear();
}
int Jidac::paranoid()
////////////////////////////////////////////////////////////////////////////
///////// This is a merge of unzpaq206.cpp, patched by me to become unz.cpp
///////// Now support FRANZOFFSET
{
#ifdef _WIN32
#ifndef _WIN64
	myprintf("00423$ WARNING: paranoid test use a lot of RAM, not good for Win32, better Win64\n");
#endif // corresponds to #ifndef (#ifndef _WIN64)
#endif // corresponds to #ifdef (#ifdef _WIN32)
	unz(archive.c_str(), g_password);
	return 0;
}
// Callback for user defined ZPAQ error handling.
// It will be called on input error with an English language error message.
// This function should not return.
extern void unzerror(const char* msg);
// Virtual base classes for input and output
// get() and put() must be overridden to read or write 1 byte.
class unzReader {
public:
  virtual int get() = 0;  // should return 0..255, or -1 at EOF
  virtual ~unzReader() {}
};
class unzWriter {
public:
  virtual void put(int c) = 0;  // should output low 8 bits of c
  virtual ~unzWriter() {}
};
// An Array of T is cleared and aligned on a 64 byte address
//   with no constructors called. No copy or assignment.
// Array<T> a(n, ex=0);  - creates n<<ex elements of type T
// a[i] - index
// a(i) - index mod n, n must be a power of 2
// a.size() - gets n
template <typename T>
class Array {
  T *data;     // user location of [0] on a 64 byte boundary
  size_t n;    // user size
  int offset;  // distance back in bytes to start of actual allocation
  void operator=(const Array&);  // no assignment
  Array(const Array&);  // no copy
public:
  Array(size_t sz=0, int ex=0): data(0), n(0), offset(0) {
    resize(sz, ex);} // [0..sz-1] = 0
  void resize(size_t sz, int ex=0); // change size, erase content to zeros
  ~Array() {resize(0);}  // free memory
  size_t size() const {return n;}  // get size
  int isize() const {return int(n);}  // get size as an int
  T& operator[](size_t i) {assert(n>0 && i<n); return data[i];}
  T& operator()(size_t i) {assert(n>0 && (n&(n-1))==0); return data[i&(n-1)];}
};
// Change size to sz<<ex elements of 0
template<typename T>
void Array<T>::resize(size_t sz, int ex) {
  assert(size_t(-1)>0);  // unsigned type?
  while (ex>0) {
    if (sz>sz*2) unzerror("Array too big");
    sz*=2, --ex;
  }
  if (n>0) {
    assert(offset>=0 && offset<=64);
    assert((char*)data-offset);
    free((char*)data-offset);
  }
  n=0;
  if (sz==0) return;
  n=sz;
  const size_t nb=128+n*sizeof(T);  // test for overflow
  if (nb<=128 || (nb-128)/sizeof(T)!=n) unzerror("Array too big");
  data=(T*)calloc(nb, 1);
  g_allocatedram+=nb;
  
  if (!data) unzerror("out of memory");
  // Align array on a 64 byte address.
  // This optimization is NOT required by the ZPAQ standard.
  offset=64-(((char*)data-(char*)0)&63);
  assert(offset>0 && offset<=64);
  data=(T*)((char*)data+offset);
}
//////////////////////////// unzSHA1 ////////////////////////////
// For computing SHA-1 checksums
class unzSHA1 {
public:
  void put(int c) {  // hash 1 byte
    uint32_t& r=w[len0>>5&15];
    r=(r<<8)|(c&255);
    if (!(len0+=8)) ++len1;
    if ((len0&511)==0) process();
  }
  double size() const {return len0/8+len1*536870912.0;} // size in bytes
  const char* result();
  unzSHA1() {init();}
private:
  void init();
  uint32_t len0, len1;
  uint32_t h[5];
  uint32_t w[80];
  char hbuf[20];
  void process();
};
// Start a new hash
void unzSHA1::init() {
  len0=len1=0;
  h[0]=0x67452301;
  h[1]=0xEFCDAB89;
  h[2]=0x98BADCFE;
  h[3]=0x10325476;
  h[4]=0xC3D2E1F0;
}
// Return old result and start a new hash
const char* unzSHA1::result() {
  // pad and append length
  const uint32_t s1=len1, s0=len0;
  put(0x80);
  while ((len0&511)!=448)
    put(0);
  put(s1>>24);
  put(s1>>16);
  put(s1>>8);
  put(s1);
  put(s0>>24);
  put(s0>>16);
  put(s0>>8);
  put(s0);
  // copy h to hbuf
  for (int i=0; i<5; ++i) {
    hbuf[4*i]=h[i]>>24;
    hbuf[4*i+1]=h[i]>>16;
    hbuf[4*i+2]=h[i]>>8;
    hbuf[4*i+3]=h[i];
  }
  // return hash prior to clearing state
  init();
  return hbuf;
}
// Hash 1 block of 64 bytes
void unzSHA1::process() {
  for (int i=16; i<80; ++i) {
    w[i]=w[i-3]^w[i-8]^w[i-14]^w[i-16];
    w[i]=w[i]<<1|w[i]>>31;
  }
  uint32_t a=h[0];
  uint32_t b=h[1];
  uint32_t c=h[2];
  uint32_t d=h[3];
  uint32_t e=h[4];
  const uint32_t k1=0x5A827999, k2=0x6ED9EBA1, k3=0x8F1BBCDC, k4=0xCA62C1D6;
#define f1(a,b,c,d,e,i) e+=(a<<5|a>>27)+((b&c)|(~b&d))+k1+w[i]; b=b<<30|b>>2;
#define f5(i) f1(a,b,c,d,e,i) f1(e,a,b,c,d,i+1) f1(d,e,a,b,c,i+2) \
              f1(c,d,e,a,b,i+3) f1(b,c,d,e,a,i+4)
  f5(0) f5(5) f5(10) f5(15)
#undef f1
#define f1(a,b,c,d,e,i) e+=(a<<5|a>>27)+(b^c^d)+k2+w[i]; b=b<<30|b>>2;
  f5(20) f5(25) f5(30) f5(35)
#undef f1
#define f1(a,b,c,d,e,i) e+=(a<<5|a>>27)+((b&c)|(b&d)|(c&d))+k3+w[i]; \
        b=b<<30|b>>2;
  f5(40) f5(45) f5(50) f5(55)
#undef f1
#define f1(a,b,c,d,e,i) e+=(a<<5|a>>27)+(b^c^d)+k4+w[i]; b=b<<30|b>>2;
  f5(60) f5(65) f5(70) f5(75)
#undef f1
#undef f5
  h[0]+=a;
  h[1]+=b;
  h[2]+=c;
  h[3]+=d;
  h[4]+=e;
}
//////////////////////////// unzSHA256 //////////////////////////
// For computing SHA-256 checksums
// http://en.wikipedia.org/wiki/SHA-2
class unzSHA256 {
public:
  void put(int c) {  // hash 1 byte
    unsigned& r=w[len0>>5&15];
    r=(r<<8)|(c&255);
    if (!(len0+=8)) ++len1;
    if ((len0&511)==0) process();
  }
  double size() const {return len0/8+len1*536870912.0;} // size in bytes
  uint64_t usize() const {return len0/8+(uint64_t(len1)<<29);} //size in bytes
  const char* result();  // get hash and reset
  unzSHA256() {init();}
private:
  void init();
  unsigned len0, len1;
  unsigned s[8];
  unsigned w[16];
  char hbuf[32];
  void process();
};
void unzSHA256::init() {
  len0=len1=0;
  s[0]=0x6a09e667;
  s[1]=0xbb67ae85;
  s[2]=0x3c6ef372;
  s[3]=0xa54ff53a;
  s[4]=0x510e527f;
  s[5]=0x9b05688c;
  s[6]=0x1f83d9ab;
  s[7]=0x5be0cd19;
  memset(w, 0, sizeof(w));
}
void unzSHA256::process() {
  #define ror(a,b) ((a)>>(b)|(a<<(32-(b))))
  #define m(i) \
     w[(i)&15]+=w[(i-7)&15] \
       +(ror(w[(i-15)&15],7)^ror(w[(i-15)&15],18)^(w[(i-15)&15]>>3)) \
       +(ror(w[(i-2)&15],17)^ror(w[(i-2)&15],19)^(w[(i-2)&15]>>10))
  #define r(a,b,c,d,e,f,g,h,i) { \
    unsigned t1=ror(e,14)^e; \
    t1=ror(t1,5)^e; \
    h+=ror(t1,6)+((e&f)^(~e&g))+k[i]+w[(i)&15]; } \
    d+=h; \
    {unsigned t1=ror(a,9)^a; \
    t1=ror(t1,11)^a; \
    h+=ror(t1,2)+((a&b)^(c&(a^b))); }
  #define mr(a,b,c,d,e,f,g,h,i) m(i); r(a,b,c,d,e,f,g,h,i);
  #define r8(i) \
    r(a,b,c,d,e,f,g,h,i);   \
    r(h,a,b,c,d,e,f,g,i+1); \
    r(g,h,a,b,c,d,e,f,i+2); \
    r(f,g,h,a,b,c,d,e,i+3); \
    r(e,f,g,h,a,b,c,d,i+4); \
    r(d,e,f,g,h,a,b,c,i+5); \
    r(c,d,e,f,g,h,a,b,i+6); \
    r(b,c,d,e,f,g,h,a,i+7);
  #define mr8(i) \
    mr(a,b,c,d,e,f,g,h,i);   \
    mr(h,a,b,c,d,e,f,g,i+1); \
    mr(g,h,a,b,c,d,e,f,i+2); \
    mr(f,g,h,a,b,c,d,e,i+3); \
    mr(e,f,g,h,a,b,c,d,i+4); \
    mr(d,e,f,g,h,a,b,c,i+5); \
    mr(c,d,e,f,g,h,a,b,i+6); \
    mr(b,c,d,e,f,g,h,a,i+7);
  static const unsigned k[64]={
    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5,
    0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
    0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3,
    0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
    0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc,
    0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
    0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7,
    0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
    0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13,
    0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
    0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3,
    0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
    0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5,
    0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
    0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,
    0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2};
  unsigned a=s[0];
  unsigned b=s[1];
  unsigned c=s[2];
  unsigned d=s[3];
  unsigned e=s[4];
  unsigned f=s[5];
  unsigned g=s[6];
  unsigned h=s[7];
  r8(0);
  r8(8);
  mr8(16);
  mr8(24);
  mr8(32);
  mr8(40);
  mr8(48);
  mr8(56);
  s[0]+=a;
  s[1]+=b;
  s[2]+=c;
  s[3]+=d;
  s[4]+=e;
  s[5]+=f;
  s[6]+=g;
  s[7]+=h;
  #undef mr8
  #undef r8
  #undef mr
  #undef r
  #undef m
  #undef ror
}
// Return old result and start a new hash
const char* unzSHA256::result() {
  // pad and append length
  const unsigned s1=len1, s0=len0;
  put(0x80);
  while ((len0&511)!=448) put(0);
  put(s1>>24);
  put(s1>>16);
  put(s1>>8);
  put(s1);
  put(s0>>24);
  put(s0>>16);
  put(s0>>8);
  put(s0);
  // copy s to hbuf
  for (int i=0; i<8; ++i) {
    hbuf[4*i]=s[i]>>24;
    hbuf[4*i+1]=s[i]>>16;
    hbuf[4*i+2]=s[i]>>8;
    hbuf[4*i+3]=s[i];
  }
  // return hash prior to clearing state
  init();
  return hbuf;
}
//////////////////////////// AES /////////////////////////////
// For encrypting with AES in CTR mode.
// The i'th 16 byte block is encrypted by XOR with AES(i)
// (i is big endian or MSB first, starting with 0).
class unzAES_CTR {
  uint32_t Te0[256], Te1[256], Te2[256], Te3[256], Te4[256]; // encryption tables
  uint32_t ek[60];  // round key
  int Nr;  // number of rounds (10, 12, 14 for AES 128, 192, 256)
  uint32_t iv0, iv1;  // first 8 bytes in CTR mode
public:
  unzAES_CTR(const char* key, int keylen, const char* iv=0);
    // Schedule: keylen is 16, 24, or 32, iv is 8 bytes or NULL
  void encrypt(uint32_t s0, uint32_t s1, uint32_t s2, uint32_t s3, unsigned char* ct);
  void encrypt(char* unzBuf, int n, uint64_t offset);  // encrypt n bytes of unzBuf
};
// Some AES code is derived from libtomcrypt 1.17 (public domain).
#define Te4_0 0x000000FF & Te4
#define Te4_1 0x0000FF00 & Te4
#define Te4_2 0x00FF0000 & Te4
#define Te4_3 0xFF000000 & Te4
// Extract byte n of x
static inline unsigned unzbyte(unsigned x, unsigned n) {return (x>>(8*n))&255;}
// x = y[0..3] MSB first
static inline void LOAD32H(uint32_t& x, const char* y) {
  const unsigned char* u=(const unsigned char*)y;
  x=u[0]<<24|u[1]<<16|u[2]<<8|u[3];
}
// y[0..3] = x MSB first
static inline void STORE32H(uint32_t& x, unsigned char* y) {
  y[0]=x>>24;
  y[1]=x>>16;
  y[2]=x>>8;
  y[3]=x;
}
#define setup_mix(temp) \
  ((Te4_3[unzbyte(temp, 2)]) ^ (Te4_2[unzbyte(temp, 1)]) ^ \
   (Te4_1[unzbyte(temp, 0)]) ^ (Te4_0[unzbyte(temp, 3)]))
// Initialize encryption tables and round key. keylen is 16, 24, or 32.
unzAES_CTR::unzAES_CTR(const char* key, int keylen, const char* iv) {
  assert(key  != NULL);
  assert(keylen==16 || keylen==24 || keylen==32);
  // Initialize IV (default 0)
  iv0=iv1=0;
  if (iv) {
    LOAD32H(iv0, iv);
    LOAD32H(iv1, iv+4);
  }
  // Initialize encryption tables
  for (int i=0; i<256; ++i) {
    unsigned s1=
    "\x63\x7c\x77\x7b\xf2\x6b\x6f\xc5\x30\x01\x67\x2b\xfe\xd7\xab\x76"
    "\xca\x82\xc9\x7d\xfa\x59\x47\xf0\xad\xd4\xa2\xaf\x9c\xa4\x72\xc0"
    "\xb7\xfd\x93\x26\x36\x3f\xf7\xcc\x34\xa5\xe5\xf1\x71\xd8\x31\x15"
    "\x04\xc7\x23\xc3\x18\x96\x05\x9a\x07\x12\x80\xe2\xeb\x27\xb2\x75"
    "\x09\x83\x2c\x1a\x1b\x6e\x5a\xa0\x52\x3b\xd6\xb3\x29\xe3\x2f\x84"
    "\x53\xd1\x00\xed\x20\xfc\xb1\x5b\x6a\xcb\xbe\x39\x4a\x4c\x58\xcf"
    "\xd0\xef\xaa\xfb\x43\x4d\x33\x85\x45\xf9\x02\x7f\x50\x3c\x9f\xa8"
    "\x51\xa3\x40\x8f\x92\x9d\x38\xf5\xbc\xb6\xda\x21\x10\xff\xf3\xd2"
    "\xcd\x0c\x13\xec\x5f\x97\x44\x17\xc4\xa7\x7e\x3d\x64\x5d\x19\x73"
    "\x60\x81\x4f\xdc\x22\x2a\x90\x88\x46\xee\xb8\x14\xde\x5e\x0b\xdb"
    "\xe0\x32\x3a\x0a\x49\x06\x24\x5c\xc2\xd3\xac\x62\x91\x95\xe4\x79"
    "\xe7\xc8\x37\x6d\x8d\xd5\x4e\xa9\x6c\x56\xf4\xea\x65\x7a\xae\x08"
    "\xba\x78\x25\x2e\x1c\xa6\xb4\xc6\xe8\xdd\x74\x1f\x4b\xbd\x8b\x8a"
    "\x70\x3e\xb5\x66\x48\x03\xf6\x0e\x61\x35\x57\xb9\x86\xc1\x1d\x9e"
    "\xe1\xf8\x98\x11\x69\xd9\x8e\x94\x9b\x1e\x87\xe9\xce\x55\x28\xdf"
    "\x8c\xa1\x89\x0d\xbf\xe6\x42\x68\x41\x99\x2d\x0f\xb0\x54\xbb\x16"
    [i]&255;
    unsigned s2=s1<<1;
    if (s2>=0x100) s2^=0x11b;
    unsigned s3=s1^s2;
    Te0[i]=s2<<24|s1<<16|s1<<8|s3;
    Te1[i]=s3<<24|s2<<16|s1<<8|s1;
    Te2[i]=s1<<24|s3<<16|s2<<8|s1;
    Te3[i]=s1<<24|s1<<16|s3<<8|s2;
    Te4[i]=s1<<24|s1<<16|s1<<8|s1;
  }
  // setup the forward key
  Nr = 10 + ((keylen/8)-2)*2;  // 10, 12, or 14 rounds
  int i = 0;
  uint32_t* rk = &ek[0];
  uint32_t temp;
  static const uint32_t rcon[10] = {
    0x01000000UL, 0x02000000UL, 0x04000000UL, 0x08000000UL,
    0x10000000UL, 0x20000000UL, 0x40000000UL, 0x80000000UL,
    0x1B000000UL, 0x36000000UL};  // round constants
  LOAD32H(rk[0], key   );
  LOAD32H(rk[1], key +  4);
  LOAD32H(rk[2], key +  8);
  LOAD32H(rk[3], key + 12);
  if (keylen == 16) {
    for (;;) {
      temp  = rk[3];
      rk[4] = rk[0] ^ setup_mix(temp) ^ rcon[i];
      rk[5] = rk[1] ^ rk[4];
      rk[6] = rk[2] ^ rk[5];
      rk[7] = rk[3] ^ rk[6];
      if (++i == 10) {
         break;
      }
      rk += 4;
    }
  }
  else if (keylen == 24) {
    LOAD32H(rk[4], key + 16);
    LOAD32H(rk[5], key + 20);
    for (;;) {
      temp = rk[5];
      rk[ 6] = rk[ 0] ^ setup_mix(temp) ^ rcon[i];
      rk[ 7] = rk[ 1] ^ rk[ 6];
      rk[ 8] = rk[ 2] ^ rk[ 7];
      rk[ 9] = rk[ 3] ^ rk[ 8];
      if (++i == 8) {
        break;
      }
      rk[10] = rk[ 4] ^ rk[ 9];
      rk[11] = rk[ 5] ^ rk[10];
      rk += 6;
    }
  }
  else if (keylen == 32) {
    LOAD32H(rk[4], key + 16);
    LOAD32H(rk[5], key + 20);
    LOAD32H(rk[6], key + 24);
    LOAD32H(rk[7], key + 28);
    for (;;) {
      temp = rk[7];
      rk[ 8] = rk[ 0] ^ setup_mix(temp) ^ rcon[i];
      rk[ 9] = rk[ 1] ^ rk[ 8];
      rk[10] = rk[ 2] ^ rk[ 9];
      rk[11] = rk[ 3] ^ rk[10];
      if (++i == 7) {
        break;
      }
      temp = rk[11];
      rk[12] = rk[ 4] ^ setup_mix(temp<<24|temp>>8);
      rk[13] = rk[ 5] ^ rk[12];
      rk[14] = rk[ 6] ^ rk[13];
      rk[15] = rk[ 7] ^ rk[14];
      rk += 8;
    }
  }
}
// Encrypt to ct[16]
void unzAES_CTR::encrypt(uint32_t s0, uint32_t s1, uint32_t s2, uint32_t s3, unsigned char* ct) {
  int r = Nr >> 1;
  uint32_t *rk = &ek[0];
  uint32_t t0=0, t1=0, t2=0, t3=0;
  s0 ^= rk[0];
  s1 ^= rk[1];
  s2 ^= rk[2];
  s3 ^= rk[3];
  for (;;) {
    t0 =
      Te0[unzbyte(s0, 3)] ^
      Te1[unzbyte(s1, 2)] ^
      Te2[unzbyte(s2, 1)] ^
      Te3[unzbyte(s3, 0)] ^
      rk[4];
    t1 =
      Te0[unzbyte(s1, 3)] ^
      Te1[unzbyte(s2, 2)] ^
      Te2[unzbyte(s3, 1)] ^
      Te3[unzbyte(s0, 0)] ^
      rk[5];
    t2 =
      Te0[unzbyte(s2, 3)] ^
      Te1[unzbyte(s3, 2)] ^
      Te2[unzbyte(s0, 1)] ^
      Te3[unzbyte(s1, 0)] ^
      rk[6];
    t3 =
      Te0[unzbyte(s3, 3)] ^
      Te1[unzbyte(s0, 2)] ^
      Te2[unzbyte(s1, 1)] ^
      Te3[unzbyte(s2, 0)] ^
      rk[7];
    rk += 8;
    if (--r == 0) {
      break;
    }
    s0 =
      Te0[unzbyte(t0, 3)] ^
      Te1[unzbyte(t1, 2)] ^
      Te2[unzbyte(t2, 1)] ^
      Te3[unzbyte(t3, 0)] ^
      rk[0];
    s1 =
      Te0[unzbyte(t1, 3)] ^
      Te1[unzbyte(t2, 2)] ^
      Te2[unzbyte(t3, 1)] ^
      Te3[unzbyte(t0, 0)] ^
      rk[1];
    s2 =
      Te0[unzbyte(t2, 3)] ^
      Te1[unzbyte(t3, 2)] ^
      Te2[unzbyte(t0, 1)] ^
      Te3[unzbyte(t1, 0)] ^
      rk[2];
    s3 =
      Te0[unzbyte(t3, 3)] ^
      Te1[unzbyte(t0, 2)] ^
      Te2[unzbyte(t1, 1)] ^
      Te3[unzbyte(t2, 0)] ^
      rk[3];
  }
  // apply last round and map cipher state to byte array block:
  s0 =
    (Te4_3[unzbyte(t0, 3)]) ^
    (Te4_2[unzbyte(t1, 2)]) ^
    (Te4_1[unzbyte(t2, 1)]) ^
    (Te4_0[unzbyte(t3, 0)]) ^
    rk[0];
  STORE32H(s0, ct);
  s1 =
    (Te4_3[unzbyte(t1, 3)]) ^
    (Te4_2[unzbyte(t2, 2)]) ^
    (Te4_1[unzbyte(t3, 1)]) ^
    (Te4_0[unzbyte(t0, 0)]) ^
    rk[1];
  STORE32H(s1, ct+4);
  s2 =
    (Te4_3[unzbyte(t2, 3)]) ^
    (Te4_2[unzbyte(t3, 2)]) ^
    (Te4_1[unzbyte(t0, 1)]) ^
    (Te4_0[unzbyte(t1, 0)]) ^
    rk[2];
  STORE32H(s2, ct+8);
  s3 =
    (Te4_3[unzbyte(t3, 3)]) ^
    (Te4_2[unzbyte(t0, 2)]) ^
    (Te4_1[unzbyte(t1, 1)]) ^
    (Te4_0[unzbyte(t2, 0)]) ^
    rk[3];
  STORE32H(s3, ct+12);
}
// Encrypt or decrypt slice unzBuf[0..n-1] at offset by XOR with AES(i) where
// i is the 128 bit big-endian distance from the start in 16 byte blocks.
void unzAES_CTR::encrypt(char* unzBuf, int n, uint64_t offset) {
  for (uint64_t i=offset/16; i<=(offset+n)/16; ++i) {
    unsigned char ct[16];
    encrypt(iv0, iv1, i>>32, i, ct);
    for (int j=0; j<16; ++j) {
      const int k=i*16-offset+j;
      if (k>=0 && k<n)
        unzBuf[k]^=ct[j];
    }
  }
}
#undef setup_mix
#undef Te4_3
#undef Te4_2
#undef Te4_1
#undef Te4_0
//////////////////////////// stretchKey //////////////////////
// PBKDF2(pw[0..pwlen], salt[0..saltlen], c) to unzBuf[0..dkLen-1]
// using HMAC-unzSHA256, for the special case of c = 1 iterations
// output size dkLen a multiple of 32, and pwLen <= 64.
static void unzpbkdf2(const char* pw, int pwLen, const char* salt, int saltLen,
                    char* unzBuf, int dkLen) {
  assert(dkLen%32==0);
  assert(pwLen<=64);
  unzSHA256 sha256;
  char b[32];
  for (int i=1; i*32<=dkLen; ++i) {
    for (int j=0; j<pwLen; ++j) sha256.put(pw[j]^0x36);
    for (int j=pwLen; j<64; ++j) sha256.put(0x36);
    for (int j=0; j<saltLen; ++j) sha256.put(salt[j]);
    for (int j=24; j>=0; j-=8) sha256.put(i>>j);
    memcpy(b, sha256.result(), 32);
    for (int j=0; j<pwLen; ++j) sha256.put(pw[j]^0x5c);
    for (int j=pwLen; j<64; ++j) sha256.put(0x5c);
    for (int j=0; j<32; ++j) sha256.put(b[j]);
    memcpy(unzBuf+i*32-32, sha256.result(), 32);
  }
}
// Hash b[0..15] using 8 rounds of salsa20
// Modified from http://cr.yp.to/salsa20.html (public domain) to 8 rounds
static void salsa8(uint32_t* b) {
  unsigned x[16]={0};
  memcpy(x, b, 64);
  for (int i=0; i<4; ++i) {
    #define R(a,b) (((a)<<(b))+((a)>>(32-b)))
    x[ 4] ^= R(x[ 0]+x[12], 7);  x[ 8] ^= R(x[ 4]+x[ 0], 9);
    x[12] ^= R(x[ 8]+x[ 4],13);  x[ 0] ^= R(x[12]+x[ 8],18);
    x[ 9] ^= R(x[ 5]+x[ 1], 7);  x[13] ^= R(x[ 9]+x[ 5], 9);
    x[ 1] ^= R(x[13]+x[ 9],13);  x[ 5] ^= R(x[ 1]+x[13],18);
    x[14] ^= R(x[10]+x[ 6], 7);  x[ 2] ^= R(x[14]+x[10], 9);
    x[ 6] ^= R(x[ 2]+x[14],13);  x[10] ^= R(x[ 6]+x[ 2],18);
    x[ 3] ^= R(x[15]+x[11], 7);  x[ 7] ^= R(x[ 3]+x[15], 9);
    x[11] ^= R(x[ 7]+x[ 3],13);  x[15] ^= R(x[11]+x[ 7],18);
    x[ 1] ^= R(x[ 0]+x[ 3], 7);  x[ 2] ^= R(x[ 1]+x[ 0], 9);
    x[ 3] ^= R(x[ 2]+x[ 1],13);  x[ 0] ^= R(x[ 3]+x[ 2],18);
    x[ 6] ^= R(x[ 5]+x[ 4], 7);  x[ 7] ^= R(x[ 6]+x[ 5], 9);
    x[ 4] ^= R(x[ 7]+x[ 6],13);  x[ 5] ^= R(x[ 4]+x[ 7],18);
    x[11] ^= R(x[10]+x[ 9], 7);  x[ 8] ^= R(x[11]+x[10], 9);
    x[ 9] ^= R(x[ 8]+x[11],13);  x[10] ^= R(x[ 9]+x[ 8],18);
    x[12] ^= R(x[15]+x[14], 7);  x[13] ^= R(x[12]+x[15], 9);
    x[14] ^= R(x[13]+x[12],13);  x[15] ^= R(x[14]+x[13],18);
    #undef R
  }
  for (int i=0; i<16; ++i) b[i]+=x[i];
}
// BlockMix_{Salsa20/8, r} on b[0..128*r-1]
static void blockmix(uint32_t* b, int r) {
  assert(r<=8);
  uint32_t x[16];
  uint32_t y[256];
  memcpy(x, b+32*r-16, 64);
  for (int i=0; i<2*r; ++i) {
    for (int j=0; j<16; ++j) x[j]^=b[i*16+j];
    salsa8(x);
    memcpy(&y[i*16], x, 64);
  }
  for (int i=0; i<r; ++i) memcpy(b+i*16, &y[i*32], 64);
  for (int i=0; i<r; ++i) memcpy(b+(i+r)*16, &y[i*32+16], 64);
}
// Mix b[0..128*r-1]. Uses 128*r*n bytes of memory and O(r*n) time
static void smix(char* b, int r, int n) {
  Array<uint32_t> x(32*r), v(32*r*n);
  for (int i=0; i<r*128; ++i) x[i/4]+=(b[i]&255)<<i%4*8;
  for (int i=0; i<n; ++i) {
    memcpy(&v[i*r*32], &x[0], r*128);
    blockmix(&x[0], r);
  }
  for (int i=0; i<n; ++i) {
    uint32_t j=x[(2*r-1)*16]&(n-1);
    for (int k=0; k<r*32; ++k) x[k]^=v[j*r*32+k];
    blockmix(&x[0], r);
  }
  for (int i=0; i<r*128; ++i) b[i]=x[i/4]>>(i%4*8);
}
// Strengthen password pw[0..pwlen-1] and salt[0..saltlen-1]
// to produce key unzBuf[0..buflen-1]. Uses O(n*r*p) time and 128*r*n bytes
// of memory. n must be a power of 2 and r <= 8.
void unzscrypt(const char* pw, int pwlen,
            const char* salt, int saltlen,
            int n, int r, int p, char* unzBuf, int buflen) {
  assert(r<=8);
  assert(n>0 && (n&(n-1))==0);  // power of 2?
  Array<char> b(p*r*128);
  unzpbkdf2(pw, pwlen, salt, saltlen,  &b[0], p*r*128);
  for (int i=0; i<p; ++i) smix(&b[i*r*128], r, n);
  unzpbkdf2(pw, pwlen, &b[0], p*r*128,  unzBuf, buflen);
}
// Stretch key in[0..31], assumed to be unzSHA256(password), with
// NUL terminate salt to produce new key out[0..31]
void stretchKey(char* out, const char* in, const char* salt) {
  unzscrypt(in, 32, salt, 32, 1<<14, 8, 1, out, 32);
}
//////////////////////////// unzZPAQL ///////////////////////////
// Symbolic instructions and their sizes
typedef enum {NONE,CONS,CM,ICM,MATCH,AVG,MIX2,MIX,ISSE,SSE} CompType;
const int compsize[256]={0,2,3,2,3,4,6,6,3,5};
// A unzZPAQL virtual machine COMP+HCOMP or PCOMP.
class unzZPAQL {
public:
  unzZPAQL();
  void clear();           // Free memory, erase program, reset machine state
  void inith();           // Initialize as HCOMP to run
  void initp();           // Initialize as PCOMP to run
  void run(uint32_t input);    // Execute with input
  int read(unzReader* in2);  // Read header
  void outc(int c);       // output a byte
  unzWriter* output;         // Destination for OUT instruction, or 0 to suppress
  unzSHA1* sha1;             // Points to checksum computer
  uint32_t H(int i) {return h(i);}  // get element of h
  // unzZPAQL block header
  Array<uint8_t> header;   // hsize[2] hh hm ph pm n COMP (guard) HCOMP (guard)
  int cend;           // COMP in header[7...cend-1]
  int hbegin, hend;   // HCOMP/PCOMP in header[hbegin...hend-1]
private:
  // Machine state for executing HCOMP
  Array<uint8_t> m;        // memory array M for HCOMP
  Array<uint32_t> h;       // hash array H for HCOMP
  Array<uint32_t> r;       // 256 element register array
  uint32_t a, b, c, d;     // machine registers
  int f;              // condition flag
  int pc;             // program counter
  // Support code
  void init(int hbits, int mbits);  // initialize H and M sizes
  int execute();  // execute 1 instruction, return 0 after HALT, else 1
  void unzdiv(uint32_t x) {if (x) a/=x; else a=0;}
  void mod(uint32_t x) {if (x) a%=x; else a=0;}
  void swap(uint32_t& x) {a^=x; x^=a; a^=x;}
  void swap(uint8_t& x)  {a^=x; x^=a; a^=x;}
  void err();  // exit with run time error
};
// Read header from in2
int unzZPAQL::read(unzReader* in2) {
  // Get header size and allocate
  int hsize=in2->get();
  if (hsize<0) unzerror("end of header");
  hsize+=in2->get()*256;
  if (hsize<0) unzerror("end of header");
  header.resize(hsize+300);
  cend=hbegin=hend=0;
  header[cend++]=hsize&255;
  header[cend++]=hsize>>8;
  while (cend<7) header[cend++]=in2->get(); // hh hm ph pm n
  // Read COMP
  int n=header[cend-1];
  for (int i=0; i<n; ++i) {
    int type=in2->get();  // component type
    if (type==-1) unzerror("unexpected end of file");
    header[cend++]=type;  // component type
    int size=compsize[type];
    if (size<1) unzerror("Invalid component type");
    if (cend+size>hsize) unzerror("COMP overflows header");
    for (int j=1; j<size; ++j)
      header[cend++]=in2->get();
  }
  if ((header[cend++]=in2->get())!=0) unzerror("missing COMP END");
  // Insert a guard gap and read HCOMP
  hbegin=hend=cend+128;
  if (hend>hsize+129) unzerror("missing HCOMP");
  while (hend<hsize+129) {
    assert(hend<header.isize()-8);
    int op=in2->get();
    if (op<0) unzerror("unexpected end of file");
    header[hend++]=op;
  }
  if ((header[hend++]=in2->get())!=0) unzerror("missing HCOMP END");
  assert(cend>=7 && cend<header.isize());
  assert(hbegin==cend+128 && hbegin<header.isize());
  assert(hend>hbegin && hend<header.isize());
  assert(hsize==header[0]+256*header[1]);
  assert(hsize==cend-2+hend-hbegin);
  return cend+hend-hbegin;
}
// Free memory, but preserve output, sha1 pointers
void unzZPAQL::clear() {
  cend=hbegin=hend=0;  // COMP and HCOMP locations
  a=b=c=d=f=pc=0;      // machine state
  header.resize(0);
  h.resize(0);
  m.resize(0);
  r.resize(0);
}
// Constructor
unzZPAQL::unzZPAQL() {
  output=0;
  sha1=0;
  clear();
}
// Initialize machine state as HCOMP
void unzZPAQL::inith() {
  assert(header.isize()>6);
  assert(output==0);
  assert(sha1==0);
  init(header[2], header[3]); // hh, hm
}
// Initialize machine state as PCOMP
void unzZPAQL::initp() {
  assert(header.isize()>6);
  init(header[4], header[5]); // ph, pm
}
// Initialize machine state to run a program.
void unzZPAQL::init(int hbits, int mbits) {
  assert(header.isize()>0);
  assert(cend>=7);
  assert(hbegin>=cend+128);
  assert(hend>=hbegin);
  assert(hend<header.isize()-130);
  assert(header[0]+256*header[1]==cend-2+hend-hbegin);
  h.resize(1, hbits);
  m.resize(1, mbits);
  r.resize(256);
  a=b=c=d=pc=f=0;
}
// Run program on input by interpreting header
void unzZPAQL::run(uint32_t input) {
  assert(cend>6);
  assert(hbegin>=cend+128);
  assert(hend>=hbegin);
  assert(hend<header.isize()-130);
  assert(m.size()>0);
  assert(h.size()>0);
  assert(header[0]+256*header[1]==cend+hend-hbegin-2);
  pc=hbegin;
  a=input;
  while (execute()) ;
}
void unzZPAQL::outc(int c) {
  if (output) output->put(c);
  if (sha1) sha1->put(c);
}
// Execute one instruction, return 0 after HALT else 1
int unzZPAQL::execute() {
  switch(header[pc++]) {
    case 0: err(); break; // ERROR
    case 1: ++a; break; // A++
    case 2: --a; break; // A--
    case 3: a = ~a; break; // A!
    case 4: a = 0; break; // A=0
    case 7: a = r[header[pc++]]; break; // A=R N
    case 8: swap(b); break; // B<>A
    case 9: ++b; break; // B++
    case 10: --b; break; // B--
    case 11: b = ~b; break; // B!
    case 12: b = 0; break; // B=0
    case 15: b = r[header[pc++]]; break; // B=R N
    case 16: swap(c); break; // C<>A
    case 17: ++c; break; // C++
    case 18: --c; break; // C--
    case 19: c = ~c; break; // C!
    case 20: c = 0; break; // C=0
    case 23: c = r[header[pc++]]; break; // C=R N
    case 24: swap(d); break; // D<>A
    case 25: ++d; break; // D++
    case 26: --d; break; // D--
    case 27: d = ~d; break; // D!
    case 28: d = 0; break; // D=0
    case 31: d = r[header[pc++]]; break; // D=R N
    case 32: swap(m(b)); break; // *B<>A
    case 33: ++m(b); break; // *B++
    case 34: --m(b); break; // *B--
    case 35: m(b) = ~m(b); break; // *B!
    case 36: m(b) = 0; break; // *B=0
    case 39: if (f) pc+=((header[pc]+128)&255)-127; else ++pc; break; // JT N
    case 40: swap(m(c)); break; // *C<>A
    case 41: ++m(c); break; // *C++
    case 42: --m(c); break; // *C--
    case 43: m(c) = ~m(c); break; // *C!
    case 44: m(c) = 0; break; // *C=0
    case 47: if (!f) pc+=((header[pc]+128)&255)-127; else ++pc; break; // JF N
    case 48: swap(h(d)); break; // *D<>A
    case 49: ++h(d); break; // *D++
    case 50: --h(d); break; // *D--
    case 51: h(d) = ~h(d); break; // *D!
    case 52: h(d) = 0; break; // *D=0
    case 55: r[header[pc++]] = a; break; // R=A N
    case 56: return 0  ; // HALT
    case 57: outc(a&255); break; // OUT
    case 59: a = (a+m(b)+512)*773; break; // HASH
    case 60: h(d) = (h(d)+a+512)*773; break; // HASHD
    case 63: pc+=((header[pc]+128)&255)-127; break; // JMP N
    case 64: break; // A=A
    case 65: a = b; break; // A=B
    case 66: a = c; break; // A=C
    case 67: a = d; break; // A=D
    case 68: a = m(b); break; // A=*B
    case 69: a = m(c); break; // A=*C
    case 70: a = h(d); break; // A=*D
    case 71: a = header[pc++]; break; // A= N
    case 72: b = a; break; // B=A
    case 73: break; // B=B
    case 74: b = c; break; // B=C
    case 75: b = d; break; // B=D
    case 76: b = m(b); break; // B=*B
    case 77: b = m(c); break; // B=*C
    case 78: b = h(d); break; // B=*D
    case 79: b = header[pc++]; break; // B= N
    case 80: c = a; break; // C=A
    case 81: c = b; break; // C=B
    case 82: break; // C=C
    case 83: c = d; break; // C=D
    case 84: c = m(b); break; // C=*B
    case 85: c = m(c); break; // C=*C
    case 86: c = h(d); break; // C=*D
    case 87: c = header[pc++]; break; // C= N
    case 88: d = a; break; // D=A
    case 89: d = b; break; // D=B
    case 90: d = c; break; // D=C
    case 91: break; // D=D
    case 92: d = m(b); break; // D=*B
    case 93: d = m(c); break; // D=*C
    case 94: d = h(d); break; // D=*D
    case 95: d = header[pc++]; break; // D= N
    case 96: m(b) = a; break; // *B=A
    case 97: m(b) = b; break; // *B=B
    case 98: m(b) = c; break; // *B=C
    case 99: m(b) = d; break; // *B=D
    case 100: break; // *B=*B
    case 101: m(b) = m(c); break; // *B=*C
    case 102: m(b) = h(d); break; // *B=*D
    case 103: m(b) = header[pc++]; break; // *B= N
    case 104: m(c) = a; break; // *C=A
    case 105: m(c) = b; break; // *C=B
    case 106: m(c) = c; break; // *C=C
    case 107: m(c) = d; break; // *C=D
    case 108: m(c) = m(b); break; // *C=*B
    case 109: break; // *C=*C
    case 110: m(c) = h(d); break; // *C=*D
    case 111: m(c) = header[pc++]; break; // *C= N
    case 112: h(d) = a; break; // *D=A
    case 113: h(d) = b; break; // *D=B
    case 114: h(d) = c; break; // *D=C
    case 115: h(d) = d; break; // *D=D
    case 116: h(d) = m(b); break; // *D=*B
    case 117: h(d) = m(c); break; // *D=*C
    case 118: break; // *D=*D
    case 119: h(d) = header[pc++]; break; // *D= N
    case 128: a += a; break; // A+=A
    case 129: a += b; break; // A+=B
    case 130: a += c; break; // A+=C
    case 131: a += d; break; // A+=D
    case 132: a += m(b); break; // A+=*B
    case 133: a += m(c); break; // A+=*C
    case 134: a += h(d); break; // A+=*D
    case 135: a += header[pc++]; break; // A+= N
    case 136: a -= a; break; // A-=A
    case 137: a -= b; break; // A-=B
    case 138: a -= c; break; // A-=C
    case 139: a -= d; break; // A-=D
    case 140: a -= m(b); break; // A-=*B
    case 141: a -= m(c); break; // A-=*C
    case 142: a -= h(d); break; // A-=*D
    case 143: a -= header[pc++]; break; // A-= N
    case 144: a *= a; break; // A*=A
    case 145: a *= b; break; // A*=B
    case 146: a *= c; break; // A*=C
    case 147: a *= d; break; // A*=D
    case 148: a *= m(b); break; // A*=*B
    case 149: a *= m(c); break; // A*=*C
    case 150: a *= h(d); break; // A*=*D
    case 151: a *= header[pc++]; break; // A*= N
    case 152: unzdiv(a); break; // A/=A
    case 153: unzdiv(b); break; // A/=B
    case 154: unzdiv(c); break; // A/=C
    case 155: unzdiv(d); break; // A/=D
    case 156: unzdiv(m(b)); break; // A/=*B
    case 157: unzdiv(m(c)); break; // A/=*C
    case 158: unzdiv(h(d)); break; // A/=*D
    case 159: unzdiv(header[pc++]); break; // A/= N
    case 160: mod(a); break; // A%=A
    case 161: mod(b); break; // A%=B
    case 162: mod(c); break; // A%=C
    case 163: mod(d); break; // A%=D
    case 164: mod(m(b)); break; // A%=*B
    case 165: mod(m(c)); break; // A%=*C
    case 166: mod(h(d)); break; // A%=*D
    case 167: mod(header[pc++]); break; // A%= N
    case 168: a &= a; break; // A&=A
    case 169: a &= b; break; // A&=B
    case 170: a &= c; break; // A&=C
    case 171: a &= d; break; // A&=D
    case 172: a &= m(b); break; // A&=*B
    case 173: a &= m(c); break; // A&=*C
    case 174: a &= h(d); break; // A&=*D
    case 175: a &= header[pc++]; break; // A&= N
    case 176: a &= ~ a; break; // A&~A
    case 177: a &= ~ b; break; // A&~B
    case 178: a &= ~ c; break; // A&~C
    case 179: a &= ~ d; break; // A&~D
    case 180: a &= ~ m(b); break; // A&~*B
    case 181: a &= ~ m(c); break; // A&~*C
    case 182: a &= ~ h(d); break; // A&~*D
    case 183: a &= ~ header[pc++]; break; // A&~ N
    case 184: a |= a; break; // A|=A
    case 185: a |= b; break; // A|=B
    case 186: a |= c; break; // A|=C
    case 187: a |= d; break; // A|=D
    case 188: a |= m(b); break; // A|=*B
    case 189: a |= m(c); break; // A|=*C
    case 190: a |= h(d); break; // A|=*D
    case 191: a |= header[pc++]; break; // A|= N
    case 192: a ^= a; break; // A^=A
    case 193: a ^= b; break; // A^=B
    case 194: a ^= c; break; // A^=C
    case 195: a ^= d; break; // A^=D
    case 196: a ^= m(b); break; // A^=*B
    case 197: a ^= m(c); break; // A^=*C
    case 198: a ^= h(d); break; // A^=*D
    case 199: a ^= header[pc++]; break; // A^= N
    case 200: a <<= (a&31); break; // A<<=A
    case 201: a <<= (b&31); break; // A<<=B
    case 202: a <<= (c&31); break; // A<<=C
    case 203: a <<= (d&31); break; // A<<=D
    case 204: a <<= (m(b)&31); break; // A<<=*B
    case 205: a <<= (m(c)&31); break; // A<<=*C
    case 206: a <<= (h(d)&31); break; // A<<=*D
    case 207: a <<= (header[pc++]&31); break; // A<<= N
    case 208: a >>= (a&31); break; // A>>=A
    case 209: a >>= (b&31); break; // A>>=B
    case 210: a >>= (c&31); break; // A>>=C
    case 211: a >>= (d&31); break; // A>>=D
    case 212: a >>= (m(b)&31); break; // A>>=*B
    case 213: a >>= (m(c)&31); break; // A>>=*C
    case 214: a >>= (h(d)&31); break; // A>>=*D
    case 215: a >>= (header[pc++]&31); break; // A>>= N
    case 216: f = (true); break; // A==A f = (a == a)
    case 217: f = (a == b); break; // A==B
    case 218: f = (a == c); break; // A==C
    case 219: f = (a == d); break; // A==D
    case 220: f = (a == uint32_t(m(b))); break; // A==*B
    case 221: f = (a == uint32_t(m(c))); break; // A==*C
    case 222: f = (a == h(d)); break; // A==*D
    case 223: f = (a == uint32_t(header[pc++])); break; // A== N
    case 224: f = (false); break; // A<A f = (a < a)
    case 225: f = (a < b); break; // A<B
    case 226: f = (a < c); break; // A<C
    case 227: f = (a < d); break; // A<D
    case 228: f = (a < uint32_t(m(b))); break; // A<*B
    case 229: f = (a < uint32_t(m(c))); break; // A<*C
    case 230: f = (a < h(d)); break; // A<*D
    case 231: f = (a < uint32_t(header[pc++])); break; // A< N
    case 232: f = (false); break; // A>A f= (a > a)
    case 233: f = (a > b); break; // A>B
    case 234: f = (a > c); break; // A>C
    case 235: f = (a > d); break; // A>D
    case 236: f = (a > uint32_t(m(b))); break; // A>*B
    case 237: f = (a > uint32_t(m(c))); break; // A>*C
    case 238: f = (a > h(d)); break; // A>*D
    case 239: f = (a > uint32_t(header[pc++])); break; // A> N
    case 255: if((pc=hbegin+header[pc]+256*header[pc+1])>=hend)err();break;//LJ
    default: err();
  }
  return 1;
}
// Print illegal instruction error message and exit
void unzZPAQL::err() {
  unzerror("unzZPAQL execution error");
}
///////////////////////// Component //////////////////////////
// A Component is a context model, indirect context model, match model,
// fixed weight mixer, adaptive 2 input mixer without or with current
// partial byte as context, adaptive m input mixer (without or with),
// or SSE (without or with).
struct unzComponent {
  uint32_t limit;      // max count for cm
  uint32_t cxt;        // saved context
  uint32_t a, b, c;    // multi-purpose variables
  Array<uint32_t> cm;  // cm[cxt] -> p in bits 31..10, n in 9..0; MATCH index
  Array<uint8_t> ht;   // ICM/ISSE hash table[0..size1][0..15] and MATCH unzBuf
  Array<uint16_t> a16; // MIX weights
  void init();    // initialize to all 0
  unzComponent() {init();}
};
void unzComponent::init() {
  limit=cxt=a=b=c=0;
  cm.resize(0);
  ht.resize(0);
  a16.resize(0);
}
////////////////////////// StateTable ////////////////////////
// Next state table generator
class StateTable {
  enum {N=64}; // sizes of b, t
  int num_states(int n0, int n1);  // compute t[n0][n1][1]
  void discount(int& n0);  // set new value of n0 after 1 or n1 after 0
  void next_state(int& n0, int& n1, int y);  // new (n0,n1) after bit y
public:
  uint8_t ns[1024]; // state*4 -> next state if 0, if 1, n0, n1
  int next(int state, int y) {  // next state for bit y
    assert(state>=0 && state<256);
    assert(y>=0 && y<4);
    return ns[state*4+y];
  }
  int cminit(int state) {  // initial probability of 1 * 2^23
    assert(state>=0 && state<256);
    return ((ns[state*4+3]*2+1)<<22)/(ns[state*4+2]+ns[state*4+3]+1);
  }
  StateTable();
};
// How many states with count of n0 zeros, n1 ones (0...2)
int StateTable::num_states(int n0, int n1) {
  const int B=6;
  const int bound[B]={20,48,15,8,6,5}; // n0 -> max n1, n1 -> max n0
  if (n0<n1) return num_states(n1, n0);
  if (n0<0 || n1<0 || n1>=B || n0>bound[n1]) return 0;
  return 1+(n1>0 && n0+n1<=17);
}
// New value of count n0 if 1 is observed (and vice versa)
void StateTable::discount(int& n0) {
  n0=(n0>=1)+(n0>=2)+(n0>=3)+(n0>=4)+(n0>=5)+(n0>=7)+(n0>=8);
}
// compute next n0,n1 (0 to N) given input y (0 or 1)
void StateTable::next_state(int& n0, int& n1, int y) {
  if (n0<n1)
    next_state(n1, n0, 1-y);
  else {
    if (y) {
      ++n1;
      discount(n0);
    }
    else {
      ++n0;
      discount(n1);
    }
    // 20,0,0 -> 20,0
    // 48,1,0 -> 48,1
    // 15,2,0 -> 8,1
    //  8,3,0 -> 6,2
    //  8,3,1 -> 5,3
    //  6,4,0 -> 5,3
    //  5,5,0 -> 5,4
    //  5,5,1 -> 4,5
    while (!num_states(n0, n1)) {
      if (n1<2) --n0;
      else {
        n0=(n0*(n1-1)+(n1/2))/n1;
        --n1;
      }
    }
  }
}
// Initialize next state table ns[state*4] -> next if 0, next if 1, n0, n1
StateTable::StateTable() {
  // Assign states by increasing priority
  const int N=50;
  uint8_t t[N][N][2]={{{0}}}; // (n0,n1,y) -> state number
  int state=0;
  for (int i=0; i<N; ++i) {
    for (int n1=0; n1<=i; ++n1) {
      int n0=i-n1;
      int n=num_states(n0, n1);
      assert(n>=0 && n<=2);
      if (n) {
        t[n0][n1][0]=state;
        t[n0][n1][1]=state+n-1;
        state+=n;
      }
    }
  }
  // Generate next state table
  memset(ns, 0, sizeof(ns));
  for (int n0=0; n0<N; ++n0) {
    for (int n1=0; n1<N; ++n1) {
      for (int y=0; y<num_states(n0, n1); ++y) {
        int s=t[n0][n1][y];
        assert(s>=0 && s<256);
        int s0=n0, s1=n1;
        next_state(s0, s1, 0);
        assert(s0>=0 && s0<N && s1>=0 && s1<N);
        ns[s*4+0]=t[s0][s1][0];
        s0=n0, s1=n1;
        next_state(s0, s1, 1);
        assert(s0>=0 && s0<N && s1>=0 && s1<N);
        ns[s*4+1]=t[s0][s1][1];
        ns[s*4+2]=n0;
        ns[s*4+3]=n1;
      }
    }
  }
}
///////////////////////// Predictor //////////////////////////
// A predictor guesses the next bit
class unzPredictor {
public:
  unzPredictor(unzZPAQL&);
  void init();          // build model
  int predict();        // probability that next bit is a 1 (0..32767)
  void update(int y);   // train on bit y (0..1)
  bool isModeled() {    // n>0 components?
    assert(z.header.isize()>6);
    return z.header[6]!=0;
  }
private:
  // unzPredictor state
  int c8;               // last 0...7 bits.
  int hmap4;            // c8 split into nibbles
  int p[256];           // predictions
  uint32_t h[256];           // unrolled copy of z.h
  unzZPAQL& z;             // VM to compute context hashes, includes H, n
  unzComponent comp[256];  // the model, includes P
  // Modeling support functions
  int dt2k[256];        // division table for match: dt2k[i] = 2^12/i
  int dt[1024];         // division table for cm: dt[i] = 2^16/(i+1.5)
  uint16_t squasht[4096];    // squash() lookup table
  short stretcht[32768];// stretch() lookup table
  StateTable st;        // next, cminit functions
  // reduce prediction error in cr.cm
  void train(unzComponent& cr, int y) {
    assert(y==0 || y==1);
    uint32_t& pn=cr.cm(cr.cxt);
    uint32_t count=pn&0x3ff;
    int error=y*32767-(cr.cm(cr.cxt)>>17);
    pn+=(error*dt[count]&-1024)+(count<cr.limit);
  }
  // x -> floor(32768/(1+exp(-x/64)))
  int squash(int x) {
    assert(x>=-2048 && x<=2047);
    return squasht[x+2048];
  }
  // x -> round(64*log((x+0.5)/(32767.5-x))), approx inverse of squash
  int stretch(int x) {
    assert(x>=0 && x<=32767);
    return stretcht[x];
  }
  // bound x to a 12 bit signed int
  int clamp2k(int x) {
    if (x<-2048) return -2048;
    else if (x>2047) return 2047;
    else return x;
  }
  // bound x to a 20 bit signed int
  int clamp512k(int x) {
    if (x<-(1<<19)) return -(1<<19);
    else if (x>=(1<<19)) return (1<<19)-1;
    else return x;
  }
  // Get cxt in ht, creating a new row if needed
  size_t find(Array<uint8_t>& ht, int sizebits, uint32_t cxt);
};



// Initailize model-independent tables
unzPredictor::unzPredictor(unzZPAQL& zr):
    c8(1), hmap4(1), z(zr) {
  assert(sizeof(uint8_t)==1);
  assert(sizeof(uint16_t)==2);
  assert(sizeof(uint32_t)==4);
  assert(sizeof(uint64_t)==8);
  assert(sizeof(short)==2);
  assert(sizeof(int)==4);
  // Initialize tables
  dt2k[0]=0;
  for (int i=1; i<256; ++i)
    dt2k[i]=2048/i;
  for (int i=0; i<1024; ++i)
    dt[i]=(1<<17)/(i*2+3)*2;
  for (int i=0; i<32768; ++i)
    stretcht[i]=int(custom_log((i+0.5)/(32767.5-i))*64+0.5+100000)-100000;
  for (int i=0; i<4096; ++i)
    squasht[i]=int(32768.0/(1+custom_exp((i-2048)*(-1.0/64))));
  // Verify floating point math for squash() and stretch()
  uint32_t sqsum=0, stsum=0;
  for (int i=32767; i>=0; --i)
    stsum=stsum*3+stretch(i);
  for (int i=4095; i>=0; --i)
    sqsum=sqsum*3+squash(i-2048);
  assert(stsum==3887533746u);
  assert(sqsum==2278286169u);
}
// Initialize the predictor with a new model in z
void unzPredictor::init() {
  // Initialize context hash function
  z.inith();
  // Initialize predictions
  for (int i=0; i<256; ++i) h[i]=p[i]=0;
  // Initialize components
  for (int i=0; i<256; ++i)  // clear old model
    comp[i].init();
  int n=z.header[6]; // hsize[0..1] hh hm ph pm n (comp)[n] 0 0[128] (hcomp) 0
  const uint8_t* cp=&z.header[7];  // start of component list
  for (int i=0; i<n; ++i) {
    assert(cp<&z.header[z.cend]);
    assert(cp>&z.header[0] && cp<&z.header[z.header.isize()-8]);
    unzComponent& cr=comp[i];
    switch(cp[0]) {
      case CONS:  // c
        p[i]=(cp[1]-128)*4;
        break;
      case CM: // sizebits limit
        if (cp[1]>32) unzerror("max size for CM is 32");
        cr.cm.resize(1, cp[1]);  // packed CM (22 bits) + CMCOUNT (10 bits)
        cr.limit=cp[2]*4;
        for (size_t j=0; j<cr.cm.size(); ++j)
          cr.cm[j]=0x80000000;
        break;
      case ICM: // sizebits
        if (cp[1]>26) unzerror("max size for ICM is 26");
        cr.limit=1023;
        cr.cm.resize(256);
        cr.ht.resize(64, cp[1]);
        for (size_t j=0; j<cr.cm.size(); ++j)
          cr.cm[j]=st.cminit(j);
        break;
      case MATCH:  // sizebits
        if (cp[1]>32 || cp[2]>32) unzerror("max size for MATCH is 32 32");
        cr.cm.resize(1, cp[1]);  // index
        cr.ht.resize(1, cp[2]);  // unzBuf
        cr.ht(0)=1;
        break;
      case AVG: // j k wt
        if (cp[1]>=i) unzerror("AVG j >= i");
        if (cp[2]>=i) unzerror("AVG k >= i");
        break;
      case MIX2:  // sizebits j k rate mask
        if (cp[1]>32) unzerror("max size for MIX2 is 32");
        if (cp[3]>=i) unzerror("MIX2 k >= i");
        if (cp[2]>=i) unzerror("MIX2 j >= i");
        cr.c=(size_t(1)<<cp[1]); // size (number of contexts)
        cr.a16.resize(1, cp[1]);  // wt[size][m]
        for (size_t j=0; j<cr.a16.size(); ++j)
          cr.a16[j]=32768;
        break;
      case MIX: {  // sizebits j m rate mask
        if (cp[1]>32) unzerror("max size for MIX is 32");
        if (cp[2]>=i) unzerror("MIX j >= i");
        if (cp[3]<1 || cp[3]>i-cp[2]) unzerror("MIX m not in 1..i-j");
        int m=cp[3];  // number of inputs
        assert(m>=1);
        cr.c=(size_t(1)<<cp[1]); // size (number of contexts)
        cr.cm.resize(m, cp[1]);  // wt[size][m]
        for (size_t j=0; j<cr.cm.size(); ++j)
          cr.cm[j]=65536/m;
        break;
      }
      case ISSE:  // sizebits j
        if (cp[1]>32) unzerror("max size for ISSE is 32");
        if (cp[2]>=i) unzerror("ISSE j >= i");
        cr.ht.resize(64, cp[1]);
        cr.cm.resize(512);
        for (int j=0; j<256; ++j) {
          cr.cm[j*2]=1<<15;
          cr.cm[j*2+1]=clamp512k(stretch(st.cminit(j)>>8)*1024);
        }
        break;
      case SSE: // sizebits j start limit
        if (cp[1]>32) unzerror("max size for SSE is 32");
        if (cp[2]>=i) unzerror("SSE j >= i");
        if (cp[3]>cp[4]*4) unzerror("SSE start > limit*4");
        cr.cm.resize(32, cp[1]);
        cr.limit=cp[4]*4;
        for (size_t j=0; j<cr.cm.size(); ++j)
          cr.cm[j]=squash((j&31)*64-992)<<17|cp[3];
        break;
      default: unzerror("unknown component type");
    }
    assert(compsize[*cp]>0);
    cp+=compsize[*cp];
    assert(cp>=&z.header[7] && cp<&z.header[z.cend]);
  }
}
// Return next bit prediction using interpreted COMP code
int unzPredictor::predict() {
  assert(c8>=1 && c8<=255);
  // Predict next bit
  int n=z.header[6];
  assert(n>0 && n<=255);
  const uint8_t* cp=&z.header[7];
  ///assert(cp[-1]==n);
  for (int i=0; i<n; ++i) {
    assert(cp>&z.header[0] && cp<&z.header[z.header.isize()-8]);
    unzComponent& cr=comp[i];
    switch(cp[0]) {
      case CONS:  // c
        break;
      case CM:  // sizebits limit
        cr.cxt=h[i]^hmap4;
        p[i]=stretch(cr.cm(cr.cxt)>>17);
        break;
      case ICM: // sizebits
        assert((hmap4&15)>0);
        if (c8==1 || (c8&0xf0)==16) cr.c=find(cr.ht, cp[1]+2, h[i]+16*c8);
        cr.cxt=cr.ht[cr.c+(hmap4&15)];
        p[i]=stretch(cr.cm(cr.cxt)>>8);
        break;
      case MATCH: // sizebits bufbits: a=len, b=offset, c=bit, cxt=bitpos,
                  //                   ht=unzBuf, limit=pos
        assert(cr.cm.size()==(size_t(1)<<cp[1]));
        assert(cr.ht.size()==(size_t(1)<<cp[2]));
        assert(cr.a<=255);
        assert(cr.c==0 || cr.c==1);
        assert(cr.cxt<8);
        assert(cr.limit<cr.ht.size());
        if (cr.a==0) p[i]=0;
        else {
          cr.c=(cr.ht(cr.limit-cr.b)>>(7-cr.cxt))&1; // predicted bit
          p[i]=stretch(dt2k[cr.a]*(cr.c*-2+1)&32767);
        }
        break;
      case AVG: // j k wt
        p[i]=(p[cp[1]]*cp[3]+p[cp[2]]*(256-cp[3]))>>8;
        break;
      case MIX2: { // sizebits j k rate mask
                   // c=size cm=wt[size] cxt=input
        cr.cxt=((h[i]+(c8&cp[5]))&(cr.c-1));
        assert(cr.cxt<cr.a16.size());
        int w=cr.a16[cr.cxt];
        assert(w>=0 && w<65536);
        p[i]=(w*p[cp[2]]+(65536-w)*p[cp[3]])>>16;
        assert(p[i]>=-2048 && p[i]<2048);
      }
        break;
      case MIX: {  // sizebits j m rate mask
                   // c=size cm=wt[size][m] cxt=index of wt in cm
        int m=cp[3];
        assert(m>=1 && m<=i);
        cr.cxt=h[i]+(c8&cp[5]);
        cr.cxt=(cr.cxt&(cr.c-1))*m; // pointer to row of weights
        assert(cr.cxt<=cr.cm.size()-m);
        const int* wt=(int*)&cr.cm[cr.cxt];
        p[i]=0;
        for (int j=0; j<m; ++j)
          p[i]+=(wt[j]>>8)*p[cp[2]+j];
        p[i]=clamp2k(p[i]>>8);
      }
        break;
      case ISSE: { // sizebits j -- c=hi, cxt=bh
        assert((hmap4&15)>0);
        if (c8==1 || (c8&0xf0)==16)
          cr.c=find(cr.ht, cp[1]+2, h[i]+16*c8);
        cr.cxt=cr.ht[cr.c+(hmap4&15)];  // bit history
        const int *wt=(int*)&cr.cm[cr.cxt*2];
        p[i]=clamp2k((wt[0]*p[cp[2]]+wt[1]*64)>>16);
      }
        break;
      case SSE: { // sizebits j start limit
        cr.cxt=(h[i]+c8)*32;
        int pq=p[cp[2]]+992;
        if (pq<0) pq=0;
        if (pq>1983) pq=1983;
        int wt=pq&63;
        pq>>=6;
        assert(pq>=0 && pq<=30);
        cr.cxt+=pq;
        p[i]=stretch(((cr.cm(cr.cxt)>>10)*(64-wt)+(cr.cm(cr.cxt+1)>>10)*wt)
             >>13);
        cr.cxt+=wt>>5;
      }
        break;
      default:
        unzerror("component predict not implemented");
    }
    cp+=compsize[cp[0]];
    assert(cp<&z.header[z.cend]);
    assert(p[i]>=-2048 && p[i]<2048);
  }
  assert(cp[0]==NONE);
  return squash(p[n-1]);
}
// Update model with decoded bit y (0...1)
void unzPredictor::update(int y) {
  assert(y==0 || y==1);
  assert(c8>=1 && c8<=255);
  assert(hmap4>=1 && hmap4<=511);
  // Update components
  const uint8_t* cp=&z.header[7];
  int n=z.header[6];
  assert(n>=1 && n<=255);
  ///assert(cp[-1]==n);
  for (int i=0; i<n; ++i) {
    unzComponent& cr=comp[i];
    switch(cp[0]) {
      case CONS:  // c
        break;
      case CM:  // sizebits limit
        train(cr, y);
        break;
      case ICM: { // sizebits: cxt=ht[b]=bh, ht[c][0..15]=bh row, cxt=bh
        cr.ht[cr.c+(hmap4&15)]=st.next(cr.ht[cr.c+(hmap4&15)], y);
        uint32_t& pn=cr.cm(cr.cxt);
        pn+=int(y*32767-(pn>>8))>>2;
      }
        break;
      case MATCH: // sizebits bufbits:
                  //   a=len, b=offset, c=bit, cm=index, cxt=bitpos
                  //   ht=unzBuf, limit=pos
      {
        assert(cr.a<=255);
        assert(cr.c==0 || cr.c==1);
        assert(cr.cxt<8);
        assert(cr.cm.size()==(size_t(1)<<cp[1]));
        assert(cr.ht.size()==(size_t(1)<<cp[2]));
        assert(cr.limit<cr.ht.size());
        if (int(cr.c)!=y) cr.a=0;  // mismatch?
        cr.ht(cr.limit)+=cr.ht(cr.limit)+y;
        if (++cr.cxt==8) {
          cr.cxt=0;
          ++cr.limit;
          cr.limit&=(1<<cp[2])-1;
          if (cr.a==0) {  // look for a match
            cr.b=cr.limit-cr.cm(h[i]);
            if (cr.b&(cr.ht.size()-1))
              while (cr.a<255
                     && cr.ht(cr.limit-cr.a-1)==cr.ht(cr.limit-cr.a-cr.b-1))
                ++cr.a;
          }
          else cr.a+=cr.a<255;
          cr.cm(h[i])=cr.limit;
        }
      }
        break;
      case AVG:  // j k wt
        break;
      case MIX2: { // sizebits j k rate mask
                   // cm=wt[size], cxt=input
        assert(cr.a16.size()==cr.c);
        assert(cr.cxt<cr.a16.size());
        int err=(y*32767-squash(p[i]))*cp[4]>>5;
        int w=cr.a16[cr.cxt];
        w+=(err*(p[cp[2]]-p[cp[3]])+(1<<12))>>13;
        if (w<0) w=0;
        if (w>65535) w=65535;
        cr.a16[cr.cxt]=w;
      }
        break;
      case MIX: {   // sizebits j m rate mask
                    // cm=wt[size][m], cxt=input
        int m=cp[3];
        assert(m>0 && m<=i);
        assert(cr.cm.size()==m*cr.c);
        assert(cr.cxt+m<=cr.cm.size());
        int err=(y*32767-squash(p[i]))*cp[4]>>4;
        int* wt=(int*)&cr.cm[cr.cxt];
        for (int j=0; j<m; ++j)
          wt[j]=clamp512k(wt[j]+((err*p[cp[2]+j]+(1<<12))>>13));
      }
        break;
      case ISSE: { // sizebits j  -- c=hi, cxt=bh
        assert(cr.cxt==uint32_t(cr.ht[cr.c+(hmap4&15)]));
        int err=y*32767-squash(p[i]);
        int *wt=(int*)&cr.cm[cr.cxt*2];
        wt[0]=clamp512k(wt[0]+((err*p[cp[2]]+(1<<12))>>13));
        wt[1]=clamp512k(wt[1]+((err+16)>>5));
        cr.ht[cr.c+(hmap4&15)]=st.next(cr.cxt, y);
      }
        break;
      case SSE:  // sizebits j start limit
        train(cr, y);
        break;
      default:
        assert(0);
    }
    cp+=compsize[cp[0]];
    assert(cp>=&z.header[7] && cp<&z.header[z.cend]
           && cp<&z.header[z.header.isize()-8]);
  }
  assert(cp[0]==NONE);
  // Save bit y in c8, hmap4
  c8+=c8+y;
  if (c8>=256) {
    z.run(c8-256);
    hmap4=1;
    c8=1;
    for (int i=0; i<n; ++i) h[i]=z.H(i);
  }
  else if (c8>=16 && c8<32)
    hmap4=(hmap4&0xf)<<5|y<<4|1;
  else
    hmap4=(hmap4&0x1f0)|(((hmap4&0xf)*2+y)&0xf);
}
// Find cxt row in hash table ht. ht has rows of 16 indexed by the
// low sizebits of cxt with element 0 having the next higher 8 bits for
// collision detection. If not found after 3 adjacent tries, replace the
// row with lowest element 1 as priority. Return index of row.
size_t unzPredictor::find(Array<uint8_t>& ht, int sizebits, uint32_t cxt) {
  assert(ht.size()==size_t(16)<<sizebits);
  int chk=cxt>>sizebits&255;
  size_t h0=(cxt*16)&(ht.size()-16);
  if (ht[h0]==chk) return h0;
  size_t h1=h0^16;
  if (ht[h1]==chk) return h1;
  size_t h2=h0^32;
  if (ht[h2]==chk) return h2;
  if (ht[h0+1]<=ht[h1+1] && ht[h0+1]<=ht[h2+1])
    return memset(&ht[h0], 0, 16), ht[h0]=chk, h0;
  else if (ht[h1+1]<ht[h2+1])
    return memset(&ht[h1], 0, 16), ht[h1]=chk, h1;
  else
    return memset(&ht[h2], 0, 16), ht[h2]=chk, h2;
}
//////////////////////////// unzDecoder /////////////////////////
// unzDecoder decompresses using an arithmetic code
class unzDecoder {
public:
  unzReader* in;        // destination
  unzDecoder(unzZPAQL& z);
  int decompress();  // return a byte or EOF
  void init();       // initialize at start of block
private:
  uint32_t low, high;     // range
  uint32_t curr;          // last 4 bytes of archive
  unzPredictor pr;      // to get p
  int decode(int p); // return decoded bit (0..1) with prob. p (0..65535)
};
unzDecoder::unzDecoder(unzZPAQL& z):
    in(0), low(1), high(0xFFFFFFFF), curr(0), pr(z) {
}
void unzDecoder::init() {
  pr.init();
  if (pr.isModeled()) low=1, high=0xFFFFFFFF, curr=0;
  else low=high=curr=0;
}
// Return next bit of decoded input, which has 16 bit probability p of being 1
int unzDecoder::decode(int p) {
  assert(p>=0 && p<65536);
  assert(high>low && low>0);
  if (curr<low || curr>high) unzerror("archive corrupted");
  assert(curr>=low && curr<=high);
  uint32_t mid=low+uint32_t(((high-low)*uint64_t(uint32_t(p)))>>16);  // split range
  assert(high>mid && mid>=low);
  int y=curr<=mid;
  if (y) high=mid; else low=mid+1; // pick half
  while ((high^low)<0x1000000) { // shift out identical leading bytes
    high=high<<8|255;
    low=low<<8;
    low+=(low==0);
    int c=in->get();
    if (c<0) unzerror("unexpected end of file");
    curr=curr<<8|c;
  }
  return y;
}
// Decompress 1 byte or -1 at end of input
int unzDecoder::decompress() {
  if (pr.isModeled()) {  // n>0 components?
    if (curr==0) {  // segment initialization
      for (int i=0; i<4; ++i)
        curr=curr<<8|in->get();
    }
    if (decode(0)) {
      if (curr!=0) unzerror("decoding end of input");
      return -1;
    }
    else {
      int c=1;
      while (c<256) {  // get 8 bits
        int p=pr.predict()*2+1;
        c+=c+decode(p);
        pr.update(c&1);
      }
      return c-256;
    }
  }
  else {
    if (curr==0) {  // segment initialization
      for (int i=0; i<4; ++i)
        curr=curr<<8|in->get();
      if (curr==0) return -1;
    }
    assert(curr>0);
    --curr;
    return in->get();
  }
}
/////////////////////////// unzPostProcessor ////////////////////
class unzPostProcessor {
  int state;   // input parse state: 0=INIT, 1=PASS, 2..4=loading, 5=POST
  int hsize;   // header size
  int ph, pm;  // sizes of H and M in z
public:
  unzZPAQL z;     // holds PCOMP
  unzPostProcessor(): state(0), hsize(0), ph(0), pm(0) {}
  void init(int h, int m);  // ph, pm sizes of H and M
  int write(int c);  // Input a byte, return state
  void setOutput(unzWriter* out) {z.output=out;}
  void setSHA1(unzSHA1* sha1ptr) {z.sha1=sha1ptr;}
  int getState() const {return state;}
};
// Copy ph, pm from block header
void unzPostProcessor::init(int h, int m) {
  state=hsize=0;
  ph=h;
  pm=m;
  z.clear();
}
// (PASS=0 | PROG=1 psize[0..1] pcomp[0..psize-1]) data... EOB=-1
// Return state: 1=PASS, 2..4=loading PROG, 5=PROG loaded
int unzPostProcessor::write(int c) {
  assert(c>=-1 && c<=255);
  switch (state) {
    case 0:  // initial state
      if (c<0) unzerror("Unexpected EOS");
      state=c+1;  // 1=PASS, 2=PROG
      if (state>2) unzerror("unknown post processing type");
      if (state==1) z.clear();
      break;
    case 1:  // PASS
      if (c>=0) z.outc(c);
      break;
    case 2: // PROG
      if (c<0) unzerror("Unexpected EOS");
      hsize=c;  // low byte of size
      state=3;
      break;
    case 3:  // PROG psize[0]
      if (c<0) unzerror("Unexpected EOS");
      hsize+=c*256;  // high byte of psize
      if (hsize<1) unzerror("Empty PCOMP");
      z.header.resize(hsize+300);
      z.cend=8;
      z.hbegin=z.hend=z.cend+128;
      z.header[4]=ph;
      z.header[5]=pm;
      state=4;
      break;
    case 4:  // PROG psize[0..1] pcomp[0...]
      if (c<0) unzerror("Unexpected EOS");
      assert(z.hend<z.header.isize());
      z.header[z.hend++]=c;  // one byte of pcomp
      if (z.hend-z.hbegin==hsize) {  // last byte of pcomp?
        hsize=(z.cend-2)+z.hend-z.hbegin;
        z.header[0]=hsize&255;  // header size with empty COMP
        z.header[1]=hsize>>8;
        z.initp();
        state=5;
      }
      break;
    case 5:  // PROG ... data
      z.run(c);
      break;
  }
  return state;
}
//////////////////////// unzDecompresser ////////////////////////
// For decompression and listing archive contents
class unzDecompresser {
public:
  unzDecompresser(): z(), dec(z), pp(), state(BLOCK), decode_state(FIRSTSEG) {}
  void setInput(unzReader* in) {dec.in=in;}
  bool findBlock();
  bool findFilename(unzWriter* = 0);
  void readComment(unzWriter* = 0);
  void setOutput(unzWriter* out) {pp.setOutput(out);}
  void setSHA1(unzSHA1* sha1ptr) {pp.setSHA1(sha1ptr);}
  void decompress();  // decompress segment
  void readSegmentEnd(char* sha1string = 0);
private:
  unzZPAQL z;
  unzDecoder dec;
  unzPostProcessor pp;
  enum {BLOCK, FILENAME, COMMENT, DATA, SEGEND} state;  // expected next
  enum {FIRSTSEG, SEG} decode_state;  // which segment in block?
};
// Find the start of a block and return true if found. Set memptr
// to memory used.
bool unzDecompresser::findBlock() {
  assert(state==BLOCK);
  // Find start of block
  uint32_t h1=0x3D49B113, h2=0x29EB7F93, h3=0x2614BE13, h4=0x3828EB13;
  // Rolling hashes initialized to hash of first 13 bytes
  int c;
  while ((c=dec.in->get())!=-1) {
    h1=h1*12+c;
    h2=h2*20+c;
    h3=h3*28+c;
    h4=h4*44+c;
    if (h1==0xB16B88F1 && h2==0xFF5376F1 && h3==0x72AC5BF1 && h4==0x2F909AF1)
      break;  // hash of 16 byte string
  }
  if (c==-1) return false;
  // Read header
  if ((c=dec.in->get())!=1 && c!=2) unzerror("unsupported ZPAQ level");
  if (dec.in->get()!=1) unzerror("unsupported unzZPAQL type");
  z.read(dec.in);
  if (c==1 && z.header.isize()>6 && z.header[6]==0)
    unzerror("ZPAQ level 1 requires at least 1 component");
  state=FILENAME;
  decode_state=FIRSTSEG;
  return true;
}
// Read the start of a segment (1) or end of block code (255).
// If a segment is found, write the filename and return true, else false.
bool unzDecompresser::findFilename(unzWriter* filename) {
  assert(state==FILENAME);
  int c=dec.in->get();
  if (c==1) {  // segment found
    while (true) {
      c=dec.in->get();
      if (c==-1) unzerror("unexpected EOF");
      if (c==0) {
        state=COMMENT;
        return true;
      }
      if (filename) filename->put(c);
    }
  }
  else if (c==255) {  // end of block found
    state=BLOCK;
    return false;
  }
  else
    unzerror("missing segment or end of block");
  return false;
}
// Read the comment from the segment header
void unzDecompresser::readComment(unzWriter* comment) {
  assert(state==COMMENT);
  state=DATA;
  while (true) {
    int c=dec.in->get();
    if (c==-1) unzerror("unexpected EOF");
    if (c==0) break;
    if (comment) comment->put(c);
  }
  if (dec.in->get()!=0) unzerror("missing reserved byte");
}
// Decompress n bytes, or all if n < 0. Return false if done
void unzDecompresser::decompress() {
  assert(state==DATA);
  // Initialize models to start decompressing block
  if (decode_state==FIRSTSEG) {
    dec.init();
    assert(z.header.size()>5);
    pp.init(z.header[4], z.header[5]);
    decode_state=SEG;
  }
  // Decompress and load PCOMP into postprocessor
  while ((pp.getState()&3)!=1)
    pp.write(dec.decompress());
  // Decompress n bytes, or all if n < 0
  while (true) {
    int c=dec.decompress();
    pp.write(c);
    if (c==-1) {
      state=SEGEND;
      return;
    }
  }
}
// Read end of block. If a unzSHA1 checksum is present, write 1 and the
// 20 byte checksum into sha1string, else write 0 in first byte.
// If sha1string is 0 then discard it.
void unzDecompresser::readSegmentEnd(char* sha1string) {
  assert(state==SEGEND);
  // Read checksum
  int c=dec.in->get();
  if (c==254) {
    if (sha1string) sha1string[0]=0;  // no checksum
  }
  else if (c==253) {
    if (sha1string) sha1string[0]=1;
    for (int i=1; i<=20; ++i) {
      c=dec.in->get();
      if (sha1string) sha1string[i]=c;
    }
  }
  else
    unzerror("missing end of segment marker");
  state=FILENAME;
}
///////////////////////// Driver program ////////////////////
uint64_t unzoffset=0;  // number of bytes input prior to current block
// Handle errors
void unzerror(const char* msg) {
  myprintf("\n");
  myprintf("00424: Error at offset %1.0f: %s\n", double(unzoffset), msg);
  exit(1);
}
// Input archive
class unzInputFile: public unzReader {
  FILE* f;  // input file
  enum {BUFSIZE=4096};
  uint64_t offset;  // number of bytes read
  unsigned p, end;  // start and end of unread bytes in unzBuf
  unzAES_CTR* aes;  // to decrypt
  char unzBuf[BUFSIZE];  // input buffer
  int64_t filesize;
public:
  unzInputFile(): f(0), offset(0), p(0), end(0), aes(0),filesize(-1) {}
  void open(const char* filename, const char* key);
  // Return one input byte or -1 for EOF
  int get() {
    if (f && p>=end) {
      p=0;
	  
      end=fread(unzBuf, 1, BUFSIZE, f); // NOLINT(unix.Stream)
      if (aes) aes->encrypt(unzBuf, end, offset);
    }
    if (p>=end) return -1;
    ++offset;
    return unzBuf[p++]&255;
  }
  // Return number of bytes read
  uint64_t tell() {return offset;}
  int64_t getfilesize() {return filesize;}
  ~unzInputFile() 
  {
    close();
  }
  void close() 
  {
    if (f) {
      fclose(f);
      f = nullptr;
    }
  }
};
// Open input. Decrypt with key.
void unzInputFile::open(const char* filename, const char* key) {
  f=fopen(filename, "rb");
  if (!f) {
    perror(filename);
    return ;
  }
	fseeko(f, 0, SEEK_END);
	filesize=ftello(f);
	fseeko(f, 0, SEEK_SET);
  if (key) {
    char salt[32], stretched_key[32];
    unzSHA256 sha256;
    for (int i=0; i<32; ++i) salt[i]=get();
    if (offset!=32) unzerror("no salt");
    while (*key) sha256.put(*key++);
    stretchKey(stretched_key, sha256.result(), salt);
    aes=new unzAES_CTR(stretched_key, 32, salt);
	g_allocatedram+=sizeof(unzAES_CTR);
		
    if (!aes) unzerror("out of memory");
    aes->encrypt(unzBuf, end, 0);
  }
}
// File to extract
class unzOutputFile: public unzWriter {
  FILE* f;  // output file or NULL
  unsigned p;  // number of pending bytes to write
  enum {BUFSIZE=4096};
  char unzBuf[BUFSIZE];  // output buffer
public:
  unzOutputFile(): f(0), p(0) {}
  void open(const char* filename);
  void close();
  // write 1 byte
  void put(int c) {
    if (f) {
      unzBuf[p++]=c;
      if (p==BUFSIZE) fwrite(unzBuf, 1, p, f), p=0;
    }
  }
  virtual ~unzOutputFile() {close();}
};
// Open file unless it exists. Print error message if unsuccessful.
void unzOutputFile::open(const char* filename) {
  close();
  f=fopen(filename, "rb");
  if (f) {
    fclose(f);
    f=0;
    myprintf("00425: file exists: %s\n", filename);
  }
  f=fopen(filename, "wb");
  if (!f) perror(filename);
}
// Flush output and close file
void unzOutputFile::close() {
  if (f && p>0) fwrite(unzBuf, 1, p, f);
  if (f) fclose(f), f=0;
  p=0;
}
// Write to string
struct unzBuf: public unzWriter {
  size_t limit;  // maximum size
  std::string s;  // saved output
  unzBuf(size_t l): limit(l) {}
  // Save c in s
  void put(int c) {
    if (s.size()>=limit) unzerror("output overflow");
    s+=char(c);
  }
};
// Test if 14 digit date is valid YYYYMMDDHHMMSS format
void verify_date(uint64_t date) {
  int year=date/1000000/10000;
  int month=date/100000000%100;
  int day=date/1000000%100;
  int hour=date/10000%100;
  int min=date/100%100;
  int sec=date%100;
  if (year<1900 || year>2999 || month<1 || month>12 || day<1 || day>31
      || hour<0 || hour>59 || min<0 || min>59 || sec<0 || sec>59)
	  {
		  myprintf("\n\n");
		  myprintf("00426: date %s\n",migliaia(date));
		  myprintf("00427: year   %d\n",year);
		  myprintf("00428: month  %d\n",month);
		  myprintf("00429: day    %d\n",day);
		  myprintf("00430: hour   %d\n",hour);
		  myprintf("00431: min    %d\n",min);
		  myprintf("00432: sec    %d\n",day);
	///	unzerror("invalid date");
	  }
}
// Test if string is valid UTF8
void unzverify_utf8(const char* s) {
  while (true) {
    int c=uint8_t(*s);
    if (c==0) return;
    if ((c>=128 && c<194) || c>=245) unzerror("invalid UTF-8 first byte");
    int len=1+(c>=192)+(c>=224)+(c>=240);
    for (int i=1; i<len; ++i)
      if ((s[i]&192)!=128) unzerror("invalid UTF-8 extra byte");
    if (c==224 && uint8_t(s[1])<160) unzerror("UTF-8 3 byte long code");
    if (c==240 && uint8_t(s[1])<144) unzerror("UTF-8 4 byte long code");
    s+=len;
  }
}
// read 8 byte LSB number
uint64_t unzget8(const char* p) {
  uint64_t r=0;
  for (int i=0; i<8; ++i)
    r+=(p[i]&255ull)<<(i*8);
  return r;
}
// read 4 byte LSB number
uint32_t unzget4(const char* p) {
  uint32_t r=0;
  for (int i=0; i<4; ++i)
    r+=(p[i]&255u)<<(i*8);
  return r;
}
// file metadata
struct unzDT {		// if you get some warning here, update your compiler!
  uint64_t date;    // if you get some warning here, update your compiler!
  // unzdt YYYYMMDDHHMMSS or 0 if deleted
  uint64_t attr;  // first 8 bytes, LSB first
  std::vector<uint32_t> ptr;  // fragment IDs
  char sha1hex[FRANZOFFSETV3+1];		 // 1+32+32 (unzSHA256)+ zero
  char sha1decompressedhex[FRANZOFFSETV3+1];		 // 1+32+32 (unzSHA256)+ zero
  std::string sha1fromfile;		 // 1+32+32 (unzSHA256)+ zero
  unzDT(): date(0), attr(0),sha1fromfile("") {sha1hex[0]=0x0;sha1decompressedhex[0]=0x0;}
};
typedef std::map<std::string, unzDT> unzDTMap;
bool unzcomparesha1hex(unzDTMap::iterator i_primo, unzDTMap::iterator i_secondo)
{
	return (strcmp(i_primo->second.sha1hex,i_secondo->second.sha1hex)<0);
}
bool unzcompareprimo(unzDTMap::iterator i_primo, unzDTMap::iterator i_secondo)
{
	return (i_primo->first<i_secondo->first);
}
///////// end of patched unzpaq206.cpp
/*
	franzo section
*/

void hex2binary(const std::string& i_hexstr, char* i_bytearray,const unsigned int i_arraysize)
{
	if (i_bytearray==NULL)
	{
		myprintf("00433: GURU: i_bytearray null\n");
		seppuku();
	}
	if (i_arraysize==0)
	{
		myprintf("00434: GURU: i_arraysize zero\n");
		seppuku();
	}
    size_t length = i_hexstr.length();
    if (length==0) 
	{
    	myprintf("00435: GURU: i_hexstr empty!\n");
		seppuku();
    }
	if (length%2!=0)
	{
    	myprintf("00436: GURU: i_hexstr length not even!\n");
		seppuku();
	}
	if ((length/2)!=i_arraysize)
	{
    	myprintf("00437: GURU: length/2 %s must be i_arraysize  %s!\n",migliaia(length/2),migliaia2(i_arraysize));
		seppuku();
	
	}
    for (size_t i=0;i<length;i+=2) 
	{
        //std::string byteString=i_hexstr.substr(i,2);
		///myprintf("Lavoro da indice length-i %d\n",length-i-2);
        std::string byteString=i_hexstr.substr(length-i-2,2);
        i_bytearray[i/2]=(char)strtol(byteString.c_str(),NULL,16); // Convert the 2 characters into a byte
		///myprintf("00438: i/2 %d valore %02X\n",i/2,i_bytearray[i/2]&255);
    }
}


/// yes, I can do incomprensible code too :)
/// decode a franzoblock, discriminating on length of the block, to get crc32 and hash, and hashtype
int decode_franz_block
(const bool i_isdirectory,const char* i_franz_block,string& o_hashtype,string& o_hashvalue,string& o_crc32value,int64_t& o_creationtime, int64_t& o_accesstime,bool& o_isordered,int& o_version,franz_posix*& o_posix,
bool& o_isadded)
{
	int	risultato=-1;
	o_hashtype		="";
	o_hashvalue		="";
	o_crc32value	="";
	o_accesstime	=0;
	o_creationtime	=0;
	o_isordered		=false;
	o_version		=0;
	o_isadded		=false;

	if (i_franz_block==NULL)
	{
		if (flagdebug)
			myprintf("00439: i_franz_block null\n");
		return -1;
	}
		
	int	ricostruito	=(i_franz_block[0]-'0')*10+(i_franz_block[1]-'0');

	if ((ricostruito==FRANZO_XXHASH64B) || (ricostruito==FRANZO_MD5B)||(ricostruito==FRANZO_BLAKE3B)||(ricostruito==FRANZO_SHA_256B)
		||(ricostruito==FRANZO_SHA3B)||(ricostruito==FRANZO_XXH3B)||(ricostruito==FRANZO_SHA_1B))
	{
		o_hashtype	=decodealgoname(ricostruito);
		///myprintf("00440: o_hashtype decoded %s ricostruito %d\n",o_hashtype.c_str(),ricostruito);
		if (o_hashtype=="")
		{
			myprintf("00441: C5, cannot decode %d\n",ricostruito);
			return 0;
		}
		risultato	=ricostruito;

///64 bit
		if (ricostruito==FRANZO_XXHASH64B)
			o_hashvalue	=bin2hex_64(arraytoint64(i_franz_block+2));
		else
//128 bit
		if ((ricostruito==FRANZO_MD5B)||(ricostruito==FRANZO_XXH3B))
			o_hashvalue	=bin2hex_64(arraytoint64(i_franz_block+10))+bin2hex_64(arraytoint64(i_franz_block+2));
		else
//160 bit
		if (ricostruito==FRANZO_SHA_1B)
			o_hashvalue	=bin2hex_32(arraytoint32(i_franz_block+18))+bin2hex_64(arraytoint64(i_franz_block+10))+bin2hex_64(arraytoint64(i_franz_block+2));
		else
///256 bit
		if ((ricostruito==FRANZO_BLAKE3B)||(ricostruito==FRANZO_SHA_256B)||(ricostruito==FRANZO_SHA3B))
			o_hashvalue	=bin2hex_64(arraytoint64(i_franz_block+26))+bin2hex_64(arraytoint64(i_franz_block+18))+bin2hex_64(arraytoint64(i_franz_block+10))+bin2hex_64(arraytoint64(i_franz_block+2));
		
	
	
		if (i_isdirectory)
			o_crc32value="        ";
		else
			o_crc32value=bin2hex_32(arraytoint32(i_franz_block+34));
		
		o_creationtime	=arraytoint64(i_franz_block+38);
		o_isordered		=*(i_franz_block+46)&255;
		o_isadded		=*(i_franz_block+47)&255;
	
/*	
		
hash  |EF46DB3751D8E999|
crc32 |62D1577B|
offset 000 valore 049 31 car 1 *
offset 001 valore 052 34 car 4 *
offset 002 valore 239 EF
offset 003 valore 070 46 car F
offset 004 valore 219 DB
offset 005 valore 055 37 car 7
offset 006 valore 081 51 car Q
offset 007 valore 216 D8
offset 008 valore 233 E9
offset 009 valore 153 99
offset 010 valore 000 00
offset 011 valore 000 00
offset 012 valore 000 00
offset 013 valore 000 00
offset 014 valore 000 00
offset 015 valore 000 00
offset 016 valore 000 00
offset 017 valore 000 00
offset 018 valore 000 00
offset 019 valore 000 00
offset 020 valore 000 00
offset 021 valore 000 00
offset 022 valore 000 00
offset 023 valore 000 00
offset 024 valore 000 00
offset 025 valore 000 00
offset 026 valore 000 00
offset 027 valore 000 00
offset 028 valore 000 00
offset 029 valore 000 00
offset 030 valore 000 00
offset 031 valore 000 00
offset 032 valore 000 00
offset 033 valore 000 00

offset 034 valore 123 7B car {
offset 035 valore 087 57 car W
offset 036 valore 209 D1
offset 037 valore 098 62 car b

offset 038 valore 008 08
offset 039 valore 007 07
offset 040 valore 006 06
offset 041 valore 005 05
offset 042 valore 004 04
offset 043 valore 003 03
offset 044 valore 000 00
offset 045 valore 000 00

offset 046 valore 000 00 isordered
offset 047 valore 000 00 isadded
offset 048 valore 000 00
offset 049 valore 000 00 * 1

*/
	}
	
	if (i_franz_block[0]==0)
		if (i_franz_block[0+8]!=0)
		{
			if (i_franz_block[0+40]==0)
				o_hashtype="XXHASH64";
			o_hashvalue=i_franz_block+8;
			risultato=FRANZO_XXHASH64; //franzotype
		}
	if (i_franz_block[41]!=0)
		if (i_franz_block[41+8]==0)
		{
			if (i_isdirectory)
				o_crc32value="        ";
			else
				o_crc32value=i_franz_block+41;
		}
	if ((i_franz_block[0]=='0') && (i_franz_block[1]=='8'))
			if (i_franz_block[0+66]==0)
			{
				risultato=FRANZO_SHA_1; //franzotype
				o_hashtype="SHA-1";
				o_hashvalue=i_franz_block+2;
				if (i_isdirectory)
					o_crc32value="        ";
				else
				{
					if (i_franz_block[67]!=0)
						if (i_franz_block[67+8]==0)
							o_crc32value=i_franz_block+67;
				}
			}
	if ((i_franz_block[0]=='0') && (i_franz_block[1]=='9'))
			if (i_franz_block[0+66]==0)
			{
				risultato=FRANZO_XXH3; //franzotype
				o_hashtype="XXH3";
				o_hashvalue=i_franz_block+2;
				if (i_isdirectory)
					o_crc32value="        ";
				else
				{
					if (i_franz_block[67]!=0)
						if (i_franz_block[67+8]==0)
							o_crc32value=i_franz_block+67;
				}
			}
	if (i_franz_block[0]=='1')
		if (i_franz_block[1]=='0') // <<< 10
			if (i_franz_block[0+66]==0)
			{
				risultato=FRANZO_WINHASH64;
				o_hashtype="WINXXHASH64";
				o_hashvalue=i_franz_block+2;
				if (i_isdirectory)
					o_crc32value="        ";
				else
				{
					if (i_franz_block[67]!=0)
						if (i_franz_block[67+8]==0)
							o_crc32value=i_franz_block+67;
				}
				o_creationtime	=arraytoint64(i_franz_block+2+31+1);
///				o_accesstime	=arraytoint64(i_franz_block+2+31+1+8);
			}
	/// zpaqfranz 52, sha 256. Note: '0' is not "0" !
	if ((i_franz_block[0]=='0') && (i_franz_block[1]=='4'))
			if (i_franz_block[0+66]==0)
			{
				risultato=FRANZO_SHA_256; //franzotype
				o_hashtype="SHA-256";
				o_hashvalue=i_franz_block+2;
				if (i_isdirectory)
					o_crc32value="        ";
				else
				{
					if (i_franz_block[67]!=0)
						if (i_franz_block[67+8]==0)
							o_crc32value=i_franz_block+67;
				}
			}
	if ((i_franz_block[0]=='0') && (i_franz_block[1]=='3'))
			if (i_franz_block[0+66]==0)
			{
				risultato=FRANZO_BLAKE3; //franzotype
				o_hashtype="BLAKE3";
				o_hashvalue=i_franz_block+2;
				if (i_isdirectory)
					o_crc32value="        ";
				else
				{
					if (i_franz_block[67]!=0)
						if (i_franz_block[67+8]==0)
							o_crc32value=i_franz_block+67;
				}
			}
	if ((i_franz_block[0]=='0') && (i_franz_block[1]=='2'))
			if (i_franz_block[0+66]==0)
			{
				risultato=FRANZO_SHA3; //franzotype
				o_hashtype="SHA-3";
				o_hashvalue=i_franz_block+2;
				if (i_isdirectory)
					o_crc32value="        ";
				else
				{
					if (i_franz_block[67]!=0)
						if (i_franz_block[67+8]==0)
							o_crc32value=i_franz_block+67;
				}
			}
	if ((i_franz_block[0]=='0') && (i_franz_block[1]=='1')) // <<< 1, not 4!
			if (i_franz_block[0+66]==0)
			{
				risultato=FRANZO_MD5; //franzotype
				o_hashtype="MD5";
				o_hashvalue=i_franz_block+2;
				if (i_isdirectory)
					o_crc32value="        ";
				else
				{
					if (i_franz_block[67]!=0)
						if (i_franz_block[67+8]==0)
							o_crc32value=i_franz_block+67;
				}
			}

///	this is the FRANZOBLOCKV3 (upto 128 bytes+atime+ctime+vnumber+isordered) and the V4 (V3+posix structure)
	if ((i_franz_block[0]=='3') || (i_franz_block[0]=='4'))
	{
		bool onlyheader=(i_franz_block[0]=='3');

		if (flagdebug2)
		{
			if (onlyheader)
				myprintf("00442: decode a FRANZOFFSETV3 only header\n");
			else
				myprintf("00443: decode a FRANZOFFSETV3 with posix\n");
		}
		int expectedfranzotype=i_franz_block[1]-'A';
		MAPPATIPOHASH::iterator p=g_mappatipohash.find(expectedfranzotype);
		if (p==g_mappatipohash.end())
		{
			myprintf("00444: GURU cannot find expectedfranzotype %d\n",expectedfranzotype);
			seppuku();
			return 0;
		}
		string hashname	=p->second.hashname;
		int hashlen		=p->second.hashlen;
		if (flagdebug2)
			myprintf("00445: expectedfranzotype %d => |%-15s| len %03d\n",expectedfranzotype,hashname.c_str(),hashlen);

		risultato	=expectedfranzotype;
		o_hashtype	=hashname;
		o_hashvalue	=i_franz_block+2;

		int offsetcrc= 2+hashlen+2;
		if (i_isdirectory)
			o_crc32value="        ";
		else
			o_crc32value=i_franz_block+offsetcrc;

		o_isordered=arraytoint32(i_franz_block+offsetcrc+8+2);
		if (flagdebug2)
			myprintf("00446: Ordered stream %08d\n",o_isordered);

		o_version=arraytoint32(i_franz_block+offsetcrc+8+2+4);
		if (flagdebug2)
			myprintf("00447: Version number %08d\n",o_version);

		o_creationtime	=arraytoint64(i_franz_block+offsetcrc+8+2+4+4);
		o_accesstime	=arraytoint64(i_franz_block+offsetcrc+8+2+4+4+8);

		if (flagdebug2)
		{
			myprintf("00448: cdate %s\n",migliaia(o_creationtime));
			myprintf("00449: adate %s\n",migliaia(o_accesstime));
		}

		if (!onlyheader)
		{
			int64_t offsetposix=offsetcrc+8+2+4+4+8+(8*4); // 8*4= future expansion
			o_posix=(franz_posix*) (i_franz_block+offsetposix);
#ifndef ESX
			if (flagdebug5)
				myprintf("00450: Taking posix too @ offset position %08d o_posix value %s\n",offsetposix,migliaia(int64_t(o_posix)));
#endif
		}
	}
	///myprintf("00451: Risultato %s\n",o_crc32value.c_str());
	return risultato;
}
///https://gist.github.com/0x3f00/90edbec0c04616d0b8c21586762bf1ac
static std::string basesessantaquattro(const std::string& data)
{
    static char sEncodingTable[] = {
      'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H',
      'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P',
      'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X',
      'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f',
      'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n',
      'o', 'p', 'q', 'r', 's', 't', 'u', 'v',
      'w', 'x', 'y', 'z', '0', '1', '2', '3',
      '4', '5', '6', '7', '8', '9', '+', '/'
    };
    size_t in_len = data.size();
    if (in_len == 0)
      return "";
    size_t out_len = 4 * ((in_len + 2) / 3);
    std::string ret(out_len, '\0');
    size_t i;
    char *p = const_cast<char*>(ret.c_str());
    if (in_len == 1) {
      ret[0] = sEncodingTable[(data[0] >> 2) & 0x3F];
      ret[1] = sEncodingTable[((data[0] & 0x3) << 4)];
      ret[2] = '=';
      ret[3] = '=';
      return ret;
    }
    if (in_len == 2) {
      ret[0] = sEncodingTable[(data[0] >> 2) & 0x3F];
      ret[1] = sEncodingTable[((data[0] & 0x3) << 4) | ((int)(data[1] & 0xF0) >> 4)];
      ret[2] = sEncodingTable[((data[1] & 0xF) << 2)];
      ret[3] = '=';
      return ret;
    }
    for (i = 0; i < in_len - 2; i += 3) {
      *p++ = sEncodingTable[(data[i] >> 2) & 0x3F];
      *p++ = sEncodingTable[((data[i] & 0x3) << 4) | ((int) (data[i + 1] & 0xF0) >> 4)];
      *p++ = sEncodingTable[((data[i + 1] & 0xF) << 2) | ((int) (data[i + 2] & 0xC0) >> 6)];
      *p++ = sEncodingTable[data[i + 2] & 0x3F];
    }
    if (i < in_len) {
      *p++ = sEncodingTable[(data[i] >> 2) & 0x3F];
      if (i == (in_len - 1)) {
        *p++ = sEncodingTable[((data[i] & 0x3) << 4)];
        *p++ = '=';
      }
      else {
        *p++ = sEncodingTable[((data[i] & 0x3) << 4) | ((int) (data[i + 1] & 0xF0) >> 4)];
        *p++ = sEncodingTable[((data[i + 1] & 0xF) << 2)];
      }
      *p++ = '=';
    }
    return ret;
}
string Jidac::sanitizzanomefile(string i_filename,int i_filelength,int& io_collisioni,MAPPAFILEHASH& io_mappacollisioni)
{

	if  (i_filename=="")
		return("");
	
#ifdef _WIN32
	if (flagfixreserved)
	{
		const std::string caratteriNonValidi = "\\:*?\"<>|";
		for (char& c:i_filename) 
			if (caratteriNonValidi.find(c)!=std::string::npos) 
					c = '_';
	}
#endif // corresponds to #ifdef (#ifdef _WIN32)

	string percorso			=extractfilepath(i_filename);
	string nome				=prendinomefileebasta(i_filename);
	string estensione		=prendiestensione(i_filename);
	string senzaestensione	=percorso+nome;
	string newname;
	
	
	
	int lunghezza=FRANZMAXPATH;
	if (i_filelength>0)
		if (i_filelength<FRANZMAXPATH)
			lunghezza=i_filelength;
	lunghezza-=9; // antidupe
	if (lunghezza<10)
		lunghezza=10;
	char numero[60];
	if (flagparanoid)
	{
		// make unique and short filename
		snprintf(numero,sizeof(numero),"%08d_",++io_collisioni);
		newname=numero;
		DTMap::iterator p=dt.find(i_filename);
		string myhashtype	="";
		string myhash		="";
		string mycrc32		="";
		int64_t	myaccesstime=0;
		int64_t mycreationtime=0;
		bool	myisordered=false;
		int		myversion=0;
		franz_posix* myposix=NULL;
		bool	myisadded=false;
		if (p!=dt.end())
		{
			decode_franz_block(isdirectory(i_filename),p->second.franz_block,
			myhashtype,
			myhash,
			mycrc32,
			mycreationtime,
			myaccesstime,
			myisordered,
			myversion,
			myposix,
			myisadded);
			if (myhashtype!="")
				if (myhash!="")
				{
					p->second.hexhash=myhash;
					myhash=myhash.substr(0, 10);
					newname+="$"+myhashtype+"!"+myhash+"%";
					p->second.hashtype=myhashtype;
				}
		}
		else
			myprintf("00452: not found %s\n",i_filename.c_str());
		if (flagdebug3)
			myprintf("00453: paranoid filename <<%s>>\n",newname.c_str());
		return newname;
	}
	if (flagflat) /// desperate extract without path and filenames
	{
///		Stay safe
		string temp=purgeansi(nome.substr(0, 20));
		temp=basesessantaquattro(temp);
		snprintf(numero,sizeof(numero),"%08d_%05d_",++io_collisioni,(int)i_filename.length());
		newname=numero;
		newname.append(temp.c_str());
		/// retain extension, BUT purge Windows reserved words
		estensione=purgeansi(estensione);
		for (unsigned int j=0;j<forbiddenstringsize;j++)
			myreplaceall(estensione,stringtolower(forbiddenstring[j]),"_");
		/// and strip to 3
		if ((estensione.size())>3)
			estensione=myleft(estensione,3);
		if (estensione!="")
			newname+="."+estensione;
		if (flagdebug3)
			myprintf("00454: flatted filename <<%s>>\n",newname.c_str());
		return newname;
	}
	if (flagutf)
	{
		string prenome=nome;
// this is name, throw everything (FALSE)
		nome=purgeansi(forcelatinansi(utf8toansi(nome)),false);
		if (flagdebug3)
			if (nome!=prenome)
			{
				printbar('-');
				myprintf("00455: flagutf pre  %s\n",prenome.c_str());
				myprintf("00456: utf8toansi   %s\n",utf8toansi(nome).c_str());
				myprintf("00457: force2ansi   %s\n",forcelatinansi(utf8toansi(nome)).c_str());
				myprintf("00458: purgeansi    %s\n",nome.c_str());
			}
		if (flagfixeml)
		{
			if (estensione=="eml")
			{
				prenome=compressemlfilename(nome);
				if (nome!=prenome)
				{
					if (flagdebug3)
					{
						myprintf("00459: eml pre  %s\n",nome.c_str());
						myprintf("00460: eml post %s\n",prenome.c_str());
					}
					nome=prenome;
				}
			}
			else
			{
				for (int i=0;i<10;i++)
					myreplaceall(newname,"  "," ");
			}
		}
/// this is a path, so keep \ and / (TRUE)
		string prepercorso=percorso;
		percorso=purgeansi(forcelatinansi(utf8toansi(percorso)),true);
		if (flagdebug3)
			if (percorso!=prepercorso)
			{
				myprintf("00461: flagutf pre  perc %s\n",prepercorso.c_str());
				myprintf("00462: flagutf post perc %s\n",percorso.c_str());
			}
	}
	if (flagdebug3)
	{
		myprintf("00463: First    %03d %s\n",(int)i_filename.length(),i_filename.c_str());
		myprintf("00464: Percorso %03d %s\n",(int)percorso.length(),percorso.c_str());
		myprintf("00465: nome     %03d %s\n",(int)nome.length(),nome.c_str());
		myprintf("00466: ext      %03d %s\n",(int)estensione.length(),estensione.c_str());
		myprintf("00467: Senza ex %03d %s\n",(int)senzaestensione.length(),senzaestensione.c_str());
	}
	if (flagfix255)
	{

		int	lunghezzalibera=lunghezza-percorso.length();//%08d_
		if (lunghezzalibera<10)
		{
			if (flagdebug3)
			{
				myprintf("\n\n\n");
				myprintf("00468: Path too long: need shrink %08d %s\n",(int)percorso.length(),percorso.c_str());
				myprintf("00469: lunghezzalibera %d\n",lunghezzalibera);
			}
			vector<string> esploso;
			string temppercorso=percorso;
			size_t barra;
			while (1)
			{
				if (flagdebug3)
					myprintf("00470: temppercorso %s\n",temppercorso.c_str());
				barra=temppercorso.find('/');
				if (flagdebug3)
					myprintf("00471: Barra %ld\n",(long int)barra);
				if (barra==string::npos)
					break;
				if (flagdebug3)
					myprintf("00472: Eureka!!\n");
				esploso.push_back(temppercorso.substr(0, barra));
				temppercorso=temppercorso.substr(barra+1,temppercorso.length());
			}
			int lunghezzamassima=0;
			int indicelunghezzamassima=-1;
			for (unsigned int i=0;i<esploso.size();i++)
			{
				if ((int)esploso[i].length()>lunghezzamassima)
				{
					indicelunghezzamassima=i;
					lunghezzamassima=esploso[i].length();
				}
				if (flagdebug3)
					myprintf("00473: Esploso %d %03d %s\n",(int)i,(int)esploso[i].length(),esploso[i].c_str());
			}
			int lunghezzacheserve=lunghezza-10-(percorso.length()-lunghezzamassima);
			if (lunghezzacheserve<lunghezzamassima)
			{
				esploso[indicelunghezzamassima]=esploso[indicelunghezzamassima].substr(0,lunghezzacheserve);
				string imploso;
				for (unsigned 	int i=0;i<esploso.size();i++)
					imploso+=esploso[i]+'/';
				if (flagdebug3)
					myprintf("00474: Imploso           %d %s\n",(int)imploso.length(),imploso.c_str());
				percorso=imploso;
///				lunghezzalibera=lunghezza-percorso.length();
				makepath(percorso);
			}
			else
			{
				myprintf("00475: HOUSTON\n");
			}
		}
	}
	newname=nome;
	int lunghezzalibera=lunghezza-percorso.length();
	if (flagdebug2)
		myprintf("00476: lunghezze per %03d nome %03d tot %03d\n",(int)percorso.length(),lunghezzalibera,(int)(percorso.length()+lunghezzalibera));
	if (newname.length()>(unsigned int)lunghezzalibera)
	{
		newname=newname.substr(0,lunghezzalibera-9);
		if (flagdebug3)
			myprintf("00477: Trimmone newname %d %s\n",(int)newname.length(),newname.c_str());
	}
	newname=percorso+newname;
	if (flagdebug2)
		myprintf("00478: %d: newname %s\n",__LINE__,newname.c_str());
	std::map<string,string>::iterator collisione;
	string candidato=newname;
	if (estensione!="")
		candidato=candidato+'.'+estensione;
	// to be reworked by much faster sorted array
	if (flagfix255)	/// we are on windows, take care of case
	{
		candidato=stringtolower(candidato);
	}
	if (flagdebug2)
		myprintf("00479: candidato %s\n",candidato.c_str());
	collisione=io_mappacollisioni.find(candidato);
	if (collisione!=io_mappacollisioni.end())
	{
		if (flagdebug2)
			myprintf("00480: found  1 %s\n",candidato.c_str());
		if (collisione->second!=candidato)
		{
			if (flagdebug3)
			{
				myprintf("00481: Collisione %s\n",collisione->second.c_str());
				myprintf("00482: newname    %s\n",collisione->second.c_str());
			}
			snprintf(numero,sizeof(numero),"_%d",io_collisioni++);
			newname+=numero;
			if (flagdebug2)
				myprintf("00483: postname   %s\n\n\n\n\n",newname.c_str());
		}
	}
	io_mappacollisioni.insert(std::pair<string, string>(candidato,i_filename));
	if (estensione!="")
		newname+="."+estensione;
	if (flagdebug3)
		myprintf("00484: Finalized %d %s\n",(int)newname.length(),newname.c_str());
	if (flagdebug3)
		if (newname.length()>255)
		{
			myprintf("00485: WARN pre  %08d   %s\n",(int)i_filename.length(),i_filename.c_str());
			myprintf("00486: WARN post %08d   %s\n",(int)newname.length(),newname.c_str());
			myprintf("\n");
		}
	return newname;
}
/*
	section: progress
*/
// beware STATIC not good for M/T
void print_progress(int64_t ts, int64_t td, int64_t i_scritti, int i_percentuale) 
{
    static int64_t ultimi_secondi = 0;
    static int ultima_percentuale = 0;
    
    // Parameter validation
    if (td > ts) 
		td = ts;
    if (td < 1000000) 
		return;
    
    // Time calculation
    int64_t tempo_trascorso 	= mtime() - g_start;
    int secondi 				= tempo_trascorso / 1000;
    if (secondi == 0) 
		secondi = 1;
    
    // ETA calculation (estimated remaining time)
    double eta = 0.001 * tempo_trascorso * (ts - td) / (td + 1.0);
    if (eta >= 350000) 
		return; // Reasonable limit per ETA (circa 4 giorni)
    
    int percentuale = (int)(td * 100.0 / (ts + 0.5));
    
    if (flagpakka) 
	{
        // Every 10%
        bool aggiorna = ((percentuale % 10) == 0);/// || (percentuale == 1);
        bool percentuale_cambiata = (percentuale != ultima_percentuale) || (percentuale == 1);
        
        if (aggiorna && percentuale_cambiata && !flagnoeta) 
		{
            ultima_percentuale = percentuale;
            myprintf("%03d%% %02d:%02d:%02d %20s of %20s %10s/s\r", 
						percentuale,
						(int)(eta / 3600), 
						(int)(eta / 60) % 60, 
						(int)eta % 60,
						migliaia(td), 
						migliaia2(ts), 
						tohuman(td / secondi));
        }
    } 
	else 
	{
        // Detailed mode - update every second
        if (secondi != ultimi_secondi) 
		{
            ultimi_secondi = secondi;
            
            // Projection calculation
            int64_t projection = ts;
            if ((command == 'a' || command == 'Z') && (ts > 0)) 
			    projection = (int64_t)(i_scritti / (1.0 * td / ts));
            
            // Time format: HH:MM:SS
            int ore 			= (int)(eta / 3600);
            int minuti 			= (int)(eta / 60) % 60;
            int sec 			= (int)eta % 60;
            double perc_precisa = td * 100.0 / (ts + 0.5);
            
            // Determine output and format
            bool usa_stderr 	= flagwriteonconsole;
            bool stampa 		= (usa_stderr) || (!flagnoeta);
            
            if (stampa) 
			{
                const char* formato;
                
                if (i_percentuale > 0) 
				{
                    // Con percentuale esterna
                    formato = "(%03d%%) %6.2f%% %02d:%02d:%02d  (%10s)->(%10s)=>(%10s) %10s/s\r";
                    
                    if (usa_stderr) 
                        fprintf(stderr, formato, i_percentuale, perc_precisa, ore, minuti, sec,
                               tohuman(td), tohuman2(i_scritti), tohuman3(projection), tohuman4(td/secondi));
					else 
                        myprintf(formato, i_percentuale, perc_precisa, ore, minuti, sec,
                                tohuman(td), tohuman2(i_scritti), tohuman3(projection), tohuman4(td/secondi));
                } 
				else 
				if (i_scritti > 0) 
				{
                    // Without external percentage, but with data written
                    formato = "       %6.2f%% %02d:%02d:%02d  (%10s)->(%10s)=>(%10s) %10s/s\r";
                    
                    if (usa_stderr) 
					    fprintf(stderr, formato, perc_precisa, ore, minuti, sec,
                               tohuman(td), tohuman2(i_scritti), tohuman3(projection), tohuman4(td/secondi));
                    else
                        myprintf(formato, perc_precisa, ore, minuti, sec,
                                tohuman(td), tohuman2(i_scritti), tohuman3(projection), tohuman4(td/secondi));
                } 
				else 
				{
                    // Only base data
                    formato = "       %6.2f%% %02d:%02d:%02d  (%10s)=>(%10s) %10s/s         \r";
                    
                    if (usa_stderr) 
					    fprintf(stderr, formato, perc_precisa, ore, minuti, sec,
                               tohuman(td), tohuman2(projection), tohuman3(td/secondi));
                    else 
					    myprintf(formato, perc_precisa, ore, minuti, sec,
                                tohuman(td), tohuman2(projection), tohuman3(td/secondi));
                }
            }
        }
    }
}

/// work with a batch job
void avanzamento(int64_t i_lavorati,int64_t i_totali,int64_t i_inizio)
{
	static int ultimapercentuale=0;
	if (flagnoeta==true)
		return;
	int percentuale=int(i_lavorati*100.0/(i_totali+0.5));
	if (percentuale>0)
		if (((percentuale%10)==0)  || (percentuale==1))
	//if ((((percentuale%10)==0) && (percentuale>0)) || (percentuale==1))
	if (percentuale!=ultimapercentuale)
	{
		ultimapercentuale=percentuale;
		double eta=0.001*(mtime()-i_inizio)*(i_totali-i_lavorati)/(i_lavorati+1.0);
		int secondi=(mtime()-i_inizio)/1000;
		if (secondi==0)
			secondi=1;
		if (eta<356000)
			myprintf("%03d%% %02d:%02d:%02d (%10s) of (%10s) %20s /s\n", percentuale,
			int(eta/3600), int(eta/60)%60, int(eta)%60, tohuman(i_lavorati), tohuman2(i_totali),migliaia3(i_lavorati/secondi));
		fflush(stdout);
	}
}
bool myavanzamento(int64_t i_lavorati,int64_t i_totali,int64_t i_inizio,bool i_barran=true)
{
	bool	hostampato=false;
	static int ultimapercentuale=0;
	int percentuale=int(i_lavorati*100.0/(i_totali+0.5));
	if (percentuale>100)
		percentuale=100;
	if (((percentuale%5)==0) && (percentuale>0))
		if (percentuale!=ultimapercentuale)
		{
			ultimapercentuale=percentuale;
			double eta=0.001*(mtime()-i_inizio)*(i_totali-i_lavorati)/(i_lavorati+1.0);
			int secondi=(mtime()-i_inizio)/1000;
			if (secondi==0)
				secondi=1;
			if (eta<356000)
			{
				myprintf("%03d%% %02d:%02d:%02d (%10s) of (%10s) %20s/s", percentuale,
			int(eta/3600), int(eta/60)%60, int(eta)%60, tohuman(i_lavorati), tohuman2(i_totali),migliaia3(i_lavorati/secondi));
				if (i_barran)
					myprintf("\n");
				else
					myprintf("\r");
				hostampato=true;
			}
			fflush(stdout);
		}
	return hostampato;
}
/// sorting functions
// Return p<q for sorting files by decreasing size, then fragment ID list
bool compareFragmentList(DTMap::const_iterator p, DTMap::const_iterator q) {
  if (p->second.size!=q->second.size) return p->second.size>q->second.size;
  if (p->second.ptr<q->second.ptr) return true;
  if (q->second.ptr<p->second.ptr) return false;
  if (p->second.data!=q->second.data) return p->second.data<q->second.data;
  return p->first<q->first;
}
// Sort by sortkey, then by full path
bool compareFilename(DTMap::iterator ap, DTMap::iterator bp)
{
  if (ap->second.data!=bp->second.data)
    return ap->second.data<bp->second.data;
  return ap->first<bp->first;
}
bool comparedatethenfilename(DTMap::iterator ap, DTMap::iterator bp)
{
	if (ap->second.date!=bp->second.date)
		return ap->second.date<bp->second.date;
	return ap->first<bp->first;
}

bool compareredallavgthenfilename(DTMap::iterator ap, DTMap::iterator bp)
{
	if (ap->second.red_avg!=bp->second.red_avg)
		return ap->second.red_avg<bp->second.red_avg;
	return ap->first<bp->first;
}

bool compareorderby(DTMap::iterator a, DTMap::iterator b) 
{
    // If orderby is empty, it doesn't sort
    if (orderby.empty()) 
        return false;

    // Populate g_theorderby only once if necessary
    if (g_theorderby.empty()) 
    {
        g_theorderby.clear();
        std::string temp_orderby = orderby;
        if (!temp_orderby.empty() && temp_orderby[temp_orderby.length() - 1] != ';') 
            temp_orderby += ';';
        explode(temp_orderby, ';', g_theorderby);
    }

    // Compare fields based on criteria in g_theorderby with explicit loop
    for (size_t i = 0; i < g_theorderby.size(); ++i) 
    {
        const std::string& criterio = g_theorderby[i];
        if (criterio.empty()) 
            continue;

        // Comparison for each criterion
        if (criterio == "ext") 
        {
            std::string a_ext = prendiestensione(a->first);
            std::string b_ext = prendiestensione(b->first);
            if (a_ext != b_ext) 
                return flagdesc ? (a_ext > b_ext) : (a_ext < b_ext);
        }
        else if (criterio == "name") 
        {
            std::string a_name = prendinomefileebasta(a->first);
            std::string b_name = prendinomefileebasta(b->first);
            if (a_name != b_name) 
                return flagdesc ? (a_name > b_name) : (a_name < b_name);
        }
        else if ((criterio == "full") || (criterio == "fullname"))
        {
            if (a->first != b->first) 
                return flagdesc ? (a->first > b->first) : (a->first < b->first);
        }
        else if (criterio == "hash") ///nonva
        {
            if (a->second.hexhash != b->second.hexhash) 
                return flagdesc ? (a->second.hexhash > b->second.hexhash) : (a->second.hexhash < b->second.hexhash);
        }
        else if (criterio == "size") 
        {
            if (a->second.size != b->second.size) 
                return flagdesc ? (a->second.size > b->second.size) : (a->second.size < b->second.size);
        }
        else if (criterio == "attr") 
        {
            if (a->second.attr != b->second.attr) 
                return flagdesc ? (a->second.attr > b->second.attr) : (a->second.attr < b->second.attr);
        }
        else if (criterio == "date") 
        {
            if (a->second.date != b->second.date)
                return flagdesc ? (a->second.date > b->second.date) : (a->second.date < b->second.date);
        }
        else if (criterio == "creation") 
        {
            if (a->second.creationdate != b->second.creationdate)
                return flagdesc ? (a->second.creationdate > b->second.creationdate) : (a->second.creationdate < b->second.creationdate);
        }
        else if (criterio == "access") 
        {
            if (a->second.accessdate != b->second.accessdate)
                return flagdesc ? (a->second.accessdate > b->second.accessdate) : (a->second.accessdate < b->second.accessdate);
        }
        else if (criterio == "data") 
        {
            if (a->second.data != b->second.data) 
                return flagdesc ? (a->second.data > b->second.data) : (a->second.data < b->second.data);
        }
    }

    // Tie-breaking criterion: full file name
    return flagdesc ? (a->first > b->first) : (a->first < b->first);
}
/*
	Section: help
*/


void help_range()
{
	scrivi_riga("-range X:Y", "Range versions [X-Y]");
	scrivi_riga("-range X:", "Range versions [X-THE LAST]");
	scrivi_riga("-range :X", "Range versions [1-X]");
	scrivi_riga("-range X", "Range is single version X");
	scrivi_riga("-range ::X", "Last X versions");
	scrivi_riga("-utf", "Remove non-utf8 chars");
	scrivi_riga("-utf", "Remove non-utf8 chars");
}

void help_date()
{
	scrivi_riga("-datefrom X","datetime<=X The length must be even, beware of leading zeros");
	scrivi_riga("-dateto   Y","datetime>=Y OK 2022, 202210, 2022-12-25, 2002-12-25_03:04:05, 20121225030405");
}
void help_size()
{
    scrivi_riga("-maxsize X","Filter on filesize. Use K, M, G, T and KB,MB,GB,TB");
    scrivi_riga("-minsize Y","ex. 3000000, 3.000.000, 3000K, 3.2KB, 3M, 3MB, 2G, 3GB, 2TB, 3T");
}
void help_orderby()
{
	scrivi_riga("-orderby x","Sort files by (one or more of) ext;name;full;fullname;hash;size;");
	scrivi_riga("","attr;date;creation;access;");
	scrivi_riga("-desc","Descending sort (if -orderby)");
}
void help_printhash(bool i_flagadd)
{
	char linea[200];
	for (MAPPATIPOHASH::iterator p=g_mappatipohash.begin(); p!=g_mappatipohash.end(); ++p)
		if (p->second.flagiszpaq)
		{
			snprintf(linea,sizeof(linea),"%s",p->second.hashdescription.c_str());
			scrivi_riga(p->second.switchname.c_str(),linea);
		}
	if (!i_flagadd)
	{
		for (MAPPATIPOHASH::iterator p=g_mappatipohash.begin(); p!=g_mappatipohash.end(); ++p)
			if (!p->second.flagiszpaq)
			{
				snprintf(linea,sizeof(linea),"%s",p->second.hashdescription.c_str());
				scrivi_riga(p->second.switchname.c_str(),linea);
			}
	}
}
/*
void help_printhashline(bool i_flagadd)
{

	string	risultato;
	for (MAPPATIPOHASH::iterator p=g_mappatipohash.begin(); p!=g_mappatipohash.end(); ++p)
		if (p->second.flagiszpaq)
			scrivi_riga(p->second.switchname.c_str(),"");

	if (!i_flagadd)
	{
		risultato="";
		for (MAPPATIPOHASH::iterator p=g_mappatipohash.begin(); p!=g_mappatipohash.end(); ++p)
			if (!p->second.flagiszpaq)
				scrivi_riga(p->second.switchname.c_str(),"");
	}
}
*/
string help_b(bool i_usage,bool i_example)
{
	if (i_usage)
	{
		scrivi_riga("CMD b","Bbenchmark and CPU stresser");
		scrivi_riga(" ","Rough benchmarking of hash-checksum");
		scrivi_riga(" ","franzomips (fake index) showed if no switch selected");
		scrivi_riga(" ","By default test ALL for 5 seconds with 400.000 bytes");
		scrivi_riga(" ","NOTE: This reflects maximum theoretical performance,");
		scrivi_riga(" ","not real-world speeds");
		scrivi_riga("-debug", "Do internal check (for non-Intel CPU)");
		scrivi_riga("-verbose", "Verbose output");
		scrivi_riga("-n X","Set time limit to X s (<1000)");
		scrivi_riga("-minsize Y","Run on chunks of Y bytes (<2000000000)");
		help_printhash(false);
		scrivi_riga("-all", "Multithread run (CPU cooker)");
		scrivi_riga("-tX", "With -all limit to X threads");
	}
	if (i_usage && i_example) scrivi_examples();
	if (i_example)
	{              
		scrivi_esempio("Benchmark all","b");
		scrivi_esempio("Benchmark all on 1.86GB","b -minsize 2000000000");
		scrivi_esempio("Benchmark all on 1MB","b -minsize 1048576");
		scrivi_esempio("Benchmark SHA256 and BLAKE3","b -sha256 -blake 3 -minsize 1048576");
		scrivi_esempio("Benchmark for 10 second each","b -n 10 -sha256 -blake3 -minsize 1048576");
		scrivi_esempio("CPU stress test (heats the CPU)","b -all -n 10000");
		scrivi_esempio("Cook the CPU (all cores)","b -all -n 20 -blake3");
		scrivi_esempio("Cook the CPU (8 cores)","b -all -t8 -n 20 -blake3");
	}
	return "CPU benchmark, speed in franzomips (!)";
}

string help_autotest(bool i_usage,bool i_example)
{
	if (i_usage)
	{
		scrivi_riga("CMD autotest","Operational self-test on this system");
		scrivi_riga("-all", "Heavy test (all hashes)");
		scrivi_riga("-n X","On heavy test (-all) use X size (min: 200.000,default 1.000.000)");
		scrivi_riga("-n X","On light test (not -all) use X ASCII chars");
		scrivi_riga("-verbose", "Verbose output");
		scrivi_riga("-to d0","Create (into folder d0) a dotest.sh/bat script)");
		scrivi_riga("-checktxt X","Test outYY.txt files inside X folder");
	}
	if (i_usage && i_example) scrivi_examples();
	if (i_example)
	{
		scrivi_esempio("Hashing internal test 'ABCD'","autotest");
		scrivi_esempio("Hashing internal test 'ABCDEFGHIJ'","autotest -n 10");
		scrivi_esempio("Hashing internal test","autotest -all");
#if defined(HWSHA1) || defined(HWSHA2)
		scrivi_esempio("Hashing internal test","autotest -hw");
#endif // corresponds to #if (#if defined(HWSHA1) || defined(HWSHA2))
		scrivi_esempio("Prepare a z:\\pippo\\dotest.bat","autotest -all -verbose -to z:\\pippo");
		scrivi_esempio("Check output results","autotest -checktxt z:\\ugo");
	}
	return "Check hidden errors post-build";

}
#ifdef ZPAQFULL ///NOSFTPSTART
string help_isopen(bool i_usage,bool i_example)
{
	if (i_usage)
	{
		scrivi_riga("CMD isopen()","Check if a file is open (and execute some kind of script)");
	}
	if (i_usage && i_example) scrivi_examples();
	if (i_example)
	{
		scrivi_esempio("Check some thunderbird running","isopen c:\\pippo\\INBOX -exec_ok killthunderbird.bat");
	}
	return("Detect locked file(s) (by other software)");

}
#endif ///NOSFTPEND
string help_versum(bool i_usage,bool i_example)
{
	if (i_usage)
	{
		scrivi_riga("CMD versum","hashdeep-like double check");
		scrivi_riga(" ","Double-check for 'remote' restore (ex. Unix => Win)");
		scrivi_riga(" ","Heterogeneous restore can be tricky");

		scrivi_riga("-ssd", "Multithread (for SSDs, do NOT use on spinning drives)");
		scrivi_riga("-find", "Change the source (original) to the destination (extracted)");
		scrivi_riga("-replace", "folder (if different)");
		scrivi_riga("-to", "file.zpaq Test against hashes stored in .zpaq (MUST match algo type!)");
		scrivi_riga(" ","aka: do NOT compare sha3 hashes with xxhash64 or something !=");
		scrivi_riga("-hashdeep", "Use hashdeep format for the input file (DEFAULT: zpaqfranz)");
		scrivi_riga("-checktxt", "Test against .md5 / _md5.txt file (w/wildcards)");
		scrivi_riga("-fasttxt", "Test against _crc32.txt file (w/wildcards)");
		scrivi_riga("-fasttxt -quick","Test QUICK against _crc32.txt file (w/wildcards)");
	}
	if (i_usage && i_example) scrivi_examples();
	if (i_example)
	{
#ifdef ZPAQFULL ///NOSFTPSTART
		color_yellow();
		moreprint("Educational purpose zfs-based backup of tank/d with various test on Win (-ssd for multithread)");
		color_restore();
		///moreprint("Destroy the snapshot fc (if any)     zfs destroy  tank/d@fc");
		scrivi_esempio("Take the snapshot fc of tank/d","zfs snapshot tank/d@fc");
		scrivi_esempio("Get the hash list with xxhash64","sum /tank/d/.zfs/snapshot/fc -forcezfs -ssd -xxhash -noeta -silent -out /tmp/hash_xx64.txt");
		scrivi_esempio("Create hashdeep.txt w/md5","hashdeep -c md5 -r /tank/d/.zfs/snapshot/fc >/tmp/hashdeep.txt");
		scrivi_esempio("Make the backup (fixing path w/-to)","a /tmp/thebak.zpaq /tank/d/.zfs/snapshot/fc /tmp/hash_xx64.txt /tmp/hashdeep.txt -to /tank/d");
		scrivi_esempio("Destroy the snapshot","zfs destroy tank/d@fc");
		moreprint("!- Transfer somehow thebak.zpaq to Win (usually with rsync)");
		moreprint("!- Full-scale test (aka:using filesystem), with extraction-restore");
		scrivi_esempio("Extract in z:\\uno (-longpath)","x thebak.zpaq -to z:\\uno -longpath");
		scrivi_esempio("Verify files by hash list","versum z:\\uno\\_tmp\\hash_xx64.txt -ssd -find /tank/d/.zfs/snapshot/fc -replace z:\\uno\\_tank\\d");
		scrivi_esempio("Paranoid double-check with hashdeep","versum z:\\uno\\_tmp\\hashdeep.txt -hashdeep -ssd -find /tank/d/.zfs/snapshot/fc -replace z:\\uno\\_tank\\d");
		moreprint("!- Small-scale test, without reading from filesystem");
		scrivi_esempio("Compare the md5 with the .zpaq","versum \"*.zpaq\" -checktxt");
		scrivi_esempio("Compare the crc32 with the .zpaq","versum \"*.zpaq\" -fasttxt");
		scrivi_esempio("Compare the quick with the .zpaq","versum \"*.zpaq\" -fasttxt -quick");
		scrivi_esempio("Automagically compare  .zpaq","versum \"*.zpaq\"");
#endif ///NOSFTPEND
	}
	return("Double-check hashes (hashdeep-like)");
}
///zpaqfranz backup z:\prova_????.zpaq c:\zpaqfranz


string help_backup(bool i_usage,bool i_example)
{
	if (i_usage)
	{
		
		scrivi_riga("CMD backup","Multipart-managed backup: keeps part size/hash/quickhash");
		scrivi_riga(" ","Hardening backups in 'pieces' (ex. rsync, robocopy etc)");
		scrivi_riga(" ","Use command testbackup to check missing or invalid 'pieces'");
		scrivi_riga("-backupxxh3", "Store XXH3 instead of default MD5");
		scrivi_riga("-backupzeta", "Store ZETA instead of default MD5 [UNENCRYPTED]");
		scrivi_riga("-index X","Store index (and .pid) files in X folder (for WORM drive)");
		scrivi_riga("-tmp", ".tmp instead of .zpaq for running multipart");
		scrivi_riga("-notrim", "DISABLE autotrim (if possible) of incomplete transaction");

	}
	if (i_usage && i_example) scrivi_examples();
	if (i_example)
	{
		scrivi_esempio("Use the same parameters as add","backup z:\\prova.zpaq *.txt -key pippo");
		scrivi_esempio("Store XXH3 (instead of MD5)","backup z:\\prova.zpaq *.txt -backupxxh3");
		scrivi_esempio("Write index in c:\\temp","backup z:\\prova.zpaq c:\\nz -index c:\\temp");
		scrivi_esempio("Store ZETA (instead of MD5)","backup z:\\prova.zpaq *.txt -backupzeta");
		scrivi_esempio("Rename to .zpaq after completing","backup z:\\prova.zpaq *.txt -tmp");
	}
	return("Create hardened multipart backup");
}
string help_testbackup(bool i_usage,bool i_example)
{
	if (i_usage)
	{

		scrivi_riga("CMD testbackup","Check multipart-managed backup");
		scrivi_riga("-to", "something Path to .zpaq chunks (if different)");
		scrivi_riga("-verify", "Read from filesystem and recompute hashes");
		scrivi_riga("-ssd", "Multithread (for SSDs, do NOT use on spinning drives)");
		scrivi_riga("-paranoid", "Compare index vs chunks (require password if encrypted)");
		scrivi_riga("-verbose", "Show more things");
		scrivi_riga("-find", "Change something in filenames");
		scrivi_riga("-replace", "for 'dirty' tricks");
		scrivi_riga("-checktxt f1","Load md5sum-like textfile to compare against index");
		help_range();
		scrivi_riga("-index X","Get index (and .pid) files in X folder (for WORM drive)");
	}
	if (i_usage && i_example) scrivi_examples();
	if (i_example)
	{
		scrivi_esempio("Quick check local backup","testbackup foo.zpaq");
		scrivi_esempio("Multipart in different path","testbackup foo.zpaq -to \\\\franzk\\z\\ -ssd");
		scrivi_esempio("Different path, MD5 full test","testbackup foo.zpaq -to \\\\franzk\\z\\ -verify");
		scrivi_esempio("With multithread (on solid drives)","testbackup foo.zpaq -to \\\\franzk\\z\\ -verify -ssd");
		scrivi_esempio("Check from chunk 10 until last","testbackup foo.zpaq -range 10: -verify");
		scrivi_esempio("Test index with password (if any)","testbackup foo.zpaq -paranoid -key pippo");
		scrivi_esempio("Compare md5 hashes","testbackup foo.zpaq -checktxt z:\\md5.txt");
		scrivi_esempio("Test with index in c:\\temp","testbackup z:\\prova.zpaq -index c:\\temp -paranoid");
	}
	return("Verify hardened multipart backup");
}
string help_work(bool i_usage,bool i_example)
{
	if (i_usage)
	{
		scrivi_riga("CMD work","Execute multiple commands (verb-noun format)");
		scrivi_riga("Available nouns:","");
        scrivi_riga("big               ","Outputs a large ASCII string from input text");
        scrivi_riga("pad               ","Left-pads a number with zeros");
        scrivi_riga("filepathnotrailing","Returns a file path without trailing backslash");
        scrivi_riga("date              ","Displays current date or datetime");
        scrivi_riga("printbar          ","Prints a row of repeated characters");
        scrivi_riga("turbo             ","Sets CPU power to maximum (enables Turbo Boost)");
        scrivi_riga("noturbo           ","Reduces CPU speed (limits Turbo Boost)");
        scrivi_riga("monitoroff        ","Turns off the monitor");
        scrivi_riga("monitoron         ","Turns on the monitor");
        scrivi_riga("shutdown          ","(Try to) shutdown");
#ifdef _WIN32
		scrivi_riga("resetacl","Revert Windows' ACL to administrators");
#endif	
        scrivi_riga("devart         ","Outputs a large ASCII string from input text");
		scrivi_riga("devart-red     ","Outputs a red    large ASCII string from input text");
		scrivi_riga("devart-green   ","Outputs a green  large ASCII string from input text");
		scrivi_riga("devart-yellow  ","Outputs a yellow large ASCII string from input text");
		scrivi_riga("devart-cyan    ","Outputs a cyan   large ASCII string from input text");
		scrivi_riga("last X","Show last file in X");
        scrivi_riga("lastfile X","Show last file in X (only filename)");
		scrivi_riga("getsize X","Show size of X (multiple / wildcard allowed)");
		scrivi_riga("checkspace","Check if enough free space");
#ifdef ZPAQFULL ///NOSFTPSTART
		scrivi_riga("encode f1 f2 pass",	"FRANZEN encrypt. Use -ssd for multithread (limit with -tX)");
		scrivi_riga("decode f1 f2 pass",	"FRANZEN decrypt. Use -ssd for multithread (limit with -tX)");
		scrivi_riga("test   f1 pass",		"FRANZEN test.    Use -ssd for multithread (limit with -tX)");
		scrivi_riga("fulltest f1 f2 pass",	"FRANZEN full test. Encrypt, decrypt, compare");
		scrivi_riga("autotest",   			"FRANZEN (quick) autotest");
		scrivi_riga("crc32",   				"FRANZEN CRC32 check");
		scrivi_riga("ispasswordok",   		"FRANZEN quickly check password");
		
#endif ///NOSFTPEND
		
	}
	if (i_usage && i_example) scrivi_examples();
	if (i_example)
	{
		scrivi_esempio("Write a large ASCII string","work big \"count the ok\"");
        scrivi_esempio("Write in uppercase ASCII  ","work big \"COUNT THE OK\"");
        scrivi_esempio("Write a custom big string ","work big \"forza inter\"");
        scrivi_esempio("Pad number to 8 digits","work pad 123");
        scrivi_esempio("Pad number to 4 digits","work pad 123 -n 4");
        scrivi_esempio("Remove trailing backslash","work filepathnotrailing \"z:\\doc\\2\\3.eml\"");
        scrivi_esempio("Show concise datetime","work date -terse");
        scrivi_esempio("Format date as year_month_day","work date \"%year_%month_%day\" -terse");
        scrivi_esempio("Print a line of dashes","work printbar -terse");
        scrivi_esempio("Print a line of exclamation marks","work printbar \"!\" -terse");
        scrivi_esempio("Reduce CPU speed (and power usage)","work noturbo");
        scrivi_esempio("Turn off monitor","work monitoroff");
        scrivi_esempio("Shutdown","work shutdown");
#ifdef _WIN32
        scrivi_esempio("Fix 'strange' ACLs","work resetacl z:\\temp");
#endif	
        scrivi_esempio("Devart","work devart ALL-OK");
        scrivi_esempio("Last file name","work lastfile z:\\temp\\copia*.zpaq -terse");
        scrivi_esempio("Scary text","work devart-red ERROR! -terse");
        scrivi_esempio("Show filesize","work getsize zpaqfranz*.cpp /tmp/prova");
        scrivi_esempio("Check free space","work checkspace c:\\ 10g d:\\ 20g -exec_error nospace.bat");
#ifdef ZPAQFULL ///NOSFTPSTART
        scrivi_esempio("Encrypt (experimental)","work encode j:\\1.zpaq z:\\crip.cha pippo -ssd");
        scrivi_esempio("Test FRANZEN file","work test z:\\crip.cha pippo -ssd");
	    scrivi_esempio("Encrypt fulltest","work fulltest j:\\1.zpaq z:\\testme pippo -ssd");
		scrivi_esempio("FRANZEN autotest","work autotest");
		scrivi_esempio("FRANZEN crc32","work crc32 z:\\1.zpaq");
		scrivi_esempio("FRANZEN password","work ispasswordok z:\\1.zpaq pippo");
#endif ///NOSFTPEND
		
	}
	return("Run multiple commands");
}
#ifdef ZPAQFULL ///NOSFTPSTART
#ifdef SFTP
string help_sftp(bool i_usage,bool i_example)
{
	if (i_usage)
	{
		scrivi_riga("CMD sftp","Multiple commands (verb-noun) for SFTP servers");
		scrivi_riga("noun  upload","Upload a single file to SFTP");
		scrivi_riga("noun  verify","Quick compare local to remote file");
		scrivi_riga("noun  quick ","Get the QUICK hash of a remote file");
		scrivi_riga("noun  ls    ","List remote folder");
		scrivi_riga("noun  delete","Delete remote file");
		scrivi_riga("noun  size  ","Get size of remote file");
		scrivi_riga("noun  rsync ","Rsync-like local files to remote folder (-ssd)");
		scrivi_riga(" ","   -force: do NOT append");
		scrivi_riga("noun  1on1  ","Quick compare local files to remote folder (-ssd)");
		scrivi_riga("noun  mkdir ","Create a remote folder");
		scrivi_riga("-host", "A  IPV4 hostname (ex. pippo.ciao.com)");
		scrivi_riga("-user", "B  SFTP username (ex. thesftpuser)");
		scrivi_riga("-password", "C  SFTP password (ex. thehardpwd)");
		scrivi_riga("-port", "D  SFTP port     (ex. 22)");
		scrivi_riga("-ssh", "E  SSH key       (ex. thekey)");
		scrivi_riga("-bandwidth", "F  Limit global speed");
		
	}
	if (i_usage && i_example) scrivi_examples();
	if (i_example)
	{
		scrivi_esempio("Upload a file","sftp upload j:\\1.zpaq /tmp/bak         -host 1.2.3.4 -user k1 -password pippo -port 23");
		scrivi_esempio("Verify a file","sftp verify j:\\1.zpaq /tmp/bak/1.zpaq  -host 1.2.3.4 -user k1 -password pippo -port 23");
		scrivi_esempio("ls","sftp ls     /tmp                       -host 1.2.3.4 -user k1 -password pippo -port 23");
		scrivi_esempio("Delete a file","sftp delete /tmp/bak/1.zpaq            -host 1.2.3.4 -user k1 -password pippo -port 23");
		scrivi_esempio("Get size","sftp size   /tmp/bak/1.zpaq            -host 1.2.3.4 -user k1 -password pippo -port 23");
		scrivi_esempio("Get remote hash","sftp quick  /tmp/bak/1.zpaq            -host 1.2.3.4 -user k1 -password pippo -port 23");
		scrivi_esempio("Multithread","sftp quick  /tmp/remotefolder     -ssd -host 1.2.3.4 -user k1 -password pippo -port 23");
		scrivi_esempio("Rsync","sftp rsync  d:\\test* /home/fra    -ssd -host 1.2.3.4 -user k1 -password pippo -port 23");
		scrivi_esempio("1on1","sftp 1on1   d:\\test* /home/fra    -ssd -host 1.2.3.4 -user k1 -password pippo -port 23");
		scrivi_esempio("Rsync w/limit","sftp rsync  d:\\test* /home/fra    -ssd -host 1.2.3.4 -user k1 -password pippo -bandwidth 5m");
		scrivi_esempio("ls","sftp ls     /tmp                       -host 1.2.3.4 -user k1 -ssh theopensshkey.key ");
		scrivi_esempio("Mkdir","sftp mkdirl /home/franco/pippo         -host 1.2.3.4 -user k1 -ssh theopensshkey.key ");
	}
	return("SFTP interface");
}
string help_ssh(bool i_usage,bool i_example)
{
	if (i_usage)
	{
		scrivi_riga("CMD ssh","Multiple commands (verb-noun) for SSH servers");
		scrivi_riga("libssh required","Win64 auto-downloads DLLs to zpaqfranz folder");
#ifdef _WIN64		
		scrivi_riga("noun  md5sum","Compare local folder to remote, with md5");
		scrivi_riga("noun  sha1sum","Compare local folder to remote, with sha1");
		scrivi_riga("noun  sha256sum","Compare local folder to remote, with sha256");
#endif
		scrivi_riga("-host", "A  IPV4 hostname (ex. pippo.ciao.com)");
		scrivi_riga("-user", "B  SSH username (ex. thesftpuser)");
		scrivi_riga("-password", "C  SSH password (ex. thehardpwd)");
		scrivi_riga("-port", "D  SSH port     (ex. 22)");
		scrivi_riga("-ssh", "E  SSH key       (ex. thekey)");
	}
	if (i_usage && i_example) scrivi_examples();
	if (i_example)
	{
		scrivi_esempio("Compare with sha1","ssh sha1sum d:\\bak -remote /pip -host 1.2.3.4 -user k1 -password pippo");
	}
	return("SSH interface");
}

string help_cloud(bool i_usage,bool i_example)
{
	if (i_usage)
	{
		color_green();
		moreprint("CMD   cloud              zpaqfranz-to-cloud-via-SFTP");
		color_restore();
		moreprint("");
		color_cyan();
		moreprint("SFTP REQUIRED:");
		color_restore();
		moreprint("+ : -host        A SFTP server hostname          (ex. backup.example.com)");
		moreprint("+ : -user        B SFTP username                 (ex. backupuser)");
		moreprint("+ : -remote      C Remote destination path       (ex. /home/backup/archives/)");
		moreprint("");
		color_cyan();
		moreprint("SFTP AUTHENTICATION (choose one):");
		color_restore();
		moreprint("+ : -password    D SFTP password                 (ex. mySecretPass123)");
		moreprint("+ : -ssh         E SSH private key               (ex. ~/.ssh/backup_key)");
		moreprint("");
		color_cyan();
		moreprint("OPTIONAL SETTINGS:");
		color_restore();
		color_yellow();
		moreprint("+ : -key           Enable encryption password    (**RECOMMENDED**)");
		color_restore();
		moreprint("+ : -port        F SFTP port                     (ex. 23, default: 22)");
		moreprint("+ : -bandwidth   G Limit global upload speed     (ex. 1000K)");
		moreprint("+ : -stat          List changed file name in log (privacy risk)");
		moreprint("                   Use -mailprivacy for filtered log with totals only");
		moreprint("+ : -test          Test archive before upload    (time-consuming)");
		moreprint("+ : -verify        Verify CRC-32 before upload");
		moreprint("+ : -force         **OVERWRITE** remote archive  (DANGEROUS, needs captcha)");
		moreprint("+ : -onlyupload    Continue upload only");
		moreprint("+ : -md5deep       Run a full deep ssh test  (old but fast)");
		moreprint("+ : -sha1deep      Run a full deep ssh test  (good)");
		moreprint("+ : -sha256deep    Run a full deep ssh test  (paranoid)");
		moreprint("");
		color_cyan();
		moreprint("EMAIL NOTIFICATIONS:");
		color_restore();
		moreprint("+ : -mailfull    H Full report e-mail            (ex. full@gmail.com)");
		moreprint("+ : -mailprivacy I Privacy report e-mail         (ex. privacy@gmail.com)");
		moreprint("+ : -maila       J Email program path            (see docs!)");
		moreprint("+ : -customer    K Email subject text            (ex. myhomebackup)");

	}
	if (i_usage && i_example) scrivi_examples();
	if (i_example)
	{
		moreprint("");
		color_cyan();
		moreprint("Basic automated backup, hardcoded key:");
		color_restore();
		moreprint("cloud u:\\backup.zpaq c:\\data\\*.cpp -host backup.company.com -user backupuser");
		moreprint(" -password mySFTPpass123 -port 23456 -remote /home/backups/paqqa/ -key pippo");
		moreprint("");
		
		color_cyan();
		moreprint("Secure verified SSH backup, key prompt:");
		color_restore();
		moreprint("cloud u:\\prod.zpaq c:\\server\\*.*  -host secure.example.com -user produser");
		moreprint(" -ssh ~/.ssh/prod_key -remote /secure/backups/ -test -verify -bandwidth 1m -key");
		moreprint("");
		
		color_cyan();
		moreprint("Full backup with -stat, dual emails (full and filtered):");
		color_restore();
		moreprint("cloud u:\\3.zpaq c:\\zp\\*.cpp  -host theserver.something -user theuser -port 23");
		moreprint(" -ssh thekey -remote /home/p/z/ -stat -test -verify -key -mailfull f@user.com");
		moreprint("-mailprivacy privacy@gmail.com -maila c:\\zpaqfranz\\maila2.exe -customer zcloud");
		moreprint("");
		
		color_cyan();
		moreprint("Resume upload only, no key asked:");
		color_restore();
		moreprint("cloud u:\\3.zpaq c:\\zp\\*.cpp  -host theserver.something -user theuser -port 23");
		moreprint(" -ssh thekey -remote /home/p4/franz/ -onlyupload");
		moreprint("");
		
		color_cyan();
		moreprint("Maila interface:");
		color_restore();
		moreprint("Sends reports by backup status (0 = SUCCESS, other = ERROR)");
		moreprint("Report types:");
		moreprint("  -full     Detailed report with filenames        (ex.  personal backups)");
		moreprint("  -privacy  Filtered report with data totals only (ex. for third parties)");
		moreprint("Scenario:   Full log to the client (w/files), privacy-filtered to the admin");
		moreprint("Example: maila2 0 ciao -full pip@user.com z:\\log.txt -privacy mar@it.it z:\\pri.txt");
	}
	return("Upload .zpaq (via SFTP)");
}
#endif // corresponds to #ifdef (#ifdef SFTP)
#endif ///NOSFTPEND
string help_comparehex(bool i_usage,bool i_example)
{
	if (i_usage)
	{
		scrivi_riga("CMD comparehex","Compare HEX substs from two files");
		scrivi_riga("First file  ","Name of first  text file");
		scrivi_riga("Second file ","Name of second text file");
		scrivi_riga("Haystack    ","The string to be searched");
		scrivi_riga("Expected len","Size of the hash");
	}
	if (i_usage && i_example) scrivi_examples();
	if (i_example)
	{
		scrivi_esempio("Quick check local backup","comparehex z:\\1.txt z:\\2.txt \"GLOBAL SHA256:\" 64");
	}
	return("Compare hex substrings in two files");
}
string help_count(bool i_usage,bool i_example)
{
	if (i_usage)
	{
		scrivi_riga("CMD count","Count strings inside files (just like grep)");
	}
	if (i_usage && i_example) scrivi_examples();
	if (i_example)
	{
		scrivi_esempio("I expect 3 all OK in logfiles","count z:\\*.txt 3 \"all OK\"");
		scrivi_esempio("I expect 10 BIG OK in logfiles","count z:\\*.txt 10");
	}
	return("Count substrings in file(s)");
}

string help_consolidatebackup(bool i_usage,bool i_example)
{
	if (i_usage)
	{
		scrivi_riga("CMD consolidate","Merge multipart-managed backup in one");
		scrivi_riga(" ","or convert a standard .zpaq to backup");
		scrivi_riga("-to", "something New backup file");
		scrivi_riga("-destination X","Copy-rename to X");
	}
	if (i_usage && i_example) scrivi_examples();
	if (i_example)
	{
		scrivi_esempio("Convert archive to backup","consolidate z:\\foo.zpaq -to k:\\newbackup -key pippo");
		scrivi_esempio("Rename a backup","consolidate z:\\oldname -destination z:\\newname");
		scrivi_esempio("Copy-Rename a backup","consolidate z:\\oldname -destination j:\\output\\newname");
	}
	return("Merge multipart backup into one archive");
}

string help_last2(bool i_usage,bool i_example)
{
	if (i_usage)
	{
		scrivi_riga("CMD last2","Compare last 2 rows of a textfile, hash filename");
		scrivi_riga(" ","Usually n-1 row the remote md5sum, last the local");
		scrivi_riga(" ","zpaqfranz a z:\\1.zpaq *.bat -checktxt -noeta >z:\\l.txt");
		scrivi_riga(" ","(some kind of rsync-rclone to remote)");
		scrivi_riga(" ","(some kind of md5sum from remote) >z:\\r.txt");
		scrivi_riga(" ","grep \"final MD5:\" z:\\l.txt >>z:\r.txt");
		scrivi_riga(" ","zpaqfranz last2 z:\\r.txt -big");
	}
	if (i_usage && i_example) scrivi_examples();
	if (i_example)
	{
		scrivi_esempio("Compare md5 hashes","last2 c:\\stor\\confronto.txt -big");
	}
	return("Compare last two lines in file");
}


string help_last(bool i_usage,bool i_example)
{
	if (i_usage)
	{
		scrivi_riga("CMD last","Get last of multipart filename, usually for");
		scrivi_riga(" ","scripting. Backups use 8 (eight) ? in filename");
		moreprint(" ");
		moreprint("Windows' example (script use %%, direct only %)");
		moreprint(" ");
		moreprint("FOR /f %%G in ('zpaqfranz last K:\\parte_???????? -pakka -noeta') DO ");
		moreprint("ssh -i thekey user@theserver.com md5sum '/home/franco/%%G' >remote.txt");
		moreprint(" ");
		moreprint("FOR /f %%G in ('zpaqfranz last K:\\parte_???????? -pakka -noeta') DO ");
		moreprint("zpaqfranz sum k:/%%G -md5 -pakka -noeta -stdout >>remote.txt");
		moreprint(" ");
		moreprint("zpaqfranz last2 remote.txt -big");
		moreprint(" ");
	}

	if (i_usage && i_example) scrivi_examples();
	if (i_example)
	{
		scrivi_esempio("Get the last partname","last z:\\prova_????????");
	}
	return("Get latest multipart filename");
}

string help_pause(bool i_usage,bool i_example)
{
	if (i_usage)
	{
		scrivi_riga("CMD pause","Get a key from stdin (like pause on DOS)");
		scrivi_riga("-n X","Wait X seconds, then proceed");
		scrivi_riga("-pakka", "Write less");
		scrivi_riga("-silent", "Write way less");
		scrivi_riga("-find x","Way for key x");
		scrivi_riga("-comment y","Change the prompt");
		
	}
	if (i_usage && i_example) scrivi_examples();
	if (i_example)
	{
		scrivi_esempio("Wait for any key","pause");
		scrivi_esempio("Wait for key z","pause -find z");
		scrivi_esempio("Wait for 5 seconds (or key)","pause -n 5");
		scrivi_esempio("Wait 5 seconds (or key) small output","pause -n 5 -pakka");
		scrivi_esempio("Wait 5 seconds (or key) NO output","pause -n 5 -pakka -silent");
		scrivi_esempio("Italian","pause -comment \"Premi un tasto\" -terse");
		
	}
	return("Pause script until timeout or keypress");
}

string help_setpassword(bool i_usage,bool i_example)
{
	if (i_usage)
	{
		scrivi_riga("CMD password","Change/remove password of single archive (no multipart)");
		scrivi_riga(" ","By default DRY RUN (only test)");
		scrivi_riga("-force", "Overwrite output if exists");
		scrivi_riga("-space", "Do not check for free space");
		scrivi_riga("-key2 X","Use X as new password");
	}
	if (i_usage && i_example) scrivi_examples();
	if (i_example)
	{
		scrivi_esempio("Change pass from X to Y","password z:\\x.zpaq z:\\y.zpaq -key X -key2 Y");
		scrivi_esempio("Add password X to NON encrypted","password z:\\nocrypt.zpaq z:\\yescrypt.zpaq -key2 X");
		scrivi_esempio("Remove password X from encrypted","password z:\\crypt.zpaq z:\\nocrypt.zpaq -key X");
	}
	return ("Change/remove password of single archive (no multipart)");
}
string help_trim(bool i_usage,bool i_example)
{

	if (i_usage)
	{
		scrivi_riga("CMD trim","Trim incomplete .zpaq file");
		scrivi_riga(" ","By default DRY RUN (only test)");
		scrivi_riga("-kill", "Do a 'wet' (effective) in-place run");
		scrivi_riga("-to", "tiny.zpaq Trim on tiny.zpaq");
		scrivi_riga("-verify", "Check the copy before trim");
	}
	if (i_usage && i_example) scrivi_examples();
	if (i_example)
	{
		scrivi_esempio("Trim file (dry run)","trim z:\\1.zpaq");
		scrivi_esempio("Trim file IN PLACE (wet run)","trim z:\\1.zpaq -kill");
		scrivi_esempio("Trim file on other (safer)","trim z:\\1.zpaq -to d:\\small.zpaq");
		scrivi_esempio("Trim file w/verify","trim z:\\1.zpaq -to d:\\small.zpaq -verify");
		scrivi_esempio("Trim a multipart NON encrypted","trim z:\\uno_???? -kill");
	}
	return("Remove incomplete transactions from .zpaq");

}
string help_crop(bool i_usage,bool i_example)
{

	if (i_usage)
	{
		scrivi_riga("CMD crop","Discard latest version(s)");
		scrivi_riga(" ","Permanently deletes recent versions from an archive,");
		scrivi_riga(" ","keeping only those up to a specified version number (-until)");
		scrivi_riga(" ","By default DRY RUN (only test)");
		scrivi_riga("-kill", "Perform the actual crop operation (the default is a dry run)");
		scrivi_riga("-to tiny.zpaq","Reduce to tiny.zpaq (safer)");
		scrivi_riga("-until X","Discard every versions >X");
		scrivi_riga("-maxsize X","Manually cut at X (RISKY)");
	    scrivi_riga("-force", "Crop in-place (no backup: VERY RISKY!)");
	}
	if (i_usage && i_example) scrivi_examples();
	if (i_example)
	{
		scrivi_esempio("Reduce file (dry run, just infos)","crop z:\\1.zpaq");
		scrivi_esempio("Reduce up to version 100","crop z:\\1.zpaq -to d:\\2.zpaq -until 100 -kill");
		scrivi_esempio("Reduce to first 100.000","crop z:\\1.zpaq -to d:\\2.zpaq -maxsize 100k -kill");
		scrivi_esempio("Crop in place (NO BACKUP! RISKY!)","crop z:\\1.zpaq -until 2 -kill -force");
	}
	return("Trim .zpaq archive (remove old versions, reduce size)");

}
void print_sub()
{
	scrivi_riga(" ","Substitute %hour %min %sec %weekday %year %month %day");
	scrivi_riga(" ","%week %date %time %datetime %timestamp (or $hour...)");
}
void print_doublequote()
{
	color_yellow();
	moreprint("REMEMBER: wildcards require double quotes. E.g., \"*.cpp\", \"test_???.zpaq\"");
	color_restore();
}
string help_a(bool i_usage,bool i_example)
{
	if (i_usage)
	{
		scrivi_riga("CMD a","(add) / append (ransomware)");
		scrivi_riga(" ","zpaqfranz stores an extra checksum (CRC-32/XXH64) for each file");
		scrivi_riga(" ","to detect potential SHA-1 collisions, a feature zpaq lacks.");
		scrivi_riga(" ","This may cause a slowdown of ~10% on modern CPUs and can be");
		scrivi_riga(" ","disabled with -nochecksum or -715");
		print_sub();
		scrivi_riga(" ","By default do NOT store ADSs on Windows (essentially useless).");
		scrivi_riga(" ","By default, .XLS files are forcibly re-added to every backup, as older");
		scrivi_riga(" ","Excel often modify metafiles without changing content. -xls to disable");
		scrivi_riga("-verbose", "Verbose output");
		scrivi_riga("-n X", "Show X files to be added, before and after sort");
		scrivi_riga("-debug", "Show debugging information");
		scrivi_riga("-debug2", "Show detailed information");
		scrivi_riga("-debug3", "Show VERY detailed debugging information");
		scrivi_riga("-summary", "Be brief");
		scrivi_riga("-noeta", "Do not show ETA (redirect output to log file)");
		scrivi_riga("-pakka", "New-style output (by chunks)");
		scrivi_riga("-forcewindows", "Store ADS stuff                (default: NO)");
		scrivi_riga("-xls", "Do NOT force adding of XLS/PPT (default: NO)");
		scrivi_riga("-forcezfs", "Do NOT ignore .zfs             (default: YES)");
		scrivi_riga("-715", "Runs just about like 7.15");
		scrivi_riga("-debug -zero","Add files but zero-filled (debugging)");
		scrivi_riga("-debug -zero -kill", "Add 0-byte long file (debugging)");
		scrivi_riga("-nochecksum", "Disable extra checksums (faster, but less reliable)");
		scrivi_riga("-nodedup", "Turn off deduplicator");
		scrivi_riga("-store", "Store mode: no deduplication, no compression");
		scrivi_riga("-touch", "Force 'touch' on date (converting 7.15 to zpaqfranz)");
		scrivi_riga("-norecursion", "Do not recurse into folders (default: YES)");
#ifdef _WIN32
		scrivi_riga("-findzpaq", "On Windows search the .zpaq in every drive letter (USB device)");
#endif // corresponds to #ifdef (#ifdef _WIN32)
		scrivi_riga("-append", "Append-only (antiransomware)");
		help_printhash(true);
		scrivi_riga("-test", "Do a post-add test (doveryay, no proveryay).");
		scrivi_riga("-verify", "Verify hashes against filesystem");
		scrivi_riga("-verify -ssd","Verify hashes against filesystem MULTITHREAD (do NOT use on spinning drives)");
		scrivi_riga("-paranoid", "Test for file with same size and timestamp, but !=hash (-ssd multithread)");
		scrivi_riga("-vss", "Volume Shadow Copies (Win with admin rights) to backup files from %users%.");
		scrivi_riga("-timestamp X","Setting version datetime @X, ex 2021-12-30_01:03:04 to freeze zfs snapshots");
		scrivi_riga(" ","Must be monotonic. increasing (v[i+1].date>v[i]+date)");
		help_date();
		scrivi_riga("-comment", "foo  Add a version with ASCII text 'foo'");
		scrivi_riga("-filelist", "Add the list of file to be added in a VFILE");
		scrivi_riga("-copy", "z:\\two  Make a 2nd copy of the written data into another folder");
#ifdef ZPAQFULL ///NOSFTPSTART
		scrivi_riga("-exec_ok", "p.sh Execute p.sh on successful completion, passing the archive name as a parameter");
#endif ///NOSFTPEND
		scrivi_riga("-freeze", "kajo  If current archive size > maxsize, move to kajo folder");
		scrivi_riga("-stdin", "Input data from stdin (pipe)");
		scrivi_riga("-stdout", "Force a NOT DEDUPLICATED file ready to stdout (pipe OUT)");
		scrivi_riga("-checktxt", "kaj Write out MD5 on kaj. For rsync/rclone sync");
		scrivi_riga("-checktxt", "Write out MD5 on archivename.txt");
		scrivi_riga("-buffer X","Use a input buffer of X bytes (default: 4KB)");
		scrivi_riga("-hashdeep", "Add the hashdeep MD5 VFILE (-ssd for multithread)");
		scrivi_riga("-fasttxt", "Write out CRC32 on archivename_crc32.txt");
		scrivi_riga("-fasttxt -verify","Post-check of crc32.txt");
		scrivi_riga("-home", "Create one archive for folder (-not -only)");
		scrivi_riga("-collision", "Double check for SHA-1 collisions");
		scrivi_riga("-chunk X","Split in chunk of size X");
#ifdef ZPAQFULL ///NOSFTPSTART
#ifdef unix
		scrivi_riga("-dataset", "x    Add changes on zfs dataset x");
#endif // corresponds to #ifdef (#ifdef unix)
#endif ///NOSFTPEND
		help_orderby();
#if defined(_WIN32)
#ifdef ZPAQFULL ///NOSFTPSTART
		scrivi_riga("-sfx autoz","Make SFX autoz.exe (on Win)");
		scrivi_riga("-sfxto foldr","Set -to into the SFX module");
		scrivi_riga("-sfxforce", "Set -force into the SFX module");
		scrivi_riga("-sfxnot", "Like -not for SFX");
		scrivi_riga("-sfxonly", "Like -only for SFX");
		scrivi_riga("-sfxuntil", "Like -until for SFX");
#endif ///NOSFTPEND
		scrivi_riga("-longpath", "Enable support for Windows paths longer than 255 characters");
		scrivi_riga("-windate", "Store file creation date");
		scrivi_riga("-open", "Early fail if archive is already open");
		scrivi_riga("-ads", "Store filelist in NTFS' ADS (Alternate Data Stream)");
#endif // corresponds to #if (#if defined(_WIN32))
		scrivi_riga("-image", "Create a raw image of a drive (Administrator/root rights required)");
		scrivi_riga("-fast", "Store filelist inside the archive (EXPERIMENTAL)");
		scrivi_riga("-ignore", "Do not show file access error");
		scrivi_riga("-pause", "Wait for key press after run");
		scrivi_riga("-ifexist X","Abort if X folder does not exist");
#if defined(_WIN32)
		scrivi_riga("-thunderbird", "Take appdata local\\roaming thunderbird");
#endif // corresponds to #if (#if defined(_WIN32))
		scrivi_riga("-date", "Store creation date (slower)");
		scrivi_riga("-frugal", "Use less RAM, but CANNOT WORK with mixed hashes");
		scrivi_riga("-stat", "Show external files added/updated");
		scrivi_riga("-external X","Run X before add (replace %files or $files)");
		scrivi_riga("-touch X", "Change every filedate to be stored to X");
		scrivi_riga("-input X", "Load the X file as files to be added");
		scrivi_riga("-destination X ", "Load the X file as -to");
		scrivi_riga("-errorlog X", "Write the errors on the X file");
		scrivi_riga("-ht", "Enable HyperThread (if any)");
		scrivi_riga("-notrim", "DISABLE autotrim of incomplete transaction (not with -chunk)");
#ifdef _WIN32
		scrivi_riga("-noonedrive", "Do NOT add onedrive placeholders");
		scrivi_riga("-monitor", "Turn off the monitor (Windows)");
#endif
		scrivi_riga("-slow", "Reduce CPU power (experimental on Linux)");
		scrivi_riga("-shutdown", "Attempt to shut down the computer upon completion");
#ifdef unix
		scrivi_riga("-tar", "Store *nix metadata");
#endif
#ifdef _WIN32
		scrivi_riga("-ntfs", "Scan a NTFS drive");
#endif
		scrivi_riga("-appendoutput", "Append to the output file specified by -out instead of overwriting it");
		scrivi_riga("-writeonconsole", "Write to stderr too");
		scrivi_riga("-checksize X", "Check if enoungh free space (or fail)");
		scrivi_riga("-nodelete", "Store all files togheter. WARNING: you must handle name collisions!");
		scrivi_riga("-franzen X", "EXPERIMENTAL: create .franzen file too with key X");
		}
		/*
		fdisk -l image.img
losetup -fP _dev_sda.img
losetup -a
mkdir -p /ripristinato
mount /dev/loop0p1 /ripristinato
(...)
umount /ripristinato
losetup -d /dev/loop0
*/
	if (i_usage && i_example) scrivi_examples();
	if (i_example)
	{
		scrivi_esempio("Add two folders to archive","a z:\\1.zpaq c:\\data\\* d:\\pippo\\*");
		scrivi_esempio("Add folder, storing full hash SHA3","a z:\\2.zpaq c:\\nz\\ -sha3");
		scrivi_esempio("Add folder, then verification","a z:\\3.zpaq c:\\nz\\ -test");
		scrivi_esempio("Add two files","a z:\\4.zpaq.zpaq c:\\vecchio.sql r:\\1.txt");
		scrivi_esempio("Add as zpaq 7.15 (no checksum)","a z:\\5.zpaq c:\\audio -715");
		scrivi_esempio("Add and mark version","a z:\\6.zpaq c:\\data\\* -comment first_copy");
#if defined(_WIN32) || defined(_WIN64)
		scrivi_esempio("Add by a VSS (Windows admin)","a z:\\7.zpaq c:\\users\\utente\\* -vss");
#endif // corresponds to #if (#if defined(_WIN32) || defined(_WIN64))
		scrivi_esempio("Add folder with timestamping (zfs)","a z:\\8.zpaq c:\\data\\* -timestamp 2021-12-30_01:03:04");
		scrivi_esempio("Create multipart archive","a \"z:\\9_????.zpaq\" c:\\data\\");
		scrivi_esempio("Create indexed multipart archive","a \"z:\\a_???.zpaq\" c:\\data\\ -index z:\\a_000.zpaq");
		scrivi_esempio("Add folder, with encryption","a z:\\b.zpaq c:\\nz\\ -key mygoodpassword");
		scrivi_esempio("Add folder, maximum compress","a z:\\c.zpaq c:\\nz\\ -m5");
		scrivi_esempio("Store the filelist VFILE","a z:\\d.zpaq c:\\nz\\ -filelist");
		scrivi_esempio("Add WITHOUT CRC-32/hash (like 715)","a z:\\e.zpaq c:\\nz\\ -nochecksum");
		scrivi_esempio("Add 2nd copy to USB drive (U)","a \"z:\\f_???.zpaq\" c:\\nz\\ -copy u:\\usb");
#ifdef ZPAQFULL ///NOSFTPSTART
		scrivi_esempio("Launch pippo.bat after OK","a \"z:\\g_???.zpaq\" c:\\nz\\ -exec_ok u:\\pippo.bat");
#endif ///NOSFTPEND
		scrivi_esempio("Archive file if bigger of 10GB","a z:\\h.zpaq c:\\nz\\ -freeze y:\\archived -maxsize 10000000000");
#ifdef ZPAQFULL ///NOSFTPSTART
#if defined(_WIN32)
		scrivi_esempio("Make z:\\2.exe from z:\\1.zpaq","a z:\\1.zpaq *.cpp -sfx z:\\2.exe");
		scrivi_esempio("2.exe extract/overwrite into z:\\kom","a z:\\1.zpaq *.cpp -sfx z:\\2.exe -sfxto z:\\kom -sfxforce");
#endif // corresponds to #if (#if defined(_WIN32))
#endif ///NOSFTPEND
		scrivi_esempio("Prepare a debug archive...for me","a z:\\1.zpaq c:\\nz\\ -debug -zero");
		scrivi_esempio("In-place 7.15 to zpaqfranz  1/2","a z:\\1.zpaq c:\\nz\\ -touch");
		scrivi_esempio("In-place 7.15 to zpaqfranz  2/2","a z:\\1.zpaq c:\\nz\\");
		scrivi_esempio("Hard-check of files","a z:\\1.zpaq c:\\nz\\ -paranoid");
		scrivi_esempio("Hard-check of files multithread","a z:\\1.zpaq c:\\nz\\ -paranoid -ssd");
		scrivi_esempio("Archive, without recursion","a z:\\1.zpaq f:\\zarc\\*.* -norecursion");
		scrivi_esempio("Archive mysqldump","a z:\\1.zpaq mydump.sql -stdin");
		scrivi_esempio("MD5 quick check","a z:\\knb.zpaq c:\\nz\\ -checktxt z:\\pippo.txt");
		scrivi_esempio("Write MD5 on z:\\knb.txt","a z:\\knb.zpaq c:\\nz\\ -checktxt");
		scrivi_esempio("Write CRC32 on z:\\1_crc32.txt","a z:\\1.zpaq c:\\nz\\ -fasttxt");
#ifdef _WIN32
		scrivi_esempio("Find file /prova/ci.zpaq on drives","a z:\\prova\\ci.zpaq c:\\nz\\* -findzpaq");
		scrivi_esempio("Abort if file already open","a z:\\2.zpaq c:\\nz\\* -open");
		scrivi_esempio("Raw imaging drive E with built in","a z:\\2.zpaq e: -image");
		scrivi_esempio("Imaging C with pwd and big buffer","a z:\\2.zpaq c: -image -buffer 1MB -key pippo");
		scrivi_esempio("Create VFILE-l-hashdeep.txt w/md5","a z:\\2.zpaq *.txt *.cpp -hashdeep -ssd");
#endif // corresponds to #ifdef (#ifdef _WIN32)
		scrivi_esempio("Multiple z:\\utenti_something.zpaq","a z:\\utenti.zpaq c:\\users -home");
		scrivi_esempio("All users, but not franco","a /temp/test1 /home -home -not franco");
		scrivi_esempio("Only SARA and NERI folders","a /temp/test2 /home -home -only \"*SARA\" -only \"*NERI\"");
		scrivi_esempio("Sort (orderby) before add","a z:\\test.txt c:\\dropbox -orderby ext;name");
		scrivi_esempio("Sorting files from largest","a z:\\test.txt c:\\dropbox -orderby size -desc");
		scrivi_esempio("Manage SHA-1 collisions","a z:\\1.zpaq messageA messageB -collision");
#ifdef unix
		scrivi_esempio("Update from tank/d dataset","a /tmp/test.zpaq * -dataset \"tank/d\"");
#endif // corresponds to #ifdef (#ifdef unix)
#ifdef _WIN32
		scrivi_esempio("Store filelist on NTFS","a z:\\1.zpaq *.cpp -ads");
#endif // corresponds to #ifdef (#ifdef _WIN32)
		scrivi_esempio("Split in 1GB chunks","a z:\\1.zpaq c:\\pippo -chunk 1GB");
		scrivi_esempio("Store (EXPERIMENTAL) filelist","a z:\\1.zpaq c:\\pippo -fast");
		scrivi_esempio("Do not mess output with errors","a z:\\1.zpaq c:\\users -ignore");
		scrivi_esempio("Wait for a key press after run","a z:\\1.zpaq c:\\users -pause");
		scrivi_esempio("Abort if /monta...rar does not exist","a /1.zpaq /thefolder -ifexist /monta/nas1_nfs3/rar");
#ifdef _WIN32
		scrivi_esempio("Take Thunderbird email of utente","a z:\\1.zpaq c:\\users\\utente -thunderbird");
		scrivi_esempio("Close and take Thunderbird email","a z:\\1.zpaq c:\\users\\utente -thunderbird -kill");
#endif // corresponds to #ifdef (#ifdef _WIN32)
		scrivi_esempio("Store creation date (slower)","a z:\\1.zpaq c:\\users\\utente -date");
		scrivi_esempio("Use less RAM: DO NOT MIX HASHES!","a z:\\1.zpaq c:\\nz -frugal");
		scrivi_esempio("Store external VFILE-l-external.txt","a z:\\2.zpaq c:\\nz -external \"c:\\nz\\hashdeep64 -r -c sha1 %files\"");
		scrivi_esempio("Alter the filedate (piped)","type 1.txt|zpaqfranz a z:\\2.zpaq 1.sql -stdin -touch 2024_02_03");
		scrivi_esempio("Load files from text file","a z:\\1.zpaq -input z:\\thelist.txt");
		scrivi_esempio("Write errors","a z:\\1.zpaq c:\\windows\\system32 -errorlog z:\\errors.txt -silent");
		scrivi_esempio("Load files/to from text files","a z:\\1.zpaq -input z:\\input.txt -destination z:\\destination.txt");
#ifdef _WIN32
		scrivi_esempio("Do NOT add onedrive placeholder","a z:\\1.zpaq c:\\users\\utente\\onedrive -onedrive");
		scrivi_esempio("Reduce CPU power, turn off","a z:\\1.zpaq c:\\pippo -slow -monitor -shutdown");
#endif
#ifdef unix
		scrivi_esempio("Store metadata too","a /tmp/1.zpaq /www -tar -highway64");
#endif
#ifdef _WIN32
		scrivi_esempio("Quickly scan a NTFS drive","a z:\\1.zpaq d:\\ -ntfs");
#endif
#ifdef unix
		scrivi_esempio("Raw imaging a device","a /tmp/bak.zpaq /dev/sdb -image");
#endif
		scrivi_esempio("Append to outputfile","a /tmp/bak.zpaq etc -out result.txt -appendoutput");
		scrivi_esempio("Force 10GB+ free space","a /tmp/bak.zpaq etc -checkspace 10g -exec_err fulldisk.sh");
		scrivi_esempio("Make franzen file","a z:\\1.zpaq c:\\nz -franzen pippo -key pluto");
		
	}
	return("Add/append file(s) to archive");
}
#ifdef ZPAQFULL ///NOSFTPSTART
string help_update(bool i_usage,bool i_example)
{
	if (i_usage)
	{
		scrivi_riga("CMD update","(refresh zpaqfranz from Internet)");
		scrivi_riga("  ","Check/download from http://www.francocorbelli.it/zpaqfranz");
#ifdef _WIN64
		scrivi_riga(" ","or from two user-entered URLs");
		scrivi_riga("-force", "Wet-run (do the update, default dry-run)");
		scrivi_riga("-force -kill","Replace current zpaqfranz from Internet");
#endif // corresponds to #ifdef (#ifdef _WIN64)
	}
	if (i_usage && i_example) scrivi_examples();
	if (i_example)
	{
		scrivi_esempio("Check for updates","update");
#ifdef _WIN64
		scrivi_esempio("Check for updates","upgrade");
		scrivi_esempio("Update (if any)","update -force");
		scrivi_esempio("Get always from Internet","update -force -kill");
		scrivi_esempio("Use specific URLs","update https://www.pippo.com/ugo.sha256 http://www.pluto.com/zpaqnew.exe");
#endif // corresponds to #ifdef (#ifdef _WIN64)
	}
#ifdef _WIN32
	return ("Update zpaqfranz (www.francocorbelli.it)");
#else
	return ("Check for new zpaqfranz version (www.francocorbelli.it)");
#endif // corresponds to #ifdef (#ifdef _WIN32)
}


#ifdef _WIN64
string help_download(bool i_usage,bool i_example)
{
	if (i_usage)
	{
		scrivi_riga("CMD download","Get file from Internet");
		scrivi_riga("-force", "Overwrite output file");
		scrivi_riga("-space", "Do not check the output path");
		scrivi_riga("-checktxt", "z   Test hash in z file (len 32=MD5, 40=SHA-1, 64=SHA-256)");
	}
	if (i_usage && i_example) scrivi_examples();
	if (i_example)
	{
		scrivi_esempio("Download in ugo.txt","download https://www.1.it/2.cpp ./2.cpp");
		scrivi_esempio("Download+check SHA256","download http://www.1.it/3.cpp z:\\3.cpp -checktxt http://www.1.it/3.sha256");
		scrivi_esempio("Download+check MD5","download http://www.1.it/4.cpp z:\\4.cpp -checktxt http://www.1.it/4.md5");
	}
	return ("Download file from Internet");
}
#endif // corresponds to #ifdef (#ifdef _WIN64)
#endif ///NOSFTPEND

#ifdef _WIN32
#ifdef ZPAQFULL ///NOSFTPSTART
string help_rd(bool i_usage,bool i_example)
{
	if (i_usage)
	{
		scrivi_riga("CMD rd","remove directory on Windows");
		scrivi_riga(" ","Delete hard-to-remove dir (like rd /s or rm -r)");
		scrivi_riga("-kill", "Wet run (default: DRY run)");
		scrivi_riga("-force", "Remove folder if not-zero files present");
		scrivi_riga("-space", "Do not check if writeable (ex. 0 bytes free)");
	}
	if (i_usage && i_example) scrivi_examples();
	if (i_example)
		scrivi_esempio("Remove folder z:\\kajo:","rd z:\\kajo -force -kill -space");
	return ("Remove hard-to-delete Windows folder (ex. path >255)");
}
#endif ///NOSFTPEND
string help_pakka(bool i_usage,bool i_example)
{
	if (i_usage)
	{
		scrivi_riga("CMD pakka","create zpaqlist-compatible output");
		scrivi_riga("-all", "All version(s)");
		scrivi_riga("-distinct", "Do not deduplicate output");
		scrivi_riga("-until X", "Choose version X");
		scrivi_riga("-out", "thefile  Write output on thefile");
	}
	if (i_usage && i_example) scrivi_examples();
	if (i_example)
	{
		scrivi_esempio("List to file","pakka h:\\zarc\\1.zpaq -out z:\\default.txt");
		scrivi_esempio("Disable de-duplicator","pakka h:\\zarc\\1.zpaq -all -distinct -out z:\\default.txt");
		scrivi_esempio("Get version 10","pakka h:\\zarc\\1.zpaq -until 10 -out z:\\10.txt");
	}
	return ("Output for third-party extractors");
}
#endif // corresponds to #ifdef (#ifdef _WIN32)
string help_fzf(bool i_usage,bool i_example)
{
	if (i_usage)
	{
		scrivi_riga("CMD fzf","List archive content 'plain-and-dirty'");
		scrivi_riga("-all", "Show all version");
	}
	if (i_usage && i_example) scrivi_examples();
	if (i_example)
	{
		scrivi_esempio("List filenames","fzf z:\\kajo.zpaq");
		scrivi_esempio("List filenames/pipe in fzf","fzf z:\\kajo.zpaq|fzf");
	}
	return ("List archive filenames (raw output)");
}
string help_collision(bool i_usage,bool i_example)
{
	if (i_usage)
	{
		scrivi_riga("CMD collision","Inspect for SHA-1 collisions");
	}
	if (i_usage && i_example) scrivi_examples();
	if (i_example)
	{
		scrivi_esempio("Inspect file","collision z:\\kajo.zpaq");
	}
	return ("Inspect archive for SHA-1 collisions");
}
string help_dump(bool i_usage,bool i_example)
{
	if (i_usage)
	{
		scrivi_riga("CMD dump","Display technical archive information (not for huge archives!)");
		scrivi_riga("BTW","will show archive compatibility level");
		scrivi_riga(" ","60+  = zpaqfranz from  v60 and more ~jul 2024");
		scrivi_riga(" ","<60  = zpaqfranz up to v59.x");
		scrivi_riga(" ","715  = standard  zpaq  7.15 (or zpaqfranz -715)");
		scrivi_riga("-summary", "Brief");
		scrivi_riga("-verbose", "Show useful infos");
		scrivi_riga("-all", "A bit deeper");
	}
	if (i_usage && i_example) scrivi_examples();
	if (i_example)
	{
		scrivi_esempio("Default infos","dump z:\\kajo.zpaq");
		scrivi_esempio("More","dump z:\\kajo.zpaq -verbose");
		scrivi_esempio("Brief","dump z:\\kajo.zpaq -summary");
		scrivi_esempio("All available details","dump z:\\kajo.zpaq -all");
	}
	return ("Show tech info (may fail with large archives)");
}
string help_redu(bool i_usage,bool i_example)
{
	if (i_usage)
	{
		scrivi_riga("CMD redu","Technical (quick) exam of files");
	}
	if (i_usage && i_example) scrivi_examples();
	if (i_example)
	{
		scrivi_esempio("Default infos","redu z:\\*.exe");
	}
	return ("Estimate compression (0=none, 255=high)");
}
string help_w(bool i_usage,bool i_example)
{
	if (i_usage)
	{
		scrivi_riga("CMD w","Chunked-extraction");
		scrivi_riga(" ","Extract/test in chunks, on disk or 'ramdisk' (RAM)");
		scrivi_riga(" ","The output -to folder MUST BE EMPTY");
		scrivi_riga("-maxsize X", "Maxsize of the chunk @ X bytes");
		scrivi_riga("-ramdisk", "Use 'RAMDISK'");
		scrivi_riga("-frugal", "Use less possible RAM (default: get 75% of free RAM)'");
		scrivi_riga("-ssd", "Multithread writing from ramdisk");
		scrivi_riga("-test", "Do not write on media");
		scrivi_riga("-verbose", "Show useful infos");
		scrivi_riga("-checksum", "Do CRC-32 / hashes test");
		scrivi_riga("-verify", "Do a 'check-against-filesystem'");
		scrivi_riga("-paranoid", "Extract to filesystem, then delete if OK (need -verify)");
#ifdef _WIN32
		scrivi_riga("-longpath", "Extracting on Windows filenames longer than 255");
#endif // corresponds to #ifdef (#ifdef _WIN32)
	}
	if (i_usage && i_example) scrivi_examples();
	if (i_example)
	{
		scrivi_esempio("Extract to a spinning drive","w z:\\1.zpaq -to p:\\muz7\\ -ramdisk -longpath");
		scrivi_esempio("Paranoid check into folder muz7","w z:\\1.zpaq -to z:\\muz7\\ -paranoid -verify -verbose -frugal -longpath");
		scrivi_esempio("Paranoid  max chunksize 1000000000","w z:\\1.zpaq -to z:\\muz7\\ -paranoid -verify -maxsize 1000000000");
		scrivi_esempio("Test in RAM (no disk write,M/T)","w z:\\1.zpaq -ramdisk -test -checksum -ssd -frugal");
		scrivi_esempio("Top test (W/disk write on SSD z:\\)","w z:\\1.zpaq -to z:\\kajo -ramdisk -paranoid -verify -checksum -longpath -ssd");
	}
	return ("Extract/test large files in chunks");
}
string help_x(bool i_usage,bool i_example)
{
	if (i_usage)
	{
		scrivi_riga("CMD x","Extract");
		scrivi_riga(" ","During extraction,if CRC-32s are present, the codes are checked.");
		scrivi_riga(" ","Extract multiple files with '*'");
		scrivi_riga("-all", "All versions");
		scrivi_riga("-all -comment","Restore all versions with DATETIME and comment (if any)");
		scrivi_riga("-checksum", "force a full hash-code verify (if added with -checksum)");
		scrivi_riga("-zero", "extract to dummy, 0-length files. Do an empty-full restore.");
		scrivi_riga("-zero -debug","extract full-sized files, 0 filled (Dry restore)");
		scrivi_riga("-zero -debug -kill","Only extract filenames (0 bytes long)");
		scrivi_riga("-utf", "change everything non latin to latin (Linux/*Nix => NTFS compatibility)");
		scrivi_riga("-fix255", "shrink max file name, avoid different case collision (Linux => NTFS)");
		scrivi_riga(" ","(pippo.txt and PIPPO.txt are be silently overwritten by 7.15).");
		scrivi_riga("-fixeml", "compress .eml filenames.");
#ifdef _WIN32
		scrivi_riga("-longpath", "Extracting on Windows filenames longer than 255");
		scrivi_riga("-fixreserved", "fix reserved filenames on Windows (ex. LPT1).");
		scrivi_riga("-windate", "Restore (if any) file's creation date");
#endif // corresponds to #ifdef (#ifdef _WIN32)
		scrivi_riga("-flat", "emergency restore of everything into a single folder (Linux => NTFS)");
		scrivi_riga("-filelist", "show (if any) a stored filelist");
		scrivi_riga("-force", "Force overwrite AND extracting of corrupted files (if any)");
		scrivi_riga("-space", "Do not check free space before extract");
		scrivi_riga("-find/replace", "Replace part of text");
		scrivi_riga("-replace X","Juxtapose X to stored path");
		scrivi_riga("-image", "Change the progress to handle huge files (-minsize X default 20MB)");
		scrivi_riga("-stdout", "Output (if possible) a single file on stdout");
		scrivi_riga("-external", "Show (if any) a stored external file");
		scrivi_riga("-ramdisk", "Extract to RAM, then write (if possible)");
		help_range();
#ifdef unix
		scrivi_riga("-tar", "Extract metadata (e.g. user, group ...if any), coalescing hard links");
#endif
#ifdef ZPAQFULL ///NOSFTPSTART
#ifdef _WIN64
		scrivi_riga("-ramsize", "Win64: allocate max virtual memory across all swapfiles");
#endif	
		scrivi_riga("-huge", "Use alternate write policy (huge file on non-sparse filesystem)");

#endif ///NOSFTPEND
	}
	if (i_usage && i_example) scrivi_examples();
	if (i_example)
	{
		scrivi_esempio("Single file to file extraction","x 1.zpaq \"/k/foo/b.md\" -to \"/tmp/restored/b.md\"");
		scrivi_esempio("Single file to folder tree","x 1.zpaq -only \"*whatever\" -to /tmp/foldertree");
		scrivi_esempio("Everything into folder muz7","x z:\\1.zpaq -to z:\\muz7\\");
		scrivi_esempio("0-bytes files (check restoration)","x z:\\1.zpaq -to z:\\muz7\\ -kill");
		scrivi_esempio("Extract into single directory","x z:\\1.zpaq -to z:\\muz7\\ -flat");
		scrivi_esempio("Extract without utf,<255,.eml","x z:\\1.zpaq -to z:\\muz7\\ -utf -fix255 -fixeml");
		scrivi_esempio("Extract forcing overwrite","x z:\\1.zpaq -to z:\\muz7\\ -force");
		scrivi_esempio("Extract version K","x z:\\1.zpaq -to z:\\muz7\\ -until K");
		scrivi_esempio("Extract last versions of multipart","x \"z:\\a_???\" -to z:\\ugo");
		scrivi_esempio("Extract into muz7 every versions","x z:\\1.zpaq -to z:\\muz7\\ -all");
		scrivi_esempio("Show the filelist (if any)","x z:\\1.zpaq -filelist");
		scrivi_esempio("Show the filelist (if any) of v3","x z:\\1.zpaq -filelist -until 3");
		scrivi_esempio("Extract all *.xls into new archive","x z:\\1.zpaq *.xls -repack onlyxls.zpaq");
		scrivi_esempio("Extract from a VSS (Windows)","x z:\\1.zpaq \\\\?\\GLOBALROOT\\Device\\HarddiskVolumeShadowCopy1\\path -to d:\\output");
		scrivi_esempio("Replace path in extract","x 1.zpaq -find /tank/ -replace z:\\uno\\");
		scrivi_esempio("Change path in extract, longpath","x 1.zpaq -replace z:\\uno\\ -longpath");
		scrivi_esempio("Create files' tree","x 1.zpaq -to z:\\testdir\\ -debug -kill -zero -longpath");
		scrivi_esempio("Range-extract version","x copia.zpaq -only *comp.pas -to z:\\allcomp -all -range 100:1000");
		scrivi_esempio("Restore datetime and comments","x copia.zpaq -to z:\\prova\\ -all -comment");
		scrivi_esempio("Restore huge image w/smart progress","x copia.zpaq -to z:\\prova\\ -image");
		scrivi_esempio("Single file to stdout","x copia.zpaq 00000015.zfs >z:\\15.zfs");
		scrivi_esempio("Extract multiple zpaqs","x \"vu*.zpaq\" -to z:\\pippo\\");
		scrivi_esempio("Show external VFILE","x z:\\1.zpaq -external -silent");
		scrivi_esempio("Spinning drive with lot of RAM","x z:\11.zpaq -to z:\\ugo -ramdisk");
		scrivi_esempio("Restoring user/group/dates","x /1.zpaq -to /tmp/ugo -tar");
#ifdef ZPAQFULL ///NOSFTPSTART
#ifdef _WIN64
		scrivi_esempio("Max virtual memory allocation", "x 1.zpaq -to somewhere -ramdisk -ramsize");
		scrivi_esempio("Try allocating 500GB virtual memory", "x 1.zpaq -to somewhere -ramdisk -ramsize 500GB");
#endif
#endif ///NOSFTPEND
		scrivi_esempio("Restoring huge files on not-NTFS","x z:\\1.zpaq -to u:\\restore -huge");
#ifdef _WIN32
		scrivi_esempio("Restoring with sparse file","x z:\\1.zpaq -to u:\\restore -sparse");
#endif
	}
	return("Extract file(s)");

}
string help_l(bool i_usage,bool i_example)
{

	if (i_usage)
	{
		scrivi_riga("CMD l","List");
		scrivi_riga(" ","If source folders are specified, do a compare of the archive's content.");
		scrivi_riga(" ","A 'verify' more than a 'list', much faster than the standard,");
		scrivi_riga(" ","as it performs a block calc  codes of source files, but not of");
		scrivi_riga(" ","the archived ones; also checks the CRC-32, to intercept any SHA1 collisions.");
		scrivi_riga(" ","Use the exact same parameters of add(), just use l instead of a.");
		scrivi_riga("-force", "Shows all files (even marked as corrupted)");
		scrivi_riga("-checksum", "Shows CRC-32/hash, if any");
		scrivi_riga("-summary", "Compact file list");
		scrivi_riga("-comment", "foo  Works on version foo, if possible");
		scrivi_riga("-comment", "Enumerate version-comment");
		scrivi_riga("-find", "pippo   Just like |grep -i pippo");
		scrivi_riga("-replace", "foo  Replace -find with -replace in the output");
		scrivi_riga("-to", "knb       Do the standard rename()");
		scrivi_riga("-utc", "Do not convert to localtime (show UTC)");
		scrivi_riga("-stdout", "If -verbose show if files' fragments are ordered");
#ifdef _WIN32
		scrivi_riga("-windate", "Show (if any) file's creation date");
		scrivi_riga("-ads", "Skip NTFS filelist (if any)");
#endif // corresponds to #ifdef (#ifdef _WIN32)
		scrivi_riga("-fast", "Try to extract the filelist (if present)");
		scrivi_riga("-date", "Show creation date (if any)");
		scrivi_riga("-attr", "Show the attr");
		scrivi_riga("-terse", "Make a 'script-aware' output");
		scrivi_riga("-nodel", "Do not show deleted files (with -all)");
		scrivi_riga("-csv","\"some\"   Enable -csv delimiter  (\\t for TAB)");
		scrivi_riga("-csvhf","\"!\"    CSV line header/footer (\\t for TAB)");
		help_date();
		help_size();
		help_orderby();
		help_range();
		scrivi_riga("-715", "Binary-compatible zpaq 7.15 output");
		scrivi_riga("-norecursion", "Do not recurse with -only (see example below)");
		scrivi_riga("-tar", "Show Posix metadata (if any)");
		scrivi_riga("-home", "Show 1-level data");
		scrivi_riga("-orderby X","-desc -n Y");
		
	}
	if (i_usage && i_example) scrivi_examples();
	if (i_example)
	{
		scrivi_esempio("Last version","l z:\\1.zpaq");
		scrivi_esempio("Last version w/checksums","l z:\\1.zpaq -checksum");
		scrivi_esempio("Compact output","l z:\\1.zpaq -checksum -summary");
		scrivi_esempio("Compact output renamed","l z:\\1.zpaq -checksum -summary -to z:\\knb");
		scrivi_esempio("All (every) version","l z:\\1.zpaq -all");
		scrivi_esempio("Version comments (if any)","l z:\\1.zpaq -comment");
		scrivi_esempio("V.comments verbose (if any)","l z:\\1.zpaq -comment -all");
		scrivi_esempio("Only stored 'zpaq.cpp'","l z:\\1.zpaq -find zpaq.cpp -pakka");
		scrivi_esempio("Find-and-replace (like awk or sed)","l r:\\1.zpaq -find c:/biz/ -replace z:\\mydir\\");
		scrivi_esempio("List the 10 greatest file","l z:\\1.zpaq -all -orderby size -desc -n 10");
		scrivi_esempio("List files >1G","l z:\\1.zpaq -minsize 1g");
		scrivi_esempio("List files >100M of 2017","l z:\\1.zpaq -minsize 100m -datefrom 2017 -dateto 2017");
		scrivi_esempio("List ORDERED files (-stdout)","l z:\\1.zpaq -stdout");
		scrivi_esempio("Compare to files on disk   ","l z:\\1.zpaq \"//somewhere/scanner/\" -ssd");
		scrivi_esempio("Find the versions of a file","l z:\\1.zpaq -only \"*/the/file.doc\" -all");
		scrivi_esempio("Force recomputing list","l z:\\1.zpaq -ads");
		scrivi_esempio("Try to get the fast filelist","l z:\\1.zpaq -fast");
		scrivi_esempio("Files added in versions 2 and 3","l z:\\1.zpaq -range 2:3");
		scrivi_esempio("Files added in last version","l z:\\1.zpaq -range ::1");
		scrivi_esempio("Show creation date (if any)","l z:\\1.zpaq -date");
		scrivi_esempio("Fixed sized/no header and footer","l z:\\1.zpaq -terse");
		scrivi_esempio("Where are the restorable versions? ","l z:\\1.zpaq -find \"$$$$\" -all -nodel");
		scrivi_esempio("TAB-delimited CSV output           ","l z:\\1.zpaq -terse -csv \"\\t\"");
		scrivi_esempio("Enclose fields between double quote","l z:\\1.zpaq -terse -csv \"\\\",\\\"\" -csvhf \"\\\"\"");
		scrivi_esempio("Output just like zpaq 7.15","l z:\\1.zpaq -715");
		scrivi_esempio("Show a folder WITHOUT subfolders","l z:\\1.zpaq -only c:/dropbox/snapshot -norecursion");
		scrivi_esempio("Show a folder WITH subfolders","l z:\\1.zpaq -only c:/dropbox/snapshot");
		scrivi_esempio("Get metadata (if any)","l /tmp/backup.zpaq -tar");
		scrivi_esempio("Show 4 largest 1-level folders","l z:\\1.zpaq c:/zpaqfranz -home -desc -n 4");
	}
	return("List file(s)");

}
string help_i(bool i_usage,bool i_example)
{
	if (i_usage)
	{
		scrivi_riga("CMD i (info)","Directly shows the versions into the archive, with size and comments");
		scrivi_riga("-comment", "Shows comments (if any)");
		scrivi_riga("-stat", "Count 'weird' files and show uncompressed size (slow)");
		help_range();
	}
	if (i_usage && i_example) scrivi_examples();
	if (i_example)
	{
		scrivi_esempio("Show versions info (command i)","i z:\\1.zpaq");
		scrivi_esempio("Count 'not good filenames'","i z:\\1.zpaq -stat");
		scrivi_esempio("Shows version comment","i z:\\1.zpaq -comment");
		scrivi_esempio("Show version 153","i z:\\1.zpaq -range 153");
		scrivi_esempio("Show last 5 versions","i z:\\1.zpaq -range ::5");
	}
	return("Show file/archive info");

}
#ifndef ANCIENT
string help_ls(bool i_usage,bool i_example)
{
	if (i_usage)
	{
		scrivi_riga("CMD ls","Navigate inside .zpaq like a 'filesystem'");
		scrivi_riga(" ","EXPERIMENTAL");
		scrivi_riga(" ","Enter help or ? to commands list");

	}
	if (i_usage && i_example) scrivi_examples();
	if (i_example)
	{
		scrivi_esempio("Enter inside archive","ls z:\\1.zpaq");
	}
	return ("Browse inside .zpaq archive");
}

string help_tui(bool i_usage,bool i_example)
{
	if (i_usage)
	{
		scrivi_riga("CMD tui","Start text-based TUI");
		scrivi_riga(" ","Please strike ? key to get all commands");
	}
	if (i_usage && i_example) scrivi_examples();
	if (i_example)
	{
		scrivi_esempio("Launch the TUI","tui z:\\okane.zpaq");
	}
	return("Text UI for listing/extraction");

}
#endif
#ifdef _WIN32
string help_q(bool i_usage,bool i_example)
{
	if (i_usage)
	{
		scrivi_riga("CMD q"," Windows archiving of C: (*** admin rights mandatory ***)");
		scrivi_riga(" ","Take as much C: as possible (no Windows and swapfile)");
		scrivi_riga(" ","This is NOT a full backup (aka: bare-metal restorable)");
		scrivi_riga("-forcewindows", "INCLUDE Windows folder");
		scrivi_riga("-frugal", "Exclude Windows, %programfiles% and %temp%");
		scrivi_riga("-all", "Get everything (except swapfile)");
		scrivi_riga("-to", "c:\\piz    Use c:\\piz for snap (default c:\\franzsnap)");
		scrivi_riga(" ","It is possible to use %pcname as placeholder");
		scrivi_riga(" ","Just about all switches of add() (-key -m -only ...)");
		scrivi_riga(" ","except files selection (always C:/*)");
		scrivi_riga(" ","****      The folder franzsnap MUST NOT EXIST and be on C:");
	}
	if (i_usage && i_example) scrivi_examples();
	if (i_example)
	{
		scrivi_esempio("NOT C:\\WINDOWS, NOT RECYCLE BIN","q z:\\1.zpaq");
		scrivi_esempio("Everything","q z:\\1.zpaq -all");
		scrivi_esempio("Everything NOT C:\\DROPBOX","q z:\\1.zpaq -all -not c:/franzsnap/dropbox");
		scrivi_esempio("NOT C:\\WINDOWS, NOT %programs%","q z:\\1.zpaq -frugal");
		scrivi_esempio("Only C/C++ files and header","q z:\\1.zpaq -only *.c* -only *.h*");
		scrivi_esempio("For multi-PC 'backup' on one zpaq","q z:\\1.zpaq -frugal -to c:\\snap_%pcname -verbose");
	}
	return("Archive C: with VSS (Windows)");

}

string help_ads(bool i_usage,bool i_example)
{

	if (i_usage)
	{
		scrivi_riga("CMD ads","Manipulate NTFS Alternate Data Stream");
	}
	if (i_usage && i_example) scrivi_examples();
	if (i_example)
	{
		scrivi_esempio("Show    ADS","ads z:\\1.zpaq");
		scrivi_esempio("Remove  ADS (all of them)","ads z:\\*.zpaq -kill");
		scrivi_esempio("Remove  ADS (only one)","ads z:\\*.zpaq -only fasttxt -kill");
		scrivi_esempio("Rebuild ADS filelist","ads z:\\1.zpaq -force");
	}
	return("Manipulate ADS (Alternate Data Stream)");

}

string help_g(bool i_usage,bool i_example)
{
	if (i_usage)
	{
		scrivi_riga("CMD g","Run a q command (Windows archiving of C:)");
		scrivi_riga(" ","If the user is in the administrator group, BUT");
		scrivi_riga(" ","the current shell does not have admin rights, this will work");
	}
	if (i_usage && i_example) scrivi_examples();
	if (i_example)
	{
		scrivi_esempio("NOT C:\\WINDOWS, NOT RECYCLE BIN","g z:\\1.zpaq");
	}
	return("Archive C: from shell without admin rights");
}
#endif // corresponds to #ifdef (#ifdef _WIN32)
string help_find(bool i_usage,bool i_example)
{
	if (i_usage)
	{
		scrivi_riga("CMD find","Search file(s) with wildcards. DO NOT FORGET DOUBLE QUOTES ON *NIX!");
		scrivi_riga("-verbose", "Show date/size (default:NO)");
		help_date();
		help_size();
		help_orderby();
		scrivi_riga("-find", "Like grep -i");
	}
	if (i_usage && i_example) scrivi_examples();
	if (i_example)
	{
		scrivi_esempio("'Double filter'","find c:\\dropbox *.txt -minsize 1000000  -find franco");
		scrivi_esempio("Search in multiple folders","find c:\\uno z:\\kb -only *franco*");
		scrivi_esempio("Search file ending with 01.cpp","find c:\\zpaqfranz *01.cpp");
		scrivi_esempio("Search all .cpp","find c:\\zpaqfranz *.cpp -verbose");
		scrivi_esempio("Search *francia* BEWARE DOUBLE QUOTE","find /root \"*francia*\"");
		scrivi_esempio("Search filtered on date","find c:\\zpaqfranz *.cpp -datefrom 20220920 -dateto 2022-10-01");
		scrivi_esempio("Search every file of 2017","find . -datefrom 2017 -dateto 2017");
		scrivi_esempio("Search every EXE file of 2017","find . *.exe -datefrom 2017 -dateto 2017");
		scrivi_esempio("10 biggest cpp","find . *.cpp -orderby size -desc -limit 10 -verbose");
	}
	return("Search file(s) using wildcards");
}
string help_e(bool i_usage,bool i_example)
{

	if (i_usage)
	{
		scrivi_riga("CMD e","Extract on current folder");
		scrivi_riga(" ","Shortcut for extracting on Windows with longpath");
	}
	if (i_usage && i_example) scrivi_examples();
	if (i_example)
	{
		scrivi_esempio("Extract everything 'here'","e z:\\1.zpaq -longpath");
	}
	return("Extract file(s) to current folder");
}
string help_dirsize(bool i_usage,bool i_example)
{
	if (i_usage)
	{
		scrivi_riga("CMD dirsize","Show cumulative folder(s) size");
		scrivi_riga(" ","Case INsensitive ENDING with parameters (unless -force)");
		scrivi_riga(" ","i.e. marcus == /1/marcus, /tank/d/documenti/MARCUS");
		scrivi_riga("-force", "Exact match; /tank/marcus != /tank/MARCUS");
	}
	if (i_usage && i_example) scrivi_examples();
	if (i_example)
	{
		scrivi_esempio("Search with 2 parameters","dirsize z:\\1.zpaq marcus vanessa");
		scrivi_esempio("Getting size (insensitive)","dirsize z:\\1.zpaq /tank/d/documenti/marcus -force");
	}
	return("Show total folder(s) size");
}
#ifdef ZPAQFULL ///NOSFTPSTART
#ifdef _WIN32
string help_sfx(bool i_usage,bool i_example)
{
	if (i_usage)
	{
		scrivi_riga("CMD sfx","sfx module, with encryption support");
		scrivi_riga("(no switch)","Write SFX along the .zpaq");
		scrivi_riga("(w/switch)","Convert .zpaq (max 2GB) to Windows .EXE");
		scrivi_riga("-to X","Extract the .zpaq from a .exe into X");
	}
	if (i_usage && i_example) scrivi_examples();
	if (i_example)
	{
		scrivi_esempio("Create  z:\\1.exe","sfx z:\\1.zpaq");
		scrivi_esempio("Convert 1.zpaq to 2.exe","sfx z:\\1.zpaq -sfx z:\\2.exe");
		scrivi_esempio("Extract sfx module","sfx z:\\64bit.exe");
		scrivi_esempio("Extract the zpaq (if any)","sfx z:\\1.exe -to z:\\1.zpaq -space -force");
	}
	return("Create SFX module (supports encryption)");
}
#endif // corresponds to #ifdef (#ifdef _WIN32)
#endif ///NOSFTPEND
string help_rsync(bool i_usage,bool i_example)
{
	if (i_usage)
	{
		scrivi_riga("CMD rsync","Delete dangling temporary rsync file");
		scrivi_riga("-kill", "Wet run (default: dry run)");
	}
	if (i_usage && i_example) scrivi_examples();
	if (i_example)
	{
		scrivi_esempio("Purge temporary (dry run)","rsync \\\\nas\\thebackup");
		scrivi_esempio("Purge temporary (WET run)","rsync \\\\nas\\thebackup -kill");
	}
	return("Clean rsync dangling temp file(s)");
}
string help_checkpassword(bool i_usage,bool i_example)
{
	if (i_usage)
	{
		scrivi_riga("CMD checkpassword","Check if password is OK");
		scrivi_riga("-key X","Use X as password");
	}
	if (i_usage && i_example) scrivi_examples();
	if (i_example)
	{
		scrivi_esempio("Check if password is pippo","checkpassword file.zpaq -key pippo");
	}
	return("Check password");
}
string help_t(bool i_usage,bool i_example)
{

	if (i_usage)
	{
		scrivi_riga("CMD t","Test");
		scrivi_riga(" ","NO PATH:   check all blocks, and CRC-32s of the files");
		scrivi_riga(" ","           corresponds to what would be generated by extracting");
		scrivi_riga(" ","WITH PATH: compares files/folders in the path(s) with the");
		scrivi_riga(" ","           archive's content");
		scrivi_riga("-checksum", "Enable hash checksums");
		scrivi_riga("-verify", "Do a filesystem post-check: STORED CRC==DECOMPRESSED==FROM FILE.");
		scrivi_riga("-verify -ssd","Multithread verify (do NOT use on spinning drives)");
		scrivi_riga("-find", "pippo   For path-rework of verify");
		scrivi_riga("-replace", "plu  For path-rework of verify (find and replace)");
		scrivi_riga("-paranoid", "Extract all into -to something, check every file with stored hash");
		scrivi_riga(" ","delete every equal files");
		scrivi_riga("-collision", "Test collisions");
		scrivi_riga("-quick", "Do not check hash, only size/date");
		scrivi_riga("-crc32", "Run a triple CRC-32 check (!) against the filesystem");
		scrivi_riga(" ","Use -find/replace to fix path (if needed); -ssd for M/T");
		scrivi_riga("-ssd", "Run multithread CRC-32 rebuilder\n");
		scrivi_riga("-debug6", "Enforce CRC-32 error\n");
		
	}
	if (i_usage && i_example) scrivi_examples();
	if (i_example)
	{
		scrivi_esempio("Last version","t z:\\1.zpaq");
		scrivi_esempio("All versions","t z:\\1.zpaq -all");
		scrivi_esempio("Last+Against filesystem, 4 threads","t z:\\1.zpaq -verify -ssd -t4");
		scrivi_esempio("Real paranoid: extract all","t z:\\1.zpaq -to z:\\knb -paranoid");
		scrivi_esempio("Multiple paranoid check (Win)","t *.zpaq -to z:\\temp\\ -paranoid -longpath -big");
		scrivi_esempio("Multiple test (*NIX)","t \"/copie/*.zpaq\" ");
		scrivi_esempio("Compare with string manipulation","t z:\\2 c:\\nz -find k:\\nz -replace c:\\nz -verify");
		scrivi_esempio("All version SHA-1 collisions","t z:\\1.zpaq -collision -all");
		scrivi_esempio("Triple check CRC-32","t z:\\1.zpaq -crc32");
		scrivi_esempio("3 check w/path manipulation","t z:\\1.zpaq -crc32 -find \"x:/memme/\" -replace \"c:/nz/\"");
		color_yellow();
		moreprint("BEWARE: path(s) changes the logic!");
		color_restore();
		scrivi_esempio("Fast-SHA1 (nz the source dir)","t z:\\1.zpaq c:\\nz");
		scrivi_esempio("SHA1 + hash","t z:\\1.zpaq c:\\nz -verify");
		scrivi_esempio("Quick-and-dirty size/date","t z:\\1.zpaq c:\\nz c:\\kz -quick");
	}
	return("Test archive integrity or compare with filesystem");

}
string help_sync(bool i_usage, bool i_example)
{
    if (i_usage)
    {
        scrivi_riga("CMD sync","Compare archive content with filesystem folders");
        scrivi_riga("  ","Estimate size of new/changed data to be compressed");
        scrivi_riga("-quick", "Compare only file sizes (skip hash verification)");
        scrivi_riga("-ssd", "Use multithreaded hashing for faster processing");
    }
    if (i_usage && i_example) scrivi_examples();
    if (i_example)
    {
        scrivi_esempio("(example) Archive with 3 folders","a z:\\1.zpaq c:\\zpaqfranz c:\\nz c:\\ut");
        scrivi_esempio("Check all 3 folders against archive","sync z:\\1.zpaq c:\\zpaqfranz c:\\nz c:\\ut");
        scrivi_esempio("Check only 2 specific folders","sync z:\\1.zpaq c:\\nz c:\\ut");
        scrivi_esempio("Check with multithreaded hashing","sync z:\\1.zpaq c:\\nz -ssd");
        scrivi_esempio("Quick size-only comparison","sync z:\\1.zpaq c:\\nz -quick");
        scrivi_esempio("Check specific subfolder only","sync z:\\1.zpaq c:\\zpaqfranz\\release -ssd");
    }
    return("Compare archive with filesystem");
}
string help_v(bool i_usage,bool i_example)
{
	if (i_usage)
	{
		moreprint("CMD   v (verify)","Verify all files (by hashes) against filesystem");
		scrivi_riga("-ssd", "Multithread (for SSD/NVMe). Do NOT use on spinning drives");
		scrivi_riga("-tX", "Limit -ssd to X threads");
		scrivi_riga("-until Y", "Check the version Y");
		scrivi_riga("-find", "pippo   For path-rework of verify");
		scrivi_riga("-replace", "plu  For path-rework of verify (find and replace)");
		scrivi_riga("-verbose", "Show distinct errors");
		scrivi_riga("-debug", "Show a lot of info");
		scrivi_riga("-output x.txt","Put errors in x.txt (alias -out)");
	}
	if (i_usage && i_example) scrivi_examples();
	if (i_example)
	{
		scrivi_esempio("Last version","v z:\\1.zpaq");
		scrivi_esempio("Show errors line by line","v z:\\1.zpaq -verbose");
		scrivi_esempio("2n version","v z:\\1.zpaq -until 2");
		scrivi_esempio("Remake path","v z:\\1.zpaq -find c:\\dropbox -replace z:\\knb");
		scrivi_esempio("1st version, multithread","v z:\\1.zpaq -until 1 -ssd");
	}

	return ("Verify an archive (against filesystem)");
}
string help_p(bool i_usage,bool i_example)
{

	if (i_usage)
	{
		scrivi_riga("CMD p","Paranoid test");
		scrivi_riga(" ","Test the archive (** NOT multipart **) in a very paranoid fashion.");
		scrivi_riga(" ","ZPAQ reference decompressor is used to extract blocks in RAM.");
		scrivi_riga(" ","Runs on unzpaq206.cpp source instead of 7.15 extract: double check");
		scrivi_riga(" ","to avoid the risk of 'silent' bugs. The RAM needed can");
		scrivi_riga(" ","quickly become unmanageable (warn: be very careful with 32bit versions)");
		scrivi_riga("-noeta", "Brief");
		scrivi_riga("-verbose", "Shows positive checks");
		scrivi_riga("-verify", "Next level (mine) of paranoia: check hashes against the filesystem.");
		scrivi_riga(" ","Essentially equivalent to extracting in a temporary folder and check");
		scrivi_riga(" ","against initial folders. For very paranoid people, or debug reason.");
	}
	if (i_usage && i_example) scrivi_examples();
	if (i_example)
	{
		scrivi_esempio("Paranoid, use a lot of RAM","p z:\\1.zpaq");
		scrivi_esempio("Very paranoid, use a lot of RAM","p z:\\1.zpaq -verify");
	}
	return("Paranoid archive test (slow, high RAM)");

}
string help_c(bool i_usage,bool i_example)
{

	if (i_usage)
	{
		scrivi_riga("CMD c","Compare dirs");
		scrivi_riga(" ","Compare a 'master' directory (d0) against N 'slaves' (d1, d2... dN).");
		scrivi_riga(" ","This is ideal for verifying replicated folders (e.g., created by zpaq");
		scrivi_riga(" ","restore, rsync, robocopy, or ZFS replica), especially across different");
		scrivi_riga(" ","filesystems (like Linux NAS and Windows NTFS)");
		scrivi_riga(" ","By default check file name and file size (excluding .zfs), not the content.");
		scrivi_riga("-ssd", "Concurrent threads will be created, each scan a slave dir (-t K to limit).");
		scrivi_riga(" ","Not recommended for a single spinning drive; ideal for multiple target");
		scrivi_riga(" ","directories on different physical disks");
		help_printhash(false);
		help_size();
		scrivi_riga("-715", "Work as 7.15 (with .zfs and ADS)");
		scrivi_riga("-forcezfs", "Include .zfs");
		scrivi_riga("-checksum", "Run hash compare");

	}
	if (i_usage && i_example) scrivi_examples();
	if (i_example)
	{
		scrivi_esempio("Compare master d0 against d1,d2,d3","c c:\\d0 k:\\d1 j:\\d2 p:\\d3");
		scrivi_esempio("Multithread compare","c c:\\d0 k:\\d1 j:\\d2 p:\\d3 -ssd");
		scrivi_esempio("Hashed compare d0 against d1,d2,d3","c c:\\d0 k:\\d1 j:\\d2 p:\\d3 -checksum -xxh3");
	}
	return("Compare master dir vs slave dir(s)");

}
string help_s(bool i_usage,bool i_example)
{
	if (i_usage)
	{
		scrivi_riga("CMD s","Size");
		scrivi_riga(" ","Cumulative size of N directory, and free space (estimate for *Nix).");
		scrivi_riga(" ","Everything containing .zfs and :$DATA (Windows's ADS) ignored by default");
		scrivi_riga(" ","Very quick-and-dirty check of rsynced folders against the master");
		scrivi_riga("-ssd", "for multithreaded executions (warning for single spinning drive)");
		scrivi_riga("-minsize X","Show a warning if free space < X");
		scrivi_riga("-715", "Work as 7.15 (with .zfs and ADS)");
		scrivi_riga("-forcezfs", "Include .zfs");
		scrivi_riga("-home", "Show 1-level cumulative size");
		scrivi_riga("-ignore", "Do not show file errors (ex. ERROR_ACCESS_DENIED)");
	}
	if (i_usage && i_example) scrivi_examples();
	if (i_example)
	{
		scrivi_esempio("Dir cumulative size (no .zfs/NTFS)","s r:\\vbox s:\\uno");
		scrivi_esempio("Multithreaded size","s r:\\vbox s:\\uno -ssd");
		scrivi_esempio("(Kind of) size of c:\\users","s c:\\users -home -ssd -ignore");
	}
	return("Show dir(s) size and free disk space");

}


string help_oneonone(bool i_usage,bool i_example)
{
	if (i_usage)
	{
		scrivi_riga("CMD 1on1","Julius Erving and Larry Bird Go One on One");
		scrivi_riga(" ","Deduplicate a folder against another one");
		scrivi_riga("-deleteinto X", "Delete corresponding files found in directory X");
		scrivi_riga("-checksum", "Rely only on checksums, not filenames");
		///scrivi_riga("-zero", "Deduplicate 0-length files too");
		scrivi_riga("-ssd", "Enable multithreading (use with care on single spinning drives)");
		scrivi_riga("-forcezfs", "Do not exclude zfs files (default: IGNORE)");
		scrivi_riga("-kill", "Perform a wet run (default is a dry run)");
		help_printhash(false);
	}
	if (i_usage && i_example) scrivi_examples();
	if (i_example)
	{
		scrivi_esempio("Dry run, =hash,=filename,multithread","1on1 c:\\dropbox -deleteinto z:\\pippero2 -ssd");
		scrivi_esempio("Real run, 0-files too","1on1 c:\\dropbox -deleteinto z:\\pippero2 -zero -kill");
		scrivi_esempio("Real run, with XXH3, with *","1on1 c:\\dropbox -deleteinto z:\\pippero2 -xxh3 -kill -forcezfs");
	}
	return("Delete folder2 file(s) matching folder1's name/hash");
}


string help_r(bool i_usage,bool i_example)
{
	if (i_usage)
	{
		scrivi_riga("CMD r","'robocopy'");
		scrivi_riga(" ","Mirror a master folder, just like robocopy /mir or rsync -a --delete");
		scrivi_riga(" ","to one or more slave (destination) folders");
		print_sub();
		scrivi_riga(" ","ENFORCING XLS, ignore .zfs and ADS by default");
		scrivi_riga("", "ENFORCING XLS, ignore .zfs and ADS by default");
		scrivi_riga("-kill", "wet run (default: dry-run");
		scrivi_riga("-space", "do not exit if not enough space reported");
		scrivi_riga("-ssd", "run one thread for folder");
		scrivi_riga("-verify", "after copy quick check if OK (only filename and size)");
		scrivi_riga("-checksum", "heavy (hash) test of equality. Suggest: -xxh3 fast and reliable.");
		help_size();
		scrivi_riga("-xls", "Do not enforce backup of XLS/PPT");
		scrivi_riga("-715", "Work as 7.15 (with .zfs and ADS)");
		scrivi_riga("-forcezfs", "Include .zfs");
		scrivi_riga("-append", "Only append data (*risky, use with zpaq archives)");
		scrivi_riga("-zero", "Fill all output file with zeros (for debug)");
		scrivi_riga("-verbose", "Show internal timings");
		scrivi_riga("-buffer X", "Use a input buffer of X bytes (default: 1MB)");
		scrivi_riga("-pakka", "Check-before-touch (faster for big tree over LAN)");
#ifdef _WIN32
		scrivi_riga("-big", "Special Windows function for big files over LAN");
#endif // corresponds to #ifdef (#ifdef _WIN32)
		scrivi_riga("-bandwidth X", "Limit to X the write rate");


	}
	if (i_usage && i_example) scrivi_examples();
	if (i_example)
	{
		scrivi_esempio("Robocopy d0 in d1,d2      (dry run)","r c:\\d0 k:\\d1 j:\\d2 p:\\d3");
		scrivi_esempio("Robocopy d0 in d1,d2      (WET run)","r c:\\d0 k:\\d1 j:\\d2 p:\\d3 -kill");
		scrivi_esempio("Robocopy with verify      (WET run)","r c:\\d0 k:\\d1 j:\\d2 p:\\d3 -kill -verify");
		scrivi_esempio("Robocopy with hash verify (WET run)","r c:\\d0 k:\\d1 j:\\d2 p:\\d3 -kill -verify -checksum -xxh3");
		scrivi_esempio("Robocopy d0 in d1, forced (WET run)","r c:\\d0 k:\\d1 j:\\d2 -kill -space");
		scrivi_esempio("Robocopy append mode      (WET run)","r c:\\d0 z:\\backup_%day -append -kill");
		scrivi_esempio("Robocopy d0 in d1,w/infos (WET run)","r c:\\d0 k:\\d1 -kill -verbose");
		scrivi_esempio("Robocopy d0=>d1 over LAN  (WET run)","r c:\\d0 \\\\nas\\d1 -kill -verbose -pakka");
#ifdef _WIN32
		scrivi_esempio("Huge file to NAS (Windows)(WET run)","r c:\\d0 \\\\nas\\share\\d1 -kill -big");
#endif // corresponds to #ifdef (#ifdef _WIN32)
		scrivi_esempio("Robocopy only huge files  (WET run)","r c:\\d0 z:\\dest -kill -minsize 10GB");
		scrivi_esempio("Robocopy only E01 files   (WET run)","r c:\\d0 z:\\dest -kill -only *.e01");
		scrivi_esempio("Robocopy limited to 100MB/s (WET run)","r c:\\d0 k:\\d1 -kill -bandwidth 100M");

	}
	return("Robocopy master to multiple slave folders");
}
string help_cp(bool i_usage,bool i_example)
{
	if (i_usage)
	{
		scrivi_riga("CMD cp","'friendly copy'");
		scrivi_riga(" ","Copy files (with wildcards) into -to folder");
		scrivi_riga(" ","with 1 sec progression feedback. Huge file, tiny bandwidth");
		scrivi_riga(" ","and unreliable media (-verify)");
		scrivi_riga(" ","By default overwrite, use -paranoid to create unique name");
		scrivi_riga("-verify", "Do an heavy (XXH3) check of copied data");
		scrivi_riga("-paranoid", "Rename output file to do not overwrite");
		scrivi_riga("-append", "Only append data (*risky, use with zpaq archives)");
		scrivi_riga("-force", "Do no check if destination is writeable");
		scrivi_riga("-space", "Do no check if enough destination free space");
	}
	if (i_usage && i_example) scrivi_examples();
	if (i_example)
	{
		scrivi_esempio("Copy k:\\*.mp4 d:\\a.txt in z:\\pluto","cp k:\\*.mp4 d:\\a.txt -to z:\\pluto");
		scrivi_esempio("Copy with verify","cp k:\\*.mp4 -to z:\\pluto -verify");
		scrivi_esempio("Copy WITHOUT overwrite","cp k:\\*.mp4 -to z:\\pluto -paranoid");
		scrivi_esempio("Resumable copy (append only)","cp k:\\*.zpaq -to z:\\pluto -append");
	}
	return("Friendly file copy with ETA (resumable)");

}
#ifdef ZPAQFULL ///NOSFTPSTART
string help_zfs(bool i_usage,bool i_example)
{
	if (i_usage)
	{
		scrivi_riga("On UNIX you get some zfs-specific commands","");
		scrivi_riga("--- Enumerate / delete snapshots / sizeof","");
		scrivi_riga("zfslist","");
		scrivi_riga("zfspurge","");
		scrivi_riga("zfssize","");
		scrivi_riga("--- Freezing snapshot inside archive","");
		scrivi_riga("zfsadd","");
		scrivi_riga("--- Make / restore zfs backups inside zpaq","");
		scrivi_riga("zfsbackup","");
		scrivi_riga("zfsreceive","");
		scrivi_riga("zfsrestore","");
		scrivi_riga("--- Make / restore zfs backups of proxmox VM","");
		scrivi_riga("zfsproxbackup","");
		scrivi_riga("zfsproxrestore","");
	}
	if (i_example)
	{
		moreprint("Ask extensive help, example zpaqfranz h zfsadd       zpaqfranz h zfslist");
	}
	return "Bunch of zfs-specific commands";
}
string help_zfsadd(bool i_usage,bool i_example)
{
	if (i_usage)
	{
		scrivi_riga("CMD zfsadd","Freeze a selection of snapshots into an archive");
		scrivi_riga(" ","Optional subfolder as 3rd parameter");
		scrivi_riga("-script", "pi.sh Write a script-ready on pi.sh (alias -out)");
		scrivi_riga("-force", "Do the freezing (wet run)");
	}
	if (i_usage && i_example) scrivi_examples();	
	if (i_example)
	{
		scrivi_esempio(" ","!USE THE DOUBLEQUOTES!");
		scrivi_esempio(" ","BEWARE of single -  \"-pippo\" DOES NOT WORK!");
		scrivi_esempio(" ","zfsadd /tmp/kong.zpaq \"tank/d@2021\" \"--60d\"");
		scrivi_esempio(" ","zfsadd /tmp/kong.zpaq \"tank/d@2021\" \"--60d\" \"scanner\"");
		scrivi_esempio(" ","zfsadd /tmp/kong.zpaq \"tank/d@2021\" \"--60d\" \"scanner\" -force");
		scrivi_esempio(" ","zfsadd /tmp/kong.zpaq \"tank/d@2021\" \"--60d\" \"scanner\" -script ./dothejob.sh");
	}
	return("Freeze zfs' snapshots inside the archive");
}
string help_zfspurge(bool i_usage,bool i_example)
{
	if (i_usage)
	{
		scrivi_riga("CMD zfspurge","Destroy selected zfs snapshot (works like zfslist)");
		scrivi_riga("-script", "pi.sh Write a script-ready on pi.sh (alias -out)");
	}
	if (i_usage && i_example) scrivi_examples();
	if (i_example)
	{
			scrivi_esempio(" ","!USE THE DOUBLEQUOTES!");
			scrivi_esempio(" ","BEWARE of single -  \"-pippo\" DOES NOT WORK!");
			scrivi_esempio(" ","zfspurge \"tank/d@2021\" \"--60d\"");
			scrivi_esempio(" ","zfspurge \"*\" \"*\"");
			scrivi_esempio(" ","zfspurge \"tank\" \"--7d\"");
			scrivi_esempio(" ","zfspurge \"tank\" \"--7d\" -script mygoodscript.sh");
	}
	return("Purge snapshots with wildcards");

}
string help_zfslist(bool i_usage,bool i_example)
{
	if (i_usage)
	{
		scrivi_riga("CMD zfslist","Show (/filtering) existing zfs snapshot");
		scrivi_riga("-script", "pi.sh Write a script-ready on pi.sh (alias -out)");
	}
	if (i_usage && i_example) scrivi_examples();
	if (i_example)
	{
		if ((g_optional=="zfslist") || (g_optional==""))
		{
			scrivi_esempio(" ","!USE THE DOUBLEQUOTES!");
			scrivi_esempio(" ","BEWARE of single -  \"-pippo\" DOES NOT WORK!");
			scrivi_esempio(" ","zfslist  \"tank/d@\"");
			scrivi_esempio(" ","zfslist  \"*\"");
			scrivi_esempio(" ","zfslist  \"*\" \"syncoid\"");
			scrivi_esempio(" ","zfslist  \"*\" \"10d\" -script pippo.sh");
		}
	}
	return("List zfs' snapshots with wildcard");
}

string help_zfssize(bool i_usage,bool i_example)
{
	if (i_usage)
	{
		scrivi_riga("CMD zfssize","Show (/filtering) the SIZE of existing zfs snapshot");
	}
	if (i_usage && i_example) scrivi_examples();
	if (i_example)
	{
		if ((g_optional=="zfssize") || (g_optional==""))
		{
			scrivi_esempio(" ","!USE THE DOUBLEQUOTES!");
			scrivi_esempio(" ","BEWARE of single -  \"-pippo\" DOES NOT WORK!");
			scrivi_esempio(" ","zfssize  \"tank/d@\"");
			scrivi_esempio(" ","zfssize  \"*\"");
			scrivi_esempio(" ","zfssize  \"*\" \"syncoid\"");
			scrivi_esempio(" ","zfssize  \"*\" \"10d\" -script pippo.sh");
		}
	}
	return("List zfs' SIZE of snapshots with wildcard");
}

string help_zfsproxbackup(bool i_usage,bool i_example)
{
	if (i_usage)
	{
		scrivi_riga("CMD zfsproxbackup","");
		scrivi_riga(" ","Archiving proxmox backups (from zfs local storage)");
		scrivi_riga(" ","Getting VM disks from /var/lib/vz");
		scrivi_riga("-force", "Destroy temporary snapshot (before backup)");
		scrivi_riga("-kill", "Remove snapshot (after backup)");
		scrivi_riga("-all", "Get all VM");
		scrivi_riga("-not", "Do not backup (exclude)");
		scrivi_riga("-snapshot", "kj  Make 'snapname' to kj (default: francoproxmox)");
	}
	if (i_usage && i_example) scrivi_examples();
	if (i_example)
	{
		scrivi_esempio("Backup/encrypt w/key 'pippo' VM 200","zfsproxbackup /bak/200.zpaq 200 -force -kill -key pippo");
		scrivi_esempio("Backup 2 VMs: 200 and 300","zfsproxbackup /bak/200_300.zpaq 200 300");
		scrivi_esempio("Backup ALL VMs","zfsproxbackup /bak/all.zpaq  -all -force -kill");
		scrivi_esempio("Backup all EXCEPT 200 and 300","zfsproxbackup /bak/part.zpaq -all -not 200 -not 300 -force -kill");
	}
	return("Backup of proxmox on zfs");
}

string help_zfsproxrestore(bool i_usage,bool i_example)
{
	if (i_usage)
	{
		scrivi_riga("CMD zfsproxrestore","Restore proxmox backups (on local storage)");
#ifndef _WIN32
		scrivi_riga(" ","into /var/lib/vz and /etc/pve/qemu-server");
		scrivi_riga(" ","Without files selection restore everything");
#endif
		scrivi_riga(" ","Files can be a sequence of WMIDs (ex. 200 300)");
		scrivi_riga("-kill", "Remove snapshot (after backup)");
		scrivi_riga("-not", "Do not restore (exclude)");
	}
	if (i_usage && i_example) scrivi_examples();
	if (i_example)
	{
		scrivi_esempio("Restore all VMs","zfsproxrestore /backup/allvm.zpaq");
		scrivi_esempio("Restore 2 VMs: 200 and 300","zfsproxrestore /backup/allvm.zpaq 200 300");
		scrivi_esempio("Restore VM 200, release snapshot","zfsproxrestore /backup/allvm.zpaq 200 -kill");
		scrivi_esempio("Restore all VMs, except 200","zfsproxrestore /backup/allvm.zpaq -not 200 -kill");
	}
	return("Restore of proxmox on zfs");
}
string help_zfsbackup(bool i_usage,bool i_example)
{
	if (i_usage)
	{
		scrivi_riga("CMD zfsbackup","Backup w/incremental zfs snapshots for long-term storage");
		scrivi_riga(" ","Usually root privileges required");
		scrivi_riga("-snapshot kj","Make 'snapname' to kj (default: zpaqfranco)");
	}
	if (i_usage && i_example) scrivi_examples();
	if (i_example)
	{
			scrivi_esempio("Update tank/d backup,retain snapshot","zfsbackup /tmp/incr.zpaq tank/d");
			scrivi_esempio("Update tank backup,delete snapshot","zfsbackup /tmp/incr.zpaq tank -kill");
			scrivi_esempio("Update tank/d backup,w/hashdeep","zfsbackup /tmp/incr.zpaq tank/d");
			scrivi_esempio("Choose snapmark to 'mycopy'","zfsbackup /tmp/incr.zpaq tank/d -snapshot mycopy");
	}
	return("Backup of zfs' streams");
}

string help_zfsrestore(bool i_usage,bool i_example)
{
	if (i_usage)
	{
		scrivi_riga("CMD zfsrestore","Prepare a script for restoring from EXTRACTED .zfs backup files");
		scrivi_riga("-snapshot kj","Make 'snapname' to kj (default: franco)");
	}
	if (i_usage && i_example) scrivi_examples();
	if (i_example)
	{
		scrivi_esempio("Restore *.zfs into /rez to rpool/rk","zfsrestore /rez rpool/rk -script myscript.sh");
		scrivi_esempio("Restore *.zfs into /rez to rpool/rk","zfsrestore /rez rpool/rk -script myscript.sh -snapshot ugo");
	}
	return("Restore from extracted .zfs stream");
}

string help_zfsreceive(bool i_usage,bool i_example)
{
	if (i_usage)
	{
		scrivi_riga("CMD zfsreceive","Prepare a script for restoring from zpaq archive");
		scrivi_riga("-snapshot", "kj  Make 'snapname' to kj (default: franco)");
	}
	if (i_usage && i_example) scrivi_examples();
	if (i_example)
	{
		scrivi_esempio("Rebuild rpool/restored from archive","zfsreceive /tmp/ordinato.zpaq rpool/restored -script myscript.sh");
	}
	return("Restore (with zfs) from zpaq archive");
}
#endif ///NOSFTPEND

string help_z(bool i_usage,bool i_example)
{
	if (i_usage)
	{
		scrivi_riga("CMD z","Delete empty directories, zero length");
		scrivi_riga(" ","Remove empty directories in d0...dK folders. Conservative (ex hidden Thumbs.db)");
		scrivi_riga("-kill", "Do a wet run (default dry run)");
		scrivi_riga("-verbose", "Show infos");
#ifdef _WIN32
		scrivi_riga("-longpath", "Extracting on Windows filenames longer than 255");
#endif // corresponds to #ifdef (#ifdef _WIN32)
	}
	if (i_usage && i_example) scrivi_examples();
	if (i_example)
	{
		scrivi_esempio("Delete empty dirs in d0,d1(dry run)","z c:\\d0 k:\\d1");
		scrivi_esempio("Delete empty dirs in d0,d1(WET run)","z c:\\d0 k:\\d1 -kill -longpath");
	}
	return("Remove empty directories");
}
string help_m(bool i_usage,bool i_example)
{
	if (i_usage)
	{
		scrivi_riga("CMD m","merge, consolidate");
		scrivi_riga(" ","Merge a split (multipart) archive into a single one,");
		scrivi_riga(" ","just like a concatenated cat or copy /b");
		scrivi_riga("-force", "Overwrite existing output");
		scrivi_riga("-space", "Ignore lack of free space");
		scrivi_riga("-verify", "Double-check (XXH3 hash test)");
	}
	if (i_usage && i_example) scrivi_examples();
	if (i_example)
	{
		scrivi_esempio("Merge (consolidate) multipart","m \"p:\\test\\prova_???\" z:\\cons.zpaq -verify");
	}
	return("Merge multipart archive into one");
}
string help_d(bool i_usage,bool i_example)
{
	if (i_usage)
	{
		scrivi_riga("CMD d","Deduplicate");
		scrivi_riga(" ","Find and delete duplicate files in a single folder.");
		scrivi_riga(" ","WARNING: This operation is destructive!");
		scrivi_riga(" ","Note: The folder path must end with a path separator ('/' or '\')");
		scrivi_riga("-ssd", "Multithread run");
		scrivi_riga("-force", "Wet run (default: dry-run)");
		scrivi_riga("-verbose", "Show duplicated files");
		scrivi_riga("-(somehash)", "Use (somehash), one of the available next two lines, for detection");
		help_printhash(false);
	}
	if (i_usage && i_example) scrivi_examples();
	if (i_example)
	{
		scrivi_esempio("Deduplicate d0 (dry run, w/xxh3)","d c:\\d0\\");
		scrivi_esempio("Deduplicate d0 (dry run,xxh3,M/T)","d c:\\d0\\ -ssd");
		scrivi_esempio("Deduplicate d0 WITHOUT MERCY (wet)","d c:\\d0\\ -kill");
		scrivi_esempio("Dedup WITHOUT MERCY (wet run,sha256)","d c:\\d0\\ -force -sha256");
	}
	return("Deduplicate file(s) in folder (no mercy)");

}
string help_mysqldump(bool i_usage,bool i_example)
{
	if (i_usage)
	{
		if (i_usage)
		{
			scrivi_riga("CMD mysqldump","Dump all MySQL/MariaDB databases");
			scrivi_riga(" ","Requires 'mysql' (or 'mariadb') and 'mysqldump' (or 'mariadb-dump')");
#ifdef _WIN32
			scrivi_riga(" ","On Windows, append '.exe' to executable names [of course]");
#endif
			scrivi_riga(" ","Use one of these methods to locate executables:");
			scrivi_riga(" ","- Specify path with -bin something");
			scrivi_riga(" ","- Let the program search automatically (default)");
#ifdef _WIN32
			scrivi_riga(" ","- Use -space to download from the Internet (Windows only)");
#endif
			scrivi_riga("-bin path","Path where mysql/mariadb(.exe) and mysqldump/mariadb-dump(.exe) are located");
#ifdef _WIN32
			scrivi_riga("-space", "Download mysql.exe and mysqldump.exe from the Internet");
#endif
			scrivi_riga("-u user","MySQL/MariaDB username");
			scrivi_riga("-p password","MySQL/MariaDB password (use quotes if it contains spaces)");
			scrivi_riga("-h host","MySQL/MariaDB host (e.g., localhost or IP address)");
			scrivi_riga("-P port","MySQL/MariaDB port (default: 3306)");
			scrivi_riga("-key pwd","Password for encrypting the ZPAQ archive");
			scrivi_riga("-mX", "ZPAQ compression method (X = 0-5, none to highest)");
			scrivi_riga("-verbose", "Be... verbose");
			scrivi_riga("-only", "pattern Select only databases containing the specified text or matching pattern");
			scrivi_riga(" ","-only 2015 matches any DB containing '2015' (e.g., db2015, test2015prod)");
			scrivi_riga("-not", "pattern  Exclude databases containing the specified text or matching pattern");
			scrivi_riga(" ","-not temp matches any DB containing 'temp' (e.g., temporary, temp_db)");
			scrivi_riga(" ","*** Note: System databases (information_schema, performance_schema,");
			scrivi_riga(" ","    sys) are automatically excluded");
		}
	}
	if (i_usage && i_example) scrivi_examples();
	if (i_example)
	{
		scrivi_esempio("Dump all databases (Windows)","mysqldump z:\\1.zpaq -u root -p pluto -h 127.0.0.1 -P 3306 -key pippo -m2");
		scrivi_esempio("Get tools from Internet (Windows)","mysqldump z:\\1.zpaq -u root -p pluto -space");
		scrivi_esempio("Auto-search on Linux","mysqldump /tmp/test.zpaq -u root -p pluto");
		scrivi_esempio("Specify path on Linux","mysqldump /tmp/test.zpaq -u root -p pluto -bin \"/bin\"");
		scrivi_esempio("Include databases with '2015'","mysqldump test.zpaq -u root -p pluto -only 2015");
        scrivi_esempio("Exclude databases with 'geo'","mysqldump test.zpaq -u root -p pluto -not geo");
        scrivi_esempio("Multiple conditions","mysqldump test.zpaq -u root -p pluto -only prod -not backup");
    }
	return("Dump all MySQL databases to .zpaq");

}

string help_ntfs(bool i_usage,bool i_example)
{
	if (i_usage)
	{
		if (i_usage)
		{
			scrivi_riga("CMD ntfs","Restore zpaqfranz's NTFS images to raw");
			scrivi_riga("-to", "out.raw   Write to full-size raw image");
		}
	}
	if (i_usage && i_example) scrivi_examples();
	if (i_example)
	{
		scrivi_esempio("Restore to raw","ntfs z:\\1.img -to z:\\restored.raw");
    }
	return("Restore zpaqfranz NTFS images");
}
string help_drive(bool i_usage,bool i_example)
{
	if (i_usage)
	{
		if (i_usage)
		{
			scrivi_riga("CMD drive","Show Windows' drive(s)");
		}
	}
	if (i_usage && i_example) scrivi_examples();
	if (i_example)
	{
		scrivi_esempio("Show drives","drive");
		scrivi_esempio("Show drives","drives");
    }
	return("List Windows drives");
}

string help_utf(bool i_usage,bool i_example)
{
	if (i_usage)
	{
		scrivi_riga("CMD utf","deal with strange filenames");
		scrivi_riga(" ","Check (or sanitize) paths with non-latin chars");
		scrivi_riga(" ","Can become a real problem extracting on different filesystems (ex. *nix => NTFS)");
		scrivi_riga("-kill", "Wet run (default dry run)");
		scrivi_riga("-verbose", "Show what is running");
		scrivi_riga("-fix255", "Show files too long");
		/*
		scrivi_riga("-utf", "Sanitize filenames (strip non-latin)");
		scrivi_riga("-fix255", "Sanitize file length and filecase collisions pippo.txt PIPPO.txt)");
		scrivi_riga("-fixeml", "Sanitize .eml filenames (Fwd Fwd Fwd => Fwd)");
		scrivi_riga("-dirlength", "X  Set the 'fix' limit");
		scrivi_riga("-filelength", "Y Set the 'fix' limit");
		*/
	}
	if (i_usage && i_example) scrivi_examples();
	if (i_example)
	{
		scrivi_esempio("Check UTF-filenames (dry run)","utf z:\\knb");
		scrivi_esempio("Sanitize UTF-filenames (wet run)","utf z:\\knb -kill");
		/*
		moreprint("Check >255 and case collisions:      utf z:\\knb -fix255");
		moreprint("Fix .eml filenames (dry run):        utf z:\\knb -fixeml");
		*/
	}
	return("Fix long names, convert to Latin charset");

}
string help_f(bool i_usage,bool i_example)
{
	if (i_usage)
	{
		scrivi_riga("CMD f","(fill, or wipe)");
		scrivi_riga(" ","Fill (wipe) 99% of free disk space in 500MB chunks");
		scrivi_riga(" ","Stress-testing a storage subsystem (disk,controller,cache,cables)");
		scrivi_riga("-verbose", "Show write speed (useful to check speed consistency)");
		scrivi_riga("-force", "Do NOT delete (after run) the temporary filename. By default free");
		scrivi_riga("-zero", "Zero-fill instead of random. Use to prepare a thin VMDK shrink");
		scrivi_riga("-verify", "For -zero: do a verify.");
	}
	if (i_usage && i_example) scrivi_examples();
	if (i_example)
	{
		scrivi_esempio("Fill (wipe) almost all free space","f z:\\");
		scrivi_esempio("Fill (wipe) keep temp files","f z:\\ -force -verbose");
		scrivi_esempio("Zero free space (VM shrink)","f z:\\ -zero");
		scrivi_esempio("Zero free space (WITH verify)","f z:\\ -zero -verify");
	}
	return("Fill/wipe disk (for reliability/privacy)");

}
string help_summa(bool i_usage,bool i_example)
{
	if (i_usage)
	{
		scrivi_riga("CMD sum","");
		scrivi_riga("CMD sha1","(retained for historical reasons, 7.15 always uses SHA-1 only)");
		scrivi_riga(" ","Calculate hash/cksum of files/dirs, dupes and cumulative GLOBAL SHA256");
		scrivi_riga(" ","(If two directories have the same GLOBAL SHA256 they are ==)");
		scrivi_riga(" ","Default: -sha1 | Faster: -blake3 | Fastest: -xxh3 | Safer: -sha256");
		scrivi_riga(" ","BTW use 'hash' (not 'sum') for md5sum/sha1sum-like output format");
		scrivi_riga(" ","Use -out to save hashes to a .sfv-style file for later verification");
		help_printhash(false);
		scrivi_riga("-ssd", "make N thread (do not use with spinning HDDs, but SSDs and NVMes)");
		scrivi_riga("-mm", "use memory mapped file instead of 'regular' fread");
		scrivi_riga("-kill", "show the files to be deleted to manually deduplicate");
		scrivi_riga("-home", "get a 1-level checksum, for comparing hierarchically user-organized folders.");
		scrivi_riga("-summary", "show only GLOBAL (fast manual compare of directories)");
		scrivi_riga("-rename", "rename all files with the hash");
		scrivi_riga("-forcezfs", "force .zfs path (DEFAULT: skip)");
		scrivi_riga("-kill -force","runs a deduplication without ask anything!");
		help_size();
		scrivi_riga("-715", "Work as 7.15 (with .zfs and ADS)");
		scrivi_riga("-checktxt kaj", "Check MD5 against kaj file. For rsync/rclone sync");
		scrivi_riga("-hashdeep", "Make (into mandatory -out) hashdeep-compatible output");
		scrivi_riga("-zeta", "Make the ZETA hash");
		scrivi_riga("-zetaenc", "Make the ZETA-encrypted hash");
		help_orderby();
		scrivi_riga("-last", "Get only the last file");
		scrivi_riga("-norecursion", "Disable recursion");
		
	}
	if (i_usage && i_example) scrivi_examples();
	if (i_example)
	{
		scrivi_esempio("SHA1 of all files (and duplicated)","sum z:\\knb");
		scrivi_esempio("SHA1 multithread, only summary","sum z:\\knb -ssd -summary");
		scrivi_esempio("XXH3 multithread","sum z:\\knb -ssd -xxh3");
		scrivi_esempio("CRC-32c HW accelerated","sum z:\\knb -crc32c -pakka -noeta");
		scrivi_esempio("Hashes to be compared (dir1)","sum c:\\nz  -pakka -noeta -nosort -crc32c -find c:\\nz  -replace bakdir >1.txt");
		scrivi_esempio("Hashes to be compared (dir2)","sum z:\\knb -pakka -noeta -nosort -crc32c -find z:\\knb -replace bakdir >2.txt");
		scrivi_esempio("Duplicated files with sha256","sum z:\\knb -kill -sha256");
		scrivi_esempio("Duplicated files minsize 1000000","sum z:\\knb -kill -ssd -minsize 1000000");
		scrivi_esempio("MAGIC cumulative hashes of 1-level","sum p:\\staff -xxh3 -home -ssd");
		scrivi_esempio("BLAKE3 multithread from memory map","sum z:\\knb -ssd -blake3 -mm");
		scrivi_esempio("MD5 quick check","sum z:\\knb.zpaq -checktxt z:\\pippo.txt");
		scrivi_esempio("hashdeep-compatible (multithread)","sum *.jpg *.cpp -md5 -hashdeep -ssd -out z:\\thehash.txt");
		scrivi_esempio("like md5sum","sum *.txt -md5 -pakka -noeta -stdout -nosort");
		scrivi_esempio("Order the output","sum z:\\ -xxh3 -orderby size -desc -only *.cpp");
		scrivi_esempio("ZETA multithread","sum z:\\knb -ssd -zeta");
		scrivi_esempio("ZETA on last","sum z:\\knb -zeta -last");
		scrivi_esempio("Silently create SFV-style hash file", "sum c:\\nz -ssd -xxh3 -out Z:\\pippo.txt -silent");
		scrivi_esempio("Verify SFV file (multi-thread)", "versum Z:\\pippo.txt -ssd");
		scrivi_esempio("Only current files", "sum * -norecursion");
	}
	return("Calculate hashes, find duplicate file(s)");

}
string help_hasha(bool i_usage,bool i_example)
{
	if (i_usage)
	{
		scrivi_riga("CMD hash","Calculate hash of files/dirs");
		scrivi_riga(" ","With no switches, by default, use SHA-1 (reliable, but not very fast)");
		help_printhash(false);
		scrivi_riga("-ssd", "make N thread (do not use with spinning HDDs, but SSDs and NVMes)");
		scrivi_riga("-mm", "use memory mapped file instead of 'regular' fread");
		scrivi_riga("-forcezfs", "force .zfs path (DEFAULT: skip)");
		help_size();
		scrivi_riga("-715", "Work as 7.15 (with .zfs and ADS)");
		scrivi_riga("-verbose", "Show more infos");
		scrivi_riga("-stdout", "Do not mess the output");
		scrivi_riga("-pakka", "Do not mess the output");
		scrivi_riga("-noeta", "Do not show ETA");
		scrivi_riga("-last", "Get only the last file");
		scrivi_riga("-franzhash", "Use franzhash on a single file with multithread");
		scrivi_riga("-franzhash -frugal", "franzhash with a single thread");
		scrivi_riga("-norecursion", "Disable recursion");
	}
	if (i_usage && i_example) scrivi_examples();
	if (i_example)
	{
		scrivi_esempio("SHA1 of all files","hash z:\\knb");
		scrivi_esempio("SHA1 of all files, multithread","hash z:\\knb -ssd");
		scrivi_esempio("XXH3 multithreaded","hash z:\\knb -ssd -xxh3");
		scrivi_esempio("SHA256 to file","hash z:\\knb -ssd -sha256 -stdout -out 1.txt");
		scrivi_esempio("SHA1 of the last file","hash z:\\knb -last");
		scrivi_esempio("franzhash 4 parts/4 threads","hash z:\\pippo.zpaq -franzhash -blake3 -t4");
		scrivi_esempio("franzhash 4 parts/1 thread","hash z:\\pippo.zpaq -franzhash -blake3 -t4 -frugal");		
		scrivi_esempio("only files in c:\\nz","hash c:\\nz -norecursion");		
		
	}
	return("Calculate file hash");
}

string help_dir(bool i_usage,bool i_example)
{
	if (i_usage)
	{
		scrivi_riga("CMD dir","(yes, dir as in Windows, even better)");
		scrivi_riga(" ","A powerful alternative to standard 'dir' or 'ls' that includes");
		scrivi_riga(" ","cumulative file sizes");
		scrivi_riga(" ","'Mini clone' of Windows's dir command, with the main switches");
		scrivi_riga(" ","Windows-style switches (e.g., /s) must be placed before other switches");
		scrivi_esempio("+","/s            Recursive");
		scrivi_esempio("+","/os           Order by size");
		scrivi_esempio("+","/a            Show all (hidden)");
		scrivi_riga("-checksum", "Show hashes for every file");
		scrivi_riga("-(somehash)", "Use (somehash) to find duplicate/show checksums");
		help_printhash(false);
		scrivi_riga("-n X","like |tail -X");
		help_size();
		scrivi_riga("-nodir","Shows only files");
	}
	if (i_usage && i_example) scrivi_examples();
	if (i_example)
	{
		scrivi_esempio("Windows-dir command clone","dir /root/script /od");
		scrivi_esempio("Show the 10 largest .mp4 file in c:\\","dir c:\\ /s /os -n 10 -find .mp4");
		scrivi_esempio("Find .mp4 duplicate in C:\\","dir c:\\ /s -crc32 -find .mp4");
		scrivi_esempio("How big is c:\\z,with subdirs?","dir c:\\z /s -n 1");
		scrivi_esempio("100 biggest dup. files in c:\\z?","dir c:\\z /s -crc32 -n 100");
		scrivi_esempio("Show -md5 checksum, recurse by size","dir z:\\cb /s /os -checksum -md5");
		scrivi_esempio("Find duplicate, recurse by size","dir z:\\cb /s /os -xxh3");
		scrivi_esempio("Like dir","dir z:\\cb\\*.avi");
		scrivi_esempio("Better than dir","dir c:\\*.cpp /s /os -n 100");
		scrivi_esempio("Get last 5 backup files","dir c:\\backup\\*.zpaq /on -n 5 -terse");
		scrivi_esempio("Show newer files","dir c:\\backup\\*.zpaq /s -datefrom 2025 -nodir");
		
	}
	return("Enhanced dir (better than Windows' dir)");

}
string help_k(bool i_usage,bool i_example)
{
	if (i_usage)
	{
		scrivi_riga("CMD k","(kill, risky!)");
		scrivi_riga(" ","Kill (delete) all files and directories that aren't in an archive");
		scrivi_riga(" ","removing excess files");
	}
	if (i_usage && i_example) scrivi_examples();
	if (i_example)
	{
		scrivi_esempio("Create an archive","a z:\\1.zpaq c:\\z");
		scrivi_esempio("Extract into z:\\knb","x z:\\1.zpaq c:\\z -to z:\\knb");
		scrivi_esempio(" ","... something happens (change) in");
		scrivi_esempio(" ","z:\\knb and we want to turn back");
		scrivi_esempio(" ","WITHOUT delete everything and ");
		scrivi_esempio("extract again (maybe it's huge)","k z:\\1.zpaq c:\\z -to z:\\knb");
	}
	return("Delete file(s) not in archive (RISKY!)");

}

#ifdef ZPAQFULL ///NOSFTPSTART
string help_n(bool i_usage,bool i_example)
{
	if (i_usage)
	{
		scrivi_riga("CMD n","(decimatioN)");
		scrivi_riga(" ","Keep -n X files in a folder (NO recursive scan), delete all the others");
		scrivi_riga(" ","At least one * must be used to filter.");
		scrivi_riga(" ","with -exec execute external command");
		scrivi_riga("-kill", "Do a wet run (default dry run)");
		scrivi_riga("-exec", "p.bat   Instead of delete launch p.bat with parameter");
		scrivi_riga(" ","/od           Order by date (default)");
		scrivi_riga(" ","/on           Order by name");
		scrivi_riga("-verbose", "Show infos");
		scrivi_riga("-force", "Continue even if >50 files founded");
	}
	if (i_usage && i_example) scrivi_examples();
	if (i_example)
	{
		scrivi_esempio("Keep 10 newest files in z:\\1\\","n z:\\1\\*.txt -n 10 -kill");
		scrivi_esempio("Keep 20 ordered by name","n z:\\1\\dumpy_*.sql -n 20 -kill -force /on");
		scrivi_esempio("Keep 30 txt ordered by name","n z:\\1\\*.txt -n 20 -kill -force /on");
		scrivi_esempio("Check the last file with ugo.bat","n z:\\1\\*.txt -kill -exec ugo.bat");
	}
	return("Delete older file(s), keep newest X");
}
#endif ///NOSFTPEND
string help_mainswitches(bool i_usage,bool i_example)
{
	if ((i_usage) || (i_example))
	{
		scrivi_riga("-all [N]", "All versions (default 4 digits)");
		scrivi_riga("-key X", "Archive password X");
		scrivi_riga("-mN -method N", "0=no compression, 1..5=faster..better ");
		scrivi_riga("-force", "Overwrite");
		scrivi_riga("-test", "Verify (extract/add)");
		scrivi_riga("-kill", "Allow destructive operations ('wet runs')");
		scrivi_riga("-to out...", "Prefix files to out");
		scrivi_riga("-until N", "Roll back to N'th version");		
#ifdef HWSHA1
		scrivi_riga("-hw","Hardware-accelerated SHA1 code    (not in all CPUs)");
#endif // corresponds to #ifdef (#ifdef HWSHA1)

	}
	return("Frequently used switches");
}
string help_switches(bool i_usage,bool i_example)
{
	if ((i_usage) || (i_example))
	{
		char buffer[200];
		time_t nowz=time(NULL);
		tm* t=gmtime(&nowz);
		int64_t date=(t->tm_year+1900)*10000000000LL+(t->tm_mon+1)*100000000LL
		  +t->tm_mday*1000000+t->tm_hour*10000+t->tm_min*100+t->tm_sec;
		snprintf(buffer,sizeof(buffer),"%s   Set date, roll back (UT, default time: 235959)",dateToString(flagutc,date).c_str());
		scrivi_riga("-until",buffer);
		scrivi_riga("-not files... ","Exclude. * and ? match any string or char");
		scrivi_riga("     =[+-#^?] ","List: exclude by comparison result");
		scrivi_riga("-only files...","Include only matches (default: *) example *pippo*.mp4");
		scrivi_riga("-always files ","Always (force) adding some file");
		scrivi_riga("-noattributes ","Ignore/don't save file attributes or permissions");
		scrivi_riga("-index F      ","Extract: create index F for archive");
		scrivi_riga("              ","Add: create suffix for archive indexed by F, update F");
		scrivi_riga("-sN -summary N","If >0 show only summary (sha1())");
	}
	return("Standard switches");
}
string help_commonswitches(bool i_usage,bool i_example)
{
	if ((i_usage) || (i_example))
		g_programflags.tutti();
	
	return("Most common switches");
}

string help_franzswitches(bool i_usage,bool i_example)
{
	if ((i_usage) || (i_example))
{
///	-all [N]             All version
	scrivi_riga("-715", "Works just about like v7.15");
	scrivi_riga("-all [N]", "All versions (default 4 digits)");
	scrivi_riga("-big", "ASCII art on final result");
	scrivi_riga("-checksum", "Store SHA1+CRC32 for every file");
	scrivi_riga("-comment", "foo  Add/find ASCII comment string to versions");
	scrivi_riga("-debug", "Show lot of infos (superverbose)");
	scrivi_riga("-dirlength X", "Utf command: find dirs with length>X, extract maxdirlen");
	scrivi_riga("-filelength X", "Utf command: find file with length>X, extract maxfilelen");
	scrivi_riga("-filelist", "Store the add() list in VFILE-l-filelist.txt");
	scrivi_riga("-find X", "Search for X in full filename (ex. list)");
	scrivi_riga("-fix255", "Shrink total file length and case collisions (NTFS)");
	scrivi_riga("-fixeml", "Heuristically compress .eml filenames (Fwd Fwd Fwd =>Fwd)");
	scrivi_riga("-flat", "Everything in single path (emergency extract of strange files)");
	scrivi_riga("-forcewindows", "Take $DATA$ and System Volume Information");
	scrivi_riga("-forcezfs", "Force paths including .zfs");
	scrivi_riga("-kill", "In extraction write 0-bytes file instead of data");
	scrivi_riga("-kill", "Show 'script-ready' log of dup files");
	scrivi_riga("-limit X", "(like -n)");
	scrivi_riga("-n", "X Only print last X lines in dir (like tail)/first X (list)");
	scrivi_riga("-nocolor", "disable colors");
	scrivi_riga("-nodedup", "Disabling deduplication");
	scrivi_riga("-noeta", "Do not show ETA");
	scrivi_riga("-nomac", "Skip ._something and .DS_Store and Thumbs.db");
	scrivi_riga("-nopath", "Do not store path");
	scrivi_riga("-noqnap", "Skip path including @Recently-Snapshot and @Recycle");
	scrivi_riga("-norecursion", "Do not recurse into folders (default: YES)");
	scrivi_riga("-nosort", "Do not sort file when adding or listing");
	scrivi_riga("-nosynology", "Skip #snapshot, #recycle etc");
	scrivi_riga("-output", "s.txt Output on s.txt too (alias: -out)");
	scrivi_riga("-pakka", "Output for PAKKA (briefly)");
	scrivi_riga("-replace Y", "Replace X with Y in full filename (ex. list)");
	scrivi_riga("-silent", "Be mute (!)");
	scrivi_riga("-store", "Store mode: turn off deduplication and compression");
	scrivi_riga("-summary", "Concise output");
	scrivi_riga("-timestamp X", "Set version datetime@X 14 digit (2021-12-30_01:03:04)"); 	// force the timestamp
	scrivi_riga("-utc", "Do not convert to localtime (use UTC, like 715)");
	scrivi_riga("-utf", "Remove non-utf8 chars");
	scrivi_riga("-utf8", "Like -utf");	help_date();
	scrivi_riga("-verbose", "Show more");
	scrivi_riga("-verify", "Force re-read of file during t (test command) or c");
	scrivi_riga("-xls", "Do NOT always force XLS/PPT");
	scrivi_riga("-zfs", "Skip paths including .zfs");	help_size();
#if defined(_WIN32)
	scrivi_riga("-open", "Check if .zpaq is already open => abort if yes");
	scrivi_riga("-longpath", "add/extract on Windows filenames longer than 255");
	scrivi_riga("-noconsole", "disable console manipulation (older Windows)");
	scrivi_riga("", "support env variable NO_CONSOLE (no-color.org)");
#endif // corresponds to #if (#if defined(_WIN32))
	help_printhash(false);
#ifdef ZPAQFULL ///NOSFTPSTART
	scrivi_riga("-exec_ok", "f.sh After OK launch f.sh");
	scrivi_riga("-exec_error", "z After NOT OK launch z");
	scrivi_riga("-exec_warn", "cz At Warn launch cz");
	scrivi_riga("-exec", "pip.bat Launch pip.bat %1 with command n");
#ifdef _WIN32
	scrivi_riga("-vss", "Do a VSS for drive C: (Windows with administrative rights)");
#endif // corresponds to #ifdef (#ifdef _WIN32)
#endif ///NOSFTPEND

	help_orderby();
	
}
	return("Advanced zpaqfranz switches");
}
string help_voodooswitches(bool i_usage,bool i_example)
{
	if ((i_usage) || (i_example))
	{
		scrivi_riga("-memzero","Do memzero on libsodium (just placebo)");
		scrivi_riga("-repack F [X]","Extract to new archive F with key X (default: none)");
		scrivi_riga("-tN -threads N","Use N threads (default: 0 = all cores)");
		scrivi_riga("-fragment N","Use 2^N KiB average fragment size (default: 6)");
		scrivi_riga("-mNB -method NB","Use 2^B MiB blocks (0..11, default: 04, 14, 26..56)");
		scrivi_riga("-method","{xs}B[,N2]...[{ciawmst}[N1[,N2]...]]...  Advanced:");
		scrivi_riga(" ","x=journaling (default). s=streaming (no dedupe)");
		scrivi_riga(" ","  N2: 0=no pre/post. 1,2=packed,byte LZ77. 3=BWT. 4..7=0..3 with E8E9");
		scrivi_riga(" ","  N3=LZ77 min match. N4=longer match to try first (0=none). 2^N5=search");
		scrivi_riga(" ","  depth. 2^N6=hash table size (N6=B+21: suffix array). N7=lookahead");
		scrivi_riga(" ","  Context modeling defaults shown below:");
		scrivi_riga(" ","c0,0,0: context model. N1: 0=ICM, 1..256=CM max count. 1000..1256 halves");
		scrivi_riga(" ","  memory. N2: 1..255=offset mod N2, 1000..1255=offset from N2-1000 byte");
		scrivi_riga(" ","  N3...: order 0... context masks (0..255). 256..511=mask+byte LZ77");
		scrivi_riga(" ","  parse state, >1000: gap of N3-1000 zeros");
		scrivi_riga(" ","i: ISSE chain. N1=context order. N2...=order increment");
		scrivi_riga(" ","a24,0,0: MATCH: N1=hash multiplier. N2=halve buffer. N3=halve hash tab");
		scrivi_riga(" ","w1,65,26,223,20,0: Order 0..N1-1 word ISSE chain. A word is bytes");
		scrivi_riga(" ","  N2..N2+N3-1 ANDed with N4, hash mulitpiler N5, memory halved by N6");
		scrivi_riga(" ","m8,24: MIX all previous models, N1 context bits, learning rate N2");
		scrivi_riga(" ","s8,32,255: SSE last model. N1 context bits, count range N2..N3");
		scrivi_riga(" ","t8,24: MIX2 last 2 models, N1 context bits, learning rate N2");
	}
	return("Expert-level (nerd) switches");

}


// Structure to store information about categories
struct CategoryInfo {
    std::string name;
    int sortposition;
    std::vector<std::string> commands;
};

// Functor to sort categories by sort position
struct CategorySorter {
    bool operator()(const CategoryInfo& a, const CategoryInfo& b) const {
        return a.sortposition < b.sortposition;
    }
};

// Main function to print the help
void printhelp(const MAPPAHELP& help_map,unsigned int maxchar) 
{

    // 1. Group commands by category and store the sort position
    std::vector<CategoryInfo> categorieComandi;
    std::map<std::string, int> categorySortPosition;

    for (MAPPAHELP::const_iterator p = help_map.begin(); p != help_map.end(); ++p) {
        bool found = false;
        for (std::vector<CategoryInfo>::iterator cat = categorieComandi.begin(); cat != categorieComandi.end(); ++cat) {
            if (cat->name == p->second.category) {
                cat->commands.push_back(p->first);
                found = true;
                break;
            }
        }
        if (!found) {
            CategoryInfo newCat;
            newCat.name = p->second.category;
            newCat.sortposition = p->second.sortposition;
            newCat.commands.push_back(p->first);
            categorieComandi.push_back(newCat);
        }
        categorySortPosition[p->second.category] = p->second.sortposition;
    }

    // 2. Sort commands within each category alphabetically
    for (std::vector<CategoryInfo>::iterator cat = categorieComandi.begin(); cat != categorieComandi.end(); ++cat) {
        std::sort(cat->commands.begin(), cat->commands.end());
    }

    // 3. Sort categories by sort position
    std::sort(categorieComandi.begin(), categorieComandi.end(), CategorySorter());

    // 4. Calculate the maximum length of category names for alignment
    size_t maxLength = 0;
    for (std::vector<CategoryInfo>::const_iterator cat = categorieComandi.begin(); cat != categorieComandi.end(); ++cat) {
        if (cat->name.length() > maxLength) {
            maxLength = cat->name.length();
        }
    }

    // 5. Print categories and commands
    std::string rigaCorrente;
    bool primaCategoria = true;

    for (std::vector<CategoryInfo>::const_iterator cat = categorieComandi.begin(); cat != categorieComandi.end(); ++cat) {
        // Each category must start on a new line
        if (!primaCategoria) {
            moreprint("");
            rigaCorrente.clear();
        }

        // Print category header in yellow
        color_yellow();
        std::string intestazione = cat->name;
		moreprint(intestazione.c_str(), true);
		color_restore();
        moreprint(":", true);

        // Calculate indentation based on maximum length
        std::string indentazione(maxLength - cat->name.length() + 1, ' ');
        moreprint(indentazione.c_str(), true);

        color_green();
        rigaCorrente += intestazione + indentazione;

        // Print commands one by one, handling wrap
        bool primoComando = true;
        for (std::vector<std::string>::const_iterator cmd = cat->commands.begin(); cmd != cat->commands.end(); ++cmd) {
            std::string separatore = primoComando ? "" : ", ";

            // If the separator + command don't fit, it wraps and realigns
            if (rigaCorrente.length() + separatore.length() + cmd->length() > maxchar) {
                moreprint("");
                // Add the same indentation used for the first command of the category
                std::string nuovaRigaIndentazione(maxLength + 2, ' ');
                moreprint(nuovaRigaIndentazione.c_str(), true);
                rigaCorrente.clear();
                rigaCorrente += nuovaRigaIndentazione;
                separatore = ""; // No need for a separator at the beginning of the new line
            }

            moreprint((separatore + *cmd).c_str(), true);
            rigaCorrente += (separatore + *cmd);

            primoComando = false;
        }

        primaCategoria = false;
    }

    // Print the last line if it is not empty
    if (!rigaCorrente.empty()) {
        moreprint("");
    }
}

void Jidac::load_help_map()
{
	/// a map is not so good, but we want to keep the executable small
	/// NOT in the constructor
	
	// Core
	help_map.insert(std::pair<string, HelpInfo>("a", 				HelpInfo("Core     ", help_a,				0)));
	help_map.insert(std::pair<string, HelpInfo>("x",				HelpInfo("Core     ", help_x,				0)));
	help_map.insert(std::pair<string, HelpInfo>("l",				HelpInfo("Core     ", help_l,				0)));
	help_map.insert(std::pair<string, HelpInfo>("e",				HelpInfo("Core     ", help_e,				0)));
	
	help_map.insert(std::pair<string, HelpInfo>("backup", 			HelpInfo("Backup   ", help_backup,			1)));
#ifdef ZPAQFULL ///NOSFTPSTART
	help_map.insert(std::pair<string, HelpInfo>("mysqldump", 		HelpInfo("Backup   ", help_mysqldump,		1)));
#endif ///NOSFTPEND


#ifdef ZPAQFULL ///NOSFTPSTART
#if defined(_WIN32)
	help_map.insert(std::pair<string, HelpInfo>("g", 				HelpInfo("Backup   ", help_g,				1)));
	help_map.insert(std::pair<string, HelpInfo>("q", 				HelpInfo("Backup   ", help_q,				1)));
#endif // corresponds to #if (#if defined(_WIN32))
#endif ///NOSFTPEND

	// Restore
	help_map.insert(std::pair<string, HelpInfo>("w", 				HelpInfo("Restore  ", help_w,				2)));
#if defined(_WIN32)
	help_map.insert(std::pair<string, HelpInfo>("ntfs", 			HelpInfo("Restore  ", help_ntfs,			2)));
#endif 

	// Info
	help_map.insert(std::pair<string, HelpInfo>("dirsize", 			HelpInfo("Info/list", help_dirsize,			3)));
	help_map.insert(std::pair<string, HelpInfo>("i",				HelpInfo("Info/list", help_i,				3)));
#if defined(_WIN32)
	help_map.insert(std::pair<string, HelpInfo>("drive", 			HelpInfo("Info/list", help_drive,			3)));
#endif

	// List  
	help_map.insert(std::pair<string, HelpInfo>("fzf", 				HelpInfo("Info/list", help_fzf,				3)));
#ifndef ANCIENT
	help_map.insert(std::pair<string, HelpInfo>("ls", 				HelpInfo("Info/list", help_ls,				3)));
	help_map.insert(std::pair<string, HelpInfo>("tui", 				HelpInfo("Info/list", help_tui,				3)));
#endif
#if defined(_WIN32)
	help_map.insert(std::pair<string, HelpInfo>("pakka", 			HelpInfo("Info/list", help_pakka,			3)));
#endif

#if defined(_WIN32)
	help_map.insert(std::pair<string, HelpInfo>("drive", 			HelpInfo("Info/list", help_drive,			3)));

#endif // corresponds to #if (#if defined(_WIN32))

	// Test
	help_map.insert(std::pair<string, HelpInfo>("p", 				HelpInfo("Test     ", help_p,				4)));
	help_map.insert(std::pair<string, HelpInfo>("sync", 			HelpInfo("Test     ", help_sync,			4)));
	help_map.insert(std::pair<string, HelpInfo>("t", 				HelpInfo("Test     ", help_t,				4)));
	help_map.insert(std::pair<string, HelpInfo>("testbackup", 		HelpInfo("Test     ", help_testbackup,		4)));


#ifdef ZPAQFULL ///NOSFTPSTART
#ifdef SFTP
	help_map.insert(std::pair<string, HelpInfo>("ssh", 				HelpInfo("Cloud    ", help_ssh,			5)));
	help_map.insert(std::pair<string, HelpInfo>("sftp", 			HelpInfo("Cloud    ", help_sftp,			5)));
	help_map.insert(std::pair<string, HelpInfo>("cloud", 			HelpInfo("Cloud    ", help_cloud,			5)));
#endif // corresponds to #ifdef (#ifdef SFTP)
#ifdef _WIN64
	help_map.insert(std::pair<string, HelpInfo>("download", 		HelpInfo("Cloud    ", help_download,		5)));
#endif // corresponds to #ifdef (#ifdef _WIN64)
#endif ///NOSFTPEND

	// File
	help_map.insert(std::pair<string, HelpInfo>("1on1", 			HelpInfo("File     ", help_oneonone,		6)));
	help_map.insert(std::pair<string, HelpInfo>("c",				HelpInfo("File     ", help_c,				6)));
	help_map.insert(std::pair<string, HelpInfo>("cp", 				HelpInfo("File     ", help_cp,				6)));
	help_map.insert(std::pair<string, HelpInfo>("d",				HelpInfo("File     ", help_d,				6)));
	help_map.insert(std::pair<string, HelpInfo>("dir", 				HelpInfo("File     ", help_dir,				6)));
	help_map.insert(std::pair<string, HelpInfo>("find", 			HelpInfo("File     ", help_find,			6)));
	help_map.insert(std::pair<string, HelpInfo>("hash", 			HelpInfo("File     ", help_hasha,			6)));
	help_map.insert(std::pair<string, HelpInfo>("r", 				HelpInfo("File     ", help_r,				6)));
	help_map.insert(std::pair<string, HelpInfo>("s", 				HelpInfo("File     ", help_s,				6)));
	help_map.insert(std::pair<string, HelpInfo>("sum", 				HelpInfo("File     ", help_summa,			6)));
#ifdef ZPAQFULL ///NOSFTPSTART
	help_map.insert(std::pair<string, HelpInfo>("n", 				HelpInfo("File     ", help_n,				6)));
#if defined(_WIN32)
	help_map.insert(std::pair<string, HelpInfo>("rd", 				HelpInfo("File     ", help_rd,				6)));
#endif
#endif ///NOSFTPEND

// Admin
	help_map.insert(std::pair<string, HelpInfo>("autotest", 		HelpInfo("Admin    ", help_autotest,		7)));
	help_map.insert(std::pair<string, HelpInfo>("b",				HelpInfo("Admin    ", help_b,				7)));
	help_map.insert(std::pair<string, HelpInfo>("collision", 		HelpInfo("Admin    ", help_collision,		7)));
	help_map.insert(std::pair<string, HelpInfo>("consolidate", 		HelpInfo("Admin    ", help_consolidatebackup,7)));
	help_map.insert(std::pair<string, HelpInfo>("crop", 			HelpInfo("Admin    ", help_crop,			7)));
	help_map.insert(std::pair<string, HelpInfo>("dump", 			HelpInfo("Admin    ", help_dump,			7)));
	help_map.insert(std::pair<string, HelpInfo>("k",				HelpInfo("Admin    ", help_k,				7)));
	help_map.insert(std::pair<string, HelpInfo>("m",				HelpInfo("Admin    ", help_m,				7)));
	help_map.insert(std::pair<string, HelpInfo>("password", 		HelpInfo("Admin    ", help_setpassword,		7)));
	help_map.insert(std::pair<string, HelpInfo>("redu", 			HelpInfo("Admin    ", help_redu,			7)));
	help_map.insert(std::pair<string, HelpInfo>("trim", 			HelpInfo("Admin    ", help_trim,			7)));
#ifdef ZPAQFULL ///NOSFTPSTART
#if defined(_WIN32)
	help_map.insert(std::pair<string, HelpInfo>("ads", 				HelpInfo("Admin    ", help_ads,				7)));
#endif // corresponds to #if (#if defined(_WIN32))
	help_map.insert(std::pair<string, HelpInfo>("update", 			HelpInfo("Admin    ", help_update,			7)));
	help_map.insert(std::pair<string, HelpInfo>("upgrade", 			HelpInfo("Admin    ", help_update,			7)));
#endif ///NOSFTPEND


	// Utils
	help_map.insert(std::pair<string, HelpInfo>("checkpassword", 	HelpInfo("Utils    ", help_checkpassword,	8)));
	help_map.insert(std::pair<string, HelpInfo>("comparehex", 		HelpInfo("Utils    ", help_comparehex,		8)));
	help_map.insert(std::pair<string, HelpInfo>("count", 			HelpInfo("Utils    ", help_count,			8)));
	help_map.insert(std::pair<string, HelpInfo>("f",				HelpInfo("Utils    ", help_f,				8)));
	help_map.insert(std::pair<string, HelpInfo>("last", 			HelpInfo("Utils    ", help_last,			8)));
	help_map.insert(std::pair<string, HelpInfo>("last2", 			HelpInfo("Utils    ", help_last2,			8)));
	help_map.insert(std::pair<string, HelpInfo>("pause", 			HelpInfo("Utils    ", help_pause,			8)));
	help_map.insert(std::pair<string, HelpInfo>("rsync", 			HelpInfo("Utils    ", help_rsync,			8)));
	help_map.insert(std::pair<string, HelpInfo>("utf", 				HelpInfo("Utils    ", help_utf,				8)));
	help_map.insert(std::pair<string, HelpInfo>("versum", 			HelpInfo("Utils    ", help_versum,			8)));
	help_map.insert(std::pair<string, HelpInfo>("work", 			HelpInfo("Utils    ", help_work,			8)));
	help_map.insert(std::pair<string, HelpInfo>("z", 				HelpInfo("Utils    ", help_z,				8)));
#ifdef ZPAQFULL ///NOSFTPSTART
	help_map.insert(std::pair<string, HelpInfo>("isopen", 			HelpInfo("Utils    ", help_isopen,			8)));
#if defined(_WIN32)
	help_map.insert(std::pair<string, HelpInfo>("sfx", 				HelpInfo("Utils    ", help_sfx,				8)));
#endif
#endif ///NOSFTPEND
	

#ifdef ZPAQFULL ///NOSFTPSTART
#if defined(unix)
	help_map.insert(std::pair<string, HelpInfo>("zfs", 				HelpInfo("Admin    ", help_zfs,				7)));
	help_map.insert(std::pair<string, HelpInfo>("zfsproxbackup", 	HelpInfo("Backup   ", help_zfsproxbackup,	1)));
	help_map.insert(std::pair<string, HelpInfo>("zfsproxrestore", 	HelpInfo("Restore  ", help_zfsproxrestore,	2)));
	help_map.insert(std::pair<string, HelpInfo>("zfsbackup", 		HelpInfo("Backup   ", help_zfsbackup,		1)));
	help_map.insert(std::pair<string, HelpInfo>("zfsrestore", 		HelpInfo("Restore  ", help_zfsrestore,		2)));
	help_map.insert(std::pair<string, HelpInfo>("zfsreceive", 		HelpInfo("Backup   ", help_zfsreceive,		1)));
	help_map.insert(std::pair<string, HelpInfo>("zfsadd", 			HelpInfo("Backup   ", help_zfsadd,			1)));
	help_map.insert(std::pair<string, HelpInfo>("zfslist", 			HelpInfo("Info/list", help_zfslist,			3)));
	help_map.insert(std::pair<string, HelpInfo>("zfspurge", 		HelpInfo("Admin    ", help_zfspurge,		7)));
	help_map.insert(std::pair<string, HelpInfo>("zfssize", 			HelpInfo("Info/list", help_zfssize,			3)));
#endif // corresponds to #if (#if defined(unix))
#endif ///NOSFTPEND



	switches_map.insert(std::pair<string, HelpInfo>("main", 		HelpInfo("dummy", help_mainswitches,		0)));
	switches_map.insert(std::pair<string, HelpInfo>("normal", 		HelpInfo("dummy", help_switches,			1)));
	switches_map.insert(std::pair<string, HelpInfo>("common", 		HelpInfo("dummy", help_commonswitches,		2)));
	switches_map.insert(std::pair<string, HelpInfo>("franz", 		HelpInfo("dummy", help_franzswitches,		3)));
	switches_map.insert(std::pair<string, HelpInfo>("voodoo", 		HelpInfo("dummy", help_voodooswitches,		4)));}


void Jidac::usage(bool i_flagdie=true)
{
	const char* base = 
	#ifdef ZPAQFULL
		"Top tier archiver w/dedup";
	#else
		"Secure archiver w/dedup";
	#endif

	const char* hw = ihavehw() ? " & HW SHA1/2" : "";
	char output[128];
	snprintf(output, sizeof(output), "%s%s (C) by ", base, hw);
	moreprint(output, true);

	color_cyan();
	moreprint("Franco Corbelli");
	color_cyan();
	moreprint("Help     ",true);
	color_restore();
	moreprint(": zpaqfranz h ",true);
	color_green();
	moreprint("<command>",true);
	color_restore();
	moreprint(" (single) zpaqfranz ",true);
	color_green();
	moreprint("h h",true);
	color_restore();	
	moreprint(" (full)");
	
	
	color_green();
	load_help_map();

	unsigned int leftspace=66;
	if (!isAnyOutputRedirected())
		leftspace=(terminalwidth()-4);
		
	printhelp(help_map,leftspace);
	
	color_restore();

	color_cyan();
	moreprint("Switches ",true);
	color_restore();
	moreprint(": zpaqfranz h ",true);
	color_green();
	moreprint("main",true);
	color_yellow();
	moreprint("  ",true);
	color_restore();
	moreprint("zpaqfranz h ",true);
	color_green();
	moreprint("common",true);
	color_restore();
	moreprint("  zpaqfranz h ",true);
	color_green();
	moreprint("franz");
	color_restore();
	
/*
#ifdef HWSHA2
	
	if (ihavehw())
	{
		printf ("\033[1;32;44mHW ACCELERATION ON\033[0m\n");
	}
	else
	{
		color_red();
		moreprint(" (HW OFF)");
	}
#endif // corresponds to #ifdef (#ifdef HWSHA2)
*/
#ifdef HWSHA1
	moreprint("     -hw : Force hardware SHA1 (fails if unsupported by CPU)");
	
#endif // corresponds to #ifdef (#ifdef HWSHA1)

	
#ifdef ZPAQFULL ///NOSFTPSTART
#if defined(_WIN32)
	color_cyan();
	moreprint("Update   ",true);
	color_restore();
	moreprint(": zpaqfranz ",true);
	color_green();
	moreprint("update -force");
	color_restore();
#else
	moreprint("Look for newer version  (Internet):    zpaqfranz update");
#endif // corresponds to #if (#if defined(_WIN32))
#endif ///NOSFTPEND

		
	if (i_flagdie)
		seppuku();
}
void Jidac::helphelp()
{
	if (!flagnoconsole)
	{
		setupConsole();
		printf("\033[2J"); //cls erase the first line
		printf("\033[%d;0H",(int)1);
		restoreConsole();
	}
	load_help_map();
	color_green();

	unsigned int leftspace=0;
	if (!isAnyOutputRedirected())
		leftspace=(terminalwidth()-72)/2;

	moreprint("                                      FFFF",false,leftspace);
	moreprint(" ZZZZZZ PPPPP.    AAAAA.    QQQQQQ FFFFF RRRRR AAAAA.   NNNNNN.  ZZZZZZ",false,leftspace); 
	moreprint("   ZZZZ PPP  PPP      AAA QQQ  QQQ FFF  RRRR       AAA NNN  NNN    ZZZZ",false,leftspace);  
	moreprint("  ZZZZ  PPP  PPP .AAAAAAA QQQ  QQQ FFF  RRR   .AAAAAAA NNN  NNN   ZZZZ",false,leftspace);   
	moreprint(" ZZZZ   PPP PPPP AAA  AAA QQQQ QQQ FFF  RRR   AAA  AAA NNN  NNN  ZZZZ",false,leftspace);    
	moreprint("ZZZZZZZ PPPPP.    AAAAAA     QQQQQ FFF  RRR    AAAAAA  NNN  NNN ZZZZZZZ",false,leftspace); 
	moreprint("        PPP                    QQQ",false,leftspace);                                          
	color_red();
	moreprint("(C) 2021-2025 by Franco Corbelli: provided as-is,no warranty whatsoever",false,leftspace);
	color_yellow();
	moreprint("           WWW: https://sourceforge.net/projects/zpaqfranz",false,leftspace);
	color_restore();
	moreprint("          Swiss army knife for backup and disaster recovery",false,leftspace);
	moreprint("  Like 7z or RAR on steroids,with deduplicated \"snapshots\" (versions)",false,leftspace);
	moreprint("  Conceptually similar to Mac time machine, but much more efficiently",false,leftspace);
	moreprint("  Keeps backup always-to-always,no need to prune (bye bye Ransomware)",false,leftspace);
	moreprint("  Easily handles millions of files and TBs of data, non-latin support",false,leftspace);
	moreprint("  Multithreaded HW accelerations, full encryption, multipart archives",false,leftspace);
	moreprint("  Minimal data transfer => low bandwidth Virtual Machine Cloud backup",false,leftspace);
	moreprint("  Data integrity check CRC32+XXHASH|SHA-1|SHA-2|SHA-3|MD5|XXH3|BLAKE3",false,leftspace);
#ifdef ZPAQFULL ///NOSFTPSTART
#ifdef unix
	moreprint("  Specific zfs handling functions,full multiplatform interoperability",false,leftspace);
#endif // corresponds to #ifdef (#ifdef unix)
#endif ///NOSFTPEND
	moreprint("  Windows, FreeBSD, OpenBSD, Linux, MacOS, Solaris, OmniOS and others",false,leftspace);
	color_red();
	moreprint("  Extended help:   zpaqfranz h h           ALL IN:   zpaqfranz h full",false,leftspace);
	color_restore();
}
//// print a lot more
void Jidac::usageall(string i_command)
{
	load_help_map();
	if (i_command=="")
	{
		moreprint("Get help for one command with zpaqfranz h something");
		moreprint(" zpaqfranz   h all -nomore => everything, ready to be piped");
		moreprint(" zpaqfranz   h a           => ask help and examples for command 'a'");
		moreprint(" zpaqfranz -he a           => ask examples for command 'a'");
		moreprint(" ");
		for (MAPPAHELP::iterator p=help_map.begin(); p!=help_map.end(); ++p)
		{
			char linea[200];
			string temp=(*p->second.function)(false,false);
			snprintf(linea,sizeof(linea),"%-15s",p->first.c_str());
			color_green();
			moreprint(linea,true);
			color_restore();
			snprintf(linea,sizeof(linea),"%s",temp.c_str());
			moreprint(linea);
		}
		for (MAPPAHELP::iterator p=switches_map.begin(); p!=switches_map.end(); ++p)
		{
			char linea[200];
			string temp=(*p->second.function)(false,false);
			snprintf(linea,sizeof(linea),"%-15s",p->first.c_str());
			color_green();
			moreprint(linea,true);
			color_restore();
			snprintf(linea,sizeof(linea),"%s",temp.c_str());
			moreprint(linea);
		}
		seppuku();
		return;
	}

	MAPPAHELP::iterator a=help_map.find(i_command);
	if (a==help_map.end())
	{
		// maybe we want a switch ?
		if (i_command!="")
		{
			MAPPAHELP::iterator b=switches_map.find(i_command);
			if (b!=switches_map.end())
			{
				(*b->second.function)(true,true);
				seppuku();
			}
		}
//	if not found => show everything
		usage(false); // do not seppuku!
		moreprint("Usage full:");
		for (MAPPAHELP::iterator p=help_map.begin(); p!=help_map.end(); ++p)
		{
			
			///(*p->second)(true,true);
			(*p->second.function)(true,true);
			morebar('-');
		}
		morebar('-');
		moreprint("Extended switches:");
		help_switches(true,true);
		morebar('-');
		moreprint("zpaqfranz switches:");
		help_franzswitches(true,true);
		morebar('-');
		moreprint("Voodoo switches");
		help_voodooswitches(true,true);
	}
	else
	{	// please note: first parameter help, second example
		(*a->second.function)(true,true);
		morebar('-');
	}
	print_doublequote();
	seppuku();
}
void Jidac::examples(string i_command)
{
	load_help_map();	// not in the constructor!
//	if not found => show everything
	MAPPAHELP::iterator a=help_map.find(i_command);
	if (a==help_map.end())
	{
		for (MAPPAHELP::iterator p=help_map.begin(); p!=help_map.end(); ++p)
		{
			(*p->second.function)(false,true);
			morebar('-');
		}
	}
	else
	{	// please note: first parameter help, second example
		(*a->second.function)(false,true);
		morebar('-');
	}
}
void open_output(string i_filename)
{
	if (i_filename!="")
		if (g_output_handle==0)
		{
			g_output=i_filename;
			g_output_handle = fopen(i_filename.c_str(), flagappendoutput && fileexists(i_filename.c_str()) ? "ab" : "wb");
			
			if (g_output_handle==NULL)
				printf("28342: ERROR OPENING LOG FILE %s\n",i_filename.c_str());
		}
}
// Rename name using tofiles[]
string Jidac::rename(string name)
{
	franzreplace(name);
	
/*
	kludge
	extracting \\franzk\z\NS\something -to z:\pippo with longpath
	converted to
	z:\pippo\__franzk_z (...)
	./somewhere => _/somewhere etc
*/
#ifdef _WIN32
	if (flaglongpath)
		if ((command=='x') || (command=='w'))
			if (tofiles.size()==1)
			{
					/*
				if (flagdebug3)
				{
					myprintf("00487: longname |");
					printUTF8(name.c_str());
					myprintf("| => fixed to |");
				}
					*/

				if (name.size()>2) // fix for *nix relative paths
					if (name[0]=='.')
						if (name[1]=='/')
							name[0]='_';
				myreplaceall(name,"/./","/_/");
				myreplaceall(name,"/../","/__/");
				if (iswindowsunc(name))
				{
					replace(name,"//","__");
					replace(name,"/","_");
				}
				if (name.size()>2)
					if (isalpha(name[0]))
						if (name[1]==':')
							if (name[2]=='/')
								name[1]='_';

				string finale=includetrailingbackslash(tofiles[0])+name;
				if (flagdebug3)
				{
					myprintf("00488: longname |%Z| => fixed to |%Z|\n",name.c_str(),finale.c_str());
				}
				return finale;
			}
#endif // corresponds to #ifdef (#ifdef _WIN32)
	if (flagnopath)
	{
		string myname=name;
		for (unsigned i=0; i<files.size(); ++i)
		{
			string pathwithbar=includetrailingbackslash(extractfilepath(files[i]));
			if (flagdebug3)
				myprintf("00489: pathwithbar %s\n",pathwithbar.c_str());
			myreplace(myname,pathwithbar,"");
			if (flagdebug3)
				myprintf("00490: cutting path <<%s>> file <<%s>> to <<%s>>\n",files[i].c_str(),name.c_str(),myname.c_str());
		}
		return myname;
	}
	if (files.size()==0 && tofiles.size()>0)  // append prefix tofiles[0]
	{
		name=append_path(tofiles[0], name);
	}
	else
	{  // replace prefix files[i] with tofiles[i]
		const int n=name.size();
		for (unsigned i=0; i<files.size() && i<tofiles.size(); ++i)
		{
			const int fn=files[i].size();
			if (fn<=n && files[i]==name.substr(0, fn))
				return tofiles[i]+name.substr(fn);
        }
	}
	myreplaceall(name,"/./","/_/");
	myreplaceall(name,"/../","/__/");

  return name;
}
#ifdef _WIN32
string	windows_fixbackslash(string i_command,string i_parameter)
{
	wchar_t *wc = GetCommandLineW();
	string mycommandline=wtou(wc);
	myprintf("00493: mycommandline  |%s|\n",mycommandline.c_str());
	myprintf("00494: i_command      |%s|\n",i_command.c_str());
	myprintf("00495: i_parameter    |%s|\n",i_parameter.c_str());
	return "";
}
#endif // corresponds to #ifdef (#ifdef _WIN32)

bool do_not_print_headers()
{
///	return ((!flagpakka) && (!flagsilent) && (!flagstdout) && (!flagterse) && ((command=='l') && (flag715)));
	bool risultato=(flagpakka || (flagsilent) || (flagstdout) || (flagterse) || ((command=='l') && (flag715)));
	if (flagdebug)
		myprintf("51790: do_not_print_headers %d\n",int(risultato));
	return risultato;
	
}
void decoderange(string i_range)
{
/*
-range 2:4 -> Extract all versions from 2 to 4
-range 2: -> Extract all versions from 2 to <all that exist>
-range :3 -> Extract all versions from 1 to 3 (equal to: 1:3)
-range 2
-range ::3 -> Extract the last 3
*/
///myprintf("00496: entering decode\n");

	g_rangefrom	=0;
	g_rangeto	=0;
	g_rangelast	=0;
	if (i_range=="")
		return;
	string primaparte	="";
	string secondaparte	="";
	unsigned int i=0;
	// pre-check for ::3
	if (i_range.size()>=3)
	{
		if (!isdigit(i_range[i]))
			if (!isdigit(i_range[i+1]))
			{
				string resto=myright(i_range,i_range.size()-2);
				string temp="";
				for (unsigned int j=0;j<resto.size();j++)
					if (isdigit(resto[j]))
						temp+=resto[j];
				int lastver=atoll(temp.c_str());
				if (lastver>0)
				{
					g_rangelast=lastver;
					return;
				}
			}
	}

	i=0;
	while (i<i_range.size())
	{
		if (isdigit(i_range[i]))
			primaparte+=i_range[i];
		else
			break;
		i++;
	}
	if (primaparte=="0")
	{
		myprintf("00497: ERROR: 0 is not feasible as FROM in -range\n");
		seppuku();
	}
	if (flagdebug3)
	{
		myprintf("00498: size vale %d\n",i_range.size());
		myprintf("00499: i vale %d\n",i);
		myprintf("00500: prima  |%s|\n",primaparte.c_str());
	}
	bool nodivider=(i==i_range.size());

	if (i<i_range.size())
	{
		i++;
		while (i<i_range.size())
		{
			if (isdigit(i_range[i]))
				secondaparte+=i_range[i];
			else
				break;
			i++;
		}
	}
	if (flagdebug3)
	{
		myprintf("00501: dopo\n");
		myprintf("00502: i vale %d\n",i);
		myprintf("00503: seconda  |%s|\n",secondaparte.c_str());
	}
	if (primaparte=="")
		g_rangefrom=1;
	else
		(g_rangefrom=atol(primaparte.c_str()));

	if (secondaparte=="")
	{
		if (nodivider)
			g_rangeto=g_rangefrom;
		else
			g_rangeto=99999999;
	}
	else
		(g_rangeto=atol(secondaparte.c_str()));

	if (flagdebug2)
	{
		myprintf("00504: Rangefrom  %d\n",g_rangefrom);
		myprintf("00505: Rangeto    %d\n",g_rangeto);
	}

	if (g_rangeto<g_rangefrom)
	{
		myprintf("00506: ERROR: TO (%d) must be > FROM (%d)\n",g_rangeto,g_rangefrom);
		g_rangefrom	=0;
		g_rangeto	=0;
		seppuku();
	}
	if (flagdebug)
	{
		printbar('-');
		myprintf("00507: final Rangefrom  %d\n",g_rangefrom);
		myprintf("00508: final Rangeto    %d\n",g_rangeto);
	}
	if (g_rangefrom==0)
	{
		myprintf("00509: cannot decode range |%s| you should use something like 2:4 or 2: or :3\n",i_range.c_str());
		seppuku();
	}
	if (!do_not_print_headers())
		if (flagdebug)
		{
			myprintf("00510: franz:%-21s %21s\n","rangefrom (version)",migliaia(g_rangefrom));
			myprintf("00511: franz:%-21s %21s\n","rangeto   (version)",migliaia(g_rangeto));
		}
}

/*
	On FreeBSD (and zfs) home is very often a symlink, but the readlink() sometimes
	report relative links (/home => usr/home)
*/
#ifdef unix
string my_realpath(std::string const& i_path)
{
#ifdef ANCIENT
	char buf[16384];
#else
	char buf[33000]; //No MAXPATHLEN on Solaris
#endif // corresponds to #ifdef (#ifdef ANCIENT)
	if (i_path.size()>sizeof(buf))
	{
		error("33975:  realpath");
	}
    char *res=realpath(i_path.c_str(),buf);
    if (res)
	{
		return buf;
    }
	else
	{
		if (flagdebug)
			myprintf("00512: error on realpath of %s\n",i_path.c_str());
		return i_path;
    }
}
#endif // corresponds to #ifdef (#ifdef unix)

///#include <mach-o/dyld.h> for  _NSGetExecutablePath
#ifdef __APPLE__
#include <mach-o/dyld.h>
#endif // corresponds to #ifdef (#ifdef __APPLE__)


string finalizza_none(void* p_hash)
{
	if (p_hash==NULL)
		return "";
	return "";
}

string finalizza_sha3(void* p_hash)
{
	if (p_hash==NULL)
		return "";
	SHA3* casted=(SHA3*)p_hash;
	return (*casted).getHash();
}
string finalizza_xxhash64(void* p_hash)
{
	if (p_hash==NULL)
		return "";
	XXHash64* casted=(XXHash64*)p_hash;
	return bin2hex_64((*casted).hash());

	//	return binarytohex((const unsigned char*)(*casted).hash(),8);
}
string finalizza_sha1(void* p_hash)
{
	if (p_hash==NULL)
		return "";
	libzpaq::SHA1* casted=(libzpaq::SHA1*)p_hash;
	char sha1result[20];
	memcpy(sha1result, (*casted).result(), 20);
	return binarytohex((const unsigned char*)sha1result,20);
}
string finalizza_sha256(void* p_hash)
{
	if (p_hash==NULL)
		return "";
	libzpaq::SHA256* casted=(libzpaq::SHA256*)p_hash;
	char sha256result[32];
	memcpy(sha256result, (*casted).result(), 32);
	return binarytohex((const unsigned char*)sha256result,32);
}
string finalizza_xxh3(void* p_hash)
{
	if (p_hash==NULL)
		return "";
	XXH3_state_t* casted=(XXH3_state_t*)p_hash;
	XXH128_hash_t myhash=XXH3_128bits_digest(casted);
	return bin2hex_128(myhash.high64,myhash.low64);
}
string finalizza_md5(void* p_hash)
{
	if (p_hash==NULL)
		return "";
	MD5* casted=(MD5*)p_hash;
	return (*casted).getHash();
}
string finalizza_blake3(void* p_hash)
{
	if (p_hash==NULL)
		return "";
	blake3_hasher * casted=(blake3_hasher *)p_hash;
	uint8_t output[BLAKE3_OUT_LEN];
	blake3_hasher_finalize(casted,output,BLAKE3_OUT_LEN);
	return binarytohex((const unsigned char*)output,BLAKE3_OUT_LEN);
}
string finalizza_whirlpool(void* p_hash)
{
	if (p_hash==NULL)
		return "";
	NESSIEstruct * casted=(NESSIEstruct *)p_hash;
	unsigned char output[512]={0};
	NESSIEfinalize(casted,output);
	return binarytohex(output,64);
}
string finalizza_highway64(void* p_hash)
{
	if (p_hash==NULL)
		return "";
	HighwayHashCat * casted=(HighwayHashCat *)p_hash;
	uint64_t hash=HighwayHashCatFinish64(casted);
	return bin2hex_64(hash);
}
string finalizza_highway128(void* p_hash)
{
	if (p_hash==NULL)
		return "";
	HighwayHashCat * casted=(HighwayHashCat *)p_hash;
	uint64_t hash[2];
	HighwayHashCatFinish128(casted,hash);
	return binarytohex((const unsigned char*)&hash,16);
}
string finalizza_highway256(void* p_hash)
{
	if (p_hash==NULL)
		return "";
	HighwayHashCat * casted=(HighwayHashCat *)p_hash;
	uint64_t hash[4];
	HighwayHashCatFinish256(casted,hash);
	return binarytohex((const unsigned char*)&hash,32);
}

string finalizza_crc32(void* p_hash)
{
	if (p_hash==NULL)
		return "";
	const uint32_t* casted=(uint32_t*)p_hash;
	char	temp[10];
	snprintf(temp,sizeof(temp),"%08X",(*casted));
	return temp;
}
string finalizza_crc32c(void* p_hash)
{
	if (p_hash==NULL)
		return "";
	const uint32_t* casted=(uint32_t*)p_hash;
	char	temp[10];
	snprintf(temp,sizeof(temp),"%08X",(*casted));
	return temp;
}
string finalizza_wyhash(void* p_hash)
{
	if (p_hash==NULL)
		return "";
	return "";
}
string finalizza_nilsimsa(void* p_hash)
{
	if (p_hash==NULL)
		return "";
	return "";
}
string finalizza_entropy(void* p_hash)
{
	if (p_hash==NULL)
		return "";
	return "";
}

/// this must compile on 20-years-old C++
bool Jidac::cli_filesandcommand(const string& i_opt,string i_string,char i_command,int argc,const char** argv, int* i_i)
{
	if ((argv==NULL) || (i_i==NULL))
	{
		myprintf("00513: GURU null data\n");
		seppuku();
		return false;
	}

	if (i_opt==i_string)
	{
		command=i_command;
		while (++(*i_i)<argc && argv[(*i_i)][0]!='-')
			files.push_back(argv[(*i_i)]);
		(*i_i)--;
		if (!do_not_print_headers())
			if (flagdebug)
				myprintf("00514: franz:%-21s %21c - command\n",i_string.c_str(),command);

		return true;
	}
	return false;
}

string get_final_part(string i_filename)
{
	string part0=subpart(i_filename, 0);
	
	int parts=0;
	if (part0!=i_filename) 
	{  // multi-part?
		for (int i=1;; ++i) 
		{
			string partname=subpart(i_filename, i);
			if (partname==part0) 
				error("48805: too many archive parts");
			FP fp=myfopen(partname.c_str(), RB);
			if (fp==FPNULL) 
				break;
			++parts;
			if (fp!=NULL)
				myfclose(&fp);
		}
	}
	return subpart(i_filename, parts);
	
}
bool Jidac::cli_getkey	(const string& i_opt,string i_string,int argc,const char** argv, int* i_i,string* o_plain,char**	o_password,char*	o_password_string)
{
		
	if (flagonlyupload)
		return false;
	if ((argv==NULL) || (i_i==NULL) || (o_plain==NULL) || (o_password_string==NULL))
	{
		myprintf("00515: GURU null data\n");
		seppuku();
		return false;
	}
	if (i_opt==i_string)
	{
		if ((*i_i)<argc-1) // I am not the last parameter
			if (argv[(*i_i)+1][0]!='-') // -key pippo -whirlpool
			{
				*(o_plain)="";
				libzpaq::SHA256 sha256;
				for (const char* p=argv[++(*i_i)]; *p; ++p)
				{
					sha256.put(*p);
					(*o_plain)+=*p;
				}
				if (g_keyfilehash!="")
					for (unsigned int i=0;i<g_keyfilehash.size();i++)
					{
						sha256.put(g_keyfilehash[i]);
						(*o_plain)+=g_keyfilehash[i];
					}
					
				memcpy(o_password_string, sha256.result(), 32);
				(*o_password)=o_password_string;
			}
		if ((*o_password)==NULL)
		{
			string spassword=mygetpasswordblind("");
			if (spassword!="")
			{
				if ((command=='a') || (command=='Z'))
				{
					string thefinalpart=get_final_part(archive);
					if (!fileexists(thefinalpart.c_str()))
					{
						string doublepwd=mygetpasswordblind("Password,again :");
						if (doublepwd!=spassword)
						{
							myprintf("\n");
							myprintf("51852! You must enter the exact password TWICE\n");
							seppuku();
						}						
					}
				}
				libzpaq::SHA256 sha256;
				for (unsigned int i=0;i<spassword.size();i++)
					sha256.put(spassword[i]);
				memcpy(o_password_string, sha256.result(), 32);
				(*o_password)=o_password_string;
			}
		}
///		myprintf("00516: ORENGOOOO franz:%-21s %21s\n",i_string.c_str(),(*o_plain).c_str());

		if (!do_not_print_headers())
			if (flagdebug)
			{
				if (flagdebug3)
					myprintf("00516: franz:%-21s %21s\n",i_string.c_str(),(*o_plain).c_str());
				else
					myprintf("00517: franz:%-21s %21s\n",i_string.c_str(),"(hidden)");
			}
		return true;
	}
	return false;
}

bool Jidac::cli_getstring	(const string& i_opt,string i_string,bool	i_flagoptional,const string& i_short,int argc,const char** argv, int* i_i,const string&  i_default,string* o_thestring)
{
	if ((argv==NULL) || (i_i==NULL) || (o_thestring==NULL))
	{
		myprintf("00518: GURU null data\n");
		seppuku();
		return false;
	}
	if ((i_flagoptional) && (i_short=="BEQUIET"))
		return false;
	if (i_opt==i_string)
	{
		///myprintf("$$$$$$$$$$$ %s\n",i_opt.c_str());
		(*o_thestring)=i_default;
		if ( ((*i_i)<argc-1)  )
		{
			(*o_thestring)=argv[++(*i_i)];
			if (!do_not_print_headers())
				if (flagdebug)
				{
					if ((mypos("password",i_string)!=-1) || (i_string=="-p"))
						myprintf("00519: franz:%-21s %21s %d\n",i_string.c_str(),"(hidden)",int(flagterse));
					else
						myprintf("00519: franz:%-21s %21s %d\n",i_string.c_str(),(*o_thestring).c_str(),int(flagterse));
				}
		}
		return true;
	}
	else
	if (i_short.size()==2)
	{
		if ((i_opt[0]=='-') && (isdigit(i_opt[2])))
			if (i_opt[1]==i_short[1])
			{
			///	(*o_thestring)=i_default;
				(*o_thestring)=argv[(*i_i)]+2;
				if (!do_not_print_headers())
					if (flagdebug)
						myprintf("00520: franz:%-21s %21s\n",i_string.c_str(),(*o_thestring).c_str());
				return true;
			}
	}

	return false;
}


bool Jidac::cli_getarray(const string& i_opt,string i_string,int argc,const char** argv, int* i_i,vector<string>* o_files,string* o_stringtype)
{
	if ((argv==NULL) || (i_i==NULL) || (o_files==NULL))
	{
		myprintf("00521: GURU null data\n");
		seppuku();
		return false;
	}

	if (i_opt==i_string)
	{
		while (++(*i_i)<(argc) && (argv[(*i_i)][0]!='-'))
		{
			if (o_stringtype!=NULL)
			{
				if (argv[(*i_i)][0]=='=')
					(*o_stringtype)=argv[(*i_i)];
				else
					(*o_files).push_back(argv[(*i_i)]);
			}
			else
				(*o_files).push_back(argv[(*i_i)]);
		}
		--(*i_i);

		if (!do_not_print_headers())
			if (flagdebug)
				if ((*o_files).size()>0)
				{
					for (unsigned int i=0;i<(*o_files).size();i++)
						myprintf("00522: franz:%-21s %21s\n",i_string.c_str(),(*o_files)[i].c_str());
					printbar('-');
				}
		return true;
	}
	return false;
}

bool Jidac::cli_getint(const string& i_opt,string i_string,bool	i_flagoptional,const string& i_short,int argc,const char** argv, int* i_i,int i_default,int* o_thenumber)
{
	if ((argv==NULL) || (i_i==NULL) || (o_thenumber==NULL))
	{
		myprintf("00523: GURU null data\n");
		seppuku();
		return false;
	}


	if (i_opt==i_string)
	{
		(*o_thenumber)=i_default;
		if (i_flagoptional)
		{
			if ( ((*i_i)<argc-1) )
				if (argv[(*i_i)+1][0]!='-')
					(*o_thenumber)=(int)myatoll(argv[++(*i_i)]);
		}
		else
		{
			if ( ((*i_i)<argc-1) && (isdigit(argv[(*i_i)+1][0])) )
				(*o_thenumber)=(int)myatoll(argv[++(*i_i)]);
		}

		if (!do_not_print_headers())
			if (flagdebug)
				myprintf("00524: franz:%-21s %21s\n",i_string.c_str(),migliaia(*o_thenumber));
		return true;
	}
	else
	if (i_short.size()==2)
	{
		if ((i_opt[0]=='-') && (isdigit(i_opt[2])))
			if (i_opt[1]==i_short[1])
			{
				(*o_thenumber)=i_default;
				(*o_thenumber)=(int)myatoll(argv[(*i_i)]+2);
				if (!do_not_print_headers())
					if (flagdebug)
						myprintf("00525: franz:%-21s %21s\n",i_string.c_str(),migliaia(*o_thenumber));
				return true;
			}
	}
	return false;
}

bool Jidac::cli_getuint(const string& i_opt,string i_string,bool	i_flagoptional,const string& i_short,int argc,const char** argv, int* i_i,unsigned int i_default,unsigned int* o_thenumber)
{
	if ((argv==NULL) || (i_i==NULL) || (o_thenumber==NULL))
	{
		myprintf("00526: GURU null data\n");
		seppuku();
		return false;
	}

	if (i_short=="BEQUIET")
		return false;

	if (i_opt==i_string)
	{
		(*o_thenumber)=i_default;
		if (i_flagoptional)
		{
			if ( ((*i_i)<argc-1) )
				if (argv[(*i_i)+1][0]!='-')
					(*o_thenumber)=(int)myatoll(argv[++(*i_i)]);
		}
		else
		{
			if ( ((*i_i)<argc-1) && (isdigit(argv[(*i_i)+1][0])) )
				(*o_thenumber)=(int)myatoll(argv[++(*i_i)]);
		}
		if (!do_not_print_headers())
			if (flagdebug)
				myprintf("00527: franz:%-21s %21s\n",i_string.c_str(),migliaia(*o_thenumber));
		return true;
	}
	return false;
}
bool Jidac::cli_getuint64(const string& i_opt,string i_string,bool	i_flagoptional,const string& i_short,int argc,const char** argv, int* i_i,uint64_t i_default,uint64_t* o_thenumber)
{
	if ((argv==NULL) || (i_i==NULL) || (o_thenumber==NULL))
	{
		myprintf("00528: GURU null data\n");
		seppuku();
		return false;
	}
	if (i_short=="BEQUIET")
		return false;
	if (i_opt==i_string)
	{
		(*o_thenumber)=i_default;
		if (i_flagoptional)
		{
			if ( ((*i_i)<argc-1) )
				if (argv[(*i_i)+1][0]!='-')
					(*o_thenumber)=(int)myatoll(argv[++(*i_i)]);
		}
		else
		{
			if ( ((*i_i)<argc-1) && (isdigit(argv[(*i_i)+1][0])) )
				(*o_thenumber)=myatoll(argv[++(*i_i)]);
		}
		if (!do_not_print_headers())
			if (flagdebug)
				myprintf("00529: franz:%-21s %21s\n",i_string.c_str(),migliaia(*o_thenumber));
		return true;
	}
	return false;
}

bool Jidac::cli_getdate(string& i_opt,string i_string,int argc,const char** argv, int* i_i,int64_t* o_date)
{
	if ((argv==NULL) || (i_i==NULL) || (o_date==NULL))
	{
		myprintf("00530: GURU null data\n");
		seppuku();
		return false;
	}
	if (i_opt==i_string)
		if ((*i_i)+1<argc)
			if (strlen(argv[(*i_i)+1])>=1)
			{
				string mytimestamp=argv[(*i_i)+1];
				(*i_i)++;
				///format_datetime

				int64_t newdate=encodestringdate(mytimestamp,true);
				if (newdate!=-1)
				{
					
					(*o_date)=newdate;
					
					if (!do_not_print_headers())
						if (flagdebug)
						{
							if (flagdebug3)
								myprintf("00531: franz:%s change from %s => %s\n",i_string.c_str(),dateToString(flagutc,*o_date).c_str(),dateToString(flagutc,newdate).c_str());
							myprintf("00532: franz:%-21s   <<%s>>\n",i_string.c_str(),dateToString(true,newdate).c_str());
						}
					i_opt="skipme";
					
				}
			}
	return false;
}

bool Jidac::cli_onlystring(const string& i_opt,string i_string,string i_alias,string& o_thefile,int argc,const char** argv, int* i_i,bool* i_theflag)
{
	if ((argv==NULL) || (i_i==NULL))
	{
		myprintf("00533: GURU null data\n");
		seppuku();
		return false;
	}
	if (i_alias=="")
		i_alias="@N3b12vc$fjvn4ba";

	if ((i_opt==i_string) || (i_opt==i_alias))
	{
		if (o_thefile=="")
		{
			if (++(*i_i)<argc && argv[(*i_i)][0]!='-')
			{
				o_thefile=argv[(*i_i)];
				if (!do_not_print_headers())
					if (flagdebug)
					{
						if ((mypos("password",i_string)!=-1) || (i_string=="-p"))
							myprintf("00538: franz:%-21s %s\n",i_string.c_str(),"(hidden)");
						else
							myprintf("00534: franz:%-21s <<%s>>\n",i_string.c_str(),o_thefile.c_str());
					}
				if (i_theflag!=NULL)
					(*i_theflag)=true;
			}
			else
				(*i_i)--;
		}

		if (i_string=="-keyfile")
		{
			if (o_thefile!="")
			{
				g_keyfilehash=keyfile_to_string(o_thefile);
				if (g_keyfilehash=="")
				{
					myprintf("49268: bad -keyfile!\n");
					seppuku();
				}
				g_keyfile=o_thefile;
			}
///			myprintf("********************************************** %s\n",g_keyfilehash.c_str());
			
		}
	/*
		g_keyfilehash=keyfile_to_string(g_keyfile);
		if (g_keyfilehash=="")
		{
			myprintf("49268: bad -keyfile\n");
			seppuku();
		}
	*/		


		return true;
	}
	return false;
}

bool	readfiletoarray(string i_filename,vector<string>& o_lines)
{
	o_lines.clear();
	if (!fileexists(i_filename))
	{
		myprintf("00535! cannot find %Z\n",i_filename.c_str());
		return false;
	}
	FILE* myfile = freadopen(i_filename.c_str());
	if (myfile==NULL)
	{
		myprintf("00537: cannot open file %Z\n",i_filename.c_str());
		return false;
	}
#ifdef ANCIENT
	char 	line[16384];
#else
	char 	line[65536];
#endif // corresponds to #ifdef (#ifdef ANCIENT)

	string 	linea;
	while (fgets(line, sizeof(line), myfile))
	{
		linea=line;
		if (flagdebug3)
			myprintf("00539: line %s\n",linea.c_str());
		myreplaceall(linea,std::string(1,10),"");
		myreplaceall(linea,std::string(1,13),"");
		o_lines.push_back(linea);
	}
	fclose(myfile);
	return true;
}

bool isbigendian(void)
{
    union
	{
		uint32_t i;
		char c[4];
    } bint = {0x01020304};
    return bint.c[0] == 1;
}


void replacetabs(std::string &str) 
{
    std::string::size_type pos = 0;
    while ((pos=str.find("\\t", pos))!=std::string::npos) 
        str.replace(pos++,2,"\t");
}

int Jidac::loadparameters(int argc, const char** argv)
{
	///printf("*********************** CARICO *******************\n");

	bool flagdummy=false;
	g_programflags.add(&flag715,			"-715",					"Runs just about like zpaq 7.15",					"a;");
	g_programflags.add(&flagappend,			"-append",				"Append-only (antiransomware, slow)",				"a;");
	g_programflags.add(&flagbackupxxh3,		"-backupxxh3",			"Use XXH3 in backup instead of MD5",				"");
	g_programflags.add(&flagbackupzeta,		"-backupzeta",			"Use ZETA in backup instead of MD5",				"");
	g_programflags.add(&flagbig,			"-big",					"Write the result of the processing in large text",	"all;");
	g_programflags.add(&flagchecksum,		"-checksum",			"Do checksums",										"");
	g_programflags.add(&flagchecktxt,		"-checktxt",			"Create Checktxt.txt",								"");
#ifdef ZPAQFULL ///NOSFTPSTART
#ifdef _WIN32
	g_programflags.add(&flagsfx,			"-sfx",					"Enable SFX module",								"");
#endif // corresponds to #ifdef (#ifdef _WIN32)
#endif ///NOSFTPEND
	g_programflags.add(&flagfasttxt,		"-fasttxt",				"Create test .txt with CRC-32 and QUICK",											"");
	g_programflags.add(&flagcomment,		"-comment",				"Comment version",									"");
	g_programflags.add(&flagwriteonconsole,	"-writeonconsole",		"Write the output on stderr",							"");
	g_programflags.add(&flagappendoutput,	"-appendoutput",		"Append to -out file (do not start from scratch)",							"");
	g_programflags.add(&flagdebug,			"-debug",				"Show debug line number",							"");
	g_programflags.add(&flagdebug2,			"-debug2",				"Show debug infos",									"");
	g_programflags.add(&flagdebug3,			"-debug3",				"Show A LOT of debug",								"");
	g_programflags.add(&flagdebug4,			"-debug4",				"Write debug data on z:\\",							"");
	g_programflags.add(&flagdebug5,			"-debug5",				"Show RAM usage",							"");
	g_programflags.add(&flagdebug6,			"-debug6",				"NTFS/Enforce test",							"");
	g_programflags.add(&flagdesc,			"-desc",				"Orderby desc",										"");
	g_programflags.add(&flagnosymlink,		"-symlink",				"Ignore Windows REPARSE_POINT (Symlink)",										"");
	g_programflags.add(&flagmd5deep,		"-md5deep",				"Run md5deep on cloud",								"");
	g_programflags.add(&flagsha1deep,		"-sha1deep",			"Run sha1deep on cloud",								"");
	g_programflags.add(&flagsha256deep,		"-sha256deep",			"Run sha256deep on cloud",								"");
	g_programflags.add(&flagdonotforcexls,	"-xls",					"Do NOT force adding of XLS/PPT (default: NO)",		"a;");
	g_programflags.add(&flagdummy,			"-debug -zero -kill",	"Add 0-byte long file (debugging)",					"");
	g_programflags.add(&flagdummy,			"-debug -zero",			"Add files but zero-filled (debugging)",			"");
	g_programflags.add(&flagfilelist,		"-filelist",			"Create a filelist .txt",							"");
#ifdef _WIN32
	g_programflags.add(&flagads,			"-ads",					"Store filelists on NTFS",							"");
	g_programflags.add(&flagsparse,			"-sparse",				"Try to create sparse file on Windows",				"");
#endif // corresponds to #ifdef (#ifdef _WIN32)
	g_programflags.add(&flagfast,			"-fast",				"Store filelists inside",							"");
	g_programflags.add(&flagfix255,			"-fix255",				"Fix 255",											"");
	g_programflags.add(&flagfixeml,			"-fixeml",				"Fix eml filenames",								"");
	g_programflags.add(&flagflat,			"-flat",				"Flat filenames",									"");
	g_programflags.add(&flagforce,			"-force",				"Force (usually overwrite)",											"");
	g_programflags.add(&flagforcewindows,	"-forcewindows",		"Store ADS stuff                (default: NO)",		"a;");
	g_programflags.add(&flagforcezfs,		"-forcezfs",			"Enforce using .zfs",								"");
	g_programflags.add(&flagfrugal,			"-frugal",				"Frugal backup",									"");
	g_programflags.add(&flagfranzhash,		"-franzhash",			"Use franzhash",									"");
	g_programflags.add(&flaghashdeep,		"-hashdeep",			"Hashdeep",											"");
	g_programflags.add(&flagignore,			"-ignore",				"Ignore (do not show) file errors",												"a;");
	g_programflags.add(&flaghuge,			"-huge",				"Use different extraction algo",					"");
	g_programflags.add(&flagnotrim,			"-notrim",				"Disable autotrim of incomplete transactions",												"");
	g_programflags.add(&flagonedrive,		"-onedrive",			"Do NOT get onedrive placeholders",												"");
	g_programflags.add(&flaghome,			"-home",				"Divide into multiple files, one for each folder.",												"a;");
	g_programflags.add(&flagkill,			"-kill",				"It usually means 'do something dangerous.'",												"");
	g_programflags.add(&flaght,				"-ht",					"Enable Hyperthread (if any)",												"");
	g_programflags.add(&flagnocaptcha,		"-nocaptcha",			"Skip chaptcha",												"");
	g_programflags.add(&flagmm,				"-mm",					"Memory mapped file",									"");
	g_programflags.add(&flagnoattributes,	"-noattributes",		"Do not store file attribute",									"");
	g_programflags.add(&flagnodir,			"-nodir",				"On 'dir' do not show dirs, only files",									"");
	g_programflags.add(&flagattr,			"-attr",				"Show attribute (listing)",									"");
	g_programflags.add(&flagthunderbird,	"-thunderbird",			"Thunderbird's e-mail",									"");
	g_programflags.add(&flagnodedup,		"-nodedup",				"Turn off deduplicator",							"");
	g_programflags.add(&flagnoeta,			"-noeta",				"Do not show ETA",									"");
	g_programflags.add(&flagnopath,			"-nopath",				"Do not store path",								"");
	g_programflags.add(&flagnoqnap,			"-noqnap",				"Exclude QNAP snap & trash",						"a;");
	g_programflags.add(&flagnomac,			"-nomac",				"Exclude Mac hidden files",						"a;");
	g_programflags.add(&flagnosynology,		"-nosynology",			"Exclude Synology system files",						"a;");
	g_programflags.add(&flagnorecursion,	"-norecursion",			"Do not recurse into folders (default: YES)",		"");
	g_programflags.add(&flagnosort,			"-nosort",				"Do not sort file",									"");
	g_programflags.add(&flaglast,			"-last",				"Work on last file",									"");
	g_programflags.add(&flagpakka,			"-pakka",				"New output style",										"");
	g_programflags.add(&flagdistinct,		"-distinct",			"PAKKA zpaqlist",										"");
	g_programflags.add(&flagparanoid,		"-paranoid",			"Paranoid 'something'",											"");
	///g_programflags.add(&flagpaq,			"-paq",					"Enable paq-levels",											"");
	g_programflags.add(&flagcollision,		"-collision",			"Collision check",											"");
	g_programflags.add(&flagramdisk,		"-ramdisk",				"Ramdisk (really: heap)",											"");
	g_programflags.add(&flagrename,			"-rename",				"Rename",											"");
	g_programflags.add(&flagsilent,			"-silent",				"Silent (no) output",											"");
	g_programflags.add(&flagnoconsole,		"-noconsole",			"Do not manipulate console",						"",flagnoconsole);
	g_programflags.add(&flagskipzfs,		"-zfs",					"Do NOT ignore .zfs             (default: YES)",	""); //flagskipzfs
	g_programflags.add(&flagspace,			"-space",				"Do not check space/writeability",					"");
	g_programflags.add(&flagssd,			"-ssd",					"Reads the files with multithreading from the solid-state drive",												"");
	g_programflags.add(&flagonlyupload,		"-onlyupload",			"In cloud ... just continue upload",				"");
	g_programflags.add(&flagnomore,			"-nomore",				"Disable internal 'more' (ex |less)",				"");
	g_programflags.add(&flagnopid,			"-nopid",				"Do not use pids in backup",				"");
	g_programflags.add(&flagsalt,			"-salt",				"Fix encryption salt to 0",												"");
	g_programflags.add(&flaghdd,			"-hdd",					"HDD (use if possible RAM before drive)",												"");
	g_programflags.add(&flagstat,			"-stat",				"Shows statistics",										"");
	g_programflags.add(&flagstdin,			"-stdin",				"Reads the data to be compressed from stdin",											"");
	g_programflags.add(&flagterse,			"-terse",				"Create output without header and footer",			"");
	g_programflags.add(&flagnodel,			"-nodel",				"Do not show deleted files (in listing)",			"");
	g_programflags.add(&flagstdout,			"-stdout",				"File suitable for extraction via piping to stdout (reduces efficiency).",											"");
	g_programflags.add(&flagstore,			"-store",				"Store mode: no deduplication, no compression",		"");
	g_programflags.add(&flagtar,			"-tar",					"TAR mode (store/show Posix metadata)",							"");
	g_programflags.add(&flagtmp,			"-tmp",					"Use .tmp instead of .zpaq during backup",			"");
	g_programflags.add(&flagtest,			"-test",				"Only do test",										"");
	g_programflags.add(&flagtouch,			"-touch",				"Force 'touch' on date (7.15 to zpaqfranz)",		"");
	g_programflags.add(&flagutc,			"-utc",					"Use UTC time",										"");
	g_programflags.add(&flagdate,			"-date",				"Show/save creation date (if possible)",			"");
	g_programflags.add(&flagutf,			"-utf",					"UTF-8",											"");
	g_programflags.add(&flagverbose,		"-verbose",				"Verbose output",									"");
	g_programflags.add(&flagverify,			"-verify",				"Verify (read from filesystem)",					"");
	g_programflags.add(&flagvss,			"-vss",					"Enable Volume Shadow Copies",						"a;");
	g_programflags.add(&flagzero,			"-zero",				"Zeroing something",										"");
	g_programflags.add(&flagpause,			"-pause",				"Pause after run (for runhigh)",					"");
	g_programflags.add(&flagquiet,			"-quiet",				"Do not show filesystem errors",												"");
#ifdef ZPAQFULL ///NOSFTPSTART
	g_programflags.add(&flagmemzero,		"-memzero",				"Do memzero on libsodium (just placebo)",									"");
	g_programflags.add(&g_sfxflagforce,		"-sfxforce",			"Sfx force",									"");
	g_programflags.add(&g_sfxflagall,		"-sfxall",				"Sfx all",										"");
#endif ///NOSFTPEND
	g_programflags.add(&flagbarraod,		"/od",					"Order by date",									"dir;");
	g_programflags.add(&flagbarraon,		"/on",					"Order by name",									"dir;");
	g_programflags.add(&flagbarraos,		"/os",					"Order by size",									"dir;");

	g_programflags.add(&flagnocolor,		"-nocolor",				"Monochrome output",								"",flagnocolor);
	g_programflags.add(&flagnodelete,		"-nodelete",			"Do not logical delete files",						"");
	g_programflags.add(&flagslow,			"-slow",				"Reduce CPU usage",											"");
	g_programflags.add(&flagshutdown,		"-shutdown",			"Shutdown-after-add",											"");
	g_programflags.add(&flagimage,			"-image",				"Drive image",										"");

#ifdef _WIN32
///	g_programflags.add(&flagdd,				"-dd",					"dd",												"");
	g_programflags.add(&flagmonitoroff,		"-monitor",				"Turn off monitor",											"");
	g_programflags.add(&flagfindzpaq,		"-findzpaq",			"Search .zpaq in every drive letter (USB device)",	"");
	g_programflags.add(&flagfixcase,		"-fixcase",				"Fix CAse",											"");
	g_programflags.add(&flagfixreserved,	"-fixreserved",			"fixreserved",										"");
	g_programflags.add(&flagntfs,			"-ntfs",				"NTFS image",										"");
	g_programflags.add(&flaglongpath,		"-longpath",			"Longpath",											"");
	g_programflags.add(&flagopen,			"-open",				"Abort if archive seems already opened",												"");
#endif // corresponds to #ifdef (#ifdef _WIN32)

	g_programflags.add(&flaghw,				"-hw",					"Use HW SHA1",										"a;x;");
	g_programflags.add(&flagnojit,			"-nojit",				"Do not use JIT",									"");


	for (int i=0; i<argc; i++)
	{
		const string parametro=argv[i];

		if (g_programflags.exists(parametro))
			g_programflags.settrue(parametro);
	}
	
	if (flagdebug3)
		flagdebug2=true;
	if (flagdebug2)
		flagdebug=true;
	if (flagdebug)
		flagverbose=true;
	
	if (flagdebug3)
		g_programflags.debugga();

///flemma
	// A bit of refactoring. The boolean differentiate hashes used inside zpaqfranz archive
	g_mappatipohash.insert(std::pair<int, tipohash>(FRANZO_NONE		 ,	tipohash("NONE",		0,"Disable checksums",											true	,"-nochecksum",		&flagnochecksum,	&finalizza_none,		"")));
	g_mappatipohash.insert(std::pair<int, tipohash>(FRANZO_CRC_32	 ,	tipohash("CRC-32",	 	8,"Old but ubiquitous, superfast, not very strong",				true	,"-crc32",			&flagcrc32,			&finalizza_crc32,		TOSTRING(FRANZO_CRC_32))));
	g_mappatipohash.insert(std::pair<int, tipohash>(FRANZO_XXHASH64	 ,	tipohash("XXHASH64",   16,"Very fast, low CPU usage, zpaqfranz's default",				true	,"-xxhash",			&flagxxhash64,		&finalizza_xxhash64,	TOSTRING(FRANZO_XXHASH64))));
	g_mappatipohash.insert(std::pair<int, tipohash>(FRANZO_XXHASH64B ,	tipohash("XXHASH64B",  16,"Very fast, low CPU usage, zpaqfranz's 60+ default",			true	,"-xxhashb",		&flagxxhash64b,		&finalizza_xxhash64,	TOSTRING(FRANZO_XXHASH64B))));
	g_mappatipohash.insert(std::pair<int, tipohash>(FRANZO_SHA_1	 ,	tipohash("SHA-1",	   40,"Fair speed, very reliable, some collisions known",			true	,"-sha1",			&flagsha1,			&finalizza_sha1,		TOSTRING(FRANZO_SHA_1))));
	g_mappatipohash.insert(std::pair<int, tipohash>(FRANZO_SHA_1B	 ,	tipohash("SHA-1B",	   40,"Fair speed, very reliable, some collisions known",			true	,"-sha1b",			&flagsha1b,			&finalizza_sha1,		TOSTRING(FRANZO_SHA_1B))));
	g_mappatipohash.insert(std::pair<int, tipohash>(FRANZO_SHA_256	 ,	tipohash("SHA-256",	   64,"CPU intensive, one of the most reliable. Legal proof in EU",	true	,"-sha256",			&flagsha256,		&finalizza_sha256,		TOSTRING(FRANZO_SHA_256))));
	g_mappatipohash.insert(std::pair<int, tipohash>(FRANZO_SHA_256B	 ,	tipohash("SHA-256B",   64,"CPU intensive, one of the most reliable. Legal proof in EU",	true	,"-sha256b",		&flagsha256b,		&finalizza_sha256,		TOSTRING(FRANZO_SHA_256B))));
	g_mappatipohash.insert(std::pair<int, tipohash>(FRANZO_XXH3		 ,	tipohash("XXH3",	   32,"Very fast and strong, zpaqfranz default for file comparing",	true	,"-xxh3",			&flagxxh3,			&finalizza_xxh3,		TOSTRING(FRANZO_SHA3))));
	g_mappatipohash.insert(std::pair<int, tipohash>(FRANZO_XXH3B	 ,	tipohash("XXH3B",	   32,"Very fast and strong, zpaqfranz default for file comparing",	true	,"-xxh3b",			&flagxxh3b,			&finalizza_xxh3,		TOSTRING(FRANZO_XXH3B))));
	g_mappatipohash.insert(std::pair<int, tipohash>(FRANZO_MD5		 ,	tipohash("MD5",	       32,"Common, fast, hashdeep compatible. Not cryptographically secure",	true	,"-md5",			&flagmd5,			&finalizza_md5,			TOSTRING(FRANZO_MD5))));
	g_mappatipohash.insert(std::pair<int, tipohash>(FRANZO_MD5B		 ,	tipohash("MD5B",	   32,"Common, fast, hashdeep compatible. Not cryptographically secure",	true	,"-md5b",			&flagmd5b,			&finalizza_md5,			TOSTRING(FRANZO_MD5B))));
	g_mappatipohash.insert(std::pair<int, tipohash>(FRANZO_BLAKE3	 ,	tipohash("BLAKE3",	   64,"Fast, CPU intensive (on Win64 HW acceleration), reliable",	true	,"-blake3",			&flagblake3,		&finalizza_blake3,		TOSTRING(FRANZO_BLAKE3))));
	g_mappatipohash.insert(std::pair<int, tipohash>(FRANZO_BLAKE3B	 ,	tipohash("BLAKE3B",	   64,"Fast, CPU intensive (on Win64 HW acceleration), reliable",	true	,"-blake3b",		&flagblake3b,		&finalizza_blake3,		TOSTRING(FRANZO_BLAKE3B))));
	g_mappatipohash.insert(std::pair<int, tipohash>(FRANZO_SHA3		 ,	tipohash("SHA-3",	   64,"Latest NIST standard, very strong",							true	,"-sha3",			&flagsha3,			&finalizza_sha3,		TOSTRING(FRANZO_SHA3))));
	g_mappatipohash.insert(std::pair<int, tipohash>(FRANZO_SHA3B	 ,	tipohash("SHA-3B",	   64,"Latest NIST standard, very strong",							true	,"-sha3b",			&flagsha3b,			&finalizza_sha3,		TOSTRING(FRANZO_SHA3B))));
	g_mappatipohash.insert(std::pair<int, tipohash>(FRANZO_WHIRLPOOL ,	tipohash("WHIRLPOOL", 128,"Slow but very reliable",										true	,"-whirlpool",		&flagwhirlpool,		&finalizza_whirlpool,	TOSTRING(FRANZO_WHIRLPOOL))));
	g_mappatipohash.insert(std::pair<int, tipohash>(FRANZO_HIGHWAY64 ,	tipohash("HIGHWAY64",  16,"Experimental Google HighwayHash, C implementation, 64 bit",		true	,"-highway64",		&flaghighway64,		&finalizza_highway64,	TOSTRING(FRANZO_HIGHWAY64))));
	g_mappatipohash.insert(std::pair<int, tipohash>(FRANZO_HIGHWAY128,	tipohash("HIGHWAY128", 32,"Experimental Google HighwayHash, C implementation, 128 bit",		true	,"-highway128",		&flaghighway128,	&finalizza_highway128,	TOSTRING(FRANZO_HIGHWAY128))));
	g_mappatipohash.insert(std::pair<int, tipohash>(FRANZO_HIGHWAY256,	tipohash("HIGHWAY256", 64,"Experimental Google HighwayHash, C implementation, 256 bit",		true	,"-highway256",		&flaghighway256,	&finalizza_highway256,	TOSTRING(FRANZO_HIGHWAY256))));
	g_mappatipohash.insert(std::pair<int, tipohash>(ALGO_CRC32C		 ,	tipohash("CRC-32C",	    8,"'Castagnoli' variation of CRC-32, HW accelerated",			false	,"-crc32c",			&flagcrc32c,		&finalizza_crc32c,		TOSTRING(ALGO_CRC32C))));
	g_mappatipohash.insert(std::pair<int, tipohash>(ALGO_WYHASH		 ,	tipohash("WYHASH",	   16,"Maybe the fastest, limited 'strength'",						false	,"-wyhash",			&flagwyhash,		&finalizza_wyhash,		TOSTRING(ALGO_WYHASH))));
	g_mappatipohash.insert(std::pair<int, tipohash>(ALGO_NILSIMSA	 ,	tipohash("NILSIMSA",  128,"Look for similarities, not differences",						false	,"-nilsimsa",		&flagnilsimsa,		&finalizza_nilsimsa,	TOSTRING(ALGO_NILSIMSA))));
	g_mappatipohash.insert(std::pair<int, tipohash>(ALGO_ENTROPY	 ,	tipohash("ENTROPY",     6,"Quick-and-dirty entropy estimator",							false	,"-entropy",		&flagentropy,		&finalizza_entropy,		TOSTRING(ALGO_ENTROPY))));
	g_mappatipohash.insert(std::pair<int, tipohash>(ALGO_QUICK	 	 ,	tipohash("QUICK",      16,"Quick partial hasher",										false	,"-quick",			&flagquick,			&finalizza_xxhash64,	TOSTRING(ALGO_QUICK))));
	g_mappatipohash.insert(std::pair<int, tipohash>(ALGO_ZETA	 	 ,	tipohash("ZETA",       16,"Zpaq partial hasher",										false	,"-zeta",			&flagzeta,			&finalizza_xxhash64,	TOSTRING(ALGO_ZETA))));
	g_mappatipohash.insert(std::pair<int, tipohash>(ALGO_ZETAENC	 ,	tipohash("ZETAENC",    16,"Zpaq partial hasher (encrypted)",							false	,"-zetaenc",		&flagzetaenc,		&finalizza_xxhash64,	TOSTRING(ALGO_ZETAENC))));
#ifdef _WIN32
	g_mappatipohash.insert(std::pair<int, tipohash>(FRANZO_WINHASH64,tipohash("WINHASH64", 	16,"Same as xxhash64 (with Windows' dates)",						true	,"-windate",		&flagwindate,		&finalizza_xxhash64,	TOSTRING(FRANZO_WINHASH64))));
#endif // corresponds to #ifdef (#ifdef _WIN32)
	// Initialize options to default values
	// Why some variables out of Jidac? Because of pthread: does not like very much C++ objects
	// quick and dirty.
	g_ioBUFSIZE			=1048576;	//not more just like zpaq
	g_thechosenhash		=FRANZO_SHA_1; //FRANZO_SHA_1;
	g_thechosenhash_str	="SHA-1";
	fullcommandline		="";
  	plainpassword		="";
	g_mysql_host		="127.0.0.1";
	g_mysql_port		=3306;
	g_mysql_password	="";
	g_mysql_user		="root";

#ifdef ZPAQFULL ///NOSFTPSTART
#ifdef SFTP
	g_sftp_key			="";
	g_sftp_host			="";
	g_sftp_port			=22;
	g_sftp_bandwidth	=0;
	g_sftp_password		="";
	g_sftp_user			="";
	g_sftp_remote		="";
#endif // corresponds to #ifdef (#ifdef SFTP)
#endif ///NOSFTPEND
	g_device_fd			=-1;
	g_device_size		=0;

	g_franzsnap			="c:/franzsnap";
	g_vss_shadow		="";
	g_replaceme			="";
	g_franzotype		=FRANZO_XXHASH64B; //by default take CRC-32 AND XXHASH64
	g_franzotypelen		=16;
	g_255				=0; // errors on longer than 255 chars
	g_deleteinto		="";
#ifdef ZPAQFULL ///NOSFTPSTART
	g_sfx				="";
	g_sfxto				="";
	g_sfxnot			="";
	g_sfxonly			="";
	g_sfxuntil			="";
#endif ///NOSFTPEND
	g_freeze			="";
	g_archive			="";
	g_indexname			="";
	g_csvstring			="";
	g_csvhf				="";
	g_bin				="";
	g_pidname			="";
	g_backupposition	="";
	g_output_handle		=NULL;
	g_error_handle		=NULL;
	g_archivefp			=FPNULL;
	g_output			="";
	g_error				="";
	g_exec_error		="";
	g_exec_warn			="";
	g_exec_ok			="";
	g_exec				="";
	g_exec_text			="";
	g_copy				="";
	g_until				="";
#ifdef unix
	g_tempsnapshot		="";
	g_basesnapshot		="";
	g_dataset			="";
#endif // corresponds to #ifdef (#ifdef unix)
	command				=0;
	fragment			=6;
	minsize				=0;
	g_ramsize			=0;
	flagramsize			=false;
	g_checksize			=0;
	maxsize				=0;
	g_remotespeed		=0;
	dirlength			=0;
	filelength			=0;
	all					=0;
	g_password			=0;
	index				=0;
	g_keyfilehash		="";
	g_keyfile			="";
	method				="";
	repack				="";
	checktxt			="";
	fasttxt				="";
	indexfasttxt		="";
	backuptxt			="";
	backupindex			="";
	new_password		=0;
	summary				=-1;
	menoenne			=0;
	versioncomment		="";
	searchfrom			="";
	snapmark			="";
	orderby				="";
	replaceto			="";
	searchhash			="";
	zpaqfranzexename	="";
	fullzpaqexename		="";
	howmanythreads		=0;
	version				=DEFAULT_VERSION;
	date				=0;
	g_flagmultipart		=false;
	g_flagcreating		=false;
	g_testifselected	=false;
	flagrange			=false;
	
	bool flagforzarobocopy=false;

	if (argc>1)
		for (int i=1; i<argc; i++)
			fullcommandline+=string(argv[i])+" ";


	if (argc>0)
	{
		zpaqfranzexename=argv[0];
#ifdef _WIN32
		if (!isextension(zpaqfranzexename.c_str(), ".exe"))
			zpaqfranzexename+=".exe";
#endif // corresponds to #ifdef (#ifdef _WIN32)
	}


	const char *no_color=getenv("NO_COLOR");
	if ((no_color!=NULL) && (no_color[0]!='\0'))
		flagnocolor=true;
#ifdef _WIN32
	color_save();
	wchar_t myexepath[_MAX_PATH];
	GetModuleFileName(NULL,myexepath,_MAX_PATH);
	fullzpaqexename=wtou(myexepath);
#endif // corresponds to #ifdef (#ifdef _WIN32)

#ifdef unix
	fullzpaqexename=my_realpath(zpaqfranzexename);

#ifdef BSD  // BSD
#ifndef __OpenBSD__ 	// OpenBSD is not FreeBSD
#ifndef __APPLE__   	// Mac is different (of course)
	if (flagdebug)
		myprintf("00540: Pretend to be FreeBSD\n");
	int mib[4];
	mib[0]=CTL_KERN;
	mib[1]=KERN_PROC;
	mib[2]=KERN_PROC_PATHNAME;
	mib[3]=-1;
	char buf[1024];
	size_t cb=sizeof(buf);
	sysctl(mib,4,buf,&cb,NULL,0);
	fullzpaqexename=my_realpath(buf);
#endif // corresponds to #ifndef (#ifndef __APPLE__   	// Mac is different (of course))
#endif // corresponds to #ifndef (#ifndef __OpenBSD__ 	// OpenBSD is not FreeBSD)
#endif // corresponds to #ifdef (#ifdef BSD  // BSD)


#ifdef __linux__
	if (flagdebug)
		myprintf("00541: Pretend to be Linux\n");
	const size_t bufSize = PATH_MAX + 1;
	char buf[bufSize]={0};
	const char *linkName = "/proc/self/exe";
	if (readlink(linkName, buf, bufSize - 1)>0)
		fullzpaqexename=buf;
	///else
		///myprintf("00542: something wrong!");
#endif // corresponds to #ifdef (#ifdef __linux__)

#ifdef SOLARIS
	if (flagdebug)
		myprintf("00543: Pretend to be Solaris\n");
	fullzpaqexename=getexecname();
#endif // corresponds to #ifdef (#ifdef SOLARIS)

#ifdef __APPLE__   	// Mac is different (of course)
	if (flagdebug)
		myprintf("00544: Pretend to be Mac\n");
	char buf[1024];
	uint32_t size = sizeof(buf);
	if (_NSGetExecutablePath(buf, &size) == 0)
		fullzpaqexename=buf;
#endif // corresponds to #ifdef (#ifdef __APPLE__   	// Mac is different (of course))

	///	If I pretend to be... dir... work like dir!
	string myexename=extractfilename(zpaqfranzexename);
	if (myexename=="dir")
	{
		files.clear();
		int i=0;
		while (++i<argc && argv[i][0]!='-')  // read filename args
			files.push_back(argv[i]);
		dir();
		seppuku();
		return 0;
	}
	if (myexename=="robocopy")
		flagforzarobocopy=true;
#endif // corresponds to #ifdef (#ifdef unix)

	if (flagdebug)
	{	
		if (isbigendian())
			myprintf("00545: This seems a BIG ENDIAN CPU    (aka:'strange')\n");
		else
			myprintf("00546: This seems a LITTLE ENDIAN CPU (aka:'normal')\n");
	}
	if (argc>=2) // early disable output
	{
		if  (stringcomparei(argv[1],"last"))
			flagpakka=true;

		if  (stringcomparei(argv[1],"fzf"))
		{
			flagpakka=true;
			flagstdout=false;
			flagnoeta=true;
		}
	}

	if (flagdebug)
		myprintf("52860: k0 flagnojit %d\n",int(flagnojit));

#if defined(__amd64__) || defined(__i386__)
	if (flagdebug)
		myprintf("52820: This seems amd64/i386, turning OFF flagnojit\n");
	flagnojit=false;
	
#ifdef unix
	if (flagdebug)
		myprintf("52588: UNIX: checking OS support for JIT\n");
    void* p=(void*)mmap(0,8192, PROT_READ|PROT_WRITE|PROT_EXEC,MAP_PRIVATE|MAP_ANON, -1, 0);
	if (p==MAP_FAILED) 
	{
		if (flagverbose)
			myprintf("52594$ OS unsupported, turning ON flagnojit\n");
		flagnojit=true;
	}
	else
	{
		if (flagdebug)
			myprintf("52850: mmap OK, releasing\n");
		munmap(p,8192);
	}
#endif // corresponds to #ifdef (#ifdef unix)
#else
	if (flagdebug)
		myprintf("52824: CPU not amd64/i386, turning ON flagnojit\n");
	flagnojit=true;
#endif // corresponds to #if (#if defined(__amd64__) || defined(__i386__))

	if (flagdebug)
		myprintf("52861: k1 flagnojit %d\n",int(flagnojit));

#if defined(NOJIT) || defined(BIG) // those are really "strange"
	if (flagdebug)
		myprintf("52847: -DNOJIT or -DBIG => turning on flagnojit\n");
	flagnojit=true;
#endif // corresponds to #if (#if defined(NOJIT) || defined(BIG) // those are really "strange")

	if (flagdebug)
		myprintf("52862: k2 flagnojit %d\n",int(flagnojit));

	string textnojit="-JIT,";
	if (flagnojit)
		textnojit="-NOJIT,";
		
#ifdef ESX
	textnojit="-ESX,";
#endif // corresponds to #ifdef (#ifdef ESX)

#ifdef NAS
	textnojit="-NAS,";
#endif // corresponds to #ifdef (#ifdef NAS)

	if (flag715)
		myprintf("52511: zpaq v7.15 journaling archiver, compiled Aug 17 2016\n");
	else
	{
		if ((!flagpakka) && (!flagstdout) && (!flagterse))
		{
			char buffer[300];
			if (iswindowsxp())
				textnojit+="-WinXP";
#ifdef ZPAQFULL ///NOSFTPSTART
#ifdef SFTP
				textnojit+="SFTP";
#ifdef _WIN64
	if (wehaveresources())
		textnojit+=",RES";
		
#endif
#endif // corresponds to #ifdef (#ifdef SFTP)
#endif ///NOSFTPEND

#ifndef ZPAQFULL
		snprintf(buffer,sizeof(buffer),"zpaqfranz-open v" ZPAQ_VERSION "%s" TEXT_BIG TEXT_ALIGN TEXT_HWPRE TEXT_HWBLAKE3 TEXT_HWSHA1 TEXT_HWSHA2 TEXT_IPV ZSFX_VERSION ZPAQ_DATE,textnojit.c_str()); 
#else
		snprintf(buffer,sizeof(buffer),"zpaqfranz v" ZPAQ_VERSION "%s" TEXT_BIG TEXT_ALIGN TEXT_HWPRE TEXT_HWBLAKE3 TEXT_HWSHA1 TEXT_HWSHA2 TEXT_IPV ZSFX_VERSION ZPAQ_DATE,textnojit.c_str()); 
#endif
			color_green();
			moreprint(buffer);
			color_restore();
		}
	}
	if (flagdebug)
		myprintf("00547: FULL exename <<%s>>\n",fullzpaqexename.c_str());

	

	for (int i=1;i<argc;i++)
		if  (stringcomparei(argv[i],"-nomore"))
		{
			flagnomore=true;
			break;
		}
		
#ifdef _WIN64
	if (flagnomore)
	{
		// Enable the use of large pages
		HANDLE hProcess=GetCurrentProcess();
		SIZE_T largePageMinimum=GetLargePageMinimum();
		if (largePageMinimum>0) 
		{
			BOOL success=SetProcessWorkingSetSize(hProcess,largePageMinimum,largePageMinimum);
			if (success) 
				myprintf("52927: Large page OK %s\n",migliaia(largePageMinimum));
			 else 
				myprintf("52929! Large page KAPUTT %s\n",migliaia(largePageMinimum));
		} 
		else 
			myprintf("52930$ Large page support not available on this system\n");
	}	
#endif // corresponds to #ifdef (#ifdef _WIN64)

/// check some magic to show help in heuristic way
/// I know, it's bad, but help is always needed!
	if (argc==1) // zero parameters
	{
		usage();
		seppuku();
	}
	if (argc==2) // only ONE
	{
		const string parametro=argv[1];
		if  ((stringcomparei(parametro,"help"))
			||
			(stringcomparei(parametro,"-h"))
			||
			(stringcomparei(parametro,"h"))
			||
			(stringcomparei(parametro,"?"))
			||
			(stringcomparei(parametro,"-?"))
			||
			(stringcomparei(parametro,"/?"))
			||
			(stringcomparei(parametro,"--help"))
			||
			(stringcomparei(parametro,"-help")))
			{
				helphelp();
				seppuku();
			}
		if ((stringcomparei(parametro,"-he"))
			||
			(stringcomparei(parametro,"-helpe"))
			||
			(stringcomparei(parametro,"-example"))
			||
			(stringcomparei(parametro,"-examples")))
			{
				examples("");
				seppuku();
			}
	}
	if ((argc==3)||(argc==4)) // only TWO (-examples sha1)
	{
		const string parametro	=argv[1];
		const string comando	=argv[2];
		if  ((stringcomparei(parametro,"help"))
			||
			(stringcomparei(parametro,"-h"))
			||
			(stringcomparei(parametro,"h"))
			||
			(stringcomparei(parametro,"?"))
			||
			(stringcomparei(parametro,"/?"))
			||
			(stringcomparei(parametro,"-?"))
			||
			(stringcomparei(parametro,"--help"))
			||
			(stringcomparei(parametro,"-help")))
			{
				if (comando=="h") /// zpaqfranz h h
					usageall("");
				else
				{
					///myprintf("$$$$$$$$$$$$$ comando %s\n",comando.c_str());
					usageall(comando);
				}
				seppuku();
			}
		if ((stringcomparei(parametro,"-he"))
			||
			(stringcomparei(parametro,"-helpe"))
			||
			(stringcomparei(parametro,"-example"))
			||
			(stringcomparei(parametro,"-examples")))
			{
				examples(comando);
				seppuku();
			}
			
	}
  // Init archive state
	ht.resize(1);  // element 0 not used
	ver.resize(1); // version 0
	dhsize=dcsize=0;
	// Get date
	time_t nowz=time(NULL);
	const tm* t=gmtime(&nowz);
	date=(t->tm_year+1900)*10000000000LL+(t->tm_mon+1)*100000000LL
      +t->tm_mday*1000000+t->tm_hour*10000+t->tm_min*100+t->tm_sec;
	g_optional="";

	///	a bit of refactoring. getting, early, the hasher
	static const string	dummyhash="-dummyhash";
	int		howmanyhasher=0;
	for (int i=1; i<argc; ++i)
		for (MAPPATIPOHASH::iterator p=g_mappatipohash.begin(); p!=g_mappatipohash.end(); ++p)
			if (argv[i]==(p->second.switchname))
				if ((p->second.switchflag)!=NULL)
				{
					*(p->second.switchflag)=true;
					argv[i]=dummyhash.c_str();
					howmanyhasher++;
					g_thechosenhash=p->first;
					g_thechosenhash_str=p->second.hashname;
				}
	if (howmanyhasher>1)
	{
		myprintf("\n");
		myprintf("00548: ABORT: you cannot choose more than ONE hasher, but you picked %d\n",howmanyhasher);
		for (MAPPATIPOHASH::iterator p=g_mappatipohash.begin(); p!=g_mappatipohash.end(); ++p)
			if (p->second.switchname!="")
					myprintf("%s ",p->second.switchname.c_str());
		myprintf("\n");
		seppuku();
		return 0;
	}
	if (flagdebug)
		myprintf("00549: The chosen algo %d %s\n",g_thechosenhash,g_thechosenhash_str.c_str());

#ifdef HWSHA2
		if (ihavehw())
		{
			if (flagverbose)
				myprintf("00550: DETECTED SHA1/2 HW INSTRUCTIONS\n");
			flaghw=true;
		}
#endif // corresponds to #ifdef (#ifdef HWSHA2)
// Get optional options. the hasher turned to -dummyhash

	string myrange="";

	for (int i=1; i<argc; ++i)
	{
		string opt=argv[i];  // read command
		if (flagforzarobocopy)
		{
			opt			="robocopy";
			flagkill	=true;
			flagverbose	=true;
			flagspace	=true;
		}
		///myprintf("---- >opt  %s\n",opt.c_str());

		if (opt=="-dummyhash")
		{
			/// taken by hash selection
		}
		else if ((opt=="benchmark") || (opt=="b"))		command='b';
		else if ((opt=="autotest"))						command='8';
		else if ((opt=="pause")) 						command='0';
		else if (cli_filesandcommand(opt,"d",			'd',argc,argv,&i));
		else if (cli_filesandcommand(opt,"dir",			'2',argc,argv,&i));
		else if (cli_filesandcommand(opt,"find",		'j',argc,argv,&i));
		else if (cli_filesandcommand(opt,"isopen",		'!',argc,argv,&i));
		else if (cli_filesandcommand(opt,"password",	'6',argc,argv,&i));
		else if (cli_filesandcommand(opt,"rsync",		'3',argc,argv,&i));
		else if (cli_filesandcommand(opt,"1on1",		')',argc,argv,&i));
		else if (cli_filesandcommand(opt,"sum",			'1',argc,argv,&i));
		else if (cli_filesandcommand(opt,"hash",		'9',argc,argv,&i));
		else if (cli_filesandcommand(opt,"trim",		'4',argc,argv,&i));
		else if (cli_filesandcommand(opt,"versum",		'|',argc,argv,&i));
		else if (cli_filesandcommand(opt,"last2",		'^',argc,argv,&i));
		else if (cli_filesandcommand(opt,"testbackup",	'_',argc,argv,&i));
		else if (cli_filesandcommand(opt,"comparehex",	'?',argc,argv,&i));
		else if (cli_filesandcommand(opt,"work",		']',argc,argv,&i));
#ifdef ZPAQFULL ///NOSFTPSTART
#ifdef SFTP
		else if (cli_filesandcommand(opt,"sftp",		'@',argc,argv,&i));
		else if (cli_filesandcommand(opt,"ssh",			'@',argc,argv,&i));
#endif // corresponds to #ifdef (#ifdef SFTP)
#endif ///NOSFTPEND
		else if (cli_filesandcommand(opt,"big",			'/',argc,argv,&i));
		else if (cli_filesandcommand(opt,"count",	    '[',argc,argv,&i));
		else if (cli_filesandcommand(opt,"consolidate",	'Y',argc,argv,&i));
		else if (cli_filesandcommand(opt,"zfsrestore",	'%',argc,argv,&i));
		else if (cli_filesandcommand(opt,"zfslist",		'B',argc,argv,&i));
		else if (cli_filesandcommand(opt,"zfspurge",	'C',argc,argv,&i));
		else if (cli_filesandcommand(opt,"zfssize",		'H',argc,argv,&i));
#if defined(_WIN32)
		else if (cli_filesandcommand(opt,"rd",			'7',argc,argv,&i));
		else if (cli_filesandcommand(opt,"drive",		'G',argc,argv,&i));
		else if (cli_filesandcommand(opt,"drives",		'G',argc,argv,&i));
		
#endif // corresponds to #if (#if defined(_WIN32))
	else
		if ((
		opt=="checkpassword" 	||
		opt=="pakka" 			||
		opt=="ntfs"				||
		opt=="add" 				||
		opt=="backup"			||
		opt=="append"			||
		opt=="extract" 			||
		opt=="last" 			||
		opt=="list" 			||
		opt=="mysqldump" 		||
#ifndef ANCIENT
		opt=="ls" 				||
		opt=="tui" 				||
#endif
#ifdef ZPAQFULL ///NOSFTPSTART
#ifdef SFTP
		opt=="cloud"				||
#endif
#endif ///NOSFTPEND
		opt=="dump" 			||
		opt=="collision"		||
		opt=="fzf" 				||
		opt=="k" 				||
		opt=="a"  				||
		opt=="e"  				||
		opt=="x" 				||
		opt=="p" 				||
		opt=="t" 				||
		opt=="test" 			||
		opt=="sync" 			||
		opt=="l" 				||
		opt=="v"				||
		opt=="w"				||
		opt=="i" 				||
		opt=="q" 				||
		opt=="g" 				||
#ifdef ZPAQFULL ///NOSFTPSTART
		opt=="sfx" 				||
#endif ///NOSFTPEND
		opt=="crop" 			||
		opt=="m"				||
		opt=="dirsize"  		||
		opt=="zfsadd"  			||
		opt=="zfsreceive"  		||
		opt=="zfsproxbackup"  	||
		opt=="zfsproxrestore"  	||
		opt=="zfsbackup")
        && i<argc-1 && argv[i+1][0]!='-' && command==0)
		{
			command=opt[0];
		///myprintf("00551: comando %c\n",command);
			if (opt=="append")
			{
				g_optional="ransomware";
				flagappend=true;
			}
#ifndef ANCIENT
			if (opt=="tui")
				command='T';
			if (opt=="ls")
				command=':';
#endif

			if (opt=="zfsadd")
			{
				g_optional="zfsadd";
				command='A';
			}
			if (opt=="checkpassword")
				command='N';
			if (opt=="mysqldump")
				command='M';
			if (opt=="ntfs")
				command='E';
			if (opt=="dump")
				command='D';
			if (opt=="collision")
				command='K';
			if (opt=="crop")
				command='+';
			if (opt=="fzf")
				command='F';
			if (opt=="backup")
			{
				flagtmp=true;
				command='Z';
			}
			if (opt=="last")
			{
				command='L';
				flagpakka=true;
			}
#ifdef ZPAQFULL ///NOSFTPSTART
#ifdef SFTP
			if (opt=="cloud")
				command='O';
#endif
#endif ///NOSFTPEND
			if (opt=="pakka")
				command='.';
			if (opt=="zfsreceive")
				command=';';
			if (opt=="zfsbackup")
				command='$';
			if (opt=="zfsproxbackup")
				command='=';
			if (opt=="zfsproxrestore")
				command='(';
			if (opt=="extract")
				command='x';
			if (opt=="test")
				command='t';
			if (opt=="sync")
				command='I';
#ifdef ZPAQFULL ///NOSFTPSTART
			if (opt=="sfx")
				command='y';
#endif ///NOSFTPEND
			if (opt=="dirsize")
			{
				command='5';
				g_optional="dirsize";
			}
			archive=argv[++i];  // append ".zpaq" to archive if no extension
			
			if (opt=="backup")
			{
				string percorso=extractfilepath(archive);
				if (percorso=="")
					archive="./"+archive;
				if (flagdebug)
					myprintf("00552: backup path |%s| archive |%s|\n",percorso.c_str(),archive.c_str());
			}
			fullarchive="";

			if ((command=='x') || (command=='t'))
			{
				const char* star	=strrchr(argv[i], '*');
				///const char* qmark	=NULL; //conflict with multipart strrchr(argv[i], '?');
				if ((star) /*|| (qmark)*/)
				{
					fullarchive=archive;
					myprintf("00553: Jolly in archivename!\n");
				}
			}
			const char* slash	=strrchr(argv[i], '/');
			const char* dot		=strrchr(slash ? slash : argv[i], '.');
			if (!dot && archive!="")
				archive+=".zpaq";
			while (++i<argc && argv[i][0]!='-')
				files.push_back(argv[i]);
			--i;

			
///zpaqfranz a z:\foo
///if file "./foo" or folder "./foo" does esists, create or update "z:\foo.zpaq" with the "./foo"
			if ((opt=="a") || (opt=="add"))
				if (files.size()==0)
				{
					if (archive!="")
					{
						string candidate="./"+prendinomefileebasta(archive);
						if (fileexists(candidate) || direxists(candidate))
						{
							candidate=prendinomefileebasta(archive);
							files.push_back(candidate);
							myprintf("00554: Founded %Z => automagically added\n",candidate.c_str());
						}
					}
				}
		}
		else if (
		(opt=="n") 			||
		(opt=="f") 			||
		(opt=="c") 			||
		(opt=="s") 			||
		(opt=="utf") 		||
		(opt=="r") 			||
		(opt=="robocopy") 	||
		(opt=="cp") 	||
#ifdef _WIN32
		(opt=="ads") 	||
#endif // corresponds to #ifdef (#ifdef _WIN32)
#ifdef _WIN64
		(opt=="download") 	||
#endif // corresponds to #ifdef (#ifdef _WIN64)
		(opt=="update") 	||
		(opt=="upgrade") 	||
		(opt=="redu") ||
		opt=="z")
		{
			command=opt[0];
			if (opt=="cp")
				command='o';

			if ((opt=="upgrade") || (opt=="update"))
				command='U';

#ifdef _WIN64
			if (opt=="download")
				command='W';
#endif // corresponds to #ifdef (#ifdef _WIN64)

			if (opt=="redu")
				command='R';
#ifdef _WIN32
			if (opt=="ads")
				command='S';
			if (opt=="update")
				command='U';
#endif // corresponds to #ifdef (#ifdef _WIN32)
			if (flagforzarobocopy)
			{
				///myprintf("00556: i=%d  argc %d\n",(int)i,argc);
				if (i==1)
					i--;
			}
			while (++i<argc && argv[i][0]!='-')
			{
	//	a very ugly fix for last \ in Windows
				string candidate=argv[i];
				cutdoublequote(candidate);
				if (havedoublequote(candidate))
				{
					myprintf("00557$ WARNING: double quote founded in command line and cutted\n");
					candidate=mypopback(candidate);
					myprintf("||%s||\n",candidate.c_str());
				}
				files.push_back(candidate);
			}
			i--;
		}
		else if ((!flagforzarobocopy) && ((opt.size()<2 || opt[0]!='-'))) usage();
		else if (cli_getint		(opt,"-P",			false,	"-P",							argc,argv,&i,4,					&g_mysql_port));
		else if (cli_getint		(opt,"-bandwidth",	false,	"",								argc,argv,&i,0,					&g_sftp_bandwidth));
#ifdef ZPAQFULL ///NOSFTPSTART
#ifdef SFTP
		else if (cli_getint		(opt,"-port",		false,	"",								argc,argv,&i,22,				&g_sftp_port));
#endif // corresponds to #ifdef (#ifdef SFTP)
#endif ///NOSFTPEND
		else if (cli_getint		(opt,"-all",		false,	"",								argc,argv,&i,4,					&all));
		else if (cli_getint		(opt,"-fragment",	false,	"",								argc,argv,&i,fragment,			&fragment));
		else if (cli_getuint	(opt,"-filelength",	false,	"",								argc,argv,&i,filelength,		&filelength));
		else if (cli_getuint	(opt,"-dirlength",	false,	"",								argc,argv,&i,dirlength,			&dirlength));
		else if (cli_getuint	(opt,"-n",			false,	"",								argc,argv,&i,menoenne,			&menoenne));
		else if (cli_getuint	(opt,"-limit",		false,	"",								argc,argv,&i,menoenne,			&menoenne));
		else if (cli_getint		(opt,"-buffer",		false,	"",								argc,argv,&i,g_ioBUFSIZE,		&g_ioBUFSIZE));
		else if (cli_getuint64	(opt,"-chunk",		false,	"",								argc,argv,&i,g_chunk_size,		&g_chunk_size));
		else if (cli_getuint64	(opt,"-minsize",	false,	"",								argc,argv,&i,minsize,			&minsize));
		else if (cli_getuint64	(opt,"-maxsize",	false,	"",								argc,argv,&i,maxsize,			&maxsize));
		else if (cli_getuint64	(opt,"-remotespeed",false,	"",								argc,argv,&i,g_remotespeed,		&g_remotespeed));
		else if (cli_getuint64	(opt,"-checksize",	false,	"",								argc,argv,&i,g_checksize,		&g_checksize));
		else if (cli_getstring	(opt,"-method",		false,	"-m",							argc,argv,&i,"",				&method));
		else if (cli_getstring	(opt,"-csv",		false,	"-tab",							argc,argv,&i,"",				&g_csvstring));
		else if (cli_getstring	(opt,"-csvhf",		false,	"",								argc,argv,&i,"",				&g_csvhf));
		else if (cli_getstring	(opt,"-bin",		false,	"",								argc,argv,&i,"",				&g_bin));
		else if (cli_getstring	(opt,"-h",			false,	"-h",							argc,argv,&i,"",				&g_mysql_host));
		else if (cli_getstring	(opt,"-u",			false,	"-u",							argc,argv,&i,"",				&g_mysql_user));
		else if (cli_getstring	(opt,"-p",			false,	"-p",							argc,argv,&i,"",				&g_mysql_password));
		else if (cli_getint		(opt,"-threads",	false,	"-t",							argc,argv,&i,howmanythreads,	&howmanythreads));
		else if (cli_getint		(opt,"-summary",	true, 	"",								argc,argv,&i,1,					&summary));
		///else if (cli_getint		(opt,"-red4",		false, 	"",								argc,argv,&i,-1,				&red4));
		else if (cli_onlystring	(opt,"-snapshot",			"",				snapmark,		argc,argv,&i,					NULL));
#ifdef unix
		else if (cli_onlystring	(opt,"-dataset",			"",				g_dataset,		argc,argv,&i,					NULL));
#endif // corresponds to #ifdef (#ifdef unix)
		else if (cli_onlystring	(opt,"-find",				"-search",		searchfrom,		argc,argv,&i,					NULL));
		else if (cli_onlystring	(opt,"-replace",			"",				replaceto,		argc,argv,&i,					NULL));
		else if (cli_onlystring	(opt,"-orderby",			"",				orderby,		argc,argv,&i,					NULL));
		else if (cli_onlystring	(opt,"-findhash",			"-searchhash",	searchhash,		argc,argv,&i,					NULL));
		else if (cli_onlystring	(opt,"-exec_error",			"-exec_err",	g_exec_error,	argc,argv,&i,					NULL));
		else if (cli_onlystring	(opt,"-exec_warn",			"-exec_warn",	g_exec_warn,	argc,argv,&i,					NULL));
		else if (cli_onlystring	(opt,"-exec_ok",			"",				g_exec_ok,		argc,argv,&i,					NULL));
		else if (cli_onlystring	(opt,"-copy",				"",				g_copy,			argc,argv,&i,					NULL));
		else if (cli_onlystring	(opt,"-freeze",				"",				g_freeze,		argc,argv,&i,					NULL));
		else if (cli_onlystring	(opt,"-output",				"-out",			g_output,		argc,argv,&i,					NULL));
		else if (cli_onlystring	(opt,"-keyfile",			"",				g_keyfile,		argc,argv,&i,					NULL));
		else if (cli_onlystring	(opt,"-errorlog",			"-error",		g_error,		argc,argv,&i,					NULL));
		else if (cli_onlystring	(opt,"-ifexist",			"-ifexists",	g_ifexist,		argc,argv,&i,					NULL));
		///else if (cli_onlystring	(opt,"-ismounted",			"",	g_ismounted,		argc,argv,&i,					NULL));
		else if (cli_onlystring	(opt,"-script",				"",				g_script,		argc,argv,&i,					NULL));
#ifdef ZPAQFULL ///NOSFTPSTART
		else if (cli_onlystring	(opt,"-sfx",				"",				g_sfx,			argc,argv,&i,					&flagsfx));
		else if (cli_onlystring	(opt,"-sfxto",				"",				g_sfxto,		argc,argv,&i,					NULL));
#endif ///NOSFTPEND
		else if (cli_onlystring	(opt,"-deleteinto",			"",				g_deleteinto,	argc,argv,&i,					NULL));
#ifdef ZPAQFULL ///NOSFTPSTART
#ifdef SFTP
		else if (cli_onlystring	(opt,"-ssh",				"",				g_sftp_key,	argc,argv,&i,					NULL));
		else if (cli_onlystring	(opt,"-host",				"",				g_sftp_host,	argc,argv,&i,					NULL));
		else if (cli_onlystring	(opt,"-user",				"",				g_sftp_user,	argc,argv,&i,					NULL));
		else if (cli_onlystring	(opt,"-password",			"",				g_sftp_password,	argc,argv,&i,					NULL));
		else if (cli_onlystring	(opt,"-remote",				"",					g_sftp_remote,	argc,argv,&i,					NULL));
		else if (cli_onlystring	(opt,"-mailfull",			"",					g_sftp_mailfull,	argc,argv,&i,					NULL));
		else if (cli_onlystring	(opt,"-mailprivacy",		"",					g_sftp_mailprivacy,	argc,argv,&i,					NULL));
		else if (cli_onlystring	(opt,"-maila",			"",					g_sftp_maila,	argc,argv,&i,					NULL));
		else if (cli_onlystring	(opt,"-customer",			"",					g_sftp_customer,	argc,argv,&i,					NULL));
#endif // corresponds to #ifdef (#ifdef SFTP)
#endif ///NOSFTPEND
		else if (cli_onlystring	(opt,"-exec",				"",				g_exec,			argc,argv,&i,					NULL));
		else if (cli_onlystring	(opt,"-exec",				"",				g_exec,			argc,argv,&i,					NULL));
		else if (cli_onlystring	(opt,"-comment",			"",				versioncomment,	argc,argv,&i,					&flagcomment));
		else if (cli_onlystring	(opt,"-checktxt",			"",				checktxt,		argc,argv,&i,					&flagchecktxt));
		else if (cli_onlystring	(opt,"-fasttxt",			"",				fasttxt,		argc,argv,&i,					&flagfasttxt));
		else if (cli_getdate	(opt,"-timestamp",											argc,argv,&i,					&date));
		else if (cli_getdate	(opt,"-touch",												argc,argv,&i,					&g_touch));
		else if (cli_getdate	(opt,"-datefrom",											argc,argv,&i,					&g_datefrom));
		else if (cli_getdate	(opt,"-dateto",												argc,argv,&i,					&g_dateto));
		else if (cli_getarray	(opt,"-not",												argc,argv,&i,					&notfiles,		&nottype));
#ifdef ZPAQFULL ///NOSFTPSTART
		else if (cli_getarray	(opt,"-sfxnot",												argc,argv,&i,					&sfxnotfiles,	&sfxnottype));
		else if (cli_getarray	(opt,"-sfxonly",											argc,argv,&i,					&sfxonlyfiles,	NULL));
		else if (cli_getstring	(opt,"-sfxuntil",	false, 	"",								argc,argv,&i,"",				&g_sfxuntil));
		else if (cli_onlystring	(opt,"-franzen",				"",							g_franzen,	argc,argv,&i,					NULL));

#endif ///NOSFTPEND
		else if (cli_getarray	(opt,"-only",												argc,argv,&i,					&onlyfiles,		NULL));
		else if (cli_getarray	(opt,"-always",												argc,argv,&i,					&alwaysfiles,	NULL));
		///else if (cli_getarray	(opt,"-level0",												argc,argv,&i,					&level0,		NULL));
		///else if (cli_getarray	(opt,"-level1",												argc,argv,&i,					&level1,		NULL));
		///else if (cli_getarray	(opt,"-level2",												argc,argv,&i,					&level2,		NULL));
		///else if (cli_getarray	(opt,"-level3",												argc,argv,&i,					&level3,		NULL));
		///else if (cli_getarray	(opt,"-level4",												argc,argv,&i,					&level4,		NULL));
		///else if (cli_getarray	(opt,"-level5",												argc,argv,&i,					&level5,		NULL));
		else if (cli_getstring	(opt,"-range",		false,	"",								argc,argv,&i,"",				&myrange))
		{
			flagrange=true;
			decoderange(myrange);
		}
		else if (cli_getstring	(opt,"-index",		false,	"",								argc,argv,&i,"",				&g_indexname))
		{
			index =g_indexname.c_str();
		}
		else if (cli_getuint64	(opt,"-ramsize",	false,	"",								argc,argv,&i,g_ramsize,			&g_ramsize))
		{
			flagramsize=true;
		}
		else if (cli_getstring	(opt,"-external",		false,	"",								argc,argv,&i,"",				&g_externalname))
		{
			flagexternal=true;
		}
		else if (cli_getstring	(opt,"-input",		false,	"",								argc,argv,&i,"",				&g_input))
		{
			flaginput=true;
		}
		else if (cli_getstring	(opt,"-destination",		false,	"",								argc,argv,&i,"",				&g_destination))
		{
			flagdestination=true;
		}
		else if (cli_getkey		(opt,"-key",												argc,argv,&i,&plainpassword,	&g_password,		g_password_string))
		{
	///
		///	myprintf("\n\n\n g_keyfile %s\n",g_keyfile.c_str());
			if (flagdebug3)
			{
				myprintf("00558: Password        %s\n",	g_password);
				myprintf("00559: Password string %s\n",	g_password_string);
			}
		}
		else if (cli_getkey		(opt,"-key2",												argc,argv,&i,&plainpassword2,	&new_password,	new_password_string));

		else
		if (opt=="-repack" && i<argc-1)
		{
			repack=argv[++i];
			string estensione=prendiestensione(repack);
			if (estensione=="")
				repack+=".zpaq";
			if (i<argc-1 && argv[i+1][0]!='-')
			{
				libzpaq::SHA256 sha256;
				for (const char* p=argv[++i]; *p; ++p)
					sha256.put(*p);
				memcpy(new_password_string, sha256.result(), 32);
				new_password=new_password_string;
			}
		}
		else if (opt=="-to")
		{  // read tofiles. Possible collision with -tthread
			while (++i<argc && argv[i][0]!='-')
			{
	// fix to (on windows) -to "z:\pippo pluto" going to a mess
				string mytemp=mytrim(argv[i]);
///				string fixedstring=windows_fixbackslash("-to",mytemp);
				myreplaceall(mytemp,"\"","");
				tofiles.push_back(mytemp);
				if (!do_not_print_headers())
					if (flagdebug)
						myprintf("00560: franz:%-21s <<%s>>\n","-to",mytemp.c_str());

			}
			if (tofiles.size()==0)
				tofiles.push_back("");
			--i;
		}
		else
		if (opt=="-until" && i+1<argc)
		{
			g_until=argv[i+1];
		  // Read digits from multiple args and fill in leading zeros
			version=0;
			int digits=0;
			if (argv[i+1][0]=='-')
			{  // negative version
				version=atol(argv[i+1]);
				if (version>-1)
					usage();
				++i;
			}
			else
			{  // positive version or date
				while (++i<argc && argv[i][0]!='-')
				{
					for (int j=0; ; ++j)
					{
						if (isdigit(argv[i][j]))
						{
							version=version*10+argv[i][j]-'0';
							++digits;
						}
						else
						{
							if (digits==1)
								version=version/10*100+version%10;
							digits=0;
							if (argv[i][j]==0)
								break;
						}
					}
				}
				--i;
			}
		  // Append default time
			if (version>=19000000LL     && version<=29991231LL)
				version=version*100+23;
			if (version>=1900000000LL   && version<=2999123123LL)
				version=version*100+59;
			if (version>=190000000000LL && version<=299912312359LL)
				version=version*100+59;
			if (version>9999999)
			{
				if (version<19000101000000LL || version>29991231235959LL)
				{
					fflush(stdout);
					myprintf("00561: Version date %1.0f must be 19000101000000 to 29991231235959\n",double(version));
					g_exec_text="Version date must be 19000101000000 to 29991231235959";
					exit(1);
				}
				date=version;
			}
		}
		else
		if (opt=="skipme")
		{
		}
		else
		{
			if (!g_programflags.exists(argv[i]))
				myprintf("00562! Unknown option ignored: %s\n", argv[i]);
		}
	}

/*
	Check from "weird" parameters
*/
	if (g_keyfile!="")
	{
		if (g_password==NULL)
		{
			myprintf("49267: -keyfile require a -key\n");
			seppuku();
		}
	}
	if (flagnosynology)
	{
		myprintf("00563: Filling -not for -nosynology\n");
		notfiles.push_back("*/@recycle/*");
		notfiles.push_back("*/#recycle/*");
		notfiles.push_back("*/#snapshot/*");
		
		notfiles.push_back("*/@ActiveBackup/*");
		notfiles.push_back("*/@sharebin/*");
		notfiles.push_back("*/@appconf/*");
		notfiles.push_back("*/@appdata/*");
		notfiles.push_back("*/@apphome/*");
		notfiles.push_back("*/@appshare/*");
		notfiles.push_back("*/@apptemp/*");
		notfiles.push_back("*/@clamav/*");
		notfiles.push_back("*/@database/*");
		notfiles.push_back("*/@docker/*");
		notfiles.push_back("*/@eaDir/*");
		notfiles.push_back("*/@maillog/*");
		notfiles.push_back("*/@MailScanner/*");
		notfiles.push_back("*/@postfix/*");
		notfiles.push_back("*/@S2S/*");
		notfiles.push_back("*/@sharesnap/*");
		notfiles.push_back("*/@synoconfd/*");
		notfiles.push_back("*/@SynologyDrive/*");
		notfiles.push_back("*/@SynoFinder-etc-volume/*");
		notfiles.push_back("*/@SynoFinder-log/*");
		notfiles.push_back("*/@tmp/*");
		notfiles.push_back("*/@USBCopy/*");
		notfiles.push_back("*/@userpreference/*");
		
	}
	if (g_rangefrom>0)
	{
		if (g_until!="")
		{
			myprintf("00564! -until incompatible with -range\n");
			return 2;
		}
		all=8;
	}

	myreplaceall(g_csvstring,"/","\\");
	replacetabs(g_csvstring);

	myreplaceall(g_csvhf,"/","\\");
	replacetabs(g_csvhf);
	
#ifdef _WIN32
#ifdef ZPAQFULL ///NOSFTPSTART
		if (flagvss)
		{
			if (!isadmin())
			{
				myprintf("\n");
				myprintf("00565: Admin rights required for VSS => runhigh()\n");
				runhigh(" -pause");
				return 2;
			}
		}
#endif ///NOSFTPEND
	if (flagimage && flagstdin)
	{
		myprintf("00566! -image incompatible with -stdin\n");
		return 2;
	}
	if
	(flagimage)
		if (!isadmin())
		{
			myprintf("\n");
			myprintf("00569! Impossible to image: admin rights required\n");
			return 2;
		}
#endif // corresponds to #ifdef (#ifdef _WIN32)

/*
	fix some defaults
*/

	if (snapmark!="")
	{
		string newmark	="";
		string temp		=snapmark;
		for (unsigned int i=0;i<temp.size();i++)
			if ((isalpha(temp[i])) || (isdigit(temp[i])))
				newmark+=temp[i];
		if (newmark!="")
			if (isdigit(newmark[0]))
				newmark[0]='a';
		if (newmark.size()>30)
			newmark.erase(30,std::string::npos);

		if (newmark!="")
		{
			if (newmark!=snapmark)
				myprintf("00570: franz:zfs snapshot mark to  |%s|\n",newmark.c_str());
			snapmark=newmark;
		}
	}
	if (g_output!="")
		open_output(g_output);

	if (g_error!="")
		if (fileexists(g_error))
		{
			if (flagverbose)
				printf("02743: DELETING ERROR FILE %s\n",g_error.c_str());
			delete_file(g_error.c_str());
		}
	if (flagforcezfs)
		flagskipzfs=false; // win over skip

#ifdef HWSHA1
	if (flaghw)
		Sha1Prepare(true);
	else
		Sha1Prepare(false);
#endif // corresponds to #ifdef (#ifdef HWSHA1)


//	write franzs' parameters (if not very briefly)
	if ((!flagpakka) && (!flagstdout) && (!flagterse))
	{
		string franzparameters="";

		for (MAPPATIPOHASH::iterator p=g_mappatipohash.begin(); p!=g_mappatipohash.end(); ++p)
			if ((p->second.switchflag)!=NULL)
				if (*(p->second.switchflag))
					franzparameters+=p->second.switchname+" ";

		string attivati=g_programflags.compact();
		franzparameters+=attivati;

		if (franzparameters!="")
			if (!do_not_print_headers())
				if (flagdebug)
					myprintf("00571: franz:%s\n",franzparameters.c_str());

	}

	if (howmanythreads<1)
		howmanythreads=numberOfProcessors();

  // Test date
	if (nowz==-1 || date<19000000000000LL || date>30000000000000LL)
		error("date is incorrect, use -until YYYY-MM-DD HH:MM:SS to set");
  // Adjust negative version
	if (version<0)
	{
		Jidac jidac(*this);
		jidac.version=DEFAULT_VERSION;
		jidac.read_archive(NULL,archive.c_str());
		version+=jidac.ver.size()-1;
		myprintf("00575: Version %1.0f\n", version+.0);
	}
/*
	Substitute %day into archive and files and comments
*/
	archive=format_datetime(archive);
	for (unsigned int i=0;i<files.size();i++)
		files[i]=format_datetime(files[i]);
	versioncomment=format_datetime(versioncomment);

// Load dynamic functions in Windows Vista and later
#ifndef unix
	HMODULE h = GetModuleHandle(TEXT("kernel32.dll"));
	if (h == NULL)
		printerr("module", "GetModuleHandle", 0);
	else
	{
		findFirstStreamW = reinterpret_cast<FindFirstStreamW_t>(
			reinterpret_cast<void*>(GetProcAddress(h, "FindFirstStreamW")));
		findNextStreamW = reinterpret_cast<FindNextStreamW_t>(
			reinterpret_cast<void*>(GetProcAddress(h, "FindNextStreamW")));
		getFinalPathNameByHandleW = reinterpret_cast<GetFinalPathNameByHandleW_t>(
			reinterpret_cast<void*>(GetProcAddress(h, "GetFinalPathNameByHandleW")));
	}
	if ((!findFirstStreamW) || (!findNextStreamW))
		myprintf("00577$ Alternate streams not supported in Windows XP\n");
#endif

/// postop
#ifdef ZPAQFULL ///NOSFTPSTART
#ifdef SFTP
	if (g_sftp_key!="")
		if (!fileexists(g_sftp_key.c_str()))
		{
			if (g_sftp_password!="")
			{
				g_sftp_key="";
				myprintf("49049$ -ssh keyfile does not exists, but -password setted => falling back!\n");
			}
		}	
#endif
#endif ///NOSFTPEND

	if (flag715)
	{
		
		flaghuge			=false;
		flagslow			=false;
#ifdef _WIN32
		flagmonitoroff		=false;
		flagsparse			=false;
#endif
		flagonedrive		=false;
		flagnotrim			=true;
		flagtmp				=false;
		flagnodelete		=false;
		flagdate			=false;
		flagutc				=true;
		flagzero			=false;
		flagforcezfs		=true;
		flagdonotforcexls	=true;
		flagforcewindows	=true;
		flagcrc32			=false;
		flagentropy			=false;
		flagchecksum		=false;
		flagnochecksum		=true;
		flagfilelist		=false;
		flagads				=false;
		flagfast			=false;
		flaghashdeep		=false;
		flagxxh3			=false;
		flagxxhash64		=false;
		flagxxhash64b		=false;
		flagblake3b			=false;
		flagsha256b			=false;
		flagmd5b			=false;
		flagsha1b			=false;
		flagxxh3b			=false;
		flagsha3b			=false;
		flagfixeml			=false;
		flagfix255			=false;
		flagtouch			=false;
		flagrename			=false;
		flagramdisk			=false;
		flagnorecursion		=false;
#ifdef _WIN32
		flagwindate			=false;
		flagfixcase			=false;
		flagfixreserved		=false;
		flaglongpath		=false;
		flagfindzpaq		=false;
#endif // corresponds to #ifdef (#ifdef _WIN32)
		flagutf				=false;
		flagflat			=false;
		flagparanoid		=false;
		///flagpaq				=false;
		flagcollision		=false;
		flagnodedup			=false;
		flagstdout			=false;
		flagstdin			=false;
		flagterse			=false;
		g_franzotype		=0;
		g_franzotypelen		=0;
		if ((command!='l') && (!flag715))
		{
			myprintf("00578: **** Activated V7.15 mode ****\n");
			myprintf("00579: T forcezfs,donotforcexls,forcewindows; F crc32,checksum,filelist,xxhash,xxh3,fixeml,fix255,fixreserved,longpath,utf,flat\n");
		}
	}

#ifdef _WIN32
	if (flaglongpath)
	{
		if (flagdebug3)
			printbar('+');
		for (unsigned int i=0;i<onlyfiles.size();i++)
		{
			if (flagdebug3)
				myprintf("00580: onlyfiles %03d files |%s| ",i,onlyfiles[i].c_str());
			onlyfiles[i]=makelongpath(onlyfiles[i]);
			if (flagdebug3)
				myprintf(" => long |%s|\n",onlyfiles[i].c_str());
		}
		for (unsigned int i=0;i<notfiles.size();i++)
		{
			if (flagdebug3)
				myprintf("00581: notfiles  %03d files |%s| ",i,notfiles[i].c_str());
			notfiles[i]=makelongpath(notfiles[i]);
			if (flagdebug3)
				myprintf(" => long |%s|\n",notfiles[i].c_str());
		}
		for (unsigned int i=0;i<alwaysfiles.size();i++)
		{
			if (flagdebug3)
				myprintf("00581: alwaysfiles  %03d files |%s| ",i,alwaysfiles[i].c_str());
			alwaysfiles[i]=makelongpath(alwaysfiles[i]);
			if (flagdebug3)
				myprintf(" => long |%s|\n",alwaysfiles[i].c_str());
		}
		if (flagdebug3)
			printbar('$');
	}
#endif // corresponds to #ifdef (#ifdef _WIN32)

	return 0;
}

//  Return 1 if error else 0.
int Jidac::doCommand()
{
	if (g_chunk_size>0)
	{
		if (command!='a')
		{
			myprintf("00582! -chunk works only with a command\n");
			return 2;
		}
		
		if (!iswildcards(archive))
		{
			myprintf("00583! the archive must be multipart (with some ?) for -chunk\n");
			return 2;
		}
		if (g_indexname!="")
		{
			myprintf("00584! -chunk incompatible with -index\n");
			return 2;
		}
	}
  // Execute command
	if (flaginput)
	{
		if (fileexists(g_input))
		{
			vector<string> inputfiles;
			readfiletoarray(g_input,inputfiles);
			if (!do_not_print_headers())
				if (flagdebug)
					myprintf("00585: Inputfiles count  %s\n",migliaia(inputfiles.size()));
			if (inputfiles.size()>0)
				for (unsigned int i=0;i<inputfiles.size();i++)
				{
					string temp=inputfiles[i];
#ifdef _WIN32
					temp=wintolinuxpath(temp);
#endif // corresponds to #ifdef (#ifdef _WIN32)
					files.push_back(temp);
					if (flagdebug3)
						myprintf("00586: inputfiles %08d %s\n",i,temp.c_str());
				}
		}
		else
			myprintf("00587: -input file DOES NOT EXISTS! %s\n",g_input.c_str());
	}

	if (flagdestination)
	{
		if (fileexists(g_destination))
		{
			vector<string> destinationfiles;
			readfiletoarray(g_destination,destinationfiles);
			if (!do_not_print_headers())
				if (flagdebug)
					myprintf("00323: Destination count %s\n",migliaia(destinationfiles.size()));
			if (destinationfiles.size()>0)
				for (unsigned int i=0;i<destinationfiles.size();i++)
				{
					string temp=destinationfiles[i];
#ifdef _WIN32
					temp=wintolinuxpath(temp);
#endif // corresponds to #ifdef (#ifdef _WIN32)
					tofiles.push_back(temp);
					if (flagdebug3)
						myprintf("00581: destination %08d %s\n",i,temp.c_str());
				}
		}
		else
		{
			if (command!='Y') //consolidatebackup
				myprintf("54065: -destination file DOES NOT EXISTS! %s\n",g_destination.c_str());
		}
	}

	
	theonlyone(command,archive);
#ifdef ZPAQFULL ///NOSFTPSTART
	if (flagslow)
	{
		myprintf("62776$ Due to -slow reducing CPU usage (turn off TurboBoost)\n");
		maxcpu(99);
	}
#endif ///NOSFTPEND
#ifdef _WIN32
	if (flagmonitoroff)
	{
		myprintf("62736$ Due to -monitorff => turning off monitor\n");
		SendMessage(HWND_BROADCAST, WM_SYSCOMMAND, SC_MONITORPOWER,2);
	}
#endif

	if ( (command=='a')  && files.size()>0) // enforce: we do not want to change anything when adding
	{
		if (flagstore)
		{
			flagnodedup=true;
			method='0';
		}
		g_fakewrite			=false;
		flagfixeml			=false;
		flagfix255			=false;
		flagutf				=false;
#ifdef _WIN32
		flagfixcase			=false;
		flagfixreserved		=false;
#endif // corresponds to #ifdef (#ifdef _WIN32)
		flagflat			=false;

		g_franzotype=FRANZO_XXHASH64B; // by default 2 (CRC32+XXHASH64)
		g_franzotypelen=16;
		for (MAPPATIPOHASH::iterator p=g_mappatipohash.begin(); p!=g_mappatipohash.end(); ++p)
		{
	///		myprintf("00588: iterator %d\n",p->first);
			if (p->second.switchflag!=NULL)
				if (*(p->second.switchflag))
					if (p->second.flagiszpaq)
					{
						g_franzotype=p->first;
						g_franzotypelen=p->second.hashlen;
						break;
					}
		}
		if (flag715 || flagnochecksum)
			g_franzotype=FRANZO_NONE;

		if (flagappend)
			return append();
		if (flaghome)
			return addhome();
		else
			return add();
	}
	else if (command=='+') return crop();
#ifdef ZPAQFULL ///NOSFTPSTART
	else if (command=='!') return isopen();
#endif ///NOSFTPEND
	else if (command=='|') return versum();
	else if (command=='^') return last2();
	else if (command=='_') return testbackup();
	else if (command=='?') return comparehex();
	else if (command=='[') return count();
	else if (command==']') return work();
#ifdef ZPAQFULL ///NOSFTPSTART
#ifdef SFTP
	else if (command=='@') return sftp();
	else if (command=='J') return ssh();
#endif // corresponds to #ifdef (#ifdef SFTP)
	else if (command=='$') return zfsbackup();
	else if (command=='=') return zfsproxbackup();
	else if (command=='(') return zfsproxrestore();
	else if (command=='%') return zfsrestore();
	else if (command==';') return zfsreceive();
#endif ///NOSFTPEND
	else if (command==')') return oneonone();

	else if (command=='0') return pause();
	else if (command=='1') return summa();
	else if (command=='2') return dir();
	else if (command=='3') return purgersync();
	else if (command=='4') return trim();
	else if (command=='5') return zpaqdirsize();
	else if (command=='6') return setpassword();
#ifdef ZPAQFULL ///NOSFTPSTART
	else if (command=='7') return rd();
#endif ///NOSFTPEND
	else if (command=='8') return autotest();
	else if (command=='9') return hasha();
#ifdef ZPAQFULL ///NOSFTPSTART
	else if (command=='A') return zfsadd();
	else if (command=='B') return zfslist();
	else if (command=='C') return zfspurge();
#endif ///NOSFTPEND
	else if (command=='D') return dump();
#ifdef _WIN32
	else if (command=='E') return restoreimage();
#endif
	else if (command=='F') return fzf();
#ifdef _WIN32
	else if (command=='G') return drive();
#endif
#ifdef ZPAQFULL ///NOSFTPSTART
#ifndef _WIN32
	else if (command=='H') return zfssize();
#endif
#endif ///NOSFTPEND
	else if (command=='I') return sync();
	else if (command=='K') return collision(true);
	else if (command=='L') return last();
#ifdef ZPAQFULL ///NOSFTPSTART
	else if (command=='M') return mysql();
#endif ///NOSFTPEND
	else if (command=='N') return checkpassword();
#ifdef ZPAQFULL ///NOSFTPSTART
#ifdef SFTP
	else if (command=='O') return cloud();
#endif
#endif ///NOSFTPEND
//P
//Q
	else if (command=='R') return redu();
#ifdef _WIN32
	else if (command=='S') return ads();
#endif
#ifndef ANCIENT
	else if (command=='T') return tui();
#endif
#ifdef ZPAQFULL ///NOSFTPSTART
	else if (command=='U') return update();
#endif ///NOSFTPEND
//V
#ifdef ZPAQFULL ///NOSFTPSTART
#ifdef _WIN64
	else if (command=='W') return download();
#endif // corresponds to #ifdef (#ifdef _WIN64)
#endif ///NOSFTPEND
//X
	else if (command=='Y') return consolidatebackup();
	else if (command=='Z') return backup();
#ifdef _WIN32
	else if (command=='.') return pakkalist();
#endif // corresponds to #ifdef (#ifdef _WIN32)

	else if (command=='b') return benchmark();
	else if (command=='c') return dircompare(false,false);
	else if (command=='d') return deduplicate();
	else if (command=='e') return ecommand();
	else if (command=='f') return fillami();
#ifdef ZPAQFULL ///NOSFTPSTART
#ifdef _WIN32
	else if (command=='g') return adminrun();
#endif // corresponds to #ifdef (#ifdef _WIN32)
#endif ///NOSFTPEND
	else if (command=='i') return info();
	else if (command=='j') return findj();
	else if (command=='k') return kill();
	else if (command=='l') return list();
	else if (command=='m') return consolidate(archive);
#ifdef ZPAQFULL ///NOSFTPSTART
	else if (command=='n') return decimation();
#endif ///NOSFTPEND
	else if (command=='o') return mycopy();
	else if (command=='p') return paranoid();
#ifdef _WIN32
	else if (command=='q') return windowsc();

#endif // corresponds to #ifdef (#ifdef _WIN32)
	else if (command=='r') return robocopy();
	else if (command=='s') return dircompare(true,false);
	else if (command=='t') return multisomething();
	else if (command=='u') return utf();
	else if (command=='v') return verify(true);
	else if (command=='w') return extractw();
	else if (command=='x') return multisomething();
#ifdef ZPAQFULL ///NOSFTPSTART
	else if (command=='y') return sfx();
#endif ///NOSFTPEND
	else if (command=='z') return zero();
#ifndef ANCIENT
	else if (command==':') return ls();
#endif
	else usage();
	return 0;
}
bool Jidac::getfoldersize(string i_folder,uint64_t& o_totalsize,uint32_t & o_totalfile,uint32_t& o_totaldir,uint32_t& o_longfiles)
{
	o_totalsize	=0;
	o_totalfile	=0;
	o_totaldir	=0;
	o_longfiles	=0;
	if (i_folder=="")
		return false;
	/// we need to cut last / for Windows longpath
	if (isdirectory(i_folder))
		i_folder=i_folder.substr(0,i_folder.size()-1);
	DTMap mydestinationdir;
	if (flagdebug)
	{
		myprintf("00589: Scanning dir <<%Z>>\n",i_folder.c_str());
	}
	scandir(true,mydestinationdir,i_folder);
	eol();
	///printbar(' ',false);
	///myprintf("\r");
	for (DTMap::iterator p=mydestinationdir.begin(); p!=mydestinationdir.end(); ++p)
	{
		string fn=p->first;
		if (fn.size()>255)
			o_longfiles++;
		if (!isdirectory(p->first))
		{
			o_totalsize+=p->second.size;
			o_totalfile++;
		}
		else
			o_totaldir++;
	}
	if (flagdebug)
		myprintf("00591: files %s dirs %s size %s long %s\n",migliaia((int64_t)o_totalfile),migliaia2((int64_t)o_totaldir),migliaia3((int64_t)o_totalsize),migliaia4((int64_t)o_longfiles));
	if (o_totalfile || o_totaldir || o_totalsize)
		return true;
	return false;
}
#ifdef ZPAQFULL ///NOSFTPSTART
int Jidac::rd()
{
	myprintf("00592: Remove Directory ");
	if (files.size()==0)
	{
		myprintf("00593! rd exactly at least one folder\n");
		return 2;
	}
	// cut the last / because we want longfile support on Windows
	for (unsigned int i=0;i<files.size();i++)
	{
		if (isdirectory(files[i]))
			files[i]=files[i].substr(0, files[i].size()-1);
#ifdef _WIN32
		if (flaglongpath)
			if (iswindowspath(files[i]))
				if (!islongpath(files[i]))
					files[i]="//?/"+files[i];
#endif // corresponds to #ifdef (#ifdef _WIN32)
		uint64_t 		totalsize	=0;
		unsigned int 	totalfile	=0;
		unsigned int 	totaldir	=0;
		unsigned int 	longfiles	=0;
		if (!direxists(files[i]))
		{
			myprintf("\n");
			myprintf("00594: Folder %d does not exist? %Z\n",i,files[i].c_str());
			return 1;
		}
		if (!getfoldersize(files[i],totalsize,totalfile,totaldir,longfiles))
		{
			myprintf("00596: cannot enumerate folder %d %Z\n",i,files[i].c_str());
			return 1;
		}
		if (!flagspace)
			if (!saggiascrivibilitacartella(files[i]))
			{
				myprintf("\n");
				myprintf("00598: cannot write into %d %Z -space to bypass\n",i,files[i].c_str());
				return 1;
			}
		myprintf("\n");
		printbar('=');
		myprintf("00600: Files %s for %s bytes (%s) longpath %s\n",migliaia(totalfile),migliaia2((int64_t)totalsize),tohuman((int64_t)totalsize),migliaia3(longfiles));
#ifdef _WIN32
		if (!flaglongpath)
			if (longfiles)
				myprintf("00601$ *** WARNING: long files detected, but no -longpath switch ***\n\n");
#endif // corresponds to #ifdef (#ifdef _WIN32)
		if (totalsize>0)
			if (!flagforce)
			{
				myprintf("00602! the folder size is not zero, use -force to bypass\n");
				return 2;
			}
		if (flagkill)
		{
			if (totalsize>0)
				if (!getcaptcha("y","Remove folder WITH subfolders?"))
					return 1;
			if (stermina(files[i],totalfile))
			{
				myprintf("\n");
				myprintf("00603: OK: folder %i does not seems to exist anymore %Z\n",i,files[i].c_str());
			}
			else
			{
#ifdef _WIN32
	if (!flaglongpath)
		if (longfiles)
			myprintf("00605: Try to use the -longpath switch to erase files >255 in length\n");
#endif // corresponds to #ifdef (#ifdef _WIN32)
				return 2;
			}
		}
		else
		{
			myprintf("00606: dry run. Use -kill for a wet-run\n");
			return 2;
		}
	}
	return 0;
}
#endif ///NOSFTPEND

uint32_t checkfilename(
const string&	i_filename,
int* 			o_toolongfilenames,
int* 			o_adsfilenames,
int* 			o_utf8names,
int* 			o_reservedfilenames,
int*			o_windowspath,
int*			o_windowsunc,
int*			o_relativepath)
{
	if (i_filename=="")
		return 0;
	uint32_t	risultato=0;
	if (o_toolongfilenames)
		if (i_filename.length()>255)
		{
			(*o_toolongfilenames)++;
			risultato&=FIX_TOOLONG;
		}
	if (o_adsfilenames)
		if (strstr(i_filename.c_str(), ":$DATA"))
			if (mypos("VCOMMENT",i_filename)!=0)
			{
				(*o_adsfilenames)++;
				risultato&=FIX_ADS;
			}
	if (o_utf8names)
		if (i_filename!=utf8toansi(i_filename))
		{
			(*o_utf8names)++;
			risultato&=FIX_UTF8;
		}
	if (o_reservedfilenames)
	{
		string fixed;
		if (isreserved(i_filename,fixed))
		{
			(*o_reservedfilenames)++;
			risultato&=FIX_RESERVED;
		}
	}
	if (o_windowspath)
		if ((iswindowspath(i_filename)) || (islongpath(i_filename)))
		{
			(*o_windowspath)++;
			risultato&=FIX_WINDOWSPATH;
		}
	if (o_windowsunc)
		if (iswindowsunc(i_filename))
		{
			(*o_windowsunc)++;
			risultato&=FIX_WINDOWSUNC;
		}
	if (o_relativepath)
	{
		if (i_filename.size()>2) ///  ./pippo
			if (i_filename[0]=='.')
				if (i_filename[1]=='/')
					{
						(*o_relativepath)++;
						risultato&=FIX_RELATIVE;
					}
		if (i_filename.size()>3) ///  ../pippo
			if (i_filename[0]=='.')
				if (i_filename[1]=='.')
					if (i_filename[2]=='/')
					{
						(*o_relativepath)++;
						risultato&=FIX_RELATIVE;
					}
	}
	return risultato;
}
bool isfileopen(const string& i_filename)
{
#ifdef _WIN32
	if (i_filename=="")
		return false;
	if (!fileexists(i_filename))
		return false;
	HANDLE h=CreateFileW(utow(i_filename.c_str()).c_str(), GENERIC_READ,0,NULL,OPEN_EXISTING,0,NULL);
	if ((h!=NULL) && (h!=INVALID_HANDLE_VALUE))
	{
		CloseHandle(h);
		return false;
	}
	return true;
#else
	if (i_filename=="quiet")
		if (flagdebug)
			myprintf("be quiet\n");
	return false;
#endif // corresponds to #ifdef (#ifdef _WIN32)
}

int compressfraglist(const vector<unsigned>& ptr, bool i_flagprint)
{
	int howmanyhypens	=0;
	bool hyphen			=false;
	for (unsigned int i=0; i<ptr.size(); ++i)
	{
		if ( (i==0) || (i==ptr.size()-1) || (ptr[i]!=ptr[i-1]+1) || (ptr[i]!=ptr[i+1]-1) )
		{
			if (i_flagprint)
				if (!hyphen)
					myprintf(" ");
			hyphen=false;
			if (i_flagprint)
				myprintf("%d", ptr[i]);
		}
		else
		{
			if	(!hyphen)
			{
				if (i_flagprint)
					myprintf("-");
				howmanyhypens++;
			}
			hyphen=true;
		}
	}
	return howmanyhypens;
}


bool ismac(const string& i_stringa)
{
	string solonome=extractfilename(i_stringa);
	///myprintf("00607: solonome |%s|\n",solonome.c_str());
	if (solonome==".DS_Store")
	{
		if (flagverbose)
			myprintf("00608: Skip Mac .DS_Store %s\n",i_stringa.c_str());
		return true;
	}
	if (solonome=="Thumbs.db")
	{
		if (flagverbose)
			myprintf("00609: Skip Mac Thumbs.db %s\n",i_stringa.c_str());
		return true;
	}
	if (solonome.size()>2)
		if ((solonome[0]=='.') && (solonome[1]=='_'))
		{
			if (flagverbose)
				myprintf("00610: Skip Mac ._something %s\n",i_stringa.c_str());
			return true;
		}
	return false;
}

// Function to check if filename meets the required conditions
bool Jidac::onlynorecursion(string filename) 
{
	if (flagdebug5)
		myprintf("Vado di checkfilename %s su %s\n",filename.c_str(),onlyfiles[0].c_str());
	
	for (unsigned int i=0;i<onlyfiles.size();i++)
	{
		string percorso=includetrailingbackslash(onlyfiles[i]);
		string ilfile=filename;
#ifdef _WIN32
		percorso=stringtolower(percorso);
		ilfile=stringtolower(ilfile);
#endif
		if (ilfile==percorso)
			return true;
		
		if (isdirectory(ilfile))
		{
			if (flagdebug5)
				myprintf("Entro1\n");
	        if (ilfile.size() > percorso.size())
			{
				if (flagdebug5)
					myprintf("Entro2 %s\n",ilfile.substr(0,percorso.size()).c_str());
				if (ilfile.substr(0,percorso.size()) == percorso) 
				{
						string remaining = ilfile.substr(percorso.size());
						if (flagdebug5)
							myprintf("Entro3 remaining %s\n",remaining.c_str());
						if (std::count(remaining.begin(),remaining.end(),'/')==1)
							return true;
				}
			}
        }
		else
		{
			string percorsofile=includetrailingbackslash(extractfilepath(ilfile));
			if (percorsofile==percorso)
			{
				if (flagdebug5)
					myprintf("OK: un file %s con percorsofile %s == percorso %s\n",ilfile.c_str(),percorsofile.c_str(),percorso.c_str());
				return true;
			}
		}
	}
	return false;
	
}
    
    
// Test whether filename and attributes are selected by files, -only, and -not
// If rn then test renamed filename.
// if i_size >0 check file size too (minsize,maxsize)
bool Jidac::isselected(const char* filename, bool rn,int64_t i_size)
{
	if (g_optional=="versum")
		return true; //dirsize, take ALL the stuff, for pos() filtering
	if (g_optional=="dirsize")
		return true; //dirsize, take ALL the stuff, for pos() filtering
	if (g_optional=="zfsadd")
		return true; // skip all this stuff, take everything
	bool matched=true;
#ifdef _WIN32
	if (flagonedrive)
		if (!isrealfile(filename))
		{
			if (flagverbose)
				myprintf("57254$ Skip placeholder <<%Z>>\n",filename);
			return false;
		}
#endif
	if (!flagforcezfs)
		if (flagskipzfs) //this is an "automagically" exclude for zfs' snapshots
			if (iszfs(filename))
			{
				if (flagverbose)
					myprintf("00611: Verbose: Skip .zfs %s\n",filename);
				return false;
			}
	
	if (flagnomac)
		if (ismac(filename))
			return false;
/*
	if (flagnosynology)
		if (issynology(filename))
			return false;
*/
	
	if (flagnoqnap) //this is an "automagically" exclude for qnap's snapshots
		if (
			(strstr(filename, "@Recently-Snapshot"))
			||
			(strstr(filename, "@Recycle"))
			||
			(strstr(filename, "/.streams/"))
			)
			{
				if (flagverbose)
					myprintf("00612: Verbose: Skip qnap %s\n",filename);
				return false;
			}
	if (!flagforcewindows) //this "automagically" exclude anything with System Volume Information
	{
		if (strstr(filename, "System Volume Information"))
		{
			if (flagverbose)
				myprintf("00613: Verbose: Skip System Volume Information %s\n",filename);
			return false;
		}
		if (strstr(filename, "$RECYCLE.BIN"))
		{
			if (flagverbose)
				myprintf("00614: Verbose: Skip trash %s\n",filename);
			return false;
		}
		
		if (strstr(filename, ".dropbox.cache"))
		{
			if (flagverbose)
				myprintf("00614: Verbose: Skip dropbox cache %s\n",filename);
			return false;
		}
	}
/// search for fake file (ASCII versions)
	if (isads(filename))
	{
		if (mypos("VCOMMENT ",filename)>-1)
			return true;
		if (mypos("VFILE-",filename)>-1)
			return true;
		if (mypos("MFILE-",filename)>-1)
			return true;
	}
	if  (!flagforcewindows)
		if (isads(filename))
			return false;
	if (i_size>0)
	{
		if (maxsize)
			if (maxsize<(uint64_t)i_size)
			{
				if (flagdebug)
					myprintf("00615: (-maxsize) too big   %19s %s\n",migliaia(i_size),filename);
				return false;
			}
		if (minsize)
			if (minsize>(uint64_t)i_size)
			{
				if (flagdebug)
					myprintf("00616: (-minsize) too small %19s %s\n",migliaia(i_size),filename);
				return false;
			}
	}
  if (files.size()>0) {
    matched=false;
    for (unsigned i=0; i<files.size() && !matched; ++i) {
      if (rn && i<tofiles.size()) {
        if (ispath(tofiles[i].c_str(), filename)) matched=true;
      }
      else if (ispath(files[i].c_str(), filename)) matched=true;
    }
  }
  if (!matched) return false;
  if (onlyfiles.size()>0)
  {
	
		matched=false;
		if (flagnorecursion)
		{
			matched=onlynorecursion(filename);
		}
		else
		{	
			for (unsigned i=0; i<onlyfiles.size() && !matched; ++i)
			{
				if (flagdebug3)
					myprintf("00617: check only %03d %s  on filename %s\n",(int)i,onlyfiles[i].c_str(),filename);

				if (ispath(onlyfiles[i].c_str(), filename))
				{
					matched=true;
					break;
				}
			}
		}
  }
  if (!matched) return false;
  for (unsigned j=0; j<notfiles.size(); ++j)
  {
	 if (flagdebug3)
		myprintf("00618: check notfiles %03d %s  on filename %s\n",(int)j,notfiles[j].c_str(),filename);
	if (ispath(notfiles[j].c_str(), filename))
      return false;
  }
  return true;
}

#define MYIO_REPARSE_TAG_CLOUD   0x9000001A
#define MYIO_REPARSE_TAG_CLOUD_1 0x9000101A
#define MYIO_REPARSE_TAG_CLOUD_2 0x9000201A
#define MYIO_REPARSE_TAG_CLOUD_3 0x9000301A
#define MYIO_REPARSE_TAG_CLOUD_4 0x9000401A
#define MYIO_REPARSE_TAG_CLOUD_5 0x9000501A
#define MYIO_REPARSE_TAG_CLOUD_6 0x9000601A
#define MYIO_REPARSE_TAG_CLOUD_7 0x9000701A
#define MYIO_REPARSE_TAG_CLOUD_8 0x9000801A
#define MYIO_REPARSE_TAG_CLOUD_9 0x9000901A
#define MYIO_REPARSE_TAG_CLOUD_A 0x9000A01A
#define MYIO_REPARSE_TAG_CLOUD_B 0x9000B01A
#define MYIO_REPARSE_TAG_CLOUD_C 0x9000C01A
#define MYIO_REPARSE_TAG_CLOUD_D 0x9000D01A
#define MYIO_REPARSE_TAG_CLOUD_E 0x9000E01A
#define MYIO_REPARSE_TAG_CLOUD_F 0x9000F01A

/*
	This is a kludge to get the filesize of a symlinked file on Windows,
	in a (more or less) "portable" (against compilators) way
*/
#ifdef _WIN32
int64_t dim(string i_filename)
{
    FILE* inFile = freadopen(i_filename.c_str());
    if (inFile==NULL)
		return 0;
	int64_t realsize=prendidimensionehandle(inFile);
	fclose(inFile);
	return realsize;
}
#endif // corresponds to #ifdef (#ifdef _WIN32)



/////////////////////////////

#ifdef _WIN32

struct NTFSFileInfo 
{
    DWORDLONG frn;
    DWORDLONG parentFrn;
    std::wstring name;
    bool isDirectory;
    int64_t size;
    FILETIME creationTime;
    FILETIME lastWriteTime;
    FILETIME lastAccessTime;
    DWORD attributes;
};

typedef struct _FILE_RECORD_SEGMENT_HEADER 
{
    CHAR MultiSectorHeader[4];
    USHORT UpdateSequenceArrayOffset;
    USHORT UpdateSequenceArraySize;
    ULONGLONG LogFileSequenceNumber;
    USHORT SequenceNumber;
    USHORT LinkCount;
    USHORT FirstAttributeOffset;
    USHORT Flags;
    ULONG BytesInUse;
    ULONG BytesAllocated;
    ULONGLONG BaseFileRecordSegment;
    USHORT NextAttributeInstance;
} FILE_RECORD_SEGMENT_HEADER, *PFILE_RECORD_SEGMENT_HEADER;

typedef struct _STANDARD_INFORMATION 
{
    LARGE_INTEGER CreationTime;
    LARGE_INTEGER LastWriteTime;
    LARGE_INTEGER LastAccessTime;
    LARGE_INTEGER ChangeTime;
    ULONG FileAttributes;
    // ... the rest is not necessary for this implementation
} STANDARD_INFORMATION, *PSTANDARD_INFORMATION;


// Update the enum to include $ATTRIBUTE_LIST
typedef enum _ATTRIBUTE_TYPE_CODE 
{
    AttributeStandardInformation = 0x10,
    AttributeAttributeList       = 0x20,
    AttributeFileName            = 0x30,
    AttributeData                = 0x80,
    AttributeEnd                 = 0xFFFFFFFF
} ATTRIBUTE_TYPE_CODE;

#pragma pack(push, 1) // Set alignment to 1 byte
typedef struct _ATTRIBUTE_LIST_ENTRY {
    ATTRIBUTE_TYPE_CODE AttributeTypeCode;
    USHORT RecordLength;
    UCHAR  AttributeNameLength;
    UCHAR  AttributeNameOffset;
    ULONGLONG StartingVcn;
    ULONGLONG SegmentReferenceNumber; // This is the FRN of the extension record!
    USHORT AttributeInstance;
    // The attribute name would follow here, if present
} ATTRIBUTE_LIST_ENTRY, *PATTRIBUTE_LIST_ENTRY;
#pragma pack(pop) // Restore default alignment

// New structures for a cleaner and safer parsing of NTFS attributes
typedef struct _ATTRIBUTE_RECORD_HEADER 
{
    ATTRIBUTE_TYPE_CODE TypeCode;
    ULONG  RecordLength;
    UCHAR  NonResident;
    UCHAR  NameLength;
    USHORT NameOffset;
    USHORT Flags;
    USHORT Instance;
} ATTRIBUTE_RECORD_HEADER, *PATTRIBUTE_RECORD_HEADER;

typedef struct _RESIDENT_ATTRIBUTE_HEADER 
{
    ATTRIBUTE_RECORD_HEADER Common;
    ULONG  ValueLength;
    USHORT ValueOffset;
    USHORT Reserved;
} RESIDENT_ATTRIBUTE_HEADER, *PRESIDENT_ATTRIBUTE_HEADER;

typedef struct _NON_RESIDENT_ATTRIBUTE_HEADER 
{
    ATTRIBUTE_RECORD_HEADER Common;
    ULONGLONG StartingVcn;
    ULONGLONG LastVcn;
    USHORT RunArrayOffset;
    USHORT CompressionUnit;
    ULONG  Padding;
    ULONGLONG AllocatedSize;
    ULONGLONG RealSize;
    ULONGLONG InitializedSize;
} NON_RESIDENT_ATTRIBUTE_HEADER, *PNON_RESIDENT_ATTRIBUTE_HEADER;

union TimeUnion 
{
    LARGE_INTEGER li;
    FILETIME ft;
};
bool getFileAttributesFromMFT(HANDLE hVolume, DWORDLONG frn, NTFSFileInfo& fi, const std::wstring& debugPath = L"")
{
    // --- PHASE 1: Reading the base MFT record ---

    struct { ULONGLONG FileReferenceNumber; } input = { frn };
    BYTE outputBuffer[10240];
    DWORD bytesReturned;

  //  bool isDebugFile = (frn == 2814749767436488) || (frn == 5629499534540560);
	bool isDebugFile=false;
    if (isDebugFile) 
	{
        myprintf("\n=== DEBUG DUMP per %s ===\n", wtou(debugPath.c_str()).c_str());
        myprintf("FRN INIZIALE: %s\n", migliaia(frn));
    }

    if (!DeviceIoControl(hVolume, FSCTL_GET_NTFS_FILE_RECORD, &input, sizeof(input),
        outputBuffer, sizeof(outputBuffer), &bytesReturned, NULL)) 
	{
        if (isDebugFile) 
			myprintf("DeviceIoControl (fas 1) failed, error: %d\n", GetLastError());
        return false;
    }

    if (bytesReturned < 12)
	{ /* ... controlli iniziali ... */ 
		return false; 
	}

    DWORD mftRecordLength = *(ULONG*)(outputBuffer + 8);
    BYTE* mftRecord = outputBuffer + 12;

    if (bytesReturned < (12 + mftRecordLength) || mftRecordLength < sizeof(FILE_RECORD_SEGMENT_HEADER)) { /* ... */ return false; }

    PFILE_RECORD_SEGMENT_HEADER record = (PFILE_RECORD_SEGMENT_HEADER)mftRecord;
    if (memcmp(record->MultiSectorHeader, "FILE", 4) != 0) { /* ... */ return false; }
    
    if (isDebugFile) {
        myprintf("Header MFT valido, FirstAttributeOffset: %d, BytesInUse: %d\n", record->FirstAttributeOffset, record->BytesInUse);
    }
    
    BYTE* attrPtr = mftRecord + record->FirstAttributeOffset;
    BYTE* mftEndPtr = mftRecord + record->BytesInUse;

    bool foundStdInfo = false;
    bool foundDataAttr = false;
    // NEW: Variable to store theFRN of the extension record containing $DATA
    DWORDLONG dataRecordFrn = 0;

    fi.size = ULONGLONG(-2);

    while (attrPtr < mftEndPtr)
    {
        PATTRIBUTE_RECORD_HEADER attrHeader = (PATTRIBUTE_RECORD_HEADER)attrPtr;
        if (attrHeader->TypeCode == AttributeEnd) break;
        if (attrHeader->RecordLength == 0 || (attrPtr + attrHeader->RecordLength > mftEndPtr)) break;

        // --- Parsing attributes in the base record ---

/// i maledetti warning
/*
        if (attrHeader->TypeCode == AttributeStandardInformation && !foundStdInfo)
        {
            // ... (logica per $STANDARD_INFORMATION, invariata) ...
            PRESIDENT_ATTRIBUTE_HEADER resAttr = (PRESIDENT_ATTRIBUTE_HEADER)attrHeader;
            if (resAttr->Common.RecordLength >= sizeof(RESIDENT_ATTRIBUTE_HEADER) && resAttr->ValueLength >= sizeof(STANDARD_INFORMATION)) {
                PSTANDARD_INFORMATION stdInfo = (PSTANDARD_INFORMATION)(attrPtr + resAttr->ValueOffset);
                fi.creationTime = *(FILETIME*)&stdInfo->CreationTime;
                fi.lastWriteTime = *(FILETIME*)&stdInfo->LastWriteTime;
                fi.lastAccessTime = *(FILETIME*)&stdInfo->LastAccessTime;
                fi.attributes = stdInfo->FileAttributes;
                foundStdInfo = true;
            }
        }
*/


		if (attrHeader->TypeCode == AttributeStandardInformation && !foundStdInfo) 
		{
			PRESIDENT_ATTRIBUTE_HEADER resAttr = (PRESIDENT_ATTRIBUTE_HEADER)attrHeader;
			if (resAttr->Common.RecordLength >= sizeof(RESIDENT_ATTRIBUTE_HEADER) && resAttr->ValueLength >= sizeof(STANDARD_INFORMATION)) 
			{
				PSTANDARD_INFORMATION stdInfo = (PSTANDARD_INFORMATION)(attrPtr + resAttr->ValueOffset);
				TimeUnion tu;
				
				tu.li = stdInfo->CreationTime;
				fi.creationTime = tu.ft;
				
				tu.li = stdInfo->LastWriteTime;
				fi.lastWriteTime = tu.ft;
				
				tu.li = stdInfo->LastAccessTime;
				fi.lastAccessTime = tu.ft;
				
				fi.attributes = stdInfo->FileAttributes;
				foundStdInfo = true;
			}
		}
        else if (attrHeader->TypeCode == AttributeData && !fi.isDirectory && !foundDataAttr)
        {
            // ... (logic for $DATA, unchanged, is only activated if $DATA is in the base record) ...
            if (attrHeader->NameLength == 0) {
                 if (attrHeader->NonResident == 0) {
                    fi.size = ((PRESIDENT_ATTRIBUTE_HEADER)attrHeader)->ValueLength;
                    foundDataAttr = true;
                 } else {
                    fi.size = ((PNON_RESIDENT_ATTRIBUTE_HEADER)attrHeader)->RealSize;
                    foundDataAttr = true;
                 }
            }
        }
        else if (attrHeader->TypeCode == AttributeAttributeList)
        {
            // NEW: Handling of $ATTRIBUTE_LIST
            if (isDebugFile) 
				myprintf("Founded $ATTRIBUTE_LIST, scanning...\n");
            
            PRESIDENT_ATTRIBUTE_HEADER resAttr = (PRESIDENT_ATTRIBUTE_HEADER)attrHeader;
            BYTE* listEntryPtr = attrPtr + resAttr->ValueOffset;
            BYTE* listEndPtr = attrPtr + resAttr->Common.RecordLength;

            while (listEntryPtr < listEndPtr) {
                PATTRIBUTE_LIST_ENTRY entry = (PATTRIBUTE_LIST_ENTRY)listEntryPtr;
                if (entry->RecordLength < sizeof(ATTRIBUTE_LIST_ENTRY)) break; // Corrupted entry

                // We look for the entry that describes the $DATA attribute
                if (entry->AttributeTypeCode == AttributeData) {
                    if (isDebugFile) myprintf("Trovata voce per $DATA in $ATTRIBUTE_LIST. FRN di estensione: %s\n", migliaia(entry->SegmentReferenceNumber));
                    dataRecordFrn = entry->SegmentReferenceNumber;
                    goto end_attribute_scan; // Exit both loops, we have the pointer
                }
                listEntryPtr += entry->RecordLength;
            }
        }

        if (foundStdInfo && foundDataAttr) break;
        attrPtr += attrHeader->RecordLength;
    }
end_attribute_scan:; // Label to exit the base record scan

    // --- PHASE 2: Reading the extension record (if necessary) ---

    // NEW: If we found a pointer to $DATA in an Attribute List and we don't have the size yet...
    if (dataRecordFrn != 0 && !foundDataAttr)
    {
        if (isDebugFile) myprintf("Avvio FASE 2: Lettura del record MFT di estensione FRN %s\n", migliaia(dataRecordFrn));
        
        input.FileReferenceNumber = dataRecordFrn;
        BYTE extOutputBuffer[10240];
        DWORD extBytesReturned;

        if (DeviceIoControl(hVolume, FSCTL_GET_NTFS_FILE_RECORD, &input, sizeof(input),
            extOutputBuffer, sizeof(extOutputBuffer), &extBytesReturned, NULL))
        {
            BYTE* extMftRecord = extOutputBuffer + 12;
            PFILE_RECORD_SEGMENT_HEADER extRecordHdr = (PFILE_RECORD_SEGMENT_HEADER)extMftRecord;
            BYTE* extAttrPtr = extMftRecord + extRecordHdr->FirstAttributeOffset;
            BYTE* extMftEndPtr = extMftRecord + extRecordHdr->BytesInUse;
            
            // Scan the extension record specifically looking for $DATA
            while (extAttrPtr < extMftEndPtr) {
                PATTRIBUTE_RECORD_HEADER extAttrHdr = (PATTRIBUTE_RECORD_HEADER)extAttrPtr;
                if (extAttrHdr->TypeCode == AttributeEnd || extAttrHdr->RecordLength == 0) break;

                if (extAttrHdr->TypeCode == AttributeData && extAttrHdr->NameLength == 0) {
                    if (extAttrHdr->NonResident) {
                         PNON_RESIDENT_ATTRIBUTE_HEADER nonResAttr = (PNON_RESIDENT_ATTRIBUTE_HEADER)extAttrHdr;
                         fi.size = nonResAttr->RealSize;
                         foundDataAttr = true;
                         if (isDebugFile) myprintf("Trovato $DATA non residente nel record di estensione. Dimensione: %s\n", migliaia(fi.size));
                    }
                    break; // Found, let's exit
                }
                extAttrPtr += extAttrHdr->RecordLength;
            }
        } else {
             if (isDebugFile) myprintf("DeviceIoControl (fas 2) failed, error: %d\n", GetLastError());
        }
    }

    if (isDebugFile) {
        myprintf("Fine parsing attributi:\n");
        myprintf("foundStdInfo: %s, foundDataAttr: %s\n", foundStdInfo ? "SI" : "NO", foundDataAttr ? "SI" : "NO");
        if(foundDataAttr) {
            myprintf("Dimensione finale del file: %s\n", migliaia(fi.size));
        } else {
            myprintf("La dimensione del file non e' stata trovata, rimane a -2\n");
        }
        myprintf("=== FINE DEBUG DUMP ===\n\n");
    }
    
    return foundStdInfo;
}


void buildPaths(DWORDLONG rootFrn, const std::wstring& rootPath, const std::map<DWORDLONG, NTFSFileInfo>& files, std::map<DWORDLONG, std::wstring>& frnToPath) 
{
    std::map<DWORDLONG, std::vector<DWORDLONG>> parentToChildren;
    for (const auto& pair : files) 
        parentToChildren[pair.second.parentFrn].push_back(pair.first);
    
    std::vector<std::pair<DWORDLONG, std::wstring>> stack;
    stack.push_back(std::make_pair(rootFrn, rootPath));

    while (!stack.empty()) 
    {
        std::pair<DWORDLONG, std::wstring> current = stack.back();
        stack.pop_back();

        DWORDLONG currentFrn = current.first;
        std::wstring currentPath = current.second;

        frnToPath[currentFrn] = currentPath;

        if (parentToChildren.count(currentFrn)) 
            for (DWORDLONG childFrn : parentToChildren[currentFrn]) 
                if (files.count(childFrn)) 
                {
                    const NTFSFileInfo& childInfo = files.at(childFrn);
                    stack.push_back(std::make_pair(childFrn, currentPath + L"\\" + childInfo.name));
                }
    }
}
int64_t ConvertFileTimeToCustomInt(const FILETIME& ft) 
{
    SYSTEMTIME st;
    if (FileTimeToSystemTime(&ft, &st)) {
        return st.wYear * 10000000000LL + st.wMonth * 100000000LL + st.wDay * 1000000
             + st.wHour * 10000 + st.wMinute * 100 + st.wSecond;
    }
    return 0;
}

bool starts_with_case_insensitive(const std::wstring& prefix, const std::wstring& text) 
{
    if (prefix.size() > text.size()) 
	    return false;
    
    for (size_t i=0;i<prefix.size();++i) 
        if (std::towlower(prefix[i]) != std::towlower(text[i])) 
            return false;
    return true;
}

int Jidac::NTFSEnumerateFiles(std::string i_path, DTMap& i_edt, bool i_checkifselected) 
{
    int fileCount = 0;

    if (i_path.size() == 0)
    {
        myprintf("64036: Error i_path empty\n");
        return 0;
    }

    std::string drive(1, std::toupper(static_cast<unsigned char>(i_path[0])));
    std::wstring volumePath = L"\\\\.\\" + utow(drive.c_str()) + L":";
    std::wstring rootPath = utow(drive.c_str()) + L":\\";
    std::wstring wi_path = utow(i_path.c_str());

    HANDLE hVolume = CreateFileW(volumePath.c_str(), GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, FILE_FLAG_BACKUP_SEMANTICS, NULL);
    if (hVolume == INVALID_HANDLE_VALUE) 
    {
        myprintf("64056: error opening volume %s: %d\n", wtou(volumePath.c_str()).c_str(), GetLastError());
        return 0;
    }

    // Step 1: Complete enumeration of files from the USN journal
    std::map<DWORDLONG, NTFSFileInfo> files;
    MFT_ENUM_DATA med;
	memset(&med,0,sizeof(med));
	med.StartFileReferenceNumber = 0;
    med.LowUsn = 0;
    med.HighUsn = MAXLONGLONG;

    BYTE buffer[64 * 1024];
    DWORD bytesReturned;
    bool moreData = true;
    myprintf("64096: Enumerating from USN Journal for drive %c...\n", drive[0]);

    while (moreData) 
    {
        if (DeviceIoControl(hVolume, FSCTL_ENUM_USN_DATA, &med, sizeof(med), buffer, sizeof(buffer), &bytesReturned, NULL)) 
        {
            DWORDLONG nextStart = *(DWORDLONG*)buffer;
            PUSN_RECORD pRecord = (PUSN_RECORD)(buffer + 8);
            DWORD offset = 8;
            while (offset < bytesReturned) 
            {
                if (pRecord->MajorVersion == 2) 
                {
                    NTFSFileInfo fi;
                    fi.frn = pRecord->FileReferenceNumber;
                    fi.parentFrn = pRecord->ParentFileReferenceNumber;
                    fi.name = std::wstring(pRecord->FileName, pRecord->FileNameLength / sizeof(WCHAR));
                    fi.isDirectory = (pRecord->FileAttributes & FILE_ATTRIBUTE_DIRECTORY) != 0;
                    fi.size = -1; // Placeholder, metadata will be obtained later
                    fi.attributes = pRecord->FileAttributes; // Base attributes from the journal
                    memset(&fi.creationTime,0,sizeof(fi.creationTime));
                    memset(&fi.lastWriteTime,0,sizeof(fi.lastWriteTime));
                    memset(&fi.lastAccessTime,0,sizeof(fi.lastAccessTime));
                    files[fi.frn] = fi;
                }
                offset += pRecord->RecordLength;
                pRecord = (PUSN_RECORD)((BYTE*)pRecord + pRecord->RecordLength);
            }
            med.StartFileReferenceNumber = nextStart;
        } 
        else 
        {
            DWORD error = GetLastError();
            if (error == ERROR_HANDLE_EOF || error == ERROR_NO_MORE_FILES) 
                moreData = false;
            else 
            {
                myprintf("65115: Error in DeviceIoControl: %d\n", error);
                CloseHandle(hVolume);
                return 0;
            }
        }
    }

    myprintf("64119: Enumeration completed, total records: %s\n", migliaia(files.size()));

    // Step 2: Find the root of the volume
    DWORDLONG rootFrn = 0;
    for (const auto& pair : files) 
    {
        if ((files.find(pair.second.parentFrn) == files.end() || pair.second.parentFrn == pair.first) &&
            pair.second.isDirectory &&
            pair.second.name != L"$RmMetadata" &&
            pair.second.name != L"Program Files" &&
            pair.second.name != L"Program Files (x86)") 
        {
            rootFrn = pair.second.parentFrn;
            myprintf("64134: Found root FRN via parent check: %s\n", wtou(pair.second.name.c_str()).c_str());
            break;
        }
    }

    // Fallback to FRN 5 if not found
    if (rootFrn == 0) 
    {
        if (files.count(5)) 
        {
            rootFrn = 5;
            myprintf("64147: Fallback to rootFrn=5\n");
        }
    }

    if (rootFrn == 0) 
    {
        myprintf("64153: Cannot find root, cannot build paths\n");
        CloseHandle(hVolume);
        return 0;
    }

    // Step 3: Reconstruct the full paths
    std::map<DWORDLONG, std::wstring> frnToPath;
    myprintf("64158: Building paths for drive %s starting from FRN %s\n", wtou(rootPath.c_str()).c_str(), migliaia(rootFrn));
    int64_t startbuild = mtime();
    buildPaths(rootFrn, rootPath.substr(0, rootPath.length() - 1), files, frnToPath);
    myprintf("64181: Path construction complete. Total paths built: %s time %s\n", migliaia(frnToPath.size()), migliaia2(mtime() - startbuild));

    // Step 4: Filter relevant files and get metadata only for those
    for (const auto& pair : files) 
    {
        const NTFSFileInfo& fi = pair.second;
        if (frnToPath.find(fi.frn) == frnToPath.end()) 
            continue; // Skip orphan files

        if (fi.isDirectory) 
            continue; // Process only files, not directories

        std::wstring path = frnToPath[fi.frn];
        if (!starts_with_case_insensitive(wi_path, path)) 
            continue; // Skip files that do not start with the specified path

        // Step 5: Get complete metadata from the MFT for the filtered files
        NTFSFileInfo updatedFi = fi; // Copy existing data
        if (!getFileAttributesFromMFT(hVolume, fi.frn, updatedFi)) 
        {
            // If it fails, keep the base data (attributes from the journal, size at -1)
            myprintf("64200: Warning: Failed to get MFT attributes for FRN %s\n", migliaia(fi.frn));
        }

        // Step 6: Process the file with the updated metadata
        SYSTEMTIME stCreate, stModify, stAccess;
        FileTimeToSystemTime(&updatedFi.creationTime, &stCreate);
        FileTimeToSystemTime(&updatedFi.lastWriteTime, &stModify);
        FileTimeToSystemTime(&updatedFi.lastAccessTime, &stAccess);
		
		
		 
        if (flagdebug)
        {
			if (prendidimensionefile(wtou(path.c_str()).c_str())!=updatedFi.size)
			{	
				myprintf("\n");
				myprintf("64112: frn %s file: %s\n", migliaia(fi.frn),wtou(path.c_str()).c_str());
				myprintf("64113: Getted %s expected %s %d\n",migliaia(prendidimensionefile(wtou(path.c_str()).c_str())),migliaia2(updatedFi.size),updatedFi.size);
			}
			
			myprintf("64179: File: %s\n", wtou(path.c_str()).c_str());
			myprintf("64183:   Size: %22s bytes ", migliaia(updatedFi.size));
            if (updatedFi.attributes) 
            {
                myprintf("Attr:");
                if (updatedFi.attributes & FILE_ATTRIBUTE_READONLY)  myprintf(" Read-only");
                if (updatedFi.attributes & FILE_ATTRIBUTE_HIDDEN)    myprintf(" Hidden");
                if (updatedFi.attributes & FILE_ATTRIBUTE_SYSTEM)    myprintf(" System");
                if (updatedFi.attributes & FILE_ATTRIBUTE_ARCHIVE)   myprintf(" Archive");
                myprintf("\n");
            }
            myprintf("64185:   Created: %04d-%02d-%02d %02d:%02d:%02d Modified: %04d-%02d-%02d %02d:%02d:%02d Access: %04d-%02d-%02d %02d:%02d:%02d\n",
                stCreate.wYear, stCreate.wMonth, stCreate.wDay, stCreate.wHour, stCreate.wMinute, stCreate.wSecond,
                stModify.wYear, stModify.wMonth, stModify.wDay, stModify.wHour, stModify.wMinute, stModify.wSecond,
                stAccess.wYear, stAccess.wMonth, stAccess.wDay, stAccess.wHour, stAccess.wMinute, stAccess.wSecond);
        }

        // Prepare data for addfile
        std::string fn = wtou(path.c_str());
        int64_t esize = (updatedFi.size == -1) ? 0 : updatedFi.size;
        int64_t edate = ConvertFileTimeToCustomInt(updatedFi.lastWriteTime);
        int64_t creationdate = ConvertFileTimeToCustomInt(updatedFi.creationTime);
        int64_t accessdate = ConvertFileTimeToCustomInt(updatedFi.lastAccessTime);
        const int64_t eattr = 'w' + (int64_t(updatedFi.attributes) << 8);

        if (flagdebug3) 
            myprintf("63963: NTFS Adding %s\n", fn.c_str());

        // Call the function to add the file
        addfile(i_checkifselected, i_edt, fn, edate, esize, eattr, creationdate, accessdate);
        fileCount++;
    }

    CloseHandle(hVolume);
    myprintf("\n");
    myprintf("64237: Filecount %s\n", migliaia(fileCount));
    return fileCount;
}
bool IsPathNTFS(const char* path) 
{
    wchar_t widePath[MAX_PATH];
    wchar_t volumeRoot[MAX_PATH];
    wchar_t fileSystemName[MAX_PATH];

    // Convert the path from char* to wchar_t*
    if (MultiByteToWideChar(CP_ACP, 0, path, -1, widePath, MAX_PATH) == 0) {
        myprintf("63988: Error multi\n");
		return false;
    }

    // Gets the root path of thevolume (e.g. "C:\")
    if (!GetVolumePathNameW(widePath, volumeRoot, MAX_PATH)) 
	{
		myprintf("63995: Cannot get on path %s\n",path);
        return false;
    }

    // Get volume information, including the filesystem name
    if (!GetVolumeInformationW(volumeRoot, NULL, 0, NULL, NULL, NULL, fileSystemName, MAX_PATH)) 
	{
        myprintf("64002: Error getting volumeroot\n");
		return false;
    }

    // Compare the filesystem name with "NTFS"
    if (_wcsicmp(fileSystemName, L"NTFS") == 0) 
	    return true;
     else 
	    return false;
 
}
#endif


void Jidac::exclude_output()
{
	if (g_output!="")
	{
		string no_output="*"+extractfilename(g_output);
		if (flagverbose)
		{
			color_yellow();
			myprintf("72383: WARN: excluding <<%s>> due to -out\n",no_output.c_str());
			color_restore();
		}
		notfiles.push_back(no_output);
	}
}

string fix_scandir(const string& i_path)
{
    if (i_path == ".") 
        return "./";
    
    if (isdirectory(i_path)) 
	    return i_path;
    
    if (realfileexists(i_path)) 
	    return i_path;
    
    string dir_path = i_path+"/";
    
    if (direxists(dir_path)) 
	{
        if (flagverbose) 
		{
            color_yellow();
            myprintf("WARNING: Path '%s' not found as file, but exists as directory '%s'. Using directory\n", 
                    i_path.c_str(), dir_path.c_str());
            color_restore();
        }
        return dir_path;
    }
    return i_path;
}

// Insert external filename (UTF-8 with "/") into dt if selected
// by files, onlyfiles, and notfiles. If filename
// is a directory then also insert its contents.
// In Windows, filename might have wildcards like "file.*" or "dir/*"
// In zpaqfranz, sometimes, we DO not want to recurse
void Jidac::scandir(bool i_checkifselected,DTMap& i_edt,string filename, bool i_recursive)
{
  // Don't scan diretories excluded by -not
  for (unsigned i=0; i<notfiles.size(); ++i)
    if (ispath(notfiles[i].c_str(), filename.c_str()))
      return;
	if (!flagforcezfs)
		if (flagskipzfs)
			if (iszfs(filename))
			{
				if (flagverbose)
					myprintf("00625: Verbose: Skip .zfs ----> %s\n",filename.c_str());
				return;
			}
	if (flagnomac)
		if (ismac(filename))
			return;
/*
	if (flagnosynology)
		if (issynology(filename))
			return false;
*/
	if (flagnoqnap)
	{
		if (filename.find("@Recently-Snapshot")!=std::string::npos)
		{
			if (flagverbose)
				myprintf("00626: Verbose: Skip qnap snapshot ----> %s\n",filename.c_str());
			return;
		}
		if (filename.find("@Recycle")!=std::string::npos)
		{
			if (flagverbose)
				myprintf("00627: Verbose: Skip qnap recycle ----> %s\n",filename.c_str());
			return;
		}
	}
#ifdef unix
// Add regular files and directories
	while (filename.size()>1 && filename[filename.size()-1]=='/')
		filename=filename.substr(0, filename.size()-1);  // remove trailing /
	struct stat sb;
	if (!lstat(filename.c_str(), &sb))
	{
		int64_t creationdate=0;
		
		if (S_ISREG(sb.st_mode))
		{
			if (flagdate)
			{
				creationdate=datacreazione(filename);
				if (flagdebug3)
					myprintf("00628: Birth date %s of %s\n",dateToString(flagutc,creationdate).c_str(),filename.c_str());
			}
			addfile(i_checkifselected,i_edt,filename, decimal_time(sb.st_mtime), sb.st_size,'u'+(sb.st_mode<<8),creationdate,0);
		}
    // Traverse directory
		if (S_ISDIR(sb.st_mode))
		{
			addfile(i_checkifselected,i_edt,filename=="/" ? "/" : filename+"/", decimal_time(sb.st_mtime),0, 'u'+(int64_t(sb.st_mode)<<8),creationdate,0);
			DIR* dirp=opendir(filename.c_str());
			if (dirp)
			{
				for (dirent* dp=readdir(dirp); dp; dp=readdir(dirp))
				{
					if (strcmp(".", dp->d_name) && strcmp("..", dp->d_name))
					{
						string s=filename;
						if (s!="/") s+="/";
						s+=dp->d_name;
						if (i_recursive)
							scandir(i_checkifselected,i_edt,s);
						else
						{
							if (!lstat(s.c_str(), &sb))
							{
								int64_t creationdate=0;
								
								if (S_ISREG(sb.st_mode))
								{
									if (flagdate)
									{
										creationdate=datacreazione(s);
										if (flagdebug3)
											myprintf("00629: Birth date %s of %s\n",dateToString(flagutc,creationdate).c_str(),s.c_str());
									}
									addfile(i_checkifselected,i_edt,s, decimal_time(sb.st_mtime), sb.st_size,'u'+(sb.st_mode<<8),creationdate,0);
								}
								if (S_ISDIR(sb.st_mode))
									addfile(i_checkifselected,i_edt,s=="/" ? "/" :s+"/", decimal_time(sb.st_mtime),0, 'u'+(int64_t(sb.st_mode)<<8),creationdate,0);
							}
						}
					}
				}
				closedir(dirp);
			}
			else
			{
					perror(filename.c_str());
			}
		}
	}
	else
	{
		if (!flagstdin)
			perror(filename.c_str());
	}
#else  // Windows: expand wildcards in filename

#ifdef _WIN32
	if ((flagntfs) && (!flagimage))
	{
		if (!IsPathNTFS(filename.c_str()))
		{
			myprintf("\n");
			myprintf("64139! I can work only on NTFS, turning off\n");
			flagntfs=false;
		}
	}
	if ((flagntfs) && (!flagimage))
	{
		printbar('-');
		printbar('-');
		myprintf("NTFS %s\n",filename.c_str());
		printbar('-');
		printbar('-');
		
		int currentPathFileCount = NTFSEnumerateFiles(filename,i_edt,i_checkifselected);
		if (flagdebug)
			myprintf("64180: Founded %s %s\n",migliaia(currentPathFileCount),migliaia2(i_edt.size()));
		return;
	}
#endif

  // Expand wildcards
  WIN32_FIND_DATA ffd;
  string t=filename;
  if (t.size()>0 && t[t.size()-1]=='/') t+="*";
  HANDLE h=FindFirstFile(utow(t.c_str()).c_str(), &ffd);

  if (!flagverbose)
	if (h==INVALID_HANDLE_VALUE)
		if (GetLastError()==5) //ERROR_ACCESS_DENIED
			if (mypos("/System Volume Information/",t)>=0)
			{
				FindClose(h);
				return;
			}

  if (h==INVALID_HANDLE_VALUE
      && GetLastError()!=ERROR_FILE_NOT_FOUND
      && GetLastError()!=ERROR_PATH_NOT_FOUND)
    printerr("scandir",t.c_str(),0);
	while (h!=INVALID_HANDLE_VALUE)
	{
		// For each file, get name, date, size, attributes
		SYSTEMTIME st;
/*
		[out, optional] LPFILETIME lpCreationTime,
  [out, optional] LPFILETIME lpLastAccessTime,
  [out, optional] LPFILETIME lpLastWriteTime
*/

		int64_t edate=0;
		if (FileTimeToSystemTime(&ffd.ftLastWriteTime, &st))
			edate=st.wYear*10000000000LL+st.wMonth*100000000LL+st.wDay*1000000
				+st.wHour*10000+st.wMinute*100+st.wSecond;

		int64_t creationdate=0;
		if (FileTimeToSystemTime(&ffd.ftCreationTime, &st))
			creationdate=st.wYear*10000000000LL+st.wMonth*100000000LL+st.wDay*1000000
				+st.wHour*10000+st.wMinute*100+st.wSecond;
		int64_t accessdate=0;
/*
		if (FileTimeToSystemTime(&ffd.ftLastAccessTime, &st))
			accessdate=st.wYear*10000000000LL+st.wMonth*100000000LL+st.wDay*1000000
				+st.wHour*10000+st.wMinute*100+st.wSecond;
*/


		int64_t esize=ffd.nFileSizeLow+(int64_t(ffd.nFileSizeHigh)<<32);
		const int64_t eattr='w'+(int64_t(ffd.dwFileAttributes)<<8);
		// Ignore links, the names "." and ".." or any unselected file
		t=wtou(ffd.cFileName);
		/// Ok this is rather weird, but is Microsoft afterall
		/// a SYMLINK in a VSS can become rather tricky
		/// this should (?) get the "real" name of a SYMLINK
		/// Microsoft documentations sucks big time
		///string solonome=extractfilename(t);
		if ((ffd.dwFileAttributes & FILE_ATTRIBUTE_REPARSE_POINT) && !(ffd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
		{
			string miofilename=path(filename)+t;
			string nuovonome=my_realpath(miofilename);
			if (nuovonome!="")
			{
				int64_t newsize=dim(nuovonome);
				esize=newsize;
			}
			string percorso="";
			size_t destra= nuovonome.rfind(t);
			if (destra!=std::string::npos)
				percorso=myleft(nuovonome,destra)+"*";
			if (percorso!="")
				filename=percorso;
		}
		if (flagdebug3) // sometimes Windows get very strange attributes
		{
			string myfn=path(filename)+t;
			myprintf("00630: FATTR %08X RES0 %08X %Z\n",(unsigned int)ffd.dwFileAttributes,(unsigned int)ffd.dwReserved0,myfn.c_str());
			string temp=decodewinattribute(ffd.dwFileAttributes);
			myprintf("00631: %s\n",temp.c_str());
		}
		if (t=="." || t=="..")
			edate=0;  // don't add, of course
	/*
		OK, now test Windows crazy fake files
	*/
		if ((ffd.dwFileAttributes & FILE_ATTRIBUTE_REPARSE_POINT) && (ffd.dwReserved0==IO_REPARSE_TAG_SYMLINK))
		{
			int64_t newsize=dim(filename);
			if (flagdebug)
				myprintf("00632: maybe Windows-symlinked file, fake size %s real size %s %s\n",migliaia(esize),migliaia(newsize),filename.c_str());
			esize=newsize;
		}
		if (ffd.dwFileAttributes & FILE_ATTRIBUTE_REPARSE_POINT)
		{
		/*
			REPARSE_POINTS are a nightmare
			For now: just skip
			char buffer[100000];
			int bufsize=100000;
			size_t 	byteletti;
			DWORD 	tag;
			string	tipo;
			string thefile=path(filename)+t;
			if (flagverbose)
				myprintf("00633: try to get reparse point %s\n",thefile.c_str());
			if (getreparsepointW(false,thefile,buffer,bufsize,byteletti,tag,tipo))
			{
				if (flagverbose)
				{
					myprintf("00634: Reparse <<%s>>\n",thefile.c_str());
					myprintf("00635: TAG %08X LEN %11s |%s|\n",tag,migliaia(byteletti),tipo.c_str());
				}
			}
			else
			{
				if (flagverbose)
					myprintf("00636: fallito getreparsepointW %s\n",thefile.c_str());
			}
			*/
		}
		if ((ffd.dwFileAttributes & FILE_ATTRIBUTE_REPARSE_POINT) && (!(ffd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)))
		{
			/// Houston, we have a strange deduplicated .vhdx file?
			/// add as by default
			if (flagdebug)
				myprintf("00637: Something strange (VHDX? SYMLINK?) FILE_ATTRIBUTE_REPARSE_POINT not DIR %s\n",t.c_str());
		
			if (flagnosymlink)
			{
				edate=0;
				if (flagverbose)
					myprintf("00638: Skipped due to -symlink REPARSE_POINT && !DIRECTORY\n");
			}
		}
		else
		{
			///	A junction?
			if ((ffd.dwFileAttributes & FILE_ATTRIBUTE_REPARSE_POINT) && (ffd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
			{

				///https://bvckup2.com/support/forum/topic/981
				///https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-fscc/c8e77b37-3909-4fe6-a4ea-2b9d423b1ee4
				if
				(
				(ffd.dwReserved0==MYIO_REPARSE_TAG_CLOUD)
				||
				(ffd.dwReserved0==MYIO_REPARSE_TAG_CLOUD_1)
				||
				(ffd.dwReserved0==MYIO_REPARSE_TAG_CLOUD_2)
				||
				(ffd.dwReserved0==MYIO_REPARSE_TAG_CLOUD_3)
				||
				(ffd.dwReserved0==MYIO_REPARSE_TAG_CLOUD_4)
				||
				(ffd.dwReserved0==MYIO_REPARSE_TAG_CLOUD_5)
				||
				(ffd.dwReserved0==MYIO_REPARSE_TAG_CLOUD_6)
				||
				(ffd.dwReserved0==MYIO_REPARSE_TAG_CLOUD_7)
				||
				(ffd.dwReserved0==MYIO_REPARSE_TAG_CLOUD_8)
				||
				(ffd.dwReserved0==MYIO_REPARSE_TAG_CLOUD_9)
				||
				(ffd.dwReserved0==MYIO_REPARSE_TAG_CLOUD_A)
				||
				(ffd.dwReserved0==MYIO_REPARSE_TAG_CLOUD_B)
				||
				(ffd.dwReserved0==MYIO_REPARSE_TAG_CLOUD_C)
				||
				(ffd.dwReserved0==MYIO_REPARSE_TAG_CLOUD_D)
				||
				(ffd.dwReserved0==MYIO_REPARSE_TAG_CLOUD_E)
				||
				(ffd.dwReserved0==MYIO_REPARSE_TAG_CLOUD_F)
				)
				{
					if (flagdebug)
						myprintf("00639: this seems a ONEDRIVE-something, try to keep\n");
				}


				else
				{
					if (flagdebug)
					{
						string myfn=path(filename)+t;
						myprintf("00640: discard REPARSE POINT & DIRECTORY <<%Z>>\n",myfn.c_str());
					}
					edate=0;  // don't add
				}
			}
		}
		string fn=path(filename)+t;
		// Save directory names with a trailing / and scan their contents
		// Otherwise, save plain files
		if (edate)
		{
			if (ffd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) fn+="/";
			addfile(i_checkifselected,i_edt,fn, edate, esize, eattr,creationdate,accessdate);
			if (i_recursive)
			{
				if (ffd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
				{
					fn+="*";
					scandir(i_checkifselected,i_edt,fn);
				}
		  // enumerate alternate streams (Win2003/Vista or later)
				else
				if (findFirstStreamW && findNextStreamW)
				{
					if (flagforcewindows)
					{
						WIN32_FIND_STREAM_DATA fsd;
						HANDLE ah=findFirstStreamW(utow(fn.c_str()).c_str(),
							FindStreamInfoStandard, &fsd, 0);
						while (ah!=INVALID_HANDLE_VALUE && findNextStreamW(ah, &fsd))
							addfile(i_checkifselected,i_edt,fn+wtou(fsd.cStreamName), edate,
						  fsd.StreamSize.QuadPart, eattr,creationdate,accessdate);
						if (ah!=INVALID_HANDLE_VALUE) FindClose(ah);
					}
				}
			}
		}
		if (!FindNextFile(h, &ffd))
		{
			if (GetLastError()!=ERROR_NO_MORE_FILES) printerr("scan2",(fn+fn).c_str(),ffd.dwFileAttributes);
				break;
		}
	}
	FindClose(h);
#endif // corresponds to #ifdef (#ifdef unix)
}
// Add external file and its date, size, and attributes to dt
void Jidac::addfile(bool i_checkifselected,DTMap& i_edt,string filename, int64_t edate,
                    int64_t esize, int64_t eattr,
					int64_t i_creationdate,int64_t i_accessdate)
{
	static int milione=0;
	if (i_checkifselected)
		if (!isselected(filename.c_str(), false,esize))
			return;
	//	OK, let's handle longpath on VSS by a kludge
	//	cook some spaghetti code!
	if (command=='q')
		if (filename.size()>250)
			myreplace(filename,g_franzsnap,g_vss_shadow);

	if (command!='j')
	{
		if (g_datefrom>0)
			if (edate<=g_datefrom)
				return;
		if (g_dateto>0)
			if (edate>=g_dateto)
				return;
	}
	DT& d=i_edt[filename];
	if (g_touch!=0)
		d.date=g_touch;
	else
		d.date=edate;
	d.creationdate=i_creationdate;
	d.accessdate=i_accessdate;
	d.size=esize;
	d.attr=flagnoattributes?0:eattr;
	d.data=0;
	g_bytescanned+=esize;
	g_filescanned++;

	static int ultimotempo	=-1;
	double scantime			=(mtime()-g_start+1);
	int iscantime			=(int64_t)(scantime/1000);

	if (flagdebug5)
	{
		milione++;
		if (milione % 1000000 == 0) 
		{
			int64_t dt_ram	=get_dt_ram();
			int64_t edt_ram	=get_edt_ram();
			int64_t extsize =(dt_ram+edt_ram+g_dt_ram)/100*165;
			
			myprintf("00642: Scanned %10s %02d:%02d:%02d %10s file/s (%21s) RAM~ %10s\n",
			migliaia((int64_t)i_edt.size()),
			int(iscantime/3600),
			int(iscantime/60)%60,
			int(iscantime)%60,
			migliaia3((int)(i_edt.size()/(scantime/1000.0))),migliaia2(g_bytescanned),tohuman(extsize));			
			fflush(stdout);
			
///			getcaptcha("ok","Fill (wipe) free space");

			return;
		}
	}
	
	if ((flagnoeta==false) && (!flagterse))
		if (iscantime!=ultimotempo)
		{
			
			ultimotempo=iscantime;
			
			myprintf("00643: Scanned %10s %02d:%02d:%02d %10s file/s (%21s)\r",
			migliaia((int64_t)i_edt.size()),
			int(iscantime/3600),
			int(iscantime/60)%60,
			int(iscantime)%60,
			migliaia3((int)(i_edt.size()/(scantime/1000.0))),migliaia2(g_bytescanned));
			fflush(stdout);
		}
}
//////////////////////////////// add //////////////////////////////////
// Append n bytes of x to sb in LSB order
inline void puti(libzpaq::StringBuffer& sb, uint64_t x, int n) {
  for (; n>0; --n) sb.put(x&255), x>>=8;
}
// A CompressJob is a queue of blocks to compress and write to the archive.
// Each block cycles through states EMPTY, FILLING, FULL, COMPRESSING,
// COMPRESSED, WRITING. The main thread waits for EMPTY buffers and
// fills them. A set of compressThreads waits for FULL threads and compresses
// them. A writeThread waits for COMPRESSED buffers at the front
// of the queue and writes and removes them.
// Buffer queue element
struct CJ {
  enum {EMPTY, FULL, COMPRESSING, COMPRESSED, WRITING} state;
  StringBuffer in;       // uncompressed input
  StringBuffer out;      // compressed output
  string filename;       // to write in filename field
  string comment;        // if "" use default
  string method;         // compression level or "" to mark end of data
  Semaphore full;        // 1 if in is FULL of data ready to compress
  Semaphore compressed;  // 1 if out contains COMPRESSED data
  CJ(): state(EMPTY) {}
};
// Instructions to a compression job
class CompressJob {
public:
  Mutex mutex;           // protects state changes
  OutputArchive* out;  // archive, public for ESXi support
private:
  int job;               // number of jobs
  CJ* q;                 // buffer queue
  unsigned qsize;        // number of elements in q
  int front;             // next to remove from queue
  Semaphore empty;       // number of empty buffers ready to fill
  Semaphore compressors; // number of compressors available to run
public:
  friend ThreadReturn compressThread(void* arg);
  friend ThreadReturn writeThread(void* arg);
  CompressJob(int threads, int buffers, OutputArchive * f):
      out(f),job(0), q(0), qsize(buffers), front(0)  {
	if (buffers<=0)
	{
		myprintf("54912! Invalid buffers! %s\n",migliaia(buffers));
		throw std::invalid_argument("54913: Invalid buffer size");
	}
    q=new CJ[buffers];
	g_allocatedram+=sizeof(CJ)*buffers;
		
    if (!q) throw std::bad_alloc();
    init_mutex(mutex);
    empty.init(buffers);
    compressors.init(threads);
    for (int i=0; i<buffers; ++i) {
      q[i].full.init(0);
      q[i].compressed.init(0);
    }
  }
  ~CompressJob() {
    for (int i=qsize-1; i>=0; --i) {
      q[i].compressed.destroy();
      q[i].full.destroy();
    }
    compressors.destroy();
    empty.destroy();
    destroy_mutex(mutex);
    delete[] q;
  }
  void appendz(StringBuffer& s, const char* filename, const string& method,
             const char* comment=0);
  vector<int> csize;  // compressed block sizes


};
// Write s at the back of the queue. Signal end of input with method=""
void CompressJob::appendz(StringBuffer& s, const char* fn, const string& method,
                        const char* comment) {
  for (unsigned k=(method=="")?qsize:1; k>0; --k) {
    empty.wait();
    lock(mutex);
    unsigned i, j;
    for (i=0; i<qsize; ++i) {
      if (q[j=(i+front)%qsize].state==CJ::EMPTY) {
        q[j].filename=fn?fn:"";
        q[j].comment=comment?comment:"jDC\x01";
//		myprintf("00644: the method |%s| fn |%s|\n",method.c_str(),fn);
        q[j].method=method;
        q[j].in.resize(0);
        q[j].in.swap(s);
        q[j].state=CJ::FULL;
        q[j].full.signal();
        break;
      }
    }
    release(mutex);
    assert(i<qsize);  // queue should not be full
  }
}
// Compress data in the background, one per buffer
ThreadReturn compressThread(void* arg) {
  CompressJob& job=*(CompressJob*)arg;
  int jobNumber=0;
  try {
    // Get job number = assigned position in queue
    lock(job.mutex);
    jobNumber=job.job++;
    assert(jobNumber>=0 && jobNumber<int(job.qsize));
    CJ& cj=job.q[jobNumber];
    release(job.mutex);
    // Work until done
    while (true) {
      cj.full.wait();
      lock(job.mutex);
      // Check for end of input
      if (cj.method=="") {
        cj.compressed.signal();
        release(job.mutex);
        return 0;
      }
      // Compress
      assert(cj.state==CJ::FULL);
      cj.state=CJ::COMPRESSING;
      release(job.mutex);
      job.compressors.wait();
	  ///myprintf("00645: compressblock meth %s filena %s %s\n",cj.method.c_str(),cj.filename.c_str(),cj.comment.c_str());
	       libzpaq::compressBlock(&cj.in, &cj.out, cj.method.c_str(),
          cj.filename.c_str(), cj.comment=="" ? 0 : cj.comment.c_str());
      cj.in.resize(0);
      lock(job.mutex);
	///	myprintf("00646: Farei qualcosa <<%s>> %08X size %ld\n",myblock.filename.c_str(),myblock.crc32,myblock.crc32size);
	  cj.state=CJ::COMPRESSED;
      cj.compressed.signal();
      job.compressors.signal();
      release(job.mutex);
    }
  }
  catch (std::exception& e) {
    lock(job.mutex);
    fflush(stdout);
    myprintf("00647: job %d: %s\n", jobNumber+1, e.what());
	g_exec_text="job error";
    release(job.mutex);
    exit(1);
  }
  return 0;
}
// Write compressed data to the archive in the background
ThreadReturn writeThread(void* arg) {
	
  CompressJob& job=*(CompressJob*)arg;
  try {
    // work until done
    while (true) {
      // wait for something to write
      CJ& cj=job.q[job.front];  // no other threads move front
      cj.compressed.wait();
      // Quit if end of input
	  
      lock(job.mutex);
	  if (cj.method=="") {
        release(job.mutex);
        return 0;
      }
      // Write to archive
      assert(cj.state==CJ::COMPRESSED);
      cj.state=CJ::WRITING;
      job.csize.push_back(cj.out.size());
      if (job.out && cj.out.size()>0) {
        release(job.mutex);
        assert(cj.out.c_str());
        const char* p=cj.out.c_str();
        int64_t n=cj.out.size();
		g_scritti+=n; // very rude

		if (flagfast)
			if (cj.filename==g_thememfileblock)
			{
				if (g_thememfilestart==0)
					g_thememfilestart=job.out->tell();
				if (flagdebug3)
					myprintf("00648: $$$$$$$$$$$$$$$$$$$$$ %s %s len=%s\n",migliaia(g_thememfilestart),cj.filename.c_str(),migliaia2(g_thememfilelength));
			}

		const int64_t N=1<<30;
        while (n>N) {
          job.out->write(p, N);
          p+=N;
          n-=N;
        }
        job.out->write(p, n);
        lock(job.mutex);
      }
      cj.out.resize(0);
      cj.state=CJ::EMPTY;
      job.front=(job.front+1)%job.qsize;
      job.empty.signal();
      release(job.mutex);
    }
  }
  catch (std::exception& e) {
    fflush(stdout);
	///this is a very dirty trick to do NOT check for control-C inside the thread
    if (!g_control_c)
	{
		myprintf("00649: zpaqfranz exiting from writeThread: %s\n", e.what());
		g_exec_text="exiting from writethread";
		exit(1);
	}
	else
	{
		myprintf("\n*** WRITE THREAD GET A CONTROL-C !!!! ***\n");
	}
  }
  return 0;
}
// Write a ZPAQ compressed JIDAC block header. Output size should not
// depend on input data.
void writeJidacHeader(libzpaq::Writer *out, int64_t date,
                      int64_t cdata, unsigned htsize)
{
	if (!out) return;
	
	if (flagdebug3)
		myprintf("00650: start writejidacheader date %s  cdata %s  htsize %s\n",migliaia(date),migliaia2(cdata),migliaia3(htsize));
	
	/*
	if (g_fp_zpaq!=FPNULL)
		myprintf("00653: g_fp_zpaq %s\n",migliaia(ftello(g_fp_zpaq)));
	*/
	assert(date>=19000000000000LL && date<30000000000000LL);
	/*
	
	cdata=2;
	htsize=3;
	*/
	StringBuffer is;
	puti(is, cdata, 8);
	libzpaq::compressBlock(&is, out, "0",
      ("jDC"+itos(date, 14)+"c"+itos(htsize, 10)).c_str(), "jDC\x01");
	if (flagdebug3)
		myprintf("00651: ended writejidacheader\n");

}

// Maps sha1 -> fragment ID in ht with known size
class HTIndex {
  vector<HT>& htr;  // reference to ht
  libzpaq::Array<unsigned> t;  // sha1 prefix -> index into ht
  unsigned htsize;  // number of IDs in t
  // Compuate a hash index for sha1[20]
  unsigned hash(const char* sha1) {
    return (*(const unsigned*)sha1)&(t.size()-1);
  }
public:
  // r = ht, sz = estimated number of fragments needed
  HTIndex(vector<HT>& r, size_t sz): htr(r), t(0), htsize(1) {
    int b;
    for (b=1; sz*3>>b; ++b)
		;
	t.resize(1, b-1);
    update();
  }
  // Find sha1 in ht. Return its index or 0 if not found.
  unsigned find(const char* sha1) {
    unsigned h=hash(sha1);
    for (unsigned i=0; i<t.size(); ++i) {
      if (t[h^i]==0) return 0;
      if (memcmp(sha1, htr[t[h^i]].sha1, 20)==0) return t[h^i];
    }
    return 0;
  }
  // Update index of ht. Do not index if fragment size is unknown.
  void update() {
    const char zero[20]={0};
    while (htsize<htr.size()) {
      if (htsize>=t.size()/4*3) {
        t.resize(t.size(), 1);
        htsize=1;
      }
      if (htr[htsize].usize>=0 && memcmp(htr[htsize].sha1, zero, 20)!=0) {
        unsigned h=hash((const char*)htr[htsize].sha1);
        for (unsigned i=0; i<t.size(); ++i) {
          if (t[h^i]==0) {
            t[h^i]=htsize;
            break;
          }
        }
      }
      ++htsize;
    }
  }
};
// For writing to two archives at once
struct WriterPair: public libzpaq::Writer {
  OutputArchive *a, *b;
  void put(int c) {
    if (a) a->put(c);
    if (b) b->put(c);
  }
  void write(const char* buf, int n) {
    if (a) a->write(buf, n);
    if (b) b->write(buf, n);
  }
  WriterPair(): a(0), b(0) {}
};
void Jidac::write715attr(libzpaq::StringBuffer& i_sb, uint64_t i_data, unsigned int i_quanti)
{
///	assert(i_sb);
	assert(i_quanti<=8);
	puti(i_sb, i_quanti, 4);
	puti(i_sb, i_data, i_quanti);
}



#define REGTYPE  '0'    //Regular file 
#define AREGTYPE '\0'   // Regular file (alternative) 
#define LNKTYPE  '1'    // Hard link 
#define SYMTYPE  '2'    // Symbolic link 
#define CHRTYPE  '3'    // Character special 
#define DIRTYPE  '5'    // Directory
#define FIFOTYPE '6'    // FIFO special
#define CONTTYPE '7'    // Reserved 

// franz_posix structure - Total size: 360 bytes

struct franz_posix 
{
    char typeflag[8];      // File type (8)
    char uid[8];           // Numeric user ID (8) 
    char gid[8];           // Numeric group ID (8) 
    char uname[32];        // User name (32)
    char gname[32];        // Group name (32)
    char mode[8];          // Permessi file (8) 
    char mtime[16];        // Modification time (16)
    char ctime[16];        // Creation time (16)
    char atime[16];        // Access time (16)
    char linkname[216];    // Path of the symbolic link or hard link (216)
};

std::string decode_typeflag(char typeflag)
{
    switch (typeflag)
    {
        case REGTYPE:
        case AREGTYPE:
            return "Regular file";
        case LNKTYPE:
            return "Hard link";
        case SYMTYPE:
            return "Symbolic link";
        case CHRTYPE:
            return "Character special";
        case DIRTYPE:
            return "Directory";
        case FIFOTYPE:
            return "FIFO special";
        case CONTTYPE:
            return "Reserved";
        default:
            return "Unknown type";
    }
}

std::string decode_mode(const char* mode_str)
{
    // The mode value is an 8-character string (like "0755", "0644", etc.)
    int mode = std::strtol(mode_str, nullptr, 8);  // Convert the string to an integer (base 8)

    std::string permissions = "";

    // Decode permissions for the owner
    permissions += (mode & 0400) ? 'r' : '-';  // bit 8 for reading (r)
    permissions += (mode & 0200) ? 'w' : '-';  // bit 7 for writing (w)
    permissions += (mode & 0100) ? 'x' : '-';  // bit 6 for execution (x)

    // Decode permissions for the group
    permissions += (mode & 0040) ? 'r' : '-';  // bit 5 for reading (r)
    permissions += (mode & 0020) ? 'w' : '-';  // bit 4 for writing (w)
    permissions += (mode & 0010) ? 'x' : '-';  // bit 3 for execution (x)

    // Decode permissions for others
    permissions += (mode & 0004) ? 'r' : '-';  // bit 2 for reading (r)
    permissions += (mode & 0002) ? 'w' : '-';  // bit 1 for writing (w)
    permissions += (mode & 0001) ? 'x' : '-';  // bit 0 for execution (x)

    return permissions;
}

// Support function to convert a Unix timestamp (in seconds) to a readable date
std::string timestamp_to_human(const char* timestamp_str)
{
    long long timestamp = std::strtoll(timestamp_str, nullptr, 10);
    time_t t = static_cast<time_t>(timestamp);
    struct tm* tm_info = localtime(&t);

    int year = tm_info->tm_year + 1900;
    int month = tm_info->tm_mon + 1;
    int day = tm_info->tm_mday;
    int hour = tm_info->tm_hour;
    int minute = tm_info->tm_min;
    int second = tm_info->tm_sec;

    char buffer[128]; // Larger buffer
    snprintf(buffer, sizeof(buffer), "%04d-%02d-%02d %02d:%02d:%02d", 
             year, month, day, hour, minute, second);

    return std::string(buffer);
}

void dump_franz_posix(struct franz_posix* i_posix)
{
    if (i_posix == NULL) 
    {
        myprintf("64433! Posix structure is NULL\n");
        return;
    }

    // Robust handling of typeflag
    char typechar = i_posix->typeflag[0]; // First significant byte
    std::string type_desc = decode_typeflag(typechar); // Type description
    myprintf("64430: type:  '%c' (%.7s)  [%s] ", 
             (typechar >= 32 && typechar <= 126) ? typechar : '.', // Only printable characters
             i_posix->typeflag + 1, // I restanti 7 byte come stringa (se presenti)
             type_desc.c_str());
    
    // Hexadecimal print of all typeflag bytes for debugging
    myprintf("  typeflag bytes: ");
    for (unsigned int i = 0; i < 8; i++) 
        myprintf("%02x ", (unsigned char)i_posix->typeflag[i]);
    myprintf("\n");

    // Rest of the structure
    myprintf("64431: uid:   %.8s (%.32s) gid: %.8s (%.32s)\n", 
             i_posix->uid, i_posix->uname, i_posix->gid, i_posix->gname);
    myprintf("64432: mode:  %.8s     (%s)\n", 
             i_posix->mode, decode_mode(i_posix->mode).c_str());
    myprintf("64433: mtime: %.16s  (%s)\n", 
             i_posix->mtime, timestamp_to_human(i_posix->mtime).c_str());
    myprintf("64434: ctime: %.16s  (%s)\n", 
             i_posix->ctime, timestamp_to_human(i_posix->ctime).c_str());
    myprintf("64435: atime: %.16s  (%s)\n", 
             i_posix->atime, timestamp_to_human(i_posix->atime).c_str());
    
    if (i_posix->linkname[0] != '\0')
        myprintf("64436: link:  %.216s\n", i_posix->linkname);
}

#ifdef unix

int get_creation_time(const char* filepath, time_t* creation_time) 
{
    struct stat st;
    *creation_time = 0;

    if (lstat(filepath, &st) != 0) {
        if (flagverbose)
            fprintf(stderr, "Cannot get creation time for %s: %s\n", filepath, strerror(errno));
        return -1;
    }

#if defined(__APPLE__)
    *creation_time = st.st_birthtimespec.tv_sec;
#elif defined(__FreeBSD__)
    *creation_time = st.st_birthtime;
#else
    // OpenBSD e altri sistemi Unix-like usano st_ctime come fallback
    *creation_time = st.st_ctime;
#endif

    return 0;
}

/*
int get_creation_time(const char* filepath, time_t* creation_time) 
{
    *creation_time = 0;
#if defined(__APPLE__)
    struct stat st;
    if (lstat(filepath, &st) == 0) 
	{
        *creation_time = st.st_birthtimespec.tv_sec;
        return 0;
    }
#elif defined(__FreeBSD__) || defined(__OpenBSD__)
    struct stat st;
    if (lstat(filepath, &st) == 0) 
	{
        *creation_time = st.st_birthtime;
        return 0;
    }
#else
    struct stat st;
    if (lstat(filepath, &st) == 0) 
	{
        *creation_time = st.st_ctime;
        return 0;
    }
#endif
	if (flagverbose)
		myprintf("64382! Cannot get creation time for %s", filepath);
    return -1;
}
*/
int set_creation_time(const char* filepath, time_t creation_time) 
{
    if (creation_time == 0) return 0;
#if defined(__APPLE__)
    struct attrlist attrs = {0};
    struct timespec times[2];
    attrs.bitmapcount = ATTR_BIT_MAP_COUNT;
    attrs.commonattr = ATTR_CMN_CRTIME;
    times[0].tv_sec = creation_time;
    times[0].tv_nsec = 0;
    if (setattrlist(filepath, &attrs, times, sizeof(times), 0) == 0) return 0;
		myprintf("64397! Error in setattrlist for %s: %s", filepath, strerror(errno));
#else
	if (flagdebug3)
		myprintf("64399$ Cannot set creation date on this system %s\n",filepath);
#endif
    return -1;
}

int savefilemetadata(const char* filepath, struct franz_posix* metadata) 
{
#ifdef ANCIENT
	(void)filepath;
	(void)metadata;
#else
    struct stat fileInfo;
    if (flagdebug3)
        myprintf("64468: Saving metadata for <<%Z>>", filepath);
    
    if (lstat(filepath, &fileInfo) == -1) 
    {
        myprintf("64473!: Error in lstat for %s\n", filepath);
        return -1;
    }
    
    // Zero out the entire structure
    memset(metadata, 0, sizeof(struct franz_posix));
    
    // Explicitly zero the typeflag again to be safe
    memset(metadata->typeflag, 0, sizeof(metadata->typeflag));
    
    // Debug the typeflag array after zeroing
    if (flagdebug5)
        myprintf("Debug - After zeroing: typeflag bytes: %02x %02x %02x %02x %02x %02x %02x %02x\n", 
                 (unsigned char)metadata->typeflag[0], (unsigned char)metadata->typeflag[1],
                 (unsigned char)metadata->typeflag[2], (unsigned char)metadata->typeflag[3],
                 (unsigned char)metadata->typeflag[4], (unsigned char)metadata->typeflag[5],
                 (unsigned char)metadata->typeflag[6], (unsigned char)metadata->typeflag[7]);
    
    // Set only the first byte based on file type
    if (S_ISREG(fileInfo.st_mode)) 
    {
        if (fileInfo.st_nlink > 1) 
        {
            metadata->typeflag[0] = LNKTYPE;
            // For hard links, we save the path of the original file in linkname
            snprintf(metadata->linkname, sizeof(metadata->linkname), "%s", filepath);
        } 
        else 
            metadata->typeflag[0] = REGTYPE;
    } 
    else if (S_ISLNK(fileInfo.st_mode)) 
        metadata->typeflag[0] = SYMTYPE;
    else if (S_ISDIR(fileInfo.st_mode)) 
        metadata->typeflag[0] = DIRTYPE;
    else if (S_ISCHR(fileInfo.st_mode)) 
        metadata->typeflag[0] = CHRTYPE;
    else if (S_ISFIFO(fileInfo.st_mode)) 
        metadata->typeflag[0] = FIFOTYPE;
    else 
        metadata->typeflag[0] = CONTTYPE;
    
    // Debug the typeflag array after setting the file type
    if (flagdebug5)
        myprintf("Debug - After setting type: typeflag bytes: %02x %02x %02x %02x %02x %02x %02x %02x\n", 
                 (unsigned char)metadata->typeflag[0], (unsigned char)metadata->typeflag[1],
                 (unsigned char)metadata->typeflag[2], (unsigned char)metadata->typeflag[3],
                 (unsigned char)metadata->typeflag[4], (unsigned char)metadata->typeflag[5],
                 (unsigned char)metadata->typeflag[6], (unsigned char)metadata->typeflag[7]);
    
    // Rest of your function remains the same
    snprintf(metadata->uid, sizeof(metadata->uid), "%07u", fileInfo.st_uid);
    snprintf(metadata->gid, sizeof(metadata->gid), "%07u", fileInfo.st_gid);
    struct passwd* pw = getpwuid(fileInfo.st_uid);
    if (pw) 
    {
        strncpy(metadata->uname, pw->pw_name, sizeof(metadata->uname) - 1);
        metadata->uname[sizeof(metadata->uname) - 1] = '\0';
    } 
    else 
        strncpy(metadata->uname, "unknown", sizeof(metadata->uname));
    
    struct group* gr = getgrgid(fileInfo.st_gid);
    if (gr) 
    {
        strncpy(metadata->gname, gr->gr_name, sizeof(metadata->gname) - 1);
        metadata->gname[sizeof(metadata->gname) - 1] = '\0';
    } 
    else
        strncpy(metadata->gname, "unknown", sizeof(metadata->gname));
    
    snprintf(metadata->mode, sizeof(metadata->mode), "%07o", fileInfo.st_mode & 07777);
    snprintf(metadata->mtime, sizeof(metadata->mtime), "%lld", (long long)fileInfo.st_mtime);
    snprintf(metadata->atime, sizeof(metadata->atime), "%lld", (long long)fileInfo.st_atime);
    time_t creation_time = 0;
    get_creation_time(filepath, &creation_time);
    snprintf(metadata->ctime, sizeof(metadata->ctime), "%lld", (long long)creation_time);
    
    if (S_ISLNK(fileInfo.st_mode)) 
    {
        ssize_t len = readlink(filepath, metadata->linkname, sizeof(metadata->linkname) - 1);
        if (len == -1) 
        {
            myprintf("64541$ Errore in readlink %s\n", filepath);
            return -1;
        }
        if ((size_t)len >= sizeof(metadata->linkname) - 1) 
        {
            myprintf("64646: Simlink truncated to %d byte for %s", sizeof(metadata->linkname) - 1, filepath);
            len = sizeof(metadata->linkname) - 1;
        }
        metadata->linkname[len] = '\0';
    } 
    else if (metadata->typeflag[0] != LNKTYPE) 
        metadata->linkname[0] = '\0';
    
    // Debug the typeflag array at the end of the function
    if (flagdebug5)
        myprintf("Debug - Before return: typeflag bytes: %02x %02x %02x %02x %02x %02x %02x %02x\n", 
                 (unsigned char)metadata->typeflag[0], (unsigned char)metadata->typeflag[1],
                 (unsigned char)metadata->typeflag[2], (unsigned char)metadata->typeflag[3],
                 (unsigned char)metadata->typeflag[4], (unsigned char)metadata->typeflag[5],
                 (unsigned char)metadata->typeflag[6], (unsigned char)metadata->typeflag[7]);
    
    if (flagdebug5)
        myprintf("64546: Metadati saved: type=%s, uid=%s, gid=%s, mode=%s, linkname=%s uname=%s gname=%s\n",
                 metadata->typeflag, metadata->uid, metadata->gid, metadata->mode, 
                 metadata->linkname, metadata->uname, metadata->gname);
    
    // Make sure we re-zero any unused bytes in typeflag before returning
    for (unsigned int i = 1; i < sizeof(metadata->typeflag); i++) {
        metadata->typeflag[i] = '\0';
    }
#endif
    return 0;
}
#ifndef ANCIENT
static int validate_metadata(const struct franz_posix* metadata) 
{
	if (metadata==NULL)
		return -1;
	
    if (!strchr("0123567", metadata->typeflag[0]) && metadata->typeflag[0] != AREGTYPE) 
	{
        myprintf("64653: Typeflag non valid: %s", metadata->typeflag);
        return -1;
    }

    for (int unsigned i = 0; i < sizeof(metadata->uid) - 1 && metadata->uid[i]; i++) 
        if (!isdigit((unsigned char)metadata->uid[i])) 
		{
            myprintf("64661: UID not valid: %s", metadata->uid);
            return -1;
        }
    
    for (int unsigned i = 0; i < sizeof(metadata->gid) - 1 && metadata->gid[i]; i++) 
        if (!isdigit((unsigned char)metadata->gid[i])) 
		{
            myprintf("64669: GID not valid: %s", metadata->gid);
            return -1;
        }

    for (int unsigned i = 0; i < sizeof(metadata->mode) - 1 && metadata->mode[i]; i++) 
        if (!isdigit((unsigned char)metadata->mode[i]) || metadata->mode[i] > '7') 
		{
            myprintf("64689: Mode not valid: %s", metadata->mode);
            return -1;
        }

    for (int unsigned i = 0; i < sizeof(metadata->mtime) - 1 && metadata->mtime[i]; i++) 
        if (!isdigit((unsigned char)metadata->mtime[i]) && metadata->mtime[i] != '-') 
		{
            myprintf("mtime non valido: %s", metadata->mtime);
            return -1;
        }
		
    for (int unsigned i = 0; i < sizeof(metadata->atime) - 1 && metadata->atime[i]; i++) 
	    if (!isdigit((unsigned char)metadata->atime[i]) && metadata->atime[i] != '-') 
		{
            myprintf("atime non valido: %s", metadata->atime);
            return -1;
        }
 
    for (int unsigned i = 0; i < sizeof(metadata->ctime) - 1 && metadata->ctime[i]; i++) 
	    if (!isdigit((unsigned char)metadata->ctime[i]) && metadata->ctime[i] != '-') 
		{
            myprintf("ctime non valido: %s", metadata->ctime);
            return -1;
        }


    if ((metadata->typeflag[0] == SYMTYPE || metadata->typeflag[0] == LNKTYPE) && metadata->linkname[0] == '\0') 
	{
        myprintf("linkname vuoto per tipo %s", metadata->typeflag);
        return -1;
    }

    return 0;
}
#endif
int restorefilemetadata(const char* filepath, const struct franz_posix* metadata) 
{
#ifdef ANCIENT
	(void)filepath;
	(void)metadata;
#else
	if (filepath==NULL)
		return -1;
	if (metadata==NULL)
		return -1;
	if (flagverbose)
		myprintf("64718: Restoring metadata for %s\n", filepath);

    if (validate_metadata(metadata) != 0) 
	{
		myprintf("64722: Errorinvalid metadata!\n");
		return -1;
    }

    uid_t uid = (uid_t) atoi(metadata->uid);
    gid_t gid = (gid_t) atoi(metadata->gid);
    mode_t mode = (mode_t) strtol(metadata->mode, NULL, 8);
    time_t mtime = (time_t) atol(metadata->mtime);
    time_t atime = (time_t) atol(metadata->atime);
    time_t ctime = (time_t) atol(metadata->ctime);

	
    if (metadata->typeflag[0] == LNKTYPE) 
	{
/*
        struct stat st;
        if (lstat(filepath, &st) == 0) 
		{
            if (unlink(filepath) == -1) 
			{
                myprintf("64740$ Error removing %s: %s\n", filepath, strerror(errno));
                return -1;
            }
        }
        if (link(metadata->linkname, filepath) == -1) 
		{
			myprintf("64746! Cannot create hard link %s -> %s: %s\n",filepath, metadata->linkname, strerror(errno));
            return -1;
        }
*/
		myprintf("64746$ Written a copy of the file instead of hard link %s -> %s\n",filepath, metadata->linkname);
		
        if (chown(filepath, uid, gid) == -1) 
		    myprintf("64750$ Error in chown %s: %s", filepath, strerror(errno));
        return 0;
    }
	

    if (metadata->typeflag[0] == SYMTYPE) 
	{
        struct stat st;
        if (lstat(filepath, &st) == 0 && !S_ISDIR(st.st_mode)) 
		{
            if (unlink(filepath) == -1) 
			{
                myprintf("64741: Error removing %s: %s\n", filepath, strerror(errno));
                return -1;
            }
        }
        if (symlink(metadata->linkname, filepath) == -1 && errno != EEXIST) 
		{
            myprintf("64767: Error symlink %s: %s\n", filepath, strerror(errno));
            return -1;
        }
#if defined(__linux__) || defined(__FreeBSD__) || defined(__OpenBSD__)
        if (lchown(filepath, uid, gid) == -1) 
		    myprintf("64772: Error lchown %s: %s", filepath, strerror(errno));
        
#endif
        return 0;
    }

    if (metadata->typeflag[0] == CHRTYPE && geteuid() == 0) 
	{
        if (access(filepath, F_OK) == 0) 
		{
            if (unlink(filepath) == -1) 
			{
                myprintf("648794: Error unlink %s: %s\n", filepath, strerror(errno));
                return -1;
            }
        }
        if (mknod(filepath, mode | S_IFCHR, 0) == -1) 
		{
            myprintf("64790: Error creating mkdnod  %s: %s\n", filepath, strerror(errno));
            return -1;
        }
    }

    if (chmod(filepath, mode) == -1) 
	{
        myprintf("64797: Error chmod  %s: %s\n", filepath, strerror(errno));
        return -1;
    }

    if (chown(filepath, uid, gid) == -1) 
	{
        myprintf("64803: Error chown %s: %s\n", filepath, strerror(errno));
        return -1;
    }

#if defined(__APPLE__) || defined(__FreeBSD__) || defined(__OpenBSD__)
    struct timeval times[2];
    times[0].tv_sec = atime;
    times[0].tv_usec = 0;
    times[1].tv_sec = mtime;
    times[1].tv_usec = 0;
    if (utimes(filepath, times) == -1) 
	{
        myprintf("64815: Error utimes %s: %s\n", filepath, strerror(errno));
        return -1;
    }
#else
    struct utimbuf times;
    times.actime = atime;
    times.modtime = mtime;
    if (utime(filepath, &times) == -1) 
	{
        myprintf("64824: Error utime %s: %s\n", filepath, strerror(errno));
        return -1;
    }
#endif

    set_creation_time(filepath, ctime);
	if (flagverbose)
		myprintf("64831: Metadata restored for %s\n", filepath);
#endif
    return 0;
}
#endif


void dump_mem(char* i_buffer,int i_franzsize)
{
	printbar('*');
	for (int i=0;i<i_franzsize;i++)
		if (isprint(i_buffer[i]))
			myprintf("offset %03d valore %03u %02X car %c\n",i,i_buffer[i],i_buffer[i]&255,i_buffer[i]);
		else
			myprintf("offset %03d valore %03u %02X\n",i,i_buffer[i]&255,i_buffer[i]&255);
	printbar('*');
}

void dump_franzattr(string i_thehash,int32_t i_writtencrc,char* i_buffer,int i_franzsize,int64_t i_creationdate,bool i_isadded)
{
	myprintf("00652: g_franzotype |%s|\n",migliaia(g_franzotype));
	myprintf("00653: franzsize    |%s|\n",migliaia(i_franzsize));
	myprintf("00654: hash         |%s|\n",i_thehash.c_str());
	myprintf("00655: crc32        |%08X|\n",i_writtencrc);
	myprintf("00656: creationdate |%s|\n",bin2hex_64(i_creationdate).c_str());
	myprintf("00657: isadded      |%d|\n",(int)i_isadded);
	
	for (int i=0;i<i_franzsize;i++)
		if (isprint(i_buffer[i]))
			myprintf("offset %03d valore %03u %02X car %c\n",i,i_buffer[i],i_buffer[i]&255,i_buffer[i]);
		else
			myprintf("offset %03d valore %03u %02X\n",i,i_buffer[i]&255,i_buffer[i]&255);
	seppuku();
}


void Jidac::writefranzattr(DTMap::iterator i_dtmap,libzpaq::StringBuffer& i_sb, uint64_t i_data, unsigned int i_quanti,string i_filename,uint32_t i_crc32fromfragments,uint32_t i_crc32,string i_thehash,int64_t i_creationdate,int64_t i_accessdate,const struct franz_posix* i_posix,bool i_isadded)
{
///	assert(i_sb);
	assert(i_filename.length()>0); 	// I do not like empty()
	assert(i_quanti<8);				//just to be sure at least 1 zero pad, so < and not <=
	assert(i_filename!="");
	uint32_t writtencrc;
	if (flagverify)
		writtencrc=i_crc32fromfragments;
	else
		writtencrc=i_crc32;
#ifdef _WIN32
	if (i_posix)
		myprintf("be quiet\n");
#endif
	i_dtmap->second.hexcrc32=bin2hex_32(writtencrc);
	if (g_franzotype==FRANZO_NONE) /*|| (i_thehash=="")*/	// 7.15
	{
		if (flagdebug3)
			myprintf("00658: old-style attr with hash |%s|\n",i_thehash.c_str());
		write715attr(i_sb,i_data,i_quanti);
		return;
	}
	
	if (flagverify || flagcollision)
		if (i_crc32!=i_crc32fromfragments)
		{
			myprintf("\n");
			myprintf("00659: GURU-C: on file %s\n",i_filename.c_str());
			myprintf("00660: GURU: CRC-32 from fragments %08X\n",i_crc32fromfragments);
			myprintf("00661: GURU: CRC-32 from file      %08X\n",i_crc32);
//			if (!flagdebug)
	///			error("Guru-C checking crc32");
		}
	if (g_franzotype==FRANZO_CRC_32) /// store only CRC-32
	{
		char mybuffer[FRANZOFFSETV1]={0};
		snprintf(mybuffer+41,sizeof(mybuffer)-41,"%08X",writtencrc);
		puti(i_sb, 8+FRANZOFFSETV1, 4); 	// 8+FRANZOFFSETV1 block
		puti(i_sb, i_data, i_quanti);
		puti(i_sb, 0, (8 - i_quanti));  // pad with zeros (for 7.15 little bug)
		i_sb.write(mybuffer,FRANZOFFSETV1);
		if (flagdebug3)
			myprintf("00662: Mode1: CRC32 by frag <<%s>> %s\n",mybuffer+41,i_filename.c_str());
	}
	else
#ifdef unix
	if (flagtar) ///1= 52 (01-MD5-0-CRC32)
	{
		if (flagdebug3)
			myprintf("64952: flagtar on\n");
		/// [0][1] +   0      2bytes long FRANZO_CODE
		///        +   2    128 bytes hash
		///        +2+128+1   8 bytes CRC32
		///                   8 bytes creationdate (binary)
		///                   8 bytes accessdate   (binary)

		char mybuffer[FRANZOFFSETV3]={0};

		if (flagdebug3)
		{
			myprintf("\n");
			myprintf("00672: thehash    %s\n",i_thehash.c_str());
			myprintf("00673: writtencrc %08X\n",writtencrc);
		}

		string mycode;
		if (flagtar)
			mycode=std::string()+"4"+char(g_franzotype+'A');
		else
			mycode=std::string()+"3"+char(g_franzotype+'A');
		if (flagdebug3)
			myprintf("00674: MYCODE |%s|\n",mycode.c_str());
		if (mycode.size()!=2)
		{
			myprintf("00675: GURU mycode must be 2 chars!\n");
			seppuku();
			return;
		}

		int offsetcrc	=0;
		int offset		=0;
		snprintf(mybuffer+offset,sizeof(mybuffer)-offset,"%s",mycode.c_str()); //two bytes
		offset+=mycode.size();
		if (flagdebug3)
			myprintf("00676: Offset1 (after mycode) %3d\n",offset);

		snprintf(mybuffer+offset,sizeof(mybuffer)-offset,"%s",i_thehash.c_str());
		offset+=i_thehash.size()+2;
		if (flagdebug3)
			myprintf("00677: Offset2 (after hash)   %3d\n",offset);

		offsetcrc=offset;
		snprintf(mybuffer+offset,sizeof(mybuffer)-offset,"%08X",writtencrc);
		offset+=8+2;

		if (flagdebug3)
			myprintf("00678: Offset3 (after CRC)    %3d\n",offset);

		uint32_t  orderedstream=0;
		if (flagstdin)
			orderedstream=1;
		offset+=inttoarray(orderedstream	,mybuffer+offset,4);

		if (flagdebug3)
			myprintf("00679: Offset4 (after ordered)%3d\n",offset);

		// catch "holes" into multipart
		uint32_t	versionnumber=1440408;
		offset+=inttoarray(versionnumber	,mybuffer+offset,4);
		if (flagdebug3)
		myprintf("00680: Offset5 (after version)%3d\n",offset);

		///i_creationdate=987654321L;
		///i_accessdate=554433229944L;

		offset+=inttoarray(i_creationdate	,mybuffer+offset,8);

		if (flagdebug3)
			myprintf("00681: Offset6 (after cdate)  %3d\n",offset);

		offset+=inttoarray(i_accessdate		,mybuffer+offset,8);

		if (flagdebug3)
			myprintf("00682: Offset6 (after adate)  %3d\n",offset);


		uint64_t azero=0;
		for (int i=0;i<3;i++)
			offset+=inttoarray(azero		,mybuffer+offset,8);

		if (flagdebug3)
			myprintf("00683: Offset7 (after spare)  %3d\n",offset);

		int		dascrivere=offset;

		if (i_posix!=NULL)
		{
			if (flagdebug5)
			{
				color_yellow();
				myprintf("00684: flagtar and posix not null, use all FRANZOFFSETV3 at offset %d\n",offset);
				color_restore();
			}
			memcpy(mybuffer+offset,i_posix, sizeof(struct franz_posix));
			dascrivere=FRANZOFFSETV3;
		}
		if (flagdebug3)
			myprintf("00685: To write %08d   header %08d + sizeof %08d\n",dascrivere,offset,sizeof(franz_posix));
		if (dascrivere>FRANZOFFSETV3)
		{
			myprintf("00686: GURU dascrivere %08d > FRANZOFFSETV3 %08d\n",dascrivere,FRANZOFFSETV3);
			seppuku();
			return;
		}
		puti(i_sb, 8+dascrivere, 4); 	// 8+FRANZOFFSETV1 block
		puti(i_sb, i_data, i_quanti);
		puti(i_sb, 0, (8 - i_quanti));  // pad with zeros (for 7.15 little bug)
		i_sb.write(mybuffer,dascrivere); ///please note the dirty trick: start by +8
		if (flagdebug3)
			myprintf("00687: Mode |%s| %s <<%s>> CRC32 <<%s>> %s\n",mycode.c_str(),decodefranzoffset(g_franzotype).c_str(),mybuffer+2,mybuffer+offsetcrc,i_filename.c_str());

	}
	else
#endif
	if ((g_franzotype==FRANZO_XXHASH64B) || (g_franzotype==FRANZO_MD5B) ||(g_franzotype==FRANZO_BLAKE3B)||(g_franzotype==FRANZO_SHA_256B)
		||(g_franzotype==FRANZO_SHA3B)||(g_franzotype==FRANZO_XXH3B)||(g_franzotype==FRANZO_SHA_1B))
		
	{
				
		char mybuffer[FRANZOFFSETV1]={0};
		int	primobyte	=g_franzotype/10+'0';
		int secondobyte	=g_franzotype%10+'0';
		///myprintf("00663: primo %d secondo %d\n",primobyte,secondobyte);
		
		mybuffer[0]=primobyte;
		mybuffer[1]=secondobyte;
		/*
		if (primobyte==mybuffer[0])
			myprintf("00664: uguale\n");
		else
			myprintf("00665: diverso\n");
		seppuku();
		*/
		mybuffer[49]=1; // backward compatibility, not zero
		
		//myprintf("$$$$$$$$$$$$$$ |%s| g_franzotypelen %d\n",i_thehash.c_str(),g_franzotypelen);
		hex2binary(i_thehash,		mybuffer+2,g_franzotypelen/2);
		inttoarray(writtencrc,		mybuffer+34,4);
		inttoarray(i_creationdate,	mybuffer+38,8);
		
		mybuffer[47]=i_isadded;
		
		puti(i_sb, 8+FRANZOFFSETV1, 4);
		puti(i_sb, i_data, i_quanti);
		puti(i_sb, 0, (8 - i_quanti));  // pad with zeros (for 7.15 little bug)
		i_sb.write(mybuffer,FRANZOFFSETV1);
		/// please note the dirty trick: start by +10
		
///		dump_franzattr(i_thehash,writtencrc,mybuffer,FRANZOFFSETV1,i_creationdate,i_isadded);

		if (flagdebug3)
			myprintf("00666: Mode14:  BINARY: <<%s>> CRC32 <<%08X>> %s\n",i_thehash.c_str(),writtencrc,i_filename.c_str());
	
	}
	else
	if (g_franzotype==FRANZO_XXHASH64)
	{
		assert(i_thehash.length()==32);
		char mybuffer[FRANZOFFSETV1]={0};
		snprintf(mybuffer+8,sizeof(mybuffer)-8,	"%s",i_thehash.c_str());
		snprintf(mybuffer+41,sizeof(mybuffer)-41,"%08X",writtencrc);
		puti(i_sb, 8+FRANZOFFSETV1, 4);
		puti(i_sb, i_data, i_quanti);
		puti(i_sb, 0, (8 - i_quanti));  // pad with zeros (for 7.15 little bug)
		i_sb.write(mybuffer,FRANZOFFSETV1);
		/// please note the dirty trick: start by +10
			
		if (flagdebug3)
			myprintf("00667: Mode2:  XXHASH64: <<%s>> CRC32 <<%s>> %s\n",mybuffer+8,mybuffer+41,i_filename.c_str());
	}
	else
	if (g_franzotype==FRANZO_SHA_1)  //3= 51 (SHA1-0-CRC32)
	{
		char mybuffer[FRANZOFFSETV2]={0};
		snprintf(mybuffer,sizeof(mybuffer),	"08"); //<<< look at this
		snprintf(mybuffer+2,sizeof(mybuffer)-2,	"%s",i_thehash.c_str());
		snprintf(mybuffer+2+64+1,sizeof(mybuffer)-2-64-1,"%08X",writtencrc);
		puti(i_sb, 8+FRANZOFFSETV2, 4); 	// 8+FRANZOFFSETV1 block
		puti(i_sb, i_data, i_quanti);
		puti(i_sb, 0, (8 - i_quanti));  // pad with zeros (for 7.15 little bug)
		i_sb.write(mybuffer,FRANZOFFSETV2); ///please note the dirty trick: start by +8
		if (flagdebug3)
			myprintf("00668: Model8: SHA1 <<%s>> CRC32 <<%s>> %s\n",mybuffer+2,mybuffer+67,i_filename.c_str());
	}
	else
	if (g_franzotype==FRANZO_SHA_256) ///4= 52 (01-SHA256-0-CRC32)
	{
		assert(i_thehash.length()==64);
		char mybuffer[FRANZOFFSETV2]={0};
		snprintf(mybuffer,sizeof(mybuffer),	"04"); //<<< look at this
		snprintf(mybuffer+2,sizeof(mybuffer)-2,	"%s",i_thehash.c_str());
		snprintf(mybuffer+2+64+1,sizeof(mybuffer)-2-64-1,"%08X",writtencrc);
		puti(i_sb, 8+FRANZOFFSETV2, 4); 	// 8+FRANZOFFSETV1 block
		puti(i_sb, i_data, i_quanti);
		puti(i_sb, 0, (8 - i_quanti));  // pad with zeros (for 7.15 little bug)
		i_sb.write(mybuffer,FRANZOFFSETV2);
		/// please note the dirty trick: start by +8
		if (flagdebug3)
			myprintf("00669: Mode4: SHA256 <<%s>> CRC32 <<%s>> %s\n",mybuffer+2,mybuffer+67,i_filename.c_str());
	}
	else
	if (g_franzotype==FRANZO_SHA3) ///2= 52 (01-SHA3-0-CRC32)
	{
		assert(i_thehash.length()==64);
		char mybuffer[FRANZOFFSETV2]={0};
		snprintf(mybuffer,sizeof(mybuffer),	"02"); //<<< look at this
		snprintf(mybuffer+2,sizeof(mybuffer)-2,	"%s",i_thehash.c_str());
		snprintf(mybuffer+2+64+1,sizeof(mybuffer)-2-64-1,"%08X",writtencrc);
		puti(i_sb, 8+FRANZOFFSETV2, 4); 	// 8+FRANZOFFSETV1 block
		puti(i_sb, i_data, i_quanti);
		puti(i_sb, 0, (8 - i_quanti));  // pad with zeros (for 7.15 little bug)
		i_sb.write(mybuffer,FRANZOFFSETV2); ///please note the dirty trick: start by +8
		if (flagdebug3)
			myprintf("00670: Mode7: SHA3 <<%s>> CRC32 <<%s>> %s\n",mybuffer+2,mybuffer+67,i_filename.c_str());
	}
	else
	if (g_franzotype==FRANZO_MD5) ///1= 52 (01-MD5-0-CRC32)
	{
		assert(i_thehash.length()==32);
		char mybuffer[FRANZOFFSETV2]={0};
		snprintf(mybuffer,sizeof(mybuffer),	"01"); //<<< look at this
		snprintf(mybuffer+2,sizeof(mybuffer)-2,	"%s",i_thehash.c_str());
		snprintf(mybuffer+2+64+1,sizeof(mybuffer)-2-64-1,"%08X",writtencrc);
		puti(i_sb, 8+FRANZOFFSETV2, 4); 	// 8+FRANZOFFSETV1 block
		puti(i_sb, i_data, i_quanti);
		puti(i_sb, 0, (8 - i_quanti));  // pad with zeros (for 7.15 little bug)
		i_sb.write(mybuffer,FRANZOFFSETV2); ///please note the dirty trick: start by +8
		if (flagdebug3)
			myprintf("00671: Mode8: MD5 <<%s>> CRC32 <<%s>> %s\n",mybuffer+2,mybuffer+67,i_filename.c_str());
	}
	else
	if (g_franzotype==FRANZO_WINHASH64) ///10= 52 (10-XXHASH64-0-CRC32-0-creationwrite)
	{
		/// lpCreationTime, lpLastAccessTime,
		/// 2  byte  10
		///  bit
		///	 	0-1 	10   type
		/// 	2-66
		///		66-67	0x0
		///		68-72	CRC32 ASCII
		///		73		0x
		///printf("FRANZO WINNNNNNNNNN ENCODE\n");
/*
		i_creationdate=0xAABBCCDDEECF;
		i_accessdate=0xBBCCDDEEAB;
*/
		assert(i_thehash.length()==32);
		char mybuffer[FRANZOFFSETV2]={0};
		snprintf(mybuffer,sizeof(mybuffer),	"10"); //<<< look at this
		snprintf(mybuffer+2,sizeof(mybuffer)-2,	"%s",i_thehash.c_str());
		inttoarray(i_creationdate	,mybuffer+2+31+1,8);
		inttoarray(i_accessdate		,mybuffer+2+31+1+8,8);
		snprintf(mybuffer+2+64+1,sizeof(mybuffer)-2-64-1,"%08X",writtencrc);
		puti(i_sb, 8+FRANZOFFSETV2, 4); 	// 8+FRANZOFFSETV1 block
		puti(i_sb, i_data, i_quanti);
		puti(i_sb, 0, (8 - i_quanti));  // pad with zeros (for 7.15 little bug)
		i_sb.write(mybuffer,FRANZOFFSETV2); ///please note the dirty trick: start by +8
		if (flagdebug3)
			myprintf("00688: Mode10: WINHASH64 <<%s>> CRC32 <<%s>> %s\n",mybuffer+2,mybuffer+67,i_filename.c_str());
	}
	else
	if (g_franzotype==FRANZO_BLAKE3) ///3= 52 (01-BLAKE3-0-CRC32)
	{
		assert(i_thehash.length()==64);
		char mybuffer[FRANZOFFSETV2]={0};
		snprintf(mybuffer,sizeof(mybuffer),	"03"); //<<< look at this
		snprintf(mybuffer+2,sizeof(mybuffer)-2,	"%s",i_thehash.c_str());
		snprintf(mybuffer+2+64+1,sizeof(mybuffer)-2-64-1,"%08X",writtencrc);
		puti(i_sb, 8+FRANZOFFSETV2, 4); 	// 8+FRANZOFFSETV1 block
		puti(i_sb, i_data, i_quanti);
		puti(i_sb, 0, (8 - i_quanti));  // pad with zeros (for 7.15 little bug)
		i_sb.write(mybuffer,FRANZOFFSETV2); ///please note the dirty trick: start by +8
		if (flagdebug)
			myprintf("00689: Mode6: BLAKE3 <<%s>> CRC32 <<%s>> %s\n",mybuffer+2,mybuffer+67,i_filename.c_str());
	}
	else
	if (g_franzotype==FRANZO_XXH3) ///5= 52 (00XXH3-0-CRC32)
	{
		assert(i_thehash.length()==32);
		char mybuffer[FRANZOFFSETV2]={0};
		snprintf(mybuffer,sizeof(mybuffer),	"09"); //<<< look at this
		snprintf(mybuffer+2,sizeof(mybuffer)-2,	"%s",i_thehash.c_str());
		snprintf(mybuffer+2+64+1,sizeof(mybuffer)-2-64-1,"%08X",writtencrc);
		puti(i_sb, 8+FRANZOFFSETV2, 4); 	// 8+FRANZOFFSETV1 block
		puti(i_sb, i_data, i_quanti);
		puti(i_sb, 0, (8 - i_quanti));  // pad with zeros (for 7.15 little bug)
		i_sb.write(mybuffer,FRANZOFFSETV2); ///please note the dirty trick: start by +8
		/// please note the dirty trick: start by +8
		if (flagdebug)
			myprintf("00690: Mode5: XXH3: <<%s>> CRC32 <<%s>> %s\n",mybuffer+2,mybuffer+67,i_filename.c_str());
	}
	else
	if ((g_franzotype==FRANZO_WHIRLPOOL) || (g_franzotype==FRANZO_HIGHWAY64) || (g_franzotype==FRANZO_HIGHWAY128) || (g_franzotype==FRANZO_HIGHWAY256)) ///1= 52 (01-MD5-0-CRC32)
	{
		char mybuffer[FRANZOFFSETV3]={0};

		if (flagdebug3)
		{
			myprintf("\n");
			myprintf("20672: thehash    %s\n",i_thehash.c_str());
			myprintf("20673: writtencrc %08X\n",writtencrc);
		}

		string mycode;
		if (flagtar)
			mycode=std::string()+"4"+char(g_franzotype+'A');
		else
			mycode=std::string()+"3"+char(g_franzotype+'A');
		if (flagdebug3)
			myprintf("00674: MYCODE |%s|\n",mycode.c_str());
		if (mycode.size()!=2)
		{
			myprintf("20675: GURU mycode must be 2 chars!\n");
			seppuku();
			return;
		}

		int offsetcrc	=0;
		int offset		=0;
		snprintf(mybuffer+offset,sizeof(mybuffer)-offset,"%s",mycode.c_str()); //two bytes
		offset+=mycode.size();
		if (flagdebug3)
			myprintf("20676: Offset1 (after mycode) %3d\n",offset);

		snprintf(mybuffer+offset,sizeof(mybuffer)-offset,"%s",i_thehash.c_str());
		offset+=i_thehash.size()+2;
		if (flagdebug3)
			myprintf("20677: Offset2 (after hash)   %3d\n",offset);

		offsetcrc=offset;
		snprintf(mybuffer+offset,sizeof(mybuffer)-offset,"%08X",writtencrc);
		offset+=8+2;

		if (flagdebug3)
			myprintf("20678: Offset3 (after CRC)    %3d\n",offset);

		uint32_t  orderedstream=0;
		if (flagstdin)
			orderedstream=1;
		offset+=inttoarray(orderedstream	,mybuffer+offset,4);

		if (flagdebug3)
			myprintf("20679: Offset4 (after ordered)%3d\n",offset);

		// catch "holes" into multipart
		uint32_t	versionnumber=1440408;
		offset+=inttoarray(versionnumber	,mybuffer+offset,4);
		if (flagdebug3)
		myprintf("20680: Offset5 (after version)%3d\n",offset);

		///i_creationdate=987654321L;
		///i_accessdate=554433229944L;

		offset+=inttoarray(i_creationdate	,mybuffer+offset,8);

		if (flagdebug3)
			myprintf("20681: Offset6 (after cdate)  %3d\n",offset);

		offset+=inttoarray(i_accessdate		,mybuffer+offset,8);

		if (flagdebug3)
			myprintf("20682: Offset6 (after adate)  %3d\n",offset);


		uint64_t azero=0;
		for (int i=0;i<3;i++)
			offset+=inttoarray(azero		,mybuffer+offset,8);

		if (flagdebug3)
			myprintf("20683: Offset7 (after spare)  %3d\n",offset);

		int		dascrivere=offset;
		if (flagdebug3)
			myprintf("20685: To write %08d   header %08d + sizeof %08d\n",dascrivere,offset,sizeof(franz_posix));
		if (dascrivere>FRANZOFFSETV3)
		{
			myprintf("20686: GURU dascrivere %08d > FRANZOFFSETV3 %08d\n",dascrivere,FRANZOFFSETV3);
			seppuku();
			return;
		}
		puti(i_sb, 8+dascrivere, 4); 	// 8+FRANZOFFSETV1 block
		puti(i_sb, i_data, i_quanti);
		puti(i_sb, 0, (8 - i_quanti));  // pad with zeros (for 7.15 little bug)
		i_sb.write(mybuffer,dascrivere); ///please note the dirty trick: start by +8
		if (flagdebug3)
			myprintf("20687: Mode |%s| %s <<%s>> CRC32 <<%s>> %s\n",mycode.c_str(),decodefranzoffset(g_franzotype).c_str(),mybuffer+2,mybuffer+offsetcrc,i_filename.c_str());
	}
	else
		perror("22144: unknown franzotype");
}

// An extract job is a set of blocks with at least one file pointing to them.
// Blocks are extracted in separate threads, set READY -> WORKING.
// A block is extracted to memory up to the last fragment that has a file
// pointing to it. Then the checksums are verified. Then for each file
// pointing to the block, each of the fragments that it points to within
// the block are written in order.
struct ExtractJob {         // list of jobs
	int	chunk;
  Mutex mutex;              // protects state
  Mutex write_mutex;        // protects writing to disk
  int job;                  // number of jobs started
  Jidac& jd;                // what to extract
  FP outf;                  // currently open output file
  DTMap::iterator lastdt;   // currently open output file name
  double maxMemory;         // largest memory used by any block (test mode)
  int64_t total_size;       // bytes to extract
  int64_t total_done;       // bytes extracted so far
  uint64_t last_write;		// last fseek
  ExtractJob(Jidac& j): chunk(0),job(0), jd(j), outf(FPNULL), lastdt(j.dt.end()),
      maxMemory(0), total_size(0), total_done(0),last_write(0) {
    init_mutex(mutex);
    init_mutex(write_mutex);
  }
  ~ExtractJob() {
    destroy_mutex(mutex);
    destroy_mutex(write_mutex);
  }
};


static int64_t g_last_progress_time = 0;

// Decompress blocks in a job until none are READY
ThreadReturn decompressThread(void* arg) {
  ExtractJob& job=*(ExtractJob*)arg;
  int jobNumber=0;
	char	byte0={0};
  // Get job number
  lock(job.mutex);
  jobNumber=++job.job;
  release(job.mutex);
  ///myprintf("00691: K1 %s\n",job.jd.archive.c_str());
  // Open archive for reading
  InputArchive in(job.jd.archive.c_str()/*,job.jd.*/);
  if (!in.isopen()) return 0;
  StringBuffer out;
  // Look for next READY job.
  int next=0;  // current job
  while (true) {
    lock(job.mutex);
    for (unsigned i=0; i<=job.jd.block.size(); ++i) {
      unsigned k=i+next;
      if (k>=job.jd.block.size()) k-=job.jd.block.size();
      if (i==job.jd.block.size()) {  // no more jobs?
        release(job.mutex);
        return 0;
      }
	  
      Block& b=job.jd.block[k];
      if (b.state==Block::READY && b.size>0 && b.usize>=0) {
        b.state=Block::WORKING;
        release(job.mutex);
        next=k;
        break;
      }
    }
    Block& b=job.jd.block[next];
    // Get uncompressed size of block
    unsigned output_size=0;  // minimum size to decompress
    assert(b.start>0);
    for (unsigned j=0; j<b.size; ++j) {
      assert(b.start+j<job.jd.ht.size());
      assert(job.jd.ht[b.start+j].usize>=0);
      output_size+=job.jd.ht[b.start+j].usize;
    }
    // Decompress
    double mem=0;  // how much memory used to decompress
    try {
      assert(b.start>0);
      assert(b.start<job.jd.ht.size());
      assert(b.size>0);
      assert(b.start+b.size<=job.jd.ht.size());
	  ///myprintf("00692: Andiamo su offset  %lld  %lld\n",b.offset,output_size);
      in.seek(b.offset, SEEK_SET);
      libzpaq::Decompresser d;
      d.setInput(&in);
      out.resize(0);
      assert(b.usize>=0);
      assert(b.usize<=0xffffffffu);
      out.setLimit(b.usize);
      d.setOutput(&out);
      if (!d.findBlock(&mem)) error("archive block not found");
      if (mem>job.maxMemory) job.maxMemory=mem;
      while (d.findFilename()) {
        d.readComment();
        while (out.size()<output_size && d.decompress(1<<14))
		{
		//		myprintf("|");
		};
		if (!flagimage)
		{
			lock(job.mutex);
			print_progress(job.total_size, job.total_done,-1,-1);
			release(job.mutex);
		}
        if (out.size()>=output_size) break;
        d.readSegmentEnd();
      }
      if (out.size()<output_size) {
        lock(job.mutex);
        fflush(stdout);
        myprintf("00693: output [%u..%u] %d of %u bytes\n",
             b.start, b.start+b.size-1, int(out.size()), output_size);
        release(job.mutex);
        error("unexpected end of compressed data");
      }
      // Verify fragment checksums if present
      uint64_t q=0;  // fragment start
      libzpaq::SHA1 sha1;
      assert(b.extracted==0);
      for (unsigned j=b.start; j<b.start+b.size; ++j) {
        assert(j>0 && j<job.jd.ht.size());
        assert(job.jd.ht[j].usize>=0);
        assert(job.jd.ht[j].usize<=0x7fffffff);
        if (q+job.jd.ht[j].usize>out.size())
          error("Incomplete decompression");
        char sha1result[20];
        sha1.write(out.c_str()+q, job.jd.ht[j].usize);
        memcpy(sha1result, sha1.result(), 20);
        q+=job.jd.ht[j].usize;
		if (memcmp(sha1result, job.jd.ht[j].sha1, 20)) {
          lock(job.mutex);
          fflush(stdout);
          myprintf("00694: Job %d: fragment %u size %d checksum failed\n",
                 jobNumber, j, job.jd.ht[j].usize);
		g_exec_text="fragment checksum failed";
          release(job.mutex);
          error("bad checksum");
        }
        ++b.extracted;
      }
    }
    // If out of memory, let another thread try
    catch (std::bad_alloc& e) {
      lock(job.mutex);
      fflush(stdout);
      myprintf("00695: Job %d killed: %s\n", jobNumber, e.what());
	  g_exec_text="Job killed";
      b.state=Block::READY;
      b.extracted=0;
      out.resize(0);
      release(job.mutex);
      return 0;
    }
    // Other errors: assume bad input
    catch (std::exception& e) {
      lock(job.mutex);
      fflush(stdout);
      myprintf("00696: Job %d: skipping [%u..%u] at %1.0f: %s\n",
              jobNumber, b.start+b.extracted, b.start+b.size-1,
              b.offset+0.0, e.what());
      release(job.mutex);
      continue;
    }

    // Write the files in dt that point to this block
    lock(job.write_mutex);
    for (unsigned ip=0; ip<b.files.size(); ++ip) {
      DTMap::iterator p=b.files[ip];
      if (p->second.date==0 || p->second.data<0
          || p->second.data>=int64_t(p->second.ptr.size()))
        continue;  // don't write
      // Look for pointers to this block
      const vector<unsigned>& ptr=p->second.ptr;
      int64_t offset=0;  // write offset
      for (unsigned j=0; j<ptr.size(); ++j) {
        if (ptr[j]<b.start || ptr[j]>=b.start+b.extracted) {
          offset+=job.jd.ht[ptr[j]].usize;
          continue;
        }
		
		///myprintf("\noffset %21s\n",migliaia(offset));
		
        // Close last opened file if different
        if (p!=job.lastdt) {
          if (job.outf!=FPNULL) {
            assert(job.lastdt!=job.jd.dt.end());
            assert(job.lastdt->second.date);
            assert(job.lastdt->second.data
                   <int64_t(job.lastdt->second.ptr.size()));
            myfclose(&job.outf);
          }
          job.lastdt=job.jd.dt.end();
        }
		string filename;
        // Open file for output
        if (job.lastdt==job.jd.dt.end())
		{
			filename=job.jd.rename(p->first);
/*
			if (!flagstdout)
				if (flagramdisk)
					if (!isdirectory(filename))
						if (p->second.pramfile==NULL)
						{
							p->second.pramfile=new franzfs;
							(*p->second.pramfile).init(p->second.size);
							g_allocatedram+=sizeof(franzfs);
						}
*/
			assert(job.outf==FPNULL);
			if ((p->second.data==0) && (!flagstdout))
			{
				if (!job.jd.flagtest)
				{
					if (flagdebug2)
					{
						myprintf("00697: MAKEPATH: %Z\n",filename.c_str());
					}
					makepath(filename);
				}
				if (!flagimage)
				{
					lock(job.mutex);
					print_progress(job.total_size, job.total_done,-1,-1);
					release(job.mutex);
				}
				if (!job.jd.flagtest)
				{
/// sometimes (in Windows) the path is not made (ex. path too long)
/// let's try to make (is just a fix). Please note utw
#ifdef _WIN32
					string percorso=extractfilepath(filename);
					if (percorso!="")
					{
						if (!flaglongpath)
							myreplaceall(percorso,"/","\\");
						if (!direxists(percorso))
						{
							if (flagdebug)
								myprintf("00699: ERROR DIRNOTEX %s\n",percorso.c_str());
							string temppercorso=percorso;
							size_t barra;
							string percorsino;
							while (1)
							{
								barra=temppercorso.find('\\');
								if (barra==string::npos)
									break;
								percorsino+=temppercorso.substr(0, barra)+'\\';
								if (direxists(percorsino))
								{
									if (flagdebug2)
										myprintf("00700: Small path exists %s\n",percorsino.c_str());
								}
								else
								{
									string dafare=percorsino;
									///dafare.pop_back();
									if (flagdebug2)
									{
										myprintf("\n\n");
										myprintf("00701: Make path of %03d\n---\n%s\n---\n",(int)dafare.length(),dafare.c_str());
									}
									if ((dafare!="\\") && (dafare!="\\\\") && (dafare!="\\\\?\\"))
									{
										bool creazione=CreateDirectory(utow(dafare.c_str()).c_str(), 0);
										if (!flaglongpath)
											if (!creazione)
												if (GetLastError()!=ERROR_ALREADY_EXISTS) 
													printerr("decomp1",dafare.c_str(),0);
									}
								}
								temppercorso=temppercorso.substr(barra+1,temppercorso.length());
							}
						}
						if (!flaglongpath)
							if (!direxists(percorso))
								myprintf("00702! path 'percorso' does not exists <<%s>>\n",percorso.c_str());
					}
#endif // corresponds to #ifdef (#ifdef _WIN32)
		///		filename=nomefileseesistegia(filename);
					if (flagstdout)
						job.outf=stdout;
					else
						job.outf=myfopen(filename.c_str(), WB);
		///printf("K2 ---\n");
					if (job.outf==FPNULL)
					{
						lock(job.mutex);
						printerr("decomp2",filename.c_str(),0);
						release(job.mutex);
					}
					
					if (g_chunk_size>0)
					{
						///g_addedchunklist_fp.push_back(job.outf);
						g_addedchunklist.push_back(filename);
					}		
	
#ifndef unix
              else if ((p->second.attr&0x200ff)==0x20000+'w') {  // sparse?
                DWORD br=0;
				///printf("K3 +++\n");

                if (!DeviceIoControl(job.outf, FSCTL_SET_SPARSE,
                    NULL, 0, NULL, 0, &br, NULL))  // set sparse attribute
                  printerr("decomp3",filename.c_str(),0);
				 ///printf("K4 +++\n");

              }
#endif // corresponds to #ifndef (#ifndef unix)
            }
          }
          else if (!job.jd.flagtest)
		  {
				if (flagstdout)
					job.outf=stdout;
				else
				{
					job.outf=myfopen(filename.c_str(), RBPLUS);  // update existing file
#ifdef _WIN32
					if (job.outf==FPNULL)
					{
						myprintf("66935! Windows: myfopen failed, retry (just one time more) after 0.3s\n");
						sleep(300); // Windows: milliseconds
						job.outf=myfopen(filename.c_str(), RBPLUS);  // update existing file
					}
#endif	
				}
          }
		  if (!job.jd.flagtest && job.outf==FPNULL) break;  // skip errors
          
	 		if (g_chunk_size>0)
			{
				///g_addedchunklist_fp.push_back(job.outf);
				g_addedchunklist.push_back(filename);
			}		
	
		  job.lastdt=p;
          assert(job.jd.flagtest || job.outf!=FPNULL);
        }
        assert(job.lastdt==p);
        // Find block offset of fragment
        uint64_t q=0;  // fragment offset from start of block
        for (unsigned k=b.start; k<ptr[j]; ++k) {
          assert(k>0);
          assert(k<job.jd.ht.size());
          if (job.jd.ht[k].usize<0) error("streaming fragment in file");
          assert(job.jd.ht[k].usize>=0);
          q+=job.jd.ht[k].usize;
        }
        assert(q+job.jd.ht[ptr[j]].usize<=out.size());
        // Combine consecutive fragments into a single write
        assert(offset>=0);
        ++p->second.data;
        uint64_t usize=job.jd.ht[ptr[j]].usize;
        assert(usize<=0x7fffffff);
        assert(b.start+b.size<=job.jd.ht.size());
        while (j+1<ptr.size() && ptr[j+1]==ptr[j]+1
               && ptr[j+1]<b.start+b.size
               && job.jd.ht[ptr[j+1]].usize>=0
               && usize+job.jd.ht[ptr[j+1]].usize<=0x7fffffff) {
          ++p->second.data;
          assert(p->second.data<=int64_t(ptr.size()));
          assert(job.jd.ht[ptr[j+1]].usize>=0);
          usize+=job.jd.ht[ptr[++j]].usize;
        }
        assert(usize<=0x7fffffff);
        assert(q+usize<=out.size());
        // Write the merged fragment unless they are all zeros and it
        // does not include the last fragment.
        uint64_t nz=q;  // first nonzero byte in fragments to be written
        while (nz<q+usize && out.c_str()[nz]==0) ++nz;
        if ((nz<q+usize || j+1==ptr.size()))
			//if (stristr(job.lastdt->first.c_str(),"Globals.pas"))
			//if (stristr(job.lastdt->first.c_str(),"globals.pas"))
			{
/// let's calc the CRC32 of the block, and store (keyed by filename)
/// in comments debug code
				if (offset>g_scritti)
					g_scritti=offset;
				uint32_t crc;
				crc=crc32_16bytes(out.c_str()+q, usize);
				s_crc32block myblock;
				myblock.crc32=crc;
				myblock.crc32start=offset;
				myblock.crc32size=usize;
				myblock.filename=job.lastdt->first;
				g_crc32.push_back(myblock);

			}
			/*
		if (job.jd.flagtest && (nz<q+usize || j+1==ptr.size()))
			if (flagramdisk)
					if (!isdirectory(filename))
						if (p->second.pramfile!=NULL)
							(*p->second.pramfile).ramwrite(offset,(char*)out.c_str()+q,usize);
			*/
		if (!job.jd.flagtest && (nz<q+usize || j+1==ptr.size()))
		{
/// with -zero do not write
			if (flagzero)
			{
/// -zero -debug: write all zeros in output
				if (flagdebug)
					///seek to the end and write a 0
					if (job.outf!=NULL)
					{
						fseeko(job.outf, offset+usize, SEEK_SET);
						myfwrite(&byte0, 1, 1, job.outf);
					}
			}
			else
			{
				if (flagdebug2)
					myprintf("00703: OFFSET-WRITE   %19s  size  %12s %s\n",migliaia((int64_t)offset),migliaia2(usize),job.lastdt->first.c_str());
				if (flagramdisk)
				{
					/// do a "ramdisk" write
				}
				else
				{	// write on realfilesystem
					if (job.outf!=NULL)
					{
					/// print_progress cannot handle huge file (ex. vmdks) due to seek-and-write on
					/// filesystems without "smartness"
					/// example: seek @ 300GB and write 1KB
					/// FS must write 300GB of zeros, then 1KB
					/// with a slow spinning drive this can seems a "freeze"
					/// =>when extracting this kind of file use -image and even -minsize something
					/// if something is 1 all writes (and seeks) will be showed
#ifdef _WIN32
						if (!flagnoeta)
							if (flagimage)
							{
								int64_t zerofill=0;
								if (offset>g_maxposition)
								{
									zerofill=offset-g_maxposition;
									g_maxposition=offset;
								}
								uint64_t showsize=20000000;
								if (minsize>0)
									showsize=minsize;
								if ((zerofill+usize)>showsize)
								{
									double eta=0.001*(mtime()-g_start)*(job.total_size-job.total_done)/(job.total_done+1.0);
									if (job.total_done==0)
											eta=0;
									int secondi=(mtime()-g_start)/1000;
									if (secondi==0)
										secondi=1;
									printf("W %10s+%10s=%10s | done %10s of %10s %6.2f%% %02d:%02d:%02d %s/s\r",tohuman(usize),tohuman2(zerofill),tohuman3(usize+zerofill),tohuman4(job.total_done),tohuman5(job.total_size),
									job.total_done*100.0/(job.total_size+0.5),
									int(eta/3600), int(eta/60)%60, int(eta)%60,
									tohuman3(job.total_done/secondi)
									);
								}
							}
#endif // corresponds to #ifdef (#ifdef _WIN32)

					if (flagdebug3)
								myprintf("00704: KA +++ seek offset %21s write %12s\n",migliaia(offset),migliaia2(usize));

						if (!flagstdout)
						{
							if (!flaghuge)
							{
								fseeko(job.outf, offset, SEEK_SET);
								myfwrite(out.c_str()+q, 1, usize, job.outf);
							}
							else
							{
								// Costanti definite dall'utente
								const int64_t seekgrande      = 1024 * 1024 * 1024; // 1 GB
								const size_t  dimensionebuffer = 1024 * 1024;      // 1 MB
								// Buffer di zeri, static per essere inizializzato una sola volta
								static std::vector<char> arrayzero(dimensionebuffer, 0);
								int64_t seek_distance = offset - job.last_write;
								if (seek_distance > seekgrande) 
								{
									int64_t inizio_ms = mtime();
									fseeko(job.outf, job.last_write, SEEK_SET);
									uint64_t zeri_da_scrivere = seek_distance;
									uint64_t zeri_scritti_tot = 0; // Rinominato per chiarezza
									
									int64_t ultimo_output_ms = inizio_ms; // Timestamp dell'ultimo output
									
									// Ciclo di scrittura dei blocchi di zeri
									for (zeri_scritti_tot = 0; zeri_scritti_tot + dimensionebuffer <= zeri_da_scrivere; zeri_scritti_tot += dimensionebuffer) 
									{
										myfwrite(arrayzero.data(), 1, dimensionebuffer, job.outf);
										
										// *** LOGICA DI AGGIORNAMENTO MODIFICATA - OGNI SECONDO ***
										int64_t tempo_attuale_ms = mtime();
										// Stampiamo solo se è passato almeno 1 secondo dall'ultimo output
										if (tempo_attuale_ms - ultimo_output_ms >= 1000) 
										{
											ultimo_output_ms = tempo_attuale_ms; // Aggiorniamo il timestamp dell'ultimo output
											int64_t tempo_trascorso_ms = tempo_attuale_ms - inizio_ms;
											
											if (tempo_trascorso_ms > 0) {
												double velocita = ((double)zeri_scritti_tot) / ((double)tempo_trascorso_ms / 1000.0);
												
												int64_t byte_rimanenti = zeri_da_scrivere - zeri_scritti_tot;
												int perc_attuale = static_cast<int>(((double)zeri_scritti_tot / zeri_da_scrivere) * 100.0);
												int eta_sec_totali = 0;
												
												if (velocita > 0) 
													eta_sec_totali = (int)(byte_rimanenti / velocita);
												
												int ore = eta_sec_totali / 3600;
												if (ore > 99)
													ore = 99;
												int min = (eta_sec_totali % 3600) / 60;
												int sec = eta_sec_totali % 60;
												myprintf("56481: Ext %10s %03d%% ETA: %02d:%02d:%02d @ %12s/s                   \r", 
													   tohuman2(byte_rimanenti), perc_attuale, ore, min, sec, tohuman(velocita));
												///fflush(stdout);
											}
										}
									}
									// Gestiamo i byte rimanenti
									size_t rimanenti = zeri_da_scrivere - zeri_scritti_tot;
									if (rimanenti > 0) 
										myfwrite(arrayzero.data(), 1, rimanenti, job.outf);
									
									eol();
									myprintf("Thinking... %10s\r",tohuman(g_fwritten));
									
								} else {
									fseeko(job.outf, offset, SEEK_SET);
								}
								// Scrittura dei dati effettivi (invariata)
								myfwrite(out.c_str() + q, 1, usize, job.outf);
								
								int64_t current_time = mtime();
								if (g_last_progress_time == 0 || (current_time - g_last_progress_time) >= 1000) 
								{
									eol();
									myprintf("Written... %10s of %10s\r", tohuman(job.total_done), tohuman2(job.total_size));
									g_last_progress_time = current_time;
								}

								// Aggiornamento di job.last_write (invariato)
								if ((offset + usize) > job.last_write) 
									job.last_write = offset + usize;
							}
						}
						else
							fwrite(out.c_str()+q, 1, usize, stdout);


					}
				}
			}
		}
        offset+=usize;
        lock(job.mutex);
        job.total_done+=usize;
        release(job.mutex);
		///myprintf("00705: Scrittoni %f\n",(double)job.total_done);
        // Close file. If this is the last fragment then set date and attr.
        // Do not set read-only attribute in Windows yet.
        if (p->second.data==int64_t(ptr.size())) {
          assert(p->second.date);
          assert(job.lastdt!=job.jd.dt.end());
          assert(job.jd.flagtest || job.outf!=FPNULL);
          if (!job.jd.flagtest) {
            assert(job.outf!=FPNULL);
            string fn=job.jd.rename(p->first);
            int64_t attr=p->second.attr;
            int64_t date=p->second.date;
            if ((p->second.attr&0x1ff)=='w'+256) attr=0;  // read-only?
            if (p->second.data!=int64_t(p->second.ptr.size()))
              date=attr=0;  // not last frag
            close(fn.c_str(), date, attr, job.outf);
            job.outf=FPNULL;
          }
          job.lastdt=job.jd.dt.end();
        }
      } // end for j
    } // end for ip
    // Last file
    release(job.write_mutex);
  } // end while true
  // Last block
  return 0;
}
ThreadReturn decompressthreadramdisk(void* arg)
{
	ExtractJob& job=*(ExtractJob*)arg;
	int jobNumber=0;
  // Get job number
	lock(job.mutex);
	jobNumber=++job.job;
	release(job.mutex);
	InputArchive in(job.jd.archive.c_str()/*,job.jd.*/);
	if (!in.isopen())
		return 0;
	StringBuffer out;
  // Look for next READY job.
	int next=0;  // current job
	while (true)
	{
		lock(job.mutex);
		for (unsigned i=0; i<=job.jd.block.size(); ++i)
		{
			unsigned k=i+next;
			if (k>=job.jd.block.size())
				k-=job.jd.block.size();
			if (i==job.jd.block.size())
			{  // no more jobs?
				release(job.mutex);
				return 0;
			}
			Block& b=job.jd.block[k];
			if (b.state==Block::READY && b.size>0 && b.usize>=0)
			{
				b.state=Block::WORKING;
				release(job.mutex);
				next=k;
				break;
			}
		}
		Block& b=job.jd.block[next];
    // Get uncompressed size of block
		unsigned output_size=0;  // minimum size to decompress
		assert(b.start>0);
		for (unsigned j=0; j<b.size; ++j)
		{
			assert(b.start+j<job.jd.ht.size());
			assert(job.jd.ht[b.start+j].usize>=0);
			output_size+=job.jd.ht[b.start+j].usize;
		}
		// Decompress
		double mem=0;  // how much memory used to decompress
		try
		{
			assert(b.start>0);
			assert(b.start<job.jd.ht.size());
			assert(b.size>0);
			assert(b.start+b.size<=job.jd.ht.size());
			in.seek(b.offset, SEEK_SET);
			libzpaq::Decompresser d;
			d.setInput(&in);
			out.resize(0);
			assert(b.usize>=0);
			assert(b.usize<=0xffffffffu);
			out.setLimit(b.usize);
			d.setOutput(&out);
			if (!d.findBlock(&mem))
				error("31284 archive block not found");
			if (mem>job.maxMemory)
				job.maxMemory=mem;
			while (d.findFilename())
			{
				d.readComment();
				while (out.size()<output_size && d.decompress(1<<14))
					;
				if (!flagimage)
				{
					lock(job.mutex);
					print_progress(job.total_size, job.total_done,-1,-1);
					release(job.mutex);
				}
				if (out.size()>=output_size)
					break;
				d.readSegmentEnd();
			}
			if (out.size()<output_size)
			{
				lock(job.mutex);
				fflush(stdout);
				myprintf("00706: output [%u..%u] %d of %u bytes\n",b.start, b.start+b.size-1, int(out.size()), output_size);
				release(job.mutex);
				error("31838 unexpected end of compressed data");
			}
		  // Verify fragment checksums if present
			uint64_t q=0;  // fragment start
			libzpaq::SHA1 sha1;
			assert(b.extracted==0);
			for (unsigned j=b.start; j<b.start+b.size; ++j)
			{
				assert(j>0 && j<job.jd.ht.size());
				assert(job.jd.ht[j].usize>=0);
				assert(job.jd.ht[j].usize<=0x7fffffff);
				if (q+job.jd.ht[j].usize>out.size())
					error("31318 Incomplete decompression");
				if (flagchecksum)
				{
					char sha1result[20];
					sha1.write(out.c_str()+q, job.jd.ht[j].usize);
					memcpy(sha1result, sha1.result(), 20);
					q+=job.jd.ht[j].usize;
					if (memcmp(sha1result, job.jd.ht[j].sha1, 20))
					{
						lock(job.mutex);
						fflush(stdout);
						myprintf("00707: Job %d: fragment %u size %d checksum failed\n",jobNumber, j, job.jd.ht[j].usize);
						g_exec_text="31327: fragment checksum failed";
						release(job.mutex);
						error("31330 bad checksum");
					}
				}
				else
					q+=job.jd.ht[j].usize;
				++b.extracted;
			}
		}
		// If out of memory, let another thread try
		catch (std::bad_alloc& e)
		{
			lock(job.mutex);
			fflush(stdout);
			myprintf("00708: Job %d killed: %s\n", jobNumber, e.what());
			g_exec_text="31341 Job killed";
			b.state=Block::READY;
			b.extracted=0;
			out.resize(0);
			release(job.mutex);
			return 0;
		}
		// Other errors: assume bad input
		catch (std::exception& e)
		{
			lock(job.mutex);
			fflush(stdout);
			myprintf("00709: Job %d: skipping [%u..%u] at %1.0f: %s\n",jobNumber, b.start+b.extracted, b.start+b.size-1,b.offset+0.0, e.what());
			release(job.mutex);
			continue;
		}
    // Write the files in dt that point to this block
    lock(job.write_mutex);
    for (unsigned ip=0; ip<b.files.size(); ++ip)
	{
		DTMap::iterator p=b.files[ip];
		if (p->second.date==0 || p->second.data<0
          || p->second.data>=int64_t(p->second.ptr.size()))
        continue;  // don't write
      // Look for pointers to this block
		const vector<unsigned>& ptr=p->second.ptr;
		int64_t offset=0;  // write offset
		for (unsigned j=0; j<ptr.size(); ++j)
		{
			if (ptr[j]<b.start || ptr[j]>=b.start+b.extracted)
			{
				offset+=job.jd.ht[ptr[j]].usize;
				continue;
			}
			// Close last opened file if different
			if (p!=job.lastdt)
				job.lastdt=job.jd.dt.end();
			if (job.lastdt==job.jd.dt.end())
			{
				if (!isdirectory(job.jd.rename(p->first)))
					if (p->second.pramfile==NULL)
					{
						p->second.pramfile=new franzfs;
						(*p->second.pramfile).init(p->second.size);
						g_allocatedram+=sizeof(franzfs);

					}
				if (p->second.pramfile==NULL)
					error("31399 cannot init ramdisk");
				if (p->second.data==0)
				{
					if (!flagimage)
					{
						lock(job.mutex);
						print_progress(job.total_size, job.total_done,-1,-1);
						release(job.mutex);
					}
				}
				job.lastdt=p;
			}
			assert(job.lastdt==p);
			// Find block offset of fragment
			uint64_t q=0;  // fragment offset from start of block
			for (unsigned k=b.start; k<ptr[j]; ++k)
			{
				assert(k>0);
				assert(k<job.jd.ht.size());
				if (job.jd.ht[k].usize<0)
					error("31420 streaming fragment in file");
				assert(job.jd.ht[k].usize>=0);
				q+=job.jd.ht[k].usize;
			}
			assert(q+job.jd.ht[ptr[j]].usize<=out.size());
			// Combine consecutive fragments into a single write
			assert(offset>=0);
			++p->second.data;
			uint64_t usize=job.jd.ht[ptr[j]].usize;
			assert(usize<=0x7fffffff);
			assert(b.start+b.size<=job.jd.ht.size());
			while (j+1<ptr.size() && ptr[j+1]==ptr[j]+1
				   && ptr[j+1]<b.start+b.size
				   && job.jd.ht[ptr[j+1]].usize>=0
				   && usize+job.jd.ht[ptr[j+1]].usize<=0x7fffffff)
			{
				++p->second.data;
				assert(p->second.data<=int64_t(ptr.size()));
				assert(job.jd.ht[ptr[j+1]].usize>=0);
				usize+=job.jd.ht[ptr[++j]].usize;
			}
			assert(usize<=0x7fffffff);
			assert(q+usize<=out.size());
			// Write the merged fragment unless they are all zeros and it
			// does not include the last fragment.
			uint64_t nz=q;  // first nonzero byte in fragments to be written
			while (nz<q+usize && out.c_str()[nz]==0) ++nz;
			if ((nz<q+usize || j+1==ptr.size()))
			{
				if (offset>g_scritti)
					g_scritti=offset;
				if (!(flagzero && flagdebug))		//-zero -debug =>write an all zeroed-file
					if (p->second.pramfile!=NULL)
						(*p->second.pramfile).ramwrite(offset,(char*)out.c_str()+q,usize);
			}
			offset+=usize;
			lock(job.mutex);
			job.total_done+=usize;
			release(job.mutex);
			if (p->second.data==int64_t(ptr.size()))
			{
				assert(job.lastdt!=job.jd.dt.end());
				job.lastdt=job.jd.dt.end();
			}
		} // end for j
	} // end for ip
    // Last file
    release(job.write_mutex);
  } // end while true
  // Last block
  return 0;
}
// Streaming output destination
struct OutputFile: public libzpaq::Writer {
  FP f;
  void put(int c) {
    char ch=c;
    if (f!=FPNULL) myfwrite(&ch, 1, 1, f);
  }
  void write(const char* buf, int n) {if (f!=FPNULL) myfwrite(buf, 1, n, f);}
  OutputFile(FP out=FPNULL): f(out) {}
};
int64_t copywitheta(int64_t i_tobecopied,libzpaq::Reader& in, libzpaq::Writer& out, uint64_t n=~0ull)
{
  const unsigned BUFSIZE=4096;
  int64_t result=0;
  char buf[BUFSIZE];
  int64_t	inizio=mtime();
  while (n>0)
  {
    int nc=n>BUFSIZE ? BUFSIZE : n;
    int nr=in.read(buf, nc);
    if (nr<1) break;
		out.write(buf, nr);
    result+=nr;
	avanzamento(result,i_tobecopied,inizio);
    n-=nr;
  }
  return result;
}
// Copy at most n bytes from in to out (default all). Return how many copied.
int64_t copy(libzpaq::Reader& in, libzpaq::Writer& out, uint64_t n=~0ull)
{
  const unsigned BUFSIZE=4096;
  int64_t result=0;
  char buf[BUFSIZE];
  while (n>0)
  {
    int nc=n>BUFSIZE ? BUFSIZE : n;
    int nr=in.read(buf, nc);
    if (nr<1) break;
		out.write(buf, nr);
    result+=nr;
	 n-=nr;
  }
  return result;
}
uint32_t crchex2int(const char *hex)
{
	assert(hex);
	uint32_t val = 0;
	for (int i=0;i<8;i++)
	{
		uint8_t byte = *hex++;
        if (byte >= '0' && byte <= '9')
			byte = byte - '0';
        else
		if (byte >= 'a' && byte <='f')
			byte = byte - 'a' + 10;
        else
		if (byte >= 'A' && byte <='F')
			byte = byte - 'A' + 10;
        val = (val << 4) | (byte & 0xF);
    }
    return val;
}
void Jidac::printsanitizeflags()
{
	if (flagflat || flagutf || flagfix255 || flagfixeml)
	{
		myprintf("\n");
		myprintf("00710: ******\n");
		if (flagflat)
			myprintf("00711$ ****** WARNING: all files FLATted, without non-latin chars, max %d length\n",(int)FRANZMAXPATH);
		else
		{
			if (flagutf)
				myprintf("00712: ****** -utf    No Non-latin chars\n");
			if (flagfix255)
				myprintf("00713: ****** -fix255 Shrink filenames to %d, case insensitive\n",(int)FRANZMAXPATH);
			if (flagfixeml)
				myprintf("00714: ****** -fixeml Heuristic compress .eml filenames (Fwd Fwd Fwd=>Fwd etc)\n");
#ifdef _WIN32
			if (flagfixreserved)
				myprintf("00715: ****** -fixreserved (fix LPT1, : etc)\n");
			if (flagfixcase)
				myprintf("00716: ****** -fixcase (fix pippo.txt and PIPPO.txt)\n");
#endif // corresponds to #ifdef (#ifdef _WIN32)
		}
		myprintf("00717: ******\n\n");
	}
}
int Jidac::info()
{
	versioncomment="";
	all=8;
	archive=getbackupnameifany(archive);

	return enumeratecomments();
}
int Jidac::zpaqdirsize()
{
	if (archive=="")
	{
		myprintf("00718! empty archive name\n");
		return 2;
	}
	if (files.size()==0)
	{
		myprintf("00719! at least one folder needed\n");
		return 2;
	}
	int errors=0;
	read_archive(NULL,archive.c_str(),&errors,0,true); /// note: kudged isselected
	if (flagdebug3)
	{
		myprintf("\n\n");
		myprintf("00720: dtsize %s\n\n",migliaia((int64_t)dt.size()));
	}
/// just a bit... overkill
	DTMap* dp[2]={&dt, &edt};
	for (int i=0; i<2; ++i)
		for (DTMap::iterator p=dp[i]->begin(); p!=dp[i]->end(); ++p)
		{
			int len=p->first.size();
			if (len>0 && p->first[len]!='/')
				for (int j=0; j<len; ++j)
				{
					if (p->first[j]=='/')
					{
						DTMap::iterator q=dp[i]->find(p->first.substr(0, j+1));
						if (q!=dp[i]->end())
							q->second.size+=p->second.size;
					}
				}
		}
/*
	a "complex" thing... just to sort the output (!)
*/
	vector<DTMap::iterator> filelist;
	myprintf("\n\n");
	if (flagforce)
	{
		myprintf("00721: case sensitive == search, because of -force switch\n");
		for (unsigned int i=0;i<files.size();i++)
		{
			if (!isdirectory(files[i]))
					files[i]+='/';
			DTMap::iterator a=dt.find(files[i]);
			if (a!=dt.end())
				filelist.push_back(a);
			else
			{
				if (flagdebug)
					myprintf("00722$ WARNING cannot find folder in the zpaq %s\n",files[i].c_str());
			}
		}
	}
	else
	{
/// case insensitive. I know, very slow, but who cares?
		myprintf("00723: case iNSeNsITIVE right search, because NO -force switch\n");
		for (unsigned int i=0;i<files.size();i++)
		{
			if (!isdirectory(files[i]))
					files[i]+='/';
			files[i]=stringtolower(files[i]);
			unsigned int oldsize=filelist.size();
			for (DTMap::iterator a=dt.begin(); a!=dt.end(); ++a)
				if (isdirectory(a->first))
				{
					int posizione=myposi(files[i],a->first);
					if (posizione>-1)
						if ((unsigned int)posizione==(unsigned int)(a->first.size()-files[i].size()))
							filelist.push_back(a);
				}
			if (flagdebug)
				if (filelist.size()==oldsize)
					myprintf("00724$ WARNING cannot find folder in the zpaq <<%s>>\n",files[i].c_str());
		}
	}
	sort(filelist.begin(), filelist.end(), compareFragmentList);
	myprintf("\n\n");
	for (unsigned fi=0;fi<filelist.size(); ++fi)
	{
		DTMap::iterator p=filelist[fi];
		myprintf("%19s [%s] <<%Z>>\n",migliaia(p->second.size),dateToString(flagutc,p->second.date).c_str(),p->first.c_str());
	}
	if (flagforce) // .find() search
	{
		if (filelist.size()==files.size())
			return 0;
		else
		{
			myprintf("00725: folder searched %s != founded %s\n",migliaia((int64_t)files.size()),migliaia2((int64_t)filelist.size()));
			return 1;
		}
	}
	return 0;
}

void Jidac::decodelastversion()
{
	if (g_rangelast>0)
	{
		myprintf("00726: You ask the last     %08d versions (...wait...)\n",g_rangelast);
		int errors=0;
		if (archive!="")
			read_archive(NULL,archive.c_str(),&errors,1,true); /// AND NOW THE MAGIC ONE!
		int lastver=ver.size()-1;
		myprintf("00727: Last version present %08d\n",lastver);
		if (g_rangelast>lastver)
		{
			myprintf("00728: Quit because weird vers selection\n");
			seppuku();
		}
		jidacreset();
		g_rangefrom	=lastver-g_rangelast+1;
		g_rangeto	=lastver;
		myprintf("00729: From version         %08d to %08d\n",g_rangefrom,g_rangeto);
	}
}

bool ismemfile(const string& i_filename)
{
	if (mypos("MFILE-",i_filename)>-1)
		return true;
	return false;
}

bool 	iszpaqfranzvirtualfile(const string& i_filename)
{
	if (mypos("VCOMMENT ",i_filename)>-1)
		return true;
	if (mypos("VFILE-",i_filename)>-1)
		return true;
	if (mypos("MFILE-",i_filename)>-1)
		return true;
	return false;
}
bool 	unziszpaqfranzvirtualfile(const string& i_filename)
{
	if (mypos("VCOMMENT ",i_filename)>-1)
		return true;
	if (mypos("VFILE-",i_filename)>-1)
		return true;
	return false;
}

#ifdef _WIN32
class franz_ads
{
	private:
	string			filename;
	string			adsname;
	HANDLE 			hFile;
	int64_t			written;
	public:
	int64_t			size()
	{
		return 	written;
	}
	bool			isopen()
	{
		return hFile!=0;
	}
	void			close()
	{
		if (isopen())
		{
			CloseHandle(hFile);
			hFile=0;
		}
	}
	DWORD write(char* i_buffer,int i_len)
	{
		if (flagdebug3)
			myprintf("00730: entering write\n");
		if (!isopen())
			return -1;
		if (flagdebug3)
			myprintf("00731: before write\n");
		DWORD bw;
		if (WriteFile(hFile,i_buffer,i_len,&bw,NULL))
		{
			if (flagdebug3)
				myprintf("00732: done write\n");
			written+=bw;
			return bw;
		}
		return -1;
	}
	
	DWORD write_uint16(uint16_t i)
	{
		if (!isopen())
			return -1;
		DWORD bw;
		if (WriteFile(hFile,&i,sizeof(i),&bw,NULL))
		{
			written+=sizeof(i);
			return bw;
		}
		return -1;
	}

	franz_ads(string i_filename,string i_adsname,char i_mode):
	filename(""),
	adsname(""),
	hFile(0),
	written(0)
	{
		if ((i_mode!='r') && (i_mode!='w'))
		{
			myprintf("00733: ADS mode can be only r or w %c\n",i_mode);
			return;
		}
		if (i_filename=="")
		{
			myprintf("00734: ADS i_filename empty\n");
			return;
		}
		if (i_adsname=="")
		{
			myprintf("00735: ADS i_adsname empty\n");
			return;
		}
		if (!fileexists(i_filename))
		{
			myprintf("00736: ADS filename does not exits %Z\n",i_filename.c_str());
			return;
		}
		for (unsigned int i=0;i<i_adsname.size();i++)
			if ( (isalpha(i_adsname[i])) || (isdigit(i_adsname[i])))
				adsname+=i_adsname[i];
		filename=i_filename;

		string thepath=i_filename+":"+adsname;
		if (flagdebug2)
			myprintf("00738: Working on %s\n",thepath.c_str());
		
		if (i_mode=='r')
			hFile=CreateFileW((utow(thepath.c_str()).c_str()), GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
		else
			hFile=CreateFileW((utow(thepath.c_str()).c_str()), GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
		
		if (hFile==INVALID_HANDLE_VALUE)
		{
			if (flagverbose)
			{		
				myprintf("00739: ADS invalid file handle mode %c on %Z\n",i_mode,i_filename.c_str());
			}
			hFile=0;
			return;
		}
	}
};

static size_t read_uint16(FILE* fp, uint16_t* i)
{
    return fread(i, sizeof(*i), 1, fp);
}

static size_t read_bin(FILE* fp, void* array, int arrayBytes)
{
    return fread(array, 1, arrayBytes, fp);
}

static void decompress_print(FILE* inpFp,size_t messageMaxBytes)
{
	if (inpFp==NULL)
	{
		myprintf("00741: infp not good\n");
		seppuku();
		return;
	}
	const int ringBufferBytes=1024*256+messageMaxBytes;
	
 	int64_t startdecompress=mtime();
    LZ4_streamDecode_t* const lz4StreamDecode = LZ4_createStreamDecode();
    char* const cmpBuf = (char*) malloc(LZ4_COMPRESSBOUND(messageMaxBytes));
	g_allocatedram+=LZ4_COMPRESSBOUND(messageMaxBytes);
	if (cmpBuf==NULL)
	{
		myprintf("00742: guru allocating cmpBuf\n");
		seppuku();
		return;
	}
    char* const decBuf = (char*) malloc(ringBufferBytes);
	g_allocatedram+=ringBufferBytes;
	
	if (decBuf==NULL)
	{
		myprintf("00743: guru allocating decBuf\n");
		seppuku();
		return;
	}
    int decOffset 				=0;
	int64_t	bytesdecompressed	=0;
	int		lines				=0;
	int64_t	printtime			=0;
    while(1)
    {
        uint16_t cmpBytes = 0;

        if (read_uint16(inpFp, &cmpBytes)!=1)
			break;
        if (cmpBytes==0) 
			break;
        if (read_bin(inpFp, cmpBuf, cmpBytes)!=cmpBytes) 
			break;

        
		char* const decPtr = &decBuf[decOffset];
		const int decBytes = LZ4_decompress_safe_continue(
			lz4StreamDecode, cmpBuf, decPtr, cmpBytes, (int) messageMaxBytes);
		if (decBytes <= 0) 
			break;
///            write_bin(outFp, decPtr, decBytes);
		bytesdecompressed+=decBytes;
		lines++;
		
		char salvato=decPtr[decBytes];
		decPtr[decBytes]=0;
		int64_t beforeprint=mtime();
		myprintf("%s",decPtr);
		printtime+=(mtime()-beforeprint);
		decPtr[decBytes]=salvato;
		
		// Add and wraparound the ringbuffer offset
		decOffset += decBytes;
		if ((size_t)decOffset >= ringBufferBytes - messageMaxBytes) decOffset = 0;
    }
	if (flagverbose)
	{
		int64_t tempo=mtime()-startdecompress;
		myprintf("\n");
		myprintf("00744: ADS: Time %s (print %s) (wrk %s) # %s / %s bytes\n",migliaia(tempo),migliaia2(printtime),migliaia3(tempo-printtime),migliaia4(lines),migliaia5(bytesdecompressed));
		myprintf("00745: Use the l (list) command with -ads to force a full rebuild of the list\n");
    }
	free(decBuf);
    free(cmpBuf);
    LZ4_freeStreamDecode(lz4StreamDecode);
}

bool win32_print_ads(string i_filename,string i_adsname,int i_maxmessagelen)
{
	string thepath=i_filename+":"+i_adsname;
	FILE* theads = freadopen(thepath.c_str());
	if (theads==NULL)
	{
		if (flagdebug)
		{
			myprintf("00746! cannot open %Z\n",thepath.c_str());
		}
		return false;
	}
 	decompress_print(theads,i_maxmessagelen);
	fclose(theads);
	return true;
}
#endif // corresponds to #ifdef (#ifdef _WIN32)
bool ischecksum()
{
	for (MAPPATIPOHASH::iterator p=g_mappatipohash.begin(); p!=g_mappatipohash.end(); ++p)
		if (p->second.switchflag!=NULL)
			if (p->second.switchflag!= (&flagnochecksum))
				if (*(p->second.switchflag))
					return true;
	return false;
}


bool Jidac::noselection()
{
	return 
	(
		(g_until=="") && 
		(g_rangefrom==0) && 
		(g_rangeto==0) && 
		(g_rangelast==0) &&
		(minsize==0) &&
		(maxsize==0) &&
		(g_datefrom==0) &&
		(g_dateto==0) &&
		(!flagchecksum) &&
		(orderby=="") &&
		(!flagdesc) &&
		(replaceto=="") &&
		(searchfrom=="")
	);
}
// List contents
int Jidac::list()
{
	if (flag715)
	{
		summary=0;
		return list715();
	}
	if (archive=="")
	{
		myprintf("00748! archive is empty\n");
		return 2;
	}

	archive=getbackupnameifany(archive);
	
	if (flagfast)
	{
		if (noselection())
			return listfast();
		else
			myprintf("00749: cannot do -fast because some selection in output\n");
	}
		
#ifdef _WIN32
	if ((g_password==NULL) && (noselection()))
 		if (!flagads)
		{
			InputArchive in(archive.c_str());
			if (in.lastfilename!="")
				if (win32_print_ads(in.lastfilename,"zpaqlist",16384))
					return 0;
		}
#endif	 // corresponds to #ifdef (#ifdef _WIN32)

	if (flagterse)
		flagattr=true;
	
	int64_t csize=0;
	if (flagcomment)
	{
		if (versioncomment=="")
			return enumeratecomments();
		enumeratecomments();
		vector<DTMap::iterator> myfilelist;
		int versione=searchcomments(versioncomment,myfilelist);
		if (versione==0)
		{
			myprintf("00750: cannot find version comment <<%s>>\n",versioncomment.c_str());
			return 1;
		}
		if (versione==-1)
		{
			myprintf("00751: multiple match for version comment <<%s>>\n",versioncomment.c_str());
			return 1;
		}
		version=versione;
		flagcomment=false;
		myprintf("00752: Found version -until %d scanning again...\n",versione);
		jidacreset();
	}


	decodelastversion();
	if (g_rangefrom>0)	// a version-range selection, stick with 8 hardcoded digit
		all=8;	
	
	
	if ((files.size()>=1) && (!flaghome))
		return testverify();

	int errors=0;
	bool flagshow;
	if (flagterse)
		csize=read_archive(NULL,archive.c_str(),&errors,1,true); /// AND NOW THE MAGIC ONE!
	else
	{
		csize=read_archive(NULL,archive.c_str(),&errors,1); 
		myprintf("\n");
	}
	
///fik
//	if (flagstat)
	{
		DTMap* dp[2]={&dt, &edt};
		for (int i=0; i<2; ++i)
			for (DTMap::iterator p=dp[i]->begin(); p!=dp[i]->end(); ++p)
			{
				int len=p->first.size();
				if (len>0 && p->first[len]!='/')
					for (int j=0; j<len; ++j)
						if (p->first[j]=='/')
						{
							DTMap::iterator q=dp[i]->find(p->first.substr(0, j+1));
							if (q!=dp[i]->end())
								q->second.size+=p->second.size;
						}
			}
	}

	if (flaghome)
	{
		std::vector<conteggio_file> conteggi;
		
		int							tot_files	=0;
		int							tot_folders	=0;
		int64_t 					tot_sizes	=0;
		string percorso;
		if (files.size()==1)
			percorso=files[0];
		
		if (flagdesc)
			orderby="dummy";
	    getfirstlevelfolders(dt,percorso,conteggi,orderby!="",flagdesc);
		
		if (conteggi.size()==0)
		{
			myprintf("56555: No match for %s. Case-sensitive problem?\n");
			return 0;
		}
		myprintf("       files          dirs                  size path\n");
		for (unsigned int i=0;i<conteggi.size();i++)
		{
			if (menoenne)
				if (i>=menoenne)
					break;
			if (conteggi[i].dimensione_totale==0)
				color_yellow();
			myprintf("%12s %12s/ %21s %s\n",migliaia(conteggi[i].numero_file),migliaia2(conteggi[i].numero_directory),migliaia3(conteggi[i].dimensione_totale),conteggi[i].percorso.c_str());
			if (conteggi[i].dimensione_totale==0)
				color_restore();
			tot_files	+=conteggi[i].numero_file;
			tot_sizes	+=conteggi[i].dimensione_totale;
			tot_folders	+=conteggi[i].numero_directory;
		}
		printbar('-');
		myprintf("%12s %12s/ %21s Count %s\n",migliaia(tot_files),migliaia2(tot_folders),migliaia3(tot_sizes),migliaia4(conteggi.size()));
			
		return 0;
	}

	g_bytescanned	=0;
	g_filescanned	=0;
	g_worked		=0;
	vector<DTMap::iterator> filelist;
	for (DTMap::iterator a=dt.begin(); a!=dt.end(); ++a)
		if (a->second.data!='-' && (all || a->second.date))
		{
			a->second.data='-';
			filelist.push_back(a);
		}
	if (orderby!="")
	{
		myprintf("00753: Sorting output  (orderby |%s|) ",orderby.c_str());
		if (flagdesc)
			myprintf(" descending ");
		sort(filelist.begin(), filelist.end(), compareorderby);
	}
 	if (menoenne)
		myprintf(" limit to first %d ",menoenne);
	if (!flagterse)
		myprintf("\n");
	int64_t usize=0;
	map<int, string> mappacommenti;
	for (unsigned i=0;i<filelist.size();i++)
	{
		DTMap::iterator p=filelist[i];
		if (isads(p->first))
		{
			string fakefile=p->first;
			myreplace(fakefile,":$DATA","");
			size_t found = fakefile.find("VCOMMENT ");
			if (found != string::npos)
			{
    			string numeroversione=fakefile.substr(found+9,8);
				int numver=mystoi(numeroversione);
				string commento=fakefile.substr(found+9+8+1,65000);
				mappacommenti.insert(std::pair<int, string>(numver, commento));
			}
		}
	}
	flagchecksum=ischecksum() || flagchecksum;
	
	
	int thesizesize=19;
	if (!flagattr)
	{
		int64_t largest=0;
		for (unsigned int i=0;i<filelist.size(); i++)
		{
			if (all)
			{
				string myfilename=filelist[i]->first;
				if (isdirectory(myfilename))
				{
					unsigned v;
					int64_t sizetoprint=filelist[i]->second.size;
					myfilename=myright(myfilename,myfilename.size()-all-3);
					
					if ((int)myfilename.length()==(all+1))
					{
						bool alldigit=true;
						for (unsigned int jj=0;jj<myfilename.length()-1;jj++)
							if (!isdigit(myfilename[jj]))
							{
								alldigit=false;
								break;
							}
						if (alldigit)
						{
							if (all>0 && filelist[i]->first.size()==all+1u && (v=atoi(filelist[i]->first.c_str()))>0 && v<ver.size())
								sizetoprint=v+1<ver.size() ? (ver[v+1].offset-ver[v].offset) : (csize-ver[v].offset);
							if (sizetoprint>largest)
								largest=sizetoprint;
						}
					}
				}
			}
			else
			{
			if (filelist[i]->second.size>largest)
				largest=filelist[i]->second.size;
			}
		}
		
		string temp=migliaia(largest);
		thesizesize=temp.size()+1 +1 ; //[ size
		if (thesizesize<4)
			thesizesize=4;
		
		string sizeheader(thesizesize,'-');
		if (flagdebug2)
		{
			myprintf("00754: largest %s  thesize %d\n",temp.c_str(),thesizesize);
			myprintf("00755: |%s|\n",temp.c_str());
			myprintf("00756: |%s|\n",sizeheader.c_str());
			///return 0;
		}

		char lineatemp[200];
		if (all)
		{
			string verheader(all,'-');
			if (flagdate)
			{
				snprintf(lineatemp,sizeof(lineatemp),"    Date     Time           Creation      %*s Ratio %*s Name/Info",thesizesize,"Size",all,"Ver");
				myprintf("00757: %s\n",lineatemp);
				myprintf("00758: ---------- --------  -------------------- %s ----- %s ----------\n",sizeheader.c_str(),verheader.c_str());
			}
			else
			{
				snprintf(lineatemp,sizeof(lineatemp),"   Date      Time   %*s Ratio %*s Name/Info",thesizesize,"Size",all,"Ver");
				myprintf("00759: %s\n",lineatemp);
				myprintf("00760: ---------- --------  %s ----- %s ----------\n",sizeheader.c_str(),verheader.c_str());
			}
		}
		else
		{
			if (flagdate)
			{
				snprintf(lineatemp,sizeof(lineatemp),"    Date      Time          Creation      %*s Ratio Name",thesizesize,"Size");
				myprintf("00761: %s\n",lineatemp);
				myprintf("00762: ---------- --------  -------------------- %s ----- -----\n",sizeheader.c_str());
			}
			else
			{
				snprintf(lineatemp,sizeof(lineatemp),"   Date      Time   %*s Ratio Name",thesizesize,"Size");
				myprintf("00763: %s\n",lineatemp);
				myprintf("00764: ---------- --------  %s ----- -----\n",sizeheader.c_str());
			}
		}
	}
	
	unsigned fi;
	for (fi=0;fi<filelist.size(); ++fi)
	{
		
		if (menoenne)
			if (fi>=menoenne)
				break;
		DTMap::iterator p=filelist[fi];
		
		
		
		flagshow=true;
		/*
		if (isads(p->first))
		{
			if (strstr(p->first.c_str(),"VCOMMENT "))
				flagshow=false;
		}
		*/
		if ((!flag715) && (!flagforcewindows) && (!all))
			flagshow=!iszpaqfranzvirtualfile(p->first);
		
/// a little of change if -search is used
		if (searchfrom!="")
			flagshow=stristr(p->first.c_str(),searchfrom.c_str());
/// redundant, but not a really big deal
		if (flagchecksum)
			if (isdirectory(p->first))
				flagshow=false;
		if ((minsize>0) || (maxsize>0))
			if (isdirectory(p->first))
				flagshow=false;
		if (maxsize>0)
			if (maxsize<(uint64_t)p->second.size)
				flagshow=false;
		if (minsize>0)
			if (minsize>(uint64_t)p->second.size)
				flagshow=false;
		if (g_datefrom>0)
			if ((p->second.date)<=g_datefrom)
				flagshow=false;
		if (g_dateto>0)
			if ((p->second.date)>=g_dateto)
				flagshow=false;

		if (g_rangefrom>0)
			if (p->first.size()>8) //hardcoded 8
			{
				string inizio=myleft(p->first,8);
				int iversion=atoll(inizio.c_str());
				flagshow=((iversion>=g_rangefrom) && (iversion<=g_rangeto));
			}
			
		if (p->second.date==0)
			if (flagnodel)
				flagshow=false;

		if (flagshow)
			if (!strchr(nottype.c_str(), p->second.data))
			{
				if (p->first!="" && (!isdirectory(p->first)))
					usize+=p->second.size;

				string myfilename		=p->first;
				string myhashtype		="";
				string myhash			="";
				string mycrc32			="";
				int64_t mycreationtime	=0;
				int64_t myaccesstime	=0;
				bool	myisordered=false;
				int		myversion=0;
				franz_posix* myposix=NULL;
				bool	myisadded=false;

				int franzotypedetected=
					decode_franz_block(isdirectory(myfilename),p->second.franz_block,
					myhashtype,
					myhash,
					mycrc32,
					mycreationtime,
					myaccesstime,
					myisordered,
					myversion,
					myposix,myisadded);
			
				if (flagdebug3)
					myprintf("00765: franzotype %d myhashtype %s myhash %s mycrc32 %s myisadded %d\n",franzotypedetected,myhashtype.c_str(),myhash.c_str(),mycrc32.c_str(),(int)myisadded);
				bool flaghoadded=(myhashtype=="XXHASH64B") ||(myhashtype=="MD5B") || (myhashtype=="BLAKE3B")||(myhashtype=="SHA-256B")||(myhashtype=="SHA-3B")||(myhashtype=="XXH3B")||(myhashtype=="SHA1-B");

				if (!flagchecksum)
				{
					franzotypedetected	=0;
					myhashtype			="";
					myhash				="";
					mycrc32				="";
				}
				if (franzotypedetected>1)
				{
					if ((myhashtype!="") && (myhash!=""))
						myhash=myhashtype+": "+myhash+" ";
					if (mycrc32!="")
						mycrc32="CRC32: "+mycrc32+" ";
				}
				else
				{
					if ((myhashtype=="") && (myhash=="") && (mycrc32!=""))
						mycrc32="CRC32: "+mycrc32+" ";
				}
				
				if (summary<=0)
				{
					unsigned 	v;
					string 		theversionnumber	="";
					bool 		flagnewversion		=false;
					bool 		isfolder			=isdirectory(myfilename);
					int64_t 	sizetoprint			=p->second.size;
					int64_t 	compressedtoprint	=p->second.kompressedsize;
					
					if (all)
					{
						theversionnumber=myfilename.substr(0,all);
						if (!isfolder)
							myfilename=myfilename.substr(all+3,myfilename.size()-all-3);
						else
							myfilename=myright(myfilename,myfilename.size()-all-3);
					
						if ((int)myfilename.length()==(all+1))
							if (myfilename[myfilename.length()-1]=='/')
							{
								bool alldigit=true;
								for (unsigned int i=0;i<myfilename.length()-1;i++)
									if (!isdigit(myfilename[i]))
									{
										alldigit=false;
										break;
									}
								if (alldigit)
								{
									myfilename="";
									flagnewversion=true;
									if (all>0 && p->first.size()==all+1u && (v=atoi(p->first.c_str()))>0 && v<ver.size())
										sizetoprint=v+1<ver.size() ? (ver[v+1].offset-ver[v].offset) : (csize-ver[v].offset);
									compressedtoprint=sizetoprint;
								}
							}
					}
					else
					{
						if (tofiles.size()>0)
							myfilename=rename(myfilename);
					}

///					if (flagattr)
	///					list_seconddata(p->second.data);
					//

					if ( !(flagterse && flagnewversion) )
					{
						if (g_csvhf!="")
							myprintf(g_csvhf.c_str());
						list_datetime(p->second.date,flagnewversion);
						tabba();
						
						if (flagdate)
						{
							list_creationdate(mycreationtime);
							tabba();
						}
						if (flagattr || flagterse)
						{
							list_attributes(p->second.attr);
							tabba();
						}
						
						
						list_filesize(isdirectory(p->first),sizetoprint,thesizesize);
						tabba();
						
						list_compressedfilesize(compressedtoprint,sizetoprint,flagnewversion,isfolder,p->second.date==0);
						tabba();
						
						if (theversionnumber!="")
						{	if (g_csvstring=="")
							myprintf("%s|",theversionnumber.c_str());
							else
							myprintf("%s",theversionnumber.c_str());
							if (g_csvstring!="")
								tabba();
						}
						if ((myhash!="") || (mycrc32!=""))
						{
							color_yellow();
							if (myhash!="")
							{
								myprintf("%s ",myhash.c_str());
								tabba();
							}
							if (mycrc32!="")
							{
								myprintf("%s ",mycrc32.c_str());
								tabba();
							}
							color_restore();
						}
						//if (flagattr||flagterse)
							////myfilename=" "+myfilename;
		/// search and replace, if requested
						///franzreplace(myfilename);
						if (flagstdout)
							if (p->second.isordered)
								myfilename="[STDOUT] "+myfilename;
						string simbolino="+";
						
						if (p->second.date==0)
							simbolino="-";
						else
						{
							if (flaghoadded)
								if (!myisadded)
									simbolino="#";
						}

						if (all>0 && p->first.size()==all+1u && (v=atoi(p->first.c_str()))>0 && v<ver.size())
							simbolino="";
						myprintf("%s",simbolino.c_str());
						tabba();
						printUTF8(myfilename.c_str());
		
						if (all>0 && p->first.size()==all+1u && (v=atoi(p->first.c_str()))>0 && v<ver.size())
						{  
							std::map<int,string>::iterator commento=mappacommenti.find(v);
							color_blackongreen();
							myprintf("Files: changed/added %s removed %s", migliaia(ver[v].updates),migliaia2(ver[v].deletes));
							if(commento!= mappacommenti.end())
								myprintf(" <<%s>>",commento->second.c_str());
							color_restore();
						}
						if (g_csvhf!="")
							myprintf(g_csvhf.c_str());

						if (flagtar)
							if (myposix)
							{
								myprintf("\n");
								dump_franz_posix(myposix);
							}
							///{
///							myprintf("***************** POSIX NOT NULL!! %s\n",myposix);
					///		dump_mem((char*)myposix,360);
				///			seppuku();
						///}
					///else
						///myprintf("POSIX NULL\n");
				
						myprintf("\n");
					}
				}
			}
	}  // end for i = each file version
	
	if (flagterse)
		return 0;
	
	int64_t 	allsize=0;
	for (DTMap::const_iterator p=dt.begin(); p!=dt.end(); ++p)
		if (p->second.date)
			for (unsigned j=0; j<p->second.ptr.size(); ++j)
			{
				unsigned k=p->second.ptr[j];
				if (k>0 && k<ht.size())
					if (ht[k].usize>=0)
						allsize+=ht[k].usize;
			}
	int64_t sizecompressed=(csize+dhsize-dcsize);
	
	myprintf("\n");
	myprintf("00766: %21s (%s) of %s (%s) in %s files shown\n",migliaia(usize),tohuman(usize),migliaia2(allsize),tohuman2(allsize),migliaia3(fi));
	myprintf("00767: %21s compressed ",migliaia(sizecompressed));
	if (allsize>0)
	{
		double ratio=(double)sizecompressed/(double)allsize;
		myprintf(" Ratio %.3f <<%Z>>\n",ratio,archive.c_str());
	}
	else
		myprintf("\n");
	if (dhsize!=dcsize)  // index?
		myprintf("00768: Note: %s of %s compressed bytes are in archive\n",
			migliaia((int64_t)(dcsize+0.0)), migliaia2((int64_t)(dhsize+0.0)));
	
	if (flagcollision)
		checksha1collision(dt,true);

#ifdef unix
	if ((!flagstdout) && (!flagterse))
		if (!flagtar)
		{
			int posix=posix_count();
			if (posix>0)
				myprintf("67062$ Info: there are %s metadata (-tar to view)\n",migliaia(posix));
		}
#endif

	return 0;
}






/////////////////////////////// extract ///////////////////////////////
// Return true if the internal file p
// and external file contents are equal or neither exists.
// If filename is 0 then return true if it is possible to compare.
// In the meantime calc the crc32 of the entire file
	
bool Jidac::equal(DTMap::const_iterator p, const char* filename,uint32_t &o_crc32,string i_myhashtype,const string i_myhash,string& o_hash)
{
	if (flagdebug3)
	{	
		myprintf("\n\n");
		myprintf("00814: equal p first  %s\n",p->first.c_str());
		myprintf("00815: equal filename %s\n",filename);
	}
	o_crc32=0;
	o_hash="";
	if (i_myhash=="FAKE")
		o_hash="FAKE";
  // test if all fragment sizes and hashes exist
	if (filename==0)
	{
		static const char zero[20]={0};
		for (unsigned i=0; i<p->second.ptr.size(); ++i)
		{
			unsigned j=p->second.ptr[i];
			if (j<1 || j>=ht.size() || ht[j].usize<0 || !memcmp(ht[j].sha1, zero, 20))
				return false;
		}
		return true;
	}
  // internal or neither file exists
	if (p->second.date==0)
	{
		bool risultato=!exists(filename);
		if (flagdebug3)
			myprintf("00816: second date zero, risultato %d\n",(int)risultato);
		return risultato;
	}
  // directories always match
	if (p->first!="" && isdirectory(p->first))
	{
		bool risultato=exists(filename);
		if (flagdebug3)
			myprintf("00817: p->first isdirectory, check exists %d\n",(int)risultato);
		return risultato;
	}
  // compare sizes
	FP in=myfopen(filename, RB);
	if ((in==NULL) || (in==FPNULL))
	{
		if (flagdebug3)
		myprintf("00818: failed fopen %s\n",filename);
		return false;
	}
	fseeko(in, 0, SEEK_END);
	if (ftello(in)!=p->second.size)
	{
		if (flagdebug3)
			myprintf("00819: ftello(in) %s <> p second size %s\n",migliaia(ftello(in)),migliaia2(p->second.size));
		///return oldfclose(in), false;
		myfclose(&in);
		return false;
	}

	if (flagquick)
	{
		myfclose(&in);
		if (flagdebug3)
			myprintf("00820: flagquick, return true\n");
		return true;
	}
  // compare hashes chunk by chunk.
	fseeko(in, 0, SEEK_SET);
	libzpaq::SHA1 sha1;
	const int BUFSIZE=4096;
	char buf[BUFSIZE];
	bool	flagshow=false;
	if (!flagnoeta)
		if (flagverbose || (p->second.size>100000000)) //only 100MB+ files
			flagshow=true;
	if (flagshow)
		myprintf("\n");
	int64_t 	done				=0;
	int 		ultimapercentuale	=-1;

	
	if (flagdebug3)
		myprintf("00821: franz_do_hash\n");
	
	if (i_myhashtype=="")		// a seppuku if myhashtype is ""
		i_myhashtype="NONE";

	franz_do_hash hashfrombuffer(i_myhashtype);
	hashfrombuffer.init();

	int64_t timestart=mtime();
	for (unsigned i=0; i<p->second.ptr.size(); ++i)
	{
		unsigned f=p->second.ptr[i];
		if (f<1 || f>=ht.size() || ht[f].usize<0)
		{
			myfclose(&in);
			return false;
		}
		double percentuale;
		if (flagshow)
		{
			percentuale=100.0*((double)i/(double)p->second.ptr.size());
			int proper=(int)percentuale;
			if (percentuale>0)
				if (proper!=ultimapercentuale)
				{
					if (proper==99)
							proper=100;
					double tempo=(mtime()-timestart+1)/1000.0;
					int myspeed=(int)(done/tempo);
					
					if (flagchecksum || flagverify ||flagparanoid)
						myprintf("00822: SHA1 %03d%%      %10s/%10s @ %10s/s + %s\r",proper,tohuman(done),tohuman3(p->second.size),tohuman2(myspeed),i_myhashtype.c_str());
					else
						myprintf("00823: SHA1 %03d%%      %10s/%10s @ %10s/s\r",proper,tohuman(done),tohuman3(p->second.size),tohuman2(myspeed));
					ultimapercentuale=(int)percentuale;
				}
		}
		for (int j=0; j<ht[f].usize;)
		{
			int n=ht[f].usize-j;
			if (n>BUFSIZE)
				n=BUFSIZE;
			int r=fread(buf, 1, n, in);
			o_crc32=crc32_16bytes(buf,r,o_crc32);
			done+=r;
			g_worked+=r;
			if (flagchecksum || flagparanoid || flagverify)
				hashfrombuffer.update(buf,r);
			if (r!=n)
			{
				myfclose(&in);
				return false;
			}
			sha1.write(buf, n);
			j+=n;
		}
		if (memcmp(sha1.result(), ht[f].sha1, 20)!=0)
		{
			myfclose(&in);
			return false;
		}
	}
	if (fread(buf, 1, BUFSIZE, in)!=0)
	{
		myfclose(&in);
		return false;
	}
	myfclose(&in);
	
	if (flagchecksum || flagverify ||flagparanoid)
	{
		o_hash=hashfrombuffer.finalize();
		if (flagdebug3)
			myprintf("00824: o_hash in equal %s\n",o_hash.c_str());
	}
	return true;
}

bool ishex(const char i_char)
{
	return (((i_char>=48) && (i_char<=57)) || ((i_char>=65) && (i_char<=70)) || ((i_char>=97) && (i_char<=102)));
}
#ifdef _WIN32
bool isletterpath(const string& i_filename)
{
	if (i_filename.size()<3)
			return false;
	if (isalpha(i_filename[0]))
		if (i_filename[1]==':')
			if ((i_filename[2]=='/') || (i_filename[2]=='\\'))
				return true;
	return false;
}
#endif // corresponds to #ifdef (#ifdef _WIN32)
int Jidac::setpassword()
{
	if (g_keyfile!="")
	{
		myprintf("54639! setpassword does not work with -keyfile\n");
		return 2;
	}
	if (files.size()!=2)
	{
		myprintf("00825! setpassword require exactly two file-parameters: source and destination\n");
		return 2;
	}
	archive=files[0];
	if (!iszpaq(archive))
			archive+=".zpaq";
	repack=files[1];
	if (!iszpaq(repack))
			repack+=".zpaq";
	string part0=subpart(archive,0);
	if (part0!=archive)
	{
		myprintf("00826! so sorry, this seems a multipart archive, abort\n");
		return 2;
	}
	if (!flagspace)
		if (!saggiascrivibilitacartella(repack))
		{
			myprintf("00827! Cannot write on output %s\n",repack.c_str());
			myprintf("00828! Aborting. Use -space to bypass and enforcing\n");
			return 2;
		}
	myprintf("\n\n");
	myprintf("00829: Opening the source archive\n");
	if (g_password!=NULL)
	{
		myprintf("00830: please take note: if the source password is incorrect\n");
		myprintf("00831: the output file will be silently corrupted\n");
		myprintf("\n\n");
	}
	if (new_password==NULL)
	{
		myprintf("00832: New password (-key2) empty, enter . for NO password\n");
		string spassword=mygetpasswordblind("");
		if (spassword==".")
			myprintf("00833: password in output removed\n");
		else
		{
			if (spassword!="")
			{
				libzpaq::SHA256 sha256;
				for (unsigned int i=0;i<spassword.size();i++)
					sha256.put(spassword[i]);
				memcpy(new_password_string, sha256.result(), 32);
				new_password=new_password_string;
			}
		}
	}
	InputArchive in(archive.c_str());
	int64_t lavoro=in.totalsize();
	if (!flagspace)
	{
		int64_t spazio=getfreespace(repack);
		if (spazio<lavoro+1024)
		{
			myprintf("00834! The free space seems tiny %s on %s\n",migliaia(spazio),repack.c_str());
			myprintf("00835! Aborting. Use -space to bypass and enforcing\n");
			return 2;
		}
	}
	if (flagforce)
		delete_file(repack.c_str());
	if (exists(repack))
		error("32507: output file exists and no -force");
	char salt[32]={0};
	if (new_password)
		libzpaq::random(salt, 32);
	myprintf("00836: Running for %s bytes\n",migliaia(in.totalsize()));
	if (g_password!=NULL)
		myprintf("00837: Source password:       present\n");
	else
		myprintf("00838: Source password:       none\n");
	if (new_password!=NULL)
		myprintf("00839: Destination password:  present\n");
	else
		myprintf("00840: Destination password:  none\n");
	OutputArchive out(archive,repack.c_str(), new_password, salt, 0);
	copywitheta(lavoro,in, out);
	myprintf("\n");
	
	myprintf("00841: Source      %19s <<%Z>>\n", migliaia(in.tell()),archive.c_str());
	myprintf("00842: Destination %19s <<%Z>>\n", migliaia(out.tell()),repack.c_str());
	
	out.close();
	myprintf("\n");
	myprintf("00845: Now quick check of the output file\n");
	g_password=new_password;
	read_archive(NULL,repack.c_str()); /// AND NOW THE MAGIC ONE!
	return 0;
}

int Jidac::checkpassword()
{
	archive=getbackupnameifany(archive);
	if (archive=="")
	{
		myprintf("54277! archive cannot be empty!\n");
		return 2;
	}
	InputArchive in(archive.c_str());
	if (!in.isopen()) 
	{
		myprintf("54284! GURU cannot open <<%Z>>\n",archive.c_str());
		return 2;
	}
 
  	char s[4]={0};
	const int nr=in.read(s, 4);
	int risultato=0;
	
	if (nr>0 && memcmp(s, "7kSt", 4) && (memcmp(s, "zPQ", 3) || s[3]<1))
		risultato=2;
	return risultato;
}
// Extract files from archive. If force is true then overwrite
// existing files and set the dates and attributes of exising directories.
// Otherwise create only new files and directories. Return 1 if error else 0.
struct tparametriramtodisk
{
	///vector<string> 	o_hashcalculated;
	vector<string> 	filenameondisk;
	vector<int64_t>	filedate;
	vector<int64_t>	fileattr;
	vector<string> 	algo;
	vector<string> 	filehash;
	vector<int64_t>	filesize;
	vector<char*>	data;
	vector<string> 	filecrc;
	vector<uint32_t> filefix;
	int				tnumber;
	uint64_t		timestart;
	bool			flagtest;
	uint64_t		o_timeend;
	int64_t			o_hashedsize;
	int64_t			o_crcsize;
	int64_t			o_writtenbythread;
	int64_t			o_timecrc;
	int64_t			o_timehash;
	int64_t			o_timefilesystem;
	int64_t			o_timewrite;
	uint32_t		o_writeerror;
	uint32_t		o_fileok;
	uint32_t		o_fileerror;
	uint32_t		o_filesnotchecked;
	uint32_t		o_filewithoutcrc;
	uint32_t		o_filecrc;
	uint32_t		o_filecrcok;
	uint32_t		o_filecrcerror;
	tparametriramtodisk(): tnumber(0),timestart(0),flagtest(false),
	o_timeend(0),
	o_hashedsize(0),
	o_crcsize(0),
	o_writtenbythread(0),
	o_timecrc(0),
	o_timehash(0),
	o_timefilesystem(0),
	o_timewrite(0),
	o_writeerror(0),
	o_fileok(0),
	o_fileerror(0),
	o_filesnotchecked(0),
	o_filewithoutcrc(0),
	o_filecrc(0),
	o_filecrcok(0),
	o_filecrcerror(0)	{}

};
void * scriviramtodisk(void *t)
{
	assert(t);
	tparametriramtodisk* par= ((struct tparametriramtodisk*)(t));
	char buffer[100];
	string hashstringato;
	string crc32fromram;

	par->o_crcsize			=0;
	par->o_hashedsize		=0;
	par->o_writtenbythread	=0;
	par->o_timecrc			=0;
	par->o_timehash			=0;
	par->o_timefilesystem	=0;
	par->o_timewrite		=0;
	par->o_writeerror		=0;
	par->o_fileok			=0;
	par->o_fileerror		=0;
	par->o_filesnotchecked	=0;
	par->o_filewithoutcrc	=0;
	par->o_filecrc			=0;
	par->o_filecrcok		=0;
	par->o_filecrcerror		=0;
	for (unsigned int i=0;i<par->filenameondisk.size();i++)
	{
		if (flagchecksum)
			if (!isdirectory(par->filenameondisk[i]))
				if (par->data[i]!=NULL)
					{
						if (par->filecrc[i]!="")
						{
							int64_t startcrc=mtime();
							par->o_filecrc++;
							uint32_t crc=0;
							crc=crc32_16bytes (par->data[i],par->filesize[i],crc);
							snprintf(buffer,sizeof(buffer),"%08X",crc);
							crc32fromram=buffer;
							if (crc32fromram==par->filecrc[i])
								par->o_filecrcok++;
							else
							{
								if (par->filecrc[i]!="00000000")
								{
									if (flagverbose)
										myprintf("00846: ERROR CRC stored %s  from ram|%s|\n",par->filecrc[i].c_str(),crc32fromram.c_str());
									par->o_filecrcerror++;
								}
							}
							par->o_crcsize+=par->filesize[i];
							par->o_timecrc+=(mtime()-startcrc);
						}
						else
						par->o_filewithoutcrc++;
						int64_t starthash=mtime();
						if (par->algo[i]=="")
							par->o_filesnotchecked++;
						else
						{
							if (flagdebug3)
								myprintf("00847: franz_do_hash\n");

							franz_do_hash hashfrombuffer(par->algo[i]);
							hashfrombuffer.init();
							hashfrombuffer.update(par->data[i],par->filesize[i]);
							hashstringato=hashfrombuffer.finalize();
							par->o_hashedsize+=par->filesize[i];
						}
						if (flagdebug)
							myprintf("00848: INFO hash stored %s %s  from ram|%s| %s\n",par->algo[i].c_str(),par->filecrc[i].c_str(),hashstringato.c_str(),par->filenameondisk[i].c_str());

						///if (par->filehash[i]!="!ERROR!")
						if (par->filehash[i]!=hashstringato)
						{
							par->o_fileerror++;
							if (flagverbose)
								myprintf("00849: ERROR hash stored |%s| |%s|  from ram|%s| %s\n",par->algo[i].c_str(),par->filehash[i].c_str(),hashstringato.c_str(),par->filenameondisk[i].c_str());
						}
						else
						{
							if (hashstringato!="")
								par->o_fileok++;
						}
						int64_t temp=(mtime()-starthash);///*0.001;
						par->o_timehash+=temp;
					}
		if (!par->flagtest)
		{
			int64_t startfilesystem=mtime();
			///myprintf("00850: makepath %s\n",par->filenameondisk[i]);
			makepath(par->filenameondisk[i], par->filedate[i],par->fileattr[i]);
			FP myfile=myfopen(par->filenameondisk[i].c_str(), WB);
			if (myfile==FPNULL)
			{
				myprintf("\n");
				myprintf("00851! Hard guru during fopen (no free RAM?)!\n");
				seppuku();
			}
			par->o_timefilesystem+=(mtime()-startfilesystem);
			int64_t startwrite=mtime();
	/// splitting for 32-bit version. I know, it is weird, but necessary
			int64_t	scritti=0;
			int64_t	n=1000000000;
			int64_t w=0;
			while (1)
			{
				int64_t dascrivere=par->filesize[i]-scritti;
				if (dascrivere>n)
						dascrivere=n;
				w=myfwrite(par->data[i]+scritti,1,dascrivere,myfile);
				scritti+=w;
				if (w!=n)
					break;
			}
			///size_t scritti=fwrite(par->data[i],1,par->filesize[i],myfile);
			par->o_writtenbythread+=scritti;
			myfclose(&myfile);
			close(par->filenameondisk[i].c_str(),par->filedate[i],par->fileattr[i]);
			par->o_timewrite+=(mtime()-startwrite);
			if (scritti!=par->filesize[i])
			{
				if (flagverbose)
				{
					myprintf("00852: written != expected %21s %21s on %Z\n",migliaia(scritti),migliaia2(par->filesize[i]),par->filenameondisk[i].c_str());
				}
				par->o_writeerror++;
			}
		}
		myavanzamentoby1sec(g_fwritten,g_ramdisksize,par->timestart,false);
	}
	par->o_timeend=mtime();
	pthread_exit(NULL);
	return 0;
}
int Jidac::ecommand()
{
	myprintf("00854: Extracting on current directory\n");
	tofiles.clear();

	string relative="./";
#ifdef _WIN32
	if (flaglongpath)
	{
		relative=relativetolongpath(relative);
		myprintf("=> Windows longpath => %Z\n",relative.c_str());
	}
#endif // corresponds to #ifdef (#ifdef _WIN32)
	tofiles.push_back(relative);
	return extract();
}
int myrename(string sfrom, string sto)
{
    // Check if the destination file or path exists
#ifdef _WIN32
    std::wstring wto = utow(sto.c_str());
    if (GetFileAttributesW(wto.c_str()) != INVALID_FILE_ATTRIBUTES)
    {
        myprintf("50850! ERROR: Destination already exists\n");
        myprintf("50851! from <<%s>>\n", sfrom.c_str());
        myprintf("50852! to   <<%s>>\n", sto.c_str());
        return 1;
    }

    if (flaglongpath)
    {
        sfrom = makelongpath(sfrom);
        sto = makelongpath(sto);
    }
    std::wstring wfrom = utow(sfrom.c_str());
    if (!MoveFileW(wfrom.c_str(), wto.c_str()))
    {
        myprintf("00855! ERROR WIN renaming\n");
        myprintf("00856! from <<%s>>\n", sfrom.c_str());
        myprintf("00857! to   <<%s>>\n", sto.c_str());
        decodewinerror(GetLastError(), "dummy");
        if (flagverbose)
            for (unsigned int j = 0; j < sfrom.length(); j++)
                myprintf("00862: %03d %03d %c\n", j, sto[j], sto[j]);
        return 1;
    }
#else
    struct stat buffer;
    if (stat(sto.c_str(), &buffer) == 0)
    {
        myprintf("00860! ERROR: Destination already exists\n");
        myprintf("00861! from <<%s>>\n", sfrom.c_str());
        myprintf("00862! to   <<%s>>\n", sto.c_str());
        return 1;
    }

    if (::rename(sfrom.c_str(), sto.c_str()) != 0)
    {
        myprintf("00863! ERROR NIX renaming\n");
        myprintf("00864! from <<%s>>\n", sfrom.c_str());
        myprintf("00865! to   <<%s>>\n", sto.c_str());
        if (flagverbose)
            for (unsigned int j = 0; j < sfrom.length(); j++)
                myprintf("00866: %03d %03d %c\n", j, sto[j], sto[j]);
        return 1;
    }
#endif
    return 0;
}
#ifdef _WIN32
bool Jidac::searchunixfile()
{
	bool risultato=false;
	for (DTMap::iterator p=dt.begin(); p!=dt.end(); ++p)
        if ((p->second.attr&255)=='u') // unix attributes
		{
			risultato=true;
			break;
		}
	return risultato;
}
#endif // corresponds to #ifdef (#ifdef _WIN32)
/////////////////////////////// list //////////////////////////////////
/// quanti==1 => version (>0)
/// quanti==0 => 0
/// else  => -1 multiple match
int Jidac::searchcomments(string i_testo,vector<DTMap::iterator> &filelist)
{
	unsigned int quanti=0;
	int versione=-1;
	filelist.clear();
	for (DTMap::iterator a=dt.begin(); a!=dt.end(); ++a)
	{
		a->second.data='-';
		filelist.push_back(a);
	}
	///VCOMMENT 00000002 seconda_versione:$DATA
	for (unsigned i=0;i<filelist.size();i++)
	{
		DTMap::iterator p=filelist[i];
		if (isads(p->first))
		{
			string fakefile=p->first;
			myreplace(fakefile,":$DATA","");
			size_t found = fakefile.find("VCOMMENT ");
			if (found != string::npos)
			{
				string numeroversione=fakefile.substr(found+9,8);
				int numver=mystoi(numeroversione);
				string commento=fakefile.substr(found+9+8+1,65000);
				if (i_testo.length()>0)
					if (!stringcomparei(commento,i_testo))
						continue;
    			mappacommenti.insert(std::pair<int, string>(numver, commento));
				versione=numver;
				quanti++;
			}
		}
	}
	if (quanti==1)
		return versione;
	else
	if (quanti==0)
		return 0;
	else
		return -1;
}
int Jidac::enumeratecomments()
{
	  // Read archive into dt, which may be "" for empty.
	int64_t csize=0;
	int errors=0;
	if (archive!="")
		csize=read_archive(NULL,archive.c_str(),&errors,1); /// AND NOW THE MAGIC ONE!
	if (command!='i')
	{
		myprintf("\n");
		myprintf("00995: Version(s) enumerator\n");
	}
	vector<DTMap::iterator> filelist;
	searchcomments(versioncomment,filelist);
	if (command!='i')
		for (MAPPACOMMENTI::const_iterator p=mappacommenti.begin(); p!=mappacommenti.end(); ++p)
			myprintf("%08d <<%s>>\n",p->first,p->second.c_str());
	for (DTMap::iterator p=edt.begin(); p!=edt.end(); ++p)
	{
		DTMap::iterator a=dt.find(rename(p->first));
		if ((a!=dt.end()) && (a->second.date))
		{
			a->second.data='-';
			filelist.push_back(a);
		}
		p->second.data='+';
		filelist.push_back(p);
	}
	for (DTMap::iterator a=dt.begin(); a!=dt.end(); ++a)
		if (a->second.data!='-' && (a->second.date))
		{
			a->second.data='-';
			filelist.push_back(a);
		}
		
	if (all)
	{
		if (g_rangelast>0)
		{
			int lastver=ver.size()-1;
			g_rangefrom	=lastver-g_rangelast+1;
			g_rangeto	=lastver;
		}
		
		if (flagstat)
		{
			myprintf("01006: ----------------------------------------------------------------------------------------------\n");
			myprintf("01007: <  Ver  > <  date  > < time >  < added > <removed> <    uncompressed   > <    compressed     >\n");
			myprintf("01008: ----------------------------------------------------------------------------------------------\n");
		}
		else
		{
			myprintf("01009: --------------------------------------------------------------------------\n");
			myprintf("01010: <  Ver  > <  date  > < time >  < added > <removed>    <    bytes added   >\n");
			myprintf("01011: --------------------------------------------------------------------------\n");
		}
		
		
		vector<unsigned int> linetobeprinted;
		for (unsigned fi=0;fi<filelist.size() /*&& (true || int(fi)<summary)*/; ++fi)
		{
			DTMap::iterator p=filelist[fi];
			unsigned v;
			if (p->first.size()==all+1u && (v=atoi(p->first.c_str()))>0 && v<ver.size())
			{
				bool show=true;
				if (g_rangefrom>0)
					if (!(((int)v>=(int)g_rangefrom) && ((int)v<=(int)g_rangeto)))
						show=false;
				if (show)
					linetobeprinted.push_back(fi);
			}
		}

		unsigned int from	=0;
		if (menoenne)
			if (menoenne<linetobeprinted.size())
				from=linetobeprinted.size()-menoenne;
		
		uint64_t totalcompressed	=0;
		uint64_t totaluncompressed	=0;
		string lastdate;
		for (unsigned fi=0;fi<filelist.size(); ++fi)
		{
			if (binary_search(linetobeprinted.begin(),linetobeprinted.end(),fi)==true)
				if (fi>=linetobeprinted[from])
				{
					DTMap::iterator p=filelist[fi];
					unsigned v=atoi(p->first.c_str());
					lastdate=dateToString(flagutc,p->second.date);
					myprintf("01012: V%08u %s ",v,lastdate.c_str());
					
					if (flagstat)
					{
						myprintf(" +%08d -%08d %20s [%20s]", ver[v].updates, ver[v].deletes,
						migliaia2(ver[v].usize),migliaia((int64_t)((v+1<ver.size() ? ver[v+1].offset : csize)-ver[v].offset+0.0)));
						totaluncompressed+=ver[v].usize;
						totalcompressed+=(int64_t)((v+1<ver.size() ? ver[v+1].offset : csize)-ver[v].offset+0.0);
					}	
					else
					{
						myprintf(" +%08d -%08d -> %20s", ver[v].updates, ver[v].deletes,
						migliaia((int64_t)((v+1<ver.size() ? ver[v+1].offset : csize)-ver[v].offset+0.0)));
						totalcompressed+=(int64_t)((v+1<ver.size() ? ver[v+1].offset : csize)-ver[v].offset+0.0);
						
					}
					std::map<int,string>::iterator commento;
					commento=mappacommenti.find(v);
					if(commento!= mappacommenti.end())
						myprintf(" <<%s>>", commento->second.c_str());
					myprintf("\n");
				}
		}
		if (flagstat)
		{
			myprintf("59648: ----------------------------------------------------------------------------------------------\n");
			if (g_password)
				myprintf("59349: %20s                               %20s  %20s [%s]\n",migliaia3(csize),migliaia(totaluncompressed),migliaia2(totalcompressed),migliaia3(totalcompressed+32));
			else
				myprintf("59149: %20s                               %20s  %20s\n",migliaia3(csize),migliaia(totaluncompressed),migliaia2(totalcompressed));
		}
		else
		{
			myprintf("59644: --------------------------------------------------------------------------\n");
			if (g_password)
				myprintf("59143: %20s                                  %20s [%s]\n",migliaia3(csize),migliaia(totalcompressed),migliaia2(totalcompressed+32));
			else
				myprintf("59643: %20s                                  %20s\n",migliaia3(csize),migliaia(totalcompressed));
				
		}

		if (flagbig)
			if (lastdate!="")
			{
				myprintf("\n");
				string primi10=lastdate.substr(0,19);

				///myreplaceall(primi10,"-","    ");
				printDigitalString(primi10.c_str());
				/*
				ascii::Ascii font=ascii::Ascii();
				font.print(primi10);
				*/
			}
						
	}
	return 0;
	
}
int Jidac::kill()
{
	myprintf("01013: KILL of:");
	if (files.size()==0)
		return -1;
	if (archive=="")
		return -1;
	read_archive(NULL,archive.c_str());
  // Read external files into edt
	///uint64_t howmanyfiles=0;
	g_bytescanned=0;
	g_filescanned=0;
	g_worked=0;
	files_count.clear();
	edt.clear();
	string cartellaoutput=tofiles[0];
	scandir(false,edt,cartellaoutput);
	eol();
	if (edt.size())
		myprintf("01014: Total files found: %s\n", migliaia(edt.size()));
	else
	{
		myprintf("01015: Found nothing in filesystem\n");
		return 1;
	}
	myprintf("\n");
	vector<string> inzpaqrinominato;
	vector<string> tobekilled;
	vector<string> dirtobekilled;
	for (DTMap::iterator a=dt.begin(); a!=dt.end(); ++a)
	{
		string dentrofile=a->first;
		myreplace(dentrofile,files[0],tofiles[0]);
		if (a->second.date==0)
		{
			if (flagverbose)
				myprintf("01016: DELETED ");
		}
		else
			inzpaqrinominato.push_back(dentrofile);
		if (flagverbose)
			myprintf("01017: Into zpaq %s  > renamed %s\n",a->first.c_str(),dentrofile.c_str());
	}
	std::sort(inzpaqrinominato.begin(), inzpaqrinominato.end());
	uint64_t		sizetobekilled=0;
	for (DTMap::iterator a=edt.begin(); a!=edt.end(); ++a)
		if (binary_search(inzpaqrinominato.begin(),inzpaqrinominato.end(),a->first)==false)
		{
			if (isdirectory(a->first))
				dirtobekilled.push_back(a->first);
			else
			{
				tobekilled.push_back(a->first);
				sizetobekilled+=a->second.size;
			}
		}
	for (unsigned int i=0;i<dirtobekilled.size();i++)
	{
		myprintf("01018: Dir  to be killed %Z\n",dirtobekilled[i].c_str());
	}
	for (unsigned int i=0;i<tobekilled.size();i++)
	{
		myprintf("01020: File to be killed %Z\n",tobekilled[i].c_str());
	}
	myprintf("\n");
	unsigned int 	totaltobekilled=dirtobekilled.size()+tobekilled.size();
	if (totaltobekilled==0)
	{
		myprintf("01022: Nothing to do\n");
		return 0;
	}
	myprintf("01023: Directories to be removed %s\n",migliaia(dirtobekilled.size()));
	myprintf("01024: Files       to be removed %s (%s bytes)\n",migliaia2(tobekilled.size()),migliaia(sizetobekilled));
	string captcha="kilL"+myto_string(dirtobekilled.size()+tobekilled.size()+sizetobekilled);
	myprintf("01025: Captcha to continue %s\n",captcha.c_str());
	char myline[81];
    int dummy=scanf("%80s", myline);
	if (dummy==888888)
		myprintf("01026: no-warning-please\n");
	if (myline!=captcha)
	{
		myprintf("01027: Wrong captcha\n");
		return 1;
	}
	myprintf("01028: Captcha OK\n");
	unsigned int killed=0;
	unsigned int killeddir=0;
	for (unsigned int i=0;i<tobekilled.size();i++)
		if (delete_file(tobekilled[i].c_str()))
				killed++;
/// OK iterating instead of recursing
	while (killeddir!=dirtobekilled.size())
		for (unsigned int i=0;i<dirtobekilled.size();i++)
			if (delete_dir(dirtobekilled[i].c_str()))
				killeddir++;
	myprintf("01029: Dir  to be removed %s -> killed %s\n",migliaia(dirtobekilled.size()),migliaia2(killeddir));
	myprintf("01030: File to be removed %s -> killed %s\n",migliaia(tobekilled.size()),migliaia2(killed));
	if ((killeddir+killed)!=(dirtobekilled.size()+tobekilled.size()))
	{
		myprintf("01031: FAILED !! some highlander !!\n");
		return 1;
	}
	return 0;
}
/*
	section: multithread
*/
struct tparametrihash
{
	vector<string> 	o_hashcalculated;
	vector<int64_t> o_sizegetted;
	vector<string> 	originalfilenames;
	vector<string> 	filestobehashed;
	vector<int>		originalindex;
	vector<string> 	filehash;
	vector<string> 	algo;
	uint64_t		timestart;
	uint64_t		timeend;
	int64_t			inizio;
	int64_t 		dimensione;
	int				tnumber;
};
void * scansionahash(void *t)
{
	assert(t);
	tparametrihash* par= ((struct tparametrihash*)(t));

	vector<string>& tmpfilestobehashed	= par->filestobehashed;
	vector<string>& tmpalgo				= par->algo;

	if (tmpfilestobehashed.size()!=tmpalgo.size())
	{
		myprintf("01032: FILETOBEHASHED != ALGO\n");
		seppuku();
	}

	vector<string>& tmphashcalculated	= par->o_hashcalculated;
	vector<int64_t>& tmpsizegetted		= par->o_sizegetted;
	g_dimensione=0;
	for (unsigned int i=0;i<tmpfilestobehashed.size();i++)
	{

		string work=tmpfilestobehashed[i];
		franz_do_hash dummy(tmpalgo[i]);
		bool calcolacrc32=tmpalgo[i]=="CRC-32";
		if (flagdebug2)
			myprintf("01033: calccrc32 %d filehash type |%s| on %s\n",int(calcolacrc32),tmpalgo[i].c_str(),work.c_str());
		string risu=dummy.filehash(0,work,calcolacrc32,par->inizio,par->dimensione);
		
		if (!flaghashdeep)
			if (flagnosort)
			{
				pthread_mutex_lock(&g_mylock);
				int printlen=0;
				if (flagpakka)
				{
					myprintf("01034: %s ",stringtolower(risu).c_str());
					printlen=risu.size()+2;
				}
				else
				{
					myprintf("01035: |%s: %s [%19s] |",tmpalgo[i].c_str(),risu.c_str(),migliaia(dummy.o_thefilesize));
					printlen=tmpalgo[i].size()+risu.size()+19+8;
				}
				
				printUTF8(work.c_str());
				printlen+=work.size();
				if (printlen<68)
				{
					string temp;
					while (printlen++<68)
						temp+=" ";
					myprintf("%s",temp.c_str());
				}
				myprintf("\n");
				pthread_mutex_unlock(&g_mylock);
			}
		
		///myprintf("01036: risultato %s\n",risu.c_str());
		///,g_dimensione,thefilesize);
		tmphashcalculated.push_back(risu);
		tmpsizegetted.push_back(dummy.o_thefilesize);
///		tmphashcalculated.push_back(hash_calc_file(string2algo(tmpalgo[i]),tmpfilestobehashed[i].c_str(),false,dummycrc,par->inizio,par->dimensione,g_dimensione));
	}
	pthread_exit(NULL);
	return 0;
}
int Jidac::deduplicate()
{
	myprintf("01037: *** DIRECTLY DELETE DUPLICATED FILES ***\n");
	if (files.size()==0)
	{
		myprintf("01038: Sorry, works only on exactly 1 dir\n");
		return 1;
	}
	if (files.size()>1)
	{
		myprintf("01039: Sorry, works only on exactly 1 dir\n");
		return 1;
	}
	if (!isdirectory(files[0]))
	{
		myprintf("01040: Sorry, you must enter a directory\n");
		return 1;
	}
	if (flagverbose)
		summary=-1;
	else
		summary=1;
	flagchecksum=false;
	flagverify=true;
	if (!ischecksum())
		flagxxh3=true;
	flagkill=true;
	if (!flagforce)
		myprintf("01041: -force not present: dry run\n");
	return summa();
}
struct tparametribenchmark
{
	int 		chunksize;		// no big data :-)
	uint32_t* 	buffer32bit;
	int			timelimit;
	string		runningalgo;
	int			tnumber;
	string		risultato;
	double		speed;
	tparametribenchmark(): chunksize(0),buffer32bit(0),timelimit(0),runningalgo(""),tnumber(0),risultato(""),speed(0) {}
};

string do_benchmark(int i_tnumber,int i_timelimit,string i_runningalgo,int i_chunksize,uint32_t* buffer32bit,double& o_speed)
{
	int64_t 	starttutto		=mtime();
	int64_t 	lavorati		=0;
	uint64_t 	totalhashtime	=0;
	int			ultimotrascorso	=0;
	int			buffersize=i_chunksize*4-7;
	MD5 md5;
	libzpaq::SHA1 sha1;
	XXH3_state_t state128;
///	franzSHA256 mysha256;
	libzpaq::SHA256 sha256;

	uint64_t _wyp[4];
	make_secret(0,_wyp);
	SHA3 sha3;
	NESSIEstruct whasher;
	NESSIEinit(&whasher);
	blake3_hasher hasher;
	blake3_hasher_init(&hasher);
	uint32_t crc	= 0;
	uint32_t crcc	= 0;
	uint64_t myseed = 0;
	XXHash64 myhash(myseed);

	HighwayHashCat state;
	uint64_t key[4] = {1, 2, 3, 4};
	HighwayHashCatStart(key, &state);

	int i=0;
	while (1)
	{
		int64_t startrandom=mtime();
		populateRandom_xorshift128plus(buffer32bit, i_chunksize,324+i,4444+i);
		int64_t randtime=mtime()-startrandom;
		if ((i_runningalgo=="XXH3")||(i_runningalgo=="XXH3B"))
		{
			(void)XXH3_128bits_reset(&state128);
			(void)XXH3_128bits_update(&state128, buffer32bit, buffersize);
		}
		else
		if (i_runningalgo=="SHA-1")
			sha1.write((const char*)buffer32bit,buffersize);
		else
		if (i_runningalgo=="SHA-1B")
			sha1.write((const char*)buffer32bit,buffersize);
		else
		if (i_runningalgo=="SHA-256")
			sha256.write((const char*)buffer32bit,buffersize);
		else
		if (i_runningalgo=="SHA-256B")
			sha256.write((const char*)buffer32bit,buffersize);
		else
		if (i_runningalgo=="WYHASH")
			wyhash((const char*)buffer32bit,buffersize,0,_wyp);
		else
		if (i_runningalgo=="MD5")
			md5.add((const char*)buffer32bit,buffersize);
		else
		if (i_runningalgo=="MD5B")
			md5.add((const char*)buffer32bit,buffersize);
		else
		if (i_runningalgo=="SHA-3")
			sha3.add((const char*)buffer32bit,buffersize);
		else
		if (i_runningalgo=="SHA-3B")
			sha3.add((const char*)buffer32bit,buffersize);
		else
		if (i_runningalgo=="WHIRLPOOL")
			NESSIEadd((const unsigned char*)buffer32bit,buffersize*8,&whasher);
		else
		if (i_runningalgo=="BLAKE3")
			blake3_hasher_update(&hasher, (const char*)buffer32bit,buffersize);
		else
		if (i_runningalgo=="BLAKE3B")
			blake3_hasher_update(&hasher, (const char*)buffer32bit,buffersize);
		else
		if (i_runningalgo=="CRC-32")
			crc=crc32_16bytes ((const char*)buffer32bit,buffersize, crc);
		else
		if (i_runningalgo=="CRC-32C")
			crcc = crc32c(crcc, (const unsigned char*)buffer32bit,buffersize);
		else
		if (i_runningalgo=="XXHASH64")
			myhash.add((const unsigned char*)buffer32bit,buffersize);
		else
		if ((i_runningalgo=="HIGHWAY64") || (i_runningalgo=="HIGHWAY128") || (i_runningalgo=="HIGHWAY256"))
			HighwayHashCatAppend((const uint8_t*)buffer32bit,buffersize,&state);
/*
	else
		{
			myprintf("01042: GURU unknown algo %s\n",i_runningalgo.c_str());
			seppuku();
			return 0;
		}
*/
		totalhashtime=mtime()-starttutto-randtime;
		if (totalhashtime==0)
			totalhashtime=1;
		lavorati+= (i_chunksize*4);
		double hashingtime=totalhashtime/1000.0;
		o_speed=lavorati/hashingtime;
		int trascorso=(int)((mtime()-starttutto+1)/1000.0);
		if (trascorso!=ultimotrascorso)
		{
			if (i_tnumber<0) /// not a pthread
			{
				myprintf("%03d s %12s: speed (%11s/s) ",trascorso,i_runningalgo.c_str(),
				tohuman3((int64_t)o_speed));
				if (flagverbose)
					myprintf("\n");
				else
					myprintf("\r");
			}
			else
			{
				pthread_mutex_lock(&g_mylock);
				if ((!flagsilent) && (!flagnoconsole))
				{
					setupConsole();
					printf("\033[%d;0H",(int)i_tnumber+1);
					restoreConsole();
				}
				myprintf("01043: Thread4 %02d %03d s %12s: speed (%11s/s)",i_tnumber,trascorso,i_runningalgo.c_str(),tohuman3((int64_t)o_speed));
				pthread_mutex_unlock(&g_mylock);
			}
			ultimotrascorso=trascorso;
		}
		if ((int)((mtime()-starttutto)/1000)>=i_timelimit)
			break;
		i++;
	}
	double hashingtime=totalhashtime/1000.0;
	o_speed=lavorati/hashingtime;
	lavorati+=mtime()-starttutto;
	int trascorso=(int)((mtime()-starttutto+1)/1000.0);
	myprintf("%08d s %12s: speed (%11s/s) ",trascorso,i_runningalgo.c_str(),tohuman3((int64_t)o_speed));
	myprintf("\n");
	char buf[100];
	snprintf(buf,sizeof(buf),"%12s: %11s/s (done %11s)",i_runningalgo.c_str(),tohuman((int64_t)o_speed),tohuman2(lavorati));
	string risultato=buf;
	return risultato;
}

void * benchmark_thread(void *t)
{
	assert(t);
	tparametribenchmark* par= ((struct tparametribenchmark*)(t));
	par->risultato=do_benchmark(par->tnumber,par->timelimit,par->runningalgo,par->chunksize,par->buffer32bit,par->speed);
	pthread_exit(NULL);
	return 0;
}
struct s_benchmark
{
    string	algoritmo;
	double	speed;
	string 	risultati;
};
bool compare_s_benchmark(const s_benchmark &a, const s_benchmark &b)
{
    return a.speed < b.speed;
}
string filecopy(bool i_singlefile,bool i_append,const string& i_infile,const string& i_outfile,bool i_verify,bool i_donotcheckspace,bool i_overwrite,uint64_t i_maxoutputsize)
{
	if ((i_infile)=="")
		return "";
	if ((i_outfile)=="")
		return "";
	if (i_append==true)
	{
		if (i_infile=="QUIT-COMP_$WARN_ING")
			return "";
	}
	string percorso=i_outfile;
	if (i_singlefile)
		percorso=extractfilepath(i_outfile);
	if (!isdirectory(percorso))
		percorso+="/";
	if (!direxists(percorso))
		makepath(percorso);
	int64_t larghezzain	=prendidimensionefile(i_infile.c_str());
	if (i_maxoutputsize>0)
		larghezzain=i_maxoutputsize;
	string solofile=extractfilename(i_infile);
	string filedefinitivo=percorso+solofile;
	if (i_singlefile)
		filedefinitivo=i_outfile;
	if (!i_overwrite)
	{
		if (flagdebug3)
			myprintf("01044: Pre not overwrite %s\n",filedefinitivo.c_str());
		filedefinitivo=nomefileseesistegia(filedefinitivo);
		if (flagdebug3)
			myprintf("01045: Post not overwrite %s\n",filedefinitivo.c_str());
	}
	if (flagdebug2)
		myprintf("01046: ready to make a copy in %s\n",filedefinitivo.c_str());
	int64_t dimensioneoutput	=0;
	int64_t	bytestoappend		=0;
	if (i_append)
	{
		dimensioneoutput	=prendidimensionefile(filedefinitivo.c_str());
		bytestoappend		=larghezzain-dimensioneoutput;

		if (bytestoappend>0)
		{
			if (dimensioneoutput>0)
				myprintf("01047: Ready to append %s bytes to %s => %s\n",migliaia(bytestoappend),migliaia2(dimensioneoutput),migliaia3(larghezzain));
		}
		else
		if (bytestoappend<0)
		{
			myprintf("01048: Destination file larger than source (-append), deleting ...\n");
			if (!delete_file(filedefinitivo.c_str()))
			{
				myprintf("01049! We get an highlander %Z\n",filedefinitivo.c_str());
				return "";
			}
			bytestoappend	=larghezzain;
			i_append		=false;
		}
		else
		if (bytestoappend==0)
		{
			if (flagdebug2)
				myprintf("01051: Source and destination filesize ==, exit\n");
			return filedefinitivo;
		}

	//// 100.000 => 80.000
	///dimensionedacopiare 100.000

	}
	else
		bytestoappend=larghezzain;
	if (!i_donotcheckspace)
	{
		int64_t spaziolibero	=getfreespace(percorso);
		if (spaziolibero<bytestoappend)
		{
			myprintf("01052: impossible to make a copy of %s insufficient free space %s on <<%s>>\n",migliaia(bytestoappend),migliaia2(spaziolibero),percorso.c_str());
			return "";
		}
	}
	FILE* outFile=NULL;
#ifdef _WIN32
	wstring widename=utow(filedefinitivo.c_str());
	if (i_append)
		outFile=_wfopen(widename.c_str(), L"ab" );
	else
		outFile=_wfopen(widename.c_str(), L"wb" );
#else
	if (i_append)
		outFile=fopen(filedefinitivo.c_str(), "ab");
	else
		outFile=fopen(filedefinitivo.c_str(), "wb");
#endif // corresponds to #ifdef (#ifdef _WIN32)
	if (outFile==NULL)
	{
		myprintf("01053: CANNOT OPEN outfile %s\n",filedefinitivo.c_str());
		return "";
	}
	
	uint64_t donesize=0;
	XXH3_state_t state128;
    (void)XXH3_128bits_reset(&state128);
	FILE* inFile = freadopen(i_infile.c_str());
	if (inFile==NULL)
	{
#ifdef _WIN32
		int err=GetLastError();
#else
		int err=1;
#endif // corresponds to #ifdef (#ifdef _WIN32)
		myprintf("\n");
		myprintf("01054: ERR <%s> kind %d\n",i_infile.c_str(),err);
		fclose(outFile);
		return "";
	}

	if (i_append)
	{
		if (flagdebug2)
			myprintf("01055: Seeking input to %s because of -append\n",migliaia(dimensioneoutput));
		if (fseeko(inFile,dimensioneoutput, SEEK_SET)!=0)
		{
#ifdef _WIN32
			int err=GetLastError();
#else
			int err=1;
#endif // corresponds to #ifdef (#ifdef _WIN32)
			myprintf("\n");
			myprintf("01056: seek ERR <%s> kind %d\n",i_infile.c_str(),err);
			fclose(outFile);
			fclose(inFile);
			return "";
		}

	}
	size_t readSize;
	int64_t startcopy=mtime();
	bool	hostampato=false;
	
/*	
	if (g_ioBUFSIZE==4096)
		g_ioBUFSIZE=1048576;
*/
	unsigned char *buffer=(unsigned char*)franz_malloc(g_ioBUFSIZE);
	///g_allocatedram+=g_ioBUFSIZE;

	if (buffer==NULL)
	{
		myprintf("01057: GURU allocating io buf of size %s\n",g_ioBUFSIZE);
		seppuku();
		fclose(outFile);
		fclose(inFile);
		return "";
	}
	if (flagdebug3)
		myprintf("01058: Buffer size %s\n",migliaia(g_ioBUFSIZE));
	

	while (!feof(inFile) && !ferror(inFile))
	{
		readSize = fread(buffer, 1, g_ioBUFSIZE, inFile);
		if (readSize == 0)
			break;
			
		int64_t bytesToWrite = readSize;
		
		// Maximum output limit check
		if (i_maxoutputsize > 0)
		{
			if (uint64_t(donesize + readSize) > i_maxoutputsize)
			{
				bytesToWrite = i_maxoutputsize - donesize;
				if (bytesToWrite <= 0)
					break;
			}
		}
		
		int64_t written = fwrite(buffer, 1, bytesToWrite, outFile);
		
		// Check complete write
		if (written != bytesToWrite)
		{
			color_red();
			myprintf("Write error: expected %lld, wrote %lld bytes\n", bytesToWrite, written);
			color_restore();
			break;
		}
		
		donesize += written;
		
		if (!i_append && i_verify)
			(void)XXH3_128bits_update(&state128, buffer, readSize);
			
		if (!flagnoeta)
			hostampato |= myavanzamentoby1sec(donesize, bytestoappend, startcopy, false);
		
		// If we have reached the maximum limit, exit
		if ((i_maxoutputsize > 0) && (donesize >= i_maxoutputsize))
			break;
	}

	if (hostampato)
	{
		printbar(' ');
		myprintf("\r");
	}
	if (flagdebug2)
	{
		myprintf("01059: Done\n");
		myprintf("01060: Written  %20s\n",migliaia(donesize));
		myprintf("01061: Expected %20s\n\n",migliaia(bytestoappend));
	}
	fclose(outFile);
	
	if (buffer!=NULL)
	{
		franz_free(buffer);
		buffer=0;
	}
	if (donesize!=(uint64_t)bytestoappend)
	{
		myprintf("01062: GURU bytes written does not match expected\n");
		fclose(inFile);
		return "";
	}

	dimensioneoutput	=prendidimensionefile(filedefinitivo.c_str());


	if (larghezzain!=dimensioneoutput)
	{
		myprintf("01063: GURU input size %s != output size %s\n",migliaia(larghezzain),migliaia2(dimensioneoutput));
		fclose(inFile);
		return "";
	}

	if (i_verify)
	{
		if (!flagnoeta)
		{
			///printbar('=');
			myprintf("01064: XXH3 verify of %Z\n",filedefinitivo.c_str());
		}
		if  (i_append)
		{
			if (flagdebug2)
				myprintf("01066: Full re-read, because of -append\n");
			fseeko(inFile,0,SEEK_SET);
			donesize=0;
			bytestoappend=prendidimensionehandle(inFile);
			startcopy=mtime();
			while ((readSize = fread(buffer, 1, g_ioBUFSIZE, inFile)) > 0)
			{
				donesize+=readSize;
				(void)XXH3_128bits_update(&state128, buffer, readSize);
				if (!flagnoeta)
					myavanzamentoby1sec(donesize,bytestoappend,startcopy,false);
			}
		}

		XXH128_hash_t myhash=XXH3_128bits_digest(&state128);
		char risultato[33];
		snprintf(risultato,sizeof(risultato),"%s",bin2hex_128(myhash.high64,myhash.low64).c_str());
		int64_t startverify=mtime();

		g_dimensione=0;
		if (flagdebug3)
			myprintf("01067: franz_do_hash\n");

		franz_do_hash dummy("XXH3");
		if (flagdebug3)
			myprintf("01068: filehash on %s\n",filedefinitivo.c_str());

		string hashreloaded=dummy.filehash(0,filedefinitivo,false,startverify,larghezzain);


		if (flagverbose || flagdebug)
		{
			myprintf("01069: Expected   XXH3 hash of the output file %s\n",risultato);
			myprintf("01070: Calculated XXH3 hash of the output file %s\n",hashreloaded.c_str());
		}
		if (hashreloaded!=risultato)
		{
			myprintf("01071: GURU hash of output file does not match!\n");
			fclose(inFile);
			return "";
		}
	}

	fclose(inFile);

	return filedefinitivo;
}
bool isjolly(const string& i_filename)
{
	return strrchr(i_filename.c_str(),'?');
}

int Jidac::trim()
{
	if (g_password)
	{
		myprintf("60290! Cannot trim with encryption, sorry\n");
		return 2;
	}
	if (files.size()!=1)
	{
		myprintf("01072! TRIM works with ONLY one single .zpaq file (no multipart)\n");
		return 2;
	}
	if (isjolly(files[0]))
	{
		if (flagdebug)
			myprintf("59604: Jolly founded => multipart trim\n");
		return fix(files[0]);
	}

	if (tofiles.size()>1)
	{
		myprintf("01073! TROM -to with only ONE output, please\n");
		return 2;
	}
	archive=files[0];  // append ".zpaq" to archive if no extension
	if (!iszpaq(archive))
			archive+=".zpaq";
	myprintf("01074: TRIMMING on %s\n",archive.c_str());
	int64_t archivesize=prendidimensionefile(archive.c_str());
  // Read archive or index into ht, dt, ver.
	int errors=0;
	string arcname=archive;  // input archive name
	if (index)
		arcname=index;
	int64_t header_pos=0;
	if (exists(subpart(arcname, 1)))
		header_pos=read_archive(NULL,arcname.c_str(), &errors);
  // Set arcname, offset, header_pos, and salt to open out archive
	arcname=archive;  // output file name
	int64_t offset=0;  // total size of existing parts
	char salt[32]={0};  // encryption salt
	if (g_password)
		libzpaq::random(salt, 32);
	
  // Remote archive
	if (index)
		error("33709: cannot trim with an index");
    string part0=subpart(archive, 0);
    if (part0!=archive)
	{  // multi-part?
		myprintf("01075! so sorry, this seems a multipart archive, abort\n");
		return 2;
    }
    // Get salt from first part if it exists
    if (g_password) {
      FP fp=myfopen(subpart(archive, 1).c_str(), RB);
      if (fp==FPNULL) {
        if (header_pos>32) error("archive first part not found");
        header_pos=32;
      }
      else {
		  if (fp!=NULL)
		  {
			if (fread(salt, 1, 32, fp)!=32) error("cannot read salt");
			myfclose(&fp);
		  }
      }
    }
	if (!exists(arcname))
	{
		myprintf("01076! archive does not seems to exists %Z\n",arcname.c_str());
        ///fclose(fp);
		return 2;
	}
	if (header_pos+offset>archivesize)
	{
		myprintf("01078! invalid offset %s vs filesize %s\n",migliaia(header_pos+offset),migliaia2(archivesize));
        ///fclose(fp);
		return 2;
	}
	if (header_pos+offset==archivesize)
	{
		myprintf("01079: TRIM seems not necessary on size %s\n",migliaia(header_pos+offset));
        ///fclose(fp);
		return 1;
	}
	if (tofiles.size()==1)
	{
		string	trimmeddestination=tofiles[0];
		if (isdirectory(trimmeddestination))
		{
			myprintf("01080! error -to is a folder, must be a file\n");
			return 2;
		}
		if (!iszpaq(trimmeddestination))
			trimmeddestination+=".zpaq";
		if (!flagforce)
			if (!saggiascrivibilitacartella(trimmeddestination))
			{
				myprintf("01081! sorry -to folder seems not writeable. Use -force to bypass\n");
				return 2;
			}
		int64_t spaziolibero=0;
		spaziolibero=getfreespace(trimmeddestination);
		if (spaziolibero<archivesize)
		{
			myprintf("\n");
			printbar('*');
			myprintf("01082$ WARNING FREE SPACE SEEMS %s NEEDED %s\n",migliaia(spaziolibero),migliaia2(archivesize));
			printbar('*');
		}
		myprintf("01083: DOING COPY (before trimming)\n");
		string risultato;
		risultato=filecopy(
		true, // singlefile
		false, // append
		archive,trimmeddestination,
		flagverify, //verify
		true,  //donocheckspace
		false, ///overwrite
		0 ); //maxoutputsize
		if (risultato=="")
		{
			myprintf("01084! ERROR: %s\n",risultato.c_str());
			return 2;
		}
		arcname=risultato;
	}
	myprintf("01085: Trim %Z at offset %s + %s\n",arcname.c_str(),migliaia(header_pos), migliaia2(offset));
	if ((tofiles.size()==0) && (!flagkill))
	{
		myprintf("01087: dry run without -to: -kill to execute in-place\n");
		return 1;
	}
	if (truncate(arcname.c_str(),header_pos+offset))
	{
		myprintf("01088! something wrong in trimming\n");
		return 2;
	}
	int64_t nuovadim=prendidimensionefile(arcname.c_str());
	if (nuovadim==(header_pos+offset))
	{
		myprintf("01090: DONE on %Z (%s)\n",arcname.c_str(),migliaia(nuovadim));
		
	}
	return 0;
}
int Jidac::purgersync()
{

	myprintf("01091: PURGING RSYNC TEMPORARY FILES ");
	if (!flagkill)
			myprintf(" : DRY RUN (no -kill)");
	myprintf("\n");
	if (files.size()==0)
	{
		myprintf("01092: No folder selected\n");
		return 1;
	}
	DTMap	myedt;
	for (unsigned int i=0;i<files.size();i++)
	{
		myprintf("01093: SCAN FOLDER %02d %Z\n",i,files[i].c_str());
		scandir(false,myedt,files[i].c_str(),true);
	}
	eol();
	myprintf("01095: Files to be checked %s\n",migliaia(myedt.size()));
	int	erased=0;
	int tobeerased=0;
	for (DTMap::iterator p=myedt.begin(); p!=myedt.end(); ++p)
	{
		string	filename=p->first;
		myreplaceall(filename,"\\","/");
		string percorso=extractfilepath(filename);
		filename=extractfilename(filename);
		int		lunghezza=filename.length();
		if (lunghezza>10)
		{
			if (filename[0]=='.')
				if (filename[lunghezza-7]=='.')
				{
					string estensionefinale=myright(filename,6);
					bool	spazzatura=true;
					for (unsigned int i=0;i<estensionefinale.length();i++)
					{
						if ((!isdigit(estensionefinale[i])) && (!isalpha(estensionefinale[i])))
						{
							spazzatura=false;
							break;
						}
					}
					if (spazzatura)
					{
						string senzaestensione=myleft(filename,filename.length()-7);
						string estensione=prendiestensione(senzaestensione);
						if ((estensione.length()>0) && (estensione.length()<=4))
						{
							string filetobepurged=percorso+filename;
#if defined (_WIN32)
							myprintf("del ");
#else
							myprintf("rm ");
#endif // corresponds to #if (#if defined (_WIN32))
							myprintf("\"");
							printUTF8(filetobepurged.c_str());
							myprintf("\"");
							myprintf("\n");
							tobeerased++;
							if (flagkill)
							{
								myprintf("01096: Deleting...\n");
								if (delete_file(filetobepurged.c_str()))
										erased++;
							}
						}
					}
				}
		}
	}
	if (flagkill)
	{
		myprintf("01097: Erased  %08d / %08d\n",erased,tobeerased);
		if (tobeerased==erased)
			return 0;
		else
			return 1;
	}
	if (tobeerased>0)
		return 0;
	else
		return 2;
}
bool isfilesequal(string i_source,string i_destination,bool i_flagfast=false)
{
	if (i_source=="")
		return false;
	if (i_destination=="")
		return false;
	if ((isdirectory(i_source)) && (isdirectory(i_destination)))
		return true;
	if (!((   (!isdirectory(i_source)) && (!isdirectory(i_destination)) )))
		return false;
	if (!fileexists(i_source))
		return false;
	if (!fileexists(i_destination))
		return false;
	FILE* source_file = freadopen(i_source.c_str());
	if (source_file==NULL)
	{
#ifdef _WIN32
		int err=GetLastError();
#else
		int err=1;
#endif // corresponds to #ifdef (#ifdef _WIN32)
		myprintf("\n");
		myprintf("01098: ERR <%s> kind %d\n",i_source.c_str(),err);
		return false;
	}
	fseeko(source_file, 0, SEEK_END);
	int64_t sorgente_dimensione=ftello(source_file);
	fseeko(source_file, 0, SEEK_SET);
	FILE* destination_file = freadopen(i_destination.c_str());
	if (destination_file==NULL)
	{
#ifdef _WIN32
		int err=GetLastError();
#else
		int err=1;
#endif // corresponds to #ifdef (#ifdef _WIN32)
		myprintf("\n");
		myprintf("01099: ERR <%s> kind %d\n",i_destination.c_str(),err);
		fclose(source_file);
		return false;
	}
	fseeko(destination_file, 0, SEEK_END);
	int64_t destinazione_dimensione=ftello(destination_file);
	fseeko(destination_file, 0, SEEK_SET);
	if (i_flagfast)
	{
		if (sorgente_dimensione<destinazione_dimensione)
		{
			if (flagdebug)
				myprintf("01100: sorgente < destinazione\n");
			fclose(source_file);
			fclose(destination_file);
			return false;
		}
	}
	else
	{
		if (sorgente_dimensione!=destinazione_dimensione)
		{
			fclose(source_file);
			fclose(destination_file);
			return false;
		}
	}
	size_t const blockSize 			= 65536;
	unsigned char buffersource		[blockSize];
	unsigned char bufferdestination	[blockSize];
	size_t readsource;
	size_t readdestination;
	if ((uint64_t)sorgente_dimensione<blockSize*4)
		i_flagfast=false;
	if (i_flagfast)
	{
			if (flagdebug2)
				myprintf("01101: Do a fast check!\n");
			readsource 		= 	fread(buffersource, 		1, blockSize, source_file);
			readdestination	=	fread(bufferdestination, 	1, blockSize, destination_file);
			if (readsource!=readdestination)
			{
				if (flagdebug)
					myprintf("01102: head read source != read dest %s %s\n",migliaia(readsource),migliaia2(readdestination));
				fclose(source_file);
				fclose(destination_file);
				return false;
			}
			if (memcmp(buffersource, bufferdestination, readsource))
			{
				if (flagdebug)
					myprintf("01103: head failed mem compare\n");
				fclose(source_file);
				fclose(destination_file);
				return false;
			}
			fseeko(source_file, 		blockSize/2, SEEK_SET);
			fseeko(destination_file, 	blockSize/2, SEEK_SET);
			readsource 		= 	fread(buffersource, 		1, blockSize, source_file);
			readdestination	=	fread(bufferdestination, 	1, blockSize, destination_file);
			if (readsource!=readdestination)
			{
				if (flagdebug)
					myprintf("01104: body read source != read dest %s %s\n",migliaia(readsource),migliaia2(readdestination));
				fclose(source_file);
				fclose(destination_file);
				return false;
			}
			if (memcmp(buffersource, bufferdestination, readsource))
			{
				if (flagdebug)
					myprintf("01105: body failed mem compare\n");
				fclose(source_file);
				fclose(destination_file);
				return false;
			}
			fseeko(source_file, 		destinazione_dimensione-blockSize, SEEK_SET);
			fseeko(destination_file, 	destinazione_dimensione-blockSize, SEEK_SET);
			readsource 		= 	fread(buffersource, 		1, blockSize, source_file);
			readdestination	=	fread(bufferdestination, 	1, blockSize, destination_file);
			if (readsource!=readdestination)
			{
				if (flagdebug)
					myprintf("01106: tail read source != read dest %s %s\n",migliaia(readsource),migliaia2(readdestination));
				fclose(source_file);
				fclose(destination_file);
				return false;
			}
			if (memcmp(buffersource, bufferdestination, readsource))
			{
				if (flagdebug)
					myprintf("01107: tail failed mem compare\n");
				fclose(source_file);
				fclose(destination_file);
				return false;
			}
	}
	else
	{
		size_t readsource, readdestination;
		while (!feof(source_file) && !ferror(source_file) && !feof(destination_file) && !ferror(destination_file))
		{
			readsource = fread(buffersource, 1, blockSize, source_file);
			if (readsource == 0)
				break;
				
			readdestination = fread(bufferdestination, 1, blockSize, destination_file);
			
			if (readsource != readdestination)
			{
				// myprintf("01108: read source != read dest %s %s\n", migliaia(readsource), migliaia2(readdestination));
				fclose(source_file);
				fclose(destination_file);
				return false;
			}
			
			if (memcmp(buffersource, bufferdestination, readsource) != 0)
			{
				// myprintf("01109: failed mem compare\n");
				fclose(source_file);
				fclose(destination_file);
				return false;
			}
			
			// confrontatitotale += readsource;
		}

	}
	fclose(source_file);
	fclose(destination_file);
	if (flagdebug)
		if (i_flagfast)
			myprintf("01110: fast files ==\n");
	return true;
}
int Jidac::mycopy()
{
	myprintf("01111: Your friendly neighborhood cp/copy ");
	if (flagverify)
		myprintf(" without a trusting attitude (-verify) ");
	if (flagparanoid)
		myprintf(" no overwrite (-paranoid) ");
	myprintf("\n");
	if (files.size()==0)
	{
		myprintf("01112! No source files\n");
		return 2;
	}
	if (tofiles.size()!=1)
	{
		myprintf("01113! exactly one -to required\n");
		return 2;
	}
	string	todirectory=tofiles[0];
	if (!isdirectory(todirectory))
			todirectory+='/';
	if (!flagforce)
		if (!saggiascrivibilitacartella(todirectory))
		{
			myprintf("01114! sorry -to directory seems not writeable. Use -force to bypass\n");
			return 2;
		}
	vector<string> 	sourcelist;
	vector<int64_t> sourcesize;
	int64_t			totalsourcesize=0;
	for (unsigned int i=0;i<files.size();i++)
	{
		scandir(false,edt,files[i].c_str(),false);
		for (DTMap::iterator p=edt.begin(); p!=edt.end(); ++p)
		{
			if (!isdirectory(p->first))
			{
				sourcelist.push_back(p->first);
				sourcesize.push_back(p->second.size);
				totalsourcesize+=p->second.size;
			}
		}
	}
	eol();
	if (sourcelist.size()==0)
	{
		myprintf("01115! cannot build source file list\n");
		return 2;
	}
	int64_t spaziolibero=0;
	spaziolibero=getfreespace(todirectory);
	if (spaziolibero<totalsourcesize)
	{
		myprintf("\n");
		printbar('*');
		myprintf("01116$ WARNING FREE SPACE %s NEEDED %s\n",migliaia(spaziolibero),migliaia2(totalsourcesize));
		printbar('*');
		if (!flagspace)
		{
			myprintf("01117! quit because not enough space; -space to bypass\n");
			return 2;
		}
	}
	myprintf("01118:         Space needed             Space free\n");
	bool		allok=true;
	int64_t		totalwritten=0;
	int			fileswritten=0;
	for (unsigned int i=0;i<sourcelist.size();i++)
	{
		string 	filesource	=sourcelist[i];
		int64_t	filesize	=sourcesize[i];
		spaziolibero=getfreespace(todirectory);
		myprintf("%21s  %21s  %s\n",migliaia(filesize),migliaia2(spaziolibero),filesource.c_str());
		string risultato;
		risultato=filecopy(
		false, // not a single file, but a folder as output
		flagappend, // append
		filesource,todirectory,
		flagverify, //verify
		true,  //donocheckspace
		!flagparanoid, //overwrite
		0); //maxoutputsize
		if (risultato=="")
		{
			myprintf("01119: ERROR: %s\n",risultato.c_str());
			allok=false;
		}
		else
		{
			totalwritten+=prendidimensionefile(risultato.c_str());
			fileswritten++;
		}
	}
	printbar('-');
	myprintf("%21s   bytes output file\n",	migliaia(totalwritten));
	myprintf("%21s   bytes input  file\n",	migliaia(totalsourcesize));
	myprintf("%21s   files OK\n",			migliaia(fileswritten));
	myprintf("%21s   files expected\n",		migliaia(sourcelist.size()));
	if (totalwritten!=totalsourcesize)
	{
		myprintf("01120: Written %s != expected %s\n",migliaia(totalwritten),migliaia2(totalsourcesize));
		allok=false;
	}
	if (allok)
		return 0;
	else
		return	2;
}



#ifdef _WIN64

// Structure to hold information for a single paging file
struct PageFileInfo 
{
    char drive[4];
    ULONGLONG initialSize;
    ULONGLONG maxSize;
    ULONGLONG availableSpace;
    bool isAutoManaged;
};

// Funzione per ottenere lo spazio disponibile su un drive (es. "C:\")
ULONGLONG getAvailableDiskSpace(const char* drivePath) {
    ULARGE_INTEGER freeBytesAvailableToCaller;
    if (GetDiskFreeSpaceExA(drivePath, &freeBytesAvailableToCaller, NULL, NULL)) {
        return freeBytesAvailableToCaller.QuadPart;
    }
    return 0;
}

// Simplified estimate of the size of a system-managed page file ("AUTO")
// The actual Windows algorithm is more complex and depends on crash dump policies, etc..
ULONGLONG getSystemManagedPageFileSize(ULONGLONG availableDiskSpace, ULONGLONG totalRAM) {
    // Estimation rule: max 3 times the RAM or 1/8 of the free disk space, whichever is smaller.
    ULONGLONG ramBasedSize = totalRAM * 3;
    ULONGLONG diskBasedSize = availableDiskSpace / 8;
    
    // A page file cannot exceed 256 TB per volume
    ULONGLONG cap = 256ULL * 1024 * 1024 * 1024 * 1024;

    return std::min({ramBasedSize, diskBasedSize, cap});
}
int parsePageFiles(const char* multiSzValue, std::vector<PageFileInfo>& pageFiles) {
    const char* currentString = multiSzValue;
    
    // Itera finché non incontra il doppio terminatore nullo (\0\0),
    // which manifests as an empty string.
    while (*currentString != '\0') {
        PageFileInfo info = {};
        char path[MAX_PATH];
        int initialMB = 0, maxMB = 0;

        // Try to read the line (e.g. "C:\pagefile.sys 1024 4096")
        int itemsScanned = sscanf(currentString, "%s %d %d", path, &initialMB, &maxMB);

        if (itemsScanned >= 1) {
            strncpy(info.drive, path, 3);
            info.drive[3] = '\0'; // Ensure termination
            
            info.initialSize = (ULONGLONG)initialMB * 1024 * 1024;
            info.maxSize = (ULONGLONG)maxMB * 1024 * 1024;
            
            // "0 0" means managed by the system
            info.isAutoManaged = (initialMB == 0 && maxMB == 0);

            char drivePath[5];
            sprintf(drivePath, "%s\\", info.drive);
            info.availableSpace = getAvailableDiskSpace(drivePath);
            
            pageFiles.push_back(info);
        }

        // --- KEY POINT ---
        // Move the pointer to the next string in the REG_MULTI_SZ buffer.
        currentString += strlen(currentString) + 1;
    }
    return pageFiles.size();
}



ULONGLONG getwifesize() {
    MEMORYSTATUSEX statex;
    statex.dwLength = sizeof(statex);
    if (!GlobalMemoryStatusEx(&statex)) {
        myprintf("Errore: impossibile ottenere lo stato della memoria.\n");
        return 0;
    }

    ULONGLONG totalRAM = statex.ullTotalPhys;
    ULONGLONG commitLimit = totalRAM; // The base is always the physical RAM

    HKEY hKey;
    const char* regPath = "SYSTEM\\CurrentControlSet\\Control\\Session Manager\\Memory Management";
    if (RegOpenKeyExA(HKEY_LOCAL_MACHINE, regPath, 0, KEY_READ, &hKey) == ERROR_SUCCESS) {
        
        char pagingFilesValue[8192]; // Larger buffer per sicurezza
        DWORD size = sizeof(pagingFilesValue);
        
        if (RegQueryValueExA(hKey, "PagingFiles", NULL, NULL, (LPBYTE)pagingFilesValue, &size) == ERROR_SUCCESS) {
            
            std::vector<PageFileInfo> pageFiles;
            int pageFileCount = parsePageFiles(pagingFilesValue, pageFiles);

            myprintf("Extimating commit limit\n");
            myprintf("- RAM            : %s\n", tohuman(totalRAM));
            myprintf("- Paging         :\n");

            if (pageFileCount > 0) {
                for (int i = 0; i < pageFileCount; i++) {
                    ULONGLONG pageFileContribution = 0;
                    
                    if (pageFiles[i].isAutoManaged) {
                        pageFileContribution = getSystemManagedPageFileSize(pageFiles[i].availableSpace, totalRAM);
                        myprintf("  - Drive %s (AUTO)  : max extimated  %10s (avail: %10s)\n",
                                 pageFiles[i].drive,
                                 tohuman(pageFileContribution),
                                 tohuman2(pageFiles[i].availableSpace));
                    } else {
                        // For a fixed file, the size is its defined maximum...
                        pageFileContribution = pageFiles[i].maxSize;
                        // ...but cannot exceed the physical space available on the disk.
                        if (pageFileContribution > pageFiles[i].availableSpace) {
                            pageFileContribution = pageFiles[i].availableSpace;
                        }
                        myprintf("  - Drive %s (FIXED) : max extimated  %10s (avail: %10s)\n",
                                 pageFiles[i].drive,
                                 tohuman(pageFiles[i].maxSize),
                                 tohuman2(pageFiles[i].availableSpace));
                    }
                    commitLimit += pageFileContribution;
                }
            } else {
                myprintf("  - No pagin file whatsoever\n");
            }
        }
        RegCloseKey(hKey);
    } else {
        myprintf("57011! Cannot read registry, only RAM (user too weak?)\n");
    }

    printbar('-');
	if (flagverbose)
		myprintf("Commit limit on virtual memory: %s\n", tohuman(commitLimit));

    return commitLimit;
}
#endif


/*
	This function is rather tricky: report the "just about free" memory of the system.
	It depends on both the operating system and the compiler (and architecture)
	It is needed for the -ramdisk switch
	If you have compiling problems, for example because you are using a "strange" system,
	just change the source code to return 0;
	As today tested on (64 bit)
	- Windows
	- FreeBSD
	- OpenBSD 6.6/7.1
	- Debian
	- Solaris 11
	- OmniOS
	- MacOS 11
	- Haiku R1/beta4
*/
#ifdef __HAIKU__
int64_t internal_getramdisksize()
{
	if (flagdebug2)
		myprintf("01121: Haiku pagesize %s!\n",migliaia(B_PAGE_SIZE));
	system_info haikuinfo;
	get_system_info(&haikuinfo);
	/*
	uint64_t totali=haikuinfo.max_pages*B_PAGE_SIZE;
	uint64_t usate=haikuinfo.used_pages*B_PAGE_SIZE;

	myprintf("01122: Totali %s\n",migliaia(totali));
	myprintf("01123: Usate  %s\n",migliaia(usate));

	myprintf("01124: cpu  %d\n",haikuinfo.cpu_count);
	myprintf("01125: free      %s\n",migliaia(haikuinfo.free_memory));
	*/
	return haikuinfo.free_memory;
}
#endif // corresponds to #ifdef (#ifdef __HAIKU__)

#ifdef _WIN32
int64_t internal_getramdisksize()
{
	if (flagdebug2)
		myprintf("01126: Hello Windows\n");
	MEMORYSTATUSEX statex;
	statex.dwLength=sizeof(statex);
	if (GlobalMemoryStatusEx(&statex))
		return statex.ullAvailPhys;
	return 0;
}
#endif // corresponds to #ifdef (#ifdef _WIN32)
#ifdef SOLARIS
//this is a reworked m_sunos5.c machine-specific top source code
// need a -lkstat to build
#include <kvm.h>
#include <kstat.h>
int64_t internal_getramdisksize()
{
	if (flagdebug2)
		myprintf("01127: Hello Solaris\n");
	long freemem;
    static kstat_t 		*ks = NULL;
	kvm_t 				*kd;
	static kstat_ctl_t 	*kc = NULL;
    kstat_named_t 		*kn;
    /* total comes from sysconf */
    ///*freemem = sysconf(_SC_PHYS_PAGES);
	if ((kc=kstat_open()) == NULL)
		error("36416: unable to open kstat");
// Solaris compilers does not like some "direct assign", firing warnings
// So this seems ugly, but for a reason
	char	p_unix			[100];
	char	p_system_pages	[100];
	char	p_freemem		[100];
	snprintf(p_unix,sizeof(p_unix),"unix");
	snprintf(p_system_pages,sizeof(p_system_pages),"system_pages");
	snprintf(p_freemem,sizeof(p_freemem),"freemem");
	ks = kstat_lookup(kc, p_unix, 0, p_system_pages);
	if (ks==NULL)
		error("36340: ks is null, quit");
	if (kstat_read(kc,ks,0)!=-1)
	{
		kn=(kstat_named_t*)kstat_data_lookup(ks, p_freemem);
		if (kn!=NULL)
			freemem=(long)(kn->value.ui32);
		else
			error("36440: guru on kstat lookup");
	}
	else
		error("36443: guru on kstat_read");
// yes, skip overflow on "strange" compilators. Slow, but who cares?
	int pagesize 			= getpagesize();
	int64_t big_pagesize 	= pagesize;
	int64_t big_freemem		= freemem;
	int64_t	big_ram	=big_freemem*big_pagesize;
	return big_ram;
}
#endif // corresponds to #ifdef (#ifdef SOLARIS)
#ifdef __OpenBSD__  // OpenBSD is not == FreeBSD.
int64_t internal_getramdisksize()
{
	if (flagdebug2)
		myprintf("01128: Hello OpenBSD\n");
	static int uvmexp_mib[] = {CTL_VM, VM_UVMEXP};
	struct uvmexp uvmexp;
	size_t size;
	size = sizeof(uvmexp);
	if (sysctl(uvmexp_mib, 2, &uvmexp, &size, NULL, 0) == -1)
		error("36445 sysctl failed");
	int pagesize = getpagesize();
	// yes, skip overflow on "strange" compilators. Slow, but who cares?
	int64_t	big_pagesize	=pagesize;
	int64_t big_free		=uvmexp.free;
	int64_t	big_ram			=big_pagesize*big_free;
	return big_ram;
}
#endif // corresponds to #ifdef (#ifdef __OpenBSD__  // OpenBSD is not == FreeBSD.)
#ifdef __APPLE__ // Mac OS/X
#include <mach/mach.h>
int64_t internal_getramdisksize()
{
	if (flagdebug2)
		myprintf("01129: Hello Mac\n");
	kern_return_t	status;
	unsigned int count = HOST_VM_INFO_COUNT;
	static vm_statistics_data_t	vm_stats;
	status = host_statistics(mach_host_self(), HOST_VM_INFO,(host_info_t)&vm_stats, &count);
	if(status!=KERN_SUCCESS)
		error("36487:  vm_statistics() failed");
	int pagesize = getpagesize();
	int64_t	big_pagesize	=pagesize;
	int64_t big_free		=vm_stats.free_count;
	int64_t	big_ram			=big_pagesize*big_free;
	return big_ram;
}
#endif // corresponds to #ifdef (#ifdef __APPLE__ // Mac OS/X)
#ifdef BSD  // FreeBSD
#ifndef __OpenBSD__ 	// OpenBSD does not have sysctlbyname (yet)
#ifndef __APPLE__   	// Mac is different (of course)
int64_t internal_getramdisksize()
{
	if (flagdebug2)
		myprintf("01130: Hello FreeBSD\n");
	int pagesize	=0;
	int inactive	=0;
	int free		=0;
	size_t size 	= sizeof free;
	sysctlbyname("vm.stats.vm.v_free_count", &free, &size, NULL, 0);
	sysctlbyname("vm.stats.vm.v_inactive_count", &inactive, &size, NULL, 0);
	size = sizeof pagesize;
	sysctlbyname("vm.stats.vm.v_page_size", &pagesize, &size, NULL, 0);
	return (free+inactive)*pagesize;/// / 1024 ;
}
#endif // corresponds to #ifndef (#ifndef __APPLE__   	// Mac is different (of course))
#endif // corresponds to #ifndef (#ifndef __OpenBSD__ 	// OpenBSD does not have sysctlbyname (yet))
#endif // corresponds to #ifdef (#ifdef BSD  // FreeBSD)
/// play old "file-like", should work in just about all flavours of Linux
#ifdef __linux__
int64_t internal_getramdisksize()
{
	if (flagdebug2)
		myprintf("01131: Hello Linux\n");
    FILE *meminfo = fopen("/proc/meminfo", "r");
    if(meminfo == NULL)
	{
		myprintf("01132: error, cannot open /proc/meminfo, maybe I am NOT running on Linux?\n");
		return 0;
	}
    char line[256];
    while(fgets(line, sizeof(line), meminfo))
    {

        int ram;
		string linea=line;
		if (mypos("MemAvailable:",linea)!=-1)
		{
			if (flagdebug3)
				myprintf("01133: MemAvailable: |%s|\n",linea.c_str());
			string onlynumber="";
			for (unsigned int i=0;i<linea.size();i++)
				if (isdigit(linea[i]))
					onlynumber+=linea[i];
			if (flagdebug3)
				myprintf("01134: Onlynumber |%s|\n",onlynumber.c_str());
			ram=atoi(onlynumber.c_str());
			if (flagdebug3)
				myprintf("01135: Atoi  %s\n",migliaia(ram));
            fclose(meminfo);
			return ram*1024L;
		}
    }
    fclose(meminfo);
    myprintf("01136: invalid /proc/meminfo format\n");
	return 0;
}
#endif // corresponds to #ifdef (#ifdef __linux__)

#ifdef ZPAQFULL ///NOSFTPSTART
#ifdef _WIN64
size_t provaAllocazioneAdattiva(size_t stimaIniziale) 
{
    size_t dimensioneDaAllocare = stimaIniziale;
    uint8_t* buffer = nullptr;

    myprintf("70192: Allocating from                      %21s bytes...\n", migliaia(dimensioneDaAllocare));

    // Cicla finché non riusciamo ad allocare il buffer
    while (true) 
	{
        // Safety check: if the size has become 0, allocation is impossible.
        if (dimensioneDaAllocare == 0) 
		{
            myprintf("70203: wife-array failed!\n");
            break;
        }

        // 1. Attempt to allocate memory
        buffer = (uint8_t*)franz_malloc(dimensioneDaAllocare);

        // 2. Check the result
        if (buffer) 
		{
			color_green();
            myprintf("70210: Virtual memory allocation successful %21s bytes\n", migliaia(dimensioneDaAllocare));
			color_restore();
            franz_free(buffer); 
            break; // Esci dal ciclo
        } 
		else 
		{
            size_t dimensionePrecedente = dimensioneDaAllocare;
            dimensioneDaAllocare = (dimensioneDaAllocare * 9) / 10; // Riduci del 10%
			myprintf("70218:Failed at %21s => retrying with %21s\n",migliaia(dimensionePrecedente), migliaia2(dimensioneDaAllocare));
///getch();
        }
    }
	return dimensioneDaAllocare;
}
#endif
#endif //NOSFTPEND
int64_t getramdisksize()
{
#ifdef ZPAQFULL ///NOSFTPSTART
#ifdef _WIN64
	if (flagdebug)
	{
		myprintf("57430: ramsize     %s\n",migliaia(g_ramsize));
		myprintf("57431: flagramsize %d\n",(int)flagramsize);
	}
	if (flagramsize)
	{
		if (g_ramsize==0)
		{
			int64_t wifemem=getwifesize();
			myprintf("70177: Testing real commit limit from       %21s (%s)\n",migliaia(wifemem),tohuman(wifemem));
			int64_t maxram=provaAllocazioneAdattiva(wifemem);
			myprintf("70175: I think that max virtual memory is   %21s (%s)\n",migliaia(maxram),tohuman(maxram));
			return maxram;
		}
		else
			return g_ramsize;
	}
#endif
#endif ///NOSFTPEND
	return internal_getramdisksize(); /// if you get an error HERE substitute with return 0;
	///return 0;
}
/*
int contabit(unsigned int u)
{
	unsigned int uCount;
	uCount=u-((u >> 1) & 033333333333)-((u >> 2) & 011111111111);
	return ((uCount + (uCount >> 3)) & 030707070707) % 63;
}

int bittino(int i)
{
	i=~i;
	return contabit((i&(-i))-1);
}
*/

#ifdef ZPAQFULL ///NOSFTPSTART

/*
AUTOTEST file
https://github.com/fcorbelli/zpaqfranz/tree/main/AUTOTEST

This is a Windows binary test file

*/
/// splitted for old C++ compilers.
char extract_test1[]={"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"};
char extract_test2[]={"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"};
char extract_test3[]={"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"};
char extract_test4[]={"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"};
#endif ///NOSFTPEND

int Jidac::pause()
{
	int thekey=0;
	if (searchfrom!="")
	{
		if (flagdebug)
			myprintf("01137: searchfrom is <<%s>>\n",searchfrom.c_str());
		if (searchfrom.size()==1)
		{
			thekey=searchfrom[0];
			if (flagdebug)
				myprintf("01138: thekey is %d %c\n",thekey,thekey);
		}
		else
		{
			if (flagdebug)
				myprintf("01139: -find not 1 char long, ignoring!\n");
		}
	}
	if (menoenne>0)
	{
		unsigned int	secondi=1;
		while ((secondi<=menoenne) && (!iskeypressed(thekey)))
		{
			if( (flagcomment) && (versioncomment!=""))
				myprintf("01140: %s (%03d)\r",versioncomment.c_str(),(menoenne-secondi)+1);
			else
				myprintf("01140: Wait %03d seconds (or press any key)\r",(menoenne-secondi)+1);
			fflush(stdout);
			sleep(1);
			secondi++;
		}
		myprintf("\n");
		fflush(stdout);
	}
	else
	{
		myprintf("\n\n");
		
				
		
		if (thekey!=0)
			myprintf("01141: **** Hit the key %c to continue (beware of case) ****\n",thekey);
		else
		{
			if( (flagcomment) && (versioncomment!=""))
				myprintf("01143: %s\n",versioncomment.c_str());
			else
				myprintf("01142: **** Hit a key to continue ****\n");
		}
		while ((!iskeypressed(thekey)))
			sleep(1);

	///	mygetch(false);
	}
	return 0;
}

bool debugwritebuffertofile(string i_filename,const void* i_buffer,size_t i_size)
{
	if (i_buffer==NULL)
	{
		myprintf("01143: i_buffer null\n");
		seppuku();
		return false;
	}
	if (i_size==0)
	{
		myprintf("01144: i_size 0\n");
		seppuku();
		return false;
	}
	if (i_filename.size()<1)
	{
		myprintf("01145: i_filenamesize <1\n");
		seppuku();
		return false;
	}
	FILE* myfile=fopen(i_filename.c_str(),"wb");
	if (myfile==NULL)
	{
		myprintf("01146: cannot write on %s\n",i_filename.c_str());
		seppuku();
		return false;
	}
	fwrite(i_buffer,i_size,1,myfile);
	fclose(myfile);
	return true;
}

int Jidac::autotest()
{
	myprintf("01147: Self-test for correct internal functioning\n"); // for non-Intel CPU
	if (all)
		pc_info();

#ifdef ZPAQFULL ///NOSFTPSTART
#ifdef _WIN64

	if (flagdebug)
	{
		if (kickstart_resources("")==0)
			myprintf("60269: Kickstart OK\n");
		else
			myprintf("60271: Kickstart failed\n");
	}
#endif
#endif ///NOSFTPEND
	
	if (flagchecktxt)
		if (checktxt!="")
			return checkautotest(checktxt);
	
	int	chunksize=1000000;
	if (all)
		if (menoenne>=200000)
			chunksize=menoenne;
	uint8_t *buffer8bit=(uint8_t*)franz_malloc(chunksize*sizeof(uint8_t));
	///g_allocatedram+=chunksize*sizeof(uint8_t);
	if (buffer8bit==0)
	{
		myprintf("01148! GURU cannot alloc the buffer8bit\n");
		return 2;
	}
#ifndef ESX
	if (flagdebug)
		myprintf("01149: buffer8bit %s\n",migliaia(int64_t(buffer8bit)));
#endif
	// why this strange thing? Because we want to debug on BIG ENDIAN, of course
	uint32_t *buffer32bit = (uint32_t*)franz_malloc(chunksize*sizeof(uint32_t));
	///g_allocatedram+=chunksize*sizeof(uint32_t);
	if (buffer32bit==0)
	{
		franz_free(buffer8bit);
		myprintf("01150! GURU cannot alloc the buffer32bit\n");
		return 2;
	}
#ifndef ESX
	if (flagdebug)
		myprintf("01151: buffer32bit %s\n",migliaia(int64_t(buffer32bit)));
#endif

	int64_t startcalc=mtime();
	MAPPAAUTOCHECK myautocheck_map;
	hash_autocheck myblock;
	myblock.ok="93EA42CC35E379AD67927C4F3B7AB78EA038A7FD67D7B245975752FDF319B0A8C40E4F4AD30D9069CBB96777AE2CA6ED23A5FEB1DCF30487401317887E97584A";
	myblock.ok5="C73D8F890F181CE6EB9FF431E08828D6BADA50AC2427546BA10A8F8226F527850FB61E638F798CE86028248262DF17D77D9D00FA5FE5E6CE6C94267E1DC2E99C";
	myautocheck_map.insert(std::pair<string, hash_autocheck>("WHIRLPOOL",myblock));
	myblock.ok="B99C2AD7BDE24144";
	myblock.ok5="4755E237BAD15B4C";
	myautocheck_map.insert(std::pair<string, hash_autocheck>("HIGHWAY64",myblock));
	myblock.ok="794503BA1B12CF8848907AAF0F62A8C5";
	myblock.ok5="C4C97D024A5DDDC7609B799BDBC46492";
	myautocheck_map.insert(std::pair<string, hash_autocheck>("HIGHWAY128",myblock));
	
	myblock.ok="6F9B44DF54E86972F2873FEFEBB06BD7E29CF9C7DB71096FF0270D72726088EF";
	myblock.ok5="13F23C2D5C49147DB7B10C8D8923CB052C2B3E1FF3EED5681E4FD69F05FFA6FE";
	myautocheck_map.insert(std::pair<string, hash_autocheck>("HIGHWAY256",myblock));

	myblock.ok="5AF0D4BB454A7D349CE97EFAFFD93CAC3B200DF166BEB9BFE2EC1838F35396AD";
	myblock.ok5="61274278289E9F6233DF34ABB392AAFE03EE7CE9D77167F3A8D9CDE1AD9861C0";
	myautocheck_map.insert(std::pair<string, hash_autocheck>("BLAKE3",myblock));
	myblock.ok="0D26839A";
	myblock.ok5="72D31AD5";
	
	myautocheck_map.insert(std::pair<string, hash_autocheck>("CRC-32",myblock));
	myblock.ok="50CB8A6F";
	myblock.ok5="B6AFE183";
	myautocheck_map.insert(std::pair<string, hash_autocheck>("CRC-32C",myblock));
	myblock.ok="A245C815AD0C65DBBC48094B281B245A";
	myblock.ok5="2ECDDE3959051D913F61B14579EA136D";
	myautocheck_map.insert(std::pair<string, hash_autocheck>("MD5",myblock));
	myblock.ok="F1D057704157A6A69F4A6AF06321FF8EA57BC719D070B5E28A92E362D03F66AD";
	myblock.ok5="F0393FEBE8BAAA55E32F7BE2A7CC180BF34E52137D99E056C817A9C07B8F239A";
	myautocheck_map.insert(std::pair<string, hash_autocheck>("SHA-256-PUT",myblock));
	myblock.ok="F1D057704157A6A69F4A6AF06321FF8EA57BC719D070B5E28A92E362D03F66AD";
	myblock.ok5="F0393FEBE8BAAA55E32F7BE2A7CC180BF34E52137D99E056C817A9C07B8F239A";
	myautocheck_map.insert(std::pair<string, hash_autocheck>("SHA-256-WRITE",myblock));
	myblock.ok="A6F8AEA5086E5EEC6585ECCCE91901C7B810BD9A1EDD06CA0EE7DBF23AD773DE";
	myblock.ok5="034AF02F68F8874B6668CCBEE49143A64BE435610E1282D93BF35FD80ACCE1FB";
	myautocheck_map.insert(std::pair<string, hash_autocheck>("SHA-3",myblock));
	myblock.ok="CEFB9B8DD36BFE7EE6CB3B1E5E5CA8D259A53FFF";
	myblock.ok5="7BE07AAF460D593A323D0DB33DA05B64BFDCB3A5";
	myautocheck_map.insert(std::pair<string, hash_autocheck>("SHA1-PUT",myblock));
	myblock.ok="CEFB9B8DD36BFE7EE6CB3B1E5E5CA8D259A53FFF";
	myblock.ok5="7BE07AAF460D593A323D0DB33DA05B64BFDCB3A5";
	myautocheck_map.insert(std::pair<string, hash_autocheck>("SHA1-WRITE",myblock));
	/*
	myblock.ok="93EA42CC35E379AD67927C4F3B7AB78EA038A7FD67D7B245975752FDF319B0A8C40E4F4AD30D9069CBB96777AE2CA6ED23A5FEB1DCF30487401317887E97584A";
	myblock.ok5="C73D8F890F181CE6EB9FF431E08828D6BADA50AC2427546BA10A8F8226F527850FB61E638F798CE86028248262DF17D77D9D00FA5FE5E6CE6C94267E1DC2E99C";
	myautocheck_map.insert(std::pair<string, hash_autocheck>("WHIRLPOOL",myblock));
	*/
	myblock.ok="25F384F0514225C3878240045180B970";
	myblock.ok5="1C8288B6013152D97B4A5D7E6C7893D4";
	myautocheck_map.insert(std::pair<string, hash_autocheck>("XXH3",myblock));
	myblock.ok="996D383079195E18";
	myblock.ok5="E47599E7C7CEF609";
	myautocheck_map.insert(std::pair<string, hash_autocheck>("XXHASH64",myblock));
	myblock.ok5="E47599E7C7CEF609";
	myblock.ok="996D383079195E18";
	myautocheck_map.insert(std::pair<string, hash_autocheck>("XXHASH64Y",myblock));
	///myblock.ok="EMPTY";
	///myautocheck_map.insert(std::pair<string, hash_autocheck>("WHYHASH",myblock));
	if (flagdebug3)
		myprintf("01152: end of insert\n");

	XXH3_state_t state128;
	XXH3_128bits_reset(&state128);
	libzpaq::SHA1 sha1;
	libzpaq::SHA1 sha1put;
	libzpaq::SHA256 sha256put;
	libzpaq::SHA256 sha256write2;
	MD5 md5;
	SHA3 sha3;
	NESSIEstruct hasher;
	NESSIEinit(&hasher);
	blake3_hasher hasherblake3;
	blake3_hasher_init(&hasherblake3);
	uint32_t crc	=0;
	uint32_t crcc	=0;
	uint64_t myseed =0;
	XXHash64 myhash(myseed);
	XXH64_hash_t seme=0;
	XXH64_state_t* state = XXH64_createState();
	assert(state != NULL && "Out of memory!");
	XXH64_reset(state,seme);
	HighwayHashCat highway64state;
	uint64_t key[4] = {1, 2, 3, 4};
	HighwayHashCatStart(key,&highway64state);
	char buffer[256];
	int64_t	total_hashed=0;
	string outfolder="";
	string outfile;
	char mynomefile[260];
	unsigned int chunk=0;
	string extract1="";
	if (flagdebug3)
		myprintf("01153: end of init\n");
#ifdef ZPAQFULL ///NOSFTPSTART
	if (tofiles.size()==1)
	{
		outfolder=includetrailingbackslash(tofiles[0]);
#ifdef unix
		if (outfolder[0]!='/')
		{
			myprintf("01154! on non-Win full path required: -to /tmp/testfolder is OK    -to ./testdir NOT GOOD\n");
			franz_free(state);
			franz_free(buffer8bit);
			franz_free(buffer32bit);
			return 2;
		}
#endif // corresponds to #ifdef (#ifdef unix)
		if (flagdebug2)
			myprintf("01155: outfolder <<%s>>\n",outfolder.c_str());

		if (mypos(" ",outfolder)>=0)
		{
			myprintf("01156! -to folder cannot contain spaces\n");
			franz_free(state);
			franz_free(buffer8bit);
			franz_free(buffer32bit);
			return 2;
		}
		if (!saggiascrivibilitacartella(outfolder))
		{
			myprintf("01157! cannot write test data into -to\n");
			franz_free(state);
			franz_free(buffer8bit);
			franz_free(buffer32bit);
			return 2;
		}
		else
		{
			if (flagdebug3)
				myprintf("01158: saggiascrivibilitacartella OK |%s|\n",outfolder.c_str());
		}
		uint64_t tofoldersize		=0;
		uint32_t tofoldernumber		=0;
		uint32_t tofolderfolder		=0;
		uint32_t tofolderlongfiles	=0;
		if (getfoldersize(outfolder,tofoldersize,tofoldernumber,tofolderfolder,tofolderlongfiles))
		{
			if (flagdebug3)
				myprintf("01159: getfoldersize OK, tofoldersize %s\n",migliaia(tofoldersize));
			if (tofoldersize>0)
			{
				myprintf("01160! WARNING the folder <<%Z>>\n",outfolder.c_str());
				franz_free(state);
				franz_free(buffer8bit);
				franz_free(buffer32bit);
				return 1;
			}
		}
		else
		{
			if (flagdebug)
				myprintf("01162: getfoldersize failed!\n");
		}
		
		
		int64_t spazio=getfreespace(outfolder);
		if ((spazio/1000000000)<18)
			if (!flagspace)
			{
				myprintf("01163! You need at least 18GB free on %s (founded %s). Use -space to bypass\n",outfolder.c_str(),tohuman(spazio));
				franz_free(state);
				franz_free(buffer8bit);
				franz_free(buffer32bit);
				return 2;
			}

		///warning: string literal of length 198756 exceeds maximum length 65536 that C++ compilers are required to suppor
		extract1=extract_test1;
		if (extract1=="DEBIAN")
		{
			myprintf("\n\n");
			myprintf("01164: *** This seems Debian: sorry, cannot make FULL autotest on this platform\n");
			myprintf("01165: *** You need to download the full source code from github and manually\n");
			myprintf("01166: *** compile\n\n");
		}
		else
		{
			string extract2=extract_test2;
			string extract3=extract_test3;
			string extract4=extract_test4;
			const string extract_test=extract1+extract2+extract3+extract4;
			if (flagdebug3)
				myprintf("01167: extract_test size %s\n",migliaia(extract_test.size()));

			size_t 	the_file_len=mimesize(extract_test.c_str());

			if (flagdebug3)
				myprintf("01168: the_file_len %s\n",migliaia(the_file_len));

			char*	the_file;
			the_file=(char*)franz_malloc(the_file_len);
			///g_allocatedram+=the_file_len;
			if (the_file==NULL)
			{
				myprintf("01169! error in malloc\n");
				franz_free(state);
				franz_free(buffer8bit);
				franz_free(buffer32bit);
				return 2;
			}
#ifndef ESX
			if (flagdebug3)
				myprintf("01170: the_file alloc OK %s\n",migliaia(int64_t(the_file)));
#endif
			if (!mime2binary(extract_test.c_str(),(unsigned char *)the_file,the_file_len))
			{
				myprintf("01171! mime decoder kaputt!\n");
				franz_free(state);
				franz_free(the_file);
				franz_free(buffer8bit);
				franz_free(buffer32bit);
				return 2;
			}
			else
			{
				if (flagdebug3)
					myprintf("01172: mime decoder OK on extract_test %s\n",extract_test.c_str());
			}
			outfile=outfolder+"sha256.zpaq";
			myprintf("01173: Creating autotest folder in <<%Z>>\n",outfolder.c_str());
	#ifdef _WIN32
			std::wstring widename=utow(outfile.c_str());
			FILE* outFile=_wfopen(widename.c_str(), L"wb");
			if (flagdebug3)
				myprintf("01175: creato widename\n");
	#else
			FILE* outFile=fopen(outfile.c_str(),"wb");
			if (flagdebug3)
				myprintf("01176: fopen non wide\n");
	#endif // corresponds to #ifdef (#ifdef _WIN32)
			if (outFile==NULL)
			{
				myprintf("01177! CANNOT OPEN outfile %s\n",outfile.c_str());
				franz_free(state);
				franz_free(the_file);
				franz_free(buffer8bit);
				franz_free(buffer32bit);
				return 2;
			}
#ifndef ESX
			if (flagdebug3)
			{
				myprintf("01178: outFile handle %s\n",migliaia(int64_t(outFile)));
				myprintf("01179: sto per fare fwrite\n");
				myprintf("01180: the_file       %s\n",migliaia(int64_t(the_file)));
				myprintf("01181: the_file_len   %s\n",migliaia(int64_t(the_file_len)));
				myprintf("01182: outFile handle %s\n",migliaia(int64_t(outFile)));
			}
#endif
			unsigned int scritti=fwrite(the_file,1,the_file_len,outFile);
			if (flagdebug3)
				myprintf("01183: scritti %s\n",migliaia(scritti));
			fclose(outFile);
			if (flagdebug2)
				myprintf("01184: dopo fclose\n");
			if (scritti!=the_file_len)
			{
				myprintf("01185! error extracting file .zpaq written %s expected %s => %s\n",migliaia(scritti),migliaia2(the_file_len),outfile.c_str());
				franz_free(the_file);
				franz_free(buffer8bit);
				franz_free(buffer32bit);
				return 2;
			}
			if (flagdebug2)
				myprintf("01186: dimensione outfile %s\n",migliaia(prendidimensionefile(outfile.c_str())));
			franz_free(the_file);
		}
	}
#endif ///NOSFTPEND
	if (all)
	{
		for (int i=0;i<10;i++)
		{
			int64_t startiteration=mtime();
			myprintf("01187: Iteration %d/9 chunksize %12s                               \n",(int)i,migliaia(chunksize));
			
			populateRandom_xorshift128plus(buffer32bit, chunksize,324+i,4444+i);
			if (flagverbose)
			{
				myprintf("01188: King0  %08X\n",(uint32_t)buffer32bit[0]);
				myprintf("01189: King1  %08X\n",(uint32_t)buffer32bit[1]);
				myprintf("01190: King2  %08X\n",(uint32_t)buffer32bit[2]);
				myprintf("01191: King3  %08X\n",(uint32_t)buffer32bit[3]);
				myprintf("01192: King4  %08X\n",(uint32_t)buffer32bit[4]);
				myprintf("01193: King5  %08X\n",(uint32_t)buffer32bit[5]);
				myprintf("01194: King6  %08X\n",(uint32_t)buffer32bit[6]);
				myprintf("01195: King7  %08X\n",(uint32_t)buffer32bit[7]);
			}
// yes we want to check BIG/LITTLE ENDIAN too
#ifdef BIG
			/// explicit swap (debug) with TWO variables, slow but who cares?
			int j=0;
			while (j<chunksize)
			{
				uint32_t tempj=buffer32bit[j];
				uint32_t tempjpiuuno=buffer32bit[j+1];
				buffer32bit[j]=tempjpiuuno;
				buffer32bit[j+1]=tempj;
				j+=2;
			}
			if (flagverbose)
			{
				myprintf("01196: Queen0 %08X\n",(uint32_t)buffer32bit[0]);
				myprintf("01197: Queen1 %08X\n",(uint32_t)buffer32bit[1]);
				myprintf("01198: Queen2 %08X\n",(uint32_t)buffer32bit[2]);
				myprintf("01199: Queen3 %08X\n",(uint32_t)buffer32bit[3]);
				myprintf("01200: Queen4 %08X\n",(uint32_t)buffer32bit[4]);
				myprintf("01201: Queen5 %08X\n",(uint32_t)buffer32bit[5]);
				myprintf("01202: Queen6 %08X\n",(uint32_t)buffer32bit[6]);
				myprintf("01203: Queen7 %08X\n",(uint32_t)buffer32bit[7]);
			}
#endif // corresponds to #ifdef (#ifdef BIG)
			for (int j=0;j<chunksize;j++)
				buffer8bit[j]=(buffer32bit[j]) & 255;
// dirty trick for border bytes BIG/LITTLE
///double-check for a fake gcc warning. Not my fault...
			for (int j=chunksize-8;j<chunksize;j++)
			{
///				buffer8bit[j]=(uint8_t)77; /// You can get a fake compiler warning here
				memset(&buffer8bit[j],77,1);
			}
/*		
			char dummyname[200];
			snprintf(dummyname,sizeof(dummyname),"z:\\parte_%i.bin",i);
			string ttemp=dummyname;
			if (debugwritebuffertofile(ttemp,buffer8bit,chunksize))
				myprintf("01204: written on %s\n",ttemp.c_str());
*/			
			if (flagverbose)
			{
				printbar('=');
				myprintf("01205: The Spartans %d\n",i);
				for (int j=0;j<300;j++)
				{
					myprintf("%02X ",buffer8bit[j]);
					if ((j+1)%20==0)
						myprintf("\n");
				}
				printbar('=');
			}
			for (int k=0;k<(i+1)*777;k++)
			{
				total_hashed+=chunksize;
//  check the block deduplicator
				for (int j=0;j<300;j++)
					buffer8bit[j]++;
				if (outfolder!="")
				{
					chunk++;
					snprintf(mynomefile,sizeof(mynomefile),"%s%02d/%04d/%05d.dat",outfolder.c_str(),i,k,(int)chunk);
					makepath(mynomefile);
					if (chunk %100==0)
						myprintf("01206: Test file %s\r",mynomefile);
					FILE* myfile=fopen(mynomefile, "wb");
					if (myfile==NULL)
					{
						myprintf("01207: cannot write on %s\n",mynomefile);
						exit(0);
					}
					fwrite(buffer8bit, 1, chunksize, myfile);
					fclose(myfile);
				}

				XXH3_128bits_update(&state128, buffer8bit, chunksize);

				sha256write2.write((const char*)buffer8bit,chunksize);
				for (int64_t l=0;l<chunksize;l++)
					sha256put.put(*(buffer8bit+l));
				///for (int64_t l=0;l<chunksize;l++)
				///sha256write2.put(*(buffer8bit+l));
				md5.add((const char*)buffer8bit,chunksize);
				sha3.add((const char*)buffer8bit,chunksize);
				NESSIEadd((const unsigned char*)buffer8bit,chunksize*8,&hasher);
				blake3_hasher_update(&hasherblake3, (const char*)buffer8bit,chunksize);
				crc=crc32_16bytes((const char*)buffer8bit,chunksize, crc);
				crcc=crc32c(crcc,(const unsigned char*)buffer8bit,chunksize);
				myhash.add((const unsigned char*)buffer8bit,chunksize);
				sha1.write((const char*)buffer8bit,chunksize);
				for (int64_t l=0;l<chunksize;l++)
					sha1put.put(*(buffer8bit+l));
				XXH64_update(state, buffer8bit, chunksize);
				HighwayHashCatAppend((const uint8_t*)buffer8bit,chunksize,&highway64state);
			}
			chunksize/=3;
			int64_t elapsed	=(mtime()-startiteration)/1000;
			int hours 		= elapsed / 3600;
			int minutes 	= (elapsed % 3600) / 60;
			int secs 		= elapsed % 60;
			if (hours>99)
				hours=99;
		
			myprintf("56464: Iteration %02d Time %9s %02d:%02d:%02d",i+1,migliaia(mtime()-startiteration),hours,minutes,secs);
			eol();
			myprintf("\n");
		}
	}
	else
	{
		if ((unsigned int)menoenne>(unsigned int)chunksize)
		{
			myprintf("01208! -n too big, max %s\n",migliaia(sizeof(chunksize)));
			franz_free(buffer8bit);
			franz_free(buffer32bit);
			franz_free(state);
			return 2;
		}
		flagverbose=true;
		chunksize=5;
		if (menoenne>0)
			chunksize=menoenne;
		myprintf("01209: Quick check chunksize %d: ",chunksize);
		for (int j=0;j<chunksize;j++)
			buffer8bit[j]='A'+j;
		if (chunksize<62)
			for (int j=0;j<chunksize;j++)
				myprintf("%c",buffer8bit[j]);
		myprintf("\n");
		XXH3_128bits_update(&state128, buffer8bit, chunksize);
		md5.add((const char*)buffer8bit,chunksize);
		sha3.add((const char*)buffer8bit,chunksize);
		NESSIEadd((const unsigned char*)buffer8bit,chunksize*8,&hasher);
		blake3_hasher_update(&hasherblake3, (const char*)buffer8bit,chunksize);
		crc=crc32_16bytes ((const char*)buffer8bit,chunksize, crc);
		crcc=crc32c(crcc, (const unsigned char*)buffer8bit,chunksize);
		myhash.add((const unsigned char*)buffer8bit,chunksize);
		sha256write2.write((const char*)buffer8bit,chunksize);
		for (int64_t l=0;l<chunksize;l++)
			sha256put.put(*(buffer8bit+l));
		///for (int64_t l=0;l<chunksize;l++)
		///	sha256write2.put(*(buffer8bit+l));
		sha1.write((const char*)buffer8bit,chunksize);
		for (int64_t l=0;l<chunksize;l++)
			sha1put.put(*(buffer8bit+l));
		XXH64_update(state, buffer8bit, chunksize);
		HighwayHashCatAppend((const uint8_t*)buffer8bit,chunksize,&highway64state);

//		mywyhash=wyhash(buffer8bit,chunksize,0,_wyp);
	}
	if (flagdebug)
		myprintf("01210: myautocheck start\n");
	MAPPAAUTOCHECK::iterator a;

	a=myautocheck_map.find("HIGHWAY64");
	if (a==myautocheck_map.end())
		error("guru 52286 HIGHWAY64");
	uint64_t hash_64=HighwayHashCatFinish64(&highway64state);
	a->second.calculated=bin2hex_64(hash_64);


	a=myautocheck_map.find("HIGHWAY128");
	if (a==myautocheck_map.end())
		error("guru 52286 HIGHWAY128");
	uint64_t hash_128[2];
	HighwayHashCatFinish128(&highway64state,hash_128);
	a->second.calculated=binarytohex((const unsigned char*)hash_128,16);


	a=myautocheck_map.find("HIGHWAY256");
	if (a==myautocheck_map.end())
		error("guru 52286 HIGHWAY256");
	uint64_t hash_256[4];
	HighwayHashCatFinish256(&highway64state,hash_256);
	a->second.calculated=binarytohex((const unsigned char*)hash_256,32);



	a=myautocheck_map.find("SHA-3");
	if (a==myautocheck_map.end())
		error("guru 32469 SHA-3");
	a->second.calculated=sha3.getHash();
	a=myautocheck_map.find("MD5");
	if (a==myautocheck_map.end())
		error("guru 32476 MD5");
	a->second.calculated=md5.getHash();
	NESSIEfinalize(&hasher,(unsigned char*)buffer);
	a=myautocheck_map.find("WHIRLPOOL");
	if (a==myautocheck_map.end())
		error("guru 32484 WHIRLPOOL");
	a->second.calculated=binarytohex((const unsigned char*)buffer,64);
	XXH128_hash_t myhashres=XXH3_128bits_digest(&state128);
	a=myautocheck_map.find("XXH3");
	if (a==myautocheck_map.end())
		error("guru 32494 XXH3");
	a->second.calculated=bin2hex_128(myhashres.high64,myhashres.low64);
	uint8_t output[BLAKE3_OUT_LEN];
	blake3_hasher_finalize(&hasherblake3,output,BLAKE3_OUT_LEN);
	a=myautocheck_map.find("BLAKE3");
	if (a==myautocheck_map.end())
		error("guru 32494 BLAKE3");
	a->second.calculated=binarytohex((const unsigned char*)output,BLAKE3_OUT_LEN);

	memcpy(buffer,sha256put.result(), 32);
	a=myautocheck_map.find("SHA-256-PUT");
	if (a==myautocheck_map.end())
		error("guru 54599 SHA-256-PUT");
	a->second.calculated=binarytohex((const unsigned char*)buffer,32);

	memcpy(buffer,sha256write2.result(), 32);
	a=myautocheck_map.find("SHA-256-WRITE");
	if (a==myautocheck_map.end())
		error("guru 54390 SHA-256-WRITE");
	a->second.calculated=binarytohex((const unsigned char*)buffer,32);


	a=myautocheck_map.find("XXHASH64");
	if (a==myautocheck_map.end())
		error("guru 32494 XXHASH64");
	a->second.calculated=bin2hex_64(myhash.hash());
	memcpy(buffer,sha1.result(),20);
	a=myautocheck_map.find("SHA1-WRITE");
	if (a==myautocheck_map.end())
		error("guru 32494 SHA1-WRITE");
	a->second.calculated=binarytohex((const unsigned char*)buffer,20);
	memcpy(buffer,sha1put.result(),20);
	a=myautocheck_map.find("SHA1-PUT");
	if (a==myautocheck_map.end())
		error("guru 32494 SHA1-PUT");
	a->second.calculated=binarytohex((const unsigned char*)buffer,20);
	snprintf(buffer,sizeof(buffer),"%08X",crc);
	a=myautocheck_map.find("CRC-32");
	if (a==myautocheck_map.end())
		error("guru 32494 CRC-32");
	a->second.calculated=buffer;
	snprintf(buffer,sizeof(buffer),"%08X",crcc);
	a=myautocheck_map.find("CRC-32C");
	if (a==myautocheck_map.end())
		error("guru 32494 CRC-32C");
	a->second.calculated=buffer;
	XXH64_hash_t yann=XXH64_digest(state);
	a=myautocheck_map.find("XXHASH64Y");
	if (a==myautocheck_map.end())
		error("guru 32495 XXHASH64Y");
	a->second.calculated=bin2hex_64(yann);

	if (flagdebug3)
		myprintf("01211: end myautocheck\n");

	int64_t endtime=mtime();
	if (isbigendian())
		myprintf("01212: This seems a BIG ENDIAN CPU    (aka:'strange')\n");
	else
		myprintf("01213: This seems a LITTLE ENDIAN CPU (aka:'normal')\n");
	if (flagverbose)
	{
		printbar('-');
		
		
		if (chunksize==5)
		{
			int countok=0;
			int	countko=0;
			for (MAPPAAUTOCHECK::iterator p=myautocheck_map.begin(); p!=myautocheck_map.end(); ++p)
			{
				if (p->second.calculated==p->second.ok5)
				{
					countok++;
					color_green();
				}
				else
				{
					countko++;
					color_red();
				}
				myprintf("56585: CALC %15s: %s\n",p->first.c_str(),p->second.calculated.c_str());
				color_restore();
			}

			if (countok==5)
				color_green();
			else
				color_yellow();
			myprintf("56622: OK %d ERROR %d | use autotest -all for stronger (and longer) test\n",countok,countko);
			color_restore();

		}
		else
		{
			for (MAPPAAUTOCHECK::iterator p=myautocheck_map.begin(); p!=myautocheck_map.end(); ++p)
				myprintf("01214: CALC %15s: %s\n",p->first.c_str(),p->second.calculated.c_str());
		}
		printbar('-');
	}
	bool	allok=true;
	if (all)
	{
		for (MAPPAAUTOCHECK::iterator p=myautocheck_map.begin(); p!=myautocheck_map.end(); ++p)
			if (p->second.ok==p->second.calculated)
				myprintf("%15s : OK\n",p->first.c_str());
			else
			{
				color_red();
				myprintf("%15s : ERROR  OK %s CALCULATED %s\n",p->first.c_str(),p->second.ok.c_str(),p->second.calculated.c_str());
				color_restore();
				allok=false;
			}
	}
	myprintf("01215: Time %.2f seconds for bytes %s\n",(endtime-startcalc)*0.001,migliaia(total_hashed));
#ifdef ZPAQFULL ///NOSFTPSTART
	if (outfolder!="")
	{
		
		chunksize=1000000;
		
		for (unsigned int j=1;j<=15;j++)
		{
			snprintf(mynomefile,sizeof(mynomefile),"%sbigone%02d.big",outfolder.c_str(),j);
			FILE* myfile=fopen(mynomefile, "wb");
			if (myfile==NULL)
			{
				myprintf("01216: cannot write on %s\n",mynomefile);
				seppuku();
			}
			myprintf("01217: Big file %s ",mynomefile);
			for (unsigned int i=0;i<100;i++)
			{
				if (j==15)
					memset(buffer32bit,0,chunksize);
				else
				if (j%3==0)
					memset(buffer32bit,j,chunksize);
				else
					populateRandom_xorshift128plus(buffer32bit,chunksize,j+777+i,j+192+i);
				fwrite(buffer32bit,4,chunksize,myfile);
				if (i>0)
					if (i%10==0) myprintf("%02d ",i);
			}
			myprintf("\n");
			fclose(myfile);
		}


#ifdef _WIN32
		string linuxpath	=outfolder;
		outfolder			=linuxtowinpath(outfolder);
		string filebatch	=outfolder+"dotest.bat";
		char	barra='\\';
		string acapo="\r\n";
		
#else
		string filebatch	=outfolder+"dotest.sh";
		string linuxpath	=outfolder;
		char barra='/';
		string acapo="\n";
		
#endif // corresponds to #ifdef (#ifdef _WIN32)
		filebatch=nomefileseesistegia(filebatch);
		if (fileexists(filebatch))
			if (remove(filebatch.c_str())!=0)
			{
				myprintf("01218: Highlander batch  %s\n", filebatch.c_str());
				franz_free(buffer8bit);
				franz_free(buffer32bit);
				return 1;
			}
		if (flagdebug3)
			myprintf("01219: filebatch %s\n",filebatch.c_str());

		string filezpaq=outfolder+"testme.zpaq";
#ifdef _WIN32
		wchar_t myexepath[_MAX_PATH];
		GetModuleFileName(NULL,myexepath,_MAX_PATH);
		string myzpaqexe=wtou(myexepath);
		myzpaqexe=linuxtowinpath(myzpaqexe);
#else
		if (extract1=="DEBIAN")
		{
			myprintf("01220: Sorry, no full test on Debian allowed. Download and compile source from github\n");
			seppuku();
		}
		string myzpaqexe=my_realpath(zpaqfranzexename);
#endif // corresponds to #ifdef (#ifdef _WIN32)

		if (flagdebug2)
			myprintf("01221: myzpaqexe %s\n",myzpaqexe.c_str());

		FILE* batch=fopen(filebatch.c_str(), "wb");
		if (batch==NULL)
		{
			myprintf("01222: cannot write on %s\n",filebatch.c_str());
			seppuku();
		}
#ifndef ESX
		if (flagdebug2)
			myprintf("01223: batch FILE* %s\n",migliaia(int64_t(batch)));
#endif

#ifdef _WIN32
		fprintf(batch,"@echo OFF\r\n");
#endif // corresponds to #ifdef (#ifdef _WIN32)
		fprintf(batch,"\"%s\" x \"%ssha256.zpaq\" -space -to \"%ste\" %s",myzpaqexe.c_str(),outfolder.c_str(),outfolder.c_str(),acapo.c_str());
		fprintf(batch,"\"%s\" sum \"%ste\" -sha256 -rename -force -out \"%sout01.txt\"%s",myzpaqexe.c_str(),outfolder.c_str(),outfolder.c_str(),acapo.c_str());
	
		fprintf(batch,"\"%s\" a \"%s\" \"%s00\" -xxhash -comment \"xxhash\" %s",myzpaqexe.c_str(),filezpaq.c_str(),outfolder.c_str(),acapo.c_str());
		fprintf(batch,"\"%s\" a \"%s\" \"%s01\" -xxh3   -comment \"xxh3\" %s",myzpaqexe.c_str(),filezpaq.c_str(),outfolder.c_str(),acapo.c_str());
		fprintf(batch,"\"%s\" a \"%s\" \"%s02\" -sha1   -comment \"sha1\" %s",myzpaqexe.c_str(),filezpaq.c_str(),outfolder.c_str(),acapo.c_str());
		fprintf(batch,"\"%s\" a \"%s\" \"%s03\" -sha256 -comment \"sha256\" %s",myzpaqexe.c_str(),filezpaq.c_str(),outfolder.c_str(),acapo.c_str());
		fprintf(batch,"\"%s\" a \"%s\" \"%s04\" -sha3   -comment \"sha3\" %s",myzpaqexe.c_str(),filezpaq.c_str(),outfolder.c_str(),acapo.c_str());
		fprintf(batch,"\"%s\" a \"%s\" \"%s05\" -blake3 -comment \"blake3\" %s",myzpaqexe.c_str(),filezpaq.c_str(),outfolder.c_str(),acapo.c_str());
		fprintf(batch,"\"%s\" a \"%s\" \"%s06\" -md5    -comment \"md5\" %s",myzpaqexe.c_str(),filezpaq.c_str(),outfolder.c_str(),acapo.c_str());
		fprintf(batch,"\"%s\" a \"%s\" \"%s07\" -whirlpool -comment \"whirlpool\" %s",myzpaqexe.c_str(),filezpaq.c_str(),outfolder.c_str(),acapo.c_str());
		fprintf(batch,"\"%s\" a \"%s\" \"%s08\" -highway64 -comment \"high64\" %s",myzpaqexe.c_str(),filezpaq.c_str(),outfolder.c_str(),acapo.c_str());
		fprintf(batch,"\"%s\" a \"%s\" \"%s09\" -highway128 -comment \"high128\" %s",myzpaqexe.c_str(),filezpaq.c_str(),outfolder.c_str(),acapo.c_str());

		fprintf(batch,"\"%s\" x \"%s\" \"%s00%c0770%c00771.dat\" -space -to \"%sverifica\" %s",myzpaqexe.c_str(),filezpaq.c_str(),outfolder.c_str(),barra,barra,outfolder.c_str(),acapo.c_str());
		fprintf(batch,"\"%s\" sum \"%sverifica\" -sha256 -out \"%sout02.txt\"%s",myzpaqexe.c_str(),outfolder.c_str(),outfolder.c_str(),acapo.c_str());
		fprintf(batch,"\"%s\" t \"%s\" -until 10 -verify -out \"%sout03.txt\"%s",myzpaqexe.c_str(),filezpaq.c_str(),outfolder.c_str(),acapo.c_str());
		fprintf(batch,"\"%s\" v \"%s\" -all -out \"%sout04.txt\"%s",myzpaqexe.c_str(),filezpaq.c_str(),outfolder.c_str(),acapo.c_str());
		fprintf(batch,"\"%s\" w \"%s\" -all -test -checksum -verbose -out \"%sout05.txt\"%s",myzpaqexe.c_str(),filezpaq.c_str(),outfolder.c_str(),acapo.c_str());
		fprintf(batch,"\"%s\" p \"%s\" -verify -out \"%sout06.txt\"%s",myzpaqexe.c_str(),filezpaq.c_str(),outfolder.c_str(),acapo.c_str());

		string temp2=excludetrailingbackslash(outfolder);
		fprintf(batch,"\"%s\" x \"%s\" -to \"%sfranco\" -space -find \"%s\" -replace \"\" %s",myzpaqexe.c_str(),filezpaq.c_str(),linuxpath.c_str(),temp2.c_str(),acapo.c_str());

		fprintf(batch,"\"%s\" sum \"%sfranco/01\"  \"%sfranco/02\"  \"%sfranco/03\" \"%sfranco/04\" \"%sfranco/05\" \"%sfranco/06\" \"%sfranco/07\" \"%sfranco/08\" \"%sfranco/09\" -xxh3 -summary -out \"%sout07.txt\"%s",myzpaqexe.c_str(),
		linuxpath.c_str(),
		linuxpath.c_str(),
		linuxpath.c_str(),
		linuxpath.c_str(),
		linuxpath.c_str(),
		linuxpath.c_str(),
		linuxpath.c_str(),
		linuxpath.c_str(),
		linuxpath.c_str(),
		outfolder.c_str(),acapo.c_str());
		
		fprintf(batch,"\"%s\" a \"%schunk_????.zpaq\" \"%s00\" -key pippo -md5b      -chunk 200k -to \"./locale/00\" %s",myzpaqexe.c_str(),outfolder.c_str(),outfolder.c_str(),acapo.c_str());
		fprintf(batch,"\"%s\" a \"%schunk_????.zpaq\" \"%s01\" -key pippo -xxhashb   -chunk 200k -to \"./locale/01\" %s",myzpaqexe.c_str(),outfolder.c_str(),outfolder.c_str(),acapo.c_str());
		fprintf(batch,"\"%s\" a \"%schunk_????.zpaq\" \"%s02\" -key pippo -blake3    -chunk 200k -to \"./locale/02\" %s",myzpaqexe.c_str(),outfolder.c_str(),outfolder.c_str(),acapo.c_str());
		fprintf(batch,"\"%s\" a \"%schunk_????.zpaq\" \"%s03\" -key pippo -xxh3b     -chunk 200k -to \"./locale/03\" %s",myzpaqexe.c_str(),outfolder.c_str(),outfolder.c_str(),acapo.c_str());
		fprintf(batch,"\"%s\" a \"%schunk_????.zpaq\" \"%s04\" -key pippo -xxhashb   -chunk 500k -to \"./locale/04\" %s",myzpaqexe.c_str(),outfolder.c_str(),outfolder.c_str(),acapo.c_str());
		fprintf(batch,"\"%s\" a \"%schunk_????.zpaq\" \"%s05\" -key pippo -sha3b     -chunk 200k -to \"./locale/05\" %s",myzpaqexe.c_str(),outfolder.c_str(),outfolder.c_str(),acapo.c_str());
		fprintf(batch,"\"%s\" a \"%schunk_????.zpaq\" \"%s06\" -key pippo -whirlpool -chunk 200k -to \"./locale/06\" %s",myzpaqexe.c_str(),outfolder.c_str(),outfolder.c_str(),acapo.c_str());
		fprintf(batch,"\"%s\" a \"%schunk_????.zpaq\" \"%s07\" -key pippo -sha256b   -chunk 200k -to \"./locale/07\" %s",myzpaqexe.c_str(),outfolder.c_str(),outfolder.c_str(),acapo.c_str());
		fprintf(batch,"\"%s\" a \"%schunk_????.zpaq\" \"%s08\" -key pippo -xxhashb   -chunk 50k  -to \"./locale/08\" %s",myzpaqexe.c_str(),outfolder.c_str(),outfolder.c_str(),acapo.c_str());
		fprintf(batch,"\"%s\" a \"%schunk_????.zpaq\" \"%s09\" -key pippo -sha256    -chunk 50k  -to \"./locale/09\" %s",myzpaqexe.c_str(),outfolder.c_str(),outfolder.c_str(),acapo.c_str());

		fprintf(batch,"\"%s\" x \"%schunk_????.zpaq\" -space -key pippo  %s",
		myzpaqexe.c_str(),outfolder.c_str(),acapo.c_str());

		fprintf(batch,"\"%s\" sum \"%slocale\" -summary -out \"%sout08.txt\"%s",
		myzpaqexe.c_str(),outfolder.c_str(),outfolder.c_str(),acapo.c_str());


		fprintf(batch,"\"%s\" t \"%schunk_????.zpaq\" -key pippo -paranoid -to \"%skane\" -space -out \"%sout09.txt\" %s",myzpaqexe.c_str(),outfolder.c_str(),outfolder.c_str(),outfolder.c_str(),acapo.c_str());

		fprintf(batch,"echo errore >>\"%slocale%c04%c2229%c10000.dat\"%s",outfolder.c_str(),barra,barra,barra,acapo.c_str());
		fprintf(batch,"\"%s\" v \"%schunk_????.zpaq\" -key pippo -verbose -out \"%sout10.txt\"%s",myzpaqexe.c_str(),outfolder.c_str(),outfolder.c_str(),acapo.c_str());

		fprintf(batch,"\"%s\" c \"%slocale\" \"%sfranco\" -xxh3 -checksum -out \"%sout11.txt\"%s",myzpaqexe.c_str(),outfolder.c_str(),outfolder.c_str(),outfolder.c_str(),acapo.c_str());

		fprintf(batch,"\"%s\" backup \"%smultipart.zpaq\" \"%ste\" -only \"*te/0*\" -xxhashb    -key pippo %s",myzpaqexe.c_str(),outfolder.c_str(),outfolder.c_str(),acapo.c_str());
		fprintf(batch,"\"%s\" backup \"%smultipart.zpaq\" \"%ste\" -only \"*te/1*\" -md5b       -key pippo %s",myzpaqexe.c_str(),outfolder.c_str(),outfolder.c_str(),acapo.c_str());
		fprintf(batch,"\"%s\" backup \"%smultipart.zpaq\" \"%ste\" -only \"*te/2*\" -xxh3b      -key pippo %s",myzpaqexe.c_str(),outfolder.c_str(),outfolder.c_str(),acapo.c_str());
		fprintf(batch,"\"%s\" backup \"%smultipart.zpaq\" \"%ste\" -only \"*te/3*\" -sha256b    -key pippo %s",myzpaqexe.c_str(),outfolder.c_str(),outfolder.c_str(),acapo.c_str());
		fprintf(batch,"\"%s\" backup \"%smultipart.zpaq\" \"%ste\" -only \"*te/4*\" -sha3b      -key pippo %s",myzpaqexe.c_str(),outfolder.c_str(),outfolder.c_str(),acapo.c_str());
		fprintf(batch,"\"%s\" backup \"%smultipart.zpaq\" \"%ste\" -only \"*te/5*\" -blake3b    -key pippo %s",myzpaqexe.c_str(),outfolder.c_str(),outfolder.c_str(),acapo.c_str());
		fprintf(batch,"\"%s\" backup \"%smultipart.zpaq\" \"%ste\" -only \"*te/6*\" -sha1b      -key pippo %s",myzpaqexe.c_str(),outfolder.c_str(),outfolder.c_str(),acapo.c_str());
		fprintf(batch,"\"%s\" backup \"%smultipart.zpaq\" \"%ste\" -only \"*te/7*\" -whirlpool  -key pippo %s",myzpaqexe.c_str(),outfolder.c_str(),outfolder.c_str(),acapo.c_str());
		fprintf(batch,"\"%s\" backup \"%smultipart.zpaq\" \"%ste\" -only \"*te/8*\" -highway64  -key pippo %s",myzpaqexe.c_str(),outfolder.c_str(),outfolder.c_str(),acapo.c_str());
		fprintf(batch,"\"%s\" backup \"%smultipart.zpaq\" \"%ste\" -only \"*te/9*\" -highway128 -key pippo %s",myzpaqexe.c_str(),outfolder.c_str(),outfolder.c_str(),acapo.c_str());
		fprintf(batch,"\"%s\" backup \"%smultipart.zpaq\" \"%ste\" -only \"*te/A*\" -xxhash     -key pippo %s",myzpaqexe.c_str(),outfolder.c_str(),outfolder.c_str(),acapo.c_str());
		fprintf(batch,"\"%s\" backup \"%smultipart.zpaq\" \"%ste\" -only \"*te/B*\" -md5        -key pippo %s",myzpaqexe.c_str(),outfolder.c_str(),outfolder.c_str(),acapo.c_str());
		fprintf(batch,"\"%s\" backup \"%smultipart.zpaq\" \"%ste\" -only \"*te/C*\" -xxh3       -key pippo %s",myzpaqexe.c_str(),outfolder.c_str(),outfolder.c_str(),acapo.c_str());
		fprintf(batch,"\"%s\" backup \"%smultipart.zpaq\" \"%ste\" -only \"*te/D*\" -sha256     -key pippo %s",myzpaqexe.c_str(),outfolder.c_str(),outfolder.c_str(),acapo.c_str());
		fprintf(batch,"\"%s\" backup \"%smultipart.zpaq\" \"%ste\" -only \"*te/E*\" -sha3       -key pippo %s",myzpaqexe.c_str(),outfolder.c_str(),outfolder.c_str(),acapo.c_str());
		fprintf(batch,"\"%s\" backup \"%smultipart.zpaq\" \"%ste\" -only \"*te/F*\" -blake3     -key pippo %s",myzpaqexe.c_str(),outfolder.c_str(),outfolder.c_str(),acapo.c_str());

		fprintf(batch,"\"%s\" testbackup \"%smultipart.zpaq\" -paranoid -verify -key pippo -out \"%sout12.txt\" %s",myzpaqexe.c_str(),outfolder.c_str(),outfolder.c_str(),acapo.c_str());
		fprintf(batch,"\"%s\" x \"%smultipart_????????\" -key pippo -until 17 -space -to \"%sex_multipart\" %s",myzpaqexe.c_str(),outfolder.c_str(),outfolder.c_str(),acapo.c_str());
		fprintf(batch,"\"%s\" t \"%smultipart_????????\" -key pippo -until 17 -verify -to \"%sex_multipart\" -out \"%sout13.txt\" %s",myzpaqexe.c_str(),outfolder.c_str(),outfolder.c_str(),outfolder.c_str(),acapo.c_str());
		fprintf(batch,"\"%s\" t \"%smultipart_????????\" \"%ste\" -key pippo -checksum -out \"%sout14.txt\" %s",myzpaqexe.c_str(),outfolder.c_str(),outfolder.c_str(),outfolder.c_str(),acapo.c_str());

		fprintf(batch,"\"%s\" a \"%sbinary.zpaq\" \"%s00\" -xxhashb -frugal %s",myzpaqexe.c_str(),outfolder.c_str(),outfolder.c_str(),acapo.c_str());
		fprintf(batch,"\"%s\" a \"%sbinary.zpaq\" \"%s01\" -xxhashb -frugal %s",myzpaqexe.c_str(),outfolder.c_str(),outfolder.c_str(),acapo.c_str());
		fprintf(batch,"\"%s\" a \"%sbinary.zpaq\" \"%s02\" -xxhashb -frugal %s",myzpaqexe.c_str(),outfolder.c_str(),outfolder.c_str(),acapo.c_str());
		fprintf(batch,"\"%s\" a \"%sbinary.zpaq\" \"%s03\" -xxhashb -frugal %s",myzpaqexe.c_str(),outfolder.c_str(),outfolder.c_str(),acapo.c_str());
		fprintf(batch,"\"%s\" a \"%sbinary.zpaq\" \"%ssha256.zpaq\" -xxhashb -frugal %s",myzpaqexe.c_str(),outfolder.c_str(),outfolder.c_str(),acapo.c_str());
		fprintf(batch,"\"%s\" a \"%sbinary.zpaq\" \"%s04\" -xxhashb -frugal %s",myzpaqexe.c_str(),outfolder.c_str(),outfolder.c_str(),acapo.c_str());
		fprintf(batch,"\"%s\" a \"%sbinary.zpaq\" \"%s05\" -xxhashb -frugal %s",myzpaqexe.c_str(),outfolder.c_str(),outfolder.c_str(),acapo.c_str());
		fprintf(batch,"\"%s\" a \"%sbinary.zpaq\" \"%s06\" -xxhashb -frugal %s",myzpaqexe.c_str(),outfolder.c_str(),outfolder.c_str(),acapo.c_str());
		fprintf(batch,"\"%s\" a \"%sbinary.zpaq\" \"%s07\" -xxhashb -frugal %s",myzpaqexe.c_str(),outfolder.c_str(),outfolder.c_str(),acapo.c_str());
		fprintf(batch,"\"%s\" a \"%sbinary.zpaq\" \"%s09\" -xxhashb -frugal %s",myzpaqexe.c_str(),outfolder.c_str(),outfolder.c_str(),acapo.c_str());
		fprintf(batch,"\"%s\" a \"%sbinary.zpaq\" \"%s09\" -xxhashb -frugal %s",myzpaqexe.c_str(),outfolder.c_str(),outfolder.c_str(),acapo.c_str());
		
		fprintf(batch,"\"%s\" x \"%sbinary.zpaq\" -only \"*sha256.zpaq\" -space -find \"sha256.zpaq\" -replace \"restored.zpaq\" %s",myzpaqexe.c_str(),outfolder.c_str(),acapo.c_str());
		fprintf(batch,"\"%s\" sum \"%srestored.zpaq\" \"%ssha256.zpaq\" -stdout -pakka -noeta -out \"%sout15.txt\" %s",myzpaqexe.c_str(),outfolder.c_str(),outfolder.c_str(),outfolder.c_str(),acapo.c_str());
		fprintf(batch,"\"%s\" p \"%sbinary.zpaq\" -verify -out \"%sout16.txt\" %s",myzpaqexe.c_str(),outfolder.c_str(),outfolder.c_str(),acapo.c_str());
		fprintf(batch,"\"%s\" r \"%s04\" \"%slocale%c04\" -kill -out \"%sout17.txt\" %s",myzpaqexe.c_str(),outfolder.c_str(),outfolder.c_str(),barra,outfolder.c_str(),acapo.c_str());

		string onlylist="-only \"*05000.dat\" -only \"*06000.dat\" -only \"*15000.dat\" -only \"*00777.dat\" -only \"*00778.dat\" -only \"*02332.dat\" -only \"*04663.dat\" -only \"*07771.dat\" -only \"*11656.dat\" -only \"*16318.dat\" -only \"*21757.dat\" -only \"*34996.dat\"";
		
		fprintf(batch,"\"%s\" x \"%sbinary.zpaq\" -all %s -space -to \"%sex_binary\" %s",
		myzpaqexe.c_str(),outfolder.c_str(),onlylist.c_str(),outfolder.c_str(),acapo.c_str());

		fprintf(batch,"\"%s\" sum \"%sex_binary\" -summary -blake3 -out \"%sout18.txt\" %s",
		myzpaqexe.c_str(),outfolder.c_str(),outfolder.c_str(),acapo.c_str());
		
		fprintf(batch,"\"%s\" sum \"%slocale\" %s -summary -blake3 -out \"%sout19.txt\" %s",
		myzpaqexe.c_str(),outfolder.c_str(),onlylist.c_str(),outfolder.c_str(),acapo.c_str());

		fprintf(batch,"\"%s\" sum \"%s00\" \"%s01\" \"%s02\" \"%s03\" \"%s04\" \"%s05\" \"%s06\" \"%s07\" \"%s08\" \"%s09\" %s -summary -blake3 -out \"%sout20.txt\" %s",
		myzpaqexe.c_str(),
		outfolder.c_str(),
		outfolder.c_str(),
		outfolder.c_str(),
		outfolder.c_str(),
		outfolder.c_str(),
		outfolder.c_str(),
		outfolder.c_str(),
		outfolder.c_str(),
		outfolder.c_str(),
		outfolder.c_str(),
		onlylist.c_str(),
		outfolder.c_str(),acapo.c_str());

		for (unsigned j=1;j<=15;j++)
		fprintf(batch,"\"%s\" a \"%sthebigone.zpaq\" \"%sbigone%02d.big\" %s",myzpaqexe.c_str(),outfolder.c_str(),outfolder.c_str(),j,acapo.c_str());

		fprintf(batch,"\"%s\" x \"%sthebigone.zpaq\" -space -to \"%sex_bigone\" %s",myzpaqexe.c_str(),outfolder.c_str(),outfolder.c_str(),acapo.c_str());
		
		fprintf(batch,"\"%s\" sum \"%sex_bigone\" -summary -sha3 -out \"%sout21.txt\" %s",
		myzpaqexe.c_str(),outfolder.c_str(),outfolder.c_str(),acapo.c_str());
		
		string temp=excludetrailingbackslash(outfolder);
		fprintf(batch,"\"%s\" autotest -checktxt \"%s\" %s",myzpaqexe.c_str(),temp.c_str(),acapo.c_str());
		
		if (flagdebug3)
			myprintf("01224: before fclose\n");
		fclose(batch);
		if (flagdebug3)
			myprintf("01225: after fclose\n");

// ok we want the +x
#ifdef unix
		chmod(filebatch.c_str(),0700);
		if (flagdebug3)
			myprintf("01226: after chmod\n");
#endif // corresponds to #ifdef (#ifdef unix)
		myprintf("\n\n");
		myprintf("01227: The test batchfile is: %s\n",filebatch.c_str());
	}
#endif ///NOSFTPEND
#ifndef ESX
	if (flagdebug3)
		myprintf("01228: franz_free buffer8bit %s\n",migliaia(int64_t(buffer8bit)));
#endif

	franz_free(buffer8bit);
#ifndef ESX
	if (flagdebug3)
		myprintf("01229: franz_free buffer32bit %s\n",migliaia(int64_t(buffer32bit)));
#endif
	franz_free(buffer32bit);


	if (flagdebug2)
		myprintf("01230: allok %d\n",int(allok));
	if (allok)
		return 0;
	else
		return 2;
	return 0; // compiler be quiet
}
int Jidac::findj()
{
	if (files.size()==0)
	{
		myprintf("01231: no files selected to find\n");
		return 1;
	}
	if (files.size()==2)
	{
		myprintf("01232: magically search %s\n",files[1].c_str());
		onlyfiles.push_back(files[1]);
		files.pop_back();
	}
	if (files[0]==".")
		files[0]+='/';
	int64_t startscan=mtime();
	for (unsigned int i=0;i<files.size();i++)
		scandir(true,edt,files[i].c_str(),!flagnorecursion);
	eol();
	int64_t scantime=mtime()-startscan;
	if (flagverbose)
		myprintf("01233: Scantime %f\n",(scantime*0.001));
	int64_t 	howmany		=0;
	int64_t 	totalsize	=0;
	vector<DTMap::iterator> filelist;
	for (DTMap::iterator p=edt.begin(); p!=edt.end(); ++p)
	{
		bool flagshow=true;
		if (searchfrom!="")
			if (stristr(p->first.c_str(),searchfrom.c_str())==0)
				flagshow=false;
		if (g_datefrom>0)
			if ((p->second.date)<=g_datefrom)
				flagshow=false;
		if (g_dateto>0)
			if ((p->second.date)>=g_dateto)
				flagshow=false;
		if (maxsize>0)
			if (maxsize<(uint64_t)p->second.size)
				flagshow=false;
		if (minsize>0)
			if (minsize>(uint64_t)p->second.size)
				flagshow=false;
		if (flagshow)
		{
			filelist.push_back(p);
			howmany++;
			totalsize+=p->second.size;
		}
	}

///////// ext;size;name;hash;date;data
	if (orderby=="")
	{
		if ((g_datefrom>0) || (g_dateto>0))
			orderby+="date;";
		if ((maxsize>0) || (minsize>0))
			orderby+="size;";
	}
	if (orderby!="")
	{
		myprintf("01234: orderby |%s|\n",orderby.c_str());
		sort(filelist.begin(), filelist.end(), compareorderby);
	}
	for (unsigned int i=0;i<filelist.size();i++)
	{
		if (menoenne) /// list -n 10 => sort by size and stop at 10
			if (i>=menoenne)
				break;

		if (flagverbose)
			myprintf("%s %19s ",dateToString(flagutc,filelist[i]->second.date).c_str(),migliaia((int64_t)filelist[i]->second.size));
		printUTF8(filelist[i]->first.c_str());
		myprintf("\n");
	}


	if (howmany)
	{
		printbar('=');
		myprintf("01235: Files %s for %s bytes (%s)\n",migliaia((int64_t)howmany),migliaia((int64_t)totalsize),tohuman((int64_t)totalsize));
	}
	return 0;
}
///zpaqfranz isopen "C:\Users\utente\AppData\Roaming\Thunderbird\Profiles\to6z2c6f.default\ImapMail\imap.googlemail.com\INBOX"

#ifdef ZPAQFULL ///NOSFTPSTART
int Jidac::isopen()
{
	if (files.size()!=1)
	{
		myprintf("01236! for isopen() exactly 1 file needed\n");
		return 2;
	}
	if (!fileexists(files[0]))
	{
		myprintf("01237! file does not exists %Z\n",files[0].c_str());
		return 1;
	}

	if (isfileopen(files[0]))
	{
		myprintf("01239: file seems open %Z\n",files[0].c_str());
		return 1;
	}
	myprintf("01241: file is NOT open %Z\n",files[0].c_str());
	return 0;
}
#endif ///NOSFTPEND

/*
	Section: main
*/


/// control-c handler
void my_handler(int s)
{
	g_control_c=true;	// block open new files for write
	
	resetconsolecolor();
	fflush(stdout);
	myprintf("\n\n");
	myprintf("01250: CONTROL-C detected, try some housekeeping...\n");

#ifdef unix

	printf("\x1B[?25h");  // Show the cursor
    fflush(stdout);
#ifdef ZPAQFULL ///NOSFTPSTART
	if (g_dataset!="")
	{
		string 	destroy_diff2	=x_one("zfs destroy "	+g_tempsnapshot,"59870: Destroy diff snapshot (if any)");
		string 	destroy_base	=x_one("zfs destroy "	+g_basesnapshot,"59870: Destroy base snapshot (if any)");
		if (flagdebug)
		{
			myprintf("01251: %s\n",destroy_diff2.c_str());
			myprintf("01252: %s\n",destroy_base.c_str());
		}
		string 	take_base		=x_one("zfs snapshot "	+g_basesnapshot,"Taking base snapshot");
		if (flagdebug)
			myprintf("01253: %s\n",take_base.c_str());
	}
#endif ///NOSFTPEND
	// control-C in blind password
    struct termios tty;
    tcgetattr(STDIN_FILENO, &tty);
    tty.c_lflag |= ECHO;
    tcsetattr(STDIN_FILENO, TCSANOW, &tty);
#endif // corresponds to #ifdef (#ifdef unix)

	if (g_chunk_size>0)
	{
		printbar('-');
		myprintf("01254: OK we get a chunk size limit of %s on %s files\n",migliaia(g_chunk_size),migliaia2(g_addedchunklist.size()));
#ifndef ESX
		myprintf("01255: g_archivefp_first handle %21s\n",migliaia(int64_t(g_archivefp_first)));
		myprintf("01256: g_archivefp       handle %21s\n",migliaia(int64_t(g_archivefp)));
#endif
		if (g_write_fp.size()==2)
			if (g_write_fp[0]==g_archivefp_first)
				if (g_write_fp[1]==g_archivefp)
					myprintf("01257: archivefp/first match (this is good)\n");

		myprintf("01258: write pool before emergency close (should be 2 max 3)\n");
		vector<FP> fp_da_chiudere;
		for (unsigned int i=0;i<g_write_fp.size();i++)
		{
#ifndef ESX
			myprintf("01259: write pool %08d %21s %s\n",i,migliaia((int64_t)(g_write_fp[i])),g_write_filename[i].c_str());
#endif
			fp_da_chiudere.push_back(g_write_fp[i]);
		}
		printbar('-');
		
		if (fp_da_chiudere.size()>0)
		{
			myprintf("01260: Closing %08d handles\n",fp_da_chiudere.size());
			for (unsigned int i=0;i<fp_da_chiudere.size();i++)
			{
#ifndef ESX
				myprintf("01261: Closing (pool size %08d) FP %21s\n",g_write_fp.size(),migliaia(int64_t(fp_da_chiudere[i])));
#endif
				myfclose(&fp_da_chiudere[i]);
				if (flagdebug3)
				myprintf("01262: Now pool size is   %08d\n",g_write_fp.size());
			}
			if (g_write_fp.size()==0)
			myprintf("01263: Closing done, seems OK\n");
			else
			myprintf("01264: Closing done, something left\n");
		}
		
		if (g_write_fp.size()!=0)
		{
			printbar('-');
			myprintf("01265: write pool NOT empty (this could be bad)\n");
			myprintf("01266: [2] write pool after close size %08d (should be zero)\n",g_write_fp.size());
#ifndef ESX
			for (unsigned int i=0;i<g_write_fp.size();i++)
				myprintf("01267: write pool %08d %21s %s\n",i,migliaia((int64_t)(g_write_fp[i])),g_write_filename[i].c_str());
#endif
			printbar('-');
		}
	}


	bool flagalwayscheck=g_flagcreating;
	if (command=='Z')
		flagalwayscheck=true;

	if (g_chunk_size>0)
	{
		unsigned int deleted	=0;
		unsigned int expected	=0;

		myprintf("01268: Fixed-size chunk: (try) deleting all of them (should be %s)\n",migliaia(g_addedchunklist.size()-1));
		for (unsigned int i=0;i<g_addedchunklist.size();i++)
		{
			if (fileexists(g_addedchunklist[i]))
			{
				expected++;
				if (delete_file_no_mercy(g_addedchunklist[i].c_str()))
				{
					if (flagdebug3)
						myprintf("01269: Erased chunk %08d <<",i);
					deleted++;
				}
				else
				{
					myprintf("01270: *FAILED delete of %08d <<%Z>>\n",i,g_addedchunklist[i].c_str());
				}
			}
			else
			{
				if (flagdebug3)
					myprintf("01272: file not found to be killed %s\n",g_addedchunklist[i].c_str());
			}
		}
		if (expected==deleted)
			color_green();
		else
			color_red();
		myprintf("01273: Expected file %s deleted %s\n",migliaia(expected),migliaia2(deleted));
		color_restore();
	}
	else
	{
		if ((g_archivefp!=FPNULL) && (g_archivefp!=NULL))
		{
#ifndef ESX
			myprintf("01274: Closing file handle %s\n",migliaia(int64_t(g_archivefp)));
#endif
			myfclose(&g_archivefp);
#ifndef ESX
			myprintf("01275: myfclose done on archivefp now %s\n",migliaia(int64_t(g_archivefp)));
#endif
		}
		if ((g_archivefp_first!=FPNULL) && (g_archivefp_first!=NULL))
		{
#ifndef ESX
			myprintf("01276: Closing file handle first %s\n",migliaia(int64_t(g_archivefp_first)));
#endif
			myfclose(&g_archivefp_first);
#ifndef ESX
			myprintf("01277: myfclose done on archivefp_first now %s\n",migliaia(int64_t(g_archivefp_first)));
#endif
		}

		if (flagalwayscheck)
			if (fileexists(g_archive))
				if (prendidimensionefile(g_archive.c_str())>=0)
					{
						if (delete_file(g_archive.c_str()))
							myprintf("01278: Erased chunk <<%Z>>\n",g_archive.c_str());
						else
							myprintf("01279! *CANNOT DELETE* <<%Z>>\n",g_archive.c_str());
					}
		// we must trim the index too!
		if (!g_flagcreating)
		{
			int64_t newdim=prendidimensionefile(g_archive.c_str());
			if (newdim>g_starting_zpaqsize)
			{
				myprintf("01282: should roll back %s from %s to %s\n",g_archive.c_str(),migliaia(newdim), migliaia2(g_starting_zpaqsize));

///				if (truncate(g_archive.c_str(), g_starting_zpaqsize))
	///				printerr("61920",g_archive.c_str(),0);
		
				if (g_starting_zpaqdate>0)
				{
					if (flagdebug3)
					myprintf("01283: should touching back to %s\n",dateToString(false,g_starting_zpaqdate).c_str());
						
					///if (!touch(g_archive.c_str(),g_starting_zpaqdate,g_starting_zpaqattr))
						///myprintf("01284: WARNING trouble in touching\n");
				}
			}
		}
	}
	if (!flagnopid)
		if (g_pidname!="")
		{
			if (g_pid_handle!=0)
			{
				myprintf("01285: Closing pid handle\n");
				fclose(g_pid_handle);
			}
			if (delete_file(g_pidname.c_str()))
				myprintf("01286: Erased pid   <<%Z>>\n",g_pidname.c_str());
			else
				myprintf("01287! *FAILED* delete of <<%Z>>\n",g_pidname.c_str());
			
		}

	// 2==control-C (maybe)
	if (s==2)
	{
#ifdef ZPAQFULL ///NOSFTPSTART
#ifdef _WIN32
		if (command=='q')
		{
			myprintf("01290: *** VSS RUNNING, DETACHING\n");
			vss_deleteshadows(linuxtowinpath(g_franzsnap));
		}
#endif // corresponds to #ifdef (#ifdef _WIN32)
#endif ///NOSFTPEND
		if ((!flagsilent) && (!flagnoconsole))
		{
			setupConsole();
			printf("\033[?25h");
			fflush(stdout);
			restoreConsole();
		}
	}

	color_restore();
#ifndef _WIN32
		fflush(stdout);
#endif // corresponds to #ifndef (#ifndef _WIN32)


	myprintf("\nGoodbye after %1.3f seconds (%s)\n",(mtime()-g_start)/1000.0,timetohuman((uint32_t)((mtime()-g_start)/1000.0)).c_str());
	exit(1);
}
// Convert argv to UTF-8 and replace \ with /
#ifdef unix
	int main(int argc, const char** argv)
	{
#else
	#ifdef _MSC_VER
		int wmain(int argc, LPWSTR* argw)
		{
	#else
		int main()
		{
			int argc=0;
			LPWSTR* argw=CommandLineToArgvW(GetCommandLine(), &argc);
	#endif // corresponds to #ifdef (#ifdef _MSC_VER)
	
#ifdef _WIN32
	/*
		Getting "real" Windows versions is a... real nightmare
		Nothing is easy, in Windows
		https://www.geoffchappell.com/studies/windows/km/ntoskrnl/inc/api/ntexapi_x/kuser_shared_data/index.htm
		The dirtiest trick: getting from KUSER_SHARED_DATA founded @ 0x7ffe0000 (!)
	*/
	BYTE* kusershareddata=(BYTE*)0x7FFE0000;
	if ((*(ULONG*)(kusershareddata+0x26c))>=10)
	{
		if (flagdebug)
			myprintf("01291: ************ Windows 10 or later => keeping flagnoconsole |%d|\n",int(flagnoconsole));
	}
	else
	{
		if (flagdebug)
			myprintf("01292: ************ Previous of Windows 10 => enforcing flagnoconsole=true\n");
		flagnoconsole=true;
	}
#endif // corresponds to #ifdef (#ifdef _WIN32)
	
///	This is Windows: take care of parameters
	vector<string> args(argc);
	libzpaq::Array<const char*> argp(argc);
	for (int i=0; i<argc; ++i)
	{
		args[i]=wtou(argw[i]);
		argp[i]=args[i].c_str();
	}
	const char** argv=&argp[0];
#endif // corresponds to #ifdef (#ifdef unix)
	pjidac=NULL;

	if (!isatty(fileno(stdout))) 
		flagnocolor=true;
		
	g_start=mtime();  		// get start time

#if (((!defined(NAS)) && (defined(ANCIENT))) || (defined(SOLARIS)))
#else
	signal (SIGINT,my_handler); // the control-C handler
#endif // corresponds to #if (#if (((!defined(NAS)) && (defined(ANCIENT))) || (defined(SOLARIS))))

#ifdef _WIN32
	if (!flagnoconsole)
	{
//// set UTF-8 for console
		g_ConsoleCP			=GetConsoleCP();
		g_ConsoleOutputCP	=GetConsoleOutputCP();

		SetConsoleCP		(65001);
		SetConsoleOutputCP	(65001);
	}
///	myprintf("01293: ConsoleCP %d ConsoleOutputCP %d\n",g_ConsoleCP,g_ConsoleOutputCP);
	OSVERSIONINFO vi;// = {0};
	vi.dwMajorVersion=0;
	vi.dwMinorVersion=0;
	vi.dwPlatformId=0;
	vi.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
	GetVersionEx(&vi);
	windows7_or_above = (vi.dwMajorVersion >= 6) && (vi.dwMinorVersion >= 1);
#endif // corresponds to #ifdef (#ifdef _WIN32)

//	infact unused, too slow
	g_sse42=false;

#if  defined(_WIN64)
    int sse42;
    SSE42(sse42);
	if (sse42)
		g_sse42=true;
#endif // corresponds to #if (#if  defined(_WIN64))

#ifdef _WIN32
	if (flagntfs)
		flagimage=true;
#endif

	if (argc == 2) 
	{
		const char* prefix = "seterrorlevel";
		size_t prefix_len = strlen(prefix);
		
		// Check that the argument starts with the prefix
		if (strncmp(argv[1], prefix, prefix_len) == 0) 
		{
			const char* input = argv[1] + prefix_len;
			
			int error_level = 0;
			int digit_count = 0;
			
			// Extract only the numeric digits, maximum 3
			while (*input && digit_count < 3) 
			{
				if (*input >= '0' && *input <= '9') 
				{
					error_level = error_level * 10 + (*input - '0');
					digit_count++;
				}
				input++;
			}
			if (digit_count > 0) 
				return (error_level > 255) ? 255 : error_level;
		}
	}
	
// If we get here, do nothing (continue normal execution)
	Jidac jidac;
	pjidac=&jidac;
	int risultatoparametri=jidac.loadparameters(argc,argv);

	if (risultatoparametri>0)
		return risultatoparametri;
	int errorcode=0;
	try
	{
		errorcode=jidac.doCommand();
		if (flagignore)
			errorcode=0; 
	}
	catch (std::exception& e)
	{
		fflush(stdout);
		myprintf("01294: zpaqfranz error: %s\n", e.what());
		errorcode=2;
	}
	fflush(stdout);
#ifdef _WIN32
	if (!flagimage)
#endif
		if (g_fwritten!=g_fexpected)
		{
			myprintf("\n");
			printbar('*');
			myprintf("01295: Something STRANGE happened. Archive seems corrupt. Media full?\n");
			myprintf("01296: WRITTEN BYTES  %19s\n",migliaia(g_fwritten));
			myprintf("01297: EXPECTED       %19s\n",migliaia(g_fexpected));
			printbar('*');
			errorcode=2;
		}

	if (flagdebug)
	{
		int64_t dt_ram	=jidac.get_dt_ram();
		int64_t edt_ram	=jidac.get_edt_ram();
	///	myprintf("01298: RAM information: sizeof(DT) %s g_dt_ram %s\n",migliaia(sizeof(DT)),migliaia2(g_dt_ram));
		myprintf("01299: internal  count %12s ~%18s\n",migliaia(jidac.get_dt_count()), migliaia2(dt_ram));
		myprintf("01300: external  count %12s ~%18s\n",migliaia(jidac.get_edt_count()),migliaia2(jidac.get_edt_ram()));
		myprintf("01301: RAM for files' data (approx) ~%18s\n",migliaia(dt_ram+edt_ram));
	
	}
	
	if (flagpause)
	{
		int thekey=0;
		myprintf("\n57597: Press any key to continue\n");
		while ((!iskeypressed(thekey)))
			sleep(1);
		myprintf("\n");
		fflush(stdout);
	}
///	  exit(0);
	if ((!flaghashdeep) && (!flagstdout) && (command!='L') && (command!='F') && (command!='.') && (!flagterse)) /// we need to make output compatible with hashdeep?
	{
		if (g_allocatedram<0)
			g_allocatedram=0;
		if (g_arrayram<0)
			g_arrayram=0;
		
		if (  !((command=='l') && (flag715)) )
		{
					
			///myprintf("62944: RAM: heap %s +array %s +files %s = %s\n",tohuman(g_allocatedram),tohuman2(g_arrayram),tohuman3(g_dt_ram),tohuman4(g_allocatedram+g_dt_ram+g_arrayram));
			///myprintf("01302: %1.3f seconds (%s) ", (mtime()-g_start)/1000.0,timetohuman((uint32_t)((mtime()-g_start)/1000.0)).c_str());
			
			if (!flagnotrim)
				if (g_incomplete_version>0)
				{
					color_red();
					ascii::Ascii font=ascii::Ascii();
					font.print("incomplete");
					myprintf("62378: Detected a 'gap' in the archive due to incomplete transaction(s) %s\n",migliaia(g_incomplete_version));
					myprintf("62379: This means that the archive is corrupted (killed process? out of space?)\n");
					myprintf("62380: Suggestion: use the trim command ASAP to remove the incomplete part,\n");
					myprintf("62381: preventing the issue from spreading\n");
					color_restore();
				}

			string mem_heap=tohuman(g_allocatedram);
			myreplaceall(mem_heap," ","");
			myreplaceall(mem_heap,"0.00B","0");
			myreplaceall(mem_heap,".00B","");
			
			string mem_array=tohuman(g_arrayram);
			myreplaceall(mem_array," ","");
			myreplaceall(mem_array,"0.00B","0");
			myreplaceall(mem_array,".00B","");

			string mem_dt=tohuman(g_dt_ram);
			myreplaceall(mem_dt," ","");
			myreplaceall(mem_dt,"0.00B","0");
			myreplaceall(mem_dt,".00B","");

			string mem_all=tohuman(g_allocatedram+g_dt_ram+g_arrayram);
			myreplaceall(mem_all," ","");
			myreplaceall(mem_all,"0.00B","0");
			myreplaceall(mem_all,".00B","");
			if (flagverbose)
				myprintf("01302: %1.3fs (%s,heap %s|array %s|dt %s=>%s) ", (mtime()-g_start)/1000.0,timetohuman((uint32_t)((mtime()-g_start)/1000.0)).c_str(),mem_heap.c_str(),mem_array.c_str(),mem_dt.c_str(),mem_all.c_str());
			else
				myprintf("01302: %1.3fs (%s,%s) ", 
			(mtime()-g_start)/1000.0,
			timetohuman((uint32_t)((mtime()-g_start)/1000.0)).c_str(),
			mem_all.c_str());
				
			if (command=='q')
				myprintf(" on VSS operation\n");
			else
			{
				if (!flagnotrim)
					if  (g_incomplete_version>0)
					{
						color_red();
						myprintf(" *INCOMPLETE TRANS* ");
						color_restore();
						errorcode=2;
					}
				if (errorcode==0)
				{
					color_green();
					myprintf("(all OK)\n");
					if (flagbig)
						bigok();
					color_restore();
				}
				else if (errorcode==1)
				{
					color_red();
					myprintf("(with warnings)\n");
					if (flagbig)
						bigwarning();
					color_restore();
				}
				else
				{
					color_red();
					myprintf("(with errors)\n");
					if (flagbig)
						bigerror();
					color_restore();
				}
				
			}
		}
		if (g_255)
		{
			myprintf("\n");
			myprintf("01303: Seems %08d errors by path/filename too long (>255)\n", g_255);
		}
#ifdef ZPAQFULL ///NOSFTPSTART
		if (pjidac!=NULL)
		{	
			if (flagslow)
			{
				myprintf("70131$ Due to -slow setting CPU to full power\n");
				(*pjidac).maxcpu(100);
			}
		}
#endif ///NOSFTPEND
		if (errorcode>=2)
		{
#ifdef ZPAQFULL ///NOSFTPSTART
			if (flagdebug2)
				myprintf("01304: call xcommand on errorcode>=2 %s\n",migliaia(errorcode));
			
			if (g_output_handle!=0)
				fflush(g_output_handle);
			if (g_error_handle!=0)
				fflush(g_error_handle);

			xcommand(g_exec_error,g_exec_text);
#endif ///NOSFTPEND
		}
		else
		if (errorcode==1)
		{
#ifdef ZPAQFULL ///NOSFTPSTART
			if (flagdebug2)
				myprintf("01305: call xcommand on errorcode==1\n");
			xcommand(g_exec_warn,g_exec_text);
#endif ///NOSFTPEND
		}
		else
		{
#ifdef ZPAQFULL ///NOSFTPSTART
			if (flagdebug2)
				myprintf("01306: call xcommand with a different errorcode (not 1, not 2) %d\n",errorcode);
	/// when adding multipart archive, and no errors, take the last filename
			if (g_archive!="")
			{
				g_exec_text=g_archive;
				if (flagdebug2)
					myprintf("01307: g_archive not null, setting g_exec_text to %s\n",g_exec_text.c_str());
			}
			if (g_exec_ok!="")
				xcommand(g_exec_ok,g_exec_text);
#endif ///NOSFTPEND
		}
	}
	else
	{
		if (flagbig)
		{
			if (errorcode==0)
			{
				color_green();
				bigok();
			}
			else if (errorcode==1)
			{
				color_red();
				bigwarning();
			}
			else
			{
				color_red();
				bigerror();
			}
			color_restore();
		}
	}
	
	if (g_output_handle!=0)
		fclose(g_output_handle);
	if (g_error_handle!=0)
		fclose(g_error_handle);

#ifdef _WIN32
	if (!flagnoconsole)
	{
//// set back the console
		SetConsoleCP		(g_ConsoleCP);
		SetConsoleOutputCP	(g_ConsoleOutputCP);
	///myprintf("01308: ConsoleCP %d ConsoleOutputCP %d\n",g_ConsoleCP,g_ConsoleOutputCP);
	}
#endif // corresponds to #ifdef (#ifdef _WIN32)
	color_restore();
#ifdef ZPAQFULL ///NOSFTPSTART
	if (pjidac!=NULL)
		if (flagshutdown)
			return (*pjidac).systemshutdown();
#endif ///NOSFTPEND
		
	return errorcode;
}
/// 55.10, reworked. Not 255-shrink, no dirnameifalreadyexists
int Jidac::utf()
{
	if (files.size()!=1)
	{
		myprintf("01309! you can fix exactly ONE folder at time\n");
		return 2;
	}
	if (!flagkill)
		myprintf("01310: Fix UTF-8 dry run (because no -kill)\n\n");

	g_bytescanned=0;
	g_filescanned=0;
	g_worked=0;
	edt.clear();
	for (unsigned i=0; i<files.size(); ++i)
		scandir(true,edt,files[i].c_str());
	eol();
	///printbar(' ');
	///myprintf("\r");
	vector<string> mydirs;
	unsigned int	howmanyfiles=0;
	unsigned int	longfiles=0;
	unsigned int	longdirs=0;
	unsigned int 	filetoolong=250;
	if (maxsize>0)
		filetoolong=maxsize;
	for (DTMap::iterator p=edt.begin(); p!=edt.end(); ++p)
		if (isdirectory(p->first))
		{
			if (p->first.size()>filetoolong)
			{
				longdirs++;
				if (flagfix255)
				{
					myprintf("01311: TOO LONG %08d %Z\n",p->first.size(),p->first.c_str());
				}
			}
			string	thedir=p->first;
			string 	ansidir=purgeansi(forcelatinansi(utf8toansi(thedir)),true); //it is a path
			if (ansidir!=thedir)
			{
				if (flagverbose)
				{
					myprintf("01313: Dir candidate %Z\n",thedir.c_str());
				}
				myreplace(thedir,includetrailingbackslash(files[0]),"");
				mydirs.push_back(thedir);
			}
		}
		else
		{
			if (p->first.size()>filetoolong)
			{
				longfiles++;
				if (flagfix255)
				{
					myprintf("01315: TOO LONG %08d %Z\n",p->first.size(),p->first.c_str());
				}
			}

			string	thefile=extractfilename(p->first);
			string 	ansifile=purgeansi(forcelatinansi(utf8toansi(thefile)),true); //it is a path
			if (thefile!=ansifile)
			{
				howmanyfiles++;
			}
		}
	myprintf("01317: UTF-8 dirs:  %12s\n",migliaia(mydirs.size()));
	myprintf("01318: UTF-8 files: %12s\n",migliaia(howmanyfiles));
	if (longdirs)
		myprintf("01319: LONG  dirs:  %12s\n",migliaia(longdirs));
	if (longfiles)
		myprintf("01320: LONG  files: %12s\n",migliaia(longfiles));
#if defined(_WIN32)
	if (!flaglongpath)
			if ((longdirs+longfiles)>0)
			{
				myprintf("\n");
				myprintf("01321$ *** WINDOWS WARNING *** found long path. Suggestion: use -longpath switch\n");
			}
#endif // corresponds to #if (#if defined(_WIN32))
	int errori=0;
	if (flagkill)
	{
		if (mydirs.size()>0)
		{
			myprintf("01322: First stage - try to fix (%s) folder names\n",migliaia(mydirs.size()));
			unsigned int renameddir=0;
			unsigned int i=0;
			while (i<mydirs.size())
			{
				string	thedir=mydirs[i];
				string livellocorrente="";
				unsigned int k=0;
				while (thedir[k]!='/')
					livellocorrente+=thedir[k++];
				if (flagverbose)
				{
					myprintf("01323: Father %Z\n",thedir.c_str());
				}
				unsigned int j=i+1;
				while (mypos(thedir,mydirs[j])==0)
				{
					if (flagverbose)
					{
						myprintf("01325: Son %Z\n",mydirs[j].c_str());
					}
					j++;
					if (j==mydirs.size())
						break;
				}

				if (j==i+1)
				{
					string  from=includetrailingbackslash(files[0])+thedir;
					string 	sto=includetrailingbackslash(files[0])+purgeansi(forcelatinansi(utf8toansi(thedir)),true); //it is a path
					if (myrename(from,sto)!=0)
					{
						if (flagverbose)
						{
							myprintf("===========> No son: ERROR renaming %Z => %Z\n",from.c_str(),sto.c_str());
							printUTF8(from.c_str());
							myprintf(" => %s\n",sto.c_str());
						}
						errori++;
					}
					else
					{
						if (flagverbose)
						{
							myprintf("===========> No son: successfully renamed %Z => %Z\n",from.c_str(),sto.c_str());
						}
						renameddir++;
					}
				}
				else
				{
					string  from=includetrailingbackslash(files[0])+thedir;
					string 	nuovopadre=purgeansi(forcelatinansi(utf8toansi(thedir)),true);
					string 	sto=includetrailingbackslash(files[0])+nuovopadre; //it is a path
					if (myrename(from,sto)!=0)
					{
						if (flagverbose)
						{
							myprintf("===========> GURU renaming ");
							printUTF8(from.c_str());
							myprintf(" => %s\n",sto.c_str());
						}
						errori++;
					}
					else
					{
						if (flagverbose)
						{
							myprintf("===========> Successfully renamed father ");
							printUTF8(from.c_str());
							myprintf(" => %s\n",sto.c_str());
							myprintf("01327: Fixing the sons\n");
						}
						renameddir++;
						unsigned int j=i+1;
						while (mypos(thedir,mydirs[j])==0)
						{
							myreplace(mydirs[j],includetrailingbackslash(thedir),includetrailingbackslash(nuovopadre));
							j++;
							if (j==mydirs.size())
								break;
						}
						j=i+1;
						while (mypos(nuovopadre,mydirs[j])==0)
						{
							if (flagverbose)
							{
								myprintf("01328: New son: %Z\n",mydirs[j].c_str());
							}
							j++;
							if (j==mydirs.size())
								break;
						}
					}
				}
				if (flagverbose)
					myprintf("\n\n\n");
				i++;
				if (i>=mydirs.size())
					break;
			}
			myprintf("01329: End of first stage, errors %s renamed %s\n",migliaia(errori),migliaia2(renameddir));
			if ((errori>0) && (!flagforce))
			{
				myprintf("01330! errors found and not -force: quit\n");
				return 2;
			}
			if (howmanyfiles==0)
			{
				myprintf("01331: No files to be renamed, quit\n");
				return 0;
			}
			myprintf("01332: Stage 2: rescan filesystem\n");
			g_bytescanned	=0;
			g_filescanned	=0;
			g_worked		=0;
			edt.clear();
			for (unsigned ii=0; ii<files.size(); ++ii)
				scandir(true,edt,files[ii].c_str());
			eol();
			///printbar(' ');
			///myprintf("\r");
			myprintf("01333: Stage 3: fix filenames\n");
			unsigned int filerenamed=0;

			for (DTMap::iterator p=edt.begin(); p!=edt.end(); ++p)
				if (!isdirectory(p->first))
				{
					string	thefile=extractfilename(p->first);
					string 	ansifile=purgeansi(forcelatinansi(utf8toansi(thefile)),true); //it is a path
					if (thefile!=ansifile)
					{
						string  from	=includetrailingbackslash(extractfilepath(p->first))+thefile;
						string  sto		=includetrailingbackslash(extractfilepath(p->first))+ansifile;
						if (myrename(from,sto)!=0)
						{
							myprintf("===========> KAPUTT RENAMING file %Z => %s\n",from.c_str(),sto.c_str());
							errori++;
						}
						else
						{
							if (flagverbose)
							{
								myprintf("===========> GOOD: successfully renamed %Z => %s\n",from.c_str(),sto.c_str());
								
							}
							filerenamed++;
						}
					}
				}
			if (filerenamed==howmanyfiles)
				myprintf("01334: File renamed == howmanyfiles == %s : this is GOOD\n",migliaia(filerenamed));
			else
			{
				myprintf("01335: ERROR: file renamed %s != howmanyfiles %s : this is BAD\n",migliaia(filerenamed),migliaia2(howmanyfiles));
				errori++;
			}
		}
	}
	return errori;
}

/// LICENSE_START.3
/// a patched... main()!
int unz(const char * archive,const char * key)
{
	if (!archive)
		return 0;
	uint64_t until=0;
	bool index=false;
	myprintf("01336: PARANOID TEST: working on %s\n",archive);
  // Journaling archive state
	std::map<uint32_t, unsigned> bsize;  // frag ID -> d block compressed size
	std::map<std::string, unzDT> unzdt;   // filename -> date, attr, frags
	std::vector<std::string> frag;  // ID -> hash[20] size[4] data
	std::string last_filename;      // streaming destination
	unsigned int zpaqvirtualfile=0;
	uint64_t ramsize=0;
	uint64_t csize=0;                    // expected offset of next non d block
	bool streaming=false, journaling=false;  // archive type
	int64_t inizio=mtime();
	uint64_t lavorati=0;
  // Decompress blocks
	unzInputFile in;  // Archive
	in.open(archive, key);
	int64_t total_size=in.getfilesize();
	unzDecompresser d;
	d.setInput(&in);
	////unzOutputFile out;   // streaming output
	bool done=false;  // stop reading?
	bool firstSegment=true;
	while (!done && d.findBlock())
  {
	unzBuf filename(65535);
    while (!done && d.findFilename(&filename))
	{
		unzBuf comment(65535);
		d.readComment(&comment);
		unzverify_utf8(filename.s.c_str());
		// Test for journaling or streaming block. They cannot be mixed.
		uint64_t jsize=0;  // journaling block size in comment
		if (comment.s.size()>=4 && comment.s.substr(comment.s.size()-4)=="jDC\x01")
		{
        // read jsize = uncompressed size from comment as a decimal string
			unsigned i;
			for (i=0; i<comment.s.size()-5 && isdigit(comment.s[i]); ++i)
			{
				jsize=jsize*10+comment.s[i]-'0';
				if (jsize>>32) unzerror("size in comment > 4294967295");
			}
			if (i<1)
				unzerror("missing size in comment");
			if (streaming)
				unzerror("journaling block after streaming block");
			journaling=true;
		}
		else
		{
			if (journaling)
			unzerror("streaming block after journaling block");
			if (index)
				unzerror("streaming block in index");
			streaming=true;
			///d.setOutput(&out);
			///d.setOutput();
		}
		/*
		if (streaming)
		myprintf("01337: Streaming\n");
		if (journaling)
		myprintf("01338: journaling\n");
		*/
      // Test journaling filename. The format must be
      // jDC[YYYYMMDDHHMMSS][t][NNNNNNNNNN]
      // where YYYYMMDDHHMMSS is the date, t is the type {c,d,h,i}, and
      // NNNNNNNNNN is the 10 digit first fragment ID for types c,d,h.
      // They must be in ascending lexicographical order.
		uint64_t date=0, id=0;  // date and frag ID from filename
		char type=0;  // c,d,h,i
		if (journaling)  // usually
		{
			if (filename.s.size()!=28)
				unzerror("filename size not 28");
			if (filename.s.substr(0, 3)!="jDC")
				unzerror("filename not jDC");
			type=filename.s[17];
			if (!strchr("cdhi", type))
				unzerror("type not c,d,h,i");
			if (filename.s<=last_filename)
			unzerror("filenames out of order");
			last_filename=filename.s;
        // Read date
			for (int i=3; i<17; ++i)
			{
				if (!isdigit(filename.s[i]))
					unzerror("non-digit in date");
				date=date*10+filename.s[i]-'0';
			}
			verify_date(date);
        // Read frag ID
			for (int i=18; i<28; ++i)
			{
				if (!isdigit(filename.s[i]))
					unzerror("non-digit in fragment ID");
				id=id*10+filename.s[i]-'0';
			}
			if (id<1 || id>4294967295llu)
				unzerror("fragment ID out of range");
		}
      // Select streaming output file
		if (streaming && (firstSegment || filename.s!=""))
		{
			///std::string fn=filename.s;
			/// out.open(fn.c_str());
		}
		firstSegment=false;
		// Decompress
		fflush(stdout);
		unzBuf seg(jsize);
		if (journaling)
			d.setOutput(&seg);
		unzSHA1 sha1;
		d.setSHA1(&sha1);
		d.decompress();
		if (journaling && seg.s.size()!=jsize)
			unzerror("incomplete output");
      // Verify checksum
		char checksum[21];
		d.readSegmentEnd(checksum);
//		if (!noeta)
///		myprintf("");
		if (checksum[0]==1)
		{
			if (memcmp(checksum+1, sha1.result(), 20))
				unzerror("unzSHA1 mismatch");
      //  else myprintf("01339: OK");
   	}
		else
		if (checksum[0]==0)
			myprintf("01340: not checked");
		else unzerror("invalid checksum type");
      filename.s="";
      // check csize at first non-d block
		if (csize && strchr("chi", type))
		{
			if (csize!=unzoffset)
			{
				myprintf("01341: Z2:    csize=%1.0f, offset=%1.0f\n",double(csize), double(unzoffset));
				unzerror("csize does not point here");
			}
			csize=0;
		}
///myprintf("=======================================\n");
      // Get csize from c block
		const size_t len=seg.s.size();
		if (type=='c')
		{
			if (len<8)
				unzerror("c block too small");
			csize=unzget8(seg.s.data());
			lavorati+=csize;
			if (flagnoeta==false)
			{
				print_datetime();
				myprintf("%20s (%20s)\n", migliaia(lavorati),migliaia(csize));
			}
        // test for end of archive marker
			if (csize>>63)
			{
				myprintf("01342: Incomplete transaction at end of archive (OK)\n");
				done=true;
			}
			else
			if (index && csize!=0)
				unzerror("nonzero csize in index");
        // test for rollback
			if (until && date>until)
			{
				myprintf("01343: Rollback: %1.0f is after %1.0f\n",double(date), double(until));
			done=true;
			}
        // Set csize to expected offset of first non d block
        // assuming 1 more byte for unread end of block marker.
			csize+=in.tell()+1;
		}
      // Test and save d block
		if (type=='d')
		{
			if (index)
				unzerror("d block in index");
			bsize[id]=in.tell()+1-unzoffset;  // compressed size
   ///     myprintf("    %u -> %1.0f ", bsize[id], double(seg.s.size()));
        // Test frag size list at end. The format is f[id..id+n-1] fid n
        // where fid may be id or 0. sizes must sum to the rest of block.
			if (len<8)
				unzerror("d block too small");
			const char* end=seg.s.data()+len;  // end of block
			uint32_t fid=unzget4(end-8);  // 0 or ID
			const uint32_t n=unzget4(end-4);    // number of frags
			if (fid==0)
			fid=id;
			///if (!noeta)
				///myprintf(".");
        ///myprintf("[%u..%u) ", fid, fid+n);
			if (fid!=id)
				unzerror("missing ID");
			if (n>(len-8)/4)
				unzerror("frag list too big");
			uint64_t sum=0;  // computed sum of frag sizes
			for (unsigned j=0; j<n; ++j)
				sum+=unzget4(end-12-4*j);
		//if (!noeta)
			//myprintf("");	//myprintf("");
        ///myprintf("= %1.0f ", double(sum));
			if (sum+n*4+8!=len)
				unzerror("bad frag size list");
        // Save frag hashes and sizes. For output, save data too.
			const char* data=seg.s.data();  // uncompressed data
			const char* flist=data+sum;  // frag size list
			assert(flist+n*4+8==end);
			for (uint32_t i=0; i<n; ++i)
			{
				while (frag.size()<=id+i)
					frag.push_back("");
				if (frag[id+i]!="")
					unzerror("duplicate frag ID");
				uint32_t f=unzget4(flist);  // frag size
				unzSHA1 sha1;
				for (uint32_t j=0; j<f; ++j)
					sha1.put(data[j]);
				const char* h=sha1.result();  // frag hash
				frag[id+i]=std::string(h, h+20)+std::string(flist, flist+4);
				frag[id+i]+=std::string(data, data+f);
				data+=f;
				flist+=4;
				ramsize+=frag[id+i].size();
			}
			assert(data+n*4+8==end);
			assert(flist+8==end);
		}
      // Test and save h block. Format is: bsize (sha1[20] size)...
      // where bsize is the compressed size of the d block with the same id,
      // and each size corresonds to a fragment in that block. The list
      // must match the list in the d block if present.
		if (type=='h')
		{
			if (len%24!=4)
			unzerror("bad h block size");
			///uint32_t b=unzget4(seg.s.data());
			///b++;
        ///myprintf("    [%u..%u) %u ", uint32_t(id), uint32_t(id+len/24), b);
        // Compare hashes and sizes
			const char* p=seg.s.data()+4;  // next hash, size
///			uint32_t sum=0;  // uncompressed size of all frags
			for (uint32_t i=0; i<len/24; ++i)
			{
				if (index)
				{
					while (frag.size()<=id+i) frag.push_back("");
					if (frag[id+i]!="") unzerror("data in index");
						frag[id+i]=std::string(p, p+24);
				}
				else
				if (id+i>=frag.size() || frag[id+i].size()<24)
					unzerror("no matching d block");
				else
				if (frag[id+i].substr(0, 24)!=std::string(p, p+24))
					unzerror("frag size or hash mismatch");
///				sum+=unzget4(p+20);
				p+=24;
			}
        ///myprintf("-> %u OK\n", sum);
		}
      // Test i blocks and save files to extract. Format is:
      //   date filename 0 na attr[0..na) ni ptr[0..ni)   (to update)
      //   0    filename                                  (to delete)
      // Date is 64 bits in YYYYMMDDHHMMSS format.
		if (type=='i')
		{
			const char* p=seg.s.data();
			const char* end=p+seg.s.size();
			while (p<end)
			{
          // read date
				if (end-p<8)
				unzerror("missing date");
				unzDT f;
				f.date=unzget8(p), p+=8;
				if (f.date!=0)
					verify_date(f.date);
          // read filename
				std::string fn;


				while (p<end && *p)
				{
				///		if (*p>=0 && *p<32) myprintf("^%c", *p+64);
       ///     else putchar(*p);
					fn+=*p++;
				}
				if (p==end)
					unzerror("missing NUL in filename");
				++p;
				if (fn.size()>65535)
				unzerror("filename size > 65535");
				unzverify_utf8(fn.c_str());

				bool isvirtual=unziszpaqfranzvirtualfile(fn);
				if (isvirtual)
					zpaqvirtualfile++;
          // read attr
				if ((f.date>0) && (!isvirtual))
				{
					if (end-p<4)
						unzerror("missing attr size");
					uint32_t na=unzget4(p);
					p+=4;
					if (na>65535)
					unzerror("attr size > 65535");
					///myprintf("2 NA VALE %d\n",na);
					if (na>FRANZOFFSETV1) // houston we have a FRANZBLOCK?
					{
						assert((na-8)<FRANZOFFSETV3); // cannot work on too small buffer
						/// paranoid works with SHA1, not CRC32. Get (if any)
						for (unsigned int i=0;i<(na-8);i++)
							f.sha1hex[i]=*(p+(na-(na-8))+i);
						f.sha1hex[(na-8)]=0x0;
						///myprintf("---FRANZ OFFSET---\n");
					}
					else
					{
						f.sha1hex[0]=0x0;
					///myprintf("---NORMAL OFFSET---\n");
					}
					for (unsigned i=0; i<na; ++i)
					{
						if (end-p<1)
							unzerror("missing attr");
						uint64_t a=*p++&255;
						if (i<8)
							f.attr|=a<<(i*8);
					}
					// read frag IDs
					if (end-p<4)
						unzerror("missing frag ptr size");
					uint32_t ni=unzget4(p);
					p+=4;
					for (uint32_t i=0; i<ni; ++i)
					{
						if (end-p<4)
							unzerror("missing frag ID");
						uint32_t a=unzget4(p);
						p+=4;
						f.ptr.push_back(a);
					// frag must refer to valid data except in an index
						if (!index)
						{
							if (a<1 || a>=frag.size())
								unzerror("frag ID out of range");
							if (frag[a]=="")
								unzerror("missing frag data");
						}
					}
				}
/// UBUNTU
			if (!isvirtual)
				unzdt[fn]=f;
///			unzdt.insert(std::pair<string, unzDT>(fn,f));
			}
		}
		///myprintf("\r");
		///print_datetime();
		myprintf("01344: Remaining %3s %% frags %12s (RAM used ~ %15s)\r",migliaia2(100-(unzoffset*100/(total_size+1))),migliaia(frag.size()),migliaia2(ramsize));
    }  // end while findFilename
    unzoffset=in.tell();
  }  // end while findBlock
	myprintf("\n");
	myprintf("01345: %s bytes of %s tested\n", migliaia(in.tell()), archive);
	printbar('-');
	myprintf("01346: Second stage: rebuilding hashes\n");
	std::vector<unzDTMap::iterator> mappadt;
	std::vector<unzDTMap::iterator> vf;
	std::map<std::string, unzDT>::iterator p;
	int64_t hashed=0;
	int64_t iniziocalcolo=mtime();
	int		unknownfranzo=0;

	for (p=unzdt.begin(); p!=unzdt.end(); ++p)
		mappadt.push_back(p);
	std::sort(mappadt.begin(), mappadt.end(),unzcompareprimo);
	for (unsigned int i=0; i<mappadt.size(); ++i)
	{
		unzDTMap::iterator p=mappadt[i];
		unzDT f=p->second;
		if (f.date)
		{
			uint64_t size=0;
			for (uint32_t k=0; i<f.ptr.size(); ++i)
				if (f.ptr[k]>0 && f.ptr[k]<frag.size() && frag[f.ptr[k]].size()>=24)
					size+=unzget4(frag[f.ptr[k]].data()+20);
			if (!index)
			{
				std::string fn=p->first;
				if ((!isads(fn)) && (!iszfs(fn)) && (!isdirectory(fn)))
				{
					int64_t startrecalc=mtime();
					string hashstoredinzpaq="";
					string myhashtype="";
					string mycrc32="";
					int64_t mycreationtime=0;
					int64_t myaccesstime=0;
					bool	myisordered=false;
					int		myversion=0;
					franz_posix* myposix=NULL;
					bool	myisadded=false;
		
					int unzfranzotype=decode_franz_block(isdirectory(p->first),p->second.sha1hex,
					myhashtype,
					hashstoredinzpaq,
					mycrc32,
					mycreationtime,
					myaccesstime,
					myisordered,
					myversion,
					myposix,myisadded);
					if ((unzfranzotype==FRANZO_XXHASH64) ||(unzfranzotype==FRANZO_WINHASH64)||(unzfranzotype==FRANZO_XXHASH64B))
					{
						uint64_t myseed = 0;
						XXHash64 myhash(myseed);
						for (uint32_t k=0; k<f.ptr.size(); ++k)
							if (f.ptr[k]<frag.size())
								for (uint32_t j=24; j<frag[f.ptr[k]].size(); ++j)
								{
									myhash.add(&frag[f.ptr[k]][j],1);
									hashed++;
								}
						snprintf(p->second.sha1decompressedhex,FRANZOFFSETV3,"%s",bin2hex_64(myhash.hash()).c_str());
					}
					else
					if ((unzfranzotype==FRANZO_SHA_1)||(unzfranzotype==FRANZO_SHA_1B))
					{
						unzSHA1 mysha1;
						for (uint32_t k=0; k<f.ptr.size(); ++k)
							if (f.ptr[k]<frag.size())
								for (uint32_t j=24; j<frag[f.ptr[k]].size(); ++j)
								{
									mysha1.put(frag[f.ptr[k]][j]);
									hashed++;
								}
						char sha1result[20];
						memcpy(sha1result, mysha1.result(), 20);
						for (int j=0; j <= 19; j++)
							snprintf(p->second.sha1decompressedhex+j*2,FRANZOFFSETV3-j*2,"%02X", (unsigned char)sha1result[j]);
						p->second.sha1decompressedhex[40]=0x0;
					}
					else
					if ((unzfranzotype==FRANZO_SHA_256)||(unzfranzotype==FRANZO_SHA_256B))
					{
						unzSHA256 mysha256;
						for (uint32_t k=0; k<f.ptr.size(); ++k)
							if (f.ptr[k]<frag.size())
								for (uint32_t j=24; j<frag[f.ptr[k]].size(); ++j)
								{
									mysha256.put(frag[f.ptr[k]][j]);
									hashed++;
								}
						char sha256result[32];
						memcpy(sha256result, mysha256.result(), 32);
					///	sha256result[43]='C';

						for (int j=0; j <= 31; j++)
							snprintf(p->second.sha1decompressedhex+j*2,FRANZOFFSETV3-j*2,"%02X", (unsigned char)sha256result[j]);
						p->second.sha1decompressedhex[64]=0x0;
					}
					else
					if ((unzfranzotype==FRANZO_BLAKE3)||(unzfranzotype==FRANZO_BLAKE3B))
					{
						blake3_hasher hasher;
						blake3_hasher_init(&hasher);
						for (uint32_t k=0; k<f.ptr.size(); ++k)
							if (f.ptr[k]<frag.size())
								for (uint32_t j=24; j<frag[f.ptr[k]].size(); ++j)
								{
									blake3_hasher_update(&hasher, &frag[f.ptr[k]][j],1);
									hashed++;
								}
						uint8_t output[BLAKE3_OUT_LEN];
						blake3_hasher_finalize(&hasher, output, BLAKE3_OUT_LEN);
						for (int j=0; j < BLAKE3_OUT_LEN; j++)
							snprintf(p->second.sha1decompressedhex+j*2,FRANZOFFSETV3-j*2,"%02X", (unsigned char)output[j]);
						p->second.sha1decompressedhex[64]=0x0;
					}
					else
					if ((unzfranzotype==FRANZO_SHA3)||(unzfranzotype==FRANZO_SHA3B))
					{
						SHA3 hasher;
						for (uint32_t k=0; k<f.ptr.size(); ++k)
							if (f.ptr[k]<frag.size())
								for (uint32_t j=24; j<frag[f.ptr[k]].size(); ++j)
								{
									hasher.add(&frag[f.ptr[k]][j],1);
									hashed++;
								}
						snprintf(p->second.sha1decompressedhex,FRANZOFFSETV3,"%s",hasher.getHash().c_str());
						p->second.sha1decompressedhex[64]=0x0;
					}
					else
					if ((unzfranzotype==FRANZO_MD5) || (unzfranzotype==FRANZO_MD5B))
					{
						MD5 hasher;
						for (uint32_t k=0; k<f.ptr.size(); ++k)
							if (f.ptr[k]<frag.size())
								for (uint32_t j=24; j<frag[f.ptr[k]].size(); ++j)
								{
									hasher.add(&frag[f.ptr[k]][j],1);
									hashed++;
								}
						memset(p->second.sha1decompressedhex,0,64);
						snprintf(p->second.sha1decompressedhex,FRANZOFFSETV3,"%s",hasher.getHash().c_str());
					}
					else
					if ((unzfranzotype==FRANZO_XXH3)||(unzfranzotype==FRANZO_XXH3B))
					{
						XXH3_state_t state128;
						(void)XXH3_128bits_reset(&state128);
						for (uint32_t k=0; k<f.ptr.size(); ++k)
							if (f.ptr[k]<frag.size())
								for (uint32_t j=24; j<frag[f.ptr[k]].size(); ++j)
								{
									(void)XXH3_128bits_update(&state128, &frag[f.ptr[k]][j],1);
									hashed++;
								}
						XXH128_hash_t myhash=XXH3_128bits_digest(&state128);
						snprintf(p->second.sha1decompressedhex,FRANZOFFSETV3,"%s",bin2hex_128(myhash.high64,myhash.low64).c_str());
					}
					else
					if (unzfranzotype==FRANZO_WHIRLPOOL)
					{
						NESSIEstruct hasher;
						NESSIEinit(&hasher);

						for (uint32_t i=0; i<f.ptr.size(); ++i)
							if (f.ptr[i]<frag.size())
								for (uint32_t j=24; j<frag[f.ptr[i]].size(); ++j)
								{
									NESSIEadd64((const unsigned char*)&frag[f.ptr[i]][j],1*8,&hasher); /// <-- whirlpool works on BITS, so *8
									hashed++;
								}
						unsigned char buffer[512]={0};
						NESSIEfinalize(&hasher,(unsigned char*)buffer);
						string nessie=binarytohex((const unsigned char*)buffer,64);
						snprintf(p->second.sha1decompressedhex,sizeof(p->second.sha1decompressedhex),"%s",nessie.c_str());

					}
					else
					if ((unzfranzotype==FRANZO_HIGHWAY64) || (unzfranzotype==FRANZO_HIGHWAY128) || (unzfranzotype==FRANZO_HIGHWAY256))
					{
						HighwayHashCat highway64state;
						uint64_t key[4] = {1, 2, 3, 4};
						HighwayHashCatStart(key,&highway64state);


						for (uint32_t i=0; i<f.ptr.size(); ++i)
							if (f.ptr[i]<frag.size())
								for (uint32_t j=24; j<frag[f.ptr[i]].size(); ++j)
								{
									HighwayHashCatAppend((const uint8_t*)&frag[f.ptr[i]][j],1,&highway64state);
									hashed++;
								}

						if (unzfranzotype==FRANZO_HIGHWAY64)
						{
							uint64_t hash=HighwayHashCatFinish64(&highway64state);
							snprintf(p->second.sha1decompressedhex,sizeof(p->second.sha1decompressedhex),"%s",bin2hex_64(hash).c_str());
						}
						if (unzfranzotype==FRANZO_HIGHWAY128)
						{
							uint64_t hash[2];
							HighwayHashCatFinish128(&highway64state,hash);
							string temp=binarytohex((const unsigned char*)hash,16);
							snprintf(p->second.sha1decompressedhex,sizeof(p->second.sha1decompressedhex),"%s",temp.c_str());
						}
						if (unzfranzotype==FRANZO_HIGHWAY256)
						{
							uint64_t hash[4];
							HighwayHashCatFinish256(&highway64state,hash);
							string temp=binarytohex((const unsigned char*)hash,32);
							snprintf(p->second.sha1decompressedhex,sizeof(p->second.sha1decompressedhex),"%s",temp.c_str());
						}

					}
					else
					{
						myprintf("\n");
						myprintf("01347: WARN UNKNOWN UNZFRANZOTYPE %d (maybe newer zpaqfranz archive?)\n",unzfranzotype);
						unknownfranzo++;
					}
					vf.push_back(p);
					if (flagverbose)
						myprintf("01348: File <<%-20s>> %08d of %08d (%20s) %1.3f %s\n",myhashtype.c_str(),i+1,(int64_t)mappadt.size(),migliaia(size),(mtime()-startrecalc)/1000.0,fn.c_str());
				}
			}
		}
	}
	if (unknownfranzo>0)
	{
		myprintf("\n");
		myprintf("01349$ *** WARNING UNKNOWN FRANZOTYPE %s. Maybe the archive is done with a newer zpaqfranz version?\n",migliaia(unknownfranzo));
	}
	std::sort(vf.begin(), vf.end(), unzcomparesha1hex);
	int64_t finecalcolo=mtime();
	myprintf("01350: Calc time (hash rebuild from fragments) %f hashed bytes %s\n",(finecalcolo-iniziocalcolo)*0.001,migliaia(hashed));
	printbar('-');
	myprintf("01351: Third stage");
	if (flagverify || flagparanoid)
		myprintf(": with check against filesystem");
	myprintf("\n");
//////////////////////////////
/////// now some tests
/////// if possible check SHA1 into the ZPAQ with SHA1 extracted with SHA1 of the current file
		unsigned int status_e=0;
		unsigned int status_nohash=0;
		unsigned int status_filenotfound=0;
		unsigned int status_1=0;
		unsigned int status_2=0;
		///int64_t rihashati=0;
		g_dimensione=0;

		std::string hashfromfile;
		int64_t starthash=mtime();
		for (unsigned i=0; i<vf.size(); ++i)
		{
			unzDTMap::iterator p=vf[i];
			string finalfile=p->first;
			if (finalfile!="VFILE-l-filelist.txt")
			{
			string hashstoredinzpaq	="";
			string myhashtype		="";
			string mycrc32			="";
			int64_t mycreationtime=0;
			int64_t myaccesstime=0;
			bool	myisordered=false;
			int		myversion=0;
			franz_posix* myposix=NULL;
			bool	myisadded=false;
		

			int myfranzo=decode_franz_block(isdirectory(p->first),p->second.sha1hex,
					myhashtype,
					hashstoredinzpaq,
					mycrc32,mycreationtime,myaccesstime,myisordered,myversion,myposix,myisadded);

			if (myfranzo==-1)
				error("33351: archive use an unknown hasher (maybe a more advanced zpaqfraz)!");
			string unzfranzostring="";
			if (flagverify || flagparanoid)
			{
				MAPPATIPOHASH::iterator a=g_mappatipohash.end();
				for (MAPPATIPOHASH::iterator pp=g_mappatipohash.begin(); pp!=g_mappatipohash.end(); ++pp)
					if (myhashtype==pp->second.hashname)
					{
///						myprintf("01352: Faccio test 1 %s\n",pp->second.hashname.c_str());
						a=pp;
						break;
					}
				
				if (a!=g_mappatipohash.end())
				{
					unzfranzostring=a->second.hashname;
					myreplace(unzfranzostring,"+CRC-32","");
					if (!fileexists(p->first))
					{
						if (flagdebug2)
							myprintf("01353: FILE NOT FOUND on %s: FILE %s\n",myhashtype.c_str(),p->first.c_str());
						status_filenotfound++;
					}
					else
					{
						if (flagdebug3)
							myprintf("01354: franz_do_hash\n");

						franz_do_hash dummy(a->first);
						if (flagdebug3)
							myprintf("01355: filehash on %s\n",p->first.c_str());

						hashfromfile=dummy.filehash(0,
						p->first.c_str(),true,starthash,hashed);
					}
				}
				else
				{
					myprintf("01356: Cannot find hasher %s\n",myhashtype.c_str());
				}
			}
			std::string hashdecompresso=p->second.sha1decompressedhex;
			if (flagverify || flagparanoid)
				if (hashfromfile=="")
					status_nohash++;
			bool localok=true;
			if (!hashstoredinzpaq.empty())
			{
				if (hashstoredinzpaq==hashdecompresso)
					status_1++;
				else
					localok=false;
			}
			if (!hashfromfile.empty())
			{
				if (hashfromfile==hashdecompresso)
					status_2++;
				else
					localok=false;
			}
			if ((!localok) || (flagverbose))
				if (unzfranzostring!="")
				{
					myprintf("01357: %14s: %s\n",myhashtype.c_str(),p->first.c_str());
					myprintf("01358: DECOMPRESSED  : %s\n",hashdecompresso.c_str());
					if (!hashstoredinzpaq.empty())
					myprintf("01359: STORED IN ZPAQ: %s\n",hashstoredinzpaq.c_str());
					if (!hashfromfile.empty())
					myprintf("01360: FROM FILE     : %s\n",hashfromfile.c_str());
					myprintf("\n");
					if (!localok)
						status_e++;
				}
			}
		}
	int64_t fine=mtime();
	unsigned int total_files=vf.size();
	myprintf("\n");
	myprintf("01361: SUMMARY : %12.2f (total time)\n",(fine-inizio)/1000.0);
	if (zpaqvirtualfile)
	myprintf("01362: Virtual : %12s (skipped, does not exists in 7.15)\n",migliaia(zpaqvirtualfile));
	myprintf("01363: Total   : %12s\n",migliaia(total_files));
	if (status_e>0)
	myprintf("01364! ERRORS  : %12s (ERROR:  something WRONG)\n",migliaia(status_e));
	if (status_nohash>0)
	myprintf("01365$ WARNING : %12s (UNKNOWN:cannot verify nohash)\n",migliaia(status_nohash));
	if (status_filenotfound>0)
	myprintf("01366$ WARNING : %12s (UNKNOWN:file not found)\n",migliaia(status_filenotfound));
	if (status_1>0)
	myprintf("01367: GOOD    : %12s of %12s (stored=decompressed)\n",migliaia(status_1),migliaia2(total_files));
	if (status_2>0)
	myprintf("01368: SURE    : %12s of %12s (stored=decompressed=file on disk)\n",migliaia(status_2),migliaia(total_files));
	if (status_e==0)
	{
		if (status_nohash+status_filenotfound)
			myprintf("01369: Unknown (cannot verify)\n");
		else
		{
			if (flagverify || flagparanoid)
			myprintf("01370: All OK (paranoid test with check against filesystem)\n");
			else
			myprintf("01371: All OK (paranoid test)\n");
		}
	}
	else
	{
		myprintf("01372! WITH ERRORS\n");
		return 2;
	}
	return 0;
}
/// LICENSE_END.3

///
/*
ZPAQ does not store blocks of zeros at all.
This means that they are not, materially, in the file,
and therefore cannot be used to calculate the CRC-32.
This is a function capable of doing it,
even for large sizes (hundreds of gigabytes or more in the case of thick virtual machine disks),
up to ~9.000TB
The function I wrote split a number into
its powers of 2, takes the CRC-32 code from a precomputed table,
and finally combines them.
It's not the most efficient method (some 10-20 iterations are typically needed),
but it's still decent
*/
const uint32_t zero_block_crc32[54] =
{
0xD202EF8D,0x41D912FF,0x2144DF1C,0x6522DF69,0xECBB4B55,0x190A55AD,0x758D6336,0xC2A8FA9D,
0x0D968558,0xB2AA7578,0xEFB5AF2E,0xF1E8BA9E,0xC71C0011,0xD8F49994,0xAB54D286,0x011FFCA6,
0xD7978EEB,0x7EE8CDCD,0xE20EEA22,0x75660AAC,0xA738EA1C,0x8D89877E,0x1147406A,0x1AD2BC45,
0xA47CA14A,0x59450445,0xB2EB30ED,0x80654151,0x2A0E7DBB,0x6DB88320,0x5B64C2B0,0x4DBDF21C,
0xD202EF8D,0x41D912FF,0x2144DF1C,0x6522DF69,0xECBB4B55,0x190A55AD,0x758D6336,0xC2A8FA9D,
0x0D968558,0xB2AA7578,0xEFB5AF2E,0xF1E8BA9E,0xC71C0011,0xD8F49994,0xAB54D286,0x011FFCA6,
0xD7978EEB,0x7EE8CDCD,0xE20EEA22,0x75660AAC,0xA738EA1C,0x8D89877E
};
uint32_t crc32ofzeroblock(uint64_t i_size)
{
///	assert(i_size<9.007.199.254.740.992); //8D89877E 2^53 9.007.199.254.740.992
	if (i_size==0)
		return 0;
	uint32_t mycrc=0;
	unsigned int i=0;
	while (i_size > 0)
	{
		if ((i_size%2)==1)
			mycrc=crc32_combine(mycrc,zero_block_crc32[i],1<<i);
		i_size=i_size/2;
		i++;
	}
   	return mycrc;
}
uint32_t crc32zeros(int64_t i_size)
{
	int64_t inizio=mtime();
	uint32_t crc=crc32ofzeroblock(i_size);
	g_zerotime+=mtime()-inizio;
	return crc;
}


/// concatenate multipart archive into one zpaq
/// check for freespace and (optionally) hash check
int Jidac::consolidate(string i_archive)
{
///	assert(i_archive);
	myprintf("01373: *** Merge (consolidate) ***\n");
	vector<string>	chunk_name;
	vector<int64_t>	chunk_size;
	const string part0=subpart(i_archive, 0);
	for (unsigned i=1; ;i++)
	{
		const string parti=subpart(i_archive, i);
		if (i>1 && parti==part0)
			break;
		if (!fileexists(parti))
			break;
		int64_t dimensione=prendidimensionefile(parti.c_str());
		if (dimensione<0)
			break;
		chunk_size.push_back(dimensione);
		chunk_name.push_back(parti);
	}
	if (chunk_name.size()==0)
	{
		myprintf("01374! Something strange: cannot find archive chunks\n");
		return 2;
	}
	int64_t total_size=0;
	for (int unsigned i=0;i<chunk_name.size();i++)
	{
		myprintf("01375: Chunk %08d %20s <<%s>>\n",(int)i,migliaia(chunk_size[i]),chunk_name[i].c_str());
		total_size+=chunk_size[i];
	}
	printbar('-');
	myprintf("01376: Total %s %20s (%s)\n",migliaia2(chunk_name.size()),migliaia(total_size),tohuman(total_size));
	if (files.size()!=1)
	{
		myprintf("01377: WARN exactly one file as output for merge needed\n");
		return 1;
	}
	string outfile=files[0];
	if (fileexists(outfile))
		if (!flagforce)
		{
			myprintf("01378: outfile exists, and no -force. Quit %s\n",outfile.c_str());
			return 1;
		}
	int64_t spazio=getfreespace(outfile);
	myprintf("01379: Outfile    <<%s>>\n",outfile.c_str());
	myprintf("01380: Free space %20s\n",migliaia(spazio));
	myprintf("01381: Needed     %20s\n",migliaia(total_size));
	if (spazio<total_size)
		if (!flagspace)
		{
			myprintf("01382: Free space seems < needed, and no -space. Quit\n");
			return 1;
		}
#ifdef _WIN32
	wstring widename=utow(outfile.c_str());
	FILE* outFile=_wfopen(widename.c_str(), L"wb" );
#else
	FILE* outFile=fopen(outfile.c_str(), "wb");
#endif // corresponds to #ifdef (#ifdef _WIN32)
	if (outFile==NULL)
	{
		myprintf("01383! CANNOT OPEN outfile %s\n",outfile.c_str());
		return 2;
	}
	size_t const blockSize = 65536;
	unsigned char buffer[blockSize];
	int64_t donesize=0;
	int64_t startcopy=mtime();
	XXH3_state_t state128;
    (void)XXH3_128bits_reset(&state128);
	if (flagverify)
		myprintf("01384: -verify: trust, but check...\n");
	for (int unsigned i=0;i<chunk_name.size();i++)
	{
		string	sorgente_nome=chunk_name[i];
		FILE* inFile = freadopen(sorgente_nome.c_str());
		if (inFile==NULL)
		{
			int err=1;
		#ifdef _WIN32
			err=GetLastError();
		#endif
			myprintf("\n");
			myprintf("01385! ERR <%s> kind %d\n",sorgente_nome.c_str(),err);
			fclose(outFile); // Close the output file too before exiting
			return 2;
		}
		size_t readSize;
		int64_t	chunk_readed=0;
		int64_t	chunk_written=0;
		while (!feof(inFile) && !ferror(inFile))
		{
			readSize = fread(buffer, 1, blockSize, inFile);
			if (readSize == 0)
				break;
				
			int64_t written = fwrite(buffer, 1, readSize, outFile);
			
			// Write error check
			if (written != (int64_t)readSize)
			{
				color_red();
				myprintf("Error writing to file: wrote %lld of %d bytes\n", written, readSize);
				color_restore();
				break;
			}
			
			chunk_written += written;
			chunk_readed += readSize;
			donesize += written;
			
			if (flagverify)
				(void)XXH3_128bits_update(&state128, buffer, readSize);
				
			avanzamento(donesize, total_size, startcopy);
		}

		fclose(inFile);
		if (flagverbose)
			myprintf("01386: Chunk %08d R %20s W %20s E %20s\n",(int)i,migliaia(chunk_readed),migliaia2(chunk_written),migliaia3(chunk_size[i]));
		if ((chunk_readed!=chunk_written) || (chunk_readed!=chunk_size[i]))
		{
			myprintf("01387: GURU on chunk %d Read, Write, Expec not equal!\n",i);
			fclose(outFile);
			return 1;
		}
	}
	fclose(outFile);
	myprintf("01388: Done\n");
	myprintf("01389: Written  %20s\n",migliaia(donesize));
	myprintf("01390: Expected %20s\n\n",migliaia(total_size));
	if (donesize!=total_size)
	{
		myprintf("01391: GURU bytes written does not match expected\n");
		return 1;
	}
	if (flagverify)
	{
		myprintf("01392: -flagverify: double check...\n");
		XXH128_hash_t myhash=XXH3_128bits_digest(&state128);
		char risultato[33];
		snprintf(risultato,sizeof(risultato),"%s",bin2hex_128(myhash.high64,myhash.low64).c_str());
		int64_t startverify=mtime();
		g_dimensione=0;
		if (flagdebug3)
			myprintf("01393: franz_do_hash\n");

		franz_do_hash dummy("XXH3");
		if (flagdebug3)
			myprintf("01394: filehash on %s\n",outfile.c_str());

		string hashreloaded=dummy.filehash(0,outfile,false,startverify,total_size);

		///string hashreloaded=xxhash_calc_file(outfile.c_str(),false,dummycrc32,startverify,total_size,io_lavorati,thefilesize);
		myprintf("01395: Expected   XXH3 hash of the output file %s\n",risultato);
		myprintf("01396: Calculated XXH3 hash of the output file %s\n",hashreloaded.c_str());
		if (hashreloaded!=risultato)
		{
			myprintf("01397: GURU hash of output file does not match!\n");
			return 1;
		}
	}
	return 0;
}

// Structure for data shared between threads
struct ThreadData {
    // Input data for each thread
    std::vector<s_crc32block>* blocks;
    int start_index;
    int end_index;
    int thread_id;
    
    // Results per thread (thread-local)
    unsigned int status_e_hash;
    unsigned int status_e_crc;
    unsigned int status_e_blocks;
    unsigned int status_0;
    unsigned int status_1;
    uint32_t checkedfiles;
    uint32_t uncheckedfiles;
    uint32_t triple_error;
    uint64_t zeroedblocks;
    uint32_t howmanyzero;
	int		 internalthreads;
    std::vector<std::string> filestobecrced;
    
    ThreadData() : status_e_hash(0), status_e_crc(0), status_e_blocks(0),
                   status_0(0), status_1(0), checkedfiles(0), uncheckedfiles(0),
                   triple_error(0), zeroedblocks(0), howmanyzero(0),internalthreads(1) {}
};

// Mutex per sezioni critiche
pthread_mutex_t g_progress_mutex 	=PTHREAD_MUTEX_INITIALIZER;
pthread_mutex_t g_dt_mutex 			=PTHREAD_MUTEX_INITIALIZER;
static int 		g_test_seconds		=0;
static uint64_t g_test_start		=0;
static int64_t 	g_global_lavorati 	=0;

// Function to process a group of files (same filename)
void process_file_group(ThreadData* data, const std::vector<int>& file_indices)
{
	
    if (file_indices.empty()) return;
    
    uint32_t currentcrc32 = 0;
    unsigned int parti = 1;
    int64_t lavorati = 0;
    
    std::string current_filename = (*data->blocks)[file_indices[0]].filename;
	if (flagdebug)
	{
		pthread_mutex_lock(&g_progress_mutex);
		myprintf("58913: process current_filename ...  %s\n", current_filename.c_str());
		pthread_mutex_unlock(&g_progress_mutex);
	}
    uint32_t crc32stored = 0;
    std::string mycrc32 = "";
    
    // Process all blocks of the same file
    for (size_t idx = 0; idx < file_indices.size(); idx++) {
        int i = file_indices[idx];
        if (flagdebug)
		{
			pthread_mutex_lock(&g_progress_mutex);
			myprintf("58927: Entered - processing block %d\n", i);
			pthread_mutex_unlock(&g_progress_mutex);
        }
        s_crc32block it = (*data->blocks)[i];
        
		
		int secondi=(mtime()-g_test_start)/1000;
		if ((!flagnoeta) && (!flagpakka))
			if (secondi!=g_test_seconds)
			{
				pthread_mutex_lock(&g_progress_mutex);
				myprintf("01413: Block %05uK %16s\r", i / 1000, tohuman(lavorati));
				pthread_mutex_unlock(&g_progress_mutex);
				g_test_seconds=secondi;
			}

        
        // Find file data in the dictionary (thread-safe read)
      
        DTMap::iterator p = (*pjidac).dt.find(it.filename);
        crc32stored = 0;
        mycrc32 = "";
        std::string myhashtype = "";
        std::string myhash = "";
        
        if (p != (*pjidac).dt.end()) {
            int64_t mycreationtime = 0;
            int64_t myaccesstime = 0;
            bool myisordered = false;
            int myversion = 0;
            franz_posix* myposix = NULL;
            bool myisadded = false;
            if (flagdebug)
			{
				pthread_mutex_lock(&g_progress_mutex);
				myprintf("58953: decodifico it.filename %s\n", it.filename.c_str());
				pthread_mutex_unlock(&g_progress_mutex);
			}
            decode_franz_block(isdirectory(it.filename), p->second.franz_block,
                              myhashtype, myhash, mycrc32, mycreationtime, myaccesstime,
                              myisordered, myversion, myposix, myisadded);
            crc32stored = crchex2int(mycrc32.c_str());
            
            if (flagdebug)
			{
				pthread_mutex_lock(&g_progress_mutex);
				myprintf("58913: %08X %s\n", crc32stored, it.filename.c_str());
				pthread_mutex_unlock(&g_progress_mutex);
			}
        } else 
		{
			pthread_mutex_lock(&g_progress_mutex);
			myprintf("58957! Cannot find it.filename <<%s>>\n", it.filename.c_str());
			pthread_mutex_unlock(&g_progress_mutex);
        }
        
		if (flagdebug)
        {
			pthread_mutex_lock(&g_progress_mutex);
	        myprintf("Thread %d - MYhashtype: %s\n", data->thread_id, myhashtype.c_str());
            myprintf("Thread %d - Myhash: %s\n", data->thread_id, myhash.c_str());
            myprintf("Thread %d - Mycrc32: %s\n", data->thread_id, mycrc32.c_str());
			pthread_mutex_unlock(&g_progress_mutex);
        }
        
        // Handling gaps with leading zeros
        if (it.crc32start > 0 && parti == 1) {
            uint64_t holesize = it.crc32start;
            uint32_t zerocrc = crc32zeros(holesize);
            currentcrc32 = crc32_combine(currentcrc32, zerocrc, holesize);
            lavorati += holesize;
            data->zeroedblocks += holesize;
            data->howmanyzero++;
        }
        
        currentcrc32 = crc32_combine(currentcrc32, it.crc32, it.crc32size);
        lavorati += it.crc32size;
        
        // Handling intermediate gaps
        if (idx + 1 < file_indices.size()) {
            int next_i = file_indices[idx + 1];
            if (((*data->blocks)[i].crc32start + (*data->blocks)[i].crc32size) != 
                (*data->blocks)[next_i].crc32start) {
                
                uint64_t holesize = (*data->blocks)[next_i].crc32start - 
                                   ((*data->blocks)[i].crc32start + (*data->blocks)[i].crc32size);
                uint32_t zerocrc = crc32zeros(holesize);
                currentcrc32 = crc32_combine(currentcrc32, zerocrc, holesize);
                lavorati += holesize;
                data->zeroedblocks += holesize;
                data->howmanyzero++;
            }
        }
        
        parti++;
    }
    
    // Final check of the file
    int last_i = file_indices.back();
    std::string filedefinitivo = (*data->blocks)[last_i].filename;
    (*pjidac).franzreplace(filedefinitivo);
    
    if (flagdebug) 
	{
		pthread_mutex_lock(&g_progress_mutex);
	   myprintf("Thread %d - Stored %08X calculated %08X %s\n", 
                data->thread_id, crc32stored, currentcrc32, filedefinitivo.c_str());
		pthread_mutex_unlock(&g_progress_mutex);
    }
    
    if (mycrc32 != "") {
        if (currentcrc32 == crc32stored) {
            if (flagdebug) 
			{
				pthread_mutex_lock(&g_progress_mutex);
	            myprintf("Thread %d - GOOD: STORED %08X = DECOMPRESSED %s\n", 
                        data->thread_id, crc32stored, filedefinitivo.c_str());
				pthread_mutex_unlock(&g_progress_mutex);
            }
            
            if (flagcrc32) {
                if (fileexists(filedefinitivo)) 
				{
                    pthread_mutex_lock(&g_dt_mutex);
                    DTMap::iterator p = (*pjidac).dt.find((*data->blocks)[last_i].filename);
                    if (p != (*pjidac).dt.end()) {
                        if (prendidimensionefile(filedefinitivo.c_str()) != p->second.size) {
                            data->triple_error++;
                            if (flagverbose) 
							{
                                pthread_mutex_lock(&g_progress_mutex);
								myprintf("Thread %d - ERROR: expected %s <> %s <<%s>>\n",
                                        data->thread_id, migliaia(p->second.size), 
                                        migliaia2(prendidimensionefile(filedefinitivo.c_str())), 
                                        filedefinitivo.c_str());
								pthread_mutex_unlock(&g_progress_mutex);
                            }
                        } else {
                            data->filestobecrced.push_back(filedefinitivo);
                            p->second.file_crc32 = currentcrc32;
                        }
                    }
                    pthread_mutex_unlock(&g_dt_mutex);
                } else {
                    data->triple_error++;
                    if (flagverbose) {
						   pthread_mutex_lock(&g_progress_mutex);
							
                        myprintf("Thread %d - ERROR: cannot find <<%s>>\n", 
                                data->thread_id, filedefinitivo.c_str());
					 pthread_mutex_unlock(&g_progress_mutex);
                    }
                }
            } else {
                data->status_1++;
            }
        } else {
            if (crc32stored != 0) {
				 pthread_mutex_lock(&g_progress_mutex);
                myprintf("59087$ Thread %03d - ERROR: STORED CRC-32 %08X != DECOMPRESSED %08X (ck %08d) %s\n",
                        data->thread_id, crc32stored, currentcrc32, parti, filedefinitivo.c_str());
				pthread_mutex_unlock(&g_progress_mutex);
                data->status_e_blocks++;
            }
        }
    } else {
        data->uncheckedfiles++;
    }
    
    // Update global progress
    pthread_mutex_lock(&g_progress_mutex);
    g_global_lavorati += lavorati;
    pthread_mutex_unlock(&g_progress_mutex);
}

// Worker thread function
void* thread_worker(void* arg) 
{
    ThreadData* data = (ThreadData*)arg;
    // Calculate the total work for this thread
    /*
	uint64_t dalavorare = 0;
    
    for (int j = data->start_index; j < data->end_index; j++) {
        dalavorare += (*data->blocks)[j].crc32size;
    }
    */
    // Group blocks by filename
    std::map<std::string, std::vector<int> > file_groups;
    
    for (int i = data->start_index; i < data->end_index; i++) {
        std::string filename = (*data->blocks)[i].filename;
        file_groups[filename].push_back(i);
    }
    
    // Process each group of files
    for (std::map<std::string, std::vector<int> >::iterator it = file_groups.begin(); 
         it != file_groups.end(); ++it) {
        process_file_group(data, it->second);
    }
    
    return NULL;
}

int Jidac::test()
{
	archive=getbackupnameifany(archive);

	if ((files.size()>0))
	{
		if (flagquick)
			myprintf("01398: -quick and dirty (only date/size) test\n");
		else
		{
			if (flagchecksum || flagverify || flagparanoid)
				myprintf("01399: SHA-1-chunked verify+HASH checksum\n");
			else
				myprintf("01400: SHA-1-chunked verify\n");
		}
		return testverify(); 
	}

	if (flagparanoid)
	{
		if (tofiles.size()!=1)
		{
			myprintf("01401! -paranoid needs a -to\n");
			return 2;
		}
		uint64_t tofoldersize=0;
		uint32_t tofoldernumber=0;
		uint32_t tofolderfolder=0;
		uint32_t tofolderlongfiles=0;
		if (getfoldersize(tofiles[0],tofoldersize,tofoldernumber,tofolderfolder,tofolderlongfiles))
			if (tofoldersize>0)
			{
				myprintf("01402$ WARNING the folder <<%Z>> contain %s bytes\n\n\n\n",
				tofiles[0].c_str(),migliaia(tofoldersize));
				if (!getcaptcha("withoutmercy","Extract-check-delete without confirmation"))
					return 1;
			}
		return extract();
	}
	int64_t starttest=mtime();
	flagtest=true;
	summary=1;
	int read_errors=0;

	const int64_t sz=read_archive(NULL,archive.c_str(),&read_errors);
	if (read_errors>0)
		myprintf("65757! cannot read_archive (%s) THIS IS VERY BAD!!!\n",migliaia(read_errors));
	if (sz<1) error("archive not found");
	for (unsigned i=0; i<block.size(); ++i)
	{
		if (block[i].bsize<0) error("negative block size");
		if (block[i].start<1) error("block starts at fragment 0");
		if (block[i].start>=ht.size()) error("block start too high");
		if (i>0 && block[i].start<block[i-1].start) error("unordered frags");
		if (i>0 && block[i].start==block[i-1].start) error("empty block");
		if (i>0 && block[i].offset<block[i-1].offset+block[i-1].bsize)
			error("unordered blocks");
		if (i>0 && block[i-1].offset+block[i-1].bsize>block[i].offset)
			error("overlapping blocks");
	}
	///myprintf("01403: franz: fine test blocchi\n");
  // Label files to extract with data=0.
  ExtractJob job(*this);
  int total_files=0;
  for (DTMap::iterator p=dt.begin(); p!=dt.end(); ++p)
  {
		p->second.data=-1;  // skip
		if (p->second.date && p->first!="")
		{
			const string fn=rename(p->first);
///			myprintf("--------------------> %s\n",fn.c_str());
			const bool isdir=p->first[p->first.size()-1]=='/';
			if (isdir)  // update directories later
				p->second.data=0;
			else
				if (block.size()>0)
			{  // files to decompress
				p->second.data=0;
				unsigned lo=0, hi=block.size()-1;  // block indexes for binary search
				for (unsigned i=0; p->second.data>=0 && i<p->second.ptr.size(); ++i)
				{
					unsigned j=p->second.ptr[i];  // fragment index
					///myprintf("01404: Fragment index %lld\n",j);
					if (j==0 || j>=ht.size() || ht[j].usize<-1)
					{
						fflush(stdout);
						printUTF8(p->first.c_str());
						myprintf(": 3 bad frag IDs, skipping...\n");
						p->second.data=-1;  // skip
						continue;
					}
					assert(j>0 && j<ht.size());
					if (lo!=hi || lo>=block.size() || j<block[lo].start
						|| (lo+1<block.size() && j>=block[lo+1].start))
						{
							lo=0;  // find block with fragment j by binary search
							hi=block.size()-1;
							while (lo<hi)
							{
								unsigned mid=(lo+hi+1)/2;
								assert(mid>lo);
								assert(mid<=hi);
								if (j<block[mid].start)
									hi=mid-1;
								else
									(lo=mid);
							}
						}
						assert(lo==hi);
						assert(lo<block.size());
						assert(j>=block[lo].start);
						assert(lo+1==block.size() || j<block[lo+1].start);
						unsigned c=j-block[lo].start+1;
						if (block[lo].size<c)
							block[lo].size=c;
						if (block[lo].files.size()==0 || block[lo].files.back()!=p)
						{
							block[lo].files.push_back(p);
						///	myprintf("+++++++++++Pushato %s\n",p->first.c_str());
						}
				}
				++total_files;
				job.total_size+=p->second.size;
			}
		}  // end if selected
  }  // end for
///	dimtotalefile=job.total_size;
	myprintf("01405: To be checked %s in %s files (%d threads)\n",migliaia(job.total_size), migliaia2(total_files), howmanythreads);
	vector<ThreadID> tid(howmanythreads);
	if (howmanythreads==1)
	{
		if (flagverbose)
			myprintf("01406: monothread decompress (test)\n");
		decompressThread(&job);
	}
	else
	{
		for (unsigned i=0; i<tid.size(); ++i)
			run(tid[i], decompressThread, &job);
		for (unsigned i=0; i<tid.size(); ++i)
			join(tid[i]);
	}
	
	
  // Report failed extractions
  unsigned extracted=0,errors=0;
  for (DTMap::iterator p=dt.begin(); p!=dt.end(); ++p)
  {
    string fn=rename(p->first);
    if (p->second.data>=0 && p->second.date
        && fn!="" && fn[fn.size()-1]!='/') {
      ++extracted;
      if (p->second.ptr.size()!=unsigned(p->second.data)) {
        fflush(stdout);
        if (++errors==1)
          myprintf(
          "\n57113: Failed (extracted/total fragments, file):\n");
        myprintf("01407! UJO %u/%u %Z\n",
                int(p->second.data), int(p->second.ptr.size()),fn.c_str());
      }
    }
  }
	if (errors>0)
	{
		fflush(stdout);
		myprintf(
			"\nChecked %u of %u files OK (%u errors)"
			" using %1.3f MB x %d threads\n",
			extracted-errors, extracted, errors, job.maxMemory/1000000,
			int(tid.size()));
	}
	else
	{
		if (!flagpakka)
			myprintf("01408: 7.15 stage time %10.2f no error detected (RAM ~%s), try CRC-32 (if any)\n",
				(mtime()-starttest)/1000.0,tohuman((int64_t)(tid.size()*job.maxMemory)));
	}
//// OK now check against CRC32 and the entire World (if any)
	

	unsigned int 	status_e		=0; //all kinds of error
	unsigned int 	status_e_hash	=0; //errors on hashes by file 
	unsigned int 	status_e_crc	=0;	//errors on crcs by file
	unsigned int 	status_e_blocks	=0;	//errors on crcs by blocks
	unsigned int 	status_0		=0;
	unsigned int 	status_1		=0;
	uint32_t 		checkedfiles	=0;
	uint32_t 		uncheckedfiles	=0;
	unsigned int 	parti			=1;
	int64_t 		lavorati		=0;
	uint64_t 		dalavorare		=0;
	uint32_t 		currentcrc32	=0;
	uint32_t		triple_error	=0;
	uint64_t		zeroedblocks	=0;
	uint32_t		howmanyzero		=0;
	vector<string> 	filestobecrced;


	if (flagdebug6)
	{
		myprintf("59327$ Due to -debug6 ENFORCING CRC-32 errors!\n");
		g_crc32[0].crc32+=5;
		g_crc32[g_crc32.size()-1].crc32+=2;
	}
	int64_t startsort=mtime();
	sort(g_crc32.begin(),g_crc32.end(),comparecrc32block);
	if (flagdebug6)
		myprintf("59333: Sort time %s of %K\n",migliaia(mtime()-startsort),g_crc32.size());
	for (size_t i=0;i<g_crc32.size();i++) 
		dalavorare += g_crc32[i].crc32size;

	int64_t startverify	=mtime();
	g_zerotime			=0;
	g_test_seconds		=0;
	g_test_start		=0;
	if (flagssd) // multithread
	{
		if (howmanythreads <= 0)
			howmanythreads = 1;
		if (!flagpakka)
		{
			color_green();
			myprintf("01409: Checking %17s blocks with CRC-32 (%s not-0 bytes) using %d threads\n",
					 migliaia(g_crc32.size()), migliaia2(dalavorare), howmanythreads);
			color_restore();
		}
		// Group blocks by filename
		std::map<std::string, std::vector<int> > file_groups;
		for (size_t i=0; i<g_crc32.size(); i++) 
			file_groups[g_crc32[i].filename].push_back(i);
		
		// Convert to vector for distribution
		std::vector<std::pair<std::string, std::vector<int> > > files_list;
		///for (auto& pair : file_groups)
			///files_list.push_back(pair);
		for (std::map<std::string, std::vector<int> >::iterator it = file_groups.begin();it != file_groups.end(); ++it) 
			files_list.push_back(*it);
		// Prepare the threads
		pthread_t*  threads 		= new pthread_t[howmanythreads];
		ThreadData* thread_data 	= new ThreadData[howmanythreads];

		// Distribute files among threads
		size_t files_per_thread = files_list.size() / howmanythreads;
		size_t remaining_files 	= files_list.size() % howmanythreads;

		// Create a vector of indexes for each thread
		std::vector<std::vector<int> > thread_indices(howmanythreads);

		size_t file_idx = 0;
		for (unsigned int t = 0; t < (unsigned)howmanythreads; t++) 
		{
			size_t files_for_this_thread = files_per_thread + (t < remaining_files ? 1 : 0);
			/*
			for (size_t f = 0; f < files_for_this_thread && file_idx < files_list.size(); f++, file_idx++) 
				for (int block_idx : files_list[file_idx].second) 
					thread_indices[t].push_back(block_idx);
			*/
			for (size_t f = 0; f < files_for_this_thread && file_idx < files_list.size(); f++, file_idx++) 
				for (size_t i = 0; i < files_list[file_idx].second.size(); i++) 
				{
					int block_idx = files_list[file_idx].second[i];
					thread_indices[t].push_back(block_idx);
				}
			if (!thread_indices[t].empty()) 
			{
				thread_data[t].blocks 		= &g_crc32;
				thread_data[t].thread_id 	= t;
				thread_data[t].start_index 	= thread_indices[t].front();
				thread_data[t].end_index 	= thread_indices[t].back() + 1;
				
				// Create the thread
				if (pthread_create(&threads[t], NULL, thread_worker, &thread_data[t]) != 0) 
				{
					myprintf("59140: Error on thread %d\n", t);
					seppuku();
				}
			}
		}

		// Wait for all threads
		for (int t=0;t<howmanythreads; t++) 
			if (!thread_indices[t].empty()) 
				pthread_join(threads[t], NULL);
		
	///	if ((!flagpakka) && (!flagnoeta))
		///	myprintf("01413: Block %05uK %16s\r", g_crc32.size() / 1000, tohuman(dalavorare));
				
		for (int t=0;t<howmanythreads;t++) 
		{
			status_e_hash 	+= thread_data[t].status_e_hash;
			status_e_crc 	+= thread_data[t].status_e_crc;
			status_e_blocks += thread_data[t].status_e_blocks;
			status_0 		+= thread_data[t].status_0;
			status_1 		+= thread_data[t].status_1;
			checkedfiles 	+= thread_data[t].checkedfiles;
			uncheckedfiles 	+= thread_data[t].uncheckedfiles;
			triple_error 	+= thread_data[t].triple_error;
			zeroedblocks 	+= thread_data[t].zeroedblocks;
			howmanyzero 	+= thread_data[t].howmanyzero;
			
			// Add files to check
			filestobecrced.insert(filestobecrced.end(),
									 thread_data[t].filestobecrced.begin(),
									 thread_data[t].filestobecrced.end());
		}
    
		// Cleanup
		delete[] threads;
		delete[] thread_data;
		
		// Destroy the mutexes
		pthread_mutex_destroy(&g_progress_mutex);
		pthread_mutex_destroy(&g_dt_mutex);

	}
	else // single thread
	{
		if (!flagpakka)
			myprintf("01409: Checking %17s blocks with CRC-32 (%s not-0 bytes)\n",migliaia(g_crc32.size()),migliaia2(dalavorare));
	
		unsigned int i=0;
		while (i < g_crc32.size())
		{
///			if (flagdebug6)
	///			myprintf("%08d  size %08d\n", i, g_crc32.size());
			
			int secondi=(mtime()-g_test_start)/1000;
			if ((!flagpakka) && (!flagnoeta))
				if (secondi!=g_test_seconds)
				{
					myprintf("01410: Block %05uK %16s\r", i / 1000, tohuman(lavorati));
					g_test_seconds=secondi;
				}
			s_crc32block it 		= g_crc32[i];
			DTMap::iterator p 		= dt.find(it.filename);
			uint32_t crc32stored 	= 0;
			string myhashtype 		= "";
			string myhash 			= "";
			string mycrc32 			= "";
			
			
			if (p != dt.end())
			{
				int64_t mycreationtime 	= 0;
				int64_t myaccesstime 	= 0;
				bool myisordered 		= false;
				int myversion 			= 0;
				franz_posix* myposix 	= NULL;
				bool myisadded 			= false;
			
				decode_franz_block(isdirectory(it.filename), p->second.franz_block,
								  myhashtype, myhash, mycrc32, mycreationtime, myaccesstime,
								  myisordered, myversion, myposix, myisadded);
				crc32stored = crchex2int(mycrc32.c_str());
			}
			
			if (flagdebug3)
			{
				myprintf("01411: MYhashtype   %s\n", myhashtype.c_str());
				myprintf("01412: Myhash       %s\n", myhash.c_str());
				myprintf("01413: Mycrc32      %s\n", mycrc32.c_str());
				myprintf("\n");
			}
			
			/// Houston, we have something that start with a sequence of zeros, let's compute the missing CRC
			if (it.crc32start > 0)
			{
				uint64_t holesize 	 = it.crc32start;
				uint32_t zerocrc 	 = crc32zeros(holesize);
				currentcrc32 		 = crc32_combine(currentcrc32, zerocrc, holesize);
				lavorati 			+= holesize;
				zeroedblocks 		+= holesize;
				howmanyzero++;
			}
			currentcrc32 	= crc32_combine(currentcrc32, it.crc32, it.crc32size);
			lavorati 	   += it.crc32size;

			if ((i + 1) < g_crc32.size())
			{
				///	
				///while (i < g_crc32.size() && g_crc32[i].filename == g_crc32[i + 1].filename)
				while (((i + 1) < g_crc32.size()) && (g_crc32[i].filename == g_crc32[i + 1].filename))
				{
					if ((g_crc32[i].crc32start + g_crc32[i].crc32size) != g_crc32[i + 1].crc32start)
					{
						uint64_t holesize 	 = g_crc32[i + 1].crc32start - (g_crc32[i].crc32start + g_crc32[i].crc32size);
						uint32_t zerocrc 	 = crc32zeros(holesize);
						currentcrc32		 = crc32_combine(currentcrc32, zerocrc, holesize);
						lavorati 			+= holesize;
						zeroedblocks 		+= holesize;
						howmanyzero++;
					}
					i++;
					if (i < g_crc32.size())
					{
						s_crc32block myit 	 = g_crc32[i];
						currentcrc32 		 = crc32_combine(currentcrc32, myit.crc32, myit.crc32size);
						lavorati 			+= myit.crc32size;
						parti++;
					}
					else
					{
						break;
					}
				}
			}
			
			if (i >= g_crc32.size())
				break; // exit 
			
			string filedefinitivo = g_crc32[i].filename;
			franzreplace(filedefinitivo);
			if (flagdebug)
				myprintf("01414: Stored %08X calculated %08X %s\n", crc32stored, currentcrc32, filedefinitivo.c_str());
			
			if (mycrc32 != "")
			{
				if (currentcrc32 == crc32stored)
				{
					if (flagdebug)
						myprintf("01415: GOOD: STORED %08X = DECOMPRESSED %s\n", crc32stored, filedefinitivo.c_str());
					if (flagcrc32)
					{
						if (fileexists(filedefinitivo))
						{
							if (prendidimensionefile(filedefinitivo.c_str()) != p->second.size)
							{
								triple_error++;
								if (flagverbose)
								{
									myprintf("01416: ERROR: expected %s <> %s <<%Z>>\n",
											 migliaia(p->second.size), migliaia2(prendidimensionefile(filedefinitivo.c_str())), filedefinitivo.c_str());
								}
							}
							else
							{
								filestobecrced.push_back(filedefinitivo);
								p->second.file_crc32 = currentcrc32;
							}
						}
						else
						{
							triple_error++;
							if (flagverbose)
							{
								myprintf("01417: ERROR: cannot find <<%Z>>\n", filedefinitivo.c_str());
							}
						}
					}
					else
						status_1++;
				}
				else
				{
					if (crc32stored != 0)
					{
						myprintf("01422$ ERROR: STORED CRC-32 %08X != DECOMPRESSED %08X (ck %08d) %s\n",
								 crc32stored, currentcrc32, parti, filedefinitivo.c_str());
						status_e_blocks++;
					}
				}
			}
			else
			{
				uncheckedfiles++;
			}
			
			parti 		  = 1;
			currentcrc32  = 0;
			i++;
		}
	}
		
	if (flagwriteonconsole)
	{
		fprintf(stderr,"\r");
		fprintf(stderr,"                                                                 \r");
	}
	if (flagpakka)
	{
		printf("\r");
		eol();
		printf("\r");
	}
	else
		myprintf("\n");
	if (!flagpakka)
	{
		myprintf("01424: CRC-32 time %14.2fs\n",(mtime()-startverify)/1000.0);
		myprintf("01425: Blocks %19s (%12s)\n",migliaia(dalavorare),migliaia2(g_crc32.size()));
		myprintf("01426: Zeros  %19s (%12s) %f s\n",migliaia(zeroedblocks),migliaia2(howmanyzero),(g_zerotime/1000.0));
		myprintf("01427: Total  %19s speed %s/s (%s/s)\n",migliaia(dalavorare+zeroedblocks),migliaia2((int64_t)((dalavorare+zeroedblocks)/((mtime()-startverify+1)/1000.0))),tohuman((int64_t)((dalavorare+zeroedblocks)/((mtime()-startverify+1)/1000.0))));
		if (checkedfiles>0)
			myprintf("01428: Checked         : %08d of %08d (zpaqfranz)\n",checkedfiles,total_files);
		if (uncheckedfiles>0)
		{
			myprintf("01429: UNcheck         : %08d of %08d (zpaq 7.15?)\n",uncheckedfiles,total_files);
				status_0=uncheckedfiles;
		}
	}
	if (status_e_hash)
	myprintf("01430: ERRORS HASH     : %08d (ERROR verifyng hash from disk)\n",status_e_hash);
	if (status_e_crc)
	myprintf("01431: ERRORS CRC FI   : %08d (ERROR verifyng CRC-32 from disk)\n",status_e_crc);
	if (status_e_blocks)
	myprintf("01432: ERRORS          : %08d (ERROR in CRC-32: corrupted? SHA-1 collisions?)\n",status_e_blocks);
	
	
	if (flagcrc32)
	{
		uint32_t		triple_ok		=0;
		
		myprintf("01433: Triple checking CRC-32 on %s files (%s)\n",migliaia(filestobecrced.size()),tohuman(dalavorare+zeroedblocks));
		
		vector<std::pair<string,string> > crc32_pair;
		int64_t starttriple=mtime();
		franzparallelhashfiles("CRC-32",dalavorare+zeroedblocks,filestobecrced,false,crc32_pair);
		printbar(' ');
		myprintf("01434: Time doing CRC-32 %14.2fs\n",(mtime()-starttriple)/1000.0);
	///	for (int i=0;i<filestobecrced.size();i++)
		///	myprintf("01435: To be CRC-ed %s\n",filestobecrced[i].c_str());
		
	
		if ((searchfrom!="") || (replaceto!=""))
		{
			myprintf("01436: due to -search/replace fixing dt\n");
			rename_a_dtmap(dt);
		}
		
		for (unsigned int j=0;j<crc32_pair.size();j++)
		{
			string thefilename=crc32_pair[j].second;
			DTMap::iterator p=dt.find(rename(thefilename));
			if (p==dt.end())
			{
				triple_error++;
				myprintf("01437: GURU cannot find thefilename in crc32_pair %s\n",thefilename.c_str());
				///myprintf("%s\n",dt.begin()->first.c_str());
				///seppuku();
			}
			else
			{
				uint32_t crc32fromfilesystem	=crchex2int(crc32_pair[j].first.c_str());
				if (p->second.file_crc32==crc32fromfilesystem)
				{
					triple_ok++;
					if (flagdebug3)
						myprintf("01438: OK SOURCE %08d %s %s\n",(int)j,crc32_pair[j].first.c_str(),crc32_pair[j].second.c_str());
				}
				else
				{
					triple_error++;
					if (flagverbose)
					{
						myprintf("01439: KAPUTT CRC-32 expected %08X founded %08X %s\n",
						p->second.file_crc32,
						crc32fromfilesystem,
						crc32_pair[j].second.c_str());
					}
				}
			}
		}
		color_green();
		myprintf("01440: Triple OK       : %08d (CRC-32 stored, decompressed and filesystem)\n",triple_ok);
		if (triple_error)
			color_red();
		myprintf("01441: Triple ERRORS   : %08d (-crc32 failed against filesystem)\n",triple_error);
		color_restore();
	}
	


	status_e = status_e_hash+status_e_crc+status_e_blocks+triple_error;
	if (status_e)
	printbar('-');
	if (status_0)
	myprintf("01442$ WARNING         : %08d (Cannot say anything)\n",status_0);
	if (status_1)
	myprintf("01443: GOOD            : %08d of %08d (stored=decompressed)\n",status_1,total_files);
	if (status_e==0)
	{
		if (status_0)
			myprintf("01444: VERDICT         : UNKNOWN  (Cannot say anything)\n");
		else
			myprintf("01445: VERDICT         : OK                   (CRC-32 stored vs decompressed)\n");
	}
	else
	{
		myprintf("01446: WITH ERRORS\n");
		errors=2;
	}
	if (flagverify)
	{
		printbar('+');
		myprintf("01447: Re-testing (hashing) from filesystem (-verify) if possible\n");
		errors+=verify(false);
	}
	if (flagcollision)
		collision(true);
	
	if (read_errors)
		return 2;
	if (status_e!=0)
		return 2;
	return (errors+status_e)>0;
}
/*
We need something out of an object (Jidac), addfile() and scandir(),
because pthread does not like very much objects.
Yes, quick and dirty
*/
void myaddfile(uint32_t i_tnumber,DTMap& i_edt,string i_filename, int64_t i_date,int64_t i_size, bool i_flagcalchash)
{
	if (g_testifselected)
		if (pjidac!=NULL)
			if (!(*pjidac).isselected(i_filename.c_str(), false,i_size))
			{
				if (flagdebug3)
					myprintf("01469: discarded %s\n",i_filename.c_str());
				return;
			}
	///Raze to the ground ads and zfs as soon as possible
	if (!flag715)
		if (isads(i_filename))
			return;
	if (!flagforcezfs)
		if (iszfs(i_filename))
			return;
	if (minsize>0)
		if ((uint64_t)i_size<minsize)
		{
			if (flagdebug)
				myprintf("01470: (-minsize) too small %19s %s\n",migliaia(i_size),i_filename.c_str());
			return;
		}
	if (maxsize>0)
		if ((uint64_t)i_size>maxsize)
		{
			if (flagdebug)
				myprintf("01471: (-maxsize) too large %19s %s\n",migliaia(i_size),i_filename.c_str());
			return;
		}

	DT& d=i_edt[i_filename];

	d.date=i_date;
	d.size=i_size;
	d.attr=0;
	d.data=0;
	d.hexhash="";
/// this seems weird, and it is. but mutex slow downs about 10x. So use -noeta to be sure no races
	if (i_flagcalchash)
		if (!isdirectory(i_filename))
		{
			int64_t starthash=mtime();

			g_dimensione=0;
			
			franz_do_hash dummy(g_thechosenhash);
			if (flagdebug3)
				myprintf("01472: filehash on %s\n",i_filename.c_str());

			d.hexhash=dummy.filehash(0,i_filename,false,0,prendidimensionefile(i_filename.c_str()));

///			d.hexhash=hash_calc_file(flag2algo(),i_filename.c_str(),false,dummycrc,mtime(),prendidimensionefile(i_filename.c_str()),dummy,thefilesize);
			if (flagverbose)
			{
				myprintf("%s: |%s| [%d] %6.3f %Z\n",g_thechosenhash_str.c_str(),d.hexhash.c_str(),i_tnumber,(mtime()-starthash)/1000.0,i_filename.c_str());
			}
		}
///  thread safe, but... who cares?
	if (g_arraybytescanned.size()==0)
	{
		myprintf("01473: GURU g_arraybytescanned not pushed?\n");
		seppuku();
		return;
	}
	pthread_mutex_lock(&g_mylock);
	g_arraybytescanned[i_tnumber]+=i_size;
	g_arrayfilescanned[i_tnumber]++;

	if (!flagnoeta)
	{
		if (i_flagcalchash)
		{
			if (!(g_arrayfilescanned[i_tnumber] % 100))
			{
				for (unsigned int i=0; i<g_arraybytescanned.size();i++)
				{
					int tempo=(int)((mtime()-g_start)/1000.0);
					if (tempo<=0)
						tempo=1;
					myprintf("%s |%02d|%10s %12s @ %10s/s\n",g_thechosenhash_str.c_str(),i,tohuman(g_arraybytescanned[i]),migliaia(g_arrayfilescanned[i]),
					tohuman2(g_arraybytescanned[i]/tempo));
				}
				if ((!flagsilent) && (!flagnoconsole))
				{
					setupConsole();
					printf("\033[%dA",(int)g_arraybytescanned.size());
					restoreConsole();
				}
			}
		}
		else
		{
			if (!(g_arrayfilescanned[i_tnumber] % 1000))
			{
				for (unsigned int i=0; i<g_arraybytescanned.size();i++)
					myprintf("|%02d|%10s %12s\n",(int)i,tohuman(g_arraybytescanned[i]),migliaia(g_arrayfilescanned[i]));
				if ((!flagsilent) && (!flagnoconsole))
				{
					setupConsole();
					printf("\033[%dA",(int)g_arraybytescanned.size());
					restoreConsole();
				}
			}
		}
		fflush(stdout);
	}
	pthread_mutex_unlock(&g_mylock);
}
void myscandir(uint32_t i_tnumber,DTMap& i_edt,string filename, bool i_recursive,bool i_flagcalchash)
{
	if (!i_recursive)
		if (flagdebug3)
			myprintf("01474: myscandir of %s\n",filename.c_str());

	///Raze to the ground ads and zfs as soon as possible
	if (isads(filename))
	{
		if (flagverbose)
			myprintf("01475: Skip :$DATA ----> %s\n",filename.c_str());
		return;
	}
	if (!flagforcezfs)
		if (iszfs(filename))
		{
			if (flagverbose)
				myprintf("01476: Skip .zfs ----> %s\n",filename.c_str());
			return;
		}
#ifdef unix
// Add regular files and directories
  while (filename.size()>1 && filename[filename.size()-1]=='/')
    filename=filename.substr(0, filename.size()-1);  // remove trailing /
	struct stat sb;
	if (!lstat(filename.c_str(), &sb))
	{
		if (S_ISREG(sb.st_mode))
		myaddfile(i_tnumber,i_edt,filename, decimal_time(sb.st_mtime), sb.st_size,i_flagcalchash);
    // Traverse directory
		if (S_ISDIR(sb.st_mode))
		{
			myaddfile(i_tnumber,i_edt,filename=="/" ? "/" : filename+"/", decimal_time(sb.st_mtime),0, i_flagcalchash);
			DIR* dirp=opendir(filename.c_str());
			if (dirp)
			{
				for (dirent* dp=readdir(dirp); dp; dp=readdir(dirp))
				{
					if (strcmp(".", dp->d_name) && strcmp("..", dp->d_name))
					{
						string s=filename;
						if (s!="/") s+="/";
						s+=dp->d_name;
						if (i_recursive)
							myscandir(i_tnumber,i_edt,s,true,i_flagcalchash);
						else
						{
							if (!lstat(s.c_str(), &sb))
							{
								if (S_ISREG(sb.st_mode))
									myaddfile(i_tnumber,i_edt,s, decimal_time(sb.st_mtime), sb.st_size,i_flagcalchash);
								if (S_ISDIR(sb.st_mode))
									myaddfile(i_tnumber,i_edt,s=="/" ? "/" :s+"/", decimal_time(sb.st_mtime),0, i_flagcalchash);
							}
						}
					}
				}
				closedir(dirp);
			}
			else
			{
				if (!flagignore)
					perror(filename.c_str());
			}
		}
	}
	else
		perror(filename.c_str());
#else  // Windows: expand wildcards in filename
  // Expand wildcards
	WIN32_FIND_DATA ffd;
	string t=filename;
///	myprintf("01477:   %s\n",t.c_str());
	if (t.size()>0 && t[t.size()-1]=='/')
		t+="*";
	///myprintf("01478:   %s\n",t.c_str());
	HANDLE h=FindFirstFile(utow(t.c_str()).c_str(), &ffd);
	if (h==INVALID_HANDLE_VALUE && GetLastError()!=ERROR_FILE_NOT_FOUND && GetLastError()!=ERROR_PATH_NOT_FOUND)
		if (!flagignore)
			printerr("myscan",t.c_str(),0);
///	myprintf("01479: 22:   %s\n",t.c_str());
	while (h!=INVALID_HANDLE_VALUE)
	{
    // For each file, get name, date, size, attributes
		SYSTEMTIME st;
		int64_t edate=0;
		if (FileTimeToSystemTime(&ffd.ftLastWriteTime, &st))
			edate=st.wYear*10000000000LL+st.wMonth*100000000LL+st.wDay*1000000
				+st.wHour*10000+st.wMinute*100+st.wSecond;
		const int64_t esize=ffd.nFileSizeLow+(int64_t(ffd.nFileSizeHigh)<<32);
    // Ignore links, the names "." and ".." or any unselected file
		t=wtou(ffd.cFileName);
		if (flagdebug3) // sometimes Windows get very strange attributes
		{
			myprintf("01480: %08X MY new t2 %s\n",(unsigned int)ffd.dwFileAttributes,t.c_str());
			string temp=decodewinattribute(ffd.dwFileAttributes);
			myprintf("01481: %s\n",temp.c_str());
			myprintf("\n");
		}
		if (t=="." || t=="..")
			edate=0;  // don't add, of course
		if ((ffd.dwFileAttributes & FILE_ATTRIBUTE_REPARSE_POINT) && (!(ffd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)))
		{
				/// Houston, we have a strange deduplicated .vhdx file?
				/// add as by default
				if (flagverbose)
					myprintf("01482: Verbose: found something strange2 (VHDX?) %s\n",t.c_str());
		}
		else
		{
			///	A junction?
			if ((ffd.dwFileAttributes & FILE_ATTRIBUTE_REPARSE_POINT) && (ffd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
				edate=0;  // don't add
		}
		string fn=path(filename)+t;

    // Save directory names with a trailing / and scan their contents
    // Otherwise, save plain files
		if (edate)
		{
			if (ffd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
				fn+="/";
			myaddfile(i_tnumber,i_edt,fn, edate, esize, i_flagcalchash);

			if (i_recursive)
				if (ffd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
				{
					fn+="*";
					myscandir(i_tnumber,i_edt,fn,true,i_flagcalchash);
				}
		}

		if (!FindNextFile(h, &ffd))
		{
			if (GetLastError()!=ERROR_NO_MORE_FILES)
				printerr("myscan2",fn.c_str(),ffd.dwFileAttributes);
			break;
		}
	}
  FindClose(h);
#endif // corresponds to #ifdef (#ifdef unix)
}




bool	isbackuppart(string i_partname,string i_mask)
{
#ifdef _WIN32
	i_partname	=stringtolower(i_partname);
	i_mask		=stringtolower(i_mask);
#endif // corresponds to #ifdef (#ifdef _WIN32)

	if (flagdebug2)
		myprintf("01483: i_partname |%s|  i_mask |%s|\n",i_partname.c_str(),i_mask.c_str());

	if (isdirectory(i_partname))
	{
		if (flagdebug)
			myprintf("01484: i_partname is a folder |%s|\n",i_partname.c_str());
		return false;
	}
	if (i_partname=="")
	{
		if (flagdebug)
			myprintf("01485: partname empty\n");
		return false;
	}

	if (!iszpaq(i_partname))
	{
		if (flagdebug)
			myprintf("01486: partname not a .zpaq |%s|\n",i_partname.c_str());
		return false;
	}

	if (i_mask=="")
	{
		if (flagdebug)
		{
			myprintf("01487: i_mask empty\n");
			///string onlyname=extractfilename(i_partname);
			if (i_partname.size()>14)
				i_mask=i_partname.substr(0,i_partname.size()-14);
			myprintf("01488: new i_mask =>|%s|\n",i_mask.c_str());

		}
	}

	string candidato=extractfilename(i_partname);
	if (candidato.size()<14)
	{
		if (flagdebug)
			myprintf("01489: partname too short of |%s|\n",i_partname.c_str());
		return false;
	}


	myreplace(i_mask,"????????.zpaq","");

	string onlyname=prendinomefileebasta(i_mask);
	if (onlyname.size()==0)
	{
		if (flagdebug)
			myprintf("01490: onlyfilename empty of mask |%s|\n",i_mask.c_str());
		return false;
	}

	if (mypos(onlyname,candidato)!=0)
	{
		if (flagdebug)
			myprintf("01491: cannot match |%s| in |%s|\n",onlyname.c_str(),candidato.c_str());
		return false;
	}

	if (candidato[candidato.size()-14]!='_')
	{
		if (flagdebug)
			myprintf("01492: char -14 not _ in |%s|\n",candidato.c_str());
		return false;
	}

	int	thepart=getpartnumber(i_partname);
	if (thepart<0)
	{
		if (flagdebug)
			myprintf("01493: thepart <0 for %s\n",i_partname.c_str());
		return false;
	}
	return true;
}



bool compare_second(const std::pair<string,string>& a,const std::pair<string,string>& b)
{
	return (a.second<b.second);
}

class multipart
{
	private:
	string			thefilename;

	public:
	vector<s_fileandsize> 	filenamearray;
	vector<s_fileandsize> 	partarray;

	string	lastpart;
	string	nextpart;

	int		howmanychunks;
	bool	ismultipart;
	bool	isgood;
	int		howmanyjolly;
	int64_t	filenamearray_size;

	multipart(string i_filename):
	howmanychunks(0),
	ismultipart(false),
	isgood(false),
	howmanyjolly(0),
	filenamearray_size(0)
	{
		if (!iszpaq(i_filename))
			i_filename+=".zpaq";
#ifdef _WIN32
		i_filename=stringtolower(i_filename);
#endif // corresponds to #ifdef (#ifdef _WIN32)
///	we really want a path, even relative
		thefilename	=i_filename;
		lastpart	="";
		nextpart	="";

		if (i_filename=="")
		{
			myprintf("01494: multipartfilename is empty\n");
			return;
		}
		for (unsigned int i=0;i<i_filename.size();i++)
			if (i_filename[i]=='?')
				howmanyjolly++;
		ismultipart=howmanyjolly>0;

		if (!ismultipart)
			return;
		enumerate();

		partarray.clear();
		int parts	=0;  // number of existing parts in multipart
		string part0=subpart(i_filename,0);
		if (flagdebug3)
		myprintf("01495: part0 %s i_filename %s\n",part0.c_str(),i_filename.c_str());
		
		string thehole	="";
		for (int i=1;; ++i)
		{
			string partname=subpart(i_filename,i);
			if (flagdebug2)
			myprintf("01496: partname on %08d %s\n",i,partname.c_str());
			
			if (partname==part0)
				error("84285: too many archive parts");
			if (!fileexists(partname))
			{
				thehole=partname;
				if (flagdebug3)
					myprintf("01497: filenamearraysize %08d partname %08d does not exists\n",filenamearray.size(),i,partname.c_str());
				if (i==1)
					thehole="";
				else
					if ((filenamearray.size()>0) && (i>0))
				{
					if (flagdebug3)
					{
						myprintf("01498: last filenamearraysize %s\n",filenamearray[filenamearray.size()-1].filename.c_str());
						myprintf("01499: i-1                    %s\n",subpart(i_filename,i-1).c_str());
					}
					if (filenamearray[filenamearray.size()-1].filename==subpart(i_filename,i-1)) 
						thehole="";
				}
				break;
			}
			else
			{
				s_fileandsize myblock;
				myblock.filename=partname;
				myblock.size=prendidimensionefile(partname.c_str());
				myblock.attr=0;
				myblock.date=0;
				myblock.isdir=isdirectory(partname);
				myblock.flaghashstored=false;
				partarray.push_back(myblock);
				if (flagdebug2)
					myprintf("01500: pushing on partarray the partname %s\n",partname.c_str());
			}
			++parts;
		}
		std::sort(partarray.begin(),partarray.end(),comparefilename);
		isgood=(thehole=="");// filenamearray.size()==partarray.size();

		if (thehole!="")
		{
		///	myprintf("01501: PART NUMBER MISMATCH: disk %s vs part %s (HOLE IN %s)\n",migliaia(filenamearray.size()),migliaia2(partarray.size()),thehole.c_str());
			myprintf("01502: [1] AT LEAST ONE HOLE DETECTED! <<%Z>>\n",thehole.c_str());
			
			if (filenamearray.size()>partarray.size()) // this should be
				for (unsigned int i=0;i<filenamearray.size();i++)
				{
					bool trovato=false;
					for (unsigned int j=0;j<partarray.size();j++)
						if (filenamearray[i].filename==partarray[j].filename)
						{
							trovato=true;
							break;
						}
					if (!trovato)
						if (flagdebug3)
							myprintf("01503: Filename not matched %s\n",filenamearray[i].filename.c_str());
				}
		}
		if (partarray.size()>0)
		{
			if (fileexists(subpart(i_filename, parts)))
				lastpart=subpart(i_filename, parts);
			nextpart=subpart(i_filename, parts+1);
		}
		else
			nextpart=subpart(i_filename, 1);
	}

	string enumerate()
	{

		/// UNIX get strange behaviour with folders and jolly
		/// this "thing" is weird, but works on Win and *nix
		DTMap thedt;
		flagforcezfs=true;
		g_arraybytescanned.clear();
		g_arrayfilescanned.clear();
		g_arraybytescanned.push_back(0);
		g_arrayfilescanned.push_back(0);
		string onlypath=extractfilepath(thefilename);
		string onlyname=extractfilename(thefilename);
		myreplace(onlyname,"????????.zpaq","");
		myreplace(onlyname,".zpaq","");

		if (flagdebug3)
		{
			myprintf("01504: scan by   %s\n",onlypath.c_str());
			myprintf("01505: filename  %s\n",thefilename.c_str());
			myprintf("01506: onlyname  %s\n",onlyname.c_str());
		}

		string temppath=onlypath;
		if (mypos("/",temppath)==-1)
			temppath="./"+temppath;

		myscandir(0,thedt,temppath,false,false);
		eol();
		///printbar(' ',false);
		///myprintf("\r");

		if (flagdebug)
			myprintf("01507: scanned %s\n",migliaia(thedt.size()));

		if (thedt.size()==0)
			return "";

		filenamearray.clear();
		for (DTMap::iterator p=thedt.begin(); p!=thedt.end(); ++p)
		{
			s_fileandsize myblock;
			string currentfilename=p->first;
#ifdef _WIN32
			currentfilename=stringtolower(currentfilename);
#endif // corresponds to #ifdef (#ifdef _WIN32)
			if (isbackuppart(currentfilename,onlyname))
			{
				int thepartnumber=getpartnumber(currentfilename);
				if (thepartnumber>0)
				{
					myblock.filename		=currentfilename;
					myblock.size			=p->second.size;
					myblock.attr			=p->second.attr;
					myblock.date			=p->second.date;
					myblock.isdir			=false;
					myblock.flaghashstored	=false;
					filenamearray.push_back(myblock);
	///				myprintf("01508: %s %s\n",estensione.c_str(),p->first.c_str());
				}
			}
			else
			{
				if (flagdebug3)
					myprintf("01509: Not backup part %s\n",currentfilename.c_str());
			}
		}
		std::sort(filenamearray.begin(),filenamearray.end(),comparefilename);
		if (flagdebug2)
			myprintf("01510: filenamearray size post %s\n",migliaia(filenamearray.size()));

		if (filenamearray.size()==0)
			return "";
		else
		{
			if (flagdebug3)
				for (int unsigned i=0;i<filenamearray.size();i++)
					myprintf("01511: filenamearray %08d %s\n",(int)i,filenamearray[i].filename.c_str());
			return filenamearray[filenamearray.size()-1].filename;
		}
	}
};


bool iswildcard(const string& i_filename)
{
	return ((strrchr(i_filename.c_str(),'?')) || (strrchr(i_filename.c_str(),'*')));
}




bool Jidac::acceptonlynot(string i_filename)
{
	if (i_filename=="")
		return false;
	bool matched;
	if (notfiles.size()>0)
		for (unsigned i=0; i<notfiles.size(); ++i)
		{
			if (flagdebug3)
				myprintf("01512: check notfiles %03d %s  on filename %s\n",(int)i,notfiles[i].c_str(),i_filename.c_str());
			if (ispath(notfiles[i].c_str(),i_filename.c_str()))
			{
				if (flagdebug3)
					myprintf("01513: discarded because ispath notfiles[i] %s %s\n",notfiles[i].c_str(),i_filename.c_str());
				return false;
			}
		}

	if (onlyfiles.size()>0)
	{
		matched=false;
		for (unsigned i=0;i<onlyfiles.size() && !matched; ++i)
		{
			if (flagdebug3)
				myprintf("01514: check only %03d %s  on filename %s\n",(int)i,onlyfiles[i].c_str(),i_filename.c_str());
			if (ispath(onlyfiles[i].c_str(),i_filename.c_str()))
				matched=true;
		}
		if (!matched)
		{
			if (flagdebug3)
				myprintf("01515: discarded because not onlyfiles\n");
			return false;
		}
	}
	return true;
}
// get first-level folders (no recursion).  NO FULL PATH!
int Jidac::listfolders(string i_path,vector<string>* o_thelist)
{
	if (o_thelist==NULL)
	{
		myprintf("01516: GURU o_thelist is null\n");
		return 0;
	}
	if (!isdirectory(i_path))
		i_path+="/";
	vector<string> tobesorted;

#ifndef unix
	if (flagdebug2)
		myprintf("01517: i_path      %s\n",i_path.c_str());
	i_path=extractfilepath(i_path);
	std::wstring wpattern = utow(i_path.c_str())+utow("*.*");
	const std::string s_pattern(wpattern.begin(),wpattern.end());
	if (flagdebug3)
		myprintf("01518: get handle for w pattern %s\n",wtou(wpattern.c_str()).c_str());
	WIN32_FIND_DATAW findfiledata;
	HANDLE myhandle=FindFirstFileW(wpattern.c_str(),&findfiledata);
	if (myhandle==INVALID_HANDLE_VALUE)
	{
		if (flagdebug)
			myprintf("01519: Invalid handle %s\n",s_pattern.c_str());
		return 0;
	}
	do
	{
		std::string t=wtou(findfiledata.cFileName);
		if ((t!=".") && (t!=".."))
		{
			std::wstring wfilepath;
			///wfilepath=utow(i_path.c_str())/*+L"\\"*/+findfiledata.cFileName;
			wfilepath=findfiledata.cFileName;
			const std::string s_wfilepath(wfilepath.begin(),wfilepath.end());
			if (flagdebug3)
				myprintf("01520: Working on %s ",s_wfilepath.c_str());
			if (findfiledata.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
			{
				if (flagdebug3)
					myprintf(": OK PUSH BACK FOLDER\n");
				string readytopush=wtou(wfilepath.c_str());
				if (acceptonlynot(t))
					tobesorted.push_back(readytopush);
			}
		}
	} while(FindNextFile(myhandle,&findfiledata)==TRUE);
	if (myhandle)
		FindClose(myhandle);
#else
	DIR 	*dir;
	const struct 	dirent *ent;
	if ((dir=opendir(i_path.c_str()))==NULL)
	{
		myprintf("01521: cannot scan in <<%s>>\n",i_path.c_str());
		return 0;
	}
	while ((ent=readdir(dir))!=NULL)
	{
		string thename=ent->d_name;
		string fullname=i_path+thename;
		if (flagdebug3)
			myprintf("01522: working on thename %s fullname %s\n",thename.c_str(),fullname.c_str());
		if ((thename!=".") && (thename!="..") && (thename!=".zfs"))
		{
			if (acceptonlynot(thename))
			{
				if (direxists(fullname))
				{
					tobesorted.push_back(thename);
					if (flagdebug3)
						myprintf("01523: no direxists fullname %s\n",fullname.c_str());
				}
				else
				{
					if (flagdebug3)
						myprintf("01524: no direxists fullname %s\n",fullname.c_str());
				}
			}
		}
	}
	closedir (dir);
#endif // corresponds to #ifndef (#ifndef unix)

	if (flagdebug)
		for (unsigned int i=0;i<tobesorted.size();i++)
			myprintf("01525: %03d  %s\n",(int)i,tobesorted[i].c_str());
	std::sort(tobesorted.begin(),tobesorted.end());
	for (unsigned int i=0;i<tobesorted.size();i++)
		(*o_thelist).push_back(tobesorted[i]);
	return tobesorted.size();
}


int Jidac::multisomething()
{
	if (fullarchive=="")
	{
		if (command=='x')
			return extract();
		else
		if (command=='t')
			return test();
		else
		{
			myprintf("01526! unknown multisomething %c\n",command);
			return 2;
		}
	}

	string estensione=prendiestensione(fullarchive);
	myprintf("01527: Searching for jolly archive(s) in <<%s>> for extension <<%s>>\n",fullarchive.c_str(),estensione.c_str());

	g_bytescanned	=0;
	g_filescanned	=0;
	g_worked		=0;
	flagskipzfs		=true;  // strip down zfs
	DTMap		thedt;

#ifdef unix
	if (flagdebug)
		myprintf("01528: running on NIX\n");
	vector<string> candidate;
	listfiles(extractfilepath(fullarchive),estensione,true,&candidate);
	if (flagdebug3)
		myprintf("01529: candidate %s with pattern %s\n",migliaia(candidate.size()),fullarchive.c_str());
	for (unsigned int i=0;i<candidate.size();i++)
	{
		string filename=candidate[i];
		if (flagdebug3)
			myprintf("01530: filename %08d %s\n",(int)i,filename.c_str());

		if (jollymatch(fullarchive.c_str(),filename.c_str()))
		{
			if (flagdebug3)
			{
				myprintf("01531: matched <<%Z>>\n",filename.c_str());
			}
			DT& d=thedt[filename];
			d.date			=0;
			d.creationdate	=0;
			d.accessdate	=0;
			d.size			=0;
			d.attr			=0;
			d.data			=0;
		}
		else
		{
			if (flagdebug3)
				myprintf("01532: DISCARDED %s in %s\n",fullarchive.c_str(),filename.c_str());
		}
	}
#else
	scandir(false,thedt,fullarchive,false);
	eol();
	///printbar(' ',false);
	///myprintf("\r");
#endif // corresponds to #ifdef (#ifdef unix)

	if (thedt.size()==0)
	{
		myprintf("01533: no archive founded => quit\n");
		return 1;
	}
	myprintf("01534: Founded %s archive(s), working\n",migliaia(thedt.size()));
	int	risultato=0;
	int therun=0;
	for (DTMap::iterator p=thedt.begin(); p!=thedt.end(); ++p)
	{
		therun++;
		jidacreset();
		archive=p->first;

		int riscomando=0;
		if (command=='x')
			riscomando=extract();
		else
		if (command=='t')
			riscomando=test();

		string stato="";
		if (riscomando==0)
			stato="OK";
		else
		if (riscomando==1)
			stato="WARNING";
		else
			stato="ERROR";


		printbar('-');
		myprintf("\r");
		myprintf("01535: Status %08d/%08d: %d %s on <<%Z>>\n",therun,thedt.size(),riscomando,stato.c_str(),archive.c_str());
		if (flagbig)
		{
			if (riscomando==0)
				bigok();
			else
			if (riscomando==1)
				bigwarning();
			else
				bigerror();
		}

		printbar('-');

		risultato+=riscomando;
	}
	return risultato;
}


///	parameters to run scan threads
struct tparametri
{
	bool		recursive;
	string 		directorytobescanned;
	DTMap		theDT;
	bool		flagcalchash;
	uint64_t	timestart;
	uint64_t	timeend;
	int	tnumber;
};
///	run a myscandir() instead of Jidac::scandir() (too hard to use a member)
void * scansiona(void *t)
{
	assert(t);
	tparametri* par= ((struct tparametri*)(t));
	DTMap& tempDTMap = par->theDT;
	myscandir(par->tnumber,tempDTMap,par->directorytobescanned,par->recursive,par->flagcalchash);
	par->timeend=mtime();
	pthread_exit(NULL);
	return 0;
}

#ifdef _WIN32
typedef DWORD (*callback_avanzamento)(
LARGE_INTEGER, // file size
LARGE_INTEGER, // bytes transferred
LARGE_INTEGER, // bytes in stream
LARGE_INTEGER, // bytes transferred for stream
DWORD, // current stream
DWORD, // callback reason
HANDLE, // handle to source file
HANDLE, // handle to destination file
LPVOID // from CopyFileEx
); // type for conciseness

DWORD  win_avanzamento(
LARGE_INTEGER TotalFileSize, // file size
LARGE_INTEGER TotalBytesTransferred, // bytes transferred
LARGE_INTEGER StreamSize, // bytes in stream
LARGE_INTEGER StreamBytesTransferred, // bytes transferred for stream
DWORD dwStreamNumber, // current stream
DWORD dwCallbackReason, // callback reason
HANDLE hSourceFile, // handle to source file
HANDLE hDestinationFile, // handle to destination file
LPVOID lpData // from CopyFileEx
)
{
	static int lastpercentuale=0;

	if (int64_t(dwStreamNumber)+int64_t(dwCallbackReason)+int64_t(hSourceFile)+int64_t(hDestinationFile)+int64_t(lpData)==12445)
		if (StreamSize.HighPart==TotalBytesTransferred.HighPart)
			if (StreamBytesTransferred.HighPart==StreamSize.HighPart)
				lastpercentuale++; // compiler be quiet!

	int64_t numeratore	=(TotalBytesTransferred	.HighPart*2147483648+TotalBytesTransferred.LowPart)*100 ;
	int64_t	denominatore=(TotalFileSize			.HighPart*2147483648+TotalFileSize.LowPart)+1;
	if (denominatore>LARGEFILE)
	{
		int percentuale=numeratore/denominatore;

		if (percentuale==1)
			myprintf("\r%s",tohuman(denominatore));
		else
			percentuale/=5;

		if (percentuale!=lastpercentuale)
		{
			myprintf(".");
			lastpercentuale=percentuale;
		}
	}

	return  PROGRESS_CONTINUE;
}
bool windows_copy(string i_src_filename,string i_dest_filename,callback_avanzamento callback_fn)
{
	wstring in_widename=utow(i_src_filename.c_str());
	wstring out_widename=utow(i_dest_filename.c_str());

	LPPROGRESS_ROUTINE prog_fn = (LPPROGRESS_ROUTINE) callback_fn;
	if (callback_fn)
		return (CopyFileEx (in_widename.c_str(),out_widename.c_str(),prog_fn,NULL,0,0)!=0);
	else
		return (CopyFile (in_widename.c_str(),out_widename.c_str(),TRUE)!=0);
}
#endif // corresponds to #ifdef (#ifdef _WIN32)

/// make a "robocopy" from source to destination file.
/// if "someone" call with valid parameters do NOT do a getfileinfo (slow)
string Jidac::secure_copy_file(
const string& i_filename,const string& i_outfilename,int64_t i_startcopy,int64_t i_totalsize,int64_t i_totalcount,int64_t& o_writtensize,int64_t& o_donesize,int64_t& o_donecount,
int64_t i_sorgente_size,
int64_t i_sorgente_date,
int64_t i_sorgente_attr,
int64_t i_destinazione_size,
int64_t i_destinazione_date,
int64_t i_destinazione_attr,
unsigned char*	i_buffer,
size_t			i_buffersize
)
{
	if (i_buffer==NULL)
	{
		myprintf("01536: GURU buffer null\n");
		seppuku();
		return "";
	}
	if (i_buffersize==0)
	{
		myprintf("01537: buffer size 0\n");
		seppuku();
		return "";
	}

	static int ultimapercentuale=0;
	if (flagdebug3)
	{
		myprintf("\n");
		myprintf("01538: From:   %s\n",i_filename.c_str());
		myprintf("01539: To:     %s\n",i_outfilename.c_str());
	}
	if (i_filename=="")
		return "30833:SOURCE-EMPTY";
	if (i_outfilename=="")
		return "30836:DEST-EMPTY";

	int64_t s1=mtime();
	if (isdirectory(i_filename))
	{
		makepath(i_outfilename);
		return "OK";
	}
	g_robocopy_makepath+=mtime()-s1;

	int64_t sorgente_dimensione		=0;
	int64_t sorgente_data			=0;
	int64_t sorgente_attr			=0;
	int64_t destinazione_dimensione	=0;
	int64_t destinazione_data		=0;
	int64_t destinazione_attr		=0;
	bool	sorgente_esiste			=false;
	bool	destinazione_esiste		=false;
	/*
	hopefully the source is ALWAYS existing!
	int64_t start_sorgente_esiste=mtime();
	sorgente_esiste		=getfileinfo(i_filename,sorgente_dimensione,sorgente_data,sorgente_attr);
	g_robocopy_check_sorgente+=mtime()-start_sorgente_esiste;
	*/
	sorgente_esiste					=true;		// trust in caller
	sorgente_dimensione				=i_sorgente_size;
	sorgente_data					=i_sorgente_date;
	sorgente_attr					=i_sorgente_attr;
	if (i_destinazione_size>=0)
	{
		/// someone call us with valid size=> take the parameters
		destinazione_esiste			=true;
		destinazione_dimensione		=i_destinazione_size;
		destinazione_data			=i_destinazione_date;
		destinazione_attr			=i_destinazione_attr;
	}
	else
	{
		/// houston, we have to make ourself
		int64_t start_destinazione_esiste=mtime();
		destinazione_esiste	=getfileinfo(i_outfilename,destinazione_dimensione,destinazione_data,destinazione_attr);
		g_robocopy_check_destinazione+=mtime()-start_destinazione_esiste;
	}
	if (flagdebug3)
	{
		myprintf("01540: Sorgente     esiste  %d\n",(int)sorgente_esiste);
		myprintf("01541: Sorgente     size    %s\n",migliaia(sorgente_dimensione));
		myprintf("01542: Sorgente     data    %s\n",migliaia(sorgente_data));
		myprintf("01543: Destinazione esiste  %d\n",(int)destinazione_esiste);
		myprintf("01544: Destinazione size    %s\n",migliaia(destinazione_dimensione));
		myprintf("01545: Destinazione data    %s\n",migliaia(destinazione_data));
		myprintf("\n");
	}
	if (!flagdonotforcexls)
		if (isxls(i_filename))
		{
///	Old Office (2000) can change xls (and ppt) metadata without "touching"
/// Therefore size-and-date algo does not work, to detect change, making hash check fail
/// (zpaq, rsync, robocopy for example)
/// The changes are in the beginning of the file, so a 64K block comparison is normally
/// faster than the full hash computation (for different files).
/// Obviously for the very same files it is almost identical
			if (flagdebug2)
				myprintf("01546: enforcing xls/ppt test %s\n",i_filename.c_str());
			int64_t s2=mtime();
			destinazione_esiste=isfilesequal(i_filename,i_outfilename,flagzero);
			g_robocopy_isequal+=mtime()-s2;
			if (destinazione_esiste)
			{
				if (flagdebug2)
					myprintf("01547: Equal XLS: skip %s\n",i_outfilename.c_str());
				int64_t s3=mtime();
				close(i_outfilename.c_str(),sorgente_data,sorgente_attr);
				g_robocopy_close+=mtime()-s3;
				return "=";
			}
			else
			{
				if (flagdebug2)
					myprintf("01548: Different XLSs!\n");
			}
		}
	if (destinazione_esiste)
	{
		if (flagdebug3)
			myprintf("01549: Esiste1\n");
		if (sorgente_esiste)
		{
			if (flagdebug3)
			{
				myprintf("01550: Esiste2\n");
			}
				if (destinazione_dimensione==sorgente_dimensione)
				{
					if (flagdebug3)
						myprintf("01551: Stessa dimensione\n");
					if (flagdebug3)
					{
						myprintf("01552: PPP %s\n",migliaia(myabs(destinazione_data,sorgente_data)));
					}
				/// this 2 is really important: it is the modulo-differences
				/// 1 or even 0 is not good for NTFS or Windows
					if (myabs(destinazione_data,sorgente_data)<=2)
					{
						if (flagdebug3)
							myprintf("01553: Stessa data\n");
						if (flagkill)
							if (sorgente_attr!=destinazione_attr)
							{
								int64_t s3=mtime();
								close(i_outfilename.c_str(),sorgente_data,sorgente_attr);
								g_robocopy_close2+=mtime()-s3;
							}
						o_writtensize	+=sorgente_dimensione;
						o_donesize		+=sorgente_dimensione;
						o_donecount++;
						if (!flagnoeta)
						{
							int percentuale=100*o_donecount/(i_totalcount+1);
							if (percentuale%10==0)
								if (percentuale!=ultimapercentuale)
								{
									ultimapercentuale=percentuale;
									int percentualebyte=100*o_donesize/(i_totalsize+1);
									double tempotrascorso=((mtime()-i_startcopy)/1000.0);
									double tempototale=(100.0/percentuale)*tempotrascorso;
									double tempoleft=tempototale-tempotrascorso;
									myprintf("[%02d %%] %10s / %s (%11s / %s [%02d %%]) ETA %02d:%02d:%02d\n",percentuale,migliaia(o_donecount),migliaia2(i_totalcount),tohuman(o_donesize),tohuman2(i_totalsize),
									percentualebyte,int(tempoleft/3600), int(tempoleft/60)%60, int(tempoleft)%60);
								}
						}
						return "=";
					}
				}
		}
		if (flagkill)
			if ((!flagappend) && (!iszpaq(i_outfilename)))
			{
				int64_t s4=mtime();
				delete_file(i_outfilename.c_str());
				g_robocopy_delete+=mtime()-s4;

				if (flagdebug3)
					myprintf("01554: Cancellato %s\n",i_outfilename.c_str());
			}
	}
	if (!flagkill)
		return "OK";


#ifdef _WIN32
	if (flagbig)
	{
		bool 	copyresult=false;
		int64_t sw1=mtime();
		if (flagnoeta)
			copyresult=windows_copy(i_filename,i_outfilename,NULL);
		else
			copyresult=windows_copy(i_filename,i_outfilename,win_avanzamento);
		g_robocopy_fread+=mtime()-sw1;

		if (!flagnoeta)
			if (sorgente_dimensione>LARGEFILE)
				myprintf("\r                              \r");
		if (copyresult)
		{
			int64_t sw2=mtime();
			close(i_outfilename.c_str(),sorgente_data,sorgente_attr);
			g_robocopy_touch+=mtime()-sw2;
			o_donecount++;
			o_writtensize+=sorgente_dimensione;
			o_donesize+=sorgente_dimensione;
			if (!flagnoeta)
				myavanzamento(o_donesize,i_totalsize,i_startcopy);
			return "OK";
		}
		else
			return "ERROR";
	}
#endif // corresponds to #ifdef (#ifdef _WIN32)

	int64_t s5=mtime();
	FILE* inFile = freadopen(i_filename.c_str());
	g_robocopy_readopen+=mtime()-s5;
	if (inFile==NULL)
	{
#ifdef _WIN32
		int err=GetLastError();
#else
		int err=1;
#endif // corresponds to #ifdef (#ifdef _WIN32)
		myprintf("\n");
		myprintf("01555: ERR <%s> kind %d\n",i_filename.c_str(),err);
		return "KAPUTT";
	}
	if (flagappend)
	{
		if (destinazione_dimensione>=sorgente_dimensione)
			flagappend=false;	// full overwrite
		if (!iszpaq(i_filename))
		{
			if (flagdebug)
				myprintf("01556: not a ZPAQ / not flagappend!\n");
			flagappend=false;
		}
		else
		{
			if (flagdebug)
				myprintf("01557: we have a ZPAQ and a --append!\n");
		}
	}
	/// to fix excluded myaddfiles()

	int64_t s6=mtime();
	///	makepath(i_outfilename);
	string percorso=extractfilepath(i_outfilename);
	if (!direxists(percorso))
		makepath(i_outfilename);
	g_robocopy_makepath2+=mtime()-s6;

	int64_t s7=mtime();
	FILE* outFile=NULL;
	if (flagdebug)
	{
		if (fileexists(i_outfilename))
			myprintf("01558: ESISTE file %s\n",i_outfilename.c_str());
		else
			myprintf("01559: NON ESISTE APPEND %s\n",i_outfilename.c_str());
	}
	if (flagappend)
		if (!isfilesequal(i_filename,i_outfilename,true))
		{
			if (flagdebug)
				myprintf("01560: fast check failed, turn back to full copy %s %s\n",i_filename.c_str(),i_outfilename.c_str());
			flagappend=false;
		}
#ifdef _WIN32
	wstring widename=utow(i_outfilename.c_str());
	if (flagappend)
	{
		if (flagdebug)
		{
			myprintf("\n");
			myprintf("01561: Apro con APPEND \n");
		}
		outFile=_wfopen(widename.c_str(), L"ab" );
	}
	else
	{
		if (flagdebug)
		{
			myprintf("\n");
			myprintf("01562: Apro con WRITE \n");
		}
		outFile=_wfopen(widename.c_str(), L"wb" );
	}
#else
	if (flagappend)
		outFile=fopen(i_outfilename.c_str(), "ab");
	else
		outFile=fopen(i_outfilename.c_str(), "wb");
#endif // corresponds to #ifdef (#ifdef _WIN32)
	if (outFile==NULL)
	{
		fclose(inFile);
		return "30847:CANNOT OPEN outfile "+i_outfilename;
	}
	g_robocopy_openoutfile+=mtime()-s7;

	size_t readSize;
	int larghezzaconsole=terminalwidth();
	if (larghezzaconsole>=50)
		larghezzaconsole=50;
	else
		larghezzaconsole=0;
	if (flagnoeta)
		larghezzaconsole=0;
	int64_t scrittitotali=0;
	int64_t dascrivere=sorgente_dimensione;
	int lastbarra=0;
	if ((sorgente_dimensione>LARGEFILE) && (larghezzaconsole>0))
		myprintf("%s",tohuman(sorgente_dimensione));
	if (flagappend)
	{
		if (destinazione_dimensione<sorgente_dimensione)
		{
			if (flagdebug3)
			{
				myprintf("\n");
				myprintf("01563: Faccio APPEND\n");
				myprintf("01564: Sorgente dimensione     %19s\n",migliaia(sorgente_dimensione));
				myprintf("01565: Destinazione dimensione %19s\n",migliaia(destinazione_dimensione));
			}
			fseeko(inFile	,destinazione_dimensione, SEEK_SET);
			if (flagdebug3)
				myprintf("01566: Seekato a %s\n",migliaia(destinazione_dimensione));
			dascrivere=sorgente_dimensione-destinazione_dimensione;
			if (flagdebug3)
				myprintf("01567: Da scrivere             %19s\n",migliaia(dascrivere));
		}
	}
	int64_t s8=mtime();
	int64_t maxspeed 						= 0;
	if (g_sftp_bandwidth>0)
		maxspeed=g_sftp_bandwidth;
	
	bool speed_control_enabled 				= (maxspeed > 0);
	static int64_t last_control_time 		= 0;
	static int64_t bytes_at_last_control	= 0;
	static int64_t total_bytes_written 		= 0;  // Global counter
	static int64_t copy_start_time 			= 0;  // Copy start time
	static int base_sleep_ms 				= 0;  // Base pause to apply

	// Initialize times at the beginning of the copy
	if (speed_control_enabled && last_control_time == 0) 
	{
		copy_start_time = last_control_time = mtime();
		bytes_at_last_control = 0;
	}

	while (!feof(inFile) && !ferror(inFile))
	{
		readSize = fread(i_buffer, 1, i_buffersize, inFile);
		if (readSize == 0)
			break;
			
		if (flagzero)
			memset(i_buffer, 0, i_buffersize);
			
		int64_t s11 = mtime();
		int scritti = fwrite(i_buffer, 1, readSize, outFile);
		g_robocopy_fwrite += mtime() - s11;
		
		// Write error check
		if (scritti != (int)readSize)
		{
			color_red();
			myprintf("63138: Error writing to output file: wrote %s of %s bytes\n", migliaia(scritti), migliaia2(readSize));
			color_restore();
			break;
		}
		
		scrittitotali 			+= scritti;
		o_donesize 				+= scritti;
		o_writtensize 			+= scritti;
		total_bytes_written 	+= scritti;

		if (speed_control_enabled)
		{
			const int control_interval_ms = 500; // Interval
			int64_t current_time = mtime();
			int64_t time_since_last_control = current_time - last_control_time;

			// Recalculate the pause only at regular intervals
			if (time_since_last_control >= control_interval_ms)
			{
				// Calculation based on global average speed from the start
				int64_t total_elapsed = current_time - copy_start_time;
				if (total_elapsed > 0)
				{
					double current_avg_speed = (double)total_bytes_written * 1000.0 / total_elapsed;
					double speed_ratio = current_avg_speed / maxspeed;
					
					if (speed_ratio > 1.1) // Se supera del 10% il target
					{
						// Calculate pause needed to bring back to target speed
						double excess_ratio = speed_ratio - 1.0;
						base_sleep_ms = (int)(excess_ratio * 20); // Gradual increment
						if (base_sleep_ms > 50) 
							base_sleep_ms = 50; // Maximum limit
					}
					else if (speed_ratio < 0.9) // Se sotto del 10% dal target
					{
						// Gradually reduce the pause
						base_sleep_ms = (int)(base_sleep_ms * 0.8);
						if (base_sleep_ms < 0) 
							base_sleep_ms = 0;
					}
					// Se siamo nel range 90%-110% non cambiamo nulla (zona morta)
				}

				// Debug every 2 seconds
				static int64_t last_debug_time = 0;
				if (flagverbose)
					if (current_time - last_debug_time > 2000)
					{
						int64_t bytes_in_interval 	= total_bytes_written - bytes_at_last_control;
						double interval_speed 		= (double)bytes_in_interval * 1000.0 / time_since_last_control;
						double global_speed 		= (double)total_bytes_written * 1000.0 / (current_time - copy_start_time);
						
						myprintf("\n");
						myprintf("Speed %10s/s|W=%10s|Avg %10s/s of %s/s|Pause %04d ms ",
						tohuman(interval_speed), 
						tohuman2(total_bytes_written),
						tohuman3(global_speed),
						tohuman4(maxspeed),
						base_sleep_ms);
						last_debug_time = current_time;
					}

				// Reset for the next interval
				last_control_time 		= current_time;
				bytes_at_last_control 	= total_bytes_written;
			}

			// Apply the constant pause after each write
			if (base_sleep_ms > 0)
			{
			#ifdef _WIN32
				Sleep(base_sleep_ms);
			#else
				usleep(base_sleep_ms * 1000); // usleep prende microsecondi
			#endif
			}
		}
		else
		{
			/*
			static bool bypass_shown = false;
			if (!bypass_shown)
			{
				myprintf("\n[SPEED CONTROL] Going FULL!\n");
				bypass_shown = true;
			}
			*/
		}
		
		if (!flagnoeta)
		{
			if ((sorgente_dimensione > LARGEFILE) && (larghezzaconsole > 0))
			{
				int barra = larghezzaconsole * scrittitotali / (sorgente_dimensione + 1);
				if (barra > lastbarra)
				{
					myprintf(".");
					lastbarra = barra;
				}
			}
			else
				myavanzamento(o_donesize, i_totalsize, i_startcopy);
		}
	}

	if (flagappend)
		if (flagdebug)
		{
			myprintf("\n");
			myprintf("01569: Scrittitotali %s\n",migliaia(scrittitotali));
		}
	if (!flagnoeta)
	{
		if ((sorgente_dimensione>LARGEFILE) && (larghezzaconsole>0))
			myprintf("\r                                                            \r");
		myavanzamento(o_donesize,i_totalsize,i_startcopy);
	}

	g_robocopy_fread+=mtime()-s8;

	int64_t s9=mtime();
	fclose(inFile);
	fclose(outFile);
	g_robocopy_fclose+=mtime()-s9;

/// note: this is a "touch" for the attr
	int64_t s10=mtime();
	close(i_outfilename.c_str(),sorgente_data,sorgente_attr);
	///touch(i_outfilename.c_str(),sorgente_data,sorgente_attr);

	g_robocopy_touch+=mtime()-s10;

	o_donecount++;
	if (scrittitotali!=dascrivere)
	{
		myprintf("\n");
		myprintf("01570: HOUSTON something seems wrong: expected %s, done %s\n",migliaia(dascrivere),migliaia2(scrittitotali));
		myprintf("01571: Corrupted source files? Lost connection? Cannot access? Media full?\n");
		return "35109: COPY CORRUPTED";
	}
	return "OK";
}
int pos(const std::string &i_stringa,const std::string& i_cerca)
{
    return (i_stringa.find(i_cerca));
}
#ifdef ZPAQFULL ///NOSFTPSTART
string Jidac::zfs_get_snaplist(string i_header,const string i_footer,vector<string>& o_array_primachiocciola,vector<string>& o_array_dopochiocciola,vector<string>& o_array_size)
{
	string filebatch="/tmp/exec_zfs.sh";
	filebatch=nomefileseesistegia(filebatch);
	if (flagdebug)
		myprintf("01572: script EXECUTING %s\n",filebatch.c_str());
	FILE* batch=fopen(filebatch.c_str(), "wb");
	if (batch==NULL)
	{
		myprintf("01573: cannot write on filebatch %s\n",filebatch.c_str());
		exit(0);
	}
	fprintf(batch,"zfs list -t snapshot\n");
	fclose(batch);
	if (chmod(filebatch.c_str(),0700)!=0)
		return "30515: error on chmod";
	string snapshotlist=exec(filebatch.c_str());
	if (snapshotlist=="")
		return "30490: snapshot list empty";
	string temp;
	int 			posizioneused	=-1;
	unsigned int 	i				=0;
	while (i<snapshotlist.length())
	{
		if (snapshotlist[i]!=10)
			temp+=snapshotlist[i];
		else
		{
			unsigned int j=0;
			while ((j<temp.size()) && (temp[j]!=' '))
				j++;
			while ((j<temp.size()) && (temp[j]==' '))
				j++;
			string usedsize="";
			while ((j<temp.size()) && (temp[j]!=' '))
            {
				usedsize+=temp[j];
                j++;
			}
						
			if (pos(temp,"NAME")==0)
				posizioneused=pos(temp,"USED");
			if (stristr(temp.c_str(),i_header.c_str()))
			{
				if (posizioneused>=0)
				{
					temp=temp.substr(0,posizioneused);
					int posizionechiocciola=pos(temp,"@");
					if (posizionechiocciola>0)
					{
						string primachiocciola=temp.substr(0,posizionechiocciola);
						string nomesnap=temp.substr(posizionechiocciola+1,temp.length());
						string trimmato="";
						for (unsigned int j=0;j<nomesnap.length();j++)
							if (nomesnap[j]!=' ')
								trimmato+=nomesnap[j];
							else
								break;
						nomesnap=trimmato;
						int posizionefooter=pos(nomesnap,i_footer);
						if ((i_footer=="") || (posizionefooter>=0))
						{
							nomesnap=mytrim2(nomesnap);
							o_array_dopochiocciola.push_back(nomesnap);
							primachiocciola=mytrim2(primachiocciola);
							o_array_primachiocciola.push_back(primachiocciola);
							o_array_size.push_back(usedsize);
							
						}
					}
				}
			}
			temp="";
		}
		i++;
	}
	delete_file(filebatch.c_str());
	return snapshotlist;
}

int Jidac::zfsenumerate(const string& i_command)
{

	string 	header		=files[0];//"tank/d@2021";
	string 	footer		="";
	///string	exepath		=zpaqfranzexename;
	if (files.size()>1)
		footer=files[1];
	if (header=="*")
		header="";
	if (footer=="*")
		footer="";
	vector<string> array_primachiocciola;
	vector<string> array_dopochiocciola;
	vector<string> array_size;
	string risul=zfs_get_snaplist(header,footer,array_primachiocciola,array_dopochiocciola,array_size);
	if (flagdebug3)
		myprintf("01574: %s\n",risul.c_str());
	vector<string> thefile;
//		this is a double check that the rebuilded snapshot name does really exists in the
//		original file. Split one lines at time
	explode(risul,'\n',thefile);

	if (flagdebug3)
		for (unsigned int i=0;i<thefile.size();i++)
			myprintf("01575: LINE   %08d |%s|\n",(int)i,thefile[i].c_str());
	if (array_primachiocciola.size()==0)
	{
		myprintf("01576: nothing to do. Do you use the doublequote?\n");
		return 1;
	}

	FILE* scripthandle=0;
	string	myoutput=g_script;
	if (myoutput!="")
	{
		myprintf("01577: Writing on script <<%s>>\n",myoutput.c_str());
		scripthandle=fopen(myoutput.c_str(),"wb");
		if (scripthandle==NULL)
		{
			myprintf("01578! ERROR OPENING SCRIPT FILE %s\n",myoutput.c_str());
			return 2;
		}
	}

	vector<string> 	snapshot_folder;
	vector<int64_t>	snapshot_date;
	vector<string>  snapshot_to;
	for (unsigned int i=0;i<array_primachiocciola.size();i++)
	{
		string prima_chiocciola	=array_primachiocciola	[i];
		string dopo_chiocciola	=array_dopochiocciola	[i];
		string tutto=prima_chiocciola+"@"+dopo_chiocciola;
		string doublecheck=tutto+" "; // please note the space
		bool flagtrovato=false;
		for (unsigned int j=0;j<thefile.size();j++)
			if (pos(thefile[j],doublecheck)>=0)
			{
				flagtrovato=true;
				break;
			}
		if (flagtrovato)
		{
			string theoutput=i_command+tutto;

			if (command=='H') ///zfssize
				myprintf("%10s - %s\n",array_size[i].c_str(),theoutput.c_str());
			else
				myprintf("%s\n",theoutput.c_str());
			if (scripthandle!=0)
				fprintf(scripthandle,"%s\n",theoutput.c_str());
		}
		else
		{
			myprintf("01579! guru evaluating <<%s>>\n",doublecheck.c_str());
			fclose(scripthandle);
			return 2;
		}
	}
	if (scripthandle!=0)
	{
		fclose(scripthandle);
#ifdef unix
// ok we want the +x
		chmod(myoutput.c_str(),0700);
#endif // corresponds to #ifdef (#ifdef unix)
	}
	return 0;
}



int Jidac::zfssize()
{
	if ((files.size()!=1) && (files.size()!=2))
	{
		myprintf("01580: zfssize needs 1 or 2 parameter(s)\n\n");
		myprintf("01581: *** DO NOT FORGET THE DOUBLEQUOTE ***\n\n");
		help_zfssize(true,true);
		return 1;
	}
	return zfsenumerate("");
}

int Jidac::zfspurge()
{
	if ((files.size()!=1) && (files.size()!=2))
	{
		myprintf("01582: zfspurge needs 1 or 2 parameter(s)\n\n");
		myprintf("01583: *** DO NOT FORGET THE DOUBLEQUOTE ***\n\n");
		help_zfspurge(true,true);
		return 1;
	}
	return zfsenumerate("zfs destroy ");
}
int Jidac::zfslist()
{
	if ((files.size()!=1) && (files.size()!=2))
	{
		myprintf("01584: zfslist needs 1 or 2 parameter(s)\n\n");
		myprintf("01585: *** DO NOT FORGET THE DOUBLEQUOTE ***\n\n");
		help_zfslist(true,true);
		return 1;
	}
	return zfsenumerate("");
}

int64_t getdatefromsnapshot(string i_snaptoget)
{
	if (i_snaptoget=="")
		return -1;

	string getcreationdate	="zfs get -p creation "+i_snaptoget;
	string creationresult	=x_one(getcreationdate,"Getting creation "+i_snaptoget+" ...");

	if (creationresult=="")
	{
		myprintf("01586: Guru, cannot open snapshot %s\n",i_snaptoget.c_str());
		seppuku();
		return 2;
	}
	int poscreation=pos(creationresult," creation ");
	if (poscreation<=0)
	{
		myprintf("01587! Guru, poscreation strange %d\n",poscreation);
		seppuku();
		return 2;
	}
	unsigned int i=poscreation+11; // strlen(" creation  ")
	string dategetted="";
	while (i<creationresult.size())
	{
		if (isdigit(creationresult[i]))
			dategetted+=creationresult[i];
		else
			break;
		i++;
	}
	if (flagdebug3)
		myprintf("01588: |%s|\n",dategetted.c_str());

	int64_t unixdate=myatoll(dategetted.c_str());
	if (flagdebug)
		myprintf("01589: Unixxxx %s\n",migliaia(unixdate));
	return decimal_time(unixdate);
}
int Jidac::zfsadd()
{
	if ((files.size()!=1) && (files.size()!=2) && (files.size()!=3))
	{
		myprintf("01590: For zfsadd you need 1, 2 or 3 parameters\n\n");
		myprintf("01591: *** DO NOT FORGET THE DOUBLEQUOTE ***\n\n");
		help_zfsadd(true,true);
		return 1;
	}

	string 	header		=files[0];//"tank/d@2021";
	string 	footer		="";
	string	exepath		=zpaqfranzexename;
	string  zpaqfile	=""; ///zfsadd
	string 	onlysubdir	=""; ///zfsadd
	if (files.size()>1)
		footer=files[1];
	if (header=="*")
		header="";
	if (footer=="*")
		footer="";
	vector<string> array_primachiocciola;
	vector<string> array_dopochiocciola;
	vector<string> array_size;
	string risul=zfs_get_snaplist(header,footer,array_primachiocciola,array_dopochiocciola,array_size);
	if (flagdebug3)
		myprintf("01592: %s\n",risul.c_str());

	vector<string> thefile;
	explode(risul,'\n',thefile);
	if (array_primachiocciola.size()==0)
	{
		myprintf("01593: nothing to do. Do you use the doublequote?\n");
		return 1;
	}

	FILE* scripthandle=0;
	string	myoutput=g_script;
	if (myoutput!="")
	{
		myprintf("01594: Writing on script <<%s>>\n",myoutput.c_str());
		scripthandle=fopen(myoutput.c_str(),"wb");
		if (scripthandle==NULL)
		{
			myprintf("01595! ERROR OPENING SCRIPT FILE %s\n",myoutput.c_str());
			return 2;
		}
	}
	if (flagdebug3)
		for (unsigned int i=0;i<files.size();i++)
			myprintf("01596: Files  %d %s\n",(int)i,files[i].c_str());
	zpaqfile	=archive; ///files[2];//"/temporaneo/kongo7.zpaq";


	if (files.size()==3)
	{
		onlysubdir=files[2];
		if (flagdebug3)
			myprintf("01597: onlysubdir [1] %s\n",onlysubdir.c_str());
		if (onlysubdir[0]=='/')
			onlysubdir.erase(0,1);
		if (flagdebug3)
			myprintf("01598: onlysubdir [2] %s\n",onlysubdir.c_str());
		if (onlysubdir!="")
			if (!isdirectory(onlysubdir))
				onlysubdir+="/";
		if (flagdebug3)
			myprintf("01599: onlysubdir [3] %s\n",onlysubdir.c_str());
	}

	if (flagverbose)
	{
		myprintf("01600: Files siz: %d\n",files.size());
		myprintf("01601: Exepath  : %s\n",exepath.c_str());
		myprintf("01602: Zpaqfile : %s\n",zpaqfile.c_str());
		myprintf("01603: Header   : %s\n",header.c_str());
		myprintf("01604: Footer   : %s\n",footer.c_str());
		if (onlysubdir!="")
			myprintf("01605: Subdir   : %s\n",onlysubdir.c_str());
		if (myoutput!="")
			myprintf("01606: Output on: %s\n",myoutput.c_str());
	}
	vector<string> 	snapshot_folder;
	vector<int64_t>	snapshot_date;
	vector<string>  snapshot_to;
	for (unsigned int i=0;i<array_primachiocciola.size();i++)
	{
		string prima_chiocciola	=array_primachiocciola	[i];
		string dopo_chiocciola	=array_dopochiocciola	[i];
		string tutto=prima_chiocciola+"@"+dopo_chiocciola;
		string doublecheck=tutto+" "; // please note the space
		bool flagtrovato=false;
		for (unsigned int j=0;j<thefile.size();j++)
			if (pos(thefile[j],doublecheck)>=0)
			{
				flagtrovato=true;
				break;
			}
		if (flagtrovato)
		{
			if (prima_chiocciola[0]!='/')
				prima_chiocciola="/"+prima_chiocciola;
			string percorso		=prima_chiocciola+"/.zfs/snapshot/"+dopo_chiocciola+"/";
			string timestamp	=dopo_chiocciola;
			myreplace(timestamp,footer,"");
			int64_t testdate=-1; //=encodestringdate(timestamp,true);
			if (testdate==-1)
			{
			///	myprintf("01607: timestamp is strange %s\n",timestamp.c_str());
				testdate=getdatefromsnapshot(tutto);
				if (testdate!=-1)
					if (flagverbose)
						myprintf("01608: Snapshot creation date %s\n",dateToString(false,testdate).c_str());
			}

			if (testdate==-1)
			{
				myprintf("01609! testdate == -1 ! \n");
				fclose(scripthandle);
				return 2;
			}
			else
			{
				timestamp=dateToString(false,testdate);
				myreplaceall(timestamp," ","_");
				snapshot_date		.push_back(testdate);
				snapshot_folder		.push_back(percorso+onlysubdir);
				snapshot_to			.push_back(prima_chiocciola+"/"+onlysubdir);
			}
			tutto=exepath+" a "+zpaqfile+" "+percorso+onlysubdir+" -to "+prima_chiocciola+"/"+onlysubdir+" -timestamp "+timestamp;
			if (scripthandle!=0)
				fprintf(scripthandle,"%s\n",tutto.c_str());
		}
		else
		{
			myprintf("01610! guru evaluating <<%s>>\n",doublecheck.c_str());
			fclose(scripthandle);
			return 2;
		}
	}

	if (scripthandle!=0)
	{
		fclose(scripthandle);
#ifdef unix
// ok we want the +x
		chmod(myoutput.c_str(),0700);
#endif // corresponds to #ifdef (#ifdef unix)
	}
	if (flagforce) /// -force, to be checked
		if (snapshot_date.size()>0)
		{
			bool allok=true;
			for (unsigned int i=0;i<snapshot_date.size();i++)
			{
				printbar('-');
				myprintf("01611: Freezing %s of %s snapshots\n",migliaia(i+1),migliaia2(snapshot_date.size()));
				myprintf("01612: Folder %s\n",snapshot_folder[i].c_str());
				myprintf("01613: To     %s\n",snapshot_to[i].c_str());

				jidacreset();
				tofiles	.clear();
				files	.clear();
				files.push_back(snapshot_folder[i]);
				date=snapshot_date[i];
				tofiles.push_back(snapshot_to[i]);
				command='a'; /// hidden parameter in read_archive with reflex on issel
				if (add()!=0)
					allok=false;
			}
			if (!allok)
				return 2;
		}
	myprintf("01614: zfsadd done (use -verbose if you like)\n");
	return 0;
}
#endif ///NOSFTPEND
/// find and delete 0-length dirs
/// in a slow (but hopefully) safe way
/// to be merged with Jidac::removeemptydirs(string i_folder,bool i_kill)
int Jidac::zero()
{
	myprintf("01615: *** Delete empty folders (zero length) *** ");
	if (!flagforcezfs)
		myprintf(" * ignoring .zfs and :$DATA ");
	myprintf("\n");
	if (files.size()==0)
	{
		myprintf("01616: no folder selected\n");
		return 1;
	}
	flagverbose=true;
	int risultato=0;
	for (unsigned i=0; i<files.size(); ++i)
		risultato+=removeemptydirs(files[i],flagkill);
	return risultato;
}

/// robocopy /mir a master folder to one or more
int Jidac::robocopy()
{
	int risultato=0;
	myprintf("01617: *** ROBOCOPY MODE *** ");
#ifdef _WIN32
	if (flagappend && flagbig)
	{
		myprintf("01618: On Windows you cannot run -append -big, removing -big\n");
		myprintf("01619: (-big is a specific switch for... big files)\n");
		flagbig=false;
	}
#endif // corresponds to #ifdef (#ifdef _WIN32)
	if (!flagkill)
		myprintf("01620: *** -kill missing: dry run *** ");
	if (!flagforcezfs)
		myprintf("01621: *** ignoring .zfs and :$DATA ***");
	myprintf("\n");
	if (files.size()<2)
	{
		myprintf("01622: at least two folders needed (instead of %d)\n",files.size());
		for (unsigned int i=0;i<files.size();i++)
			myprintf("01623: %08d %s\n",(int)i,files[i].c_str());
		return 1;
	}
	if (!direxists(files[0]))
	{
		myprintf("01624: Master dir does not exists <<%s>>\n",files[0].c_str());
		return 1;
	}
	/// slow, but the cardinality is so small
	vector<string> checkdupe;
	for (unsigned int i=0;i<files.size();i++)
	{
		if (!isdirectory(files[i]))
			files[i]=files[i]+'/';
		string	outputfolder=files[i];
#ifdef _WIN32
	outputfolder=stringtolower(outputfolder);
#endif // corresponds to #ifdef (#ifdef _WIN32)
		checkdupe.push_back(outputfolder);
	}
	if (flagdebug3)
	{
		myprintf("01625: Size checkdup %s\n",migliaia(checkdupe.size()));
		for (unsigned int i=0;i<files.size();i++)
			myprintf("01626: %03d files[i] %s  checkdupe [i] |%s|\n",(int)i,files[i].c_str(),checkdupe[i].c_str());
	}
	for (unsigned int i=1;i<files.size();i++)
		if (checkdupe[0]==checkdupe[i])
		{
			myprintf("01627: a slave dir is == to the master, quit\n");
			return 1;
		}
#ifdef _WIN32
	if (flaglongpath)
		for (unsigned int i=0;i<files.size();i++)
			files[i]=makelongpath(files[i]);
	if (flagdebug3)
		for (unsigned int i=0;i<files.size();i++)
			myprintf("01628: after %03d files[i] %s\n",(int)i,files[i].c_str());
#endif // corresponds to #ifdef (#ifdef _WIN32)
	int64_t s13=mtime();
	g_testifselected=true;
	franzparallelscandir(false,true,true);
	g_testifselected=false;
	int64_t timescandir=mtime()-s13;
///27437: space needed
	if (!flagspace)
		if (files_size[0]>0)
		{
			bool	spazioinsufficiente=false;
			for (unsigned int i=1;i<files.size();i++)
			{
				int64_t spaziolibero=getfreespace(files[i]);
				if (spaziolibero>=0)
				{
					if (files_size[0]>spaziolibero)
					{
						myprintf("01629: space needed %s but only %s reported free on <<%s>>\n",tohuman(files_size[0]),tohuman2(spaziolibero),files[i].c_str());
						spazioinsufficiente=true;
					}
				}
			}
			if (spazioinsufficiente)
			{
				myprintf("01630: exit, not enough space/destination does not exists; use -space if you want\n");
				return 1;
			}
		}

	int64_t 	startscan=mtime();
	uint64_t 	strangethings;
	myprintf("\n");
	myprintf("01631: Master  %s (%s files %s) <<%s>>\n",migliaia(files_size[0]),tohuman(files_size[0]),migliaia2(files_count[0]),files[0].c_str());
	printbar('-');
	int64_t total_size				=files_size[0];
	int64_t total_count				=files_count[0];
	int64_t done_size				=0;
	int64_t done_count				=0;
	int64_t written_size			=0;
	int robocopied					=0;
	uint64_t robocopiedsize			=0;
	int robodeleted					=0;
	uint64_t robodeletedsize		=0;
	int roboequal					=0;
	uint64_t roboequalsize			=0;
	int64_t timecopy				=0;
	int64_t timedelete				=0;
	int xlscopied					=0;
	uint64_t xlscopiedsize			=0;

	g_robocopy_check_sorgente		=0;
	g_robocopy_check_destinazione	=0;
	g_robocopy_makepath				=0;
	g_robocopy_makepath2			=0;
	g_robocopy_isequal				=0;
	g_robocopy_close				=0;
	g_robocopy_close2				=0;
	g_robocopy_touch				=0;
	g_robocopy_delete				=0;
	g_robocopy_readopen				=0;
	g_robocopy_openoutfile			=0;
	g_robocopy_fclose				=0;
	g_robocopy_fread				=0;
	g_robocopy_fwrite				=0;

	int64_t	timegetfolderinfo		=0;
	int64_t	timegetfolderinfo2		=0;
	int64_t	timesetfolderinfo		=0;

	int64_t timelocalexists			=0;
	int64_t timelocalexists2		=0;
	int64_t timelocalmakepath		=0;

/*
	if (g_ioBUFSIZE==4096)
		g_ioBUFSIZE=1048576;
*/
	unsigned char *buf=(unsigned char*)franz_malloc(g_ioBUFSIZE);
	///g_allocatedram+=g_ioBUFSIZE;
	if (buf==NULL)
	{
		myprintf("01632! GURU allocating io buf of size %s\n",g_ioBUFSIZE);
		seppuku();
		return 2;
	}


	if (g_sftp_bandwidth>0)
	{
		color_yellow();
		myprintf("63833: Due to -bandwidth the target speed will be %s\n",tohuman(g_sftp_bandwidth));
		color_restore();
	}
		
///	we start by 1 (the first slave); 0 is the master
	for (unsigned i=1; i<files.size(); ++i)
	{
		strangethings=0;
		if (flagkill)
		{
			int64_t s14=mtime();
			bool exists1=exists(files[i]);
			timelocalexists+=mtime()-s14;

			if (!exists1)
			{
				int64_t s15=mtime();
				makepath(files[i]);
				timelocalmakepath+=mtime()-s15;
			}
		}
		int64_t s16=mtime();
		bool exists2=exists(files[i]);
		timelocalexists2+=mtime()-s16;

		if (!exists2)
		{
			if (!flagkill)
			{
				myprintf("01633: Dir %d (slavez) DOES NOT EXISTS %s\n",(int)i,files[i].c_str());
				risultato=1;
			}
		}
		else
		{
		///	first stage: delete everything in slave-i that is NOT i master-0
			int64_t startdelete=mtime();
			for (DTMap::iterator p=files_edt[i].begin(); p!=files_edt[i].end(); ++p)
			{
				string filenamei=p->first;
				string filename0=filenamei;
				myreplace(filename0,files[i],files[0]);
				DTMap::iterator cerca=files_edt[0].find(filename0);
				if  (cerca==files_edt[0].end())
				{
					if (flagdebug2)
						myprintf("01634: Delete %s\n",p->first.c_str());
					if (!flagkill)
					{
							//fake: dry run
						robodeleted++;
						robodeletedsize+=p->second.size;
					}
					else
					{
						string temp=p->first;
					///	myprintf("01635: AAAAAAAAAAAAAAAAAAAAA %s\n",temp.c_str());
						bool riuscito=true;
						if (isdirectory(temp))
						{
							stermina(temp); // risky!!
							riuscito=delete_dir(temp.c_str())==0;
						}
						else
						{
						/// delete without mercy!
							/*riuscito*/delete_file(temp.c_str());
						}
						if (!riuscito)
							myprintf("01636: ERROR DELETING  <%s>\n",p->first.c_str());
						else
						{
							robodeleted++;
							robodeletedsize+=p->second.size;
						}
					}
				}
				if (menoenne>0)
					if (strangethings>menoenne)
					{
						myprintf("01637: **** TOO MANY STRANGE THINGS (-n %d)  %s\n",menoenne,migliaia(strangethings));
						break;
					}
			}
			/// OK now do the copy from master-0 to slave-i
			timedelete=mtime()-startdelete;
			int64_t globalstartcopy=mtime();

			for (DTMap::iterator p=files_edt[0].begin(); p!=files_edt[0].end(); ++p)
			{
				string filename0=p->first;
				string filenamei=filename0;
				myreplace(filenamei,files[0],files[i]);
				DTMap::iterator cerca=files_edt[i].find(filenamei);
				int64_t dest_size=-1;
				int64_t dest_date=-1;
				int64_t dest_attr=-1;
				if  (cerca==files_edt[i].end())
				{
					/// the file does not exists, maintain default -1 (=>secure_copy_file do yourself)
					///myprintf("01638: NON ! %s\n",filenamei.c_str());
				}
				else
				{
				/// the destination exists, get data from the scanned-data
					dest_size=cerca->second.size;
					dest_date=cerca->second.date;
					dest_attr=cerca->second.attr;
				}
					int64_t startcopy=mtime();
					string copyfileresult="OK";
					if (flagkill)
						copyfileresult=secure_copy_file(
					filename0,filenamei,globalstartcopy,total_size*(files.size()-1),total_count*(files.size()-1),written_size,done_size,done_count,
					p->second.size,
					p->second.date,
					p->second.attr,
					dest_size,
					dest_date,
					dest_attr,
					buf,
					g_ioBUFSIZE);
					/// the return code can be OK (file copied) or = (file not copied because it is ==)
					if ((copyfileresult!="OK") && (copyfileresult!="="))
					{
						myprintf("01639: error robocoping data  <%s> to %s\n",copyfileresult.c_str(),filenamei.c_str());
						risultato=2;
					}
					else
					{
						if (!isdirectory(filename0))
						{
							if (copyfileresult=="OK")
							{
								robocopiedsize+=p->second.size;
								robocopied++;
								if (!flagdonotforcexls)
									if (isxls(filename0))
									{
										xlscopiedsize+=p->second.size;
										xlscopied++;
									}
								timecopy+=mtime()-startcopy;
							}
							else
							{
								roboequalsize+=p->second.size;
								roboequal++;
							}
						}
					}
				if (menoenne>0)
					if (strangethings>menoenne)
					{
						myprintf("01640: **** TOO MANY STRANGE THINGS (-n %d)  %s\n",menoenne,migliaia(strangethings));
						break;
					}
			}
		}
	}

	
	franz_free(buf);
	buf=0;
	
	timecopy++; //avoid some div by zero
	timedelete++;
	myprintf("\n");


	///	folders' touch

	int	foldertoucherror=0;
	int	foldertouched	=0;
	int	folderworked	=0;
	if (flagkill)
	{
		int quantifolder=0;
		for (DTMap::iterator a=files_edt[0].begin(); a!=files_edt[0].end(); ++a)
			if (isdirectory(a->first.c_str()))
				quantifolder++;
		int64_t starttouch	=mtime();
		int64_t	ultimotempo	=0;

		for (DTMap::iterator a=files_edt[0].begin(); a!=files_edt[0].end(); ++a)
		{
			string masterfolder=a->first;
			if (isdirectory(masterfolder))
			{
				folderworked++;
				int secondi=(mtime()-starttouch)/1000;
				if (secondi!=ultimotempo)
				{
					ultimotempo=secondi;
					if (!flagnoeta)
					{
						myprintf("01641: Touching  %12s / %s @ %8s touch/s\r",migliaia(folderworked),migliaia2(quantifolder),migliaia3(folderworked/(secondi+1)));
						fflush(stdout);
					}
				}

				int64_t folder_creationdate	=0;
				int64_t	folder_attribute	=0;

				int64_t s20=mtime();
				bool gettedinfo=getdirinfo(masterfolder,folder_creationdate,folder_attribute);
				timegetfolderinfo+=mtime()-s20;

				if (!gettedinfo)
				{
					myprintf("01642: Cannot getdirinfo on %Z\n",masterfolder.c_str());
					foldertoucherror++;
					continue;
				}

				if (flagdebug2)
				{
					string	creation_date =dateToString(flagutc,folder_creationdate);
					myprintf("01643: MASTER Creation date %s for %s\n",creation_date.c_str(),masterfolder.c_str());
				}

				for (unsigned i=1; i<files.size(); ++i)
				{
					string slavefolder=masterfolder;
					if (!myreplace(slavefolder,files[0],files[i]))
					{
						myprintf("01644: Cannot get slavefolder %d %s to %s\n",(int)i,files[0].c_str(),files[i].c_str());
						foldertoucherror++;
					}
					else
					{
						if (flagdebug2)
							myprintf("01645: SLAVE FOLDER %03d %s\n",(int)i,slavefolder.c_str());
						if (!direxists(slavefolder))
						{
							myprintf("01646: Salve folder does not exists %d %s to %s\n",(int)i,files[0].c_str(),files[i].c_str());
							foldertoucherror++;
						}
						else
						{
							int64_t slave_folder_creationdate	=0;
							int64_t	slave_folder_attribute		=0;
							bool flagtocca=true;
							if (flagpakka)
							{
								int64_t s22			=mtime();
								bool gettedslave	=getdirinfo(slavefolder,slave_folder_creationdate,slave_folder_attribute);
								timegetfolderinfo2	+=mtime()-s22;
								if (gettedslave)
									if (folder_attribute==slave_folder_attribute)
										if (myabs(slave_folder_creationdate,folder_creationdate)<=2)
											flagtocca=false;
							}

							bool touched=true;
							if (flagtocca)
							{
								int64_t s21=mtime();
								touched=close(slavefolder.c_str(),folder_creationdate,folder_attribute);
								timesetfolderinfo+=mtime()-s21;
							}

							if (touched)
							{
								if (flagdebug2)
									myprintf("01647: Touch OK on slave %d %s\n",(int)i,slavefolder.c_str());
								if (flagtocca)
									foldertouched++;
							}
							else
							{
								myprintf("01648: Touch KAPUTT on slave %d %s\n",(int)i,slavefolder.c_str());
								foldertoucherror++;
							}
						}
					}
				}
			}
		}
		if (!flagnoeta)
			myprintf("\n");
	}
	if (!flagkill)
		myprintf("01649: FAKE: dry run!\n");
	if (roboequal>0)
		myprintf("01650: =   %12s %20s B\n",migliaia(roboequal),migliaia2(roboequalsize));
	if (robocopied>0)
		myprintf("01651: +   %12s %20s B in %9.2fs %15s/s\n",migliaia(robocopied),migliaia2(robocopiedsize),(timecopy/1000.0),migliaia3((int64_t)(robocopiedsize/(timecopy/1000.0))));
	if (xlscopied>0)
		myprintf("01652: xls %12s %20s B\n",migliaia(xlscopied),migliaia2(xlscopiedsize));
	if (robodeleted)
		myprintf("01653: -   %12s %20s B in %9.2fs %15s/s\n",migliaia(robodeleted),migliaia2(robodeletedsize),(timedelete/1000.0),migliaia3((int64_t)(robodeletedsize/(timedelete/1000.0))));
	double tempo=(mtime()-startscan)+1;
	tempo/=1000.0;

	myprintf("\n");
	myprintf("01654: Robocopy time  %9.2f  - Slaves getinfo %9.2f s\n",tempo,g_robocopy_check_destinazione/1000.0);

	myprintf("01655: Written bytes %s (%s) @ %s B/s\n",migliaia(written_size),tohuman(written_size),migliaia2((int64_t)(written_size/tempo))
	);
	if (foldertoucherror>0)
		myprintf("01656$ WARNING - SOME FOLDER TOUCH ERROR %s\n",migliaia(foldertoucherror));

	if (flagverbose)
	{
		g_robocopy_fread++;
		double realspeed=written_size/(g_robocopy_fread/1000.0);
		printbar('=');
		myprintf("01657: localexists  %10s loc.exist2 %10s loc.make %10s\n",migliaia(timelocalexists),migliaia2(timelocalexists2),migliaia3(timelocalmakepath));
		myprintf("01658: check_source %10s check_dest %10s makepath %10s\n",migliaia(g_robocopy_check_sorgente),migliaia2(g_robocopy_check_destinazione),migliaia3(g_robocopy_makepath));
		myprintf("01659: makepath2    %10s isequal    %10s close    %10s\n",migliaia(g_robocopy_makepath2),migliaia2(g_robocopy_isequal),migliaia3(g_robocopy_close));
		myprintf("01660: close2       %10s touch      %10s delete   %10s\n",migliaia(g_robocopy_close2),migliaia2(g_robocopy_touch),migliaia3(g_robocopy_delete));
		myprintf("01661: readopen     %10s openout    %10s fclose   %10s\n",migliaia2(g_robocopy_readopen),migliaia2(g_robocopy_openoutfile),migliaia3(g_robocopy_fclose));
		myprintf("01662: getfolderinf %10s setfolder  %10s \n",migliaia2(timegetfolderinfo),migliaia2(timesetfolderinfo));
		myprintf("01663: buffersize   %10s scandir    %10s copy     %10s @ %s/s\n",tohuman(g_ioBUFSIZE),migliaia2((int64_t)timescandir),migliaia3(g_robocopy_fread),migliaia4((int64_t)realspeed));
		if (flagpakka)
			myprintf("01664: FOLDER-TOUCH WITH -pakka (check-before-touch)\n");
		else
			myprintf("01665: FOLDER-TOUCH-WITHOUT-MERCY PROFILE (try -pakka to check-before-set)\n");
		myprintf("01666: getfolder    %10s getfolder2 %10s setfold  %10s\n",migliaia(timegetfolderinfo),migliaia2(timegetfolderinfo2),migliaia3(timesetfolderinfo));
		myprintf("01667: touched      %10s totaltouch %10s\n",migliaia4(foldertouched),migliaia5(timegetfolderinfo+timegetfolderinfo2+timesetfolderinfo));
	}
	if (not flagverify)
		return risultato;
	myprintf("01668: *** ROBOCOPY: do a (-verify) ");
	if (!flagforcezfs)
		myprintf(" ignoring .zfs and :$DATA");
	myprintf("\n");
	return dircompare(false,true);
}




/// do a s (get size) or c (compare). The second flag is for output when called by robocopy
int Jidac::dircompare(bool i_flagonlysize,bool i_flagrobocopy)
{
	if (!i_flagonlysize)
		if (files.size()<2)
		{
			myprintf("66395: On dircompare you need at least one master and one slave\n");
			return 1;
		}
	if (!exists(files[0]))
	{
		myprintf("66400: Master dir <<%Z>> does not exists\n",files[0].c_str());
		return 2;
	}
		
	if (i_flagonlysize)
		if (flaghome)
			return homesize();
		
	/// If you specify a checksum, do hard compare
	flagchecksum=ischecksum();
	
	int risultato=0;
	if (i_flagonlysize)
		myprintf("01669: Get directory size ");
	else
	{
		if (!i_flagrobocopy)
			myprintf("01670: Dir compare (%s dirs to be checked) ",migliaia(files.size()));
	}
	if (!flagforcezfs)
		myprintf(" ignoring .zfs and :$DATA\n");
	franzparallelscandir(flagchecksum,true,true);
	printbar('=');
	
	if ((files.size()!=files_size.size()) || (files.size()!=files_count.size()) || (files.size()!=files_time.size()))
	{
		myprintf("66428: GURU, files.size() not good\n");
		seppuku();
	}
	for (unsigned i=0; i<files.size(); ++i)
	{
		int64_t spazio=getfreespace(files[i]);
		if (spazio<0)
			spazio=0;
		myprintf("01671: Free %d %21s (%12s)  <<%s>>\n",(int)i,migliaia(spazio),tohuman(spazio),files[i].c_str());
		if (minsize)
			if (minsize>(uint64_t)spazio)
			{
				color_yellow();
				myprintf("01672: ***************************************\n");
				myprintf("01673: |=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|\n");
				myprintf("01674: WARN: free space < of minsize   %19s  %19s\n",migliaia(spazio),migliaia2(minsize));
				myprintf("01675: |=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|\n");
				myprintf("01676: ***************************************\n");
				color_restore();
			}
	}
	uint64_t total_size	=0;
	int64_t delta_size	=0;
	int64_t delta_files	=0;
	printbar('=');
	for (unsigned int i=0;i<files_size.size();i++)
	{
		if (i==0)
			myprintf("01677: Dir  %d %21s |%12s| |%12s| %9.2f <<%s>>\n",(int)i,migliaia(files_size[i]),"Delta bytes",									 migliaia3(files_count[i]),files_time[i]/1000.0,files[i].c_str());
		else
		{
			myprintf("01678: Dir  %d %21s |%12s| |%12s| %9.2f <<%s>>\n",(int)i,migliaia(files_size[i]),tohuman(myabs(files_size[0],files_size[i])),migliaia3(files_count[i]),files_time[i]/1000.0,files[i].c_str());
			delta_size	+= myabs(files_size[0],files_size[i]);
			delta_files	+= myabs(files_count[0],files_count[i]);
		}
		total_size	+=files_size[i];
	}
	printbar('=');
	myprintf("01679: Total  |%21s| (%s)\n",migliaia(total_size),tohuman(total_size));
	myprintf("01680: Delta  |%21s| %21s|files\n",migliaia(delta_size),migliaia2(delta_files));
/// only a s (size)? Done
	if (i_flagonlysize)
		return 0;

	uint64_t strangethings;
	myprintf("\n");
	myprintf("01681: Dir 0 (master) %s (files %s) <<%s>>\n",migliaia(files_size[0]),migliaia2(files_count[0]),files[0].c_str());
	printbar('-');
	bool flagerror=false;
	/// check from 1 (the first slave)

	// Per ogni slave, prepariamo un set con i suoi file.
	// Man mano che troviamo corrispondenze nel master, li rimuoviamo da questo set.
	// Quelli che rimangono alla fine sono i file in "eccesso".

	for (unsigned i=1; i<files.size(); ++i) 
	{
		strangethings=0;
		if (!exists(files[i]))
		{
			myprintf("[%03d] ERROR DOES NOT EXISTS <<%Z>>\n",i,files[i].c_str());
			flagerror=true;
			risultato=1;
		}
		else
		{
			if ((files_size[i]!=files_size[0]) || (files_count[i]!=files_count[0]))
			{
				myprintf("01682: Dir %d (slave) IS DIFFERENT time %f <<%s>>\n",(int)i,files_time[i]/1000.0,files[i].c_str());
				myprintf("01683: size  %24s (files %s)\n",migliaia(files_size[i]),migliaia2(files_count[i]));
			}

			// Per ogni slave, prepariamo un set con i suoi file.
			// Man mano che troviamo corrispondenze nel master, li rimuoviamo da questo set.
			// Quelli che rimangono alla fine sono i file in "eccesso".
			std::set<string> slave_files_unmatched;
			for (DTMap::iterator it = files_edt[i].begin(); it != files_edt[i].end(); ++it)
				slave_files_unmatched.insert(it->first);
			
			// 1. CICLO PRINCIPALE: Iteriamo sul master UNA SOLA VOLTA
			// In questo ciclo troviamo i file MANCANTI e i file DIFFERENTI
			for (DTMap::iterator p = files_edt[0].begin(); p != files_edt[0].end(); ++p)
			{
				string filename0 = p->first;
				string filenamei = filename0;
				myreplace(filenamei, files[0], files[i]); // Calcola il nome del file atteso nello slave
				
				DTMap::iterator cerca = files_edt[i].find(filenamei);
			
				if (cerca == files_edt[i].end())
				{
					// File trovato nel master ma NON nello slave -> MANCANTE
					myprintf("01684: missing (not in %d) %Z\n", i, filename0.c_str());
					flagerror = true;
					strangethings++;
				}
				else
				{
					// File trovato in entrambi, ora confrontiamo dimensione e checksum.
					// E lo rimuoviamo dal set dei file "non giustificati".
					slave_files_unmatched.erase(filenamei);
			
					if (p->second.size != cerca->second.size)
					{
						myprintf("01688: diff size  %18s (0) %18s (%d) %s\n", migliaia(p->second.size), migliaia2(cerca->second.size), i, filename0.c_str());
						flagerror = true;
						strangethings++;
					}
					else if (flagchecksum)
					{
						if (p->second.hexhash != cerca->second.hexhash)
						{
							myprintf("%s different %s (0) vs %s (%d) %Z\n", g_thechosenhash_str.c_str(), p->second.hexhash.c_str(), cerca->second.hexhash.c_str(), i, filename0.c_str());
							flagerror = true;
							strangethings++;
						}
					}
				}
			
				// Uscita anticipata se ci sono troppi errori
				if (menoenne > 0 && strangethings > menoenne)
				{
					myprintf("01689: **** TOO MANY STRANGE THINGS (-n %d)  %s\n", menoenne, migliaia(strangethings));
					break;
				}
			}
			
			// 2. CONTROLLO FINALE: Iteriamo sui file rimasti nel set.
			// Questi sono i file in ECCESSO (presenti nello slave ma non nel master).
			if (!(menoenne > 0 && strangethings > menoenne)) // Controlla di non essere già uscito per troppi errori
			{
				for (std::set<string>::iterator it = slave_files_unmatched.begin(); it != slave_files_unmatched.end(); ++it)
				{
					string filenamei = *it;
					string filename0 = filenamei;
					myreplace(filename0, files[i], files[0]); // Ricalcola il nome che avrebbe nel master
			
					myprintf("01686: excess  (not in 0) %Z\n", filename0.c_str());
					flagerror = true;
					strangethings++;
			
					if (menoenne > 0 && strangethings > menoenne)
					{
						myprintf("01687: **** TOO MANY STRANGE THINGS (-n %d)  %s\n", menoenne, migliaia(strangethings));
						break;
					}
				}
			}
		
			if (!flagerror)
				if ((files_size[i] == files_size[0]) && (files_count[i] == files_count[0]))
					myprintf("[%03d] == <<%Z>>\n",i,files[i].c_str());

			printbar('-');
		}
	}


	if (!flagerror)
	{
		if (flagchecksum)
		{
			color_green();
			myprintf("01690: NO diff FOR SURE in slave dirs (checksum check %s)\n",g_thechosenhash_str.c_str());
		}
		else
		{
			color_cyan();
			myprintf("01691: NO diff in slave dirs (fast check, only size)\n");
		}
	}
	else
	{
		color_yellow();
		myprintf("01692: DIFFERENT SLAVE DIRS!!\n");
		risultato=2;
	}
	color_restore();

	return risultato;
}












/// scans one or more directories, with one or more threads
/// return total time
int64_t Jidac::franzparallelscandir(bool i_flaghash,bool i_recursive,bool i_forcedir)
{
	files_edt	.clear();
	files_size	.clear();
	files_count	.clear();
	files_time	.clear();
	g_arraybytescanned.clear();
	g_arrayfilescanned.clear();
	if (files.size()==0)
	{
		if (flagdebug)
			myprintf("01693: files.size zero\n");
		return 0;
	}
	if (i_forcedir)
		for (unsigned i=0; i<files.size(); ++i)
			if (!isdirectory(files[i]))
				files[i]+='/';
	int64_t startscan=mtime();
	g_bytescanned			=0;
	g_worked				=0;
	if (flagssd)	// OK let's make different threads
	{
		vector<tparametri> 	vettoreparametri;
		vector<DTMap>		vettoreDT;
		tparametri 	myblock;
		DTMap		mydtmap;
		for (unsigned int i=0;i<files.size();i++)
		{
			vettoreDT.push_back(mydtmap);
			myblock.tnumber=i;
			myblock.directorytobescanned=files[i];
			myblock.recursive=i_recursive;
			myblock.theDT=vettoreDT[i];
			myblock.flagcalchash=i_flaghash;//flagverify;
			myblock.timestart=mtime();
			myblock.timeend=myblock.timestart;
			vettoreparametri.push_back(myblock);
		}
		int rc;
///		pthread_t* threads = new pthread_t[files.size()];
		
		std::vector<pthread_t> threads(files.size(), 0);  // Initialize all to 0

		g_allocatedram+=sizeof(pthread_t)*files.size();
		pthread_attr_t attr;
		void *status;
		// ini and set thread joinable
		pthread_attr_init(&attr);
		pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_JOINABLE);
		myprintf("01694: Creating %s scan threads\n",migliaia(files.size()));
		if (!flagsilent)
			if (!flagnoeta)
				if (!flagnoconsole)
		{
			setupConsole();
			printf("\033[?25l");
			fflush(stdout);
			restoreConsole();
		}
		if (!flagnoeta)
			for(unsigned int i = 0; i < files.size(); i++ )
			{
				print_datetime();
				myprintf("01695: Scan dir |%08d| <<%s>>\n",(int)i,files[i].c_str());
			}
		for(unsigned int i = 0; i < files.size(); i++ )
		{
			g_arraybytescanned.push_back(0);
			g_arrayfilescanned.push_back(0);
			rc = pthread_create(&threads[i], &attr, scansiona, (void*)&vettoreparametri[i]);
			if (rc)
			{
				myprintf("01696: Error creating thread\n");
				exit(-1);
			}
		}
		myprintf("\n");
		// free attribute and wait for the other threads
		pthread_attr_destroy(&attr);

		for(unsigned int i = 0; i < files.size(); i++)
		{
			// Check that the thread is valid before joining
			if (threads[i] != 0)  // 0 indica thread non inizializzato
			{
				rc = pthread_join(threads[i], &status);
				if (rc)
				{
					myprintf("61734! Unable to join thread %d\n", i);
					exit(-1);
				}
				// myprintf("01697: Thread completed %d status %d\n", (int)i, status);
			}
			else
			{
				myprintf("61738! Warning: Thread %d was not properly initialized\n", i);
			}
		}

		if (!flagsilent)
			if (!flagnoeta)
				if (!flagnoconsole)
		{
			setupConsole();
			printf("\033[%dB",(int)g_arraybytescanned.size());
			printf("\033[?25h");
			fflush(stdout);
			restoreConsole();
		}
		myprintf("\n");
		myprintf("01698: Parallel scan ended in %f s\n",(mtime()-startscan)/1000.0);
		for (unsigned i=0; i<files.size(); ++i)
		{
			uint64_t sizeofdir=0;
			uint64_t dircount=0;
			for (DTMap::iterator p=vettoreparametri[i].theDT.begin(); p!=vettoreparametri[i].theDT.end(); ++p)
			{
				string filename=rename(p->first);
				///filename=makelongpath(filename);
				if (p->second.date && p->first!="" && (!isdirectory(p->first)) && (!isads(filename)))
				{
					sizeofdir+=p->second.size;
					dircount++;
///					quantifiles++;
				}
				if (flagdebug3)
				{
					myprintf("01699: %Z\n",filename.c_str());
					myprintf("\n");
				}
			}
			files_edt	.push_back(vettoreparametri[i].theDT);
			files_size	.push_back(sizeofdir);
			files_count	.push_back(dircount);
			files_time	.push_back(vettoreparametri[i].timeend-vettoreparametri[i].timestart+1);
		}
		///delete[] threads;
	}
	else
	{	// single thread. Do a sequential scan
		g_arraybytescanned.push_back(0);
		g_arrayfilescanned.push_back(0);
		for (unsigned i=0; i<files.size(); ++i)
		{
			DTMap myblock;
			if (!flagnoeta)
			{
				print_datetime();
				myprintf("01700: Scan dir <<%s>>\n",files[i].c_str());
			}
			uint64_t blockstart=mtime();
			myscandir(0,myblock,files[i],i_recursive,i_flaghash);
			uint64_t sizeofdir=0;
			uint64_t dircount=0;
			for (DTMap::iterator p=myblock.begin(); p!=myblock.end(); ++p)
			{
				string filename=rename(p->first);
				///filename=makelongpath(filename);
				
				if (p->second.date && p->first!="" && (!isdirectory(p->first)) && (!isads(filename)))
				{
					sizeofdir+=p->second.size;
					dircount++;
///					quantifiles++;
				}
				if (flagdebug3)
				{
					myprintf("01701: %Z\n",filename.c_str());
				}
			}
			files_edt.push_back(myblock);
			files_size.push_back(sizeofdir);
			files_count.push_back(dircount);
			files_time.push_back(mtime()-blockstart);
		}
	}
	return mtime()-startscan;
}
/// wipe free space-check if can write and read OK
int Jidac::fillami()
{
	if (files.size()!=1)
	{
		myprintf("01702! FILL: exactly one directory\n");
		return 2;
	}
	if (!isdirectory(files[0]))
	{
		myprintf("01703! FILL: you need to specify a directory, not a file (last bar)\n");
		return 2;
	}
	moreprint("");
	if (flagzero)
	moreprint("Almost all free space will be filled by zeroed 512MB files.");
	else
	moreprint("Almost all free space will be filled by pseudorandom 512MB files,");
	if (!flagzero)
	moreprint("then checked from the ztempdir-created folder (2GB+ needed).");
	moreprint("");
	moreprint("These activities can reduce the media life,");
	moreprint("especially for solid state drives (SSDs) and if repeated several times.");
	moreprint("");
	if (flagforce)
	{
		moreprint("*** Temporary files are NOT deleted (no -force, to enforce zfs's scrub) ***");
		moreprint("");
	}
	if (!getcaptcha("ok","Fill (wipe) free space"))
				return 1;
	string outputdir=files[0]+"ztempdir/";
	///printf("Z1 makepath %s\n",outputdir.c_str());
	makepath(outputdir);
	if (!direxists(outputdir))
	{
		myprintf("\n");
		myprintf("01704! impossible to makepath %s\n",outputdir.c_str());
		return 2;
	}
	unsigned int percent=99;
	int64_t spazio=getfreespace(outputdir);
	myprintf("01705: Free space %12s (%s) <<%s>>\n",migliaia(spazio),tohuman(spazio),outputdir.c_str());
	if (!flagzero)
		if (spazio<600000000)
		{
			myprintf("01706! less than 600.000.000 bytes free on %s\n",outputdir.c_str());
			return 2;
		}
	uint64_t spacetowrite=spazio*percent/100;
	myprintf("01707: To write   %12s (%s) %d percent\n",migliaia(spacetowrite),tohuman(spacetowrite),percent);
	uint32_t chunksize=(2<<28)/sizeof(uint32_t); //half gigabyte in 32 bits at time
	int chunks=spacetowrite/(chunksize*sizeof(uint32_t));
	chunks--; // just to be sure
	if (chunks<=0)
	{
		if (flagzero)
			chunks=1;
		else
		{
			myprintf("01708: Abort: there is something strange on free space (2GB+)\n");
			return 1;
		}
	}
	myprintf("%d chunks of (%s) will be written\n",chunks,tohuman(chunksize*sizeof(uint32_t)));
	uint32_t *buffer32bit = (uint32_t*)franz_malloc(chunksize*sizeof(uint32_t));
	///g_allocatedram+=chunksize*sizeof(uint32_t);
	if (buffer32bit==0)
	{
		myprintf("01709! GURU cannot alloc the buffer\n");
		return 2;
	}
	int64_t starttutto=mtime();
	uint64_t hashtime;
	uint64_t totaliotime=0;
	uint64_t totalhashtime=0;
	uint64_t totalrandtime=0;
	vector<string> chunkfilename;
	vector<string> chunkhash;
	assert(outputdir.size()<200);
	char mynomefile[200+100];
	memset(buffer32bit,0,chunksize*4);
	for (int i=0;i<chunks;i++)
	{
		/// pseudorandom population (not cryptographic-level, but enough)
		int64_t startrandom=mtime();
		if (!flagzero)
			populateRandom_xorshift128plus(buffer32bit, chunksize,324+i,4444+i);
		int64_t randtime=mtime()-startrandom;
		/// get XXH3, fast and reliable (not cryptographic-level, but enough)
		int64_t starthash=mtime();
		XXH3_state_t state128;
		(void)XXH3_128bits_reset(&state128);
		(void)XXH3_128bits_update(&state128, buffer32bit, chunksize*4);
		XXH128_hash_t myhash=XXH3_128bits_digest(&state128);
		char risultato[33];
		snprintf(risultato,sizeof(risultato),"%s",bin2hex_128(myhash.high64,myhash.low64).c_str());
		chunkhash.push_back(risultato);
		hashtime=mtime()-starthash;
		snprintf(mynomefile,sizeof(mynomefile),"%szchunk_%05d_$%s",outputdir.c_str(),i,risultato);
		chunkfilename.push_back(mynomefile);
		double percentuale=(double)i/(double)chunks*100.0;
		if (i==0)
			percentuale=0;
		myprintf("%03d%% ",(int)percentuale);
		int64_t startio=mtime();
		FILE* myfile=fopen(mynomefile, "wb");
		if (myfile==NULL)
		{
#ifdef _WIN32
			myprintf("01710: myfile not open %s (error %s)\n",mynomefile,migliaia((int64_t)GetLastError()));
#else
			myprintf("01711: myfile KO %s\n",mynomefile);
#endif // corresponds to #ifdef (#ifdef _WIN32)
			exit(0);
		}
		fwrite(buffer32bit, sizeof(uint32_t), chunksize, myfile);
		fclose(myfile);
		int64_t iotime=mtime()-startio;
		uint64_t randspeed=(uint64_t)	(chunksize*sizeof(uint32_t)/((randtime+1)/1000.0));
		uint64_t hashspeed=(uint64_t)	(chunksize*sizeof(uint32_t)/((hashtime+1)/1000.0));
		uint64_t iospeed=(uint64_t)	(chunksize*sizeof(uint32_t)/((iotime+1)/1000.0));
		double trascorso=(mtime()-starttutto+1)/1000.0;
		double eta=((double)trascorso*(double)chunks/(double)i)-trascorso;
		if (i==0)
			eta=0;
		if (eta<356000)
		{
			myprintf("%0d:%02d:%02d",int(eta/3600), int(eta/60)%60, int(eta)%60);
			myprintf(" todo (%10s) rnd (%10s/s) H (%10s/s) W (%10s/s)",
			tohuman(sizeof(uint32_t)*uint64_t(chunksize)*(uint64_t)(chunks-i)),
			tohuman2(randspeed),
			tohuman3(hashspeed),
			tohuman4(iospeed));
			if (flagverbose)
				myprintf("\n");
			else
				myprintf("\r");
		}
		totaliotime		+=iotime;
		totalrandtime	+=randtime;
		totalhashtime	+=hashtime;
	}
	int64_t timetutto=mtime()-starttutto;
	myprintf("01712: Total time %f  rnd %f  hash %f  write %f\n",timetutto/1000.0,totalrandtime/1000.0,totalhashtime/1000.0,totaliotime/1000.0);
	franz_free(buffer32bit);
	if (chunkfilename.size()!=chunkhash.size())
	{
		myprintf("01713! Guru 23925: filename size != hash size\n");
		return 2;
	}
	if (chunkfilename.size()!=(unsigned int)chunks)
	{
		myprintf("01714! Abort: expecting %d chunks but %d founded\n",chunks,(unsigned int)chunkfilename.size());
		return 2;
	}
	/// by default zero to shrink vmdks
	bool flagallok=true;
	bool doverify=true;
	if (flagzero)
		if (!flagverify)
			doverify=false;
	if (doverify)
	{
		myprintf("01715: ******* VERIFY\n");
		g_bytescanned=0;
		g_filescanned=0;
		g_worked=0;
		edt.clear();
		int64_t lavorati=0;
		int64_t startverify=mtime();
		for (int unsigned i=0;i<chunkfilename.size();i++)
		{
			string filename=chunkfilename[i];
			myprintf("01716: Reading chunk %05d ",i);
			g_dimensione=0;
			if (flagdebug3)
				myprintf("01717: franz_do_hash\n");

			franz_do_hash dummy("XXH3");
			if (flagdebug3)
				myprintf("01718: filehash on %s\n",filename.c_str());

			string filehash=dummy.filehash(0,filename,false,-1,-1);
			lavorati+=dummy.o_thefilesize;

			uint64_t hashspeed=(uint64_t)(lavorati/((mtime()-startverify+1)/1000.0));
			myprintf(" (%12s/s) ",tohuman(hashspeed));
			bool flagerrore=(filehash!=chunkhash[i]);
			if (flagerrore)
			{
				myprintf("01719: ERROR\n");
				flagallok=false;
			}
			else
			{
				myprintf("01720: OK %s",chunkhash[i].c_str());
				if (flagverbose)
					myprintf("\n");
				else
					myprintf("\r");
			}
		}
		myprintf("\n");
		int64_t verifytime=mtime()-startverify;
		myprintf("01721: Verify time %f (%10s) speed (%10s/s)\n",verifytime/1000.0,tohuman(lavorati),tohuman2((int64_t)(lavorati/(verifytime/1000.0))));
	}
	if (flagallok)
	{
		myprintf("+OK all OK\n");
		if (!flagforce)
		{
			for (int unsigned i=0;i<chunkfilename.size();i++)
			{
				delete_file(chunkfilename[i].c_str());
				myprintf("01722: Deleting tempfile %05d / %05d\r",i,(unsigned int)chunkfilename.size()-1);
			}
			delete_dir(outputdir.c_str());
			myprintf("\n");
		}
		else
		{
			myprintf("01723: REMEMBER: temp file in %s\n",outputdir.c_str());
		}
	}
	else
		myprintf("01724: ERROR: SOMETHING WRONG\n");
	return 0;
}
int  Jidac::dir()
{

	bool barras	=false;
	bool barraos=false;
	bool barraod=false;
	bool barraa	=false;
	if (files.size()==0)
	{
		if (flagdebug)
			myprintf("01725: push .\n");
		files.push_back(".");
	}
	string cartella=files[0];

	if ((cartella=="/s") || (cartella=="/os") || (cartella=="/od") || (cartella=="/a"))
	{
		files.push_back(cartella);
		files[0]="./";
		cartella=files[0];
	}
	///if	(!isdirectory(cartella))
		///cartella+='/';
	if (cartella==".")
			cartella+='/';

	int posstella=mypos("*",cartella);
	if (posstella>=0)
	{
		string parteiniziale	=cartella.substr(0,posstella);
		string partefinale		=cartella.substr(posstella,cartella.size());
		if (flagdebug2)
		{
			myprintf("01726: start |%s|\n",parteiniziale.c_str());
			myprintf("01727: end   |%s|\n",partefinale.c_str());
		}
		cartella=parteiniziale;
		onlyfiles.clear();
		onlyfiles.push_back(partefinale);
	}

	if (cartella=="")
		cartella="./";
#ifdef unix
	if (flagdebug2)
		myprintf("01728: folder before %s\n",cartella.c_str());
	string nuovacartella=my_realpath(cartella);
	if (flagdebug2)
		myprintf("01729: folder after %s\n",nuovacartella.c_str());
	if	(!isdirectory(nuovacartella))
		nuovacartella+='/';
	if (!flagterse)
		if (cartella!=nuovacartella)
		{
			myprintf("01730$ WARNING path : <<%Z>>\nresolved to         : <<%Z>>\n",cartella.c_str(),nuovacartella.c_str());
		}
	cartella=nuovacartella;
	files[0]=cartella;
#endif // corresponds to #ifdef (#ifdef unix)
	if (!isdirectory(cartella))
		if (!realfileexists(cartella))
			if (direxists(cartella))
				cartella+='/';
	if (files.size()>1)
		for (unsigned i=0; i<files.size(); i++)
		{
				barras	|=(stringcomparei(files[i],"/s"));
				barraos	|=(stringcomparei(files[i],"/os"));
				barraod	|=(stringcomparei(files[i],"/od"));
				barraa	|=(stringcomparei(files[i],"/a"));
		}


	if (!flagterse)
	{
		myprintf("01731: ==== Scanning dir <<%Z>> ",cartella.c_str());
		if (barras)
			myprintf(" /s");
		if (barraos)
			myprintf(" /os");
		if (barraod)
			myprintf(" /od");
		if (barraa)
			myprintf(" /a");

		if (onlyfiles.size()>0)
			myprintf(" pattern %s ",onlyfiles[0].c_str());

		myprintf("\n");
	}
	bool		flagduplicati	=false;
	int64_t 	total_size		=0;
	int 		quantifiles		=0;
	int 		quantedirectory	=0;
	int			quantihash		=0;
	int64_t		hash_calcolati	=0;
	uint64_t	iniziohash		=0;
	uint64_t	finehash			=0;
	flagduplicati=ischecksum();
	if (flagchecksum)
		flagduplicati=false;
	g_bytescanned	=0;
	g_filescanned	=0;
	g_worked		=0;
	flagskipzfs					=true;  // strip down zfs
	scandir(true,edt,cartella,barras);
	eol();
	///printbar(' ',false);
	///myprintf("\r");
	vector <s_fileandsize> fileandsize;
	for (DTMap::iterator p=edt.begin(); p!=edt.end(); ++p)
	{
		bool flagaggiungi=true;
#ifdef _WIN32
		if (!barraa)
			flagaggiungi=((int)attrToString(p->second.attr).find("H") < 0);
		flagaggiungi &= (!isads(p->first));
#endif // corresponds to #ifdef (#ifdef _WIN32)
		if (searchfrom!="")
			flagaggiungi &= (stristr(p->first.c_str(),searchfrom.c_str())!=0);
		if (flagnodir)
			if (isdirectory(p->first.c_str()))
				flagaggiungi=false;
			
		if (flagaggiungi)
		{
			s_fileandsize myblock;
			myblock.filename=p->first;
			myblock.size=p->second.size;
			myblock.attr=p->second.attr;
			myblock.date=p->second.date;
			myblock.isdir=isdirectory(p->first);
			myblock.flaghashstored=false;
			if (flagduplicati)
			{
				if (!myblock.isdir)
				{
					if (minsize)
					{
						if (myblock.size>minsize)
							fileandsize.push_back(myblock);
					}
					else
					if (maxsize)
					{
						if (myblock.size<minsize)
							fileandsize.push_back(myblock);
					}
					else
						fileandsize.push_back(myblock);
				}
			}
			else
				fileandsize.push_back(myblock);
		}
	}
	if (flagduplicati)
	{
		if (flagdebug3)
		{
			myprintf("01732: Pre-sort\n");
			for (unsigned int i=0;i<fileandsize.size();i++)
				myprintf("01733: PRE %08d  %s %s\n",(int)i,migliaia(fileandsize[i].size),fileandsize[i].filename.c_str());
		}
		sort(fileandsize.begin(),fileandsize.end(),comparefilenamesize);
		if (flagdebug3)
		{
			myprintf("01734: Post-sort\n");
			for (unsigned int i=0;i<fileandsize.size();i++)
				myprintf("01735: POST %08d  %s %s\n",(int)i,migliaia(fileandsize[i].size),fileandsize[i].filename.c_str());
		}
		iniziohash=mtime();
		int64_t dalavorare=0;
		for (unsigned int i=0;i<fileandsize.size();i++)
			if (i<fileandsize.size()-1)
			{
				bool entrato=false;
				while (fileandsize[i].size==fileandsize[i+1].size)
				{
					if (!entrato)
					{
						dalavorare+=fileandsize[i].size;
						entrato=true;
					}
					dalavorare+=fileandsize[i+1].size;
					i++;
					if (i==fileandsize.size())
						break;
				}
			}
		myprintf("\n");
		myprintf("01736: Start checksumming %s / %s bytes ...\n",migliaia(fileandsize.size()),migliaia2(dalavorare));
		int larghezzaconsole=terminalwidth()-2;
		if (larghezzaconsole<10)
			larghezzaconsole=80;
		int64_t ultimapercentuale=0;
		int64_t rapporto;
		int64_t percentuale;
		g_dimensione=0;

		for (unsigned int i=0;i<fileandsize.size();i++)
		{
			if (i<fileandsize.size()-1)
			{
				bool entrato=false;
				while (fileandsize[i].size==fileandsize[i+1].size)
				{
					if (!entrato)
					{
						bool saveeta=flagnoeta;
						flagnoeta=true;
						if (flagdebug3)
							myprintf("01737: franz_do_hash\n");

						franz_do_hash dummy(g_thechosenhash);
						if (flagdebug3)
							myprintf("01738: filehash on %s\n",fileandsize[i].filename.c_str());

						string temp=dummy.filehash(0,fileandsize[i].filename,false,-1,-1);

						///string temp=hash_calc_file(flag2algo(),fileandsize[i].filename.c_str(),false,dummycrc,0,0,dummylavorati,thefilesize);
						flagnoeta=saveeta;
						fileandsize[i].hashhex=temp;
						fileandsize[i].flaghashstored=true;
						quantihash++;
						hash_calcolati+=fileandsize[i].size;
						entrato=true;
						if (flagdebug3)
							myprintf("01739: %08d HASH %s %s %19s %s\n",(int)i,fileandsize[i].hashhex.c_str(),dateToString(flagutc,fileandsize[i].date).c_str(),migliaia(fileandsize[i].size),fileandsize[i].filename.c_str());
						else
						{
							rapporto=larghezzaconsole*hash_calcolati/(dalavorare+1);
							percentuale=100*hash_calcolati/(dalavorare+1);
							if (!flagnoeta)
							{
								myprintf("01740: Done %03d ",(unsigned int)percentuale);
								if (percentuale>ultimapercentuale)
								{
									if (rapporto>10)
									{
										for (unsigned j=0;j<rapporto-10;j++)
											myprintf(".");
										ultimapercentuale=percentuale;
									}
								}
								myprintf("\r");
							}
						}
					}
					bool saveeta=flagnoeta;
					flagnoeta=true;
					///string temp=hash_calc_file(flag2algo(),fileandsize[i+1].filename.c_str(),false,dummycrc,0,0,dummylavorati,thefilesize);
					if (flagdebug3)
						myprintf("01741: franz_do_hash\n");
					franz_do_hash dummy(g_thechosenhash);
					if (flagdebug3)
						myprintf("01742: filehash on %s\n",fileandsize[i+1].filename.c_str());

					string temp=dummy.filehash(0,fileandsize[i+1].filename,false,-1,-1);

					///string temp=hash_calc_file(flag2algo(),fileandsize[i+1].filename.c_str(),false,dummycrc,0,0,dummylavorati,thefilesize);
					flagnoeta=saveeta;
					fileandsize[i+1].hashhex=temp;
					fileandsize[i+1].flaghashstored=true;
					quantihash++;
					hash_calcolati+=fileandsize[i+1].size;
					if (flagdebug3)
						myprintf("01743: %08d HASH-2 %s %s %19s %s\n",i+1,fileandsize[i+1].hashhex.c_str(),dateToString(flagutc,fileandsize[i+1].date).c_str(),migliaia(fileandsize[i+1].size),fileandsize[i+1].filename.c_str());
					else
					{
						rapporto=larghezzaconsole*hash_calcolati/(dalavorare+1);
						percentuale=100*hash_calcolati/(dalavorare+1);
						if (!flagnoeta)
						{
							myprintf("01744: Done %03d ",(unsigned int)percentuale);
							if (percentuale>ultimapercentuale)
								{
									if (rapporto>10)
									{
										for (unsigned j=0;j<rapporto-10;j++)
											myprintf(".");
										ultimapercentuale=percentuale;
									}
								}
							myprintf("\r");
						}
					}
					i++;
					if (i==fileandsize.size())
						break;
				}
			}
		}
		finehash=mtime();
		myprintf("\n");
		sort(fileandsize.begin(),fileandsize.end(),comparecrc32);
		if (flagdebug3)
		{
			myprintf("01745: Hash taken %08d %s\n",quantihash,migliaia(hash_calcolati));
			myprintf("01746: Before shrink %s\n",migliaia(fileandsize.size()));
			myprintf("01747: Time %f\n",(finehash-iniziohash)/1000.0);
			for (unsigned int i=0;i<fileandsize.size();i++)
				myprintf("01748: before shrink %08d  %s %s\n",(int)i,fileandsize[i].hashhex.c_str(),fileandsize[i].filename.c_str());
		}
		int limite=-1;
		for (unsigned int i=0;i<fileandsize.size(); i++)
		{
			if (flagdebug3)
				myprintf("01749: %d size %s <<%s>>\n",(int)i,migliaia(fileandsize.size()),fileandsize[i].hashhex.c_str());
			if (!fileandsize[i].flaghashstored)
			{
				limite=i;
				break;
			}
		}
		if (flagverbose)
		myprintf("01750: Limit founded %d\n",limite);
		if (limite>-1)
			for (int i=fileandsize.size()-1;i>=limite;i--)
				fileandsize.pop_back();
		if (flagdebug3)
		{
			myprintf("01751: After shrink %s\n",migliaia(fileandsize.size()));
			for (unsigned int i=0;i<fileandsize.size();i++)
				myprintf("01752: After shrinking %08d  %s %s\n",(int)i,fileandsize[i].hashhex.c_str(),fileandsize[i].filename.c_str());
		}
		sort(fileandsize.begin(),fileandsize.end(),comparesizehash);
		if (flagdebug3)
		{
			myprintf("01753: After re-sort %s\n",migliaia(fileandsize.size()));
			for (unsigned int i=0;i<fileandsize.size();i++)
				myprintf("01754: After re-sort %08d  %s %s\n",(int)i,fileandsize[i].hashhex.c_str(),fileandsize[i].filename.c_str());
		}
	}
	else
	{
	///	if (orderby!="")
		///	sort(fileandsize.begin(), fileandsize.end(), compareorderby);

		if (barraod)
			sort(fileandsize.begin(),fileandsize.end(),comparefilenamedate);
		if (barraos)
			sort(fileandsize.begin(),fileandsize.end(),comparefilenamesize);
	}
	unsigned int inizio=0;
	if (menoenne)
		if (menoenne<fileandsize.size())
			inizio=fileandsize.size()-menoenne;
	int64_t tot_duplicati=0;
	for (unsigned int i=inizio;i<fileandsize.size();i++)
		if (fileandsize[i].isdir)
		{
			if (fileandsize[i].filename[0]=='.')
				if (fileandsize[i].filename[1]=='/')
					 fileandsize[i].filename=fileandsize[i].filename.substr(2,fileandsize[i].filename.size()-3);
		}
		else
		{
			if (fileandsize[i].filename[0]=='.')
				if (fileandsize[i].filename[1]=='/')
					fileandsize[i].filename=fileandsize[i].filename.substr(2,string::npos);
		}
	for (unsigned int i=inizio;i<fileandsize.size();i++)
		if (fileandsize[i].isdir)
		{
			myprintf("%s    <DIR>               ",dateToString(flagutc,fileandsize[i].date,!flagutc).c_str());
			printUTF8(fileandsize[i].filename.c_str());
			myprintf("\n");
			quantedirectory++;
		}
		else
		{
			total_size+=fileandsize[i].size;
			quantifiles++;
			if (flagduplicati)
			{
				if (i<fileandsize.size()-1)
				{
					bool entrato=false;
					//if (memcmp(fileandsize[i].crc32hex,fileandsize[i+1].crc32hex,8)==0)
					if (fileandsize[i].hashhex==fileandsize[i+1].hashhex)
					{
						if (flagverbose)
							myprintf("%s ",fileandsize[i].hashhex.c_str());
						myprintf("%s %19s ",dateToString(flagutc,fileandsize[i].date,!flagutc).c_str(),migliaia(fileandsize[i].size));
						printUTF8(fileandsize[i].filename.c_str());
						myprintf("\n");
						while (fileandsize[i].hashhex==fileandsize[i+1].hashhex)
						{
							if (flagverbose)
							myprintf("%s ",fileandsize[i].hashhex.c_str());
							myprintf("================= %19s ",migliaia(fileandsize[i+1].size));
							printUTF8(fileandsize[i+1].filename.c_str());
							myprintf("\n");
							tot_duplicati+=fileandsize[i].size;
							entrato=true;
							i++;
							if (i==fileandsize.size())
								break;
						}
					}
					if (entrato)
						myprintf("\n");
				}
			}
			else
			{
				myprintf("%s %22s ",dateToString(flagutc,fileandsize[i].date,!flagutc).c_str(),migliaia(fileandsize[i].size));
				if (flagchecksum)
				{
					if (flagdebug3)
						myprintf("01755: franz_do_hash\n");

					franz_do_hash dummy(g_thechosenhash);
					if (flagdebug3)
						myprintf("01756: filehash on %s\n",fileandsize[i].filename.c_str());

					string temp=dummy.filehash(0,fileandsize[i].filename,false,-1,-1);
					myprintf("|| %s:%s ",g_thechosenhash_str.c_str(),temp.c_str());
				}
				printUTF8(fileandsize[i].filename.c_str());
				myprintf("\n");
			}
		}
	if (!flagterse)
	{
		myprintf("    %10s File %20s byte\n",migliaia(quantifiles),migliaia2(total_size));
		if (!flagduplicati)
		myprintf("    %10s dir ",migliaia(quantedirectory));
		else
		myprintf("                   ");
	}
	if (!isdirectory(cartella))
	{
		string percorso=extractfilepath(cartella);
		if (percorso=="")
			cartella="./";
		else
			cartella=percorso;
		///myprintf("01757: PERCO |%s|\n",percorso.c_str());
	}
	int64_t spazio=getfreespace(cartella);
	if (!flagterse)
	{
		myprintf(" %20s bytes (%s) free",migliaia(spazio),tohuman(spazio));
		myprintf("\n");
	}
	if (flagduplicati)
	{
		myprintf("\n");
		myprintf("01758: Duplicated %19s byte\n",migliaia(tot_duplicati));
		myprintf("01759: Hashed %8s files %18s bytes in %f s %s /s\n",migliaia(quantihash),migliaia2((int64_t)hash_calcolati),(finehash-iniziohash)/1000.0,migliaia3((int64_t)(hash_calcolati/((finehash-iniziohash+1)/1000.0))));
	}
	return 0;
}

#ifdef ZPAQFULL ///NOSFTPSTART
int Jidac::decimation()
{
	bool flagthelastone=false;
	if (g_exec!="")
		flagthelastone=true;
	if (flagthelastone)
		myprintf("01760: *** Run the last ones *** ");
	else
		myprintf("01761: *** Decimation *** ");
	myprintf(" *** -kill missing: dry run *** ");
	if (!flagforcezfs)
		myprintf(" *** ignoring .zfs and :$DATA ***");
	myprintf("\n\n");
	if (g_exec!="")
		if (!fileexists(g_exec))
		{
			myprintf("01762! -g_exec does not exists\n");
			return 2;
		}
	if (flagthelastone)
		if (menoenne==0)
			menoenne=1;
	if (menoenne==0)
	{
		myprintf("01763: -n or -limit not set\n");
		return 1;
	}
	flagbarraod=true; // by default, sort by date
	if (flagbarraon)
		flagbarraod=false; // if /on, sort by name
	if (files.size()>1)
	{
		myprintf("01764: only one dir can be elaborated\n");
		return 1;
	}
#ifdef _WIN32
	if (mypos("*",files[0])==-1)
	{
		myprintf("01765: * pattern requested (ex. /tmp/dump_*.sql)\n");
		return 1;
	}
#endif // corresponds to #ifdef (#ifdef _WIN32)
	franzparallelscandir(false,false,false);
	myprintf("\n");
	if (files_edt[0].size()==0)
	{
		myprintf("01766: empty result, nothing to do\n");
		return 0;
	}
	if (!flagthelastone)
		if (!flagforce)
			if (files_edt[0].size()>50)
			{
				myprintf("01767: founded a lot of files (%s), no -force => quit (security measure)\n",migliaia(files_edt[0].size()));
				return 1;
			}
	vector<string> 		scannedfiles;
	if (flagbarraod)
	{
		myprintf("01768: Order by DATE (/od or default)\n");
		vector<DTMap::iterator> filelist;
		for (DTMap::iterator a=files_edt[0].begin(); a!=files_edt[0].end(); ++a)
			filelist.push_back(a);
		sort(filelist.begin(), filelist.end(), comparedatethenfilename);
		for (unsigned int i=0; i<filelist.size();i++)
			scannedfiles.push_back(filelist[i]->first);
	}
	else
	{
		myprintf("01769: Order by NAME (/on)\n");
		for (DTMap::iterator p=files_edt[0].begin(); p!=files_edt[0].end(); ++p)
			scannedfiles.push_back(p->first);
	}
	if (scannedfiles.size()<=menoenne)
	{
		if (flagthelastone)
			menoenne=scannedfiles.size();
		else
		{
			myprintf("01770: candidate %s less or equal to limit %s => do nothing\n",migliaia(menoenne),migliaia2(scannedfiles.size()));
			return 0;
		}
	}
	vector<string> tobedeleted;
	if (flagthelastone)
	{
		for (unsigned int i=1;i<=menoenne;i++)
			tobedeleted.push_back(scannedfiles[scannedfiles.size()-i]);
	}
	else
	{
		for (unsigned int i=0;i<scannedfiles.size()-menoenne;i++)
			tobedeleted.push_back(scannedfiles[i]);
		if (flagverbose)
			for (unsigned int i=scannedfiles.size()-menoenne;i<scannedfiles.size();i++)
				myprintf("01771: KEEP   %s\n",scannedfiles[i].c_str());
	}
	myprintf("\n");
	myprintf("01772: Candidate (to be elaborated) %12s\n",migliaia(tobedeleted.size()));
	if (tobedeleted.size()==0)
	{
		myprintf("01773: Nothing to do\n");
		return 0;
	}
	if (!flagkill)
		myprintf("01774: dry run (no -kill)\n");
	if (flagthelastone)
	{
		myprintf("01775: Executing  %s times <<%s>>\n",migliaia(tobedeleted.size()),g_exec.c_str());
		for (unsigned int i=0;i<tobedeleted.size();i++)
		{
			#ifdef _WIN32
				myreplaceall(tobedeleted[i],"/","\\");
			#endif // corresponds to #ifdef (#ifdef _WIN32)
			myprintf("%08d with param <<%s>>\n",i+1,tobedeleted[i].c_str());
			if (flagkill)
				xcommand(g_exec,tobedeleted[i]);
		}
		return 0;
	}
	int deleted=0;
	int highlander=0;
	for (unsigned int i=0;i<tobedeleted.size();i++)
	{
		if (flagverbose)
		{
			myprintf("01776: DELETE <<%Z>>\n",tobedeleted[i].c_str());
			
		}
		if (flagkill)
		{
			if (delete_file(tobedeleted[i].c_str()))
				deleted++;
			else
				highlander++;
		}
	}
	if (deleted>0)
	myprintf("01777: Deleted                      %12s\n",migliaia(deleted));
	if (highlander>0)
	{
		myprintf("01778! Highlander                   %12s\n",migliaia(highlander));
		return 2;
	}
	return 0;
}
#endif ///NOSFTPEND

#ifdef _WIN32
bool iswinroot(const string& i_path)
{
#ifdef _WIN32
	/// 0123456
	/// E:        2
	/// E:\       3
	/// E:\*      4
 	/// E:\*.*    6
	/// 012345
	if (flagdebug2)
		myprintf("01779: iswinroot %s\n",i_path.c_str());
	if ((i_path.size()>6) || (i_path.size()<2) || (i_path.size()==5))
		return false;
	if (flagdebug3)
		myprintf("01780: x1\n");
	if (!isalpha(i_path[0]))
		return false;
	if (flagdebug3)
		myprintf("01781: x2\n");
	if (i_path[1]!=':')
		return false;
	if (flagdebug3)
		myprintf("01782: x3\n");
	if (i_path.size()==2)
		return true;		// E:
	if (flagdebug3)
		myprintf("01783: x4\n");
	if ((i_path[2]!='/') && (i_path[2]!='\\'))
		return false;
	if (flagdebug3)
		myprintf("01784: x5\n");
	if (i_path.size()==3)
		return	true;		// E:\ E:/
	if (flagdebug3)
		myprintf("01785: x6\n");
	if ((i_path[3]!='*'))
		return false;
	if (flagdebug3)
		myprintf("01786: x7\n");
	if (i_path.size()==4)
		return true;		// E:\*, E:/*
	if (flagdebug3)
		myprintf("01787: x8\n");
	if ((i_path[4]!='.'))
		return false;
	if (flagdebug3)
		myprintf("01788: x9\n");
	if (i_path.size()==6)
		if (i_path[5]=='*')
			return true;
	if (flagdebug3)
		myprintf("01789: x10\n");
#endif // corresponds to #ifdef (#ifdef _WIN32)
	return false;
}
#endif // corresponds to #ifdef (#ifdef _WIN32)

string prendiprimariga(const string i_filename)
{
	if (flagdebug)
		myprintf("01790: getting first line  %s\n",i_filename.c_str());
	
	if (i_filename=="")
		return "";
	if (!fileexists(i_filename))
	{
		myprintf("01791: File not found %Z\n",i_filename.c_str());
		return "";
	}

	FILE* backupfile=fopen(i_filename.c_str(), "rb");
	if (backupfile==NULL)
	{
		myprintf("01792: Cannot open file\n");
		return "";
	}

#ifdef ANCIENT
	char 	line[16384];
#else
	char 	line[65536];
#endif // corresponds to #ifdef (#ifdef ANCIENT)

	string linea="";
	if (!fgets(line, sizeof(line), backupfile))
	{
		myprintf("01793: failed reading first line\n");
		fclose(backupfile);
		return "";
	}
	fclose(backupfile);

	linea=line;
	if (linea.size()==0)
	{
		myprintf("01794: first line empty\n");
		return "";
	}
	return linea;
}

bool iszpaqfranzfile(const string i_filename,const string i_header)
{
		
	string linea=prendiprimariga(i_filename);
	if (linea.size()==0)
	{
		myprintf("01795: first line empty\n");
		return false;
	}
	if (mypos(i_header,linea)==-1)
	{
		myprintf("01796: File does not seems by zpaqfranz %s\n",linea.c_str());
		return false;
	}
	return true;
}

string getfirsthash(const string i_theline)
{
	string hashletto="";
	unsigned int i=0;
	while (i<i_theline.size())
	{
		if (ishex(i_theline[i]))
			hashletto+=i_theline[i++];
		else
			break;
	}
	return stringtolower(hashletto);
}

bool getdatafromfasttxt(string i_filename,string& o_crc32,string& o_quick,string& o_precrc32,int64_t& o_size)
{
	o_crc32		="";
	o_precrc32	="";
	o_quick		="";
	o_size		=0;
	if (!iszpaqfranzfile(i_filename,"$zpaqfranz fasttxt|"))
	{
		myprintf("01797: Does not seems a zpaqfranz's fasttxt %Z\n",i_filename.c_str());
		return false;
	}
	FILE* backupfile=fopen(i_filename.c_str(), "rb");
	if (backupfile==NULL)
	{
		myprintf("01798: Cannot open fasttxt\n");
		return false;
	}
#ifdef ANCIENT
	char 	line[16384];
#else
	char 	line[65536];
#endif // corresponds to #ifdef (#ifdef ANCIENT)
	string linea="";
	if (!fgets(line, sizeof(line), backupfile))
	{
		myprintf("01799: failed reading first line\n");
		fclose(backupfile);
		return false;
	}
	linea=line;
	if (linea.size()==0)
	{
		myprintf("01800: first line empty\n");
		fclose(backupfile);
		return false;
	}
	if (mypos("$zpaqfranz fasttxt|",linea)==-1)
	{
		myprintf("01801: Abort: first line is strange %s\n",linea.c_str());
		fclose(backupfile);
		return false;

	}
	if (!fgets(line, sizeof(line), backupfile))
	{
		myprintf("01802: failed reading second line\n");
		fclose(backupfile);
		return false;
	}
	linea=line;
	if (linea.size()==0)
	{
		myprintf("01803: second line empty\n");
		fclose(backupfile);
		return false;
	}
	string crc32fromtxt=getfirsthash(linea);
	if (crc32fromtxt.size()!=8)
	{
		myprintf("01804: CRC32 from fasttxt length !=8 %s\n",crc32fromtxt.c_str());
		fclose(backupfile);
		return false;
	}
	linea=mytrim(myright(linea,linea.size()-crc32fromtxt.size()));
	string quickprefromtxt=getfirsthash(linea);
	if (quickprefromtxt!="0")
		if (quickprefromtxt.size()!=16)
		{
			myprintf("01805: quick pre from fasttxt length !=16 %s\n",quickprefromtxt.c_str());
			fclose(backupfile);
			return false;
		}
	linea=mytrim(myright(linea,linea.size()-quickprefromtxt.size()));
	string crc32prefromtxt=getfirsthash(linea);
	if (crc32prefromtxt!="0")
		if (crc32prefromtxt.size()!=8)
		{
			myprintf("01806: crcpre32 from fasttxt length !=8 %s\n",crc32prefromtxt.c_str());
			fclose(backupfile);
			return false;
		}
	linea=mytrim(myright(linea,linea.size()-crc32prefromtxt.size()));
	string sizefromtxt="";
	unsigned int i=0;
	while ((i<linea.size()) && (linea[i]!='['))
		i++;
	while ((i<linea.size()) && (linea[i]!=']'))
	{
		if (isdigit(linea[i]))
			sizefromtxt+=linea[i];
		i++;
	}
	fclose(backupfile);
	if (flagdebug3)
	{
		myprintf("01807: CRC32     FROM FASTTXT %s|\n",crc32fromtxt.c_str());
		myprintf("01808: QUICKPRE  FROM FASTTXT %s|\n",quickprefromtxt.c_str());
		myprintf("01809: CRC32PRE  FROM FASTTXT %s|\n",crc32prefromtxt.c_str());
		myprintf("01810: SIZE      FROM FASTTXT %s|\n",sizefromtxt.c_str());
	}
	o_crc32	=crc32fromtxt;
	o_precrc32=crc32prefromtxt;
	o_quick	=quickprefromtxt;
	o_size	=myatoll(sizefromtxt.c_str());
	return true;
}
bool writedatainfasttxt(string i_filename,string i_archive,string i_crc32,string i_quick,string i_precrc32,int64_t i_size,int64_t i_presize)
{
	if (i_filename=="")
	{
		myprintf("01811: i_filename empty\n");
		return false;
	}
	if (i_archive=="")
	{
		myprintf("01812: i_archive empty\n");
		return false;
	}
	if (i_crc32.size()!=8)
	{
		myprintf("01813: i_crc32 not 8 |%s|\n",i_crc32.c_str());
		return false;
	}
	if (i_quick!="0")
		if (i_quick.size()!=16)
		{
			myprintf("01814: i_quick not 16 |%s|\n",i_quick.c_str());
			return false;
		}
	if (i_precrc32=="")
		i_precrc32="0";
	if (i_precrc32!="0")
		if (i_precrc32.size()!=8)
		{
			myprintf("01815: i_precrc32 not 0 |%s|\n",i_precrc32.c_str());
			return false;
		}
	if (i_size<0)
	{
		myprintf("01816: i_size negative\n");
		return false;
	}
	if (i_presize<0)
	{
		myprintf("01817: i_presize negative\n");
		return false;
	}

	FILE* backupfile=fopen(i_filename.c_str(), "wb");
	if (backupfile==NULL)
	{
		myprintf("01818: Cannot write on fasttxt\n");
		return false;
	}
	fprintf(backupfile,"$zpaqfranz fasttxt|1|%s|%s\n",dateToString(true,now()).c_str(),i_archive.c_str());
	fprintf(backupfile,"%s %s %s [%s] (%s)\n",i_crc32.c_str(),i_quick.c_str(),i_precrc32.c_str(),migliaia(i_size),migliaia2(i_presize));
	fclose(backupfile);
	
	return true;
}


int Jidac::append()
{
	myprintf("01819: Append 2-pass *** ALPHA STAGE *** ANTI-RANSOMWARE (FOR chflags sappend)\n");

	g_optional	="ransomware";
	g_cdatasize	=0;
	g_htsize	=0;

	g_fakewrite	=true;
	int errore	=add();
	g_fakewrite	=false;

	if (errore==0)
	{
		if (flagdebug3)
			myprintf("01820: Second round cdatasize %s  htsize %s\n",migliaia(g_cdatasize),migliaia2(g_htsize));
		jidacreset();
		return add();
	}
	else
	{
		myprintf("01821: append() something is wrong %d\n",errore);
		return errore;
	}
}


struct twoint
{
	int32_t first;
	int32_t second;
};

int	Jidac::rebuildcrc32(string i_filename,string& o_prezpaqcrc32,int64_t& 	o_prezpaqsize,string& o_thecrcfile)
{
	myprintf("01822: Rebuilding broken fasttxt (TRIM for incomplete transaction) <<%Z>>\n",i_filename.c_str());
	
	if (i_filename!=g_indexname)
	{
		if (flagads && check_if_password(i_filename))
		{
			myprintf("01823: TRIM skipped, -ads AND password\n");
		}
		else
		{
			flagkill=true;
			jidacreset();
			files.clear();
			files.push_back(i_filename.c_str());
			myprintf("01824: TRIM done, recomputing hash and CRC-32\n");
		}
	}
	int64_t startverify		=mtime();
	franz_do_hash dummyquick("QUICK");
	if (flagdebug3)
		myprintf("01825: filehash QUICK on %s\n",i_filename.c_str());

	g_dimensione=0;
	string o_initialzpaqquick=dummyquick.filehash(0,i_filename,false	,startverify,prendidimensionefile(i_filename.c_str()));
	if (o_initialzpaqquick=="")
	{
		myprintf("01826! quick hash empty!\n");
		return 2;
	}


	franz_do_hash dummyquick2("CRC-32");
	if (flagdebug3)
		myprintf("01827: filehash CRC-32 on %s\n",i_filename.c_str());

	///myprintf("01828: 4444444444444 %s\n",tohuman(prendidimensionefile(i_filename.c_str())));
	g_dimensione=0;
	string o_initialzpaqcrc32=dummyquick2.filehash(0,i_filename,false,startverify,prendidimensionefile(i_filename.c_str()));
	if (o_initialzpaqcrc32=="")
	{
		myprintf("01829! CRC-32 empty!\n");
		return 2;
	}

	myprintf("01830: Rebuilding fasttxt (%s) %Z",o_initialzpaqcrc32.c_str(),o_thecrcfile.c_str());
	if (!writedatainfasttxt(o_thecrcfile,i_filename,o_initialzpaqcrc32,o_initialzpaqquick,
	"0",prendidimensionefile(i_filename.c_str()),0))
	{
		myprintf(" :62957: something wrong!\n");
		return 2;
	}
	else
		myprintf(" :OK\n");
	if (!getdatafromfasttxt(o_thecrcfile,o_initialzpaqcrc32,o_initialzpaqquick,o_prezpaqcrc32,o_prezpaqsize))
	{
		myprintf("01831! Failed getting data from fasttxt!\n");
		return 2;
	}
	myprintf("01832: REBUILDED CRC32     %s QUICK %s SIZE %s\n",o_initialzpaqcrc32.c_str(),o_initialzpaqquick.c_str(),migliaia(o_prezpaqsize));
	return 0;
}

void forceextension(std::string& io_file, std::string i_newextension) 
{
    if (io_file=="")
        return;    
    size_t     last_dot    = io_file.rfind('.');
    size_t     last_slash     = io_file.rfind('/');
	if (i_newextension=="") 
    {
        if (last_dot != std::string::npos && 
            (last_slash == std::string::npos || last_dot > last_slash)) 
            io_file=io_file.substr(0, last_dot);
        return;
    }

    if (!i_newextension.empty() && i_newextension[0] != '.') 
        i_newextension='.'+i_newextension;

    if (last_dot == std::string::npos || 
        (last_slash != std::string::npos && last_dot < last_slash)) 
        io_file+=i_newextension;
    else 
        io_file=io_file.substr(0, last_dot)+i_newextension;
}


int	Jidac::makecrc32txt(string i_filename,
string& 	o_initialquickhash,
int64_t& 	o_initialzpaqsize,
string& 	o_initialzpaqquick,
string& 	o_initialzpaqcrc32,
string& 	o_prezpaqcrc32,
int64_t& 	o_prezpaqsize,
string&		o_thecrcfile)
{

	string 	percorso	=extractfilepath		(i_filename);
	string	nome		=prendinomefileebasta	(i_filename);
	o_thecrcfile		=percorso+nome+"_crc32.txt";
	
	if (flagads)
		o_thecrcfile=i_filename+":fasttxt";
	
	
	if (flagverbose)
		myprintf("01833: Doing makecrc32txt on %s\n",o_thecrcfile.c_str());
	if (fileexists(i_filename))
	{
		franz_do_hash dummyquick("QUICK");
		if (flagdebug3)
			myprintf("01834: filehash on %s\n",i_filename.c_str());

		o_initialquickhash=dummyquick.filehash(0,i_filename,false,-1,-1);
		o_initialzpaqsize=prendidimensionefile(i_filename.c_str());
	}
	bool	fastisok	=true;
	if (fileexists(i_filename))
		if (!fileexists(o_thecrcfile))
		{
			myprintf("01835! fasttxt does not exists %Z\n",o_thecrcfile.c_str());
			myprintf("01836: You can rebuild with -space\n");
			fastisok=false;
		}
	if (fileexists(o_thecrcfile))
	{
		if (flagverbose)
		{
			myprintf("01837: Founded fasttxt %Z\n",o_thecrcfile.c_str());
		}

		if (!getdatafromfasttxt(o_thecrcfile,o_initialzpaqcrc32,o_initialzpaqquick,o_prezpaqcrc32,o_prezpaqsize))
		{
			myprintf("01838! Failed getting data from fasttxt!\n");
			return 2;
		}
		if (flagverbose)
			myprintf("01839: CRC32  %s QUICK %s SIZE %s\n",o_initialzpaqcrc32.c_str(),o_initialzpaqquick.c_str(),migliaia(o_prezpaqsize));
		if (o_prezpaqsize!=o_initialzpaqsize)
		{
			myprintf("01840: size into fasttxt does not match %s vs %s\n",migliaia(o_prezpaqsize),migliaia2(o_initialzpaqsize));
			if (!flagspace)
			{
				myprintf("01841! quitting now. You can override with -space\n");
				return 2;
			}
			fastisok=false;
		}
		if (stringtoupper(o_initialquickhash)!=stringtoupper(o_initialzpaqquick))
		{
			myprintf("01842: quick fasttxt does not match %s vs %s\n",o_initialzpaqquick.c_str(),o_initialquickhash.c_str());
			if (!flagspace)
			{
				myprintf("01843! quitting now. You can override with -space\n");
				return 2;
			}
			fastisok=false;
		}
	}

	if (!fastisok)
	{
		if (!flagspace)
			return 2;
		///rebuild the file
		rebuildcrc32(i_filename,o_prezpaqcrc32,o_prezpaqsize,o_thecrcfile);
		seppuku();
		exit(0);
	}
	return 0;
}



std::string devicetoname(const std::string& i_device) 
{
    std::string result = i_device;  // Copy of the original string

    for (size_t i = 0; i < result.length(); ++i) 
	    if (!((result[i] >= 'A' && result[i] <= 'Z') || 
              (result[i] >= 'a' && result[i] <= 'z') || 
              (result[i] >= '0' && result[i] <= '9')))
				result[i] = '_';
    return result;
}


void Jidac::updatehash(DTMap::iterator* i_p,char* i_buf,int i_buflen)
{
	if (i_p==NULL)
		return;
	if (i_buf==NULL)
		return;
	(*i_p)->second.hashedsize+=i_buflen;
	(*i_p)->second.file_crc32=crc32_16bytes(i_buf,i_buflen,(*i_p)->second.file_crc32);
	if ((g_franzotype==FRANZO_XXHASH64) || (g_franzotype==FRANZO_XXHASH64B))
		if ((*i_p)->second.pfile_xxhash64)
			(*(*i_p)->second.pfile_xxhash64).add(i_buf,i_buflen);
	if ((g_franzotype==FRANZO_SHA_1)||(g_franzotype==FRANZO_SHA_1B))
		if ((*i_p)->second.pfile_sha1)
			((*i_p)->second.pfile_sha1)->write(i_buf,i_buflen);
	if ((g_franzotype==FRANZO_SHA_256)||(g_franzotype==FRANZO_SHA_256B))
		if ((*i_p)->second.pfile_sha256)
			((*i_p)->second.pfile_sha256)->write(i_buf,i_buflen);
	if ((g_franzotype==FRANZO_XXH3)||(g_franzotype==FRANZO_XXH3B))
		if ((*i_p)->second.pfile_xxh3)
			(void)XXH3_128bits_update((*i_p)->second.pfile_xxh3,i_buf,i_buflen);
	if ((g_franzotype==FRANZO_BLAKE3)||(g_franzotype==FRANZO_BLAKE3B))
		if ((*i_p)->second.pfile_blake3)
			blake3_hasher_update((*i_p)->second.pfile_blake3,i_buf,i_buflen);
	if ((g_franzotype==FRANZO_SHA3)||(g_franzotype==FRANZO_SHA3B))
		if ((*i_p)->second.pfile_sha3)
			(*(*i_p)->second.pfile_sha3).add(i_buf,i_buflen);
	if ((g_franzotype==FRANZO_MD5) || (g_franzotype==FRANZO_MD5B))
		if ((*i_p)->second.pfile_md5)
			(*(*i_p)->second.pfile_md5).add(i_buf,i_buflen);
	if (g_franzotype==FRANZO_WHIRLPOOL)
		if ((*i_p)->second.pfile_whirlpool)
			NESSIEadd64((const unsigned char*)i_buf,i_buflen*8,(*i_p)->second.pfile_whirlpool);/// <-- whirlpool works on BITS, so *8
	if ((g_franzotype==FRANZO_HIGHWAY64) || (g_franzotype==FRANZO_HIGHWAY128) || (g_franzotype==FRANZO_HIGHWAY256))
		if ((*i_p)->second.pfile_highway64)
			HighwayHashCatAppend((const unsigned char*)i_buf,i_buflen,(*i_p)->second.pfile_highway64);
}
#ifdef _WIN32
string	win_getlong(const string& i_file)
{
	/*
	symlink
		
    CreateFile(c_str(),
        0,
        0,  
        0,
        OPEN_EXISTING,
        FILE_FLAG_BACKUP_SEMANTICS,
        0);
     GetFinalPathNameByHandle(hFile, path, MAX_PATH, FILE_NAME_NORMALIZED);
        if (rcode)
        {
            if (path[0] == '\\' && path[1] == '\\' && path[2] == '?' && path[3] == '\\')
                return std::wstring(path + 4, path + rcode);
            else
                return std::wstring(path, path + rcode);
        }
	*/
	if (iswindowsxp())
		return i_file;
	
	if (getFinalPathNameByHandleW==NULL)
	{
		myprintf("01844: GURU: getFinalPathNameByHandleW is NULL (very old windows?)\n");
		seppuku();
		return "";
	}
	
	TCHAR filepath[MAX_PATH];
    HANDLE hfile=CreateFile(utow(i_file.c_str()).c_str(),GENERIC_READ,FILE_SHARE_READ,NULL,OPEN_EXISTING,FILE_ATTRIBUTE_NORMAL,NULL);
    if (hfile==INVALID_HANDLE_VALUE) 
	{
		if (flagdebug3)
			myprintf("01845: hfile INVALID_HANDLE_VALUE %lu\n",GetLastError());
        return "";
    }
	//manual imported from DLL
    DWORD dwsize=getFinalPathNameByHandleW(hfile,filepath,MAX_PATH,FILE_NAME_NORMALIZED);
    if (dwsize==0)
	{
		if (flagdebug3)
			myprintf("01846: dwSize not good %lu\n",GetLastError());
        CloseHandle(hfile);
        return "";
    }
	std::wstring widestring(filepath);
	CloseHandle(hfile);
	string risultato=wtou(widestring.c_str());
	return risultato;
}			
#endif		 // corresponds to #ifdef (#ifdef _WIN32)
string	forgefastcrc32(string i_filename)
{
	string 	percorso	=extractfilepath		(i_filename);
	string	nome		=prendinomefileebasta	(i_filename);
	return percorso+nome+"_crc32.txt";
}


bool isfastcrc32(string i_filename)
{
	return fileexists((forgefastcrc32(i_filename)));
}

// Add or delete files from archive. Return 1 if error else 0.
// Note: by flagverify do a CRC32-integrity check (@zpaqfranz)
///zpaqfranz a z:\1 \\?\UNC\franzk\z\cb -longpath -debug
int Jidac::add()
{
	
	string tobetested=subpart(archive, 1);
	myprintf("DEBUG: Tobetested %s\n",tobetested.c_str());
	if (!flagfasttxt)
		if (isfastcrc32(tobetested))
		{
			myprintf("65202$ Turning on -fasttxt because <<%Z>> does exists\n",forgefastcrc32(tobetested).c_str());
			flagfasttxt=true;
		}

	if (g_checksize>0)
	{
		string percorso=extractfilepath(archive);
		if (percorso!="")
		{
			int64_t spazio=getfreespace(percorso.c_str());
			if (spazio<0)
				spazio=0;
			if (flagdebug)
				myprintf("65077: -checksize %s  free on <<%Z>> is %s\n",tohuman(g_checksize),percorso.c_str(),tohuman2(spazio));
			if ((uint64_t)spazio<g_checksize)
			{
				myprintf("65073! -checksize %s  free on <<%Z>> is %s => abort\n",tohuman(g_checksize),percorso.c_str(),tohuman2(spazio));
				return 2;
			}
		}
		else
			myprintf("65087$ Cannot check space on <<%Z>>: use a full path!\n",archive.c_str());
	}
#ifdef _WIN32
	if (flaglongpath && (tofiles.size()>0))
		if (!do_not_print_headers())
			if (flagdebug)
				myprintf("68130$ WARNING: -longpath turned off, incompatible with -to\n");
#endif	 // corresponds to #ifdef (#ifdef _WIN32)
	if (g_chunk_size>0)
	{
		flagnotrim=true;
		myprintf("62896$ -notrim enabled due to -chunk\n");
	}
	if ((g_chunk_size>0) && (flagtmp))
	{
		myprintf("62802! Sorry -tmp does not work with -chunk\n");
		return 2;
	}
	if ((g_password!=NULL) && (flagbackupzeta))
	{
		myprintf("67649! Sorry, -backupzeta does not work with encryption\n");
		return 2;	
	}

	string externaloutputfile="";
#ifdef ZPAQFULL ///NOSFTPSTART
	if (g_externalname!="")
	{
		int risultato=external();
		if (risultato!=0)
			return risultato;
	}
#endif ///NOSFTPEND
	/*
	if (g_ismounted!="")
	{
		if (!ismounted(g_ismounted))
		{
			myprintf("01847: Abort because NOT -ismounted <<");
			printUTF8(g_ismounted.c_str());
			myprintf(">>\n");
			return 2;
		}
		myprintf("01848: yep, ismounted\n");
	}
*/
#ifdef ZPAQFULL ///NOSFTPSTART
#ifdef _WIN32
	if (flagthunderbird)
	{
		vector<string> thunfiles;
	
		for (unsigned int i=0;i<files.size();i++)
		{
			string temp=includetrailingbackslash(files[i]);
			string applocal=temp+"appdata/local/thunderbird/";
			string approaming=temp+"appdata/roaming/thunderbird/";
			if ((direxists(applocal)) && (direxists(approaming)))
			{
				thunfiles.push_back(applocal);
				thunfiles.push_back(approaming);
			}
			else
				myprintf("01849: Cannot find thunderbird\n");
			
		}
		if (thunfiles.size()==0)
		{
			myprintf("01850! Sorry, no Thunderbird folders added, quit!\n");
			return 2;
		}
		files.clear();
		for (unsigned int i=0;i<thunfiles.size();i++)
		{
			if (flagverbose)
			{
				myprintf("01851: Thunderbird folder %08d %Z\n",i,thunfiles[i].c_str());
			}
			files.push_back(thunfiles[i]);
		}
		if (flagkill)
		{
			string	filesubba	=g_gettempdirectory()+"thunkil.bat";
			filesubba=nomefileseesistegia(filesubba);
			if (fileexists(filesubba))
				if (remove(filesubba.c_str())!=0)
						error("Highlander thunkil.bat");
			FILE* subbatch=fopen(filesubba.c_str(), "wb");
			if (subbatch==NULL)
			{
				myprintf("01852: cannot write filesubba %s\n",filesubba.c_str());
				seppuku();
			}

			fprintf(subbatch,"@taskkill /f /im thunderbird.exe\n");
			fclose(subbatch);
			waitexecute(filesubba,"",SW_HIDE);
			remove_temp_file(filesubba);
		}
	}
#endif // corresponds to #ifdef (#ifdef _WIN32)
#endif ///NOSFTPEND

	if (g_ifexist!="")
	{
		if (!direxists(g_ifexist))
		{
			myprintf("01853! Abort because -ifexist <<%Z>>\n",g_ifexist.c_str());
			return 2;
		}
	}

#ifdef ZPAQFULL ///NOSFTPSTART
#ifdef unix
	if (g_dataset!="")
	{
		if (!isalpha(g_dataset[0]))
		{
			myprintf("01854! error -dataset : first char must be alpha %s\n",g_dataset.c_str());
			return 2;
		}
		if (mypos("@",g_dataset)>-1)
		{
			myprintf("01855! error -dataset : no @ allowed %s\n",g_dataset.c_str());
			return 2;
		}
		unsigned int howmanyslash=0;
		for (unsigned int i=0;i<g_dataset.size();i++)
			if (g_dataset[i]=='/')
				howmanyslash++;
		if (howmanyslash>1)
		{
			myprintf("01856! error -dataset : max one / allowed %s\n",g_dataset.c_str());
			return 2;
		}
	
		myprintf("01857: zfs dataset    %s\n",g_dataset.c_str());
		
		string dataset_path="/"+includetrailingbackslash(g_dataset);
		myreplace(dataset_path,"@","/");
		if (flagverbose)
			myprintf("01858: dataset path   |%s|\n",dataset_path.c_str());
		string topath=dataset_path+".zfs/snapshot/franco_diff/";
		if (flagverbose)
			myprintf("01859: topath         |%s|\n",topath.c_str());
				
		string	tempdiff	=g_gettempdirectory()+"tempdiff.txt";
		tempdiff=nomefileseesistegia(tempdiff);
		
		g_basesnapshot=g_dataset+"@franco_base";
		g_tempsnapshot=g_dataset+"@franco_diff";
		if (flagverbose)
		{
			myprintf("01860: Base snapshot  %s\n",g_basesnapshot.c_str());
			myprintf("01861: Temp snapshot  %s\n",g_tempsnapshot.c_str());
		}
		string 	destroy_diff1	=x_one("zfs destroy "	+g_tempsnapshot,"Destroy diff snapshot (if any)");
		string 	take_diff		=x_one("zfs snapshot "	+g_tempsnapshot,"Taking  diff snapshot");

		if (flagdebug3)
		{
			myprintf("01862: %s\n",destroy_diff1.c_str());
			myprintf("01863: %s\n",take_diff.c_str());
		}
		string	makediff="zfs diff -F "+g_basesnapshot+" "+g_tempsnapshot+" >"+tempdiff;
		if (flagdebug3)
			myprintf("01864: makediff |%s|\n",makediff.c_str());
		
		vector<string> resultlist;
		(void)x_one_vector(makediff,"Getting diff",resultlist);
		/*
		for (unsigned int i=0;i<resultlist.size();i++)
			myprintf("01865: %08d %s\n",resultlist[i].c_str());
		*/
		if (flagverbose)
		{
			myprintf("01866: Load a zfsdiff %s bytes long file <<%Z>>\n",
			migliaia(prendidimensionefile(tempdiff.c_str())),tempdiff.c_str());
		}
		vector<string> tobedeleted;
		files.clear();
		int caricati=loadzfsdiff(tempdiff,files,tobedeleted);
		myprintf("01867: zfsdiff to add %s\n",migliaia(caricati));
		
		remove_temp_file(tempdiff);
		
		if (caricati==0)
		{
			if (flagverbose)
			myprintf("01868: Nothing to do (from zfsdiff)\n");
			return 1;
		}
		myprintf("\n");
		for (unsigned int i=0;i<files.size();i++)
		{	
			myreplace(files[i],dataset_path,topath);
			if (flagverbose)
				myprintf("01869: %08d <<%s>>\n",(int)i,files[i].c_str());
		}
		tofiles.clear();
		searchfrom	=topath;
		replaceto	=dataset_path;
	}
#endif // corresponds to #ifdef (#ifdef unix)
#endif ///NOSFTPEND

	if (flagcollision)
	{
		if ((flagchecktxt) || (backuptxt!="") || (flagfasttxt))
		{
			myprintf("01870! -collision incompatible with checktxt, backuptxt, fasttxt\n");
			return 2;
		}
	}

	if (flaghashdeep && flagfilelist)
	{
		myprintf("01871: -hashdeep incompatible with -filelist, disabling -filelist and keeping -hashdeep\n");
		flagfilelist=false;
	}

	if (flagstdin)
		if (files.size()!=1)
		{
			myprintf("01872! with -stdin you must enter exactly ONE file\n");
			return 2;
		}

	if (flagparanoid && flagforce)
	{
		myprintf("01873: -paranoid and -force, disabling -paranoid and keeping -force\n");
		flagparanoid=false;
	}

	if (flagstdin && flagstdout)
	{
		flagnodedup		=true;
///		howmanythreads	=1;
	}
	if (flagvss)
	{
		if (flagnopath)
			error("incompatible -vss and -nopath");
		
		if (flagtest || flagverify)
		{ 
			for (unsigned int i=0;i<files.size();i++)
			{
				if (flagdebug3)
					myprintf("01874: start %03d %s\n",i,files[i].c_str());
				if (!isdirectory(files[i]))
					if (direxists(files[i]))
					{
						files[i]+="/";
					}
				///files[i]=get_good_filename(files[i]);
				if (flagdebug3)
					myprintf("01875: fixed %03d %s\n",i,files[i].c_str());
			}
		}
		
		
	}

#ifdef _WIN32
	char lettera=0;
#endif
	if (flagstdin)
		if (fragment!=6)
		{
			fragment=6;
			myprintf("01876: with -stdin fragment set to %d\n",fragment);
		}

#ifdef unix
		if (flagimage)
		{
			if (files.size()!=1)
			{
				myprintf("77835: imaging on *nix require ONE file (ex. /dev/sdb)\n");
				return 2;
			}
		}
#endif

#ifdef _WIN32
	int		numerodrive=-1;

	if (flagimage)
	{
		if (!isadmin())
		{
			myprintf("\n");
			myprintf("01877! you need admin rights, quit\n");
			return 2;
		}
		if (files.size()!=1)
		{
			myprintf("01878! -image requires exactly ONE drive-to-be-cloned\n");
			return 2;
		}
		string	thearchive=archive;
		string 	theunit=files[0];
		
		if (all)
		{
			if (!parsediskunit(theunit,lettera,numerodrive))
			{
				myprintf("66834! -image -all requires a letter, a letter: OR a number, number: (ex C  C:  40 3:)\n");
				return 2;
			}
		}
		else
		{
			if (theunit.size()>3)
			{
				myprintf("01879! -image requires a letter, a letter:, a letter:\\ (ex C  C:   E:\\)\n");
				return 2;
			}
			lettera=tolower(theunit[0]);
			if ((lettera < 'a') || (lettera>'z'))
			{
				myprintf("01880! -image must be in ['a'..'z']\n");
				return 2;
			}
		}
	}
#endif // corresponds to #ifdef (#ifdef _WIN32)


#ifdef _WIN32
	if (flagfindzpaq)
		if (archive!="")
		{
			if (isdospath(archive))
			{
				string filename=archive;
				DWORD unita=GetLogicalDrives();
				int 	founded		=0;
				string  filefounded ="";
				for (int i=0;i<26;i++)
				{
					filename[0]='A'+i;
					if (flagdebug3)
					{
						myprintf("01881: drive %c  %d  %Z\n",'A'+i,unita & 1,filename.c_str());
					}
					if (fileexists(filename))
					{
						founded++;
						filefounded=filename;
					}
					unita=unita >>1;
				}
				if (founded==0)
				{
					myprintf("01882! ERROR -findzpaq but archive is not found\n");
					return 2;
				}
				else
				if (founded>1)
				{
					myprintf("01883! ERROR -findzpaq but MORE THEN one archive found (%d)\n",founded);
					return 2;
				}

				if (filefounded!="")
				{
					myprintf("01884: INFO -findzpaq in %Z\n",filefounded.c_str());
					archive=filefounded;
				}
			}
			else
				myprintf("01885: WARN -findzpaq but archive is not letter:/something\n");

		}
#endif // corresponds to #ifdef (#ifdef _WIN32)

#ifdef _WIN32
	if (!flaglongpath)
		if (tofiles.size()==0)
			for (unsigned int i=0;i<files.size();i++)
				if (iswindowsunc(files[i]))
					if (!isdirectory(files[i]))
					{
						myprintf("01886: UNC files[%03d] not a folder, check for share |%s|\n",(int)i,files[i].c_str());
						vector<string> pezzi;
						explode(files[i],'/',pezzi);
						if (flagdebug3)
							for (unsigned int i=0;i<pezzi.size();i++)
								myprintf("01887: %03d |%s|\n",(int)i,pezzi[i].c_str());
						if (pezzi.size()==4)
							if (pezzi[0]=="")
								if (pezzi[1]=="")
								{
									files[i]+='/';
									myprintf("01888: added / to UNC path %03d |%s|\n",(int)i,files[i].c_str());
								}
					}
#endif // corresponds to #ifdef (#ifdef _WIN32)

#ifdef _WIN32
	if (flaglongpath)
		if (tofiles.size()==0)
		{
			if (flagdebug3)
				for (unsigned int i=0;i<files.size();i++)
					myprintf("01889: Before paths %d %s\n",(int)i,files[i].c_str());
			
/*
			for (unsigned int i=0;i<files.size();i++)
			{
				if (fileexists(files[i].c_str()))
					if (!direxists(files[i].c_str()))
					{
						myprintf("01890: -longpath gets PATH, not FILE, select A PATH! <<");
						printUTF8(files[i].c_str());
						myprintf(">>\n");
						return 1;
					}
			}
	*/		
			for (unsigned int i=0;i<files.size();i++)
				if ((!iswindowspath(files[i])) && (!iswindowsunc(files[i])))
					files[i]=relativetolongpath(files[i]);
			if (flagdebug3)
				for (unsigned int i=0;i<files.size();i++)
					myprintf("01891: After  paths %d %s\n",(int)i,files[i].c_str());
			unsigned int	howmanyshort=0;
			for (unsigned int i=0;i<files.size();i++)
				if ((!islongpath(files[i])) && (!islonguncpath(files[i])))
					howmanyshort++;
			if (flagdebug2)
				myprintf("01892: Howmanyshort %s files.size %s\n",migliaia(howmanyshort),migliaia2(files.size()));
			if (howmanyshort==files.size())
			{
				myprintf("01893: INFO: getting Windows' long filenames\n");
				if (flagdebug3)
					for (unsigned int i=0;i<files.size();i++)
						myprintf("01894: %03d From %s\n",(int)i,files[i].c_str());
				for (unsigned int i=0;i<files.size();i++)
				{
					if (iswinroot(files[i]))
					{
						if (flagdebug3)
							myprintf("01895: WINROOT  %s\n",files[i].c_str());
						char letter=files[i].front();
						char tempo[10];
						snprintf(tempo,sizeof(tempo),"%c:/",letter);
						string tobepushed=tempo;
						if (flagdebug3)
							myprintf("01896: pusho WINROOT on tofiles |%s|\n",tobepushed.c_str());
						tofiles.push_back(tobepushed);
						files[i]="//?/"+files[i];
					}
					else
					if ((fileexists(files[i])) && (!direxists(files[i])))
					{
						string maybelong=win_getlong(files[i]);
						if (maybelong=="")
						{
							myprintf("01897! sorry, cannot get -longpath for this file <<%Z>>\n",files[i].c_str());
							myprintf("01898: -longpath is... for PATH, not FILE\n");
							return 1;
						}
						string tobepushed=(files[i]);
						tofiles.push_back(tobepushed);
						if (flagdebug3)
						{
							myprintf("01899: short   |%s| to long |%s|\n",files[i].c_str(),maybelong.c_str());
							myprintf("01900: tofiles |%s|\n",tobepushed.c_str());
						}
						files[i]=maybelong;
					}	
					else
					{
						if (flagdebug3)
							myprintf("01901: NO ROOT  %s\n",files[i].c_str());

						/// some kludges for * *.*, folders etc
						if (isdirectory(files[i].c_str()))
						{
							files[i].pop_back();
							myprintf("01902: Trimmed last /  %s\n",files[i].c_str());
						}
						string thefilename=extractfilename(files[i]);
						if (flagdebug3)
							myprintf("01903: Thefilename |%s|\n",thefilename.c_str());

						if (thefilename=="*.*")
							thefilename="*";

						if (thefilename=="*")
						{
							files[i]=extractfilepath(files[i]);
							files[i].pop_back();
							myprintf("01904: Trimmed /* %s\n",files[i].c_str());
						}
						else
						{
							if (mypos("*",files[i])!=-1)
							{
								myprintf("01905: -longpath does not work with *, select A PATH!\n");
								return 1;
							}
							if (mypos("?",files[i])!=-1)
							{
								myprintf("01906: -longpath does not work with ?, select A PATH!\n");
								return 1;
							}
						}

				/// very dirty trick to get the exact "caseness"
				/// because some Windows does not like to mix
				/// z:\NS, \\?\Z:\ns\ and z:\ns
						if (flagdebug3)
							myprintf("01907: scandir %s\n",files[i].c_str());
						DTMap	myedt;
						scandir(false,myedt,files[i].c_str(),false);
						if (myedt.size()>0)
						{
							files[i]=extractfilepath(myedt.begin()->first);
							if (flagdebug3)
								myprintf("01908: files %s\n",files[i].c_str());
						}
						if (isalpha(files[i][0]))
						{
							string tobepushed=extractfilepath(files[i]);
							if (flagdebug3)
								myprintf("01909: pusho on tofiles |%s|\n",tobepushed.c_str());
							tofiles.push_back(tobepushed);
							files[i]="//?/"+files[i];
							///tofiles.push_back(files[i]);
							///files[i]="//?/"+files[i];
						}
						else
						{
					/// with UNC, you are on your own
					/// (very limited support)
							myprintf("01910$ WARNING: VERY LIMITED SUPPORT FOR UNC AND -LONGPATH\n");


							/*
							test for \\franzk\z to become \\franzk\z\
							*/
							if (!isdirectory(files[i]))
							{
								myprintf("01911: LONG UNC files[%03d] not a folder, check for share |%s|\n",(int)i,files[i].c_str());
								vector<string> pezzi;
								explode(files[i],'/',pezzi);
								if (flagdebug3)
									for (unsigned int i=0;i<pezzi.size();i++)
										myprintf("01912: %03d |%s|\n",(int)i,pezzi[i].c_str());
								if (pezzi.size()==4)
									if (pezzi[0]=="")
										if (pezzi[1]=="")
										{
											files[i]+='/';
											myprintf("01913: LONG UNC added / to path %03d |%s|\n",(int)i,files[i].c_str());
										}
							}
							tofiles.push_back(files[i]);
							files[i]="//?/UNC/"+tail(files[i],files[i].size()-2);
						}
					}
				}
				if (flagdebug3)
				{
					printbar('-');
					for (unsigned int i=0;i<tofiles.size();i++)
					{
						myprintf("01914: %03d From %s\n",(int)i,files[i].c_str());
						myprintf("01915: %03d To   %s\n",(int)i,tofiles[i].c_str());
					}
				}
			}
		}
#endif // corresponds to #ifdef (#ifdef _WIN32)

#ifdef _WIN32
	if (exists_fasttxt_ads(archive))
	{
		myprintf("01916: Founded a CRC-32 ADS, turning on fasttxt!\n");
		flagfasttxt=true;
		flagads=true;
	}
	else
	{
		if (flagdebug3)
			myprintf("01917: cannot find fasttxt-ADS on %s\n",archive.c_str());
	}
#endif // corresponds to #ifdef (#ifdef _WIN32)
	if (g_freeze!="")
	{
		if (maxsize>0)
		{
			if (fileexists(archive))
			{
				int64_t dimensionefile=prendidimensionefile(archive.c_str());
				if (dimensionefile>(int64_t)maxsize)
				{
					myprintf("01918: Freezing archive size %s vs maxsize %s\n",migliaia(dimensionefile),migliaia2(maxsize));
					string filescritto=filecopy(false,false,archive,g_freeze,true,false,false,0);
					if (filescritto!="")
					{
						myprintf("01919: Moved <<%s>> to <<%s>>\n",archive.c_str(),filescritto.c_str());
						myprintf("01920: Deleting (by -freeze) <<%s>>\n",archive.c_str());
						delete_file(archive.c_str());
					}
					else
						myprintf("01921: ERROR doing -freeze from %s to %s\n",archive.c_str(),filescritto.c_str());
				}
			}
		}
		else
			error("-freeze without -maxsize");
	}
	g_scritti				=0;
	string primalettera		="";
	string cartellalocale	="";
#ifdef ZPAQFULL ///NOSFTPSTART
	if (flagvss)
	{
#if defined(_WIN32)

///	command q is hardcoded. Why? Because it is so much simplier
/// the generic switch -vss is just about abandoned
		if (command=='q')
		{
			cartellalocale=g_franzsnap;
			if (!flagspace)
				if (direxists(cartellalocale))
				{
					myprintf("01922: abort because folder already exists %s\n",cartellalocale.c_str());
					myprintf("01923: you need to rename/delete or try -space to bypass\n");
					seppuku();
				}
		}
		char mydrive=0; // only ONE letter, only ONE VSS snapshot
		// abort for something like zpaqfranz a z:\1.zpaq c:\pippo d:\pluto -vss
		// abort for zpaqranz a z:\1.zpaq \\server\dati -vss
		// etc
		for (unsigned i=0; i<files.size(); ++i)
		{
			string temp=files[i];
			if (temp[1]!=':')
				error("VSS need X:something as path (missing :)");
			char currentdrive=toupper(temp[0]);
			if (!isalpha(currentdrive))
				error("VSS need X:something as path (X not isalpha)");
			if (mydrive)
			{
				if (mydrive!=currentdrive)
				error("VSS can only runs on ONE drive");
			}
			else
				mydrive=currentdrive;
		}
		string	fileoutput	=g_gettempdirectory()+"outputz.txt";
		string	filebatch	=g_gettempdirectory()+"vsz.bat";
		fileoutput			=nomefileseesistegia(fileoutput); // this will proliferate batch files, but they are tiny
		filebatch			=nomefileseesistegia(filebatch);
		print_datetime();
		myprintf("01924: VSS: starting\n");
		if (fileexists(fileoutput))
			if (remove(fileoutput.c_str())!=0)
					error("Highlander outputz.txt");
		if (fileexists(filebatch))
			if (remove(filebatch.c_str())!=0)
				error("Highlander vsz.bat");
		FILE* batch=fopen(filebatch.c_str(), "wb");
		if (batch==NULL)
		{
			myprintf("01925: cannot write on filebatch %s\n",filebatch.c_str());
			exit(0);
		}
		fprintf(batch,"@echo OFF\n");
		fprintf(batch,"@wmic shadowcopy delete /nointeractive\n");
		fprintf(batch,"@wmic shadowcopy call create Volume=%c:\\\n",mydrive);
		fprintf(batch,"@vssadmin list shadows >%s\n",fileoutput.c_str());
		fclose(batch);
		waitexecute(filebatch,"",SW_HIDE);
		if (!fileexists(fileoutput))
			error("VSS Output file KO");
		string globalroot="";
		char line[1024];
		FILE* myoutput=fopen(fileoutput.c_str(), "rb");
		if (myoutput==NULL)
		{
			myprintf("01926: cannot read from fileoutput %s\n",fileoutput.c_str());
			exit(0);
		}
		/* note that fgets don't strip the terminating \n (or \r\n) but we do not like it  */
		while (fgets(line, sizeof(line), myoutput))
        	if (strstr(line,"GLOBALROOT"))
			{
				globalroot=line;
				myreplaceall(globalroot,"\n","");
				myreplaceall(globalroot,"\r","");
				break;
			}
		fclose(myoutput);
		if (flagdebug2)
			myprintf("01927: Global root |%s|\n",globalroot.c_str());
///	sometimes VSS is not available
		if (globalroot=="")
			error("VSS cannot continue. Maybe impossible to take snapshot?");
		string volume="";
		int posstart=globalroot.find("\\\\");
		if (posstart>0)
			for (unsigned i=posstart; i<globalroot.length(); ++i)
				g_vss_shadow=g_vss_shadow+globalroot.at(i);
		if (flagdebug2)
			myprintf("01928: VSS VOLUME <<<%s>>>\n",g_vss_shadow.c_str());
		myreplaceall(g_vss_shadow,"\\","/");
		if (flagdebug2)
			myprintf("01929: VSS SHADOW <<<%s>>>\n",g_vss_shadow.c_str());


		if (command!='a')
		{
			string	filesubba	=g_gettempdirectory()+"subba.bat";
			filesubba=nomefileseesistegia(filesubba);
			print_datetime();
			myprintf("01930: VSS: intermediate\n");
			if (fileexists(filesubba))
				if (remove(filesubba.c_str())!=0)
						error("Highlander subba.txt");
			string 	vss_windows_style=g_vss_shadow;
			myreplaceall(vss_windows_style,"/","\\");
			if (cartellalocale=="")
			{
				myprintf("01931: cartellalocale empty\n");
				exit(0);
			}
			else
				myprintf("01932: cartellalocale %s\n",cartellalocale.c_str());

			FILE* subbatch=fopen(filesubba.c_str(), "wb");
			if (subbatch==NULL)
			{
				myprintf("01933: cannot write filesubba %s\n",filesubba.c_str());
				exit(0);
			}

			fprintf(subbatch,"@echo OFF\n");
			fprintf(subbatch,"rmdir %s\n",linuxtowinpath(cartellalocale).c_str());
			fprintf(subbatch,"mklink /d %s %s\\ \n",linuxtowinpath(cartellalocale).c_str(),vss_windows_style.c_str());
			///fprintf(subbatch,"subst %s: %s\n",primalettera.c_str(),cartellalocale.c_str());
			fclose(subbatch);
			waitexecute(filesubba,"",SW_HIDE);
			///int64_t	liberavss=getfreespace(primalettera+":");
			int64_t	liberavss=getfreespace(cartellalocale.c_str());
			///myprintf("01934: spazio libero vss %s\n",migliaia(liberavss));
			if (liberavss==0)
			{
				///myprintf("01935: something wrong preparing %s\n",primalettera.c_str());
				myprintf("01936! something wrong preparing %s\n",cartellalocale.c_str());
				return 2;
			}
		}

		if (command=='a')
		{
			if (flagdebug)
				myprintf("01937: tofiles because not q\n");
			tofiles.clear();
			for (unsigned i=0; i<files.size(); ++i)
				tofiles.push_back(files[i]);
			g_replaceme=tofiles[0].substr(0,2);
			if (flagdebug3)
				myprintf("01938: -------------- %s -------\n",g_replaceme.c_str());
			for (unsigned i=0; i<files.size(); ++i)
			{
				if (flagdebug3)
					myprintf("01939: PRE  FILES %s\n",files[i].c_str());
				myreplace(files[i],g_replaceme,g_vss_shadow);
				if (flagdebug3)
					myprintf("01940: POST FILES %s\n",files[i].c_str());
				if (strstr(files[i].c_str(), "GLOBALROOT")==0)
					error("VSS fail: strange post files");
			}
		}
		else
		{/// command q, windows c backup
			tofiles.clear();
			files.clear();
			string cartellaunix=cartellalocale;
			myreplaceall(cartellaunix,"\\","/");
			cartellaunix+="/*";
			files.push_back(cartellaunix);
		}
		if (flagdebug3)
		{
			for (unsigned i=0; i<files.size(); ++i)
				myprintf("01941: files %s\n",files[i].c_str());
			myprintf("\n");
			for (unsigned i=0; i<tofiles.size(); ++i)
				myprintf("01942: TOFILESSS %s\n",tofiles[i].c_str());
			myprintf("\n");
		}
#else
		myprintf("01943: Volume Shadow Copies runs only on Windows\n");
#endif // corresponds to #if (#if defined(_WIN32))
		print_datetime();
		myprintf("01944: VSS: end\n");
	}
#endif ///NOSFTPEND
	string ffranzotype=decodefranzoffset(g_franzotype);
	if (flagverify)
		ffranzotype+=" + CRC-32 by fragments";
	if (flagverbose)
	myprintf("01945: Integrity check type: %s\n",ffranzotype.c_str());

  // Read archive or index into ht, dt, ver.
  int errors=0;
  const bool archive_exists=exists(subpart(archive, 1));
  string arcname=archive;  // input archive name
  if (index) arcname=index;
  int64_t header_pos=0;
  if (exists(subpart(arcname, 1)))
    header_pos=read_archive(NULL,arcname.c_str(), &errors);
  // Set arcname, offset, header_pos, and salt to open out archive
  arcname=archive;  // output file name
  
  
	if (flagcomment)
		if (versioncomment!="")
		{
  			vector<DTMap::iterator> myfilelist;
			int versione=searchcomments(versioncomment,myfilelist);
			if (versione!=0)
			{
				myprintf("01946! version comment must be unique, aborting <<%s>>\n",versioncomment.c_str());
				return 2;
			}
		}

  int64_t offset=0;  // total size of existing parts
  char salt[32]={0};  // encryption salt
  
  if (g_password) 
  {
		if (flagdebug3)
			myprintf("01947: CREATING SALT____________________\n");
		if (flagdebug4)
		{
			myprintf("01948: **** BEWARE SALT NULL BECAUSE -debug4 ****\n");
			myprintf("01949: **** BEWARE SALT NULL BECAUSE -debug4 ****\n");
			myprintf("01950: **** BEWARE SALT NULL BECAUSE -debug4 ****\n");
			myprintf("01951: **** BEWARE SALT NULL BECAUSE -debug4 ****\n");
			myprintf("01952: **** BEWARE SALT NULL BECAUSE -debug4 ****\n");
			myprintf("01953: **** BEWARE SALT NULL BECAUSE -debug4 ****\n");
			myprintf("01954: **** BEWARE SALT NULL BECAUSE -debug4 ****\n");
		}
		else
			libzpaq::random(salt, 32);
  }

  
	int parts=0;  // number of existing parts in multipart
  // Remote archive
  if (index) {
    if (dcsize>0) error("index is a regular archive");
    if (version!=DEFAULT_VERSION) error("cannot truncate with an index");
    offset=header_pos+dhsize;
    header_pos=32*(g_password && offset==0);
    arcname=subpart(archive, ver.size());
    if (exists(arcname)) {
      myprintf("%Z: archive exists\n",arcname.c_str());
	  g_exec_text=arcname;
	  g_exec_text+=" archive exists";
      error("archive exists");
    }
    if (g_password)
	{  // derive archive salt from index
      FP fp=myfopen(index, RB);
      if (fp!=FPNULL)
			if (fp!=NULL) // COMPILER BE QUIET!
			{
				if (fread(salt, 1, 32, fp)!=32)
					error("cannot read salt from index");
				salt[0]^='7'^'z';
				myfclose(&fp);
				
			}
    }
  }
  // Local single or multi-part archive
	else 
	{
		string part0=subpart(archive, 0);
		///myprintf("01955: part0 %s   archive %s\n",part0.c_str(),archive.c_str());
		
		if (part0!=archive) 
		{  // multi-part?
			for (int i=1;; ++i) 
			{
				string partname=subpart(archive, i);
				if (partname==part0) error("too many archive parts");
				FP fp=myfopen(partname.c_str(), RB);
				if (fp==FPNULL) break;
				++parts;
				fseeko(fp, 0, SEEK_END);
				offset+=ftello(fp);
				if (fp!=NULL)
				{
					myfclose(&fp);
					
				}
			}
			
			header_pos=32*(g_password && parts==0);
			arcname=subpart(archive, parts+1);
			if (flagdebug3)
				myprintf("01956: archive %s arcname, parts+1 %s %d\n",archive.c_str(),arcname.c_str(),parts+1);
			if (exists(arcname)) 
				error("part exists");
			g_flagmultipart=true;

			if (!flagnotrim)
			{  
				if ((g_chunk_size>0) && (g_incomplete_version>0))
				{
					color_red();
					myprintf("69068: Cannot update a chunked-multipart with incomplete transaction\n");
					color_restore();
					return 2;
				}
/*
				if ((g_password) && (g_incomplete_version>0))
				{
					color_red();
					myprintf("69063: Cannot update an encrypted multipart with incomplete transaction\n");
					color_restore();
					return 2;
				}
*/			
				if (g_incomplete_version>0)
				{
					string pezzetto=subpart(archive,g_incomplete_version);
					color_yellow();
					myprintf("69068: Incomplete transaction #%d on <<%Z>>\n",g_incomplete_version,pezzetto.c_str());
					color_restore();
					if (g_incomplete_version!=parts)
					{
						myprintf("69071$ The incomplete part is NOT the last one %d, you need to trim\n",parts+1);
						myprintf("69072: More on https://github.com/fcorbelli/zpaqfranz/wiki/Real-world:-corruption\n");
						return 2;
					}
					string renamedchunk=pezzetto;
					forceextension(renamedchunk,".spaz");
					renamedchunk=nomefileseesistegia(renamedchunk);
					if (flagverbose)
							myprintf("69073: Renaming <<%Z>> to <<%Z>>\n",pezzetto.c_str(),renamedchunk.c_str());
					if (myrename(pezzetto,renamedchunk)!=0)
					{
						myprintf("69076$ Rename KAPUTT, cannot update a multipart-incomplete archive\n");
						myprintf("69073: More on http://somewhereovertherainbow\n");
						return 2;
					}
					arcname=subpart(archive,parts);
					if (command=='Z')
					{
						color_yellow();
						ascii::Ascii font=ascii::Ascii();
						font.print("FIXED");
						myprintf("69411$: Deleted last incomplete transaction, no backup done (run again on now-healty archive)\n");
						g_incomplete_version=0;
						return 1;
					}
					else
					{
						color_green();
						myprintf("69074: Discarded incomplete transaction on last chunk, continuing on <<%Z>>\n",arcname.c_str());
						color_restore();
						g_incomplete_version=0;
					}
				}
			}
			
			if (command=='Z') // backup
			{
				string lastpiece="";
				multipart thelastone(archive);
				lastpiece=thelastone.enumerate();
				if (flagdebug2)
					myprintf("01957: the last piece |%s|\n",lastpiece.c_str());
				if (isbackuppart(lastpiece,archive))
				{
					if (flagdebug3)
						myprintf("01958: IS backup part |%s|\n",lastpiece.c_str());
					if (prendidimensionefile(lastpiece.c_str())==0)
					{
						myprintf("01959: File length 0   |%s|\n",lastpiece.c_str());
						myprintf("01960: Delete lastpiece|%s|\n",lastpiece.c_str());
						delete_file(lastpiece.c_str());

						arcname=subpart(archive, parts);
						myprintf("01961: Going back to   |%s|\n",arcname.c_str());
					}
					else
					{
						if (flagdebug3)
							myprintf("01962: Last piece >0, do nothing  |%s|\n",lastpiece.c_str());
					}
				}
				else
				{
					if (flagdebug3)
						myprintf("01963: NOT a backup part |%s|\n",lastpiece.c_str());
				}
				string percorso=extractfilepath(part0);
				if (g_backupposition!="")
					percorso=g_backupposition;
				
				string solonome=prendinomefileebasta(part0);

				g_indexname=percorso+solonome+"_backup.index";

				myreplaceall(g_indexname,"?","0");
				index=g_indexname.c_str();

				backuptxt=percorso+solonome+"_backup.txt";
				myreplaceall(backuptxt,"?","0");
				if (flagverbose)
				{
					myprintf("01964: Backup index     : <<%Z>>\n",g_indexname.c_str());
					myprintf("01965: Backup txt       : <<%Z>>\n",backuptxt.c_str());
					if (!flagnopid)
						myprintf("01966: Pid file         : <<%Z>>\n",g_pidname.c_str());
					myprintf("01967: Multipart archive: <<%Z>>\n",arcname.c_str());
				}
				if (parts>0)
					if (!fileexists(backuptxt))
						myprintf("01968: Backup file does not exists! %Z\n",backuptxt.c_str());
			}

		} // end multipart

		// Get salt from first part if it exists
		if (g_password) 
		{
			FP fp=myfopen(subpart(archive, 1).c_str(), RB);
			if (fp==FPNULL) 
			{
				if (header_pos>32) 
					error("archive first part not found");
				header_pos=32;
			}
			else 
			{
				if (fp!=NULL)
				{
					if (fread(salt, 1, 32, fp)!=32) 
						error("cannot read salt");
					myfclose(&fp);
				}
			}
		}
	}
	
	
	if (g_flagmultipart && flagtmp)
	{
		string oldname=arcname;
		myreplace(arcname,".zpaq",".tmp");
		if (flagverbose)
			myprintf("68984$ Changed <<%Z>> to <<%Z>>\n",oldname.c_str(),arcname.c_str());
	
		//if (mypos("_00000001.tmp",arcname)==-1)
		{
			if (fileexists(arcname))
			{
				string renamedfile=arcname;
				forceextension(renamedfile,".spaz");
				renamedfile=nomefileseesistegia(renamedfile);
				
				myprintf("69687! The not-01 tmp part does exists <<%Z>> => renaming to <<%Z>>\n",arcname.c_str(),renamedfile.c_str());
				if (myrename(arcname,renamedfile)!=0)
				{
					error("69691$ Impossible to rename");
				}
			}
		}
	}
	
	g_archive=arcname; /// for multipart the last
	
	
	(void)getfileinfo(arcname,g_starting_zpaqsize,g_starting_zpaqdate,g_starting_zpaqattr);
	g_starting_indexsize=0;

	if (!flagnotrim)
		if (index)
			if (g_indexname!="")
			{
				g_starting_indexsize=prendidimensionefile(g_indexname.c_str());
				if (flagdebug3)
					myprintf("69211: g_indexname %Z size %s\n",g_indexname.c_str(),migliaia(g_starting_indexsize));
			}

	g_header_pos=header_pos;
	if (flagdebug2)
		myprintf("01969: header_pos  %s\n",migliaia(g_header_pos));

	string 	initialquickhash		="0";
	int64_t initialzpaqsize			=0;
	string	initialzpaqquick		="";
	string	initialzpaqcrc32		="";
	string	prezpaqcrc32			="";
	int64_t	prezpaqsize				=0;

	string 	indexinitialquickhash	="0";
	int64_t indexinitialzpaqsize	=0;
	string	indexinitialzpaqquick	="";
	string	indexinitialzpaqcrc32	="";
	string	indexprezpaqcrc32		="";
	int64_t	indexprezpaqsize		=0;

	if (g_password!=NULL)
		g_crc_getheader=true;
	else
		g_crc_getheader=false; //houston, we DO NOT have an header

	if(header_pos==0)
		if (g_crc_getheader)
			g_crc_getheader=false;

	if (g_header_pos>32)
		g_crc_getheader=false;

	if (flagdebug2)
		myprintf("01970: g_crc_getheader %d\n",int(g_crc_getheader));

	if (flagchecktxt)
		if (checktxt=="")
		{
			string 	percorso	=extractfilepath		(g_archive);
			string	nome		=prendinomefileebasta	(g_archive);
			checktxt			=percorso+nome+"_md5.txt";
		}





	if (flagfasttxt)
		if (fasttxt=="")
		{
			int resultzpaq=makecrc32txt(g_archive,initialquickhash,initialzpaqsize,initialzpaqquick,initialzpaqcrc32,prezpaqcrc32,prezpaqsize,fasttxt);
			if (resultzpaq!=0)
			{
				myprintf("01971: resultzpaq not zero\n");
				return resultzpaq;
			}
			if (g_indexname!="")
			{
				int resultindex=makecrc32txt(
				g_indexname,
				indexinitialquickhash,
				indexinitialzpaqsize,
				indexinitialzpaqquick,
				indexinitialzpaqcrc32,
				indexprezpaqcrc32,
				indexprezpaqsize,
				indexfasttxt);

				if (flagdebug3)
				{
					printbar('+');
					myprintf("01972: indexprezpaqcrc32 %s\n",indexinitialzpaqcrc32.c_str());
					myprintf("01973: indexprezpaqsize  %s\n",migliaia(indexprezpaqsize));
					printbar('+');
				}
				if (resultindex!=0)
				{
					myprintf("01974: resultindex not zero\n");
					return resultindex;
				}
			}
		}


  // Set method
  if (method=="") method="1";
  if (method.size()==1) {  // set default blocksize
    if (method[0]>='2' && method[0]<='9') method+="6";
    else method+="4";
  }
  if (strchr("0123456789xs", method[0])==0)
    error("-method must begin with 0..5, x, s");
  assert(method.size()>=2);
  if (method[0]=='s' && index) error("cannot index in streaming mode");
  // Set block and fragment sizes
  if (fragment<0) fragment=0;
  const int log_blocksize=20+atoi(method.c_str()+1);
  if (log_blocksize<20 || log_blocksize>31) error("blocksize must be 0..11");
  const unsigned blocksize=(1u<<log_blocksize)-4096;
  const unsigned MAX_FRAGMENT=fragment>19 || (8128u<<fragment)>blocksize-12
      ? blocksize-12 : 8128u<<fragment;
  const unsigned MIN_FRAGMENT=fragment>25 || (64u<<fragment)>MAX_FRAGMENT
      ? MAX_FRAGMENT : 64u<<fragment;
  // Don't mix streaming and journaling
  for (unsigned i=0; i<block.size(); ++i) {
    if (method[0]=='s') {
      if (block[i].usize>=0)
        error("cannot update journaling archive in streaming format");
    }
    else if (block[i].usize<0)
      error("cannot update streaming archive in journaling format");
  }
  	int64_t total_size=0;  // size of all input
#ifdef _WIN32
	HANDLE device=NULL;
#endif // corresponds to #ifdef (#ifdef _WIN32)
	g_bytescanned	=0;
	g_filescanned	=0;
	g_worked		=0;


	int64_t startscan=mtime();
	if (!flagimage)
	{
		for (unsigned i=0; i<files.size(); ++i)
		scandir(true,edt,files[i].c_str(),!flagnorecursion);
		eol();
		///printbar(' ',false);
		///myprintf("\r");
		if (flagverbose)
		{
			color_green();
			myprintf("78752: Scantime %s\n",migliaia(mtime()-startscan));
			color_restore();
		}
	}
	

/*
	if (flagonedrive)
	{
		myprintf("71251: Searching onedrive on %s files\n",migliaia(edt.size()));
		unsigned int onedrive_file=0;
		for (DTMap::iterator p=edt.begin(); p!=edt.end(); ++p)
		{
			string filename=rename(p->first);
			if (!isrealfile(filename))
			{
				myprintf("71257$ FAKE <<%Z>>\n",filename.c_str());
				onedrive_file++;
			}
			else
			{
				if (flagverbose)
					myprintf("71253: REAL <<%Z>>\n",filename.c_str());
			}
		}
		myprintf("71258: onedrive check finished, onedrive placeholders %s\n",migliaia(onedrive_file));
	///	return 0;
	}
*/
#ifdef _WIN32
	unsigned int	maxfilelength=0;
	if (!flaglongpath)
		for (DTMap::iterator p=edt.begin(); p!=edt.end(); ++p)
		{
			string filename=rename(p->first);
			if (filename.size()>maxfilelength)
				maxfilelength=filename.size();
		}
#endif // corresponds to #ifdef (#ifdef _WIN32)

	if (flagstdin || flagimage)
	{
		int i=0;
		if (flagdebug3)
		{
			for (DTMap::iterator p=edt.begin(); p!=edt.end(); ++p)
			{
				myprintf("01975: %03d  first %s\n",(int)i,p->first.c_str());
				myprintf("01976: %03d  date  %s\n",(int)i,migliaia(p->second.date));
				myprintf("01977: %03d  size  %s\n",(int)i,migliaia(p->second.size)); ///-1
				myprintf("01978: %03d  attr  %s\n",(int)i,migliaia(p->second.attr));
				myprintf("01979: %03d  data  %s\n",(int)i,migliaia(p->second.data));
				myprintf("01980: %03d  writ  %d\n",(int)i,p->second.written);
				myprintf("01981: %03d  ptrsi %s\n",(int)i,migliaia(p->second.ptr.size()));
				///myprintf("01982: %03d  dtv   %s\n",(int)i,migliaia(p->second.dtv.size()));
				i++;
			}
		}

		edt.clear();
		assert(files.size()==1);
		string solonome="";
		if (flagstdin)
			solonome=files[0];
#ifdef _WIN32	
		char	tempo[20];
#endif

#ifdef unix
		if (flagimage)
		{
			solonome=devicetoname(files[0])+".img";
			g_ioBUFSIZE = 16 * 1024 * 1024; // 16MB buffer
			myprintf("73821: DD image (buffer %s) of %Z on %s\n",tohuman(g_ioBUFSIZE),files[0].c_str(),solonome.c_str());
			if (!preparadump(files[0])) 
			{
				myprintf("78855: ERROR preparing %s (not root?)\n",files[0].c_str());
				return 2;
			}
			total_size=g_device_size;
		}	
#endif
#ifdef _WIN32
		if (flagimage)
		{
			if (flagntfs)
			{
				ntfs_ok=false;
				g_ioBUFSIZE = 16 * 1024 * 1024; // 16MB buffer
				lettera=toupper(lettera);
  
				snprintf(tempo,sizeof(tempo),"image_%c.img",lettera);
				solonome=tempo;
				//myprintf("78178: BUILDING NTFS IMAGE filename to %s\n",solonome.c_str());
				myprintf("78176: NTFS of drive %c: (buffer %s) on %Z\n",lettera,tohuman(g_ioBUFSIZE),solonome.c_str());
				
				snprintf(tempo,sizeof(tempo),"\\\\.\\%c:",lettera);
				string	letterpath=tempo;
				if (flagverbose)
					myprintf("01986: LETTER |%s|\n",letterpath.c_str());
				
				ntfs_ok=false;
				
				// Phase 1: Preparation
				if (!preparantfs("z:\\provona.img", lettera)) 
				{
					myprintf("78176: ERROR preparing NTFS (not administrator?)\n");
					return 2;
				}
				if (flagdebug)
					myprintf("78190: READY TO GO NTFS!\n");
				ntfs_ok=true;
				total_size=context.total_size;
			}
			else
			{
				snprintf(tempo,sizeof(tempo),"image_%c.img",lettera);
				solonome=tempo;

				if (all)
				{
		
				// BACKUP OF THE ENTIRE PHYSICAL DISK

					DWORD diskNumber =-1;
				
					if (numerodrive!=-1)
					{
						diskNumber = numerodrive;
						snprintf(tempo,sizeof(tempo),"image_%d.img",numerodrive);
						solonome=tempo;
					}
					else
					{
						if (flagdebug)
							myprintf("01985: finding physical disk containing partition %c:\n",lettera);
						
						// First open the volume to find the physical disk
						snprintf(tempo,sizeof(tempo),"\\\\.\\%c:",lettera);
						string volumepath=tempo;
						if (flagdebug2)
							myprintf("01986: VOLUME |%s|\n",volumepath.c_str());
						
						HANDLE volumeHandle = CreateFile(utow(volumepath.c_str()).c_str(),
											0,  // Read access not needed, only query
											FILE_SHARE_READ|FILE_SHARE_WRITE,
											NULL,
											OPEN_EXISTING,
											0,
											NULL);
						
						if (volumeHandle == INVALID_HANDLE_VALUE)
						{
							string winerror=decodewinerror(GetLastError(),volumepath.c_str());
							myprintf("01983! cannot open volume %c: error %s\n", lettera,winerror.c_str());
							return 2;
						}
						
						// Get information about the physical disk
						VOLUME_DISK_EXTENTS diskExtents;
						memset(&diskExtents, 0, sizeof(diskExtents));
						DWORD bytesReturned = 0;
						
						if (!DeviceIoControl(volumeHandle, IOCTL_VOLUME_GET_VOLUME_DISK_EXTENTS,
											NULL, 0, 
											&diskExtents, sizeof(diskExtents), 
											&bytesReturned, NULL))
						{
							string winerror=decodewinerror(GetLastError(),volumepath.c_str());
							myprintf("01982! cannot get disk extents for volume %c: error %s\n", lettera,winerror.c_str());
							CloseHandle(volumeHandle);
							return 2;
						}
						
						CloseHandle(volumeHandle);
						diskNumber = diskExtents.Extents[0].DiskNumber;
						myprintf("01988: Partition %c: is on physical disk %d\n", lettera, diskNumber);
					}
					
					string nomeunita=enumerate_physical_disks(diskNumber);
					color_green();
					myprintf("67792: FULL DRIVE %d | %s\n",diskNumber,nomeunita.c_str());
					color_restore();
					
					
					// Now open the physical disk
					snprintf(tempo,sizeof(tempo),"\\\\.\\PhysicalDrive%lu",diskNumber);
					string diskpath=tempo;
					if (flagverbose)
						myprintf("01989: opening physical disk %s (contains partition %c:)\n", diskpath.c_str(), lettera);
					
					
					device=CreateFile(utow(diskpath.c_str()).c_str(),
									GENERIC_READ,
									FILE_SHARE_READ|FILE_SHARE_WRITE,
									NULL,
									OPEN_EXISTING,
									0,
									NULL);
					
					if (device==INVALID_HANDLE_VALUE)
					{
						string winerror=decodewinerror(GetLastError(),diskpath.c_str());
						myprintf("11990! cannot open physical disk %s error %s\n", diskpath.c_str(),winerror.c_str());
						return 2;
					}
					
					if (SetFilePointer(device,0,NULL,FILE_BEGIN)==INVALID_SET_FILE_POINTER)
					{
						myprintf("21991! cannot setfilepointer on disk. Antivirus? Not administrator?\n");
						return 2;
					}
					
					// Get the size of the entire physical disk
					GET_LENGTH_INFORMATION lengthInfo;
					memset(&lengthInfo,0,sizeof(lengthInfo));
					DWORD dummy=0;
					
					if (DeviceIoControl(device,
									IOCTL_DISK_GET_LENGTH_INFO,
									NULL, 0,
									&lengthInfo, sizeof(lengthInfo),
									&dummy,
									(LPOVERLAPPED) NULL))
					{
						total_size = lengthInfo.Length.QuadPart;
						if (flagverbose)
							myprintf("31992: backing up ENTIRE PHYSICAL DISK %s containing partition %c:\n", diskpath.c_str(), lettera);
					}
					else
					{
						string winerror=decodewinerror(GetLastError(),diskpath.c_str());
						myprintf("41993! cannot get disk length for %s error %s\n", diskpath.c_str(),winerror.c_str());
						return 2;
					}
				}
				else
				{
					// BACKUP OF THE PARTITION ONLY (original code)
					myprintf("01984: REBUILDING IMAGE filename to %s (PARTITION MODE)\n",solonome.c_str());
					myprintf("01985: opening drive %c:\n",lettera);
					snprintf(tempo,sizeof(tempo),"\\\\.\\%c:",lettera);
					string	letterpath=tempo;
					if (flagdebug2)
						myprintf("01986: LETTER |%s|\n",letterpath.c_str());
					device=CreateFile(utow(letterpath.c_str()).c_str(),
									GENERIC_READ,
									FILE_SHARE_READ|FILE_SHARE_WRITE,
									NULL,                   // Security Descriptor
									OPEN_EXISTING,
									0,
									NULL);
					if (device==INVALID_HANDLE_VALUE)
					{
						string	winerror=decodewinerror(GetLastError(),letterpath.c_str());
						myprintf("01987! cannot open drive %c error %s\n", lettera,winerror.c_str());
						return 2;
					}
					if (SetFilePointer(device,0,NULL,FILE_BEGIN)==INVALID_SET_FILE_POINTER)
					{
						myprintf("01988! cannot setfilepointer. Antivirus? Not administrator?\n");
						return 2;
					}
					PARTITION_INFORMATION_EX sizeofletter;
					memset(&sizeofletter,0,sizeof(sizeofletter));
					DWORD dummy=0;
					if (DeviceIoControl(device,
									IOCTL_DISK_GET_PARTITION_INFO_EX,
									NULL, 0,
									&sizeofletter, sizeof(sizeofletter),
									&dummy,
									(LPOVERLAPPED) NULL))
					total_size=sizeofletter.PartitionLength.QuadPart;
				}

				if (!flagntfs)
				{
					if (all)
						myprintf("01994: Physical disk size %s (%s)\n",migliaia(total_size),tohuman(total_size));
					else
						myprintf("01989: Partition size %s (%s)\n",migliaia(total_size),tohuman(total_size));
				}

				if (!flagspace)
					if (total_size==0)
					{
						myprintf("01990! something wrong with size detection. Use -space to bypass\n");
						return 2;
					}
			}
					
		}
#endif // corresponds to #ifdef (#ifdef _WIN32)
		DT& d=edt[solonome];
		int64_t myora=nowutc(); // fix to store utc
	
		
		d.date=myora;
		d.creationdate=0;
		d.accessdate=0;
		d.size=4;
#ifdef _WIN32
		d.attr=8311;
		if (flagimage)
		{
			d.size		=total_size;
			total_size	=0;
		}
#else
		d.attr=8496245; //0644
		if (flagimage)
		{
			d.size		=total_size;
			total_size	=0;
		}

#endif // corresponds to #ifdef (#ifdef _WIN32)
		d.data=16777215;
		d.written=-1;
		if (flagdebug3)
		{
			printf("k2\n");
			for (DTMap::iterator p=edt.begin(); p!=edt.end(); ++p)
			{
				myprintf("01991: %03d  first %s\n",(int)i,p->first.c_str());
				myprintf("01992: %03d  date  %s\n",(int)i,migliaia(p->second.date));
				myprintf("01993: %03d  size  %s\n",(int)i,migliaia(p->second.size)); ///-1
				myprintf("01994: %03d  attr  %s\n",(int)i,migliaia(p->second.attr));
				myprintf("01995: %03d  data  %s\n",(int)i,migliaia(p->second.data));
				myprintf("01996: %03d  writ  %d\n",(int)i,p->second.written);
				myprintf("01997: %03d  ptrsi %s\n",(int)i,migliaia(p->second.ptr.size()));
				///myprintf("01998: %03d  dtv   %s\n",(int)i,migliaia(p->second.dtv.size()));
				i++;
			}
		}
	}

  // Sort the files to be added by filename extension and decreasing size
	vector<DTMap::iterator> vf;
	int64_t total_done	=0;  // input deduped so far
	int64_t total_xls	=0;
	int64_t file_xls	=0;
	int toolongfilenames=0;
	int adsfilenames	=0;
	int utf8names		=0;
	int casecollision	=0;
	int	folders			=0;
#ifdef ZPAQFULL ///NOSFTPSTART
	FILE* myoutfile		=NULL;
#endif ///NOSFTPEND
	string tempfile		="";
	

///	What is a file list? Just about a dir with redirection on a .txt
/// Why? Because I am paranoid: this is THE file list, dt must be ==
#ifdef ZPAQFULL ///NOSFTPSTART
	if (flagfilelist)
	{
		
		tempfile=g_gettempdirectory()+"VFILE-l-filelist.txt";
		myreplaceall(tempfile,"\\","/");
		myprintf("\n");
		myprintf("01999: Temp dir <<%s>>\n",tempfile.c_str());
		myoutfile=fopen(tempfile.c_str(), "wb");
		if (myoutfile)
		{
			fprintf(myoutfile,"This is filelist for version %s\n",migliaia(ver.size()));
			for (DTMap::iterator p=edt.begin(); p!=edt.end(); ++p)
			{
				string filename=rename(p->first);
				///franzreplace(filename);
				fprintf(myoutfile,"%s %19s ", dateToString(flagutc,p->second.date).c_str(), migliaia(p->second.size));
				printUTF8(filename.c_str(),myoutfile);
				fprintf(myoutfile,"\n");
			}
			fclose(myoutfile);
			int64_t dimensionelista=0;
			int64_t dimensionedata=0;
			int64_t dimensioneattr=0;
			if (getfileinfo(tempfile,dimensionelista,dimensionedata,dimensioneattr))
			{
				myprintf("02000: Uncompressed filelist size %s\n",migliaia(dimensionelista));
				addfile(false,edt,tempfile,dimensionedata,dimensionelista,dimensioneattr,0,0);
			}
		}
	}
	else
	if (flaghashdeep)
	{
		if (flagssd)
			myprintf("02001: Making the hashdeep.txt file with md5 (multithread)...\n");
		else
			myprintf("02002: Making the hashdeep.txt file with md5...\n");

		tempfile=g_gettempdirectory()+"VFILE-l-hashdeep.txt";
		myreplaceall(tempfile,"\\","/");
		if (flagverbose)
		{
			myprintf("\n");
			myprintf("02003: Temp hashdeep <<%s>>\n",tempfile.c_str());
		}
		string	oldout			=g_output;
		FILE*	oldhandle		=g_output_handle;
		bool	oldflaghashdeep	=flaghashdeep;
		bool	oldmd5			=flagmd5;
		bool	oldsilent		=flagsilent;
///		bool	oldflagssd		=flagssd;
		open_output(tempfile);
		if (g_output_handle!=NULL)
		{
			flaghashdeep	=true;
			flagmd5			=true;
			flagsilent		=true;
			summa();
			fprintf(g_output_handle,"# This is hashdeep for version %s\n",migliaia(ver.size()));
#ifdef unix		
			myfclose(&g_output_handle);
#else
			fclose(g_output_handle);
			g_output_handle=NULL;
#endif // corresponds to #ifdef (#ifdef unix		)

			int64_t dimensionelista=0;
			int64_t dimensionedata=0;
			int64_t dimensioneattr=0;
			if (getfileinfo(tempfile,dimensionelista,dimensionedata,dimensioneattr))
			{
				myprintf("02004: Uncompressed hashdeep size %s\n",migliaia(dimensionelista));
				addfile(false,edt,tempfile,dimensionedata,dimensionelista,dimensioneattr,0,0);
			}
			g_output		=oldout;
			g_output_handle	=oldhandle;
			flaghashdeep	=oldflaghashdeep;
			flagmd5			=oldmd5;
			flagsilent		=oldsilent;
		///	flagssd			=oldflag;
		}
		else
		{
			myprintf("02005! guru with output handle null\n");
			seppuku();
			return 2;
		}
	}
#endif ///NOSFTPEND





	/// we are paranoid, so ve recalc ALL the hashesh of equal-sized file
	/// just to take files that have the same size, same timestamp, but different data
	if (flagparanoid)
	{
		hashselect();
		if (flagdebug3)
		{
			myprintf("02006: ----files forced\n");
			for (DTMap::iterator p=edt.begin(); p!=edt.end(); ++p)
			{
				if (p->second.forceadd)
				{
					string filename=rename(p->first);
					myprintf("02007: forceadd %s\n",filename.c_str());
				}
			}
			myprintf("----end files forced\n");
		}
	}
	
	if (alwaysfiles.size())
	{
		if (flagdebug)
			myprintf("70125: -always with %s\n",migliaia(alwaysfiles.size()));
		
		for (DTMap::iterator p=edt.begin(); p!=edt.end(); ++p)
		{
			for (unsigned int j=0;j<alwaysfiles.size();j++)
			{
			///	myprintf("70148:    ispath %s vs %s\n",alwaysfiles[j].c_str(),p->first.c_str());
				if (ispath(alwaysfiles[j].c_str(),p->first.c_str()))
				{
					p->second.forceadd=true;
					if (flagdebug3)
						myprintf("70150: forceadd due -always on <<%Z>>\n",p->first.c_str());
				}
			}
		}
		
	}
	
	for (DTMap::iterator p=edt.begin(); p!=edt.end(); ++p)
	{
			string filename=rename(p->first);
			DTMap::iterator a=dt.find(filename);
			if (isdirectory(filename))
				folders++;
			if (strstr(filename.c_str(), ":$DATA"))
				adsfilenames++;
			if (filename.length()>255)
				toolongfilenames++;
			if (flagverbose)
				if (filename!=utf8toansi(filename))
					utf8names++;
			/// by default ALWAYS force XLS to be re-packed
			/// this is because sometimes Excel change the metadata (then SHA1 & CRC32)
			/// WITHOUT touching attr or filesize
			if (!flagdonotforcexls)
				if (isxls(filename))
				{
					if (flagdebug3)
					{
						myprintf("\n");
						myprintf("02008: ENFORCING XLS/PPT %s\n",filename.c_str());
					}
					total_xls+=p->second.size;
					file_xls++;
				}
			///	converting old 7.15 archives to zpaqfranz (aka: storing hashes) is not
			/// trivial. A very quick-and-dirty method is run TWO times
			/// zpaqfranz a z:\1.zpaq c:\dropbox -touch
			/// zpaqfranz a z:\1.zpaq c:\dropbox
			/// space and time wasted, but afterall about 10 SLOCs
			
			if (flagtouch)
				p->second.date+=1;  // just a little bit...
			if (a!=dt.end())
				a->second.data=1;  // keep
			if ((p->second.forceadd) || (
					(p->second.date) && (p->first!="") && (p->first[p->first.size()-1]!='/') &&
					(
						flagforce ||
						a==dt.end() ||
						( (!(isads(filename))) && (!flagdonotforcexls) && (isxls(filename))) ||
						p->second.date!=a->second.date ||
						p->second.size!=a->second.size
					)
				))
			{
				total_size+=p->second.size;
				// Key by first 5 bytes of filename extension, case insensitive
				int sp=0;  // sortkey byte position
				for (string::const_iterator q=p->first.begin(); q!=p->first.end(); ++q)
				{
					uint64_t c=*q&255;
					if (c>='A' && c<='Z') c+='a'-'A';
					if (c=='/') sp=0, p->second.data=0;
					else if (c=='.') sp=8, p->second.data=0;
					else if (sp>3) p->second.data+=c<<(--sp*8);
				}
				// Key by descending size rounded to 16K
				int64_t s=p->second.size>>14;
				if (s>=(1<<24)) s=(1<<24)-1;
				p->second.data+=(1<<24)-s-1;
/*
				char carattere=getspecificlevel(filename);
				if (carattere!='Z')
				{
					p->second.specificmethod=carattere;
					if (flagdebug)
					{
						myprintf("02009: Setting method |%c| for",carattere);
						printUTF8(filename.c_str());
						
					}
				}
*/			
				vf.push_back(p);
			}
	}
	if (flagdebug)
		if (menoenne>0) // zpaqfranz a ... -n 100 show top 10 files  to be added
		{
			int	dastampare=vf.size();
			if (menoenne<(unsigned int)dastampare)
					dastampare=menoenne;
			for (int i=0;i<dastampare; i++)
				myprintf("02010: PRE  %08d sort %19s |%s| |%s|\n",(int)i,migliaia(vf[i]->second.size),vf[i]->second.hexhash.c_str(),vf[i]->first.c_str());
		}
	///	Changin' the order of file, before archiving
	if (orderby.size()>0)
	{
		/// ext;size;name;hash;date;data;nilsimsa;
		g_theorderby.clear();
		if (orderby[orderby.size()-1]!=';')
			orderby+=';';
		explode(orderby,';',g_theorderby);
		if (g_theorderby.size()>0)
		{
			for (unsigned int i=0;i<g_theorderby.size();i++)
			{
				if (
					(g_theorderby[i]!="ext") &&
					(g_theorderby[i]!="nilsimsa") &&
					(g_theorderby[i]!="size") &&
					(g_theorderby[i]!="name") &&
					(g_theorderby[i]!="hash") &&
					(g_theorderby[i]!="date") &&
					(g_theorderby[i]!="data")
					)
				myprintf("\n");
				myprintf("02011$ WARNING: discarded orderby |%s|\n",g_theorderby[i].c_str());
			}
			myprintf("\n");
			myprintf("02012: Making the orderby\n");
			MAPPAFILEHASH mappacollisioni;
			int64_t starthashsort=mtime();
			int64_t	hashed=0;
			if ( std::find(g_theorderby.begin(), g_theorderby.end(), "hash") != g_theorderby.end() )
			for (unsigned i=0; i<vf.size(); i++)
			{
				DTMap::iterator p=vf[i];
				string	filename=p->first;
				g_dimensione=0;
				if (flagdebug3)
					myprintf("02013: franz_do_hash\n");

				franz_do_hash dummy(FRANZO_XXHASH64);
				if (flagdebug3)
					myprintf("02014: filehash on %s\n",filename.c_str());

				string thehash=dummy.filehash(0,filename,false,starthashsort,total_size);

				///string thehash=hash_calc_file(FRANZO_XXHASH64,filename.c_str(),false,dummycrc,starthashsort,total_size,hashed,thefilesize);
				if (thehash!="")
					p->second.hexhash=thehash;
				else
					myprintf("02015: error taking hash %s\n",filename.c_str());
			}
			if ( std::find(g_theorderby.begin(), g_theorderby.end(), "nilsimsa") != g_theorderby.end() )
			{
				myprintf("02016: Getting nilsimsa digest\n");
				for (unsigned i=0; i<vf.size(); i++)
				{
					DTMap::iterator p=vf[i];
					string	filename=p->first;
					uint32_t dummycrc=0;
					int64_t thefilesize=0;
					string thehash=mm_hash_calc_file(ALGO_NILSIMSA,filename.c_str(),false,dummycrc,starthashsort,total_size,hashed,thefilesize);
					if (thehash!="")
						p->second.hexhash=thehash;
					else
						myprintf("02017: error taking hash %s\n",filename.c_str());
				}
			}
			std::sort(vf.begin(), vf.end(), compareorderby);
		}
	}
	else
	{
		if (!flagnosort)
		{
			if (flagdebug2)
				myprintf("02018: Default sort\n");
			std::sort(vf.begin(), vf.end(), compareFilename);
		}
	}
	if (flagdebug)
		if (menoenne>0)
		{
			int	dastampare=vf.size();
			if (menoenne<(unsigned int)dastampare)
					dastampare=menoenne;
			printbar('-');
			for (int i=0;i<dastampare; i++)
				myprintf("02019: POST %08d sort %19s |%s| |%s|\n",(int)i,migliaia(vf[i]->second.size),vf[i]->second.hexhash.c_str(),vf[i]->first.c_str());
		}

///	Mmmhh... seems nothing to do. Exit early and quickly
	int removedcount=0;  // count
	if (!flagnodelete)
		for (DTMap::iterator p=dt.begin(); p!=dt.end(); ++p)
			if (p->second.date && !p->second.data)
				++removedcount;
	if (flagdebug)
		myprintf("02020: Removed count %s\n",migliaia(removedcount));
	
	if (((total_size==0) && (flagimage==false)) && (vf.size()==0) && (folders==0) && (removedcount==0))
	{
		myprintf("\n");
		myprintf("02021: QUIT: total size,file/folder count == zero. Already archived/wrong/inaccessible source?\n");
		return 0;
	}

	if (!flagspace)
		if (g_chunk_size>0)
		{
			int64_t extsize=0;
			for (DTMap::iterator p=edt.begin(); p!=edt.end(); ++p)
				if (!isdirectory(p->first))
					extsize+=p->second.size;

			int64_t maxpart=10;
			int		questioncounter=0;
			for (unsigned int i=0;i<archive.size();i++)
				if (archive[i]=='?')
				{
					maxpart*=10;
					questioncounter++;
				}
			maxpart/=10;
			maxpart--;
			int64_t freepart=maxpart-parts-1;
			if (flagdebug3)
				myprintf("02022: maxpart can be %s\n",migliaia(maxpart));
			int64_t availablepart=g_chunk_size*freepart;
			if (availablepart<extsize)
			{
				myprintf("02023: Last used part %s / max %s w/archive pattern %s\n",migliaia(parts),migliaia2(maxpart),archive.c_str());
				string frompart=itos(parts+1,questioncounter);
				string topart=itos(maxpart,questioncounter);
				
				myprintf("02024: Parts [%s-%s] %s * (-chunk) %s = %s < %s (worst-case space needed)\n",
				frompart.c_str(),topart.c_str(),
				migliaia(freepart),
				tohuman(g_chunk_size),tohuman2(availablepart),tohuman3(extsize));
				int64_t suggestedsize=(extsize/freepart);//*110/100;
				string ssuggested=tohuman(suggestedsize);
				if (flagdebug3)
					myprintf("02025: ssuggested |%s|\n",ssuggested.c_str());
				string firstpart="";
				unsigned int i=0;
				while ((i<ssuggested.size()) && (isdigit(ssuggested[i])))
					firstpart+=ssuggested[i++];
				int64_t ifirst=myatoll(firstpart.c_str())+1;
				string	rounded=itos(ifirst)+myright(ssuggested,2);
				if (flagdebug3)
				{
					myprintf("02026: first   |%s|\n",firstpart.c_str());
					myprintf("02027: ifirst  |%d|\n",ifirst);
					myprintf("02028: rounded |%s|\n",rounded.c_str());
				}
				myprintf("02029! Bigger -chunk size needed (at least %s). Use -space to bypass\n",rounded.c_str());
				return 2;
			}		
		}

	if (flagdebug3)
	{
		unsigned i=0;
		for (DTMap::iterator p=edt.begin(); p!=edt.end(); ++p)
		{
			myprintf("02030: %03d  first %s\n",(int)i,p->first.c_str());
			myprintf("02031: %03d  date  %s\n",(int)i,migliaia(p->second.date));
			myprintf("02032: %03d  size  %s\n",(int)i,migliaia(p->second.size)); ///-1
			myprintf("02033: %03d  attr  %s\n",(int)i,migliaia(p->second.attr));
			myprintf("02034: %03d  data  %s\n",(int)i,migliaia(p->second.data));
			myprintf("02035: %03d  writ  %d\n",(int)i,p->second.written);
			myprintf("02036: %03d  ptrsi %s\n",(int)i,migliaia(p->second.ptr.size()));
			///myprintf("02037: %03d  dtv   %s\n",(int)i,migliaia(p->second.dtv.size()));
			i++;
		}
	}
	if (flagstdin)
	{
#ifdef _WIN32
		setmode(0, O_BINARY);  // yes, we want binary
#endif // corresponds to #ifdef (#ifdef _WIN32)
		if (flagdebug) 
			myprintf("02038: IMPORT FROM STDIN\n");
		if (flagdebug3)
		{
			myprintf("02039: vf size %d\n",vf.size());
			for (unsigned i=0; i<vf.size(); i++)
			{
				DTMap::iterator p=vf[i];
				printf("62541: %03d  first %s\n",(int)i,p->first.c_str());
				printf("62541: %03d  date  %s\n",(int)i,migliaia(p->second.date));
				printf("62541: %03d  size  %s\n",(int)i,migliaia(p->second.size)); ///-1
				printf("62541: %03d  attr  %s\n",(int)i,migliaia(p->second.attr));
				printf("62541: %03d  data  %s\n",(int)i,migliaia(p->second.data));
				printf("62541: %03d  writ  %d\n",(int)i,p->second.written);
				printf("62541: %03d  ptrsi %s\n",(int)i,migliaia(p->second.ptr.size()));
				///printf("62541: %03d  dtv   %s\n",(int)i,migliaia(p->second.dtv.size()));
			}
		}
	}
	


			
  // Test for reliable access to archive
  if (archive_exists!=exists(subpart(archive, 1)))
    error("archive access is intermittent");


	if (!g_fakewrite)
	{
		if (exists(arcname))
		{
			myprintf("02040: Updating %Z at offset %s + %s\n",arcname.c_str(),migliaia(header_pos), migliaia2(offset));
			g_flagcreating=false;
		}
		else
		{
			myprintf("02041: Creating %Z at offset %s + %s\n",arcname.c_str(),migliaia(header_pos), migliaia2(offset));
			g_flagcreating=true;
		}

		//long-waited

		string percorso=extractfilepath(arcname);
		if (percorso!="")
		{
			if (!direxists(percorso))
				makepath(percorso);
			if (!flagspace)
				if (!saggiascrivibilitacartella(percorso))
				{
					myprintf("02042! Cannot write, use -space to bypass, on <<%Z>>\n",percorso.c_str());
					return 2;
				}
		}

		if (!flagnopid)
			if (g_pidname!="")
			{
				FILE* handlepid=fopen(g_pidname.c_str(), "ab");
				if (handlepid==NULL)
				{
					myprintf("02043! cannot append on pid %Z\n",g_pidname.c_str());
					return 2;
				}
				g_pid_handle=handlepid;
				if (g_flagcreating)
					fprintf(handlepid,"Creating backup %s\n",arcname.c_str());
				else
					fprintf(handlepid,"Updating backup %s\n",arcname.c_str());
				fclose(handlepid);
			}
	}


	if (flagdebug2)
		myprintf("02049: calling open archive %s arcname %s with offset %s\n",archive.c_str(),arcname.c_str(),migliaia(offset));
  // Open output
	OutputArchive out(archive,arcname.c_str(), g_password, salt, offset);
	if (flagdebug2)
		myprintf("02050: out on %s\n",arcname.c_str());
	
	
	int64_t initial_archive_size=header_pos;
	
	if (g_chunk_size>0)  // we have multiple output,maybe multiple in too: => sum the filesizes
	{
		InputArchive in(archive.c_str());
		initial_archive_size=in.totalsize();
		if (flagdebug3)
			myprintf("02051: After inputarchive in.totalsize() is %s\n",migliaia(initial_archive_size));
	}
	
	/// I know, we need something for a "goto-control-c"
	g_archivefp=out.getthefp();


  out.seek(header_pos, SEEK_SET);
  // Start compress and write jobs
  vector<ThreadID> tid(howmanythreads*2-1);
  ThreadID wid;
  CompressJob job(howmanythreads, tid.size(), &out);

	if (g_fakewrite)
		myprintf("02052: Processing %s (%s) in %s files (%s dirs), %d T ",migliaia(total_size), tohuman(total_size),migliaia2(int(vf.size())),migliaia3(folders),howmanythreads);
	else
	{
		if (flagstdin)
			myprintf("02053: Stdin ");
		if (flagimage)
		{
		//myprintf("02054: Image ");
		}
		else

			myprintf("02055: Add %s %9s%19s (%10s) %dT (%s dirs)",
			dateToString(flagutc,date).c_str(),migliaia2(int(vf.size())),
			migliaia(total_size), tohuman(total_size),howmanythreads,migliaia3(folders));
		fflush(stdout);
	}
	if (flagverbose)
		myprintf(": -m%s ",method.c_str());
	///myprintf("@ %s ",dateToString(flagutc,date).c_str());
	if (flagcomment)
		if (versioncomment.length()>0)
			myprintf("<<%s>>",versioncomment.c_str());
	myprintf("\n");
	if (casecollision>0)
		myprintf("02056: Case collisions       %9s (-fix255)\n",migliaia(casecollision));
	if (toolongfilenames)
	{
#ifdef _WIN32
	if (!flagvss)
		if (!flaglongpath)
			myprintf("02057$ Long filenames (>255) %9s *** WARNING *** (-fix255)\n",migliaia(toolongfilenames));
#else
	myprintf("02058: Long filenames (>255) %9s\n",migliaia(toolongfilenames));
#endif // corresponds to #ifdef (#ifdef _WIN32)
	}
	if (utf8names)
		myprintf("02059: Non-latin (UTF-8)     %9s\n",migliaia(utf8names));
	if (adsfilenames)
		myprintf("02060: ADS ($:DATA)          %9s\n",migliaia(adsfilenames));

///alpine
	if (howmanythreads==1) // houston, we are on ESXi
	{
		if (flagdebug5)
			myprintf("70169: BEWARE MONOTHREAD!\n");
		if (flagverbose)
			myprintf("02061: monothread compress\n");
	}
	else
	{
		if (flagdebug5)
			myprintf("70166: MULTITHREAD on tid.size() %d\n",tid.size());
		for (unsigned i=0; i<tid.size(); ++i)
			run(tid[i], compressThread, &job);
		run(wid, writeThread, &job);
	}
  // Append in streaming mode. Each file is a separate block. Large files
  // are split into \blocks of size blocksize.
  int64_t dedupesize=0;  // input size after dedupe

  if (howmanythreads>1)
  if (method[0]=='s') {

    StringBuffer sb(blocksize+4096-128);
    for (unsigned fi=0; fi<vf.size(); ++fi) {
      DTMap::iterator p=vf[fi];
	  if (!flagimage)
		print_progress(total_size, total_done,g_scritti,-1);
/*
	 if (summary<=0) {
        myprintf("+ ");
        printUTF8(p->first.c_str());
        myprintf(" %1.0f\n", p->second.size+0.0);
      }
	  */
	  FP in;
	  if (flagstdin)
		  in=stdin;
	  else
	  {
		  in=myfopen(p->first.c_str(), RB);
		  if (in==FPNULL) {
			printerr("16570",p->first.c_str(),0);
			total_size-=p->second.size;
			++errors;
			continue;
		  }
	  }
      uint64_t i=0;
      const int BUFSIZE=4096;
      char buf[BUFSIZE];
      while (true)
		  if (in!=NULL)
	  {
			int r;

		if (flagstdin)
		{

			r=fread(buf, 1, g_ioBUFSIZE, stdin);
			printf("Lett %d\n",r);
		}
		else
			r=fread(buf, 1, BUFSIZE, in);

        sb.write(buf, r);
        i+=r;
        if (r==0 || sb.size()+BUFSIZE>blocksize) {
          string filename="";
          string comment="";
          if (i==sb.size()) {  // first block?
            filename=rename(p->first);
            comment=itos(p->second.date);
            if ((p->second.attr&255)>0) {
              comment+=" ";
              comment+=char(p->second.attr&255);
              comment+=itos(p->second.attr>>8);
            }
          }
          total_done+=sb.size();
          job.appendz(sb, filename.c_str(), method, comment.c_str());
          assert(sb.size()==0);
        }
        if (r==0) break;
      }
	  if (in!=NULL)
		if ((!flagstdin) && (!flagimage))
			myfclose(&in);
    }
    // Wait for jobs to finish
    job.appendz(sb, 0, "");  // signal end of input
    for (unsigned i=0; i<tid.size(); ++i) join(tid[i]);
    join(wid);
    // Done
    const int64_t outsize=out.tell();
    myprintf("%1.0f + (%1.0f -> %1.0f) = %s\n",
        double(header_pos),
        double(total_size),
        double(outsize-header_pos),
        migliaia(outsize));
    out.close();
    return errors>0;
  }  // end if streaming
  // Adjust date to maintain sequential order
  if (ver.size() && ver.back().lastdate>=date) {
    const int64_t newdate=decimal_time(unix_time(ver.back().lastdate)+1);
    fflush(stdout);
    myprintf("02062$ Warning: adjusting date from %s to %s\n",
      dateToString(flagutc,date).c_str(), dateToString(flagutc,newdate).c_str());
    assert(newdate>date);
    date=newdate;
  }
  // Build htinv for fast lookups of sha1 in ht
  HTIndex htinv(ht, ht.size()+(total_size>>(10+fragment))+vf.size());
  const unsigned htsize=ht.size();  // fragments at start of update
  // reserve space for the header block

	if (flagdebug2)
	if (flagappend)
	{
		myprintf("02063: append cdatasize %s htsize %s\n",migliaia(g_cdatasize),migliaia2(g_htsize));
		myprintf("02064: g_optional |%s|\n",g_optional.c_str());
	}
	if (flagdebug2)
	{
		if (g_fakewrite)
			myprintf("02065: Fake write\n");
		else
			myprintf("02066: Real write\n");
		myprintf("02067: g_cdatasize  %s\n",migliaia(g_cdatasize));
		myprintf("02068: g_htsize     %s\n",migliaia(g_htsize));

	}
		if ((g_optional=="ransomware") && (g_cdatasize>0) && (g_htsize>0))
	{
		if (flagdebug2)
			myprintf("02069: append cdatasize %s htsize %s\n",migliaia(g_cdatasize),migliaia2(g_htsize));
/*
	string avviso="AVVISOOOOOO 41450    ";
	send(g_socket,avviso.c_str(),avviso.size(),0);
*/

		if (flagdebug3)
			myprintf("02070: writejidacheader 3\n");
    
		writeJidacHeader(&out, date, g_cdatasize, g_htsize);
	}
	 else
	{
		if (flagdebug3)
			myprintf("02071: writeJidacheader -1\n");
/*
	send(g_socket,avviso.c_str(),avviso.size(),0);
*/
		if (flagdebug3)
			myprintf("02072: writejidacheader 4\n");
		writeJidacHeader(&out, date, -1, htsize);
	}
		unsigned	files_updated=0;
		unsigned	files_added=0;
			
  const int64_t header_end=out.tell();
  // Compress until end of last file
  assert(method!="");
  StringBuffer sb(blocksize+4096-128);  // block to compress
  unsigned frags=0;    // number of fragments in sb
  unsigned redundancy=0;  // estimated bytes that can be compressed out of sb
  unsigned text=0;     // number of fragents containing text
  unsigned exe=0;      // number of fragments containing x86 (exe, dll)
  const int ON=4;      // number of order-1 tables to save
  unsigned char o1prev[ON*256]={0};  // last ON order 1 predictions
  libzpaq::Array<char> fragbuf(MAX_FRAGMENT);
  vector<unsigned> blocklist;  // list of starting fragments
	///int64_t	crckanz=0;
 // For each file to be added
 
	if (flagverbose)
		myprintf("02073: MAX_FRAGMENT %s (%s) MIN %s (%s)\n",migliaia(MAX_FRAGMENT),tohuman(MAX_FRAGMENT),migliaia2(MIN_FRAGMENT),tohuman2(MIN_FRAGMENT));
	int64_t startstream=mtime();

	if (flagstdin) // larger buffer not good
		g_ioBUFSIZE=4096;

	char *buf=(char*)franz_malloc(g_ioBUFSIZE);
	///g_allocatedram+=sizeof(g_ioBUFSIZE);

	if (buf==NULL)
	{
		myprintf("02074! GURU allocating io buf of size %s\n",g_ioBUFSIZE);
		seppuku();
		return 2;
	}
#ifdef _WIN32
	int64_t startntfs=0;
#endif
	franzfs thefranzfs;
	
///////////////////////////////////////////////////////////////
/// EXPERIMENTAL: adding newdata to "extend" zpaq format
/// without breaking compatibility
/// about useless (by now)

	string	memfilehash="";
#ifdef _WIN32
	if (flagimage && flagntfs)
	{
		if (flagverbose)
			myprintf("79013: Ready to save NTFS' bitmap\n");

		string memfilename	="image_"+std::string(1,context.lettera)+".img.dat";
		
		int64_t		memneeded=1;
		
		thefranzfs.init(memneeded);
		DT& d=edt[memfilename];
		d.creationdate		=now();
		d.accessdate		=now();
		d.date				=0; // if date !=0 ram is filled
		d.size				=memneeded; //fake, we'll init() later
		d.data				=1;
		d.attr				=8311;

		DTMap::iterator p=edt.find(memfilename);
		if (p!=edt.end())
		{
			myprintf("79123$ INFO => NTFS metadata %s\n",memfilename.c_str());
			p->second.pramfile=&thefranzfs;
			p->second.data=1;  // add in every case
			vf.push_back(p);
		}
		else
		{
			myprintf("02077: GURU cannot find MFILE-memfile %s\n",memfilename.c_str());
			seppuku();
		}
		
	}
	else
#endif
	if (flagfast)
	{
		
		char linebuffer[16384];
		int64_t		memneeded=0;

		uint64_t myseed = 0;
		XXHash64 myhash(myseed);

//		this is just a mockup
		bool firstrun=true;
		for (unsigned int j=0;j<2;j++)
			for (unsigned i=0; i<vf.size()-1; i++)
			{
				DTMap::iterator p=vf[i];
				string myfilename =p->first;
				myfilename=rename(myfilename);
				franzreplace(myfilename);
				snprintf(linebuffer,sizeof(linebuffer),"%s %19s %s\n", dateToString(flagutc,p->second.date).c_str(), migliaia(p->second.size),myfilename.c_str());
				int lunghezza=strlen(linebuffer);
				if (firstrun)
					memneeded+=lunghezza;
				else
					thefranzfs.ramwrite(thefranzfs.position,linebuffer,lunghezza);
				if (firstrun && (i==vf.size()-1-1))
				{
					firstrun=false;
					thefranzfs.init(memneeded);
					p->second.expectedsize=memneeded;
					p->second.size=memneeded;
				}
			}
		myhash.add(thefranzfs.data,memneeded);
		memfilehash=bin2hex_64(myhash.hash());
		if (flagdebug2)
			myprintf("02075: vf %s memneeded %s %s position %s\n",migliaia(vf.size()),migliaia2(memneeded),memfilehash.c_str(),migliaia3(thefranzfs.position));

		char thetimestamp[30];
		snprintf(thetimestamp,sizeof(thetimestamp),"%s",migliaia(now()));
		string memfilename	="MFILE-memfile";
		///string stimestamp	=thetimestamp;
		///memfilename			+=stimestamp;
		DT& d=edt[memfilename];
		d.creationdate		=now();
		d.accessdate		=now();
		d.date				=now();
		d.size				=memneeded; //fake
		d.data				=1;
#ifdef _WIN32
		d.attr				=8311;
#else
		d.attr				=8496245; //0644
#endif // corresponds to #ifdef (#ifdef _WIN32)

///		test we are the very last one			
		DTMap::iterator p=edt.find(memfilename);
		if (p!=edt.end())
		{
			if (flagdebug2)
				myprintf("02076: INFO => memfile %s\n",memfilename.c_str());
			p->second.pramfile=&thefranzfs;
			p->second.data=1;  // add in every case
			vf.push_back(p);
		}
		else
		{
			myprintf("02077: GURU cannot find MFILE-memfile %s\n",memfilename.c_str());
			seppuku();
		}

/*
		FP outf=fopen("z:\\iniziale",WB);
		myfwrite(thefranzfs.data,1,memneeded,outf);
		fclose(outf);
*/
		thefranzfs.seekstart();
		total_size+=memneeded;
		g_thememfilelength=memneeded;
		
		if (flagdebug2)
			myprintf("02078: ramfile ready on size %s\n",migliaia(memneeded));
	}

///////////////////////////////////////////////////////////////
#ifdef _WIN32
	int64_t		imagereaded=0;
#endif

	int64_t last_update_time = startstream; // -image
    for (unsigned fi=0; fi<=vf.size(); ++fi)
	{
		FP in=FPNULL;
		int bufptr=0, buflen=0;  // read pointer and limit
		DTMap::iterator p;
		bool flagmemfile=false;
		
		if (fi<vf.size())
		{
			assert(vf[fi]->second.ptr.size()==0);
			p=vf[fi];
			bufptr=buflen=0;
			flagmemfile=ismemfile(p->first);
			
	

			if ((!flagmemfile) 
				&& (!flagimage)
			)
			{
				if (flagstdin)
				{
					in=stdin;
					p->second.expectedsize=1;
					if (g_touch!=0)
						p->second.date=g_touch;
					
				}
				else
				{
					in=myfopen(p->first.c_str(), RB);
					if (in==FPNULL)
					{  // skip if not found
						p->second.date=0;
						total_size-=p->second.size;
		///	Houston, we got an error. Try to figure why re-opening the file (on Windows)
		/// Microsoft filesystem is so complex, better some help
						int64_t attrib=0;
#ifdef _WIN32
						attrib=getwinattributes(p->first);
#endif // corresponds to #ifdef (#ifdef _WIN32)
						printerr("add",p->first.c_str(),attrib);
						++errors;
						continue;
					}
				// get expected filesize. Slow down a bit. But I like very much
				///if (flagverbose)
					{
						fseeko(in, 0, SEEK_END);
						p->second.expectedsize=ftello(in);
						fseeko(in, 0, SEEK_SET);
					}
				}
			}
			p->second.data=1;  // add in every case
		}

/// EXPERIMENTAL: just a mockup

							
		
		int		ultimapercentuale=0;
		int		ultimotempo=0;
		// Read fragments
		int64_t fsize=0;  // file size after dedupe
		///int64_t	workedsofar=0; // -image 
		for (unsigned fj=0; true; ++fj)
		{
			int64_t sz		=0;  // fragment size;
			unsigned hits	=0;  // correct prediction count
			unsigned htptr	=0;  // fragment index
			char sha1result[20]={0};  // fragment hash
			unsigned char o1[256]={0};  // order 1 context -> predicted byte
			int c=EOF;  // current byte
			if (fi<vf.size())
			{
				int c1=0;  // previous byte
				unsigned h=0;  // rolling hash for finding fragment boundaries
				libzpaq::SHA1 sha1;
					///c:\nz\dd if="\\\\.\\c:" bs=1048576 count=100000000000 |c:\zpaqfranz\zpaqfranz a j:\image\prova cimage.img -stdin

		
				while (true)
				{
#ifdef _WIN32
					if (bufptr>=buflen)
					{
						bufptr=0;
						if (flagimage)
						{
							if (flagntfs)
							{
								if (vf[fi]->second.pramfile!=NULL)
								{
									///kammo
									
									if (vf[fi]->second.date==0)
									{
										startntfs=mtime();
										myprintf("\n");
										ULONGLONG bitmap_size = (context.metadata.total_clusters + 7) / 8;
										if (flagdebug6)
										{
											printbar('-');
											myprintf("sizeof(context.metadata)          %s\n",migliaia(sizeof(context.metadata)));
											myprintf("sizeof(context.clusters.size())   %s\n",migliaia(sizeof(context.clusters.size())));
											myprintf("clusters                          %s\n",migliaia(context.clusters.size()*sizeof(ClusterData)));
											myprintf("sizeof(bitmap)                    %s\n",migliaia(sizeof(bitmap_size)));
											myprintf("Bitmap size                       %s\n",migliaia(bitmap_size));
											printbar('-');
										}
										uint64_t memtobecompressed=
										sizeof(context.metadata)+
										sizeof(context.clusters.size())+
										context.clusters.size()*sizeof(ClusterData)+
										sizeof(bitmap_size)+
										bitmap_size;
										
										vf[fi]->second.pramfile->init(memtobecompressed);
										vf[fi]->second.pramfile->append(reinterpret_cast<const char*>(&context.metadata), sizeof(context.metadata));
										ULONGLONG temp=context.clusters.size();
										vf[fi]->second.pramfile->append((const char*)&temp,sizeof(temp));
										vf[fi]->second.pramfile->append((const char*)context.clusters.data(),context.clusters.size()*sizeof(ClusterData));
										vf[fi]->second.pramfile->append((const char*)&bitmap_size,sizeof(bitmap_size));
										vf[fi]->second.pramfile->append(reinterpret_cast<const char*>(context.bitmap_buffer.data() + sizeof(ULONGLONG)),bitmap_size);
											
										vf[fi]->second.pramfile->seekstart();
										vf[fi]->second.size=memtobecompressed;
										vf[fi]->second.date=now();
										g_thememfilelength=memtobecompressed;
										color_green();
										myprintf("79360: NTFS metadata for %s bytes\n",migliaia(memtobecompressed));
										color_restore();
									}
									buflen=vf[fi]->second.pramfile->ramread(g_ioBUFSIZE,buf);
								}
								else
								{
									//// -image -ntfs, taking sectors from NTFS drive
									int bytesletti=elaborantfs(buf,g_ioBUFSIZE);
									///printf("Letti %s massimo %s\n",migliaia(bytesletti),migliaia2(g_ioBUFSIZE));
									if (bytesletti==-1) 
									{
										myprintf("\n");
										myprintf("02923! READ FAIL (ntfs read)!!\n");
										c=EOF;
										///jidac.chiudintfs();
									}
									else
									{
										buflen=bytesletti;
										///workedsofar+=bytesletti;
									}
									
									if (!flagnoeta) 
									{
										int64_t current_time = mtime();
										if (current_time - last_update_time >= 1000) 
										{
											int secondi = (current_time - startstream) / 1000;
											if (secondi != ultimotempo) 
											{
												float percentuale=100.0*total_done/(total_size+1);
												///float percentuale = 100.0f * ntfs_processed_clusters / ntfs_total_clusters;
												float speed = secondi > 0 ? (total_done) / secondi : 0;
												ULONGLONG eta_seconds = 0;
												if (speed > 0) 
												{
													ULONGLONG bytes_remaining = total_size - total_done;
													eta_seconds = bytes_remaining / (speed );
												}
							
												int eta_hours = eta_seconds / 3600;
												int eta_minutes = (eta_seconds % 3600) / 60;
												int eta_secs = eta_seconds % 60;
							
												myprintf("06021: NTFS %06.2f%% %10s/%s =>+%12s @ %10s/s ETA %02d:%02d:%02d\r",
													   percentuale, 
													   tohuman(total_done), 
													   tohuman2(total_size),
													   tohuman3(g_fwritten),
													   tohuman4(speed), 
													   eta_hours, eta_minutes, eta_secs);
												ultimotempo = secondi;
												fflush(stdout);
												last_update_time = current_time;
											}
										}
									}
								}
							}
							else
							{
								DWORD bytesread;
								
								int bytes_to_take=g_ioBUFSIZE;
							
								if (all) // windows can disconnect a USB drive, reading too many bytes near the end. I know, it's weird, not my fault
									if ((total_size-total_done)<g_ioBUFSIZE)
										bytes_to_take=512;
									
								if (imagereaded==total_size)
								{
									bytes_to_take=0;
									c=EOF;
									if (flagdebug)
									{
										myprintf("69187: Brutally exit from image\n");
										eol();
									}
									buflen=0;
								}
									
								if (bytes_to_take>0)
								{
									if (!ReadFile(device, buf, bytes_to_take, &bytesread, NULL))
									{
										myprintf("\n");
										myprintf("02079: Read failed—may indicate either an error or normal completion\n");
										c=EOF;
										buflen=0;
									}
									else
									{
										buflen=bytesread;
										imagereaded+=bytesread;
									}
								}
								if (!flagnoeta)
								{
									int secondi=(mtime()-startstream)/1000;
									if (secondi!=ultimotempo)
									{
										float ratio=100.0*g_scritti/(total_size+1);
										float percentuale=100.0*imagereaded/(total_size+1);
										
										// Calculate ETA
										char eta_str[32] = "calculating...";
										if (secondi > 0 && imagereaded > 0)
										{
											long long remaining_bytes = total_size - imagereaded;
											long long bytes_per_second = imagereaded / secondi;
											
											if (bytes_per_second > 0)
											{
												int eta_seconds = (int)(remaining_bytes / bytes_per_second);
												int ore = eta_seconds / 3600;
												int minuti = (eta_seconds % 3600) / 60;
												int sec = eta_seconds % 60;
												
												snprintf(eta_str, sizeof(eta_str), "%02d:%02d:%02d", ore, minuti, sec);
											}
											else
											{
												snprintf(eta_str, sizeof(eta_str), "unknown");
											}
										}
										
										myprintf("02080: Imaging %06.2f%% %10s/%s -> %10s (%6.2f %%) @ %10s/s ETA %s\r",
												percentuale,tohuman(imagereaded),tohuman2(total_size),tohuman3(g_scritti),ratio,tohuman4(total_done/secondi),eta_str);
										ultimotempo=secondi;
									}
								}
							}
							
						}
						else
						{
							if (flagmemfile)
								buflen=thefranzfs.ramread(g_ioBUFSIZE,buf);
							else
							if (flagstdin)
								buflen=fread(buf,1,g_ioBUFSIZE,stdin);
							else
								buflen=fread(buf, 1, g_ioBUFSIZE, in);
						}
					}
#else
					if (bufptr>=buflen)
					{
						bufptr=0;
						
						if (flagimage)
						{
							int bytesletti=elaboradump(buf,g_ioBUFSIZE);
							if (bytesletti==-1) 
							{
								myprintf("\n");
								myprintf("02932! READ LINUX FAIL!!\n");
///								c=EOF;
							}
							else
							{
								buflen=bytesletti;
								///workedsofar+=bytesletti;
							}
									
							if (!flagnoeta) 
							{
								int64_t current_time = mtime();
								if (current_time - last_update_time >= 1000) 
								{
									int secondi = (current_time - startstream) / 1000;
									if (secondi != ultimotempo) 
									{
										float percentuale=100.0*total_done/(total_size+1);
										float speed = secondi > 0 ? (total_done) / secondi : 0;
										int eta_seconds = 0;
										if (speed > 0) 
										{
											int64_t bytes_remaining = total_size - total_done;
											eta_seconds = bytes_remaining / (int(speed));
										}
							
										int eta_hours = eta_seconds / 3600;
										int eta_minutes = (eta_seconds % 3600) / 60;
										int eta_secs = eta_seconds % 60;
							
										myprintf("06023: DD %06.2f%% %10s/%s =>+%12s @ %10s/s ETA %02d:%02d:%02d\r",
													   percentuale, 
													   tohuman(total_done), 
													   tohuman2(total_size),
													   tohuman3(g_fwritten),
													   tohuman4((int64_t)speed), 
													   eta_hours, eta_minutes, eta_secs);
												ultimotempo = secondi;
												fflush(stdout);
												last_update_time = current_time;
									}
								}
							}
						}
						else
						if (flagmemfile)
							buflen=thefranzfs.ramread(g_ioBUFSIZE,buf);
						else
						if (flagstdin)
							buflen=fread(buf,1,g_ioBUFSIZE,stdin);
						else
							buflen=fread(buf, 1, g_ioBUFSIZE, in);
					}
#endif // corresponds to #ifdef (#ifdef _WIN32)
					///	zero-length file (-debug -zero -kill)
					/// or zero-filled file (-debug -zero)
					if (flagdebug)
						if (flagzero)
						{
							if (flagkill)
								bufptr=buflen;
							else
								memset(buf,0,buflen);
						}

					if (bufptr==0)
						if (buflen>0)
							{
								if (g_franzotype>0)
									updatehash(&p,buf,buflen);
								///	this is why pre-get filesize: % of big files into global %
								if (!flagnoeta)
								{
									if (flagstdin)
									{
										total_size+=buflen;

										int secondi=(mtime()-startstream)/1000;
										if (secondi!=ultimotempo)
										{
											float ratio=100.0*g_scritti/(total_size+1);
											myprintf("02081: So far in=%10s out=%10s (ratio %8.2f %) @ %10s /s\r",tohuman(total_size),tohuman2(g_scritti),ratio,tohuman3(total_size/secondi));
											fflush(stdout);
											ultimotempo=secondi;
										}
									}
									else
									{
										if (p->second.expectedsize>100000000)
										{
											int percentuale=(int)(100.0*p->second.hashedsize/p->second.expectedsize)+1;
											int modulo=10;
											if (p->second.expectedsize>1000000000)
												modulo=1;
											if (percentuale!=ultimapercentuale)
											if (percentuale%modulo==0)
											{
												print_progress(total_size, total_done,g_scritti,ultimapercentuale);
												ultimapercentuale=percentuale;
											}
										}
									}
								}
							}

					if (bufptr>=buflen)
						c=EOF;
					else
						c=(unsigned char)buf[bufptr++];
					if (c!=EOF)
					{
						if (c==o1[c1])
							h=(h+c+1)*314159265u, ++hits;
						else
							h=(h+c+1)*271828182u;
						o1[c1]=c;
						c1=c;
						fragbuf[sz++]=c;	
					}
					if (c==EOF
						|| sz>=MAX_FRAGMENT
						|| (fragment<=22 && h<(1u<<(22-fragment)) && sz>=MIN_FRAGMENT))
						break;
				}
				
				assert(sz<=MAX_FRAGMENT);
				total_done+=sz;
		
				// Look for matching fragment
	///1			assert(uint64_t(sz)==sha1.usize());
		///		if (!flagstdin)
				sha1.write(&fragbuf[0],sz);
				memcpy(sha1result, sha1.result(), 20);
				if (flagnodedup || flagfast)
					htptr=0;
				else
					htptr=htinv.find(sha1result);
			}  // end if fi<vf.size()

	/// OK, lets RE-compute CRC-32 of the fragment, and store
	/// used for debug
			uint32_t crc=0;
			if (flagverify || flagcollision)
				if (g_franzotype>0)
				{
					crc=crc32_16bytes(&fragbuf[0],(uint32_t) sz);
					if (htptr)
					{
						ht[htptr].crc32=crc;
						ht[htptr].crc32size=sz;
					}
				}
			if (htptr==0) 
			{  // not matched or last block
				// Analyze fragment for redundancy, x86, text.
				// Test for text: letters, digits, '.' and ',' followed by spaces
				//   and no invalid UTF-8.
				// Test for exe: 139 (mov reg, r/m) in lots of contexts.
				// 4 tests for redundancy, measured as hits/sz. Take the highest of:
				//   1. Successful prediction count in o1.
				//   2. Non-uniform distribution in o1 (counted in o2).
				//   3. Fraction of zeros in o1 (bytes never seen).
				//   4. Fraction of matches between o1 and previous o1 (o1prev).
				int text1=0, exe1=0;
				int64_t h1=sz;
				unsigned char o1ct[256]={0};  // counts of bytes in o1
				static const unsigned char dt[256]=
				{  // 32768/((i+1)*204)
				  160,80,53,40,32,26,22,20,17,16,14,13,12,11,10,10,
					9, 8, 8, 8, 7, 7, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5,
					4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 3, 3, 3,
					3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
					2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
					1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
					1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
					1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
					1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
					1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1};
				for (int i=0; i<256; ++i) 
				{
					if (o1ct[o1[i]]<255) h1-=(sz*dt[o1ct[o1[i]]++])>>15;
					if (o1[i]==' ' && (isalnum(i) || i=='.' || i==',')) ++text1;
					if ((i<9 || i==11 || i==12 || (i>=14 && i<=31) || i>=240) && o1[i])
						--text1;
					if (i>=192 && i<240 && o1[i] && (o1[i]<128 || o1[i]>=192))
						--text1;
					if (o1[i]==139) ++exe1;
				}
				text1=(text1>=3);
				exe1=(exe1>=5);
				if (sz>0) h1=h1*h1/sz; // Test 2: near 0 if random.
				unsigned h2=h1;
				if (h2>hits) hits=h2;
				h2=o1ct[0]*sz/256;  // Test 3: bytes never seen or that predict 0.
				if (h2>hits) hits=h2;
				h2=0;
				for (int i=0; i<256*ON; ++i)  // Test 4: compare to previous o1.
				  h2+=o1prev[i]==o1[i&255];
				h2=h2*sz/(256*ON);
				if (h2>hits) hits=h2;
				if (hits>sz) hits=sz;
			// Start a new block if the current block is almost full, or at
			// the start of a file that won't fit or doesn't share mutual
			// information with the current block, or last file.
				bool newblock=false;
				if (frags>0 && fj==0 && fi<vf.size()) 
				{
					const int64_t esize=vf[fi]->second.size;
					const int64_t newsize=sb.size()+esize+(esize>>14)+4096+frags*4;
					if (newsize>blocksize/4 && redundancy<sb.size()/128) newblock=true;

				
					if (newblock) 
					{  // test for mutual information
						unsigned ct=0;
						for (unsigned i=0; i<256*ON; ++i)
						  if (o1prev[i] && o1prev[i]==o1[i&255]) ++ct;
						if (ct>ON*2) newblock=false;
					  }
					  if (newsize>=blocksize) newblock=true;  // won't fit?
				}
				if (sb.size()+sz+80+frags*4>=blocksize) newblock=true; // full?
				if (fi==vf.size()) newblock=true;  // last file?
				if (frags<1) newblock=false;  // block is empty?
				// Pad sb with fragment size list, then compress
				if (flagmemfile && (g_thememfileblock==""))
				{
					newblock=true;
					if (flagdebug3)
						myprintf("02082: ht.size()  %08d frags  %08d ht-frags %08d\n",ht.size(),frags,ht.size()-frags);
					g_thememfileblock	="jDC"+itos(date, 14)+"d"+itos(ht.size(),10);
					g_thememfileblock_h	="jDC"+itos(date, 14)+"h"+itos(ht.size(),10);
					if (flagdebug3)
					{
						myprintf("\n");
						myprintf("02083: thememfileblock is %s & %s |%s|\n\n",
							g_thememfileblock.c_str(),g_thememfileblock_h.c_str(),vf[fi]->first.c_str());
					}
				}
				/*
				if (fi<vf.size())
				myprintf("02084: flagmemfile %d %03d %s\n",(int)flagmemfile,fi,vf[fi]->first.c_str());
				*/
				
				if (newblock) 
				{
					assert(frags>0);
					assert(frags<ht.size());
					///uint64_t theblocksize=0;
					for (unsigned i=ht.size()-frags; i<ht.size(); ++i)
					{
						//theblocksize+=ht[i].usize;
						puti(sb, ht[i].usize, 4);  // list of frag sizes
					}
					puti(sb, 0, 4); // omit first frag ID to make block movable
					puti(sb, frags, 4);  // number of frags
					string m=method;
					if (isdigit(method[0]))
					{
						int redz=redundancy/(sb.size()/256+1);
						m+=","+itos(redz)+","+itos((exe>frags)*2+(text>frags));
				
							///m[0]='0';

					}
					
 
					string fn="jDC"+itos(date, 14)+"d"+itos(ht.size()-frags, 10);


					if (flagdebug3)
						myprintf("02087: operating on %s\n",fn.c_str());
					
					if (!flagimage)
						print_progress(total_size, total_done,g_scritti,ultimapercentuale);
					
					if (method[0]!='i')
					{
				///		printbar('+');
						if (howmanythreads>1)
						{
							/*
							if (fn==g_thememfileblock)
								m[0]='0';
							*/
///							printf("fi %d vf.size() %d\n",fi,vf.size());
#ifdef _WIN32
							if (flagimage && flagntfs)
								if (fi==(vf.size()-1))
								{
									///printf("File size %s %s\n",migliaia(vf[fi]->second.size),vf[fi]->first.c_str());
									m="36,207,0"; //packing the .dat with method 3
									///m="56,207,0"; //packing the .dat with method 3
								}
#endif
							if (flagdebug2)
								myprintf("02088: appendz %s %s \n",fn.c_str(),m.c_str());
							job.appendz(sb, fn.c_str(), m);
						}
						else
						{
			/// on "very strange things" (NAS/ESxi) the -pthread does not work
			/// this is a "monothread" compression: we need job (compressjob) for the job.csize vector
							try
							{
								string comment="jDC\x01";
								StringBuffer my_cj_in;       // uncompressed input
								StringBuffer my_cj_out;      // compressed output
								my_cj_in.swap(sb);
								libzpaq::compressBlock(&my_cj_in, &my_cj_out, m.c_str(),fn.c_str(), comment.c_str());
								job.csize.push_back(my_cj_out.size());
								if (job.out && my_cj_out.size()>0)
								{
									assert(my_cj_out.c_str());
									const char* p=my_cj_out.c_str();
									int64_t n=my_cj_out.size();
									g_scritti+=n; // very rude
									const int64_t N=1<<30;
									while (n>N)
									{
									  job.out->write(p, N);
									  p+=N;
									  n-=N;
									}
									job.out->write(p, n);
								}
							}
							catch (std::exception& e)
							{
								fflush(stdout);
								g_exec_text="job error";
								exit(1);
							}
						}

					}
					else 
					{  // index: don't compress data
						job.csize.push_back(sb.size());
						sb.resize(0);
					}
					
					assert(sb.size()==0);
					blocklist.push_back(ht.size()-frags);  // mark block start
					frags=redundancy=text=exe=0;
					memset(o1prev, 0, sizeof(o1prev));
				} // newblock
			// Append fragbuf to sb and update block statistics
				assert(sz==0 || fi<vf.size());
				sb.write(&fragbuf[0], sz);
				++frags;
				redundancy+=hits;
				exe+=exe1*4;
				text+=text1*2;
				if (sz>=MIN_FRAGMENT) 
				{
				  memmove(o1prev, o1prev+256, 256*(ON-1));
				  memcpy(o1prev+256*(ON-1), o1, 256);
				}
			}  // end if frag not matched or last block
		  // Update HT and ptr list
			if (fi<vf.size())
			{
				if (htptr==0) 
				{
					htptr=ht.size();
					ht.push_back(HT(sha1result, sz));
					htinv.update();
					fsize+=sz;
				}
				vf[fi]->second.ptr.push_back(htptr);
		///OK store the crc. Very dirty (to be fixed in future)
				//crckanz++;
				///crc=crc32_16bytes(&fragbuf[0],(uint32_t) sz);
				if (flagverify || flagcollision)
					if (g_franzotype>0)
					{
						ht[htptr].crc32=crc;
						ht[htptr].crc32size=sz;
					}
			}
			if (c==EOF) break;
		}  // end for each fragment fj

		if (fi<vf.size())
		{
			dedupesize+=fsize;
			DTMap::iterator p=vf[fi];
			string newname=rename(p->first.c_str());
			DTMap::iterator a=dt.find(newname);
			if (a==dt.end() || a->second.date==0) 
			{
				p->second.filework=WORK_ADDED;
				files_added++;
				if (flagdebug3)
					myprintf("02089: added newname %s\n",newname.c_str());
			}
			else 
			{
				p->second.filework=WORK_UPDATED;
				files_updated++;
				if (flagdebug3)
					myprintf("02090: $$$$$$$$$$$$$ updated newname %s\n",newname.c_str());
			}
	  
			print_progress(total_size, total_done,g_scritti,ultimapercentuale);
			if (!flagmemfile)
#ifdef _WIN32
			if ((!flagstdin) )
#else
			if (!flagstdin)
#endif // corresponds to #ifdef (#ifdef _WIN32)
			myfclose(&in);
			
		}
	}  // end for each file fi


	assert(sb.size()==0);
	if (howmanythreads>1)
	{
	// Wait for jobs to finish, NOT on ESXi
		job.appendz(sb, 0, "");  // signal end of input
		for (unsigned i=0; i<tid.size(); ++i) join(tid[i]);
			join(wid);
	}
	
	
	// Open index
	salt[0]^='7'^'z';
	OutputArchive outi(archive,index ? index : "", g_password, salt, 0);
	
	WriterPair wp;
	wp.a=&out;
	if (index) wp.b=&outi;
/*
	string avviso="AVVISOOOOOO 41904    ";
	send(g_socket,avviso.c_str(),avviso.size(),0);
*/
	if (flagdebug3)
		myprintf("02091: writejidacheader 5\n");
    
	writeJidacHeader(&outi, date, 0, htsize);
	// Append compressed fragment tables to archive
	int64_t cdatasize=out.tell()-header_end;
	int64_t thecdatasize=out.tellwritten()-header_end;
	if (flagdebug3)
	{
		myprintf("02092: out.tell      %s\n",migliaia(out.tell()));
		myprintf("02093: header_end    %s\n",migliaia(header_end));
		myprintf("02094: cdatasize     %s\n",migliaia(cdatasize));
		myprintf("02095: thecdatasize  %s\n",migliaia(thecdatasize));	
	}
	if (g_chunk_size>0)
		cdatasize=thecdatasize;
	
	StringBuffer is;
	assert(blocklist.size()==job.csize.size());
	blocklist.push_back(ht.size());
	for (unsigned i=0; i<job.csize.size(); ++i)
	{
		if (blocklist[i]<blocklist[i+1])
		{
			puti(is, job.csize[i], 4);  // compressed size of block
			for (unsigned j=blocklist[i]; j<blocklist[i+1]; ++j)
			{
				is.write((const char*)ht[j].sha1, 20);
				puti(is, ht[j].usize, 4);
			}
			if (flagfast)
			{
				g_thememfilefragend=blocklist[i+1];
				///myprintf("02096: g_themenend  %s\n",migliaia(g_thememfilefragend));
				string hblockname=("jDC"+itos(date, 14)+"h"+itos(blocklist[i], 10)).c_str();
				///myprintf("02097: hblockname _h  %s  %s @ |%s|\n",hblockname.c_str(),g_thememfileblock_h.c_str(),migliaia(out.tell()));
				if (hblockname==g_thememfileblock_h)
				{
					if (g_thememfilestart_h==0)
					{
						g_thememfilestart_h=out.tell();
						g_thememfilefragstart=blocklist[i];
					}
					if (flagdebug3)
						myprintf("02098: Fastlist %09d %09d _h %s %s\n",g_thememfilefragstart,g_thememfilefragend,migliaia(g_thememfilestart_h),hblockname.c_str());
				}
			}			
			libzpaq::compressBlock(&is, &wp, "0",("jDC"+itos(date, 14)+"h"+itos(blocklist[i], 10)).c_str(),"jDC\x01");

			is.resize(0);
		}
	}
	
#ifdef _WIN32
	int64_t start_iblock=out.tell();
#endif  // corresponds to #ifdef (#ifdef _WIN32)
  // Delete from archive
	int dtcount=0;  // index block header name
	int removed=0;  // count
	
	if (flagnodelete)
		myprintf("70125$ -nodelete active, IT IS UP TO YOU TO HANDLE FILENAME COLLISIONS!\n");
	else
	{
		for (DTMap::iterator p=dt.begin(); p!=dt.end(); ++p)
			if (p->second.date && !p->second.data)
			{
				puti(is, 0, 8);
				is.write(p->first.c_str(), p->first.size()); //strlen(p->first.c_str()));
				is.put(0);
				++removed;
				p->second.filework=WORK_REMOVED;
				if (is.size()>16000)
				{
					libzpaq::compressBlock(&is, &wp, "1",("jDC"+itos(date)+"i"+itos(++dtcount, 10)).c_str(), "jDC\x01");
					is.resize(0);
				}
			}

	}
  // Append compressed index to archive
	int added			=0;  // count
#ifdef unix
	int	goodmetadata	=0;
	int badmetadata		=0;
#endif
	for (DTMap::iterator p=edt.begin();; ++p)
	{
		if (p!=edt.end())
		{
			string filename=rename(p->first);
			int fileaggiunto=p->second.filework;
			
			if (flagnodelete)
				if (fileaggiunto==WORK_UPDATED)
					myprintf("70156! *** UPDATED FILE with -nodelete *** <<%Z>>\n",filename.c_str());
				
			
			if (flagdebug3)
			{
				if (fileaggiunto==WORK_NONE)
					myprintf("02099: file ignorato   %d %s\n",fileaggiunto,filename.c_str());
				else
				if (fileaggiunto==WORK_ADDED)
					myprintf("02100: file aggiunto   %d %s\n",fileaggiunto,filename.c_str());
				else
				if (fileaggiunto==WORK_UPDATED)
					myprintf("02101: file aggiornato %d %s\n",fileaggiunto,filename.c_str());
			}
			/// Fix longpath on VSS ( reference the addfile() )
			///	hardcoded, do you like it?
			if (command=='q')
				myreplace(filename,g_vss_shadow,g_franzsnap);
			franzreplace(filename);
///			by using FRANZOFFSETV1 we need to cut down the attr during this compare
			DTMap::iterator a=dt.find(filename);
			if (p->second.date && (a==dt.end() // new file
			|| a->second.date!=p->second.date  // date change
			|| ((int32_t)a->second.attr && (int32_t)a->second.attr!=(int32_t)p->second.attr)  // attr ch. get less bits
			|| a->second.size!=p->second.size  // size change
			|| (p->second.data && a->second.ptr!=p->second.ptr)))
			{
				if (p->second.pramfile!=NULL)
				{
					if (flagdebug3)
						myprintf("02102: ************************MEMFILE FIXING\n");
					///filename+=":$DATA";
				}
				
///				we want to strip the path of VLIST
				if (mypos("VFILE-",filename)>-1)
				{
					myprintf("\n");
#ifdef _WIN32
					myreplaceall(filename,"\\","/");
#endif // corresponds to #ifdef (#ifdef _WIN32)
					filename=extractfilename(filename);
					myprintf("02103: We get a VFILE %s\n",filename.c_str());
				
				}
				
				
				if (command=='a')
					if (flagvss)
					{
						if (flagdebug3)
						{
							myprintf("02104: pre filename     %s\n",filename.c_str());
							myprintf("02105: pre g_franzsnap  %s\n",g_franzsnap.c_str());
							myprintf("02106: pre g_vss_shadow %s\n",g_vss_shadow.c_str());
						}
						myreplace(filename,g_vss_shadow,g_franzsnap);
						if (flagdebug)
							myprintf("02107: sanitized vss    %s\n",filename.c_str());
					}

				
				uint32_t currentcrc32=0;
				if (flagverify || flagcollision)
				{
					for (unsigned i=0; i<p->second.ptr.size(); ++i)
						currentcrc32=crc32_combine(currentcrc32, ht[p->second.ptr[i]].crc32,ht[p->second.ptr[i]].crc32size);
					if (currentcrc32!=p->second.file_crc32)
						myprintf("02108: SOMETHING WRONG ON %s\n",p->first.c_str());
				}
				
				++added;
///				date and filename
				puti(is, p->second.date, 8);
				is.write(filename.c_str(), filename.size());//strlen(filename.c_str()));
				is.put(0);

				string 	hashtobewritten	="";
				string	hasherror		="";
				string 	hashname		="";


				///if (!isdirectory(p->first.c_str())) winhash!
				///if (!ismemfile(filename))
					if (!(flagdebug && flagzero && flagkill))
				{

///				zpaqfranz: write hashes and/or CRC-32
					if (g_franzotype==FRANZO_CRC_32) /// store only CRC-32
					{
						if (flagdebug3)
							myprintf("02109: Mode1: CRC32 by frag <<%08X>> for %s\n",currentcrc32,p->first.c_str());
					}
					else
					if (g_franzotype==FRANZO_XXHASH64)
						hashtobewritten=finalizza_xxhash64(p->second.pfile_xxhash64);
					else
					if (g_franzotype==FRANZO_WINHASH64)
						hashtobewritten=finalizza_xxhash64(p->second.pfile_xxhash64);
					else
					if (g_franzotype==FRANZO_XXHASH64B)
					{
						///myprintf("02110: finalizzo binary\n");
						hashtobewritten=finalizza_xxhash64(p->second.pfile_xxhash64);
					}
					else
					if (g_franzotype==FRANZO_SHA_1)
						hashtobewritten=finalizza_sha1(p->second.pfile_sha1);
					else
					if (g_franzotype==FRANZO_SHA_1B)
						hashtobewritten=finalizza_sha1(p->second.pfile_sha1);
					else
					if (g_franzotype==FRANZO_SHA_256)
						hashtobewritten=finalizza_sha256(p->second.pfile_sha256);
					else
					if (g_franzotype==FRANZO_SHA_256B)
						hashtobewritten=finalizza_sha256(p->second.pfile_sha256);
					else
					if (g_franzotype==FRANZO_WHIRLPOOL)
						hashtobewritten=finalizza_whirlpool(p->second.pfile_whirlpool);
					else
					if (g_franzotype==FRANZO_HIGHWAY64)
						hashtobewritten=finalizza_highway64(p->second.pfile_highway64);
					else
					if (g_franzotype==FRANZO_HIGHWAY128)
						hashtobewritten=finalizza_highway128(p->second.pfile_highway64);
					else
					if (g_franzotype==FRANZO_HIGHWAY256)
						hashtobewritten=finalizza_highway256(p->second.pfile_highway64);
					else
					if (g_franzotype==FRANZO_BLAKE3)
						hashtobewritten=finalizza_blake3(p->second.pfile_blake3);
					else
					if (g_franzotype==FRANZO_BLAKE3B)
						hashtobewritten=finalizza_blake3(p->second.pfile_blake3);
					else
					if (g_franzotype==FRANZO_SHA3)
						hashtobewritten=finalizza_sha3(p->second.pfile_sha3);
					else
					if (g_franzotype==FRANZO_SHA3B)
						hashtobewritten=finalizza_sha3(p->second.pfile_sha3);
					else
					if (g_franzotype==FRANZO_MD5) 
						hashtobewritten=finalizza_md5(p->second.pfile_md5);
					else
					if (g_franzotype==FRANZO_MD5B)
					{
						///myprintf("Finalizzo MD5b\n");
						hashtobewritten=finalizza_md5(p->second.pfile_md5);
					}
					else
					if ((g_franzotype==FRANZO_XXH3)||(g_franzotype==FRANZO_XXH3B))
						hashtobewritten=finalizza_xxh3(p->second.pfile_xxh3);
					else
					{
						if (g_franzotype!=FRANZO_NONE)
							myprintf("02111: Sorry, unknown g_franzotype %d\n",g_franzotype);
					}
					MAPPATIPOHASH::iterator a=g_mappatipohash.find(g_franzotype);
					if (a!=g_mappatipohash.end())
					{
						hashname	=a->second.hashname;
						hasherror	=a->second.hasherror;
						p->second.hashtype=hashname;
					}

					if (flagdebug3)
					{
						myprintf("02112: |%s|: |%s| <<%s>>\n",hashname.c_str(),hashtobewritten.c_str(),p->first.c_str());
						myprintf("02113: p->second.size       %21s\n",migliaia(p->second.size));
						myprintf("02114: p->second.hashedsize %21s\n",migliaia(p->second.hashedsize));
					}
					///	intercept (some) strange things, enforcing a fake hash (will be reported on verify of course)
					if (hashtobewritten!="")
					{
						
						p->second.hexhash=hashtobewritten;
						if ((p->second.size!=p->second.hashedsize) && (p->second.hashedsize==0))
						{
						
							if (!flagvss && (!flagstdin))
							{
								myprintf("02115: ERROR expected %19s getted 0 bytes  %Z\n",migliaia(p->second.size),filename.c_str());
								if (flagdebug3)
								{
									myprintf("02116: p->second.size       %21s\n",migliaia(p->second.size));
									myprintf("02117: p->second.hashedsize %21s\n",migliaia(p->second.hashedsize));
								}
							}
							hashtobewritten=hasherror;
						}
						else
						if (p->second.size!=p->second.hashedsize)
						{
				
							if ((!flagvss) && (!flagstdin) && (!flagfast) && (!flagquiet) && (!flagignore)
#ifdef _WIN32
								&& (!flagimage)
#endif // corresponds to #ifdef (#ifdef _WIN32)
							)
							{
								myprintf("02118$ WARN expected %19s getted %19s for %Z\n",migliaia(p->second.size),migliaia2(p->second.hashedsize),filename.c_str());
							}
						}
					}
					
				}
//					int		filework; //0 = nothing; 1=updated; 2=added

				///myprintf("02119: hastobewritten ............. %s %s |%08X|\n",p->first.c_str(),hashtobewritten.c_str(),p->second.file_crc32);
				

				struct franz_posix* themetadata=NULL;
#ifdef unix
				struct franz_posix metadata;
				if (flagtar)
				{
					if (flagdebug5)
					{
						printbar('*');
						myprintf("79600: Running flagtar, getting posix %Z\n",p->first.c_str());
					}
					
					if (savefilemetadata(p->first.c_str(), &metadata) == 0)
					{
						if (flagverbose)
						{
							color_green();
							myprintf("79608: GOOD metadata for %Z\n",p->first.c_str());
							color_restore();
						}
						themetadata=&metadata;
						goodmetadata++;
					}
					else
					{
						myprintf("79531! Cannot get metadata for %Z\n",p->first.c_str());
						badmetadata++;
					}
				}
#endif	

				if ((flagnoattributes) && (!flag715))
				{
#ifdef _WIN32
					writefranzattr(p,is,p->second.attr,5,filename,currentcrc32,p->second.file_crc32,hashtobewritten,p->second.creationdate,p->second.accessdate,themetadata,p->second.filework==WORK_ADDED);
#else
					writefranzattr(p,is,p->second.attr,3,filename,currentcrc32,p->second.file_crc32,hashtobewritten,p->second.creationdate,0,themetadata,p->second.filework==WORK_ADDED);
#endif
				}
				else
				{
					if ((p->second.attr&255)=='u')
							writefranzattr(p,is,p->second.attr,3,filename,currentcrc32,p->second.file_crc32,hashtobewritten,p->second.creationdate,0,themetadata,p->second.filework==WORK_ADDED);
					else
					if ((p->second.attr&255)=='w')
					{
							///myprintf("02120: WINDOWS writefranz attr |%s|\n",hashtobewritten.c_str());
							writefranzattr(p,is,p->second.attr,5,filename,currentcrc32,p->second.file_crc32,hashtobewritten,p->second.creationdate,p->second.accessdate,themetadata,p->second.filework==WORK_ADDED);
					}
					else
						puti(is, 0, 4);  // no attributes
				}



				if (a==dt.end() || p->second.data)
					a=p;  // use new frag pointers
				puti(is, a->second.ptr.size(), 4);  // list of frag pointers
				for (unsigned i=0; i<a->second.ptr.size(); ++i)
					puti(is, a->second.ptr[i], 4);
			}
		}
		else
		{
			if (versioncomment.length()>0)
			{
/// quickly store a fake file (for backward compatibility) with the version comment
				///VCOMMENT 00000002 seconda_versione:$DATA
				string	versioni8=myulltoa(ver.size(),8);

				string fakefile="VCOMMENT "+versioni8+" "+versioncomment+":$DATA"; //hidden windows file
				puti(is, 0, 8); // this is the "date". 0 is good, but do not pass paranoid compliance test. damn
				is.write(fakefile.c_str(), fakefile.size()); ///strlen(fakefile.c_str()));
				is.put(0);
			///	puti(is, 0, 4);  // no attributes
			///	puti(is, 0, 4);  // list of frag pointers
			}
		}
		if (is.size()>16000 || (is.size()>0 && p==edt.end()))
		{
			libzpaq::compressBlock(&is, &wp, "1",
				("jDC"+itos(date)+"i"+itos(++dtcount, 10)).c_str(), "jDC\x01");
			is.resize(0);
		}
		if (p==edt.end())
			break;
	}
	printbar(' ',false);
	myprintf("\r");
	
	if (flagwriteonconsole)
	{
		fprintf(stderr,"\r");
		fprintf(stderr,"                                                                 \r");
	}

	if (flagfast)
	{
		if (flagverbose)
			myprintf("02121: -fast enabled, creating index!\n");
		is.resize(0);
		string franzpointer="filelistpointer:"+itos(g_thememfilestart)+"|"+itos(g_thememfilelength)+"|"+itos(g_thememfilestart_h)+"|"+itos(g_thememfilefragstart)+"|"+itos(g_thememfilefragend)+"|"+itos(ver.size())+"|XXHASH:"+memfilehash+"|"+g_thememfileblock;
		puti(is, 0, 8);
		is.write(franzpointer.c_str(),franzpointer.size());
		is.put(0);
		libzpaq::compressBlock(&is, &wp, "1",("jDC"+itos(date)+"i"+itos(++dtcount, 10)).c_str(), "jDC\x01");
		is.resize(0);
	}
	
	if (!g_fakewrite)
		if (!flagstdin)
		{
#ifdef unix
			if (flagtar)
			{
				if (badmetadata>0)
					color_yellow();
				myprintf("02123: %s +added, %s -removed, %s good metadata, %s bad metadata.\n", migliaia(added), migliaia2(removed),migliaia3(goodmetadata),migliaia4(badmetadata));
				color_restore();
			}
			else
#endif
				myprintf("02122: %s +added, %s -removed.\n", migliaia(added), migliaia2(removed));
		}
	assert(is.size()==0);
  // Back up and write the header
	outi.close();
	int64_t archive_end=out.tell();
	if (flagdebug3)
		myprintf("02123: calculated **** %s %s\n",migliaia(cdatasize),migliaia2(htsize));

	if ((g_optional=="ransomware") && (g_cdatasize==0) && (g_htsize==0))
	{
		if (flagdebug3)
			myprintf("02124: calculated cdatasize %s  htsize %s\n",migliaia(cdatasize),migliaia2(htsize));
		g_cdatasize	=cdatasize;
		g_htsize	=htsize;
	}
	else
	{

		if (flagdebug3)
			myprintf("02125: writeJidacHeader last cdata %s htsize %s header_pos %s\n",migliaia(cdatasize),migliaia2(htsize),migliaia3(header_pos));
		///g_skipsocket=true;
		///string avviso="AVVISOOOOOO 42192     ";
		///send(g_socket,avviso.c_str(),avviso.size(),0);
		if (g_chunk_size>0)
		{
			if (flagdebug3)
				myprintf("02126: fix the jidacheader\n");
			out.flush(); //this is fundamental!
			g_write_on_first	=true;
			g_write_on_seek		=header_pos;
			if (g_password!=NULL)
			{
				if (out.firstchunk)
				{
					if (flagdebug3)
						myprintf("02127: firstchunk cdatasize %s +32 %s\n",migliaia(cdatasize),migliaia2(cdatasize+32));
					cdatasize+=32;
				}
			}
			if (flagdebug3)
				myprintf("02128: writejidacheader 7 (finale,chunk) header_pos %s cdatasize %s htsize %s\n",migliaia3(header_pos),migliaia(cdatasize),migliaia(htsize));
			writeJidacHeader(&out, date, cdatasize, htsize);
		}
		else
		{
			if (flagdebug3)
			{
				myprintf("02129: writejidacheader 6 (finale,stand) header_pos %s cdatasize %s htsize %s\n",migliaia3(header_pos),migliaia(cdatasize),migliaia(htsize));
				myprintf("02130: out.seek SEEK_SET at header_pos %s\n",migliaia(header_pos));
			}
			out.seek(header_pos, SEEK_SET);
#ifdef ZPAQFULL ///NOSFTPSTART
			g_franzen_jidacheader=header_pos;
#endif ///NOSFTPEND
			writeJidacHeader(&out, date, cdatasize, htsize);
			if (flagdebug3)
				myprintf("02131: preflush\n");
			out.flush(); //this is fundamental!
			if (flagdebug3)
				myprintf("02132: postflush\n");
			out.seek(0, SEEK_END);
			if (flagdebug3)
				myprintf("02133: postseek\n");
		}
	}
	int64_t archive_size=out.tell();


	out.close();
	
	if (g_chunk_size>0)
	{
		if (flagdebug3)
			myprintf("02134: old archive_size %s\n",migliaia(archive_size));
		archive_size=out.tellwritten();
		if (flagdebug3)
			myprintf("02135: new archive_size %s\n",migliaia(archive_size));
	}
	
	

	if (!flagnotrim)
		if (index)
			if (g_flagmultipart)
				if ((files_added+files_updated+removed)==0)
					if (prendidimensionefile(arcname.c_str())==104)
					{
						if (flagdebug3)
							myprintf("71409: multipart on %s size of %s\n",arcname.c_str(),migliaia(prendidimensionefile(arcname.c_str())));
						int64_t  currentindexsize=prendidimensionefile(g_indexname.c_str());
						int64_t	 deltasize=currentindexsize-g_starting_indexsize;
						if (flagdebug3)
						myprintf("71412: starting g_indexname %Z index %s current %s delta %s\n",g_indexname.c_str(),migliaia(g_starting_indexsize),migliaia2(currentindexsize),migliaia3(deltasize));
						if (deltasize==104)
						{
							if (truncate(g_indexname.c_str(),currentindexsize-104)==0)
							{
								if (flagdebug3)
									myprintf("71415: Index truncated OK!\n");
								if (delete_file(arcname.c_str()))
								{
									if (flagverbose)
										myprintf("71420: Empty chunk deleted %Z\n",arcname.c_str());
								}
								else
									myprintf("72145: Cannot delete_file <<%Z>>\n",arcname.c_str());
							}
							else
							{
								myprintf("71426! Cannot truncate index <<%Z>>\n",g_indexname.c_str());
							}
						}
					}
	
  // Truncate empty update from archive (if not indexed)
	if (!index)
	{
		if (g_chunk_size>0)
		{
			if (flagverbose)
			{
				printbar('-');
				for (unsigned int i=0;i<out.filepartnames.size();i++)
					myprintf("02136: Chunk %08d %21s %s\n",i+1,migliaia(prendidimensionefile(out.filepartnames[i].c_str())),out.filepartnames[i].c_str());
				printbar('=');
			}
			string thelast=out.lastfilename();
			myprintf("02137: INFO: The last chunk is: %Z\n",thelast.c_str());
			
			if (prendidimensionefile(thelast.c_str())==0)
			{
				if (delete_file(thelast.c_str()))
				{
					myprintf("02138: deleted %Z : no data to be keeped\n",thelast.c_str());
					
				}
			}
			else
			{
				myprintf("79143: Touching last piece\n");
				if (!filetouchnow(thelast.c_str()))
					myprintf("79148! Cannot filetouchnow last piece %Z\n",thelast.c_str());
				
			}
			if (flagdebug3)
				myprintf("02139: thecdatasize %21s\n",migliaia(thecdatasize));
			
		}
		else //default, not chunked
		{
			if (flagdebug3)
				myprintf("02140: arcname %s\n",arcname.c_str());
			
			
			if ((files_added+files_updated+removed)==0 && archive_end-header_pos==104) // no update
				archive_end=header_pos;

			if ((archive_end<archive_size) && (g_chunk_size==0))
			{
				if (archive_end>0)
				{
					if (flagverbose)
						myprintf("02141: truncating archive from %s to %s\n",migliaia(archive_size), migliaia2(archive_end));
					if (truncate(arcname.c_str(), archive_end))
						printerr("trunc",archive.c_str(),0);
					if (fasttxt!="")
					{
						myprintf("02142: Turning off fasttxt due to truncation [archive not changed]\n");
						flagfasttxt=false; // we do not want to update CRC-32!
						fasttxt="";
					}
					
///					myprintf("0000000000000000000000000000 %s\n",migliaia(g_starting_zpaqdate));
					if (g_starting_zpaqdate>0)
					{
						if (flagverbose)
							myprintf("02143: touching back to %s\n",dateToString(false,g_starting_zpaqdate).c_str());
						if (!touch(arcname.c_str(),g_starting_zpaqdate,g_starting_zpaqattr))
							myprintf("02144$ WARNING trouble in touching\n");
					}
				}
				else
				if (archive_end==0)
				{
					if (delete_file(arcname.c_str()))
						if (flagverbose)
						{
							myprintf("02145: deleted %Z: no data to be archived\n",arcname.c_str());
						}
				}
			}
		}
	}
	fflush(stdout);

  
	if (archive_end) //sometimes the unencrypted .zpaq is empty
	{
		if (flagverbose)
			if (total_xls)
					myprintf("02146: Forced XLS/PPT has included %s bytes in %s files\n",migliaia(total_xls),migliaia2(file_xls));
	
		int64_t speed=0;
		int64_t ticks=mtime()-g_start;
		if (ticks>0) 	// not divide by zero, please
			speed=(int64_t)(total_size/(ticks/1000.0));
			
		int64_t myarchive_end=archive_end;	
		
		string inchunks=" ";
		string intotalsize="";
		
			if (g_chunk_size>0)
			{
				inchunks="[CKS #"+itos(out.filepartnames.size()+1)+"]";
				intotalsize="[TOT]";
			}
			else
			if (g_flagmultipart)
			{
				intotalsize="[LAST]";
			}
		if (g_chunk_size>0)  // we have multiple output
			if (out.filepartnames.size()>0)
			{
				myarchive_end=0;
				for (unsigned int i=0;i<out.filepartnames.size();i++)
				{
					if (flagdebug3)
						myprintf("02147: Getting %08d %s\n",i,out.filepartnames[i].c_str());
					if (fileexists(out.filepartnames[i]))
						myarchive_end+=prendidimensionefile(out.filepartnames[i].c_str());
				}
			}
		///myprintf("02148: ZZZ %21s myarchive_end initial_archive_size %s\n",migliaia4(myarchive_end),migliaia(initial_archive_size));
			
		if (flagverbose)
		{
			myprintf("02149:  %21s starting size\n",migliaia(initial_archive_size));
			myprintf("02150:  %21s data to be added\n",migliaia2(total_size));
			myprintf("02151:  %21s after deduplication\n",migliaia3(dedupesize));
			myprintf("02152: +%21s after compression\n",migliaia4(myarchive_end));//-initial_archive_size),inchunks.c_str());
			myprintf("02153:  %21s total size %s\n",migliaia5(myarchive_end),inchunks.c_str());
			myprintf("02154:  Total speed %s/s\n",tohuman(speed));
			myprintf("02155:  IO buffer %s\n",migliaia6(g_ioBUFSIZE));
		}
		else
		{
			if (g_fakewrite)
			{
				myprintf("\n");
				myprintf("02156: (%s -> %s) @ %s/s\n",migliaia2(total_size), migliaia3(dedupesize),tohuman(speed));
			}
			else
			{
				int64_t global_file_len=prendidimensionefile(g_archive.c_str());

				myprintf("\n");
				if (g_chunk_size>0)  // we have multiple output
						global_file_len=myarchive_end+initial_archive_size;
						
						
				if (files_added+files_updated+removed>0)
				{
				myprintf("02157: %s + (%s -> %s -> %s %s) = %s %s @ %s/s\n",
						migliaia(initial_archive_size), 
						migliaia2(total_size), 
						migliaia3(dedupesize),
						inchunks.c_str(),
						migliaia4(myarchive_end), 
						migliaia5(global_file_len),
						intotalsize.c_str(),
						tohuman(speed));
				}
			}
		}
	}
	
	if (!flagstdin)
		if (total_size!=total_done)
			if (flagverbose)
			{
				printbar('!');
				int64_t total_size_vf=0;
				for (unsigned i=0; i<vf.size(); i++)
				{
					DTMap::iterator p=vf[i];
					if (p->second.size!=p->second.hashedsize)
						myprintf("02158: exp %15s get %15s %s\n",migliaia(p->second.size),migliaia2(p->second.hashedsize),p->first.c_str());
					total_size_vf =total_size_vf+p->second.hashedsize;
				}
				myprintf("02159: expected total_size %21s\n",migliaia(total_size));
				myprintf("02160: hashed   total_size %21s\n",migliaia(total_size_vf));
				printbar('!');
			}
		
	if (g_flagmultipart && flagtmp)
		if (fileexists(arcname))
		{
			string sto=arcname;
			myreplace(sto,".tmp",".zpaq");
			if (flagverbose)
				myprintf("68938$ Renaming  <<%Z>> to <<%Z>>\n",arcname.c_str(),sto.c_str());
			if (myrename(arcname,sto)!=0)
			{
				myprintf("71350$ GURU CANNOT RENAME <<%Z>> to <<%Z>>\n",arcname.c_str(),sto.c_str());
				return 2;
			}
			else
			{
				if (flagverbose)
				{
					color_green();
					myprintf("71354: Renaming done\n");
					color_restore();
				}
				g_archive=sto;
			}
		}
#ifdef ZPAQFULL ///NOSFTPSTART
#if defined(_WIN32)
	if (flagvss)
	{
		if (flagtest)
		{
			printbar('=');
			myprintf("02161: -test on VSS\n");
			all=false;
			jidacreset();
			errors+=testverify();
		}
		if (flagverify)
		{
			printbar('=');
			myprintf("02162: -verify on VSS\n");
			all=false;
			jidacreset();
			errors+=verify(true); //re-read, again
		}
		vss_deleteshadows(cartellalocale);
	}
	if (!flaglongpath)
		if (!flagvss) // hard-coded kludge for long vss files
			if (maxfilelength>255)
			{
				myprintf("\n");
				myprintf("02163$ *** WINDOWS WARNING *** found file length >255. Suggestion: use -longpath switch\n");
			}
#endif // corresponds to #if (#if defined(_WIN32))
#endif ///NOSFTPEND
	if (flagfilelist)
		if (fileexists(tempfile))
		{
			if (flagdebug2)
				myprintf("02164: deleting tempfile %s\n",tempfile.c_str());
			delete_file(tempfile.c_str());
		}
	///do a second copy (ex. to USB)
	if (errors==0)
		if (g_copy!="")
		{
			string filescritto=filecopy(false,false,g_archive,g_copy,true,false,false,0);
			if (filescritto!="")
				myprintf("02165: Copied <<%s>> to <<%s>>\n",g_archive.c_str(),filescritto.c_str());
			else
				myprintf("02166: ERROR doing -copy from %s to %s\n",g_archive.c_str(),filescritto.c_str());
		}
	/// late -test
	if ((flagtest) && (!flagvss))
	{
		printbar('=');
		if (flagverbose)
			myprintf("02167: Do a testverify()\n");
		all=false;
		jidacreset();
		errors=testverify();
	}
	if ((flagverify) && (!flagvss))
	{
		printbar('=');
		if (flagverbose)
			myprintf("02168: Do a verify()\n");
		all=false;
		jidacreset();
		errors=verify(true); //re-read, again
	}
#ifdef ZPAQFULL ///NOSFTPSTART
	if (flagsfx)
	{
		if (g_sfx=="")
		{
			string exeoutput=extractfilepath(g_archive)+prendinomefileebasta(g_archive)+".exe";
			if (exists(exeoutput))
				myprintf("02169$ WARNING, EXE file already exists, skipping sfx ");
			else
			{
				myprintf("02170: INFO -sfx selected => activating sfx ");
				g_sfx=exeoutput;
			}
			printUTF8(exeoutput.c_str());
			myprintf("\n");
		}
		if (g_sfx!="")
			errors+=writesfxmodule(g_sfx);
	}
#endif ///NOSFTPEND
	
	


	if ((!flagstdin)
#ifdef _WIN32
		&& (!flagimage)
#endif // corresponds to #ifdef (#ifdef _WIN32)
	)
	if (!(flagdebug && flagzero && flagkill))
		if (total_size!=(total_done))
		{
			myprintf("\n");
			bool myerror=true;
			
			if (flagvss)
				if (total_done>total_size)
					myerror=false;
			
			if (myerror)
			{
				if ((!flagquiet) && (!flagignore))
				{
					myprintf("02171$ HOUSTON expected %s, done %s, diff %s\n",migliaia(total_size),migliaia2(total_done),migliaia3(myabs(total_size,total_done)));
					myprintf("02172$ Corrupted source files? Lost connection? Cannot access? Media full?\n");
					myprintf("02173$ =>The updated .zpaq archive is almost certainly incompleted\n");
				}
				g_exec_text="38271: HOUSTON something seems wrong expected vs done";
				errors=2;
			}
		}
#ifdef _WIN32
// this is a new thing: takes "strange" file access error, for debug (cannot access, denied etc)
	if (flagverbose)
		enumerateerrors();
#endif // corresponds to #ifdef (#ifdef _WIN32)

#ifdef unix
	if (flagimage)
	{
		chiudidump();
	}
#endif

#ifdef _WIN32
	if (flagimage)
	{
		if (flagntfs)
		{
			if (ntfs_ok)
				chiudintfs();
			myprintf("80771: NTFS-metadata compression time %s sec\n",migliaia((mtime()-startntfs)/1000));
		}
		else
		{
			if (device!=NULL)
				CloseHandle(device);
		}
	}
#endif // corresponds to #ifdef (#ifdef _WIN32)


	if (flagcollision)
		if (checksha1collision(edt,false)>0) // we get the crc32 from writefranzattr, so false
		{
			if (errors==0)
				errors=1;
			if (flagcollision)
				myprintf("02180$ WARNING: some files cannot be restored correctly due to a suspected SHA-1 collision(s).\n");
		}


	int64_t dimensione_garchive=prendidimensionefile(g_archive.c_str());

	string zetacrc32;
	if (flagbackupzeta)
	{
		int64_t		finalfile		=dimensione_garchive;
		if (initialzpaqsize>0)
			finalfile=initialzpaqsize;
		int64_t 	terzaparte		=dimensione_garchive-finalfile-104;
		uint32_t 	totalcrc32		=0;
		int64_t		initialoffset	=0;

		if (g_password==NULL)
		{
			if (initialoffset==0) /// FIRST run
			{
				totalcrc32=crc32_combine(totalcrc32,g_crc_jidac,		initialoffset+104);
				totalcrc32=crc32_combine(totalcrc32,g_crc_body,			initialoffset+finalfile-104);
			}
			else
			{
				totalcrc32=crc32_combine(totalcrc32,g_crc_jidac,	104);
				totalcrc32=crc32_combine(totalcrc32,g_crc_body,		terzaparte);
			}
		}
		else
		{
			if (header_pos==0)
			{
				totalcrc32=crc32_combine(totalcrc32,g_crc_jidac,	initialoffset+104);
				totalcrc32=crc32_combine(totalcrc32,g_crc_body,		initialoffset+finalfile-104);
			}
			else
			{
				if (g_header_pos>32)
				{
					totalcrc32=crc32_combine(totalcrc32,g_crc_jidac,	104);
					totalcrc32=crc32_combine(totalcrc32,g_crc_body,		terzaparte);
				}
				else
				{
					totalcrc32=crc32_combine(totalcrc32,g_crc_header,	initialoffset+32);
					totalcrc32=crc32_combine(totalcrc32,g_crc_jidac,	initialoffset+104);
					totalcrc32=crc32_combine(totalcrc32,g_crc_body,		initialoffset+finalfile-(32+104));
				}
			}
		}
		zetacrc32=bin2hex_32(totalcrc32);
		
///		g_franzhash_file.add(g_franzhash_104,104);
	///	g_franzhash_file_bytes+=104;

		if (flagverbose)
			myprintf("61519$ COMPUTATED   %s %s CRC-32 %s\n",bin2hex_64(g_franzhash_file.hash()).c_str(),migliaia(g_franzhash_file_bytes),zetacrc32.c_str());
/*
		franz_do_hash dummy32("CRC-32");
		string crc32reloaded=dummy32.filehash(g_archive,false,0,0);
		
		franz_do_hash dummy("ZETA");
		string hashreloaded=dummy.filehash(g_archive,false,0,0);
		myprintf("61568$ ZETA    HASH %s %s CRC-32 %s\n",hashreloaded.c_str(),migliaia(dummy.o_thefilesize),crc32reloaded.c_str());
		
		franz_do_hash dummy2("ZETAENC");
		string hashreloaded2=dummy2.filehash(g_archive,false,0,0);
		myprintf("61568$ ZETAENC HASH %s %s CRC-32 %s\n",hashreloaded2.c_str(),migliaia(dummy2.o_thefilesize),crc32reloaded.c_str());
		*/
	}

	
	if ((checktxt!="") || (backuptxt!=""))
		if (fileexists(g_archive)) // with no changes no multipart file is created
	{
		int64_t startverify		=mtime();
		int64_t larghezzain		=prendidimensionefile(g_archive.c_str());
		g_dimensione			=0;
		string hashreloaded		="";

		string thehash="MD5";
		if (flagbackupxxh3)
			thehash="XXH3";
		if (flagbackupzeta)
			thehash="ZETA";

		myprintf("02181: Creating %s check txt on %s\n",thehash.c_str(),g_archive.c_str());
		franz_do_hash dummy(thehash);
		if (flagdebug2)
			myprintf("02182: filehash on %s\n",g_archive.c_str());

		if (!flagbackupzeta)
		{
			hashreloaded=dummy.filehash(0,g_archive,false,startverify,larghezzain);
			myprintf("\n");
			myprintf("%s 44202: final %s: %s\n",hashreloaded.c_str(),thehash.c_str(),g_archive.c_str());
		
			if (hashreloaded=="")
			{
				myprintf("02183! Guru calculating %s hash for <<%Z>>\n",thehash.c_str(),g_archive.c_str());
				return 2;
			}
		}
		if (checktxt!="")
		{
			FILE* myoutput=fopen(checktxt.c_str(), "wb");
			if (myoutput==NULL)
			{
				myprintf("02184! cannot write on %Z\n",checktxt.c_str());
				franz_free(buf);
				return 2;
			}
			else
			{
				fprintf(myoutput,"%s %s|[%21s] %s",stringtolower(hashreloaded).c_str(),checktxt.c_str(),migliaia(larghezzain),/*dateToString(true,now()).c_str(),*/g_archive.c_str());
				if (flagverbose)
					myprintf("02185: %s: checksum file done\n",thehash.c_str());
			}
			fclose(myoutput);
		}

		if (backuptxt!="")
		{
			if (flagverbose)
				myprintf("02186: Doing backup stuff\n");
			if (!fileexists(backuptxt))
			{
				if (flagverbose)
					myprintf("02187: Creating backup txt %Z\n",backuptxt.c_str());
				FILE* backupfile=fopen(backuptxt.c_str(), "wb");
				if (backupfile==NULL)
				{
					myprintf("02188! Cannot write on backupfile\n");
					franz_free(buf);
					return 2;
				}
				fprintf(backupfile,"$zpaqfranz backupfile|2|%s|%s|%s\n",thehash.c_str(),dateToString(true,now()).c_str(),archive.c_str());
				fclose(backupfile);
			}

			if (fileexists(backuptxt))
			{
				if (!iszpaqfranzfile(backuptxt,"$zpaqfranz backupfile|"))
				{
					myprintf("02189! Does not seems a zpaqfranz's backup\n");
					return 2;
				}
				if (flagverbose)
					myprintf("02190: Updating backup txt %Z\n",backuptxt.c_str());
				
				franz_do_hash dummyquick("QUICK");
				if (flagdebug3)
					myprintf("02191: filehash on %s\n",g_archive.c_str());

				string quickhash=dummyquick.filehash(0,g_archive,false,startverify,larghezzain);

				FILE* backupfile=fopen(backuptxt.c_str(), "rb");
				if (backupfile==NULL)
				{
					myprintf("02192! Cannot append on backupfile\n");
					franz_free(buf);
					return 2;
				}
#ifdef ANCIENT
	char 	line[16384];
#else
	char 	line[65536];
#endif // corresponds to #ifdef (#ifdef ANCIENT)

				string linea="";
				if (!fgets(line, sizeof(line), backupfile))
				{
					myprintf("02193! failed reading first line\n");
					fclose(backupfile);
					franz_free(buf);//fiza
					return 2;
				}
				linea=line;
				if (linea.size()==0)
				{
					myprintf("02194! first line empty\n");
					return 2;
				}
				if (mypos("$zpaqfranz backupfile|",linea)==-1)
				{
					myprintf("02195! Abort: first line is strange %s\n",linea.c_str());
					return 2;
				}

				string goodhash="MD5";

				if (mypos("|XXH3|",linea)>0)
				{
					if (flagverbose)
						myprintf("02196: Enabling XXH3 (in write) hasher\n");
					goodhash="XXH3";
				}
				if (mypos("|MD5|",linea)>0)
				{
					if (flagverbose)
						myprintf("02197: Enabling MD5 (in write) hasher\n");
					goodhash="MD5";
				}
				if (mypos("|ZETA|",linea)>0)
				{
					if (flagverbose)
						myprintf("71236: Enabling ZETA (in write) hasher\n");
					goodhash="ZETA";
				}
				fclose(backupfile);

				backupfile=fopen(backuptxt.c_str(), "a");
				if (backupfile==NULL)
				{
					myprintf("02200! Cannot append on backupfile <<%Z>>\n",backuptxt.c_str());
					franz_free(buf);
					return 2;
				}
				if (flagbackupzeta)
					hashreloaded="zzzz"+bin2hex_64(g_franzhash_file.hash())+"wwww"+zetacrc32;
				else
				{
					if (goodhash!=thehash)
					{
						myprintf("02198: Rebuilding %s on %s\n",goodhash.c_str(),g_archive.c_str());
						franz_do_hash dummyquick(goodhash);
						if (flagdebug3)
							myprintf("02199: filehash on %s\n",g_archive.c_str());
						hashreloaded=dummy.filehash(0,g_archive,false,startverify,larghezzain);
					}
				}
				fprintf(backupfile,"%s %s|[%21s] <%s> $%s$ %s\r\n",stringtolower(hashreloaded).c_str(),checktxt.c_str(),migliaia(larghezzain),quickhash.c_str(),dateToString(true,now()).c_str(),g_archive.c_str());
				fclose(backupfile);
			}
			else
			{
				myprintf("02201! gurone, aborting!\n");
				franz_free(buf);
				return 2;
			}
		}
	}
	franz_free(buf);

	bool isfirstrun=false;

	if (g_password==NULL)
	{
		if (header_pos==0) /// FIRST run
		{
			isfirstrun=true;
			if (flagdebug3)
				myprintf("02202: setting isfirstrun [1]\n");
		}
	}
	else
	{
		if (header_pos==32)
		{
			isfirstrun=true;
			if (flagdebug3)
				myprintf("02203: setting isfirstrun (pwd) [2]\n");
		}
	}

	if (initialzpaqsize==dimensione_garchive)
	{
		isfirstrun=true;
		if (flagdebug3)
			myprintf("02204: setting isfirstrun (size) [3]\n");
	}


	if (flagdebug3)
	{
		if (isfirstrun)
			myprintf("02205: This is the first run\n");
		else
			myprintf("02206: This is NOT the first run\n");
	}
	
	if (fasttxt!="")
		if (fileexists(g_archive))
			///if (isfirstrun)
		{

			if (flagdebug3)
			{
				myprintf("02207: archive_end %s\n",migliaia(archive_end));
				myprintf("02208: crc_1   %08X\n",g_crc_header);
				myprintf("02209: crc_2   %08X %s\n",g_crc_jidac,migliaia(header_pos));
				myprintf("02210: crc_3   %08X\n",g_crc_body);
			}

			int64_t	finalfile=dimensione_garchive;

			if (initialzpaqsize>0)
				finalfile=initialzpaqsize;

			if (flagdebug2)
				myprintf("02211: Finalfile %s\n",migliaia(finalfile));

			int64_t terzaparte=dimensione_garchive-finalfile-104;

			uint32_t totalcrc32		=0;
			int64_t	initialoffset	=0;

			if (fileexists(fasttxt))
			{
				sscanf(initialzpaqcrc32.c_str(),"%x",&totalcrc32);
				initialoffset=initialzpaqsize;
			}

			if (flagdebug2)
				myprintf("02212: Ioffset %s\n",migliaia(initialoffset));

			sscanf(initialzpaqcrc32.c_str(),"%X",&totalcrc32);

			if (g_password==NULL)
			{
				if (initialoffset==0) /// FIRST run
				{
					if (flagdebug2)
						myprintf("02213: [1] NOPWD, first run  initial offset %s from %08X\n",migliaia(initialoffset),totalcrc32);
					totalcrc32=crc32_combine(totalcrc32,g_crc_jidac,		initialoffset+104);
					totalcrc32=crc32_combine(totalcrc32,g_crc_body,			initialoffset+finalfile-104);
				}
				else
				{
					if (flagdebug2)
					{
						myprintf("02214: [2] NOPWD, other run initial offset %s from %08X\n",migliaia(initialoffset),totalcrc32);
						myprintf("02215: t5 (g_header_pos>32) %s %08X con terzaparte %s\n",migliaia(g_header_pos),totalcrc32,migliaia(terzaparte));
					}
					totalcrc32=crc32_combine(totalcrc32,g_crc_jidac,	104);
					totalcrc32=crc32_combine(totalcrc32,g_crc_body,		terzaparte);
				}
			}
			else
			{
				if (header_pos==0)
				{
			/// multipart, not part 0
					if (flagdebug2)
						myprintf("02216: combine 2 (multipart, not 0) initial offset %s from %08X\n",migliaia(initialoffset),totalcrc32);

					totalcrc32=crc32_combine(totalcrc32,g_crc_jidac,	initialoffset+104);
					totalcrc32=crc32_combine(totalcrc32,g_crc_body,		initialoffset+finalfile-104);
				}
				else
				{
			/// multipart first part, or no multipart
					if (flagdebug2)
						myprintf("02217: combine 3 (multipart1 | nomultipart) initialoffset %s from %08X\n",migliaia(initialoffset),totalcrc32);

					if (g_header_pos>32)
					{
						if (flagdebug2)
							myprintf("02218: t1 (g_header_pos>32) %s %08X con terzaparte %s\n",migliaia(g_header_pos),totalcrc32,migliaia(terzaparte));
						totalcrc32=crc32_combine(totalcrc32,g_crc_jidac,	104);
						totalcrc32=crc32_combine(totalcrc32,g_crc_body,		terzaparte);
					}
					else
					{
						if (flagdebug2)
							myprintf("02219: t2 (g_header_pos<32) %s %08X\n",migliaia(g_header_pos),totalcrc32);
						totalcrc32=crc32_combine(totalcrc32,g_crc_header,	initialoffset+32);
						totalcrc32=crc32_combine(totalcrc32,g_crc_jidac,	initialoffset+104);
						totalcrc32=crc32_combine(totalcrc32,g_crc_body,		initialoffset+finalfile-(32+104));
					}
				}
			}
			char temp[10];
			snprintf(temp,sizeof(temp),"%08X",totalcrc32);
			string scrc32post=temp;
			if (flagverbose)
				myprintf("02220: CRC-32 EXPECTED %s\n",scrc32post.c_str());

			string scrc32indexpost="";

			if (flagverify)
			{
				franz_do_hash dummy("CRC-32");
				if (flagdebug2)
					myprintf("02221: filehash on %s\n",g_archive.c_str());

				string hashreloaded=dummy.filehash(0,g_archive,false,0,finalfile);
				myprintf("02222: CRC-32 FROM FS  %s %s\n",hashreloaded.c_str(),g_archive.c_str());
				if (stringtoupper(hashreloaded)==stringtoupper(scrc32post))
					myprintf("02223: CRC-32 MATCH, THIS IS GOOD!\n");
				else
				{
					myprintf("\n");
					myprintf("02224: CRC-32 DOES NOT MATCH *** THIS IS BAD ***\n\n");
				}
			}

			if (g_crc32_index!=0)
			{
				if (flagdebug2)
				{
					printbar('=');
					myprintf("02225: indexprezpaqcrc32 %s\n",indexinitialzpaqcrc32.c_str());
					myprintf("02226: indexprezpaqsize  %s\n",migliaia(indexprezpaqsize));
				}

				uint32_t newcrc32index=0;
				sscanf(indexinitialzpaqcrc32.c_str(),"%x",&newcrc32index);

				if (flagdebug2)
					myprintf("02227: newcrc32index so far %08X\n",newcrc32index);

				g_crc32_index=crc32_combine(newcrc32index,g_crc32_index,prendidimensionefile(g_indexname.c_str())-indexprezpaqsize);

				snprintf(temp,sizeof(temp),"%08X",g_crc32_index);
				scrc32indexpost=temp;
				myprintf("02228: INDEX CRC-32 EXPECTED %s\n",scrc32indexpost.c_str());

				if (flagverify)
				{
					franz_do_hash dummy("CRC-32");
					if (flagdebug2)
						myprintf("02229: filehash on %s\n",g_indexname.c_str());

					string hashreloaded=dummy.filehash(0,g_indexname,false,0,finalfile);
					myprintf("02230: INDEX CRC-32 FROM FS  %s %s\n",hashreloaded.c_str(),g_indexname.c_str());
					if (stringtoupper(hashreloaded)==stringtoupper(scrc32indexpost))
						myprintf("02231: INDEX CRC-32 MATCH, THIS IS GOOD!\n");
					else
					{
						myprintf("\n");
						myprintf("02232: INDEX CRC-32 DOES NOT MATCH *** THIS IS BAD ***\n\n");
					}
				}
			}

			int64_t startverify		=mtime();
			franz_do_hash dummyquick("QUICK");
			if (flagdebug3)
				myprintf("02233: filehash on %s\n",g_archive.c_str());

			string quickhash=dummyquick.filehash(0,g_archive,false,startverify,finalfile);
			if (quickhash=="")
			{
				myprintf("02234! quick hash empty!\n");
				return 2;
			}

			myprintf("02235: Updating fasttxt       %Z",fasttxt.c_str());
			
			if (!writedatainfasttxt(fasttxt,g_archive,scrc32post,quickhash,
			initialzpaqcrc32,dimensione_garchive,initialzpaqsize))
			{
				myprintf(" :62957: something wrong!\n");
				return 2;
			}
			else
				myprintf(" :OK\n");

			if (g_indexname!="")
			{
				myprintf("02236: Updating INDEX fasttxt %Z",indexfasttxt.c_str());
				
				franz_do_hash dummyquick("QUICK");
				if (flagdebug3)
					myprintf("02237: filehash on %s\n",g_indexname.c_str());

				string quickhash=dummyquick.filehash(0,g_indexname,false,startverify,finalfile);
				if (quickhash=="")
				{
					myprintf("02238! quick hash empty!\n");
					return 2;
				}

				if (!writedatainfasttxt(indexfasttxt,g_indexname,
				scrc32indexpost,
				quickhash,
				indexinitialzpaqcrc32,
				prendidimensionefile(g_indexname.c_str()),
				indexinitialzpaqsize))
				{
					myprintf(" :63500: something wrong!\n");
					return 2;
				}
				else
					myprintf(" :OK\n");
			}
		}
	
///	checksha1collision(dt,true);
#ifdef ZPAQFULL ///NOSFTPSTART
#ifdef unix
	if (g_dataset!="")
	{
		string 	destroy_diff2	=x_one("zfs destroy "	+g_tempsnapshot,"59870: Destroy diff snapshot (if any)");
		string 	destroy_base	=x_one("zfs destroy "	+g_basesnapshot,"59870: Destroy base snapshot (if any)");
		if (flagdebug2)
		{
			myprintf("02244: %s\n",destroy_diff2.c_str());
			myprintf("02245: %s\n",destroy_base.c_str());
		}
		string 	take_base		=x_one("zfs snapshot "	+g_basesnapshot,"Taking base snapshot");
		if (flagdebug2)
			myprintf("02246: %s\n",take_base.c_str());
	}
#endif // corresponds to #ifdef (#ifdef unix)
#endif ///NOSFTPEND
#ifdef _WIN32
	if ((flagads) && (!flagfasttxt))
		fill_ads(g_archive,start_iblock);
#endif // corresponds to #ifdef (#ifdef _WIN32)

	if (flagstat)
	{
		unsigned int work_added		=0;
		unsigned int work_updated	=0;
		unsigned int	work_removed	=0;
		for (DTMap::const_iterator p=edt.begin(); p!=edt.end(); ++p)
		{
			///myprintf("02247: filework %d %s\n",p->second.filework,p->first.c_str());
			if (p->second.filework==WORK_ADDED)
			{
				myprintf("02248: |STAT| + %08d %Z\n",++work_added,p->first.c_str());
				if (menoenne)
					if (work_added>menoenne)
					{
						myprintf("69671$ no nore work_added due to -n %s\n",migliaia(menoenne));
						break;
					}
			}
		}
		for (DTMap::const_iterator p=edt.begin(); p!=edt.end(); ++p)
			if (p->second.filework==WORK_UPDATED)
			{
				myprintf("02249: |STAT| # %08d %Z\n",++work_updated,p->first.c_str());
				if (menoenne)
					if (work_updated>menoenne)
					{
						myprintf("69672$ no nore work_updated due to -n %s\n",migliaia(menoenne));
						break;
					}

			}
		for (DTMap::const_iterator p=dt.begin(); p!=dt.end(); ++p)
			if (p->second.filework==WORK_REMOVED)
			{
				myprintf("02250: |STAT| - %08d %Z\n",++work_removed,p->first.c_str());
				if (menoenne)
					if (work_removed>menoenne)
					{
						myprintf("69675$ no nore work_removed due to -n %s\n",migliaia(menoenne));
						break;
					}

			}
	}

	string temp="";
	string temp2;
	if (files_added>0)
	{
		temp2=migliaia(files_added);
		temp+=" added +"+temp2;
	}
	if (files_updated>0)
	{
		temp2=migliaia(files_updated);
		temp+=" updated #"+temp2;
	}
	if (removed>0)
	{
		temp2=migliaia(removed);
		temp+=" removed -"+temp2;
	}
	if (files_added+files_updated+removed>0)
		myprintf("02251: Files%s\n",temp.c_str());
	
	if (flagignore)
	{
		if (errors)
			myprintf("69706$ resetting errors to 0 due to -ignore from %d\n",errors);
		errors=0;
	}
	return errors;
}

#ifdef _WIN32
bool Jidac::fill_ads(string i_filename,int64_t i_startiblock)
{
	if (check_if_password(i_filename))
	{
		myprintf("02252: SORRY, cannot do fill_ads on encrypted archive\n");
		return false;
	}
	
	if (flagverbose)
		myprintf("02253: ADS: jump to index @ %s\n",migliaia(i_startiblock));
	int64_t startingads=mtime();
	read_archive2(i_startiblock,i_filename);
	
	if (g_password!=NULL)
	{
		myprintf("02254: **** ADS list does not work with encrypted archives ****\n");
		return false;
	}
	
	int64_t	listsize=0;
	franz_ads theads(i_filename,"zpaqlist",'w');
	if (theads.isopen())
	{
		///// This is inspired on LZ4 streaming API example : line-by-line logfile compression by Takayuki Matsuoka
		char linebuffer[16384];
		int fi=0;
		size_t messageMaxBytes=16384;
		size_t ringBufferBytes=1024 * 256 + messageMaxBytes;
		
		LZ4_stream_t* const lz4Stream = LZ4_createStream();
		const size_t cmpBufBytes = LZ4_COMPRESSBOUND(messageMaxBytes);
		char* const cmpBuf = (char*) malloc(cmpBufBytes);
		g_allocatedram+=cmpBufBytes;
		if (cmpBuf==NULL)
		{
			myprintf("02255: GURU malloc cmpBuf\n");
			seppuku();
			return 0;
		}
		char* const inpBuf = (char*) malloc(ringBufferBytes);
		g_allocatedram+=ringBufferBytes;
		if (inpBuf==NULL)
		{
			myprintf("02256: GURU malloc inpBuf\n");
			seppuku();
			return 0;
		}
		
		int inpOffset = 0;

		for (DTMap::const_iterator p=dt.begin(); p!=dt.end(); ++p)
			if (p->second.date)
			{
				fi++;
				string myfilename		=p->first;
				myfilename=rename(myfilename);
				franzreplace(myfilename);
				snprintf(linebuffer,sizeof(linebuffer),"%s %19s %s\n", dateToString(flagutc,p->second.date).c_str(), migliaia(p->second.size),myfilename.c_str());
	
				string temp=linebuffer;
				
				char* const inpPtr = &inpBuf[inpOffset];
				int inpBytes = 0;
				sprintf(inpPtr,"%s",temp.c_str());
				if (flagdebug2)
					myprintf("02257: ready to compress\n");
				inpBytes = (int) strlen(inpPtr);
				const int cmpBytes = LZ4_compress_fast_continue(lz4Stream, inpPtr, cmpBuf, inpBytes, (int) cmpBufBytes, 1);
				if (cmpBytes <= 0)
				{
					myprintf("02258! guru on cmpbytes\n");
					seppuku();
					return 2;
				}
				theads.write_uint16((uint16_t)cmpBytes);
				theads.write(cmpBuf,cmpBytes);
				listsize+=(inpBytes+2);
				inpOffset += inpBytes;
				if ((size_t)inpOffset >= ringBufferBytes - messageMaxBytes) inpOffset = 0;
			}

		int64_t 	allsize=0;
		for (DTMap::const_iterator p=dt.begin(); p!=dt.end(); ++p)
			if (p->second.date)
				for (unsigned j=0; j<p->second.ptr.size(); ++j)
				{
					unsigned k=p->second.ptr[j];
					if (k>0 && k<ht.size())
						if (ht[k].usize>=0)
							allsize+=ht[k].usize;
				}
		int64_t sizecompressed=prendidimensionefile(archive.c_str());

		snprintf(linebuffer,sizeof(linebuffer),"\n                  %21s (%s) in %s files shown\n                 %22s compressed  (ADS %s => %s)\n",
		migliaia(allsize),tohuman(allsize),migliaia3(fi),
		migliaia4(sizecompressed),tohuman4(listsize),tohuman3(theads.size()));
		
		string temp=linebuffer;

		if (allsize>0)
		{
			double ratio=(double)sizecompressed/(double)allsize;
			snprintf(linebuffer,sizeof(linebuffer),"Ratio %.3f <<%s>>\n",ratio,archive.c_str());
			string temp2=linebuffer;
			temp+=temp2;
		}				
		char* const inpPtr = &inpBuf[inpOffset];
		int inpBytes = 0;
		sprintf(inpPtr,"%s",temp.c_str());
		inpBytes = (int) strlen(inpPtr);
		const int cmpBytes = LZ4_compress_fast_continue(lz4Stream, inpPtr, cmpBuf, inpBytes, (int) cmpBufBytes, 1);
		if (cmpBytes<=0)
		{
			myprintf("02259! guru on cmpbytes\n");
			return 2;
		}
		theads.write_uint16((uint16_t)cmpBytes);
		theads.write(cmpBuf,cmpBytes);
		listsize+=(inpBytes+2);
			
		theads.write_uint16(0);
		theads.close();
		free(inpBuf);
		free(cmpBuf);
		LZ4_freeStream(lz4Stream);
		myprintf("02260: ADS: done %s => %s bytes in %s ticks\n",migliaia3(listsize),migliaia(theads.size()),migliaia2(mtime()-startingads));
		return true;
	}
	else
		myprintf("02261: ADS: cannot update. Maybe not a NTFS media?\n");
	
	return false;
}
#endif // corresponds to #ifdef (#ifdef _WIN32)

#ifdef ZPAQFULL ///NOSFTPSTART
/*
	Section: sfx
	The two binaries (zsfx.exe for Windows 64 bit, and zsfx32.exe for Win32)
	are compressed with zpipe (from 55.14+) max compression
	The 32-bit is about 2/3 of the 64 (~220K vs ~320K)
	but slower. In fact not a big deal

	Debian does not like embedded code, at all
	Fix by sed
*/
#endif ///NOSFTPEND
///DEBIANSTART
#if defined(_WIN32) && (defined(_WIN64))
char zsfx_mime64[]={"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"};
string zsfx_hash="7537DEDC40B59AF9E8029D04D3390C2AA4EE5819E0D2CDD6467C20CDA287318C";
#endif // corresponds to #if (#if defined(_WIN32) && (defined(_WIN64)))
#if defined(_WIN32) && (!defined(_WIN64))
char zsfx_mime64[]={"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"};
string zsfx_hash="29CF5510EF6E1CCA159017D0FE101FD923499D7E0146B3F5D81CD29D3003E90C";
#endif // corresponds to #if (#if defined(_WIN32) && (!defined(_WIN64)))
///DEBIANEND
#if !defined(_WIN32)
///	Unix or Linux
char zsfx_mime64[]=
{"RVJST1I="};
string zsfx_hash="ERRORE";
#endif // corresponds to #if (#if !defined(_WIN32))


void poke_octal(string& i_thestring)
{
	int posizionebarra=0;
	posizionebarra=mypos("\\",i_thestring);
	while (posizionebarra>-1)
	{
		if ((unsigned)posizionebarra!=i_thestring.size())
		{
			int esc_valore=0;
			string numerino="\\";
			posizionebarra++;
			for (unsigned int i=0;i<3;i++)
				if (isdigit(i_thestring[posizionebarra]))
				{
					numerino+=i_thestring[posizionebarra];
					esc_valore=esc_valore*8+(i_thestring[posizionebarra]-'0');
					posizionebarra++;
				}		
///			myprintf("02262: Escvalore %02X  |%s|\n",esc_valore,numerino.c_str());
			string codificato="0";
			codificato[0]=esc_valore;
			myreplaceall(i_thestring,numerino,codificato);
		}
		posizionebarra=mypos("\\",i_thestring);
	}
}


int	Jidac::loadzfsdiff(string i_filediff,vector<string>& o_added,vector<string>& o_deleted)
{
/*
M File or directory has been modified or file or directory link has changed
— File or directory is present in the older snapshot but not in the more recent snapshot
+ File or directory is present in the more recent snapshot but not in the older snapshot
R File or directory has been renamed
zfs diff -F
*/
	if (i_filediff=="")
	{
		myprintf("02263$ Warning: filediff empty\n");
		return 0;
	}
	if (!fileexists(i_filediff))
	{
		myprintf("02264$ Warning: filediff does not exists %s\n",i_filediff.c_str());
		return 0;
	}
	vector<string> diffz;
	readfiletoarray(i_filediff,diffz);
	if (flagverbose)
		myprintf("02265: zfsdiff lines  %s\n",migliaia(diffz.size()));
	for (unsigned int i=0;i<diffz.size();i++)
	{
		///R	/	/tank/d/documenti/ANNA/betzov-generali\040-\040RO -> /tank/d/documenti/ANNA/betzov-generali\040-\0403\040GIUGNO\040DEP\040FOGLIO\040PC\040E\040RICHIESTA\040TERMINI

		string theline=diffz[i];
		if (theline.size()>=3)
		{
			poke_octal(theline);
			char char_1	=theline[0]; // M
			char char_2	=theline[1]; // TAB
			char char_3	=theline[2]; // / OR F
			char char_4	=theline[3]; // TAB
			char char_5	=theline[4]; // /
			if (char_2==9) // the tab
				if ((char_3=='F') || (char_3=='/'))
					if (char_4==9) // the tab
						if (char_5=='/')
						{
							if ((char_1=='M') && (char_3=='F')) //changed file
							{
								string sthething=theline.substr(4,theline.size());
								if (flagverbose)
									myprintf("02266: MOD |%s|\n",sthething.c_str());
								o_added.push_back(sthething);
							}
							else
							if (char_1=='-')		// currently unsupported
							{
								string sthething=theline.substr(4,theline.size());
								if (flagverbose)
									myprintf("02267: DEL |%s|\n",sthething.c_str());
								o_deleted.push_back(sthething);
							}
							else
							if ((char_1=='+') && (char_3=='F')) // new file
							{
								string sthething=theline.substr(4,theline.size());
								if (flagverbose)
									myprintf("02268: ADD |%s|\n",sthething.c_str());
								o_added.push_back(sthething);
							}
							else
							if (char_1=='R') // file or folder renamed => get everything inside
							{
								int divider=mypos(" -> ",theline);
								if (divider==-1)
								{
									myprintf("02269: error in parsing -> on line %08d\n",i);
								}
								else
								{
									string sfrom=theline.substr(4,divider-4);
									string sto=	theline.substr(divider+4,theline.size());
									o_deleted.push_back(sfrom);
									o_added.push_back(sto);
									if (flagverbose)
										myprintf("02270: REN sfrom |%s| |%s|\n",sfrom.c_str(),sto.c_str());
								}
							}
						}
		}
	}
	if (flagverbose)
		myprintf("02271: + %14s - %14s\n",migliaia(o_added.size()),migliaia2(o_deleted.size()));
	return o_added.size();
}



void Jidac::pc_info()
{
#ifdef _WIN32
	myprintf("72943: Win32\n");
	if (iswindowsxp())
		myprintf("72945: This seems Windows XP!\n");
/*
#ifdef _WIN64
	int64_t wifemem=getwifesize();
	myprintf("70177: Windows-executable wifesize %s\n",tohuman(wifemem));
	provaAllocazioneAdattiva(wifemem);
#endif
*/

#endif // corresponds to #ifdef (#ifdef _WIN32)

	bool iamintel=isjitable();
	if (iamintel)
	{
		myprintf("02272: This seems Intel/AMD 'normal' CPU\n");
		if (flagnojit)
		{
			color_green();
			myprintf("02273: You can try EXTRACT without -nojit\n");
			color_restore();
		}
	}
	else
	{
		myprintf("02274: I am not sure this is Intel/AMD CPU (virtual? arm?)\n");
		if (!flagnojit)
		{
			color_yellow();
			myprintf("02275: WARNING: non Intel/AMD CPUs should be compiled with -DNOJIT or run with -nojit\n");
			color_restore();
		}
	}
	string myname=getuname();
	myprintf("02276: uname %s\n",myname.c_str());
	myprintf("02277: full exename seems <<%s>>\n",fullzpaqexename.c_str());
	int64_t myram=getramdisksize();
	if (myram<0)
		myprintf("02278: Cannot get free RAM\n");
	else
		myprintf("02279: Free RAM seems %s\n",migliaia(myram));
#ifdef HWSHA2
	if (ihavehw())
		myprintf("02280: SHA1/2 seems supported by the CPU\n");
	else
		myprintf("02281: No SHA1/2 (try -debug)\n");
#endif // corresponds to #ifdef (#ifdef HWSHA2)

	int myproc=numberOfProcessors();
	if (flaght)
		myprintf("02283: Number of threads (with HT if any) %d\n",myproc);
	else
		myprintf("02284: Number of processors (without HT) %d\n",myproc);
		
}



////////////////////


// Function to encode in Base85 (simplified ASCII85 variant)
std::string encode_base85(const std::string& data) 
{
    const char* charset = "!\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstu";
    std::string result;
    
    for (size_t i = 0; i < data.length(); i += 4) 
	{
        unsigned long value = 0;
        int padding = 0;
        
        // Collects up to 4 bytes
        for (int j = 0; j < 4; j++) 
		{
            value <<= 8;
            if (i + j < data.length()) 
			    value |= (unsigned char)data[i + j];
            else 
			    padding++;
        }
        
        // Convert to base 85
        char encoded[6] = {0};
        for (int j = 4; j >= 0; j--) 
		{
            encoded[j] = charset[value % 85];
            value /= 85;
        }
        
        // Add to the result (minus padding)
        for (int j = 0; j < 5 - padding; j++) 
		    result += encoded[j];
    }
    return result;
}

// Function to decode from Base85
std::string decode_base85(const std::string& encoded) 
{
    std::string result;
    for (size_t i=0; i<encoded.length(); i+= 5) 
	{
        unsigned long value = 0;
        int chars_to_process = (encoded.length() - i < 5) ? (encoded.length() - i) : 5;
        
        // Decode up to 5 characters
        for (int j = 0; j < chars_to_process; j++) 
		{
            char c = encoded[i + j];
            int digit = -1;
            
            if (c >= '!' && c <= 'u') 
			    digit = c - '!';
            
            if (digit >= 0 && digit < 85) 
			    value = value * 85 + digit;
        }
        
        // Convert to byte
        int bytes_to_output = chars_to_process - 1;
        for (int j = bytes_to_output - 1; j >= 0; j--) 
		    result += (char)((value >> (j * 8)) & 0xFF);
    }
    return result;
}

std::string codifica_franzhash(const std::string& input) 
{
    // --- 1. Parsing iniziale con find e substr ---
    size_t pos1 = input.find(':');
    if (pos1 == std::string::npos) return input;
    size_t pos2 = input.find(':', pos1 + 1);
    if (pos2 == std::string::npos) return input;
    size_t pos3 = input.find(':', pos2 + 1);
    if (pos3 == std::string::npos) return input;

    std::string prefix 			= input.substr(0, pos1);
    std::string algo 			= input.substr(pos1 + 1, pos2 - (pos1 + 1));
    std::string block_count_str = input.substr(pos2 + 1, pos3 - (pos2 + 1));
    std::string payload 		= input.substr(pos3 + 1);

    long block_count;
    try {
        block_count = std::stol(block_count_str);
    } catch (const std::invalid_argument& e) 
	{
        return input; // Conversion to number failed
    }
    if (block_count <= 0) return input;

    // Separation between numbers and final hash
    std::string numbers_part;
    std::string final_hash;
    size_t hash_separator_pos = payload.rfind('-');

    if (hash_separator_pos == std::string::npos) 
	{
        // No hyphen: valid only if block_count is 1.
        // Validity will be checked later.
        numbers_part = "";
        final_hash = payload;
    } else 
	{
        numbers_part = payload.substr(0, hash_separator_pos);
        final_hash = payload.substr(hash_separator_pos + 1);
    }

    // Parsing numbers ---
    std::vector<long long> numbers;
    numbers.push_back(0); // The first one is always zero

    if (!numbers_part.empty()) 
	{
        size_t start = 0;
        size_t end;
        while ((end = numbers_part.find('-', start)) != std::string::npos) {
            try {
                numbers.push_back(std::stoll(numbers_part.substr(start, end - start)));
            } catch (const std::invalid_argument& e) { return input; }
            start = end + 1;
        }
        try { // Add the last number after the last hyphen
            numbers.push_back(std::stoll(numbers_part.substr(start)));
        } catch (const std::invalid_argument& e) { return input; }
    }

    if (static_cast<long>(numbers.size()) != block_count) 
	    return input; // The number of blocks does not match
    
    // --- 4. Verification of the arithmetic progression ---
    bool is_ap = true;
    long long step = 0;
    if (block_count > 1) 
	{
        step = numbers[1] - numbers[0];
        for (size_t i = 1; i < numbers.size(); ++i) 
            if (numbers[i] != numbers[0] + static_cast<long long>(i) * step) 
			{
                is_ap = false;
                break;
            }
    }

    // Final string
	if (is_ap) 
	{
        std::string encoded_hash = encode_base85(final_hash);
        std::string result = prefix + ":" + algo + ":" + std::to_string(block_count) + ":c:";

        if (block_count == 1) {
            result += encoded_hash;
        } else {
            result += std::to_string(step) + ":" + encoded_hash;
        }
        return result;
    } 
	else 
        return input; // It is not an arithmetic progression
}

std::string decodifica_franzhash(const std::string& input) 
{
    // Check for the presence of the "c" marker (compressed)
    size_t marker_pos = input.find(":c:");
    if (marker_pos == std::string::npos) 
	    return input; // It's not encoded, return the original
    
    // Parsing
	size_t pos1 = input.find(':');
    if (pos1 == std::string::npos) return input;
    size_t pos2 = input.find(':', pos1 + 1);
    if (pos2 == std::string::npos || pos2 >= marker_pos) return input;

    std::string prefix = input.substr(0, pos1);
    std::string algo = input.substr(pos1 + 1, pos2 - (pos1 + 1));
    std::string block_count_str = input.substr(pos2 + 1, marker_pos - (pos2 + 1));
    
    // The rest of the string after ":c:"
    std::string payload = input.substr(marker_pos + 3);

    long block_count;
    try 
	{
        block_count = std::stol(block_count_str);
    } 
	catch (const std::invalid_argument& e) 
	{
        return input; // Conversion failed
    }
    if (block_count <= 0) return input;

    long long step = 0;
    std::string encoded_hash;
    if (block_count > 1) 
	{
        size_t step_separator = payload.find(':');
        if (step_separator == std::string::npos) return input; // Invalid format
        try 
		{
            step = std::stoll(payload.substr(0, step_separator));
        } 
		catch (const std::invalid_argument& e) { return input; }
        encoded_hash = payload.substr(step_separator + 1);
    } 
	else // block_count == 1
		encoded_hash = payload;
    
    std::string final_hash = decode_base85(encoded_hash);

    std::string result = prefix + ":" + algo + ":" + std::to_string(block_count) + ":";
    
    if (block_count > 1) 
	{
        std::string numbers_payload;
        for (long i = 1; i < block_count; ++i) 
		{
            numbers_payload += std::to_string(step * i);
            if (i < block_count - 1) 
			    numbers_payload += "-";
        }
        result += numbers_payload + "-" + final_hash;
    } 
	else     // If block_count is 1, there is no numeric payload, only the final hash.
		result += final_hash;
    
    return result;
}



// Structure for thread data
typedef struct 
{
    const char* filename;
    int64_t start_offset;
    int64_t end_offset;
    int thread_id;
    int total_threads;
    std::string hash_result; // Buffer per l'hash  della parte
    double* progress;  // Thread progress percentage
} franzhash_thread_data;

// Structure for the calculation/verification result
typedef struct 
{
    std::string hash_type;
    int num_parts;
    std::vector<int64_t> offsets;
    std::string final_hash;
} franzhash_result;

// Support function to convert int64_t to string
std::string int64_to_string(int64_t value) 
{
    char buffer[32];
    snprintf(buffer, sizeof(buffer), "%lld", (long long)value);
    return std::string(buffer);
}

// Support function for calculating the hash of a part
void* franzhash_thread_func(void* arg) 
{
    franzhash_thread_data* data = (franzhash_thread_data*)arg;
    char* buffer = (char*)franz_malloc(g_ioBUFSIZE);
    if (!buffer) 
    {
        myprintf("70627! Error buffer thread %d\n", data->thread_id);
        return NULL;
    }
    
    FILE* file = fopen(data->filename, "rb");
    if (!file) 
    {
        myprintf("70634: Error opening file thread %d\n", data->thread_id);
        franz_free(buffer);
        return NULL;
    }
    
    franz_do_hash hashfrombuffer(g_thechosenhash_str);
    hashfrombuffer.init();
    
    if (fseeko(file, data->start_offset, SEEK_SET) != 0) 
	{
        myprintf("70635: Error seeking in file thread %d\n", data->thread_id);
        fclose(file);
        franz_free(buffer);
        return NULL;
    }
    
    int64_t bytes_to_read = data->end_offset - data->start_offset + 1;
    int64_t bytes_read_total = 0;
    
	while (bytes_read_total < bytes_to_read) 
	{
		// Clear any previous error indicators
		clearerr(file);
		
	size_t to_read = (size_t)(((int64_t)g_ioBUFSIZE < (bytes_to_read - bytes_read_total)) ? 
                         (int64_t)g_ioBUFSIZE : (bytes_to_read - bytes_read_total));
		 size_t read = fread(buffer, 1, to_read, file);
		
		if (read > 0) 
		{
			hashfrombuffer.update(buffer, read);
			bytes_read_total += read;
			*(data->progress) = (double)bytes_read_total / bytes_to_read * 100.0;
		}
		
		// Exit conditions
		if (read == 0 || read < to_read) 
		{
			if (feof(file)) 
			{
				// Normal EOF - we're done
				break;
			}
			if (ferror(file)) 
			{
				myprintf("70636: Read error in thread %d\n", data->thread_id);
				break;
			}
			// Should not reach here, but break for safety
			break;
		}
	}
    
    fclose(file);
    franz_free(buffer);
    
    string thefinalhash = hashfrombuffer.finalize();
    data->hash_result = thefinalhash;
    
    if (flagdebug3) /// yep, no mutex, just debug
        myprintf("70670: Thread %03d hash string %s\n", data->thread_id, data->hash_result.c_str());
    
    return NULL;
}
std::string calcolafranzhash(std::string i_tipohash, std::string i_nomefile, int i_numerothread, bool i_serie) {

    // Get file size
    int64_t file_size = prendidimensionefile(i_nomefile.c_str());
    if (file_size == -1) 
        return "Error: cannot get filesize";

    // Determine effective number of threads
    int num_threads = (i_numerothread < 64) ? i_numerothread : 64; // Reasonable limit
	if (num_threads < 1) 
        num_threads = 1;

    // Calculate part size per thread
    int64_t part_size = file_size / num_threads;
    std::vector<int64_t> offsets(num_threads);
    std::vector<franzhash_thread_data> thread_data(num_threads);
    std::vector<pthread_t> threads(num_threads);
    std::vector<double> progress(num_threads, 0.0);

    // Initialize thread data
    for (int i = 0; i < num_threads; i++) {
        thread_data[i].filename = i_nomefile.c_str();
        thread_data[i].start_offset = i * part_size;
        thread_data[i].end_offset = (i == num_threads - 1) ? file_size - 1 : (i + 1) * part_size - 1;
        thread_data[i].thread_id = i;
        thread_data[i].total_threads = num_threads;
        thread_data[i].progress = &progress[i];
        offsets[i] = thread_data[i].start_offset;
    }

    int64_t start_run = mtime();

    if (i_serie) {
		myprintf("70687: franzhash: serial run %s (spinning drives, old SSD, slow CPU)\n",tohuman(file_size));
        // SERIAL EXECUTION
        for (int i = 0; i < num_threads; i++) {
            // Reset progress for the current thread
            progress[i] = 0.0;
            
            // Create and start one thread at a time
            if (pthread_create(&threads[i], NULL, franzhash_thread_func, &thread_data[i]) != 0) 
                return "Error creating thread";
            
            // Monitor the progress di questo thread specifico
            while (progress[i] < 100.0) {
                // Calculate global progress considering threads already completed + the current one
                double total_progress = 0.0;
                int64_t bytes_processed = 0;
                
                for (int j = 0; j < num_threads; j++) {
                    double thread_progress = (j < i) ? 100.0 : ((j == i) ? progress[j] : 0.0);
                    int64_t thread_bytes = (j == num_threads - 1) 
                        ? (file_size - thread_data[j].start_offset) 
                        : (thread_data[j].end_offset - thread_data[j].start_offset + 1);
                    bytes_processed += static_cast<int64_t>(thread_bytes * (thread_progress / 100.0));
                    total_progress += thread_progress;
                }
                total_progress /= num_threads;

                // Calculate average speed (byte/s)
                int64_t current_time = mtime();
                double elapsed_seconds = (current_time - start_run) / 1000.0;
                double average_speed = (elapsed_seconds > 0) ? (bytes_processed / elapsed_seconds) : 0.0;

                // Calculate ETA
                int64_t bytes_remaining = file_size - bytes_processed;
                double eta_seconds = (average_speed > 0) ? (bytes_remaining / average_speed) : 0.0;
                int eta_hours = static_cast<int>(eta_seconds / 3600);
                eta_seconds -= eta_hours * 3600;
                int eta_minutes = static_cast<int>(eta_seconds / 60);
                eta_seconds -= eta_minutes * 60;
                int eta_secs = static_cast<int>(eta_seconds);

                myprintf("70713: %7.2f%% ETA %02d:%02d:%02d %10s @ %10s/s [Part %03d/%03d]\r",
                         total_progress, eta_hours,eta_minutes,eta_secs,tohuman2(bytes_processed), tohuman(average_speed), i+1, num_threads);

#ifdef _WIN32
                Sleep(1000);
#else
                usleep(1000000); // 1 second
#endif
            }
            
            // Wait for this specific thread to terminate
            pthread_join(threads[i], NULL);
        }
    } else {
        // PARALLEL EXECUTION (original logic)
        myprintf("70423: franzhash: parallel run %s (NVMe/RAID of SSDs, multicore CPU)\n",tohuman(file_size));
        
        // Start all threads
        for (int i = 0; i < num_threads; i++) 
            if (pthread_create(&threads[i], NULL, franzhash_thread_func, &thread_data[i]) != 0) 
                return "Error creating thread";
        
        // Monitor global progress
        while (true) {
            double total_progress = 0.0;
            int64_t bytes_processed = 0;
            for (int i = 0; i < num_threads; i++) {
                double thread_progress = progress[i]; // Progress in percentage (0-100)
                int64_t thread_bytes = (i == num_threads - 1) 
                    ? (file_size - thread_data[i].start_offset) 
                    : (thread_data[i].end_offset - thread_data[i].start_offset + 1);
                bytes_processed += static_cast<int64_t>(thread_bytes * (thread_progress / 100.0));
                total_progress += thread_progress;
            }
            total_progress /= num_threads;

            // Calculate average speed (byte/s)
            int64_t current_time = mtime();
            double elapsed_seconds = (current_time - start_run) / 1000.0;
            double average_speed = (elapsed_seconds > 0) ? (bytes_processed / elapsed_seconds) : 0.0;

            // Calculate ETA
            int64_t bytes_remaining = file_size - bytes_processed;
            double eta_seconds = (average_speed > 0) ? (bytes_remaining / average_speed) : 0.0;
            int eta_hours = static_cast<int>(eta_seconds / 3600);
            eta_seconds -= eta_hours * 3600;
            int eta_minutes = static_cast<int>(eta_seconds / 60);
            eta_seconds -= eta_minutes * 60;
            int eta_secs = static_cast<int>(eta_seconds);

            myprintf("70713: %7.2f%% ETA %02d:%02d:%02d %10s @ %10s/s\r",
                     total_progress, eta_hours,eta_minutes,eta_secs,tohuman2(bytes_processed), tohuman(average_speed));

            bool all_done = true;
            for (int i = 0; i < num_threads; i++) 
                if (progress[i] < 100.0) {
                    all_done = false;
                    break;
                }
            if (all_done) 
                break;

#ifdef _WIN32
            Sleep(1000);
#else
            usleep(1000000); // 1 second (1000000 microsecondi)
#endif
        }

        // Wait for completion of all remaining threads
        for (int i = 0; i < num_threads; i++) 
            pthread_join(threads[i], NULL);
    }

    // Calculate final hash
    libzpaq::SHA256 final_sha256;
    if (flagdebug3)
        myprintf("---- OK, just debug for %03d threads\n",num_threads);
    for (int i = 0; i < num_threads; i++) {
        if (flagdebug3)
            myprintf("70880: Making global %03d %s %d %s\n",i,thread_data[i].hash_result.c_str(),thread_data[i].hash_result.size(),g_thechosenhash_str.c_str());
        final_sha256.write(thread_data[i].hash_result.c_str(),thread_data[i].hash_result.size());
    }
    myprintf("\n");
    char final_hash[32];
    memcpy(final_hash, final_sha256.result(), 32);
    std::string final_hash_hex = binarytohex((const unsigned char*)final_hash, 32);
    if (flagdebug)
        myprintf("70783: Final_hash_hex    %s\n",final_hash_hex.c_str());
    
    // Create result string
    char result_buffer[4096];
    snprintf(result_buffer, sizeof(result_buffer), "franzhash:%s:%d:", i_tipohash.c_str(), num_threads);
    for (int i = 0; i < num_threads - 1; i++) {
        char temp_buffer[32];
        snprintf(temp_buffer, sizeof(temp_buffer), "%s", int64_to_string(offsets[i + 1]).c_str());
        strcat(result_buffer, temp_buffer);
        if (i < num_threads - 2) {
            strcat(result_buffer, "-");
        }
    }
    strcat(result_buffer, "-");
    strcat(result_buffer, final_hash_hex.c_str());

    return std::string(result_buffer);
}





int Jidac::benchmark()
{
/*
	printf("Inizio test\n");
	franzcri cri("pippo",strlen("pippo"));
	if (!cri.open("z:\\okane.franzen", true))
	{
        perror("Error creating output file");
        return 0;
    }
	char sale[32]={0};
	char resto[48]={0};
	for (unsigned int i=0;i<32;i++)
		sale[i]=i;
	for (unsigned int i=0;i<48;i++)
			resto[i]=250;
	cri.write(sale,32);
	cri.write(resto,48);
	
	char singolo=255;
	cri.writeat(10,&singolo,1);
    cri.close();
	printf("done\n");
	return 0;
*/
	pc_info();

	vector<string> 	array_cpu;
	vector<float> 	array_single;
	vector<float> 	array_multi;
	

	array_cpu	.push_back("AL314 (A15) 1.7G (phy)  2");
	array_multi	.push_back(51);
	array_single.push_back(355);
	array_cpu	.push_back("Atom N2800       (phy)  4");
	array_multi	.push_back(113);
	array_single.push_back(407);
	array_cpu	.push_back("Celeron J4125 2G (phy)  4");
	array_multi	.push_back(487);
	array_single.push_back(1302);
	array_cpu	.push_back("Xeon E3 1245 V2  (vir)  4");
	array_multi	.push_back(819);
	array_single.push_back(2415);
	array_cpu	.push_back("Celeron N5105    (phy)  4");
	array_multi	.push_back(479);
	array_single.push_back(1818);
	array_cpu	.push_back("i5-6200U         (phy)  2");
	array_multi	.push_back(352);
	array_single.push_back(1903);
	array_cpu	.push_back("Xeon E5 2620 V4  (phy)  8");
	array_multi	.push_back(1520);
	array_single.push_back(1848);
	array_cpu	.push_back("Xeon E5 2630 V4  (phy) 10");
	array_multi	.push_back(1596);
	array_single.push_back(1552);
	array_cpu	.push_back("Xeon D-1541      (vir)  8");
	array_multi	.push_back(1619);
	array_single.push_back(2031);
	array_cpu	.push_back("i5-3570          (phy)  4");
	array_multi	.push_back(852);
	array_single.push_back(2956);
	array_cpu	.push_back("Intel N100       (phy)  4");
	array_multi	.push_back(900);
	array_single.push_back(3128);
	array_cpu	.push_back("i7-4790K         (phy)  4");
	array_multi	.push_back(1700);
	array_single.push_back(3265);
	array_cpu	.push_back("i7-8700K         (phy)  6");
	array_multi	.push_back(1836);
	array_single.push_back(3358);
	array_cpu	.push_back("AMD-Ryzen 7 3700X(phy)  8");
	array_multi	.push_back(2066);
	array_single.push_back(3256);
	array_cpu	.push_back("Ryzen 5825U      (phy)  8");
	array_multi	.push_back(1764);
	array_single.push_back(3941);
	array_cpu	.push_back("i9-9900K         (phy)  8");
	array_multi	.push_back(2639);
	array_single.push_back(3831);
	array_cpu	.push_back("i9-10900         (phy) 10");
	array_multi	.push_back(3049);
	array_single.push_back(3705);
	array_cpu	.push_back("AMD-3950X        (phy) 16");
	array_multi	.push_back(4677);
	array_single.push_back(4160);
	array_cpu	.push_back("AMD-5950X        (phy) 16");
	array_multi	.push_back(5843);
	array_single.push_back(4798);
	array_cpu	.push_back("i9-12900KS 56400 (phy) 16");
	array_multi	.push_back(6928);
	array_single.push_back(5403);
	array_cpu	.push_back("AMD-7950X3D      (phy) 16");
	array_multi	.push_back(7733);
	array_single.push_back(5517);
	

	int			chunksize=100000;
	int			timelimit=5;
	if (all)
		timelimit=20;
	if (menoenne>0)
	{
		if (menoenne<1000)
			timelimit=menoenne;
		else
		{
			myprintf("02282: Time limit (-n    -limit) must be <1000\n");
			return 1;
		}
	}
	if (minsize>0)
	{
		if (minsize<=2000000000)
			chunksize=minsize/4;
		else
		{
			myprintf("02283: Chunk (-minsize) must be <= 2000000000 (2 billion)\n");
			return 1;
		}
	}
	uint32_t *buffer32bit = (uint32_t*)franz_malloc(chunksize*sizeof(uint32_t));
	///g_allocatedram+=chunksize*sizeof(uint32_t);
	if (buffer32bit==NULL)
	{
		myprintf("02284: GURU cannot alloc the buffer32bit\n");
		return 1;
	}
	uint8_t *buffer8bit=(uint8_t*)franz_malloc(chunksize*sizeof(uint8_t));
	if (buffer8bit==NULL)
	{
		myprintf("02285! GURU cannot alloc the buffer8bit\n");
		franz_free(buffer32bit);
		return 2;
	}
	///g_allocatedram+=chunksize*sizeof(uint8_t);
	
	vector<string> thehashes;
	string hashes="";
	if (!ischecksum())
		hashes="XXHASH64;XXH3;SHA-1;SHA-256;BLAKE3;CRC-32;CRC-32C;WYHASH;WHIRLPOOL;MD5;SHA-3;NILSIMSA;HIGHWAY64";

	else
	{
		if (flagxxhash64)
			hashes+="XXHASH64;";
		if (flagxxh3)
			hashes+="XXH3;";
		if (flagsha1)
			hashes+="SHA-1;";
		if (flagsha256)
			hashes+="SHA-256;";
		if (flagblake3)
			hashes+="BLAKE3;";
		if (flagcrc32)
			hashes+="CRC-32;";
		if (flagcrc32c)
			hashes+="CRC-32C;";
		if (flagwyhash)
			hashes+="WYHASH;";
		if (flagwhirlpool)
			hashes+="WHIRLPOOL;";
		if (flagmd5)
			hashes+="MD5;";
		if (flaghighway64)
			hashes+="HIGHWAY64;";
		if (flagnilsimsa)
			hashes+="NILSIMSA;";
		if (flagsha3)
			hashes+="SHA-3;";

	}
	explode(hashes,';',thehashes);
	if (thehashes.size()==0)
	{
		myprintf("02286: strange hash selection\n");
		franz_free(buffer32bit);
		franz_free(buffer8bit);
		return 1;
	}
	if (all)
		if ((thehashes.size()!=1) && (thehashes.size()!=13))
		{
			myprintf("02287: When benchmarking with -all (multithread), ONE algo or nothing (all)\n");
			franz_free(buffer32bit);
			franz_free(buffer8bit);
			return 1;
		}

	if (thehashes.size()==13)
		if (flaghw)
		{
			myprintf("02288: HW disabled, because franzomips. Choose one to keep (ex -sha256)\n");
			flaghw=false;
		}
	vector<s_benchmark> 			vettorerisultati;
	vector<tparametribenchmark> 	vettoreparametribenchmark; // pthread
	myprintf("02289: Benchmarks: ");
	for (unsigned int i=0;i<thehashes.size();i++)
		myprintf("%s ",thehashes[i].c_str());
	myprintf("\n");
	myprintf("02290: Time limit %10d s  (-n X)\n",timelimit);
	myprintf("02291: Chunks of  %12s  (-minsize Y)\n",tohuman(chunksize*4));
	myprintf("\n");
	double			franzomips=0;
	if (all)
	{
		flaght=true; //we want to cook!
		int mythreads=howmanythreads;
		tparametribenchmark	myblock;
		for (int i=0;i<mythreads;i++)
		{
			myblock.speed=0;
			myblock.tnumber=i;
			myblock.chunksize=chunksize;
			myblock.buffer32bit=buffer32bit;
			myblock.timelimit=timelimit;
			if (thehashes.size()==13)
				myblock.runningalgo="SHA-3";
			else
				myblock.runningalgo=thehashes[0];
			vettoreparametribenchmark.push_back(myblock);
		}
		int rc;
		pthread_t* threads = new pthread_t[mythreads];
		g_allocatedram+=sizeof(pthread_t)*mythreads;
		pthread_attr_t attr;
		void *status;
		// ini and set thread joinable
		pthread_attr_init(&attr);
		pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_JOINABLE);
		if ((!flagsilent) && (!flagnoconsole))
		{
			setupConsole();
			printf("\033[2J"); //cls
			restoreConsole();
		}
		for(int i = 0; i < mythreads; i++ )
		{
			rc 	= pthread_create(&threads[i], &attr, benchmark_thread, (void*)&vettoreparametribenchmark[i]);
			if (rc)
			{
				myprintf("02292: Error creating thread\n");
				exit(-1);
			}
		}
		pthread_attr_destroy(&attr);
		for(int i = 0; i <mythreads; i++ )
		{
			rc = pthread_join(threads[i], &status);
			if (rc)
			{
				error("Unable to join\n");
				exit(-1);
			}
		}
		if ((!flagsilent) && (!flagnoconsole))
		{
			setupConsole();
			printf("\033[2J"); //cls
			printf("\033[%d;0H",(int)1);
			restoreConsole();
		}


		double total_speed=0;
		for (int i=0;i<mythreads;i++)
		{
			total_speed+=vettoreparametribenchmark[i].speed;
			franzomips+=vettoreparametribenchmark[i].speed;
		}
		myprintf("02293: Total speed %s /s\n",tohuman((int64_t)total_speed));
		if (thehashes.size()==13)
		{
			franzomips/=1000000;
			for (unsigned int i=0;i<array_cpu.size();i++)
				array_multi[i]=franzomips/array_multi[i]*100.0;
		}
		delete [] threads;
	}
	else
	{
/// NO pthread
		string 			risultato;
		double			speed;
		s_benchmark		block;
		for (unsigned int i=0;i<thehashes.size();i++)
		{
			risultato=do_benchmark(-1,timelimit,thehashes[i],chunksize,buffer32bit,speed);
			block.algoritmo=thehashes[i];
			block.speed=speed;
			block.risultati=risultato;
			vettorerisultati.push_back(block);
			if ((thehashes[i]!="BLAKE3") && (thehashes[i]!="HIGHWAY64")) // no HW implementation, please
				franzomips+=speed;
		}
		/// magic 3500 single 4875 (5885 multi
		if (thehashes.size()==13)
		{
			franzomips/=thehashes.size()-2;
			franzomips/=1000000;
			for (unsigned int i=0;i<array_cpu.size();i++)
				array_single[i]=franzomips/array_single[i]*100.0;
		}
		std::sort(vettorerisultati.begin(), vettorerisultati.end(), compare_s_benchmark);
		myprintf("\n");
		myprintf("02294: Results:\n\n");
		for (unsigned int i=0;i<vettorerisultati.size();i++)
			myprintf("02295: %s\n",vettorerisultati[i].risultati.c_str());
	}
	franz_free(buffer32bit);
	franz_free(buffer8bit);
		
	///sysctl hw.model hw.machine hw.ncpu
	if (thehashes.size()==13)
	{
		myprintf("\n");
		if (all)
			myprintf("02296: franzomips multi thread index %s ",migliaia((int64_t)(franzomips*7.0)));
		else
			myprintf("02297: franzomips single thread index %s ",migliaia((int64_t)franzomips));
		myprintf(" (quick CPU check, raw %s)\n",migliaia((int64_t)franzomips));
		for (unsigned int i=0;i<array_cpu.size();i++)
			if (all)
				myprintf("%s %10.2f %%\n",array_cpu[i].c_str(),array_multi[i]);
			else
				myprintf("%s %10.2f %%\n",array_cpu[i].c_str(),array_single[i]);
	}
	return 0;
}




string	Jidac::get_lastfilename(string i_file,int64_t& o_totalfilesize)
{
	o_totalfilesize=0;
	if (i_file=="")
	{
		myprintf("02298: empty filename\n");
		return "";
	}
	if (!isjolly(i_file))
	{
		myprintf("02299: no jolly (you must insert some kind of ? sequence)\n");
		return i_file;
	}
	if (flagdebug)
	{
		myprintf("02300: Jolly in archivefile!\n");
		myprintf("02301: Searching for jolly archive(s) in <<%s>>\n",i_file.c_str());
	}

	DTMap thedt;
	flagforcezfs=true;
	g_arraybytescanned.clear();
	g_arrayfilescanned.clear();
	g_arraybytescanned.push_back(0);
	g_arrayfilescanned.push_back(0);
	string onlypath=extractfilepath(i_file);
	string onlyname=extractfilename(i_file);
	myreplace(onlyname,"????????.zpaq","");
	myreplace(onlyname,".zpaq","");

	if (flagdebug3)
	{
		myprintf("02302: scan by   %s\n",onlypath.c_str());
		myprintf("02303: filename  %s\n",i_file.c_str());
		myprintf("02304: onlyname  %s\n",onlyname.c_str());
	}
	myscandir(0,thedt,onlypath,false,false);
	if (!flagpakka)
	{
		printbar(' ',false);
		myprintf("\r");
	}

	if (flagdebug2)
		myprintf("02305: scanned %s\n",migliaia(thedt.size()));

	if (thedt.size()==0)
	{
		myprintf("02306: no archive => quit\n");
		return "";
	}
	if (flagdebug3)
		myprintf("02307: Founded %s files(s), sorting\n",migliaia(thedt.size()));

	vector<string> filenamearray;
	for (DTMap::iterator p=thedt.begin(); p!=thedt.end(); ++p)
	{
		string temp		=extractfilename(p->first);
		if (isbackuppart(temp,onlyname))
		{
			filenamearray.push_back(temp);
			o_totalfilesize+=p->second.size;
		}
	}
	if (filenamearray.size()==0)
	{
		if (flagdebug)
			myprintf("02308: No single match\n");
		return "";
	}

	std::sort(filenamearray.begin(),filenamearray.end());

	string thelastone=filenamearray[filenamearray.size()-1];

	string srisultato=extractfilepath(i_file)+thelastone;
	if (!fileexists(srisultato))
	{
		if (flagdebug)
			myprintf("02309: srisultato does not exits |%s|\n",srisultato.c_str());
		return "";
	}
	return srisultato;
}
int Jidac::summa()
{
	if (flaghome)
		return sumhome();

	if (orderby!="")
		flagnosort=true;
	
	if (flagnosort)
		if (orderby=="")
			orderby="full";
		
	if (flaghashdeep)
		if (g_output=="")
		{
			myprintf("02310! with -hashdeep you need an output file -out something.txt\n");
			return 2;
		}
	if (checktxt!="")
	{
		if (files.size()!=1)
		{
			myprintf("02311! You need exactly ONE file to be checked\n");
			return 2;
		}
		string thelastzpaq=files[0];
		if (strrchr(files[0].c_str(), '?'))
		{
			int64_t dummysize;
			thelastzpaq=get_lastfilename(files[0],dummysize);
			myprintf("02312: the lastzpaq |%s|\n",thelastzpaq.c_str());
		}

		if (!fileexists(files[0]))
		{
			myprintf("02313! Abort, the first file does not exists\n",checktxt.c_str());
			return 2;
		}
		if (flagchecktxt)
			if ((checktxt=="") || (checktxt==".txt"))
			{
				string 	percorso	=extractfilepath(files[0]);
				string	nome		=prendinomefileebasta(files[0]);
				checktxt			=percorso+nome+"_md5.txt";
			}
		if (strrchr(checktxt.c_str(), '?'))
		{
			int64_t dummysize;
			checktxt=get_lastfilename(checktxt,dummysize);
			myprintf("02314: The lasttxt |%s|\n",checktxt.c_str());
		}

		if (!fileexists(checktxt))
		{
			myprintf("02315! Abort, -checktxt %s does not exists\n",checktxt.c_str());
			return 2;
		}
		myprintf("02316: Checking MD5 (because of -checktxt) on %s\n",checktxt.c_str());

		int64_t	dimensionefile=prendidimensionefile(checktxt.c_str());
		char linebuffer[1000];
		if ((uint64_t)dimensionefile>sizeof(linebuffer))
		{
			myprintf("02317! The -checktxt file seems way too big %s\n",migliaia(dimensionefile));
			return 2;
		}

		if (dimensionefile<64)
		{
			myprintf("02318! The -checktxt file seems too small %s\n",migliaia(dimensionefile));
			return 2;
		}

		FILE* inFile = freadopen(checktxt.c_str());
		if (inFile==NULL)
		{
#ifdef _WIN32
		DWORD err=GetLastError();
#else
		int err=1;
#endif // corresponds to #ifdef (#ifdef _WIN32)
			myprintf("\n");
			myprintf("02319! ERR <%s> kind %s\n",checktxt.c_str(),migliaia((int64_t)err));
			return 2;
		}
		const int letti=fread(linebuffer,1,sizeof(linebuffer),inFile);
		fclose(inFile);
		if (flagdebug3)
			myprintf("02320: Readed %d\n",letti);
		string hashletto="";
		int i=0;

		while (i<letti)
		{
			if (isdigit(linebuffer[i]) || (isalpha(linebuffer[i])))
				hashletto+=linebuffer[i++];
			else
				break;
		}
		myprintf("02321: MD5 hash from checktxt |%s| ",hashletto.c_str());

		string nomefile="";
		for (int j=i+1;j<letti;j++)
			if (linebuffer[j]!='|')
				nomefile+=linebuffer[j];
			else
				break;
		printUTF8(nomefile.c_str());
		myprintf("\n");

///dc0b4528c42b4e8d3e6e8b571a77b842 z:/pippo_0011_md5.txt|[            1.583.833] 2023-04-17 15:07:09


		int64_t startverify	=mtime();
		int64_t larghezzain	=prendidimensionefile(thelastzpaq.c_str());
		g_dimensione		=0;
		franz_do_hash dummy("MD5");
		if (flagdebug3)
			myprintf("02322: filehash on %s\n",thelastzpaq.c_str());

		string hashreloaded=dummy.filehash(0,thelastzpaq,false,startverify,larghezzain);

		myprintf("02323: MD5 recalculated       |%s| %Z\n",hashreloaded.c_str(),thelastzpaq.c_str());
		

		string temp=nomefile;
		myreplace(temp,"_md5.txt","");
		string solonomehash=stringtolower(prendinomefileebasta(temp));
		string solonomefile=stringtolower(prendinomefileebasta(thelastzpaq));

		myprintf("02324: Filename in checktxt   |%Z|\n",solonomehash.c_str());
		

		myprintf("02325: Filename to test       |%Z|\n",solonomefile.c_str());
		printbar('-');

		hashreloaded=stringtolower(hashreloaded);
		hashletto	=stringtolower(hashletto);

		if ((hashreloaded=="") || (hashreloaded!=hashletto))
		{
			myprintf("02326! ****  ERROR: FILE DOES NOT MATCH WITH THE CHECKSUM  ****\n");
			myprintf("02327! ****               THIS IS VERY BAD                 ****\n");
			myprintf("\n\n");
			return 2;
		}
		myprintf("02328: MD5 matched\n");

		return 0;
	}

	if ((!flagpakka) && (!flaghashdeep))
	{
		myprintf("02329: Getting %s",g_thechosenhash_str.c_str());
		if (flagmm)
			myprintf(" WITH MEMORY MAPPED FILES ");
		if (!flagforcezfs)
			myprintf(" ignoring .zfs and :$DATA\n");
	}
	if (flagkill)
		if (flagforce)
			if (!getcaptcha("iamsure","Delete files without confirmation"))
				return 1;

	if (flagrename)
		if (!flagforce)
		{
			if (!getcaptcha("y","Rename ALL FILES without confirmation?"))
				return 1;
		}

	if (flaghashdeep)
	{
		string hashdeepalgo="";
		if (flagmd5)
			hashdeepalgo="md5";
		else
		if (flagsha1)
			hashdeepalgo="sha1";
		else
		if (flagsha256)
			hashdeepalgo="sha256";
		else
		if (flagwhirlpool)
			hashdeepalgo="whirlpool";
		else
		{
			myprintf("02330! hashdeep algos MUST be md5 | sha1 | sha256 | whirlpool\n");
			return 2;
		}
		flagnoeta=true;
		myprintf("%%%%%%%% zpaqfranz " ZPAQ_VERSION "\n");
		myprintf("%%%%%%%% size,%s,filename\n",hashdeepalgo.c_str());

		myprintf("## invoked @ ");
		print_datetime();
		myprintf("\n");

		for (unsigned int i=0;i<files.size();i++)
		{
			myprintf("## files %08d %Z\n",i,files[i].c_str());
		}
		myprintf("##\n");
	}
	int quantifiles					=0;
	int64_t total_size				=0;
	unsigned int duplicated_files	=0;
	uint64_t duplicated_size		=0;
	uint64_t scannedsize			=0;
	vector<string> myfiles;
	flagskipzfs					=true;  // strip down zfs
	int64_t startscan=mtime();
	g_bytescanned=0;
	g_filescanned=0;
	g_dimensione=0;
	g_worked=0;
	vector<string> mydirs;


	exclude_output();
	
	for (unsigned i=0; i<files.size(); ++i)
	{
		string thepath=fix_scandir(files[i]);
		scandir(true,edt,thepath,!flagnorecursion);
	}
	eol();

	///myprintf("02332: edt size %s\n",migliaia(edt.size()));
	if (flagverify)
	{
//	deduplication: I am very lazy, so do a lot of copy
		myprintf("\n");
		myprintf("02333: *** Searching for duplicates with %s minsize %s ***\n",g_thechosenhash_str.c_str(),migliaia(minsize));
// get size and name
		std::vector<s_pair_intstring> filestobepurged;
		for (DTMap::iterator p=edt.begin(); p!=edt.end(); ++p)
			if (p->second.date && p->first!="" && (!isdirectory(p->first)) && (!isads(p->first)) )
			{
				if (minsize>0)
				{
					if ((uint64_t)p->second.size>minsize)
					{
						s_pair_intstring mypair;
						mypair.first=p->second.size;
						mypair.second=p->first;
						filestobepurged.push_back(mypair);
						///filestobepurged.push_back(make_pair(p->second.size,p->first));
						scannedsize+=p->second.size;
					}
				}
				else
				{
					s_pair_intstring mypair;
					mypair.first=p->second.size;
					mypair.second=p->first;
					filestobepurged.push_back(mypair);
					scannedsize+=p->second.size;
				}
			}
// ok, let's purge
		std::sort(filestobepurged.begin(), filestobepurged.end(),pairsortbyfirst);
		myfiles.clear();
		unsigned int i=0;
// get only files with equal size
// from filestobepurged to myfiles
		while (i<filestobepurged.size())
		{
			int j=i;
			if (filestobepurged[j].first==filestobepurged[j+1].first)
			{
				myfiles.push_back(filestobepurged[j].second);
				total_size+=filestobepurged[j].first;
				quantifiles++;
			}
			while (filestobepurged[j].first==filestobepurged[j+1].first)
			{
				myfiles.push_back(filestobepurged[j+1].second);
				total_size+=filestobepurged[j+1].first;
				quantifiles++;
				j++;
			}
			j++;
			i=j;
		}
	}
	else
	{
//	default: get everything
		for (DTMap::iterator p=edt.begin(); p!=edt.end(); ++p)
			if (p->second.date && p->first!="" && (!isdirectory(p->first)) && (!isads(p->first)) )
			{
				if (minsize>0)
				{
					if ((uint64_t)p->second.size>minsize)
					{
						myfiles.push_back(p->first);
						total_size+=p->second.size;
						quantifiles++;
					}
				}
				else
				{
					myfiles.push_back(p->first);
					total_size+=p->second.size;
					quantifiles++;
				}
			}
		scannedsize=total_size;
	}
	if (myfiles.size()==0)
	{
		myprintf("02334: Nothing to do\n");
		return 0;
	}
	if (flaglast)
	{
		if (!myfiles.empty()) 
		{
			if (flagdebug)
				myprintf("71008: getting only -last\n");
			std::string last = myfiles.back(); // Save the last element
			myfiles.clear();                   // Empty the vector
			myfiles.push_back(last);          // Add the last element
		}
	}

	vector<string> myhash;
	vector<tparametrihash> 	vettoreparametrihash;
	vector<s_stringpair> vec;
	int mythreads=howmanythreads;
	if (!flagssd)
		mythreads=1;
	uint64_t iniziohash;
	double scantime;

	if (flagnosort)
		if (orderby!="")
		{
			if (flagverbose)
			{
				myprintf("02335: Sorting output  (orderby |%s|) ",orderby.c_str());
				if (flagdesc)
					myprintf(" descending");
				myprintf("\n");
			}
			if (flagdebug3)
				for (unsigned int i=0;i<myfiles.size();i++)
					myprintf("02336: PRE  %s\n",myfiles[i].c_str());
			vector<DTMap::iterator> filelist;
			for (unsigned int i=0;i<myfiles.size();i++)
				filelist.push_back(edt.find(myfiles[i]));
			sort(filelist.begin(),filelist.end(),compareorderby);
			myfiles.clear();
			for (unsigned int i=0;i<filelist.size();i++)
				myfiles.push_back(filelist[i]->first);
			if (flagdebug3)
				for (unsigned int i=0;i<myfiles.size();i++)
					myprintf("02337: POST %s\n",myfiles[i].c_str());
		}

	if (mythreads==0)
	{
		myprintf("73637: Error, mythreads==0!\n");
		mythreads=1;
	}
	
	if (mythreads==1)
	{
		printbar(' ');
		int64_t inizio		=mtime();
		scantime=(inizio-startscan)/1000.0;
		if (!flagnoeta)
			myprintf("02338: No multithread: Found (%s) => %s bytes (%s) / %s files in %f\n",tohuman2(scannedsize),migliaia(total_size),tohuman(total_size),migliaia2(quantifiles),scantime);
		if ((flagverbose) && (!flaghashdeep))
			myprintf("02339: Total files %s\n",migliaia(myfiles.size()));
		iniziohash=mtime();
		g_dimensione=0;

		for (unsigned int i=0;i<myfiles.size();i++)
		{
			if (flagdebug3)
				myprintf("02340: franz_do_hash\n");

			franz_do_hash dummy(g_thechosenhash);
			if (flagdebug3)
				myprintf("02341: filehash on %s\n",myfiles[i].c_str());

			string risu=dummy.filehash(0,myfiles[i],false,inizio,total_size);
			if ((!flaghashdeep) && (flagnosort))
			{
				int printlen=0;
				if (flagpakka)
				{
					myprintf("02342: %s ",stringtolower(risu).c_str());
					printlen=risu.size()+2;
				}
				else
				{
					myprintf("02343: |%s: %s [%19s] |",dummy.i_hashtype2.c_str(),risu.c_str(),migliaia(dummy.o_thefilesize));
					printlen=dummy.i_hashtype2.size()+risu.size()+19+8;
				}
				
				printUTF8(myfiles[i].c_str());
				printlen+=myfiles[i].size();
				if (printlen<68)
				{
					string temp;
					while (printlen++<68)
						temp+=" ";
					myprintf("%s",temp.c_str());
				}
				myprintf("\n");
			}

			s_stringpair mypair;
			mypair.first=myfiles[i];
			mypair.second=risu;
			vec.push_back(mypair);
		}
	}
	else
	{
		tparametrihash 	myblock;
		for (int i=0;i<mythreads;i++)
		{
			myblock.tnumber=(i%mythreads);
			myblock.inizio=mtime();
			myblock.dimensione=total_size;
			myblock.timestart=0;
			myblock.timeend=0;
			vettoreparametrihash.push_back(myblock);
		}
		if (!flaghashdeep)
			printbar(' ');
		int64_t inizio		=mtime();
		scantime=(inizio-startscan)/1000.0;
		if (!flagnoeta)
			myprintf("02344: Found (%s) => %s bytes (%s) / %s files in %f\n",tohuman2(scannedsize),migliaia(total_size),tohuman(total_size),migliaia2(quantifiles),scantime);
		for (unsigned int i=0;i<myfiles.size();i++)
		{
			vettoreparametrihash[i%mythreads].filestobehashed.push_back(myfiles[i]);
			vettoreparametrihash[i%mythreads].algo.				push_back(g_thechosenhash_str.c_str());
		}
		int totfile=0;
		for (int i=0;i<mythreads;i++)
		{
			if (flagdebug3)
				myprintf("02345: Thread [%02d] files %s\n",(int)i,migliaia(vettoreparametrihash[i].filestobehashed.size()));
			totfile+=+vettoreparametrihash[i].filestobehashed.size();
		}
		if (flagverbose)
			myprintf("02346: Total files %s -> in threads %s\n",migliaia(myfiles.size()),migliaia2(totfile));
		int rc;
		///pthread_t threads[mythreads];
		pthread_t* threads = new pthread_t[mythreads];
		g_allocatedram+=sizeof(pthread_t)*mythreads;
		pthread_attr_t attr;
		void *status;
			// ini and set thread joinable
		pthread_attr_init(&attr);
		pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_JOINABLE);
		if (!flagnoeta)
		{
			myprintf("\n");
			myprintf("02347: Creating %d hashing thread(s) with %s\n",mythreads,g_thechosenhash_str.c_str());
		}
		iniziohash=mtime();
		for(int i = 0; i < mythreads; i++ )
		{
			vettoreparametrihash[i].timestart=mtime();
			rc = pthread_create(&threads[i], &attr, scansionahash, (void*)&vettoreparametrihash[i]);
			if (rc)
			{
				myprintf("02348: Error creating thread\n");
				exit(-1);
			}
		}
		pthread_attr_destroy(&attr);

		for(int i = 0; i <mythreads; i++ )
		{
			rc = pthread_join(threads[i], &status);
			if (rc)
			{
				error("Unable to join\n");
				exit(-1);
			}
		}
		delete [] threads;
		for(int i = 0; i <mythreads; i++ )
			for (unsigned int j=0;j<vettoreparametrihash[i].filestobehashed.size();j++)
			{
				s_stringpair mypair;
				mypair.first=vettoreparametrihash[i].filestobehashed[j];
				mypair.second=vettoreparametrihash[i].o_hashcalculated[j];
				vec.push_back(mypair);
			}
	}
	int64_t hashtime=mtime()-iniziohash+1;

	if ((!flagnosort) || (flagverify) || (flagcollision))
		std::sort(vec.begin(), vec.end(),pairsortbyval);

	libzpaq::SHA256 sha256;
	int64_t startprint		=mtime();
	uint64_t testedbytes	=0;
	int64_t deletedfiles	=0;
	int64_t deletedsize		=0;
	int64_t	renamedfiles	=0;
	int64_t notrenamed		=0;
	int	errori				=0;
	vector<string> sortato;
	vector<string> undofrom;
	vector<string> undoto;

	if (!flagnosort)
	for (unsigned int i=0;i<vec.size();i++)
	{
		string filename=vec[i].first;
		if (!flagignore)
		if (vec[i].second=="")
		{
			myprintf("02349: ERROR hash is empty <<%Z>>\n",filename.c_str());
		}

		DTMap::iterator p=edt.find(filename);
		if (p != edt.end())
			testedbytes+=p->second.size;
		else
		{
			myprintf("02350! GURU edt not found %08d %s\n",(int)i,filename.c_str());
			seppuku();
			return 2;
		}
		for (const char* p=vec[i].second.c_str(); *p; ++p)
			sha256.put(*p);
		franzreplace(filename);
		
		if (flaghashdeep)
		{
			string lowhash=stringtolower(vec[i].second);
			myprintf("%lld,%s,%Z\n",p->second.size,lowhash.c_str(),filename.c_str());
			
		}
		else
		if (flagrename)
		{
			if (vec[i].second!="")
			{
				string percorso=extractfilepath(filename);
				string newfilename=percorso+vec[i].second.c_str();

				if (extractfilename(newfilename)!=extractfilename(filename))
				{
					undofrom.push_back(filename);
					undoto.push_back(newfilename);
					if (myrename(filename,newfilename)==0)
						renamedfiles++;
				}
				else
					notrenamed++;
			}
		}
		else
		if (flagkill)
		{
// delete
			if (i>0)
				if (vec[i-1].second==vec[i].second)
				{
					if (summary<0)
					{
#if defined(_WIN32)
						myreplaceall(filename,"/","\\");
#endif // corresponds to #if (#if defined(_WIN32))
						myprintf("=== \"");
						if (g_output_handle!=0)
							fprintf(g_output_handle,"    \"");
						printUTF8(filename.c_str());
						myprintf("\"\n");
					}
					duplicated_files++;
					if (p != edt.end())
						duplicated_size+=p->second.size;
					if (flagforce)
						if (delete_file(filename.c_str()))
						{
							deletedfiles++;
							if (p != edt.end())
								deletedsize+=p->second.size;
						}
				}
		}
		else
		{
			if (summary<0)
			{
				if (flagpakka)
					myprintf("%s ",stringtolower(vec[i].second).c_str());

				else
				{
					myprintf("|%s: %s ",g_thechosenhash_str.c_str(),vec[i].second.c_str());
					if (p != edt.end())
						myprintf("[%19s] ",migliaia(p->second.size));
				}
			}
			if (!flagnosort)
			{
				if (i==0)
				{
					if (!flagpakka)
						if (summary<0)
							myprintf("    ");
				}
				else
				{
					if (vec[i-1].second==vec[i].second)
					{
						if (summary<0)
						{
							myprintf("=== ");
					///		if (g_output_handle!=0)
						///		fprintf(g_output_handle,"    ");
						}
						duplicated_files++;
						if (p != edt.end())
							duplicated_size+=p->second.size;
					}
					else
					{
						if (!flagpakka)
							if (summary<0)
								myprintf("    ");
					}
				}
			}
			if (summary<0)
			{
				if (!flagpakka)
					myprintf("|");
				printUTF8(filename.c_str());
				myprintf("\n");
			}
			/// check if, for some reason, we cannot read a file (ex. corrupted, ACL etc)
			//  beware: does not work for ZETA
			if ((!flagzeta) && (!flagzetaenc))
			if ((p->second.size)>0)
			{
				if (vec[i].second==emptyalgo(g_thechosenhash_str))
				{
					myprintf("\n\n");
					myprintf("02351: **** GURU ERROR non zero-length file get empty hash!\n");
					myprintf("02352: **** A non-empty file have the same hash of empty one!\n");
					myprintf("\n\n");
					errori=2;
				}
			}
		}
	}
	int64_t printtime=mtime()-startprint;
	if (flagrename)
	{
		for (unsigned int i=0;i<undofrom.size();i++)
		{
			printUTF8(undoto[i].c_str());
			myprintf(" => ");
			printUTF8(undofrom[i].c_str());
			myprintf("\n");
		}
		myprintf("02353: Renamed     files  %s\n",migliaia(renamedfiles));
		myprintf("02354: NOT renamed files  %s\n",migliaia(notrenamed));

	}
	if (summary>0)
	{
		myprintf("02355: Scanning filesystem time  %15.3f s\n",scantime);
		myprintf("02356: Data transfer+CPU   time  %15.3f s\n",hashtime/1000.0);
		myprintf("02357: Data output         time  %15.3f s\n",printtime/1000.0);
		myprintf("02358: Total size                %19s (%10s)\n",migliaia(scannedsize),tohuman(scannedsize));
		myprintf("02359: Tested size               %19s (%10s)\n",migliaia(testedbytes),tohuman(testedbytes));
		if (!flagnosort)
		{
		myprintf("02360: Duplicated size           %19s (%10s)\n",migliaia(duplicated_size),tohuman(duplicated_size));
		myprintf("02361: Duplicated files          %19s\n",migliaia(duplicated_files));
		}
		int64_t myspeed=(int64_t)(testedbytes*1000.0/(hashtime));
		myprintf("02362: Worked on %s bytes avg speed (hashtime) %s B/s\n",migliaia(total_size),migliaia2(myspeed));
		char sha256result[32];
		memcpy(sha256result, sha256.result(), 32);
		myprintf("02363: GLOBAL SHA256: ");
		for (int j=0; j <= 31; j++)
			myprintf("%02X", (unsigned char)sha256result[j]);
		myprintf("\n");
	}
	if (flagkill)
		if (flagforce)
			if (deletedfiles)
				myprintf("02364: Duplicated deleted files %s for %s bytes\n",migliaia2(deletedfiles),migliaia(deletedsize));

	return errori;
}


#ifdef _WIN32
/*
	Very, very advanced encryption here :-)
*/
void scambia(string& i_str)
{
    int n=i_str.length();
    for (int i=0;i<n/2;i++)
        std::swap(i_str[i],i_str[n-i-1]);
}
string ahahencrypt(string i_string)
{
	string risultato="";
	for (unsigned int i=0;i<i_string.size();i++)
        risultato+=i_string[i] ^33;
    return risultato;
}
#endif // corresponds to #ifdef (#ifdef _WIN32)


///	decode the mime64 into memory (~150KB, not very big),
///	then decompress by zpaq checking sha-256
/// write into i_outfile
#ifdef ZPAQFULL ///NOSFTPSTART
#ifdef _WIN32
int Jidac::decompress_sfx_to_file(FILE* i_outfile)
{
#ifdef _WIN32
	if (i_outfile==NULL)
		return 0;
	///	put down the zsfx.exe
	size_t 	zsfx_exe_len=mimesize(zsfx_mime64);
	char*	zsfx_exe;
	zsfx_exe=(char*)franz_malloc(zsfx_exe_len);
	///g_allocatedram+=zsfx_exe_len;
	if (zsfx_exe==NULL)
	{
		myprintf("02367: error in malloc zsfx\n");
		return 0;
	}
	if (!mime2binary(zsfx_mime64,(unsigned char *)zsfx_exe,zsfx_exe_len))
	{
		myprintf("02368: mime decoder kaputt!\n");
		return 0;
	}
	Mymemreader 	in	(( unsigned char *)zsfx_exe,zsfx_exe_len);
	Myfilewriter 	out	(i_outfile,zsfx_exe_len,true);//yes, SHA-256
	libzpaq::decompress(&in,&out);
	franz_free(zsfx_exe);
	printbar(' ');
	myprintf("\r");

	char sha256result[32];
	memcpy(sha256result,out.thehash256.result(), 32);
	string calculatedhash=binarytohex((const unsigned char*)sha256result,32);


	if (calculatedhash!=zsfx_hash)
	{
		myprintf("\n");
		myprintf("02369: GURU SHA-256 calculated %s != expected %s\n",calculatedhash.c_str(),zsfx_hash.c_str());
		exit(2);
	}
	return out.written;
#else
	if (i_outfile==NULL)
		return 0;
	return 0;
#endif // corresponds to #ifdef (#ifdef _WIN32)
}
#endif // corresponds to #ifdef (#ifdef _WIN32)
int Jidac::writesfxmodule(const string i_filename)
{
#if defined(_WIN32)
	myprintf("\n\n");
	myprintf("02370: *** GOING SFX (zpaq resource)\n");
	if (g_password!=NULL)
	{
		myprintf("02371: this kind of SFX-ZPAQ does NOT support encryption (yet)\n");
		return 1;
	}
	if (i_filename=="")
	{
		myprintf("02372! sfx filename empty\n");
		return 2;
	}
	if (!fileexists(archive))
	{
		myprintf("02373! archive does not exists\n");
		return 2;
	}
	int64_t dimensionezpaq=prendidimensionefile(archive.c_str());
	if (dimensionezpaq>2000000000)
	{
		myprintf("02374! ZPAQ archive size %s\n",migliaia(dimensionezpaq));
		myprintf("02375! max .EXE size 2.000.000.000, abort\n");
		return 2;
	}
	string g_franzo_start	="dnE3pipUzeiUo8BMxVKlQTIfLjmskQbhlqBobVVr";
	scambia(g_franzo_start);
	string g_franzo_end		="xzUpA6PsHSE0N5Xe4ctJ2Gz7QTNLDyOXAp4kiEOo";
	scambia(g_franzo_end);
	string i_thecommands="x pippo.zpaq";
	if (g_sfxto!="")
		i_thecommands+=" -to "+g_sfxto;
	if (g_sfxflagforce)
		i_thecommands+=" -force";
	if (g_sfxflagall)
		i_thecommands+=" -all";
	if (sfxnotfiles.size()>0)
	{
		i_thecommands+=" -not ";
		for (unsigned int i=0;i<sfxnotfiles.size();i++)
			i_thecommands+=sfxnotfiles[i]+' ';
	}
	if (sfxonlyfiles.size()>0)
	{
		i_thecommands+=" -only ";
		for (unsigned int i=0;i<sfxonlyfiles.size();i++)
			i_thecommands+=sfxonlyfiles[i]+' ';
	}
	if (g_sfxuntil!="")
		i_thecommands+=" -until "+g_sfxuntil;
	myprintf("02376: Command line  : %s\n",i_thecommands.c_str());
	myprintf("02377: Archive name  : %s\n",archive.c_str());
	myprintf("02378: Output  name  : %s\n",i_filename.c_str());
	string outfile	=prendinomefileebasta(i_filename);
	string percorso	=extractfilepath(i_filename);
	outfile=percorso+outfile+".exe";
	if (fileexists(outfile))
		if (!flagforce)
		{
			myprintf("02379! output file exists and no -force, abort %s\n",outfile.c_str());
			return 2;
		}
	myprintf("02380: Working on    : %s\n",outfile.c_str());
	std::wstring widename=utow(outfile.c_str());
	FILE* outFile=_wfopen(widename.c_str(), L"wb" );
	if (outFile==NULL)
	{
		myprintf("02381! CANNOT OPEN outfile %s\n",outfile.c_str());
		return 2;
	}
	int zsfx_exe_len=decompress_sfx_to_file(outFile);
	if (zsfx_exe_len==0)
	{
		myprintf("02382: guru extracting sfx\n");
		fclose(outFile);
		seppuku();
	}
	size_t const 	blockSize = 65536;
	unsigned char 	buffer[blockSize];
	size_t 	readSize;
	/// yes, one byte at time. Why? Because some too smart compilers can substitute too much
	/// please note: the strings are already inverted
	for (unsigned int i=0;i<g_franzo_start.size();i++)
		fwrite(&g_franzo_start[i],1,1,outFile);
	/// High security!
	string ahahaencrypted=ahahencrypt(i_thecommands);
	for (unsigned int i=0;i<i_thecommands.size();i++)
		///fwrite(&i_thecommands[i],1,1,outFile);
		fwrite(&ahahaencrypted[i],1,1,outFile);
	for (unsigned int i=0;i<g_franzo_end.size();i++)
		fwrite(&g_franzo_end[i],1,1,outFile);
	///	Now append the .zpaq. Please note: no handling for multipart (in fact, not too hard)
	FILE* inFile = freadopen(archive.c_str());
	if (inFile==NULL)
	{
		int err=GetLastError();
		myprintf("\n");
		myprintf("02383! ERR <%s> on archive kind %d\n",archive.c_str(),err);
		return 2;
	}
	while ((readSize = fread(buffer, 1, blockSize, inFile)) > 0)
		fwrite(buffer,1,readSize,outFile);
	fclose(outFile);
	///	Just debug stuff
	myprintf("02384: SFX written on: %s\n",outfile.c_str());
	myprintf("\n");
	int64_t sfxsize	=zsfx_exe_len;
	int64_t zpaqsize=prendidimensionefile(archive.c_str());
	int64_t sfxtotal=prendidimensionefile(outfile.c_str());
	myprintf("02385: SFX module    : %19s\n",migliaia(sfxsize));
	myprintf("02386: Block1        : %19s\n",migliaia(g_franzo_start.size()));
	myprintf("02387: Command       : %19s\n",migliaia(i_thecommands.size()));
	myprintf("02388: Block2        : %19s\n",migliaia(g_franzo_end.size()));
	myprintf("02389: Start         : %19s\n",migliaia(sfxsize+g_franzo_start.size()+i_thecommands.size()+g_franzo_end.size()));
	myprintf("02390: ZPAQ archive  : %19s\n",migliaia(zpaqsize));
	myprintf("02391: Expected      : %19s\n",migliaia(sfxsize+zpaqsize+g_franzo_start.size()+g_franzo_end.size()+i_thecommands.size()));
	myprintf("02392: Written       : %19s\n",migliaia(sfxtotal));
#else
	myprintf("02393: sfx module supported only on Windows\n");
	return 0;
#endif // corresponds to #if (#if defined(_WIN32))
	if (i_filename=="GCC_COMP$ILER_BE_QUIET!!!")
		return 1;
	return 0;
}
#ifdef _WIN32
unsigned char *memmem(unsigned char *i_haystack,const size_t i_haystack_len,const char *i_needle,const size_t i_needle_len)
{
    int needle_first;
    unsigned char *p = i_haystack;
    size_t plen = i_haystack_len;
    if (!i_needle_len)
        return NULL;
    needle_first = *(unsigned char *)i_needle;
    while (plen >= i_needle_len && (p = (unsigned char*)memchr(p,needle_first,plen-i_needle_len + 1)))
    {
        if (!memcmp(p,i_needle,i_needle_len))
            return (unsigned char *)p;
        p++;
        plen=i_haystack_len-(p-i_haystack);
    }
    return NULL;
}
#endif // corresponds to #ifdef (#ifdef _WIN32)

int Jidac::sfx()
{
#if defined(_WIN32)

	if (isexe(archive))
	{
		if (tofiles.size()!=1)
		{
			myprintf("74718: You must use exactly one -to something\n");
			return 2;
		}
		myprintf("74715: Extracting .zpaq <<%Z>> from .exe <<%Z>>\n",tofiles[0].c_str(),archive.c_str());
		if (!flagforce)
			if (fileexists(tofiles[0]))
			{
				myprintf("74744: Abort, because the -to file already exists. -force to overrule\n");
				return 2;
			}
		if (!flagspace)
			if (!saggiascrivibilitacartella(tofiles[0]))
			{
				myprintf("\n");
				myprintf("00535: cannot write into <<%Z>> -space to bypass\n",tofiles[0].c_str());
				return 1;
			}
		int64_t exesize=prendidimensionefile(archive.c_str());
		if (exesize<100000)
		{
			myprintf("74745: Exe size way too small\n");
			return 2;
		}
		FILE* inFile=freadopen(archive.c_str());
		if (inFile==NULL) 
		{
			myprintf("20573! ERROR opening <<%Z>>\n",archive.c_str());
			return 2;
		}
		

	/// Assumption: the SFX module is smaller then 3MB
		size_t const blockSize = 3000000;
		size_t 	readSize;
		unsigned char *buffer=(unsigned char*)franz_malloc(blockSize);
		if (buffer==NULL)
		{
			myprintf("2281! cannot allocate memory, GURU!\n");
			seppuku();
		}
		
		myprintf("74768: Reading %s from <<%Z>>\n",migliaia(blockSize),archive.c_str());
		readSize = fread(buffer, 1, blockSize, inFile);

		if (readSize<=0)
		{
			myprintf("74774: very strange readsize\n");
			seppuku();
		}
	
		string g_franzo_end		="xzUpA6PsHSE0N5Xe4ctJ2Gz7QTNLDyOXAp4kiEOo";
		scambia(g_franzo_end);
		myprintf("74785: Searching end block...\n");
		unsigned char* endblock=memmem(buffer,readSize,g_franzo_end.c_str(),g_franzo_end.size());
	
		if (endblock==NULL)
		{
			myprintf("12316: cannot find endblock, does not seems a zpaqfranz sfx\n");
			fclose(inFile);
			franz_free(buffer);
			return 2;
		}
	
		int64_t offsetfromstart=(endblock-&buffer[0])+g_franzo_end.size();
		myprintf("74794: End founded, this is good, offset %s\n",migliaia(offsetfromstart));
		
		if (offsetfromstart>=exesize)
		{
			myprintf("74803: offset %s > exesize %s, this is not good\n",migliaia(offsetfromstart),migliaia2(exesize));
			fclose(inFile);
			franz_free(buffer);
			return 2;
		}

		int64_t expectedsize=exesize-offsetfromstart;
		fseeko(inFile,offsetfromstart,SEEK_SET);

		FILE* outFile=NULL;
		outFile=_wfopen(utow(tofiles[0].c_str()).c_str(), L"wb" );
		if (outFile==NULL)
		{
			myprintf("12345: CANNOT OPEN outfile <<%Z>>\n",tofiles[0].c_str());
			seppuku();
		}
	
		int64_t donesize=0;
		bool hostampato=false;
		int64_t startcopy=mtime();
		while ((readSize = fread(buffer,1, sizeof(buffer),inFile))>0)
		{
			int64_t written=fwrite(buffer,1,readSize,outFile);
			donesize+=written;
			if (!flagnoeta)
				hostampato |= myavanzamentoby1sec(donesize,expectedsize,startcopy,false);
		}
		if (hostampato)
		{	
			printbar(' ');
			myprintf("\r");
		}
		
		if (donesize!=expectedsize)
		{
			myprintf("0103: GURU bytes written does not match expected\n");
			seppuku();
		}
		fclose(inFile);
		fclose(outFile);
	
		if (buffer!=NULL)
		{
			franz_free(buffer);
			buffer=0;
		}
		myprintf("74852: Done, written %s\n",migliaia(donesize));
		return 0;
	}




	myprintf("02394: Creating SFX module for archive %Z\n",archive.c_str());
	if (g_sfx!="")
	{
		writesfxmodule(g_sfx);
		return 0;
	}
	string outfile	=prendinomefileebasta(archive);
	string percorso	=extractfilepath(archive);
	outfile=percorso+outfile+".exe";
	if (fileexists(outfile))
		if (!flagforce)
		{
			myprintf("02395! output file exists and no -force, abort %s\n",outfile.c_str());
			return 2;
		}
	myprintf("02396: Working on    : %s\n",outfile.c_str());
	std::wstring widename=utow(outfile.c_str());
	FILE* outFile=_wfopen(widename.c_str(), L"wb" );
	if (outFile==NULL)
	{
		myprintf("02397! CANNOT OPEN outfile %s\n",outfile.c_str());
		return 2;
	}
	int zsfx_exe_len=decompress_sfx_to_file(outFile);
	if (zsfx_exe_len==0)
	{
		myprintf("02398: guru extracting sfx\n");
		fclose(outFile);
		seppuku();
	}
	fclose(outFile);
	///	Just debug stuff
	int64_t written=prendidimensionefile(outfile.c_str());
	if (written==zsfx_exe_len)
	{
		myprintf("02399: SFX written   : %s bytes\n",migliaia(written));
		return 0;
	}
	myprintf("02400! something wrong: written %s expected %s\n",migliaia(written),migliaia2(zsfx_exe_len));
	return 2;
#else
	myprintf("02401: sfx module supported only on Windows\n");
#endif // corresponds to #if (#if defined(_WIN32))
	return 0;
}
/*
more general resource-like extraction (future)
*/
#ifdef _WIN32
int Jidac::decompress_mime64_to_file(FILE* i_outfile,const char* i_mime64)
{
#if defined(_WIN32)
	if (i_outfile==NULL)
		return 0;
	if (i_mime64==NULL)
		return 0;
	size_t 	the_exe_len=mimesize(i_mime64);
	char*	the_exe;
	the_exe=(char*)franz_malloc(the_exe_len);
	///g_allocatedram+=the_exe_len;
	if (the_exe==NULL)
	{
		myprintf("02402: error in malloc\n");
		return 0;
	}
	if (!mime2binary(i_mime64,(unsigned char *)the_exe,the_exe_len))
	{
		myprintf("02403: mime decoder kaputt!\n");
		return 0;

	}
	Mymemreader 	in	(( unsigned char *)the_exe,the_exe_len);
	Myfilewriter 	out	(i_outfile,the_exe_len);
	libzpaq::decompress(&in,&out);
	franz_free(the_exe);
	return out.written;
#else
	if (i_mime64)  // fake test for compiler warning
		if (i_outfile==0)
			return 1;
	return 0;
#endif // corresponds to #if (#if defined(_WIN32))
}
#endif // corresponds to #ifdef (#ifdef _WIN32)
#endif ///NOSFTPEND

/*
int Jidac::writeresource(const string i_filename,bool i_force,const char* i_mime64)
{
#if defined(_WIN32)
	if (i_filename=="")
	{
		myprintf("02404! resource filename empty\n");
		return 2;
	}
	string outfile=i_filename;
	if (flagverbose)
	{
		myprintf("\n\n");
		myprintf("02405: *** WRITING RESOURCE %s\n",outfile.c_str());
	}
	if (fileexists(outfile))
		if (!i_force)
		{
			myprintf("02406! output file exists and no -force, abort %s\n",outfile.c_str());
			return 2;
		}
	size_t 	the_res_len=mimesize(i_mime64);
	char*	the_res;
	the_res=(char*)franz_malloc(the_res_len);
	g_allocatedram+=the_res_len;
	if (the_res==NULL)
	{
		myprintf("02407: error in malloc\n");
		return 0;
	}
	if (!mime2binary(i_mime64,(unsigned char *)the_res,the_res_len))
	{
		myprintf("02408: mime decoder kaputt!\n");
		return 0;
	}

	std::wstring widename=utow(outfile.c_str());
	FILE* outFile=_wfopen(widename.c_str(), L"wb" );
	if (outFile==NULL)
	{
		myprintf("02409! CANNOT OPEN outfile %s\n",outfile.c_str());
		franz_free(the_res);
		return 2;
	}
	size_t written=fwrite(the_res,1,the_res_len,outFile);
	if (the_res_len!=written)
	{
		myprintf("02410: guru extracting resource\n");
		fclose(outFile);
		franz_free(the_res);
		seppuku();
	}
	if (outFile!=NULL)
		fclose(outFile);
#endif // corresponds to #if (#if defined(_WIN32))
	return 0;
}
*/
/*
	Section: verify and command w (chunked extraction)
	         running on pthread
*/
int Jidac::verify(bool i_readfile)
{
	flagforce		=true;
	flagtest		=true;
	summary			=1;
	bool myflagall	=all;
	all=false;
	if (i_readfile)
	{
		const int64_t sz=read_archive(NULL,archive.c_str());
		if (sz<1)
			error("archive not found");
	}
	all=myflagall;
	myprintf("\n");
	if (flagssd)
		myprintf("02411: Verify hashes of one version vs filesystem (multithreaded)\n");
	else
	{
		if (howmanythreads==1)
			myprintf("02412: Verify hashes of one version vs filesystem (monothread)\n");
		else
			myprintf("02413: Verify hashes of one version vs filesystem (1 thread, -ssd for multithread)\n");
	}
	uint64_t 	hashtotali=0;
	int			tobechecked=0;
	int			nohashfound=0;
	vector<string> 	myfiles;
	vector<string> 	myfilesoriginal;		//in fact redundant
	vector<string> 	myfilehash;
	vector<string> 	myalgo;
	for (DTMap::iterator p=dt.begin(); p!=dt.end(); ++p)
		if (p->second.date && p->first!="")
		{
			string finalfile=rename(p->first);
			if (!isdirectory(finalfile))
			if (p->second.size>0)
			if ((finalfile!="VFILE-l-filelist.txt") && (!ismemfile(finalfile)))
			{
				hashtotali+=p->second.size;
				tobechecked++;
				string myhashtype	="";
				string myhash		="";
				string mycrc32		="";
				int64_t mycreationtime=0;
				int64_t myaccesstime=0;
				bool	myisordered=false;
				int		myversion=0;
				franz_posix* myposix=NULL;
				bool	myisadded=false;
		
				decode_franz_block(false,p->second.franz_block,
					myhashtype,
					myhash,
					mycrc32,mycreationtime,myaccesstime,myisordered,myversion,myposix,myisadded);
					
				if (myhashtype=="")
					if (mycrc32!="")
						myhashtype="CRC-32";
				if (myhashtype!="")
				{
					const tipohash* thehash=franz_get_hash(myhashtype);
					if (thehash!=NULL)
					{
						franzreplace(finalfile);
						myfiles.push_back(finalfile);
						myfilesoriginal.push_back(p->first);
						if (flagdebug3)
							myprintf("02414:  ----___ myhash %s CRC32 %s type %s\n",myhash.c_str(),mycrc32.c_str(),myhashtype.c_str());
						if ((myhashtype=="CRC-32") && (myhash==""))
							myfilehash.push_back(mycrc32);
						else
							myfilehash.push_back(myhash);
						myalgo.push_back(myhashtype);
					}
					else
						myprintf("02415: unknown algo |%s| for %s\n",myhashtype.c_str(),finalfile.c_str());
				}
				else
					nohashfound++;
			}
		}
	unsigned int mythreads=howmanythreads;
	if (flagssd)
	{
		if (myfiles.size()<mythreads)
			mythreads=myfiles.size();
	}
	else
		mythreads=1;

	int64_t	startrunning=mtime();
	vector<tparametrihash> 	vettoreparametrihash;
	tparametrihash 	myblock;
	for (unsigned int i=0;i<mythreads;i++)
	{
		myblock.tnumber		=(i%mythreads);
		myblock.inizio		=mtime();
		myblock.dimensione	=hashtotali;
		myblock.timestart	=0;
		myblock.timeend		=0;
		vettoreparametrihash.push_back(myblock);
	}
	for (unsigned int i=0;i<myfiles.size();i++)
	{
		if (flagvss)
		{
			if (flagdebug3)
			{
				myprintf("02416: g_replaceme  |%s|\n",g_replaceme.c_str());
				myprintf("02417: g_vss_shadow |%s|\n",g_vss_shadow.c_str());
				myprintf("02418: thefilename  |%s|\n",myfiles[i].c_str());
			}
			myreplace(myfiles[i],g_replaceme,g_vss_shadow);
			if (flagdebug3)
				myprintf("02419: thefilename  |%s|\n",myfiles[i].c_str());
		}
		if (mythreads!=0) ///compiler be quiet
		{
			vettoreparametrihash[i%mythreads].filestobehashed.	push_back(myfiles[i]);
			vettoreparametrihash[i%mythreads].algo.				push_back(myalgo[i]);
			vettoreparametrihash[i%mythreads].filehash.			push_back(myfilehash[i]);
			vettoreparametrihash[i%mythreads].originalfilenames.push_back(myfilesoriginal[i]);
		}
	}
	int totfile=0;
	for (unsigned int i=0;i<mythreads;i++)
	{
		if (flagdebug3)
			myprintf("02420: Thread [%02d] files %s\n",(int)i,migliaia(vettoreparametrihash[i].filestobehashed.size()));
		totfile+=+vettoreparametrihash[i].filestobehashed.size();
	}
	if (mythreads==1)
	{
		///monothread (ESXi)
		int64_t inizio=mtime();
		g_dimensione=0;

		for (unsigned int i=0;i<myfiles.size();i++)
		{
			if (flagdebug3)
				myprintf("02421: franz_do_hash\n");

			franz_do_hash dummy(myalgo[i]);
			
			bool calcolacrc32=myalgo[i]=="CRC-32";
			string risu=dummy.filehash(0,myfiles[i],calcolacrc32,inizio,hashtotali);
			if (flagdebug3)
				myprintf("02422: risu %s\n",risu.c_str());
			vettoreparametrihash[0].o_hashcalculated.push_back(risu);
			vettoreparametrihash[0].o_sizegetted.push_back(dummy.o_thefilesize);
		}
	}
	else
	{
		int rc;
		pthread_t* threads = new pthread_t[mythreads];
		g_allocatedram+=sizeof(pthread_t)*mythreads;
		pthread_attr_t attr;
		void *status;
		pthread_attr_init(&attr);
		pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_JOINABLE);
		if (!flagnoeta)
			myprintf("02423: Total files %s -> in %03d threads -> %s to be checked\n",migliaia(myfiles.size()),mythreads,migliaia2(totfile));
		startrunning=mtime();
		for(unsigned int i=0; i<mythreads; i++ )
		{
			vettoreparametrihash[i].timestart=mtime();
			rc = pthread_create(&threads[i], &attr, scansionahash, (void*)&vettoreparametrihash[i]);
			if (rc)
			{
				myprintf("02424: Error creating thread\n");
				exit(-1);
			}
		}
		pthread_attr_destroy(&attr);
		for(unsigned int i=0; i <mythreads; i++ )
		{
			rc = pthread_join(threads[i], &status);
			if (rc)
			{
				error("39275: Unable to join\n");
				exit(-1);
			}
		}
		delete [] threads;
	}
	if (flagverbose)
		myprintf("02425: Scan done, preparing report...\n");

	for (MAPPATIPOHASH::iterator p=g_mappatipohash.begin(); p!=g_mappatipohash.end(); ++p)
		p->second.resetcheckstat();

	for(unsigned int i=0;i<mythreads;i++)
		for (unsigned int j=0;j<vettoreparametrihash[i].filestobehashed.size();j++)
		{
			string finalfile		=vettoreparametrihash[i].filestobehashed[j];
			string myhashtype		=vettoreparametrihash[i].algo[j];
			///printf("finalfile %s  %s\n",finalfile.c_str(),myhashtype.c_str());
			if (myhashtype=="")
			{
				nohashfound++;
				if (flagverbose)
					myprintf("02426: NO hashtype %s\n",finalfile.c_str());
			}
			else
			{
				tipohash* thehash=franz_get_hash(myhashtype);

				if (thehash!=NULL)
				{
					if (vettoreparametrihash[i].o_hashcalculated[j]=="")
					{
						if (flagverbose || (g_output!=""))
							myprintf("02427: FILE NOT FOUND on %s: FILE %s\n",myhashtype.c_str(),finalfile.c_str());
						thehash->checkednotfound++;
					}
					else
					{
						if (vettoreparametrihash[i].o_hashcalculated[j]==vettoreparametrihash[i].filehash[j])
						{
							if (flagdebug3)
								myprintf("02428: GOOD %s:  STORED == FROM FILE %s\n",myhashtype.c_str(),finalfile.c_str());
							thehash->checkedok++;
						///	Getting the filesize is slow (very slow on network), then waste some RAM
						///  a->second.checksize+=prendidimensionefile(finalfile.c_str());
							DTMap::iterator p=dt.find(vettoreparametrihash[i].originalfilenames[j]);
							if (p!=dt.end())
								thehash->checksize+=p->second.size;
							else
							{
								if (flagdebug3)
									myprintf("02429: Cannot find originalfilename %s\n",vettoreparametrihash[i].originalfilenames[j].c_str());
							}
						}
						else
						{
							if (flagverbose || (g_output!=""))
							{
								myprintf("02430: ERROR on %s: STORED HASH %s VS %s IN FILE %Z\n",myhashtype.c_str(),vettoreparametrihash[i].filehash[j].c_str(),vettoreparametrihash[i].o_hashcalculated[j].c_str(),finalfile.c_str());
							}
							thehash->checkedfailed++;
						}
					}
				}
				else
				{
					nohashfound++;
					if (flagverbose)
						myprintf("02431: algo unknown (or no algo!) %s\n",finalfile.c_str());
				}
			}
		}

	///		write the results (if any)
	int risultato=0;
	bool outsomething=(nohashfound>0);
	if (nohashfound>0)
		risultato=1;

	for (MAPPATIPOHASH::iterator p=g_mappatipohash.begin(); p!=g_mappatipohash.end(); ++p)
		outsomething |= (p->second.checkedok+p->second.checkedfailed+p->second.checkednotfound);

	if (outsomething)
	{
		printbar('-');
		int64_t	byteshashed=0;
		for (MAPPATIPOHASH::iterator p=g_mappatipohash.begin(); p!=g_mappatipohash.end(); ++p)
		{
			byteshashed+=p->second.checksize;
			if (p->second.checkedok)
				myprintf("02432: OK   %12s : %08d of %08d (%12s hash check against file on disk)\n",p->second.hashname.c_str(),p->second.checkedok,tobechecked,tohuman(p->second.checksize));
			if (p->second.checkedfailed)
			{
				myprintf("02433: FAIL %12s : %08d of %08d (   FAILED    hash check against file on disk)\n",p->second.hashname.c_str(),p->second.checkedfailed,tobechecked);
				risultato=2;
			}
			if (p->second.checkednotfound)
			{
				myprintf("02434: WARN %12s : %08d of %08d (file not found, cannot check hash)\n",p->second.hashname.c_str(),p->second.checkednotfound,tobechecked);
				if (risultato!=2)
					risultato=1;
			}
		}
		if (nohashfound)
			myprintf("02435: UNKNOWN/NOHASH: %08d of %08d (legacy 7.15 archive?)\n",nohashfound,tobechecked);
		printbar('-');
		if (flagverbose)
		myprintf("02436: Total hashed bytes %s @ %s B/s\n",migliaia(byteshashed),migliaia2((int64_t)(byteshashed/((mtime()-startrunning)/1000.0))));
	}
	return risultato;
}
void Jidac::handleflaglongpath()
{
#ifdef _WIN32
	if (!flaglongpath)
			return;
/// check if some kind of UNC Windows path \\franzk\pippo\..., turn OFF flaglongpath
	for (unsigned int i=0;i<tofiles.size();i++)
	{
		if (islonguncpath(tofiles[i]))
		{
			myprintf("02437: error, cannot work on explicit UNC -to\n");
			error("explicit UNC -to");
		}
		if (iswindowsunc(tofiles[i]))
		{
			myprintf("02438: found UNC Windows, incompatible with -longpath, turning OFF %s\n",tofiles[i].c_str());
			flaglongpath=false;
			break;
		}
	}
	for (DTMap::iterator p=dt.begin(); p!=dt.end(); ++p)
		if (iswindowsunc(p->first))
		{
			myprintf("02439: found UNC Windows, incompatible with -longpath, turning OFF %s\n",p->first.c_str());
			flaglongpath=false;
			break;
		}
	if (flaglongpath)
		if (tofiles.size()>0)
		{
			for (unsigned int i=0;i<tofiles.size();i++)
				if (!islongpath(tofiles[i]))
					tofiles[i]="//?/"+tofiles[i];
			if (flagverbose || flagdebug)
				myprintf("02440: INFO: setting Windows' long filenames\n");
			if (flagdebug3)
				for (unsigned int i=0;i<tofiles.size();i++)
					myprintf("02441: tofiles %d %s\n",(int)i,tofiles[i].c_str());
		}
#endif // corresponds to #ifdef (#ifdef _WIN32)
}
int Jidac::extractw()
{
	myprintf("02442: **** CHUNKED EXTRACTION/TEST ****\n");
	if (flagverify && flagtest)
	{
		myprintf("02443: -verify and -test incompatible (-test does not write on disk)\n");
		myprintf("02444: maybe you mean -test -checksum ?\n");
		return 1;
	}
	if (!flagtest)
		if (tofiles.size()!=1)
		{
			myprintf("02445! you need exactly one -to\n");
			return 2;
		}
	if (flagparanoid && !flagverify)
	{
		myprintf("02446$ WARNING -paranoid without -verify: ignored\n");
		flagparanoid=false;
	}
	/// transform -tofiles on WIN32 (if neeeded)
	handleflaglongpath();
	string outputdirectory="";
	if (flagtest)
		tofiles.push_back("K:/dummy/");
	else
	{
		if (!isdirectory(tofiles[0]))
			tofiles[0]+='/';
		outputdirectory=tofiles[0];
		uint64_t tofoldersize=0;
		uint32_t tofoldernumber=0;
		uint32_t tofolderfolder=0;
		uint32_t tofolderlongfiles=0;
		if (getfoldersize(tofiles[0],tofoldersize,tofoldernumber,tofolderfolder,tofolderlongfiles))
			if (tofoldersize>0)
			{
				myprintf("02447$ WARNING the folder <<%Z>> already contain %s bytes\n\n\n",
				tofiles[0].c_str(),migliaia(tofoldersize));
				if (!getcaptcha("deleteall","Data can be overwritten, use EMPTY folder!"))
					return 1;
			}
	}
	if (flagverify && flagparanoid)
		tofiles[0]+="zfranz/";
	g_scritti		=0;
	int	errors		=0;
	int64_t sz=read_archive(NULL,archive.c_str(),&errors);
	if (sz<1)
		error("44504: archive not found");
	for (unsigned i=0; i<block.size(); ++i)
	{
		if (block[i].bsize<0)
			error("negative block size");
		if (block[i].start<1)
			error("block starts at fragment 0");
		if (block[i].start>=ht.size())
			error("block start too high");
		if (i>0 && block[i].start<block[i-1].start)
			error("unordered frags");
		if (i>0 && block[i].start==block[i-1].start)
			error("empty block");
		if (i>0 && block[i].offset<block[i-1].offset+block[i-1].bsize)
		  error("unordered blocks");
		if (i>0 && block[i-1].offset+block[i-1].bsize>block[i].offset)
		  error("overlapping blocks");
	}
	int64_t	totalarchive=0;
	vector <s_fileandsize> fileandsize;
	vector <s_fileandsize> chunkfile;
	for (DTMap::iterator p=dt.begin(); p!=dt.end(); ++p)
		if (!isdirectory(p->first))
				if (p->second.size>0)
				{
					totalarchive+=p->second.size;
					string myhashtype	="";
					string myhash		="";
					string mycrc32		="";
					int64_t mycreationtime=0;
					int64_t myaccesstime=0;
					bool	myisordered=false;
					int		myversion=0;
					franz_posix* myposix=NULL;
					bool	myisadded=false;
					decode_franz_block(false,p->second.franz_block,
					myhashtype,
					myhash,
					mycrc32,mycreationtime,myaccesstime,myisordered,myversion,myposix,myisadded);
					const tipohash* thehash=franz_get_hash(myhashtype);
					s_fileandsize myblock;
					myblock.filename	=p->first;
					myblock.size		=p->second.size;
					myblock.attr		=p->second.attr;
					myblock.date		=p->second.date;
					myblock.data		=p->second.data;
					myblock.isdir		=isdirectory(p->first);
					if (thehash!=NULL)
					{
						myblock.hashtype=myhashtype;
						myblock.hashhex=myhash;
						myblock.flaghashstored=true;
					}
					else
						myblock.flaghashstored=false;
					fileandsize.push_back(myblock);
				}
	sort(fileandsize.begin(),fileandsize.end(),comparefilenamesize);
	int64_t biggestfile=(int64_t)(fileandsize[fileandsize.size()-1].size*1.1);
	if (flagverbose)
		myprintf("02448: Minimum needed  (+10%%) %21s %s\n",migliaia(biggestfile),fileandsize[fileandsize.size()-1].filename.c_str());
	int64_t freediskspace=0;
	int64_t	freeramdisk=0;
	if (flagramdisk)
	{
		freeramdisk=getramdisksize()*75/100;
		if (flagverbose)
			myprintf("02449: Free RAM (-25%%)        %21s (as reported by OS)\n",migliaia(freeramdisk));
	}
	if (flagtest)
		freediskspace=totalarchive;
	else
	{
		if (tofiles.size()>0) //really extract
		{
			freediskspace=getfreespace(outputdirectory)*90/100;
			/// overall free space, for extract WITHOUT chunkS (paranoid)
			if (!flagspace)
			{
				if (flagverbose)
					myprintf("02450: Free work space (-10%%) %21s on <<-to %s>>\n",migliaia(freediskspace),outputdirectory.c_str());
				if (! (flagverify && flagparanoid))
					if (freediskspace<totalarchive)
					{
						myprintf("02451: free space too small %s, at least %s (bypass with -space)\n",migliaia(freediskspace),migliaia2(totalarchive+1));
						return 1;
					}
			}
		}
	}
	int64_t spazio=0;
	if (flagramdisk)
		spazio=freeramdisk;
	else
		spazio=freediskspace;
	if (maxsize>0)
		spazio=maxsize;
	if (flagfrugal)
		spazio=biggestfile;
	unsigned		int	chunkscount	=0;
	int64_t			chunkcorrente	=0;
	unsigned int 	indice			=0;
	string	initialtofiles=tofiles[0];
	char	chunksbuffer[10];
	chunkfiles.clear();
//	count the chunks in advance
	int	quantichunk=0;
	while (indice<fileandsize.size())
		if ((chunkcorrente+(int64_t)fileandsize[indice].size)>spazio)
		{
			chunkcorrente=0;
			quantichunk++;
		}
		else
		{
			chunkcorrente+=fileandsize[indice].size;
			indice++;
		}
	quantichunk++;
	if (spazio>totalarchive)
			spazio=totalarchive;
	myprintf("02452: Chunks %04d x          %21s (total decompressed size %s)\n",quantichunk,migliaia(spazio),migliaia2(totalarchive));
	if (!flagspace)
		if (!flagtest)
		{
			if (spazio<biggestfile)
			{
				myprintf("02453: chunk size (-maxsize) too small %s, at least %s needed (bypass with -space)\n",migliaia(spazio),migliaia2(biggestfile+1));
				return 1;
			}
			if (tofiles.size()>0)
				if (freediskspace<spazio)
				{
					myprintf("02454: free disk space too small %s, at least %s (bypass with -space)\n",migliaia(freediskspace),migliaia2(spazio+1));
					return 1;
				}
		}
	if ((!flagtest) && (!(flagverify && flagparanoid)))
	{
		if (flagverbose)
		{
			print_datetime();
			myprintf("02455: creating folders tree and zero-bytes files\n");
		}
		for (DTMap::iterator p=dt.begin(); p!=dt.end(); ++p)
		{
			string thefolder=rename(p->first);
			if (isdirectory(thefolder))
				makepath(thefolder,p->second.date,p->second.attr);
			else
			{
				if (p->second.size==0)
				{
					FILE* myfile=fopen(thefolder.c_str(), "wb");
					if (myfile==NULL)
					{
						myprintf("02456: cannot write on thefolder %s\n",thefolder.c_str());
						exit(0);
					}
					fclose(myfile);
					close(thefolder.c_str(),p->second.data,p->second.attr);
				}
			}
		}
		if (flagverbose)
		{
			print_datetime();
			myprintf("02457: end\n");
		}
	}
//	reset and start from scratch
	indice=0;
	chunkcorrente=0;
	int	chunkinlavorazione=1;
	while (indice<fileandsize.size())
		if ((chunkcorrente+(int64_t)fileandsize[indice].size)>spazio)
		{
			printbar('=');
			errors+=extractqueue2(chunkscount,quantichunk);
			if (flagverify)
				errors+=multiverify(chunkfile);
			if (errors==0)
			myprintf("02458: Stage XTR %04d : errors  %d (0=good)",chunkinlavorazione,errors);
			else
			myprintf("02459! Stage XTR %04d : errors  %d (0=good) *** NOT GOOD ***",chunkinlavorazione,errors);
			eol();
			myprintf("\n");
			chunkcorrente=0;
			chunkscount++;
			chunkfile.clear();
			chunkfiles.clear();
			chunkinlavorazione++;
		}
		else
		{
			if (flagverify && flagparanoid)	// split the output in different dirs
			{
				snprintf(chunksbuffer,sizeof(chunksbuffer),"%08d",(int)chunkscount);
				tofiles[0]=initialtofiles+chunksbuffer+"/";
			}
			else
				tofiles[0]=initialtofiles;
			chunkcorrente+=fileandsize[indice].size;
			string fn=fileandsize[indice].filename;
			if (!isdirectory(fn))
			{
				string writtenfilename=rename(fn);
				fileandsize[indice].writtenfilename=writtenfilename;
				chunkfile.push_back(fileandsize[indice]);
				chunkfiles.push_back(fn);
				indice++;
			}
		}
	printbar('=');
	/// finalize "spare" chunk
	errors+=extractqueue2(chunkscount,quantichunk);
	if (flagverify)
		errors+=multiverify(chunkfile);
	if (errors==0)
		myprintf("02460: Stage VEF %04d : errors  %d (0=good)\n",chunkinlavorazione,errors);
	else
		myprintf("02461: VEF %04d : errors  %d (0=good) *** NOT GOOD ***\n",chunkinlavorazione,errors);
	printbar('=');
	if (flagverify && flagparanoid)
			if (!removetempdirifempty(outputdirectory,true))
				errors++;
	return errors>0;
}
bool Jidac::removetempdirifempty(string i_folder,bool i_deleteifsizezero=false)
{
	if (flagdebug)
	{
		myprintf("\n");
		myprintf("02462: removetempdirifempty on %s\n",i_folder.c_str());
	}
	if (i_folder=="")
		return false;
	if (isdirectory(i_folder))
		i_folder=i_folder.substr(0,i_folder.size()-1);
	if (flagdebug3)
	{
		myprintf("\n");
		myprintf("02463: ready on %s\n",i_folder.c_str());
	}
	if (!direxists(i_folder))
	{
		myprintf("\nFolder does not exist? %Z\n",i_folder.c_str());
		return false;
	}
	if (flagdebug3)
	{
		myprintf("\n");
		myprintf("02464: removeemptydirs on %s\n",i_folder.c_str());
	}
	removeemptydirs(i_folder,true);
	uint64_t 		totalsize=0;
	unsigned int 	totalfile=0;
	unsigned int 	totaldir=0;
	unsigned int	totallongfiles=0;
	bool 			somefile=false;
	if (flagdebug2)
	{
		myprintf("\n");
		myprintf("02465: getfoldersize on %s\n",i_folder.c_str());
	}
	getfoldersize(i_folder,totalsize,totalfile,totaldir,totallongfiles);
	if (flagdebug3)
	{
		myprintf("02466: files %s folders %s size %s ",migliaia(totalfile),migliaia2(totaldir),migliaia3(totalsize));
		if ((totalfile==0) && (totalsize==0))
			myprintf(" THIS IS GOOD");
		else
			myprintf(" *** SOMETHING HERE ***");
		myprintf("\n");
	}
	if (totalfile)			// houston, we have a file, do nothing
		somefile=true;
	if (totalsize>0)		// houston, we have some byte, do nothing
		somefile=true;
	if (totalsize==0) 		// if only empty file, and forced, delete
		if (i_deleteifsizezero)
			somefile=false;
	if (somefile)
	{
		myprintf("02467: some files founded in %s, do nothing\n",i_folder.c_str());
	}
	else
	{
		if (flagverbose)
		{
			myprintf("02468: No files found (this is good): deleting everything in <<%Z>>\n",i_folder.c_str());
			
		}
		return stermina(i_folder,totalfile);
	}
	return false;
}
int Jidac::multiverify(vector <s_fileandsize>& i_arrayfilename)
{
	printbar(' ');
	myprintf("\r");
	myprintf("02469: VERIFY (=re-read from filesystem) and compare hashes\n");
	if (howmanythreads==1)
	{
		myprintf("02470! not yet implemented (for monothread)\n");
		return 2;
	}
	g_dimensione=0;

	for (MAPPATIPOHASH::iterator p=g_mappatipohash.begin(); p!=g_mappatipohash.end(); ++p)
		p->second.resetcheckstat();

	uint64_t 	hashtotali		=0;
	int			nohashfound		=0;
	vector<string> 	myfiles;
	vector<string> 	myfilehash;
	vector<string> 	myfilesoriginal;		//in fact redundant
	vector<string> 	myalgo;
	for (unsigned int i=0;i<i_arrayfilename.size();i++)
		if (i_arrayfilename[i].hashhex!="")
		{
			myfiles			.push_back(i_arrayfilename[i].writtenfilename);
			myfilesoriginal	.push_back(i_arrayfilename[i].filename);
			myfilehash		.push_back(i_arrayfilename[i].hashhex);
			myalgo			.push_back(i_arrayfilename[i].hashtype);
			hashtotali+=i_arrayfilename[i].size;
		}
	unsigned int mythreads=howmanythreads;
	if (flagssd)
	{
		if (myfiles.size()<mythreads)
			mythreads=myfiles.size();
	}
	else
		mythreads=1;
	vector<tparametrihash> 	vettoreparametrihash;
	tparametrihash 	myblock;
	for (unsigned int i=0;i<mythreads;i++)
	{
		myblock.tnumber		=(i%mythreads);
		myblock.inizio		=mtime();
		myblock.dimensione	=hashtotali;
		myblock.timestart	=0;
		myblock.timeend		=0;
		vettoreparametrihash.push_back(myblock);
	}
	for (unsigned int i=0;i<myfiles.size();i++)
	{
		if (mythreads!=0) // compiler be quiet
		{
			vettoreparametrihash[i%mythreads].filestobehashed.	push_back(myfiles[i]);
			vettoreparametrihash[i%mythreads].algo.				push_back(myalgo[i]);
			vettoreparametrihash[i%mythreads].filehash.			push_back(myfilehash[i]);
			vettoreparametrihash[i%mythreads].originalfilenames.push_back(myfilesoriginal[i]);
		}
	}
	int totfile=0;
	for (unsigned int i=0;i<mythreads;i++)
	{
		if (flagdebug3)
			myprintf("02471: Thread [%02d] files %s\n",(int)i,migliaia(vettoreparametrihash[i].filestobehashed.size()));
		totfile+=+vettoreparametrihash[i].filestobehashed.size();
	}
	int rc;
	pthread_t* threads = new pthread_t[mythreads];
	g_allocatedram+=sizeof(pthread_t)*mythreads;
	pthread_attr_t attr;
	void *status;
	pthread_attr_init(&attr);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_JOINABLE);
	if (flagverbose)
		myprintf("02472: Total files %s -> in %03d threads -> %s to be checked\n",migliaia(myfiles.size()),mythreads,migliaia2(totfile));
	int64_t	startrunning=mtime();
	for(unsigned int i=0; i<mythreads; i++ )
	{
		vettoreparametrihash[i].timestart=mtime();
		rc = pthread_create(&threads[i], &attr, scansionahash, (void*)&vettoreparametrihash[i]);
		if (rc)
		{
			myprintf("02473: Error creating thread\n");
			exit(-1);
		}
	}
	pthread_attr_destroy(&attr);
	for(unsigned int i=0; i <mythreads; i++ )
	{
		rc = pthread_join(threads[i], &status);
		if (rc)
		{
			error("39275: Unable to join\n");
			exit(-1);
		}
	}
	for(unsigned int i=0;i<mythreads;i++)
		for (unsigned int j=0;j<vettoreparametrihash[i].filestobehashed.size();j++)
		{
			string finalfile		=vettoreparametrihash[i].filestobehashed[j];
			string myhashtype		=vettoreparametrihash[i].algo[j];
			if (flagdebug3)
			myprintf("02474: myhashtype %s\n",myhashtype.c_str());
			tipohash* thehash=franz_get_hash(myhashtype);
			if (myhashtype=="")
			{
				nohashfound++;
				if (flagverbose)
					myprintf("02475: NO hashtype %s\n",finalfile.c_str());
			}
			else
			{
			if (thehash!=NULL)
			{
				if (vettoreparametrihash[i].o_hashcalculated[j]=="")
				{
					if (flagverbose || (g_output!=""))
					{
						myprintf("02476: FILE NOT FOUND on %s: FILE %Z\n",myhashtype.c_str(),finalfile.c_str());
						
					}
					thehash->checkednotfound++;
				}
				else
				{
					if (vettoreparametrihash[i].o_hashcalculated[j]==vettoreparametrihash[i].filehash[j])
						{
							if (flagdebug)
								myprintf("02477: GOOD %s:  STORED == FROM FILE %s\n",myhashtype.c_str(),finalfile.c_str());
							thehash->checkedok++;
						///	Getting the filesize is slow (very slow on network), then waste some RAM
						///  a->second.checksize+=prendidimensionefile(finalfile.c_str());
							DTMap::iterator p=dt.find(vettoreparametrihash[i].originalfilenames[j]);
							if (p!=dt.end())
								thehash->checksize+=p->second.size;
							else
							{
								if (flagdebug3)
									myprintf("02478: Cannot find originalfilename %s\n",vettoreparametrihash[i].originalfilenames[j].c_str());
							}
						}
						else
						{
							if (flagverbose || (g_output!=""))
							{
								myprintf("02479: ERROR on %s: STORED HASH %s VS %s IN FILE %Z\n",myhashtype.c_str(),vettoreparametrihash[i].filehash[j].c_str(),vettoreparametrihash[i].o_hashcalculated[j].c_str(),finalfile.c_str());
							}
							thehash->checkedfailed++;
						}
					}
				}
				else
				{
					nohashfound++;
					if (flagverbose)
						myprintf("02480: algo unknown (or no algo!) %s\n",finalfile.c_str());
				}
			}
		}
	///		report the results (if any)
	int risultato=0;
	bool outsomething=(nohashfound>0);
	if (nohashfound>0)
		risultato=1;
	for (MAPPATIPOHASH::iterator p=g_mappatipohash.begin(); p!=g_mappatipohash.end(); ++p)
		outsomething |= (p->second.checkedfailed+p->second.checkednotfound);

	if (flagverbose)
		outsomething=true;
	if (outsomething)
	{
		if (!flagverbose)
			myprintf("\n");
		printbar('-');
		int64_t	byteshashed=0;
		for (MAPPATIPOHASH::iterator p=g_mappatipohash.begin(); p!=g_mappatipohash.end(); ++p)
		{
			byteshashed+=p->second.checksize;
			if (p->second.checkedok)
				if (flagverbose)
					myprintf("02481: OK   %8s : %08d of %08d (%12s hash check against file on disk)\n",p->second.hashname.c_str(),p->second.checkedok,(int)myfiles.size(),tohuman(p->second.checksize));
			if (p->second.checkedfailed)
			{
				myprintf("02482: FAIL %8s : %08d of %08d (   FAILED    hash check against file on disk) ***\n",p->second.hashname.c_str(),p->second.checkedfailed,myfiles.size());
				risultato=2;
			}
			if (p->second.checkednotfound)
			{
				myprintf("02483: WARN %8s : %08d of %08d (file not found, cannot check hash)\n",p->second.hashname.c_str(),p->second.checkednotfound,myfiles.size());
				if (risultato!=2)
					risultato=1;
			}
		}
		if (nohashfound)
			myprintf("02484: UNKNOWN/NOHASH: %08d of %08d (legacy 7.15 archive?)\n",nohashfound,myfiles.size());
		printbar('-');
		if (flagverbose)
			myprintf("02485: Total hashed bytes %s @ %s B/s\n",migliaia(byteshashed),migliaia2((int64_t)(byteshashed/((mtime()-startrunning)/1000.0))));
	}
	delete [] threads;
	if (flagverify)
		if (flagparanoid)
		{
			if (flagdebug)
				myprintf("02486: -paranoid, deleting files with OK matches\n");
			bool	alldeleted=true;
			uint32_t	tobedeleted=0;
			for(unsigned int i=0;i<mythreads;i++)
				tobedeleted+=vettoreparametrihash[i].filestobehashed.size();
			uint32_t	testati=0;
			int			percentualestampata=0;
			printbar(' ');
			myprintf("\r");
			myprintf("02487: Purging ");
			for(unsigned int i=0;i<mythreads;i++)
				for (unsigned int j=0;j<vettoreparametrihash[i].filestobehashed.size();j++)
				{
					testati++;
					int percentuale=(int)(100.0*testati/tobedeleted);
					if ((percentuale %10 ==0))
					if (percentuale!=percentualestampata)
					{
						myprintf("%d ",percentuale);
						percentualestampata=percentuale;
					}
					if (vettoreparametrihash[i].o_hashcalculated[j]!="")
					{
						if (vettoreparametrihash[i].o_hashcalculated[j]==vettoreparametrihash[i].filehash[j])
						{
							if (!delete_file(vettoreparametrihash[i].filestobehashed[j].c_str()))
							{
								if (flagverbose || (g_output!=""))
								{
									myprintf("02488: cannot delete %Z\n",vettoreparametrihash[i].filestobehashed[j].c_str());
									
								}
								alldeleted=false;
							}
						}
						else
						{
							alldeleted=false;
							if (flagverbose)
							{
								myprintf("02489: NON DELETED %Z\n",vettoreparametrihash[i].filestobehashed[j].c_str());
							}
						}
					}
					else
						alldeleted=false;
				}
			myprintf("\r");
			printbar(' ',false);
			myprintf("\r");
			if (flagverbose)
				if (!alldeleted)
					bigguru();
			if (flagverbose)
				myprintf("02490: removing temp dir (if empty) %s\n",tofiles[0].c_str());
			if (!removetempdirifempty(tofiles[0],false))
			{
				if (flagverbose)
				{
					myprintf("02491: something left in %Z\n",tofiles[0].c_str());
				}
				risultato++;
			}
			else
			{
				if (flagdebug3)
				{
					myprintf("02492: folder removed %Z\n",tofiles[0].c_str());
				}
			}
		}
	return risultato;
}
int Jidac::extractqueue2(int i_chunk,int i_chunksize)
{
	if (i_chunk<0)
	{
		myprintf("02493: chunk must be >=0\n");
		return 0;
	}
	if (chunkfiles.size()==0)
	{
		myprintf("02494: WARN: chunfiles.size == 0\n");
		return 0;
	}
	vector<Block> preblock=block;      			// this takes me about 3 full day of old-school debugging
	/// a mandatory sort (for binary_search)
	sort(chunkfiles.begin(),chunkfiles.end());
	int	errors		=0;
	int total_files	=0;
	ExtractJob job(*this);
	for (DTMap::iterator p=dt.begin(); p!=dt.end(); ++p)
	{
		p->second.data=-1;  // skip by default
		if (std::binary_search(chunkfiles.begin(), chunkfiles.end(), p->first))
		{
			string fn=rename(p->first);
			string dummy="";
			if (block.size()>0)
			{  // files to decompress
				p->second.data=0;
				unsigned lo=0, hi=block.size()-1;  // block indexes for binary search
				for (unsigned i=0; p->second.data>=0 && i<p->second.ptr.size(); ++i)
				{
					unsigned j=p->second.ptr[i];  // fragment index
					if (j==0 || j>=ht.size() || ht[j].usize<-1)
					{
						fflush(stdout);
						string tempp=p->first;
						myprintf("%Z",tempp.c_str());
						myprintf(": 1 bad frag IDs, skipping...\n");
						p->second.data=-1;
						continue;
					}
					assert(j>0 && j<ht.size());
					if (lo!=hi || lo>=block.size() || j<block[lo].start
						|| (lo+1<block.size() && j>=block[lo+1].start))
					{
						lo=0;  // find block with fragment j by binary search
						hi=block.size()-1;
						while (lo<hi)
						{
							unsigned mid=(lo+hi+1)/2;
							assert(mid>lo);
							assert(mid<=hi);
							if (j<block[mid].start)
								hi=mid-1;
							else
							(lo=mid);
						}
					}
					assert(lo==hi);
					assert(lo>=0 && lo<block.size());
					assert(j>=block[lo].start);
					assert(lo+1==block.size() || j<block[lo+1].start);
					unsigned c=j-block[lo].start+1;
					if (block[lo].size<c) block[lo].size=c;
					if (block[lo].files.size()==0 || block[lo].files.back()!=p)
						block[lo].files.push_back(p);
				}
				++total_files;
				job.total_size+=p->second.size;
				/// w extract only on EMPTY folder (for speed)
				/*
				if (fileexists(fn))
				{
				}
				*/
			}
			else
				myprintf("02495: BLOCK ZERO %s\n",fn.c_str());
		}  // end if selected
	}  // end for
	g_crc32.clear();
	if (flagverbose)
	myprintf("02496: Chunk %03d/%03d %21s bytes (%s) in %s files by %d threads\n",i_chunk+1,i_chunksize,migliaia(job.total_size), tohuman(job.total_size),migliaia2(total_files),howmanythreads);
	int64_t startextract=mtime();
	vector<ThreadID> tid(howmanythreads);
	for (unsigned i=0; i<tid.size(); ++i)
		if (flagramdisk)
			run(tid[i], decompressthreadramdisk, &job);
		else
			run(tid[i], decompressThread, &job);
	for (unsigned i=0; i<tid.size(); ++i)
		join(tid[i]);
	printbar(' ',false);
	myprintf("\r");
 // Report failed extractions (on filesystem)
	if (!flagramdisk)
	{
		unsigned extracted=0;
		for (DTMap::iterator p=dt.begin(); p!=dt.end(); ++p)
		{
			string fn=rename(p->first);
			if (std::binary_search(chunkfiles.begin(), chunkfiles.end(), p->first))
			{
				++extracted;
				if (p->second.ptr.size()!=unsigned(p->second.data))
				{
					fflush(stdout);
					if (++errors==1)
					{
						myprintf("\n");
						myprintf("02497: Failed (extracted/total fragments, file):\n");
					}
					myprintf("02498: SOK p->second.data %u / p->second.ptr.size() %u %Z\n",int(p->second.data), int(p->second.ptr.size()),fn.c_str());
				}
			}
		}
		if (errors>0)
		{
			fflush(stdout);
			myprintf("\n");
			myprintf("02499: Extracted %s files (%s errors) using %s bytes x %d threads\n",
			migliaia((int64_t)extracted), migliaia3(errors), migliaia4((int64_t)job.maxMemory),
			int(tid.size()));
		}
		block=preblock; ///AARRRGHHH!!
		chunkfiles.clear();
		return errors>0;
	}
// going back to ramdisk
	int64_t endextract=mtime();
	double	time_extract=(endextract-startextract)*0.001+0.001;
	if (flagverbose)
	{
		myprintf("02500: RAMDISK       %21s bytes (%s) ",migliaia(g_ramdisksize),tohuman(g_ramdisksize));
		myprintf("02501: time %.2f s @ %s (%s/s)\n",time_extract,migliaia((int64_t)(job.total_size/time_extract)),tohuman((int64_t)(job.total_size/time_extract)));
	}
	int64_t 	startwrite=mtime();
	int64_t 	expected=0;
	uint32_t	file_expected=0;
	vector<string> 		myfiles;
	vector<int64_t> 	mydate;
	vector<int64_t> 	myattr;
	vector<string> 		myfilehash;
	vector<string> 		myalgo;
	vector<char*> 		mydata;
	vector<int64_t> 	myfilesize;
	vector<string> 		myfilecrc;
	for (DTMap::iterator p=dt.begin(); p!=dt.end(); ++p)
		if (std::binary_search(chunkfiles.begin(), chunkfiles.end(), p->first))
		{
			string finalfile=rename(p->first);
			franzreplace(finalfile);
			string myhash		="";
			string mycrc32		="";
			string myhashtype	="";
			if (!isdirectory(finalfile))
			{
				int64_t mycreationtime=0;
				int64_t myaccesstime=0;
				bool	myisordered=false;
				int		myversion=0;
				franz_posix* myposix=NULL;
				bool	myisadded=false;
					
				decode_franz_block(false,p->second.franz_block,
					myhashtype,
					myhash,
					mycrc32,mycreationtime,myaccesstime,myisordered,myversion,myposix,myisadded);
				myfilesize.push_back((*p->second.pramfile).filesize);
				expected+=(*p->second.pramfile).filesize;
				mydata.push_back((*p->second.pramfile).data);
				file_expected++;
			}
			else
			{
				myfilesize.push_back(0);
				mydata.push_back(NULL);
			}
			myfiles.push_back(finalfile);
			myfilehash.push_back(myhash);
			myfilecrc.push_back(mycrc32);
			myalgo.push_back(myhashtype);
			mydate.push_back(p->second.date);
			myattr.push_back(p->second.attr);
		}
	unsigned int mythreads=howmanythreads;
	if (myfiles.size()<mythreads)
		mythreads=myfiles.size();
	if (flagssd)
	{
		if (myfiles.size()<mythreads)
			mythreads=myfiles.size();
	}
	else
		mythreads=1;
	vector<tparametriramtodisk> vettoreramtodisk;
	tparametriramtodisk 	myblock;
	for (unsigned int i=0;i<mythreads;i++)
	{
		myblock.tnumber		=(i%mythreads);
		myblock.timestart	=mtime();
		myblock.o_timeend	=0;
		myblock.flagtest	=flagtest;
		vettoreramtodisk.push_back(myblock);
	}
	if (flagdebug3)
	{
		myprintf("02502: myfiles    %12s\n",migliaia(myfiles.size()));
		myprintf("02503: mydate     %12s\n",migliaia(mydate.size()));
		myprintf("02504: myattr     %12s\n",migliaia(myattr.size()));
		myprintf("02505: myalgo     %12s\n",migliaia(myalgo.size()));
		myprintf("02506: myfilehash %12s\n",migliaia(myfilehash.size()));
		myprintf("02507: mysize     %12s\n",migliaia(myfilesize.size()));
		myprintf("02508: mydata     %12s\n",migliaia(mydata.size()));
		myprintf("02509: mycrc32    %12s\n",migliaia(myfilecrc.size()));
	}
	for (unsigned int i=0;i<myfiles.size();i++)
	{
		vettoreramtodisk[i%mythreads].filenameondisk	.push_back(myfiles[i]);
		vettoreramtodisk[i%mythreads].filedate			.push_back(mydate[i]);
		vettoreramtodisk[i%mythreads].fileattr			.push_back(myattr[i]);
		vettoreramtodisk[i%mythreads].algo				.push_back(myalgo[i]);
		vettoreramtodisk[i%mythreads].filehash			.push_back(myfilehash[i]);
		vettoreramtodisk[i%mythreads].filesize			.push_back(myfilesize[i]);
		vettoreramtodisk[i%mythreads].data				.push_back(mydata[i]);
		vettoreramtodisk[i%mythreads].filecrc			.push_back(myfilecrc[i]);
	}
	unsigned int totfile=0;
	for (unsigned int i=0;i<mythreads;i++)
	{
		if (flagdebug3)
			myprintf("02510: Thread [%02d] files %s\n",(int)i,migliaia(vettoreramtodisk[i].filenameondisk.size()));
		totfile+=+vettoreramtodisk[i].filenameondisk.size();
	}
	int rc;
	pthread_t* threads = new pthread_t[mythreads];
	g_allocatedram+=sizeof(pthread_t)*mythreads;
	pthread_attr_t attr;
	void *status;
	pthread_attr_init(&attr);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_JOINABLE);
	if (myfiles.size()!=totfile)
	{
		myprintf("02511: guru myfiles.size != totfile\n");
		seppuku();
		exit(0);
	}
	printbar(' ',false);
	myprintf("\r");
	if (flagverbose)
		myprintf("02512: Running %d threads on %s files\n",mythreads,migliaia(myfiles.size()));
	for(unsigned int i=0; i<mythreads; i++ )
	{
		vettoreramtodisk[i].timestart=mtime();
		rc = pthread_create(&threads[i], &attr, scriviramtodisk, (void*)&vettoreramtodisk[i]);
		if (rc)
		{
			myprintf("02513: Error creating thread\n");
			exit(-1);
		}
	}
	pthread_attr_destroy(&attr);
	for(unsigned int i=0; i <mythreads; i++ )
	{
		rc = pthread_join(threads[i], &status);
		if (rc)
		{
			error("33821: Unable to join\n");
			exit(-1);
		}
	}
	int64_t			t_crcsize			=0;
	int64_t			t_hashedsize		=0;
	int64_t			t_writtenbythread	=0;
	int64_t			t_timecrc 			=1;
	int64_t			t_timehash			=1;
	int64_t			t_timefilesystem	=1;
	int64_t			t_timewrite			=1;
	uint32_t		t_writeerror		=0;
	uint32_t		t_fileok			=0;
	uint32_t		t_fileerror			=0;
	uint32_t		t_filesnotchecked	=0;
	uint32_t		t_filewithoutcrc	=0;
///	uint32_t		t_filecrc			=0;
	uint32_t		t_filecrcok			=0;
	uint32_t		t_filecrcerror		=0;
	for(unsigned int i=0;i<mythreads;i++)
	{
		t_crcsize			+=vettoreramtodisk[i].o_crcsize;
		t_hashedsize		+=vettoreramtodisk[i].o_hashedsize;
		t_writtenbythread	+=vettoreramtodisk[i].o_writtenbythread;
		t_timecrc			+=vettoreramtodisk[i].o_timecrc;
		t_timehash			+=vettoreramtodisk[i].o_timehash;
		t_timefilesystem	+=vettoreramtodisk[i].o_timefilesystem;
		t_timewrite			+=vettoreramtodisk[i].o_timewrite;
		t_writeerror		+=vettoreramtodisk[i].o_writeerror;
		t_fileok			+=vettoreramtodisk[i].o_fileok;
		t_fileerror			+=vettoreramtodisk[i].o_fileerror;
		t_filesnotchecked	+=vettoreramtodisk[i].o_filesnotchecked;
		t_filewithoutcrc	+=vettoreramtodisk[i].o_filewithoutcrc;
///		t_filecrc			+=vettoreramtodisk[i].o_filecrc;
		t_filecrcok			+=vettoreramtodisk[i].o_filecrcok;
		t_filecrcerror		+=vettoreramtodisk[i].o_filecrcerror;
	}
	double writetime=(1+mtime()-startwrite)*0.001;
	if (t_filecrcerror)
		errors++;
	if (t_fileerror)
		errors++;
	bool	issomething=(t_filecrcerror || t_fileerror || (t_crcsize!=expected) || t_filewithoutcrc || (t_hashedsize!=expected) || (t_filesnotchecked!=0) || (t_fileok!=file_expected));
	if (flagverbose)
	if (flagverify || flagchecksum)
	{
		if (issomething)
			printbar('-');
		myprintf("02514: CRC-32 %21s ",migliaia(t_crcsize));
		if (t_crcsize==expected)
			myprintf("[OK] ");
		else
			myprintf("[WARN] ");
		myprintf("(%8.2f s) @ %8s/s ",t_timecrc*0.001,tohuman((int64_t)(t_crcsize/(t_timecrc*0.001))));
		myprintf(" UNKN %s ",migliaia(t_filewithoutcrc));
		if (t_filewithoutcrc==0)
			myprintf("[OK] ");
		else
			myprintf("[WARN] ");
		myprintf(" GOOD %s ",migliaia(t_filecrcok));
		if (t_filecrcok==file_expected)
			myprintf("[OK] ");
		else
			myprintf("[WARN] ");
		myprintf(" BAD %s ",migliaia(t_filecrcerror));
		if (t_filecrcerror==0)
			myprintf("[OK]");
		else
			myprintf("[FAULT: -verbose] ");
		myprintf("\n");
		myprintf("02515: HASHes %21s ",migliaia(t_hashedsize));
		if (t_hashedsize==expected)
			myprintf("[OK] ");
		else
			myprintf("[WARN] ");
		myprintf("(%8.2f s) @ %8s/s ",t_timehash*0.001,tohuman((int64_t)(t_hashedsize/(t_timehash*0.001))));
		myprintf(" UNKN %s ",migliaia(t_filesnotchecked));
		if (t_filesnotchecked==0)
			myprintf("[OK] ");
		else
			myprintf("[WARN] ");
		myprintf(" GOOD %s ",migliaia(t_fileok));
		if (t_fileok==file_expected)
			myprintf("[OK] ");
		else
			myprintf("[WARN] ");
		myprintf(" BAD %s ",migliaia(t_fileerror));
		if (t_fileerror==0)
			myprintf("[OK] ");
		else
			myprintf("[FAULT! -verbose] ");
		myprintf("\n");
		printbar('-');
	}
	if (!flagtest)
	{
		if (flagverbose)
		{
			myprintf("02516: Time on FS (%6.2f s) writing data (%6.2f s) @ %s/s\n",t_timefilesystem*0.001,t_timewrite*0.001,tohuman((int64_t)(t_writtenbythread/(t_timewrite*0.001))));
			myprintf("02517: Written by threads %21s / reported write errors %d ",migliaia(t_writtenbythread),t_writeerror);
			if (t_writeerror==0)
				myprintf("[OK] ");
			else
				myprintf("[FAULT!] ");
			myprintf("\n");
		}
	}
	if (flagverbose)
	{
		myprintf("02518: Bytes expected     %21s (%6.2f s) @ %s B/s ",migliaia2((int64_t)expected),writetime,migliaia3((int64_t)(t_writtenbythread/writetime)));
		if (!flagtest)
		{
			if (t_writtenbythread==expected)
				myprintf("[OK]");
			else
				myprintf("[FAULT!] ");
		}
		myprintf("\n");
		myprintf("02519: RAMDISK releasing  %21s bytes ",migliaia(g_ramdisksize));
	}
	for (DTMap::iterator p=dt.begin(); p!=dt.end(); ++p)
		if (std::binary_search(chunkfiles.begin(), chunkfiles.end(), p->first))
			if (p->second.pramfile!=NULL)
				(*p->second.pramfile).reset();
	if (flagverbose)
		myprintf(" to %s (should be zero)\n",migliaia(g_ramdisksize));
	if (g_ramdisksize!=0)
	{
		myprintf("\n\n");
		myprintf("02520$ WARNING SOMETHING WRONG WITH RAM!\n");
	}
	block=preblock; ///AARRRGHHH!!
	chunkfiles.clear();
	return errors>0;
}
int Jidac::removeemptydirs(string i_folder,bool i_kill)
{
	if (i_folder=="")
		return 0;
#ifdef _WIN32
	if (flaglongpath)
		if (iswindowspath(i_folder))
			if (!islongpath(i_folder))
				i_folder="//?/"+i_folder;
#endif // corresponds to #ifdef (#ifdef _WIN32)
	if (isdirectory(i_folder))
		i_folder=i_folder.substr(0,i_folder.size()-1);
	DTMap mydestinationdir;
	if (flagdebug)
	{
		myprintf("02521: Scanning dir <<%Z>>\n",i_folder.c_str());
	}
	scandir(false,mydestinationdir,i_folder);
	eol();
	///printbar(' ',false);
	////myprintf("\r");
	vector<string> scannedfiles;
	for (DTMap::iterator p=mydestinationdir.begin(); p!=mydestinationdir.end(); ++p)
		scannedfiles.push_back(p->first);
	if (flagverbose)
		myprintf("02522: Scanned files  (remove empty dir) %s\n",migliaia(scannedfiles.size()));
	vector<string> tobedeleted;
	int candidati=0;
	for (unsigned int i=0;i<scannedfiles.size();i++)
			if (isdirectory(scannedfiles[i]))
				{
					string corrente=scannedfiles[i];
					bool flagfigli=false;
					for (unsigned int j=i+1;j<scannedfiles.size();j++)
					{
						string prossima=extractfilepath(scannedfiles[j]);
						///string nomefile=extractfilename(scannedfiles[j]);
				/// we count everything, even Thumbs.db as "non empty dirs"
						if (mypos(corrente,prossima)!=0)
						{
							break;
						}
						else
						{
							if (!isdirectory(scannedfiles[j]))
							{
								flagfigli=true;
								break;
							}
						}
					}
					if (flagfigli==0)
						tobedeleted.push_back(scannedfiles[i]);
				}
	candidati=tobedeleted.size();
	if (flagdebug3)
	{
		printbar('-');
		for (unsigned int i=0;i<tobedeleted.size();i++)
			myprintf("02523: TO BE DELETED <<%Z>>\n",tobedeleted[i].c_str());
		printbar('-');
	}
	if (candidati==0)
	{
		if (flagverbose)
		{
			myprintf("02524: zero candidates <<%Z>>\n",i_folder.c_str());
		}
		return 0;
	}
	if (!i_kill)
	{
		myprintf("02525: Empty folders        %12s on <<%Z>>\n",migliaia(candidati),i_folder.c_str());
		myprintf("02526: dry run, exiting (no -kill)\n");
		return 0;
	}
	if (flagverbose)
		myprintf("02527: Empty folders %12s ",migliaia(candidati));
	int lastrun=tobedeleted.size();
	int newrun=0;
	int64_t startdelete=mtime();
	int runs=0;
///	OK we want to be safe, so we iterate as many times as possible
/// to use delete_dir() instead of "erredbarras".
/// So only "really" empty will be deleted.
/// Not fast at all but safer.
	while (lastrun>newrun)
	{
		runs++;
		for (unsigned int i=0;i<tobedeleted.size();i++)
			if (delete_dir(tobedeleted[i].c_str()))
				tobedeleted.erase(tobedeleted.begin()+i);
		newrun=tobedeleted.size();
		if (flagdebug3)
		{
			myprintf("\n");
			myprintf("02528: lastrun - newrun %d %d\n",lastrun,newrun);
		}
		if (lastrun>newrun)
		{
			lastrun=newrun;
			newrun=0;
		}
	}
	if (flagverbose)
	{
		myprintf(" time %.2f sec, runs %04d, highlanders %s <<%Z>>\n",(mtime()-startdelete)/1000.0,runs,migliaia(tobedeleted.size()),i_folder.c_str());
	}
	if (tobedeleted.size()>0)
		if (flagdebug3)
			for (unsigned int i=0;i<tobedeleted.size();i++)
			{
				myprintf("02529: Highlander <<%Z>>\n",tobedeleted[i].c_str());
			}
	if (tobedeleted.size()==0)
		return 0;
	else
		return 1;
}
#ifdef ZPAQFULL ///NOSFTPSTART

#ifdef _WIN32

/*
	Section: 	command q. Backup of Windows C:
				command g  Launch a power*ell (non need for a cmd-administrator)
*/
int Jidac::adminrun()
{
#ifdef _WIN32
	myprintf("02530: *** LAUNCH C: ARCHIVING  ***\n");
	if (archive=="")
	{
		myprintf("02531! need an archive (.zpaq)\n");
		return 2;
	}
	if (fullcommandline=="")
	{
		myprintf("02532! command line empty\n");
		return 2;
	}
	replace(fullcommandline,"g ","q ");
	string myexename=fullzpaqexename;
///	get the "right" path is not easy, registry digging needed.
///	too "complex", try to run
	string runme=windowspowerme();
	string parms="-Command \"Start-Process '"+myexename+"' '"+fullcommandline+"' -Wait -Verb runAs\"";
	waitexecute(runme,parms,SW_HIDE);
	return 0;
#else
	myprintf("02533! Windows C: backup works... on Windows\n");
	return 2;
#endif // corresponds to #ifdef (#ifdef _WIN32)
}
#endif // corresponds to #ifdef (#ifdef _WIN32)
#endif ///NOSFTPEND

#ifdef _WIN32
int Jidac::windowsc()
{
#ifdef _WIN32
	myprintf("02534: *** (KIND OF) WINDOWS C: BACKUP  ***\n");
	if (archive=="")
	{
		myprintf("02535! need an archive (.zpaq)\n");
		return 2;
	}
	if (tofiles.size()>1)
	{
		myprintf("02536! too many -to (max 1, default %s)\n",g_franzsnap.c_str());
		return 2;
	}
	if (files.size()!=0)
		myprintf("02537: files ignored (try to copy all C:)\n");
	if (!isadmin())
	{
		myprintf("\n");
		myprintf("02538! you need admin rights, quit (retry with g command)\n");
		return 2;
	}
	if (tofiles.size()==0)
		myprintf("02539: Using default -to %s (you can use %PCNAME, ex -to c:\\snap_%PCNAME)\n",g_franzsnap.c_str());
	if (tofiles.size()==1)
	{
		string temp=tofiles[0];
		string pcname=stringtolower(win_getcomputername());
		temp=stringtolower(temp);
		if (pcname!="")
			myreplaceall(temp,"%pcname",pcname);
		if (!isletterpath(temp))
		{
			myprintf("02540! -to need to be a letter path (c:\\something)\n");
			return 2;
		}
		if ((temp[0]!='c') && (temp[0]!='C'))
		{
			myprintf("02541! -to must point to c  (c:\\something, not X:\\something)\n");
			return 2;
		}
		temp=trimbarra(temp);
		g_franzsnap=temp;
	}
	if (flagverbose)
		myprintf("02542: *** snapdir will be <<%s>> ***\n",g_franzsnap.c_str());
	HRESULT hr;
	hr=ModifyPrivilege(SE_BACKUP_NAME, TRUE);
    if (hr>0) 
		myprintf("02543: Failed to become BACKUP\n");
	hr=ModifyPrivilege(SE_AUDIT_NAME, TRUE);
    if (hr>0) 
		myprintf("02544: Failed to become AUDIT\n");
	hr=ModifyPrivilege(SE_SECURITY_NAME, TRUE);
    if (hr>0) 
		myprintf("02545: Failed to become SECURITY\n");
	tofiles.clear();
	tofiles.push_back("c:/");
	files.clear();
	files.push_back("c:/");
	notfiles.push_back(g_franzsnap+"/pagefile.sys");
	notfiles.push_back(g_franzsnap+"/swapfile.sys");
	notfiles.push_back(g_franzsnap+"/System Volume Information/*");
	notfiles.push_back("*/AppData/Local/Microsoft/WindowsApps/*");	// no full reparse point, yet
	myprintf("02546: Excluding ALWAYS pagefile.sys, swapfile.sys, System Volume Information, WindowsApps\n");
	if (all)
	{
		flagforcewindows=true;
		all=false;
	}
	else
	{
		if (flagfrugal)
		{
			notfiles.push_back(g_franzsnap+"/program files/*");
			notfiles.push_back(g_franzsnap+"/program files (x86)/*");
			notfiles.push_back(g_franzsnap+"/ProgramData/Microsoft/Windows Defender/");
			notfiles.push_back(g_franzsnap+"/ProgramData/Microsoft/Search/");
			notfiles.push_back(g_franzsnap+"/ProgramData/Package Cache/");
			myprintf("02547: Excluding        %%programfiles%% and x86, programdata/microsoft/windows defender, programdata/microsoft/search\n");
			myprintf("02548: Excluding        programdata/package cache (because -frugal)\n");
		}
		if (!flagforcewindows)
		{
			notfiles.push_back(g_franzsnap+"/windows/*");
			notfiles.push_back(g_franzsnap+"/$RECYCLE.BIN/*");
			string tempdir=g_realtemp();
			myreplaceall(tempdir,"\\","/");
			tempdir+="*";
			if (flagdebug)
				myprintf("02549: TEMP |%s|\n",tempdir.c_str());
			notfiles.push_back(tempdir);
			myprintf("02550: Excluding        C:\\WINDOWS, TEMP, RECYCLE.BIN, ADS and .zfs bypass with -forcewindows\n");
		}
	}
	flagvss=true;
	return add();
#else
	myprintf("02551! Windows C: backup works... on Windows\n");
	return 2;
#endif // corresponds to #ifdef (#ifdef _WIN32)
}

#endif // corresponds to #ifdef (#ifdef _WIN32)
/*
	Hashing (multithread) dt and edt
	scope: set 	pedt->second.forceadd=true;
*/
int Jidac::hashselect()
{
	if (howmanythreads==1)
	{
		myprintf("02552: hashselect() not yet implemented (for monothread)\n");
		return 0;
	}
	if (dt.size()==0)
		return 0;
	int64_t		startrecalc=mtime();
	vector<string> myfiles;
	vector<string> myhashestype;
	vector<string> mydirs;
	int64_t total_size				=0;
	///	decode franzblock for every edt (file to be added) that match a dt (already archived)
	///	short version: fill dt (archived) hexhash and hashtype
	///	prepare two arrays: myfiles and myhashestype (to be splitted against thread)
	for (DTMap::iterator p=edt.begin(); p!=edt.end(); ++p)
		if (p->second.date)
			if((p->first!="") && (!isdirectory(p->first)) && (!isads(p->first)))
			{
				string filename=rename(p->first);
				DTMap::iterator a=dt.find(filename);
				string myhashtype	="";
				string myhash		="";
				string mycrc32		="";
				int64_t mycreationtime=0;
				int64_t myaccesstime=0;
				bool	myisordered=false;
				int		myversion=0;
				franz_posix* myposix=NULL;
				bool	myisadded=false;
				if (a!=dt.end())
				{
					decode_franz_block(isdirectory(filename),a->second.franz_block,
					myhashtype,
					myhash,
					mycrc32,mycreationtime,myaccesstime,myisordered,myversion,myposix,myisadded);
					if (myhashtype!="")
						if (myhash!="")
						{
							if (flagdebug3)
								myprintf("02553: from dt myhashtype %s myhash %s file %s\n",myhashtype.c_str(),myhash.c_str(),p->first.c_str());
							a->second.hexhash		=myhash;
							a->second.hashtype		=myhashtype;
							myfiles.push_back		(p->first);
							myhashestype.push_back	(myhashtype);
							total_size+=p->second.size;
						}
				}
			}
	/// nothing to do
	if (myfiles.size()==0)
		return 0;
	vector<string> 			myhash;
	vector<tparametrihash> 	vettoreparametrihash;
	unsigned int mythreads=howmanythreads;
	///	please note: -ssd enable multithread read!
	if (flagssd)
	{
		if (myfiles.size()<mythreads)
			mythreads=myfiles.size();
	}
	else
		mythreads=1;
	tparametrihash 	myblock;
	for (unsigned int i=0;i<mythreads;i++)
	{
		myblock.tnumber=(i%mythreads);
		myblock.inizio=mtime();
		myblock.dimensione=total_size;
		myblock.timestart=0;
		myblock.timeend=0;
		vettoreparametrihash.push_back(myblock);
	}
	for (unsigned int i=0;i<myfiles.size();i++)
	{
		vettoreparametrihash[i%mythreads].filestobehashed	.push_back(myfiles[i]);
		vettoreparametrihash[i%mythreads].algo				.push_back(myhashestype[i]);
	}
//int totfile=0;
	for (unsigned int i=0;i<mythreads;i++)
	{
		if (flagdebug3)
			myprintf("02554: Thread [%02d] files %s\n",(int)i,migliaia(vettoreparametrihash[i].filestobehashed.size()));
///		totfile+=+vettoreparametrihash[i].filestobehashed.size();
	}
	int rc;
	pthread_t* threads = new pthread_t[mythreads];
	g_allocatedram+=sizeof(pthread_t)*mythreads;
	pthread_attr_t attr;
	void *status;
	pthread_attr_init(&attr);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_JOINABLE);
	myprintf("02555: Paranoid select: %8s files %21s (%s in %d threads)\n",migliaia(myfiles.size()),migliaia2(total_size),tohuman(total_size),mythreads);
	for(unsigned int i=0;i<mythreads;i++ )
	{
		vettoreparametrihash[i].timestart=mtime();
		rc = pthread_create(&threads[i], &attr, scansionahash, (void*)&vettoreparametrihash[i]);
		if (rc)
		{
			myprintf("02556: Error creating thread\n");
			exit(-1);
		}
	}
	pthread_attr_destroy(&attr);
	for(unsigned int i=0;i<mythreads;i++ )
	{
		rc = pthread_join(threads[i], &status);
		if (rc)
		{
			error("Unable to join\n");
			exit(-1);
		}
	///		myprintf("02557: Thread completed %d status %d\n",(int)i,status);
	}
	///	for every output of the hashing threads, with a nonempty hash,
	///	check if a dt (already archive) exists, with same name
	/// if different hash, mark the forceadd flag. Please note: so size check, to save a .find
	/// (makes debug not so hard)
	unsigned int forzati=0;
	for(unsigned int i=0;i<mythreads;i++)
		for (unsigned int j=0;j<vettoreparametrihash[i].filestobehashed.size();j++)
		{
			string	hashfromfilesystem	=vettoreparametrihash[i].o_hashcalculated[j];
			if (hashfromfilesystem!="")
			{
				string 	filename		=rename(vettoreparametrihash[i].filestobehashed[j]);
				DTMap::iterator a		=dt.find(filename);
				if (a!=dt.end())
					if (hashfromfilesystem!=a->second.hexhash)
					{
						DTMap::iterator pedt=edt.find(filename);
						if (pedt!=edt.end())
						{
							pedt->second.forceadd=true;
							forzati++;
							if (flagverbose)
							{
								myprintf("02558: DT hashtype |%s| hash |%s| filesystem |%s| %Z\n",a->second.hashtype.c_str(),a->second.hexhash.c_str(),hashfromfilesystem.c_str(),filename.c_str());
							}
						}
					}
			}
		}
	delete [] threads;
	float tempo=(mtime()-startrecalc)/1000.0;
	printbar(' ',false);
	myprintf("\r");
	myprintf("02559: Time for paranoid select : %.2fs (speed %s/s), forced files %s\n",tempo,tohuman((int64_t)(total_size/tempo)),migliaia(forzati));
	return 0;
}



bool Jidac::getjollylist(string i_fullarchive,DTMap* o_thedt)
{
	if (i_fullarchive=="")
	{
		myprintf("02582: fullarchive empty\n");
		return false;
	}
	if (o_thedt==NULL)
	{
		myprintf("02583: o_thedt is null!\n");
		return false;
	}
	if (!iswildcard(i_fullarchive))
	{
		if (flagdebug2)
			myprintf("02584: no wildcard => singlefile\n");
		DT& d=(*o_thedt)[i_fullarchive];
		d.date			=0;
		d.creationdate	=0;
		d.accessdate	=0;
		d.size			=0;
		d.attr			=0;
		d.data			=0;
		return true;
	}


	string estensione=prendiestensione(i_fullarchive);
	myprintf("02585: Searching for jolly archive(s) in <<%s>> for extension <<%s>>\n",i_fullarchive.c_str(),estensione.c_str());

	g_bytescanned	=0;
	g_filescanned	=0;
	g_worked		=0;
	flagskipzfs		=true;  // strip down zfs

#ifdef unix
	if (flagdebug)
		myprintf("02586: running on NIX\n");
	vector<string> candidate;
	listfiles(extractfilepath(i_fullarchive),estensione,true,&candidate);
	if (flagdebug3)
		myprintf("02587: candidate %s with pattern %s\n",migliaia(candidate.size()),i_fullarchive.c_str());
	for (unsigned int i=0;i<candidate.size();i++)
	{
		string filename=candidate[i];
		if (flagdebug3)
			myprintf("02588: filename %08d %s\n",(int)i,filename.c_str());

		if (jollymatch(i_fullarchive.c_str(),filename.c_str()))
		{
			if (flagdebug3)
			{
				myprintf("02589: matched <<%Z>>\n",filename.c_str());
			}
			DT& d=(*o_thedt)[filename];
			d.date			=0;
			d.creationdate	=0;
			d.accessdate	=0;
			d.size			=0;
			d.attr			=0;
			d.data			=0;
		}
		else
		{
			if (flagdebug3)
				myprintf("02590: DISCARDED %s in %s\n",i_fullarchive.c_str(),filename.c_str());
		}
	}
#else
	scandir(false,(*o_thedt),i_fullarchive,false);
	eol();
	///printbar(' ',false);
	///myprintf("\r");
#endif // corresponds to #ifdef (#ifdef unix)

	if ((*o_thedt).size()==0)
	{
		myprintf("02591: no archive founded => quit\n");
		return false;
	}
	return true;
}






typedef std::pair<string,string>  mycoppia;

#ifdef ZPAQFULL ///NOSFTPSTART
int Jidac::zfsproxbackup()
{
	if (g_ifexist!="")
	{
		if (!direxists(g_ifexist))
		{
			myprintf("84877! Abort because -ifexist <<%Z>>\n",g_ifexist.c_str());
			return 2;
		}
	}

	string	storepath	="/var/lib/vz";
	string 	theconf		="/etc/pve/qemu-server/";

	myprintf("\n\n");
	myprintf("02592: zfsproxmox-backup VERY EXPERIMENTAL!\n");
	myprintf("02593: Works only on %s VM disk(s)\n"	,storepath.c_str());
	myprintf("02594: and        on %s config(s)\n\n"	,theconf.c_str());

	if  (all)
	{
		if (files.size()!=0)
		{
			myprintf("02595: with -all cannot select VMids\n");
			return 1;
		}

		vector<string> candidate;
		listfiles(theconf,"conf",false,&candidate);
		files.clear();
		for (unsigned int j=0;j<candidate.size();j++)
		{
			string onlydigit	=stringtosomething(candidate[j],isdigit);
			if (onlydigit!="")
			{
				bool flagescluso=false;
				for (unsigned int ii=0;ii<notfiles.size();ii++)
				{
					string temp=stringtosomething(prendinomefileebasta(notfiles[ii]),isdigit);
					if (flagdebug3)
						myprintf("02596: notfiles  %03d temp |%s| ",ii,temp.c_str());
					if (onlydigit==temp)
					{
						if (flagdebug3)
							myprintf("02597: discarded because of -not %s %s\n",onlydigit.c_str(),temp.c_str());
						flagescluso=true;
						break;
					}
				}
				if (!flagescluso)
					files.push_back(candidate[j]);
			}
		}
		for (unsigned int i=0;i<files.size();i++)
			myprintf("02598: From -all getting %s\n",files[i].c_str());

		if (files.size()==0)
		{
			myprintf("02599! no .conf files founded in %s (not discarded by -not)\n",theconf.c_str());
			return 2;
		}
		for (unsigned int i=0;i<files.size();i++)
		{
			myreplace(files[i],".conf","");
			if (flagdebug3)
				myprintf("02600: Config file %03d %s\n",(int)i,files[i].c_str());
		}
	}
	else
	{
		if (files.size()==0)
		{
			myprintf("02601: please use vmid(s) (ex. 200 300 400) or -all\n");
			return 1;
		}
	}

	notfiles.clear();

	vector<string> conffiles;
	for (unsigned int i=0;i<files.size();i++)
	{
		string temp=theconf+files[i]+".conf";
		conffiles.push_back(temp);
#ifdef unix
	if (!flagforce)
		if (!fileexists(temp))
		{
			myprintf("02602: Abort because cannot find conf file %s, use -force to bypass\n",temp.c_str());
			return 1;
		}
#endif // corresponds to #ifdef (#ifdef unix)
	}

	string thepool	="";
	string listme	="zfs list";

#ifdef _WIN32
/// debug
	FILE *meminfo = fopen("c:/zpaqfranz/zfslist.txt", "rb");
    if(meminfo == NULL)
	{
		myprintf("02603! DEBUG KAPUTT?\n");
		return 2;
	}
    char line[65536];
	fread(line, 1, sizeof(line), meminfo);
    fclose(meminfo);
///    string listresult=line;
#else
	(void)x_one(listme,"Searching vz from zfs list...");
#endif // corresponds to #ifdef (#ifdef _WIN32)


	vector<string> arraylist;
	(void)x_one_vector(listme,"Searching something",arraylist);
	vector<mycoppia> name_mountpoint;

	for (unsigned int i=0;i<arraylist.size();i++)
	{
		string 	name		="";
		string 	mountpoint	="";
		string lavoro=arraylist[i];
		if (flagdebug3)
			myprintf("02604: %08d %s\n",(int)i,arraylist[i].c_str());
		unsigned int j=0;
		while (j<lavoro.size())
		{
			if (lavoro[j]!=' ')
				name+=lavoro[j];
			else
				break;
			j++;
		}
		j=lavoro.size();
		while (j>0)
		{
			if (lavoro[j]!=' ')
				j--;
			else
				break;
		}
		///printf("k2 j %d\n",j);
		for (unsigned int k=j+1;k<lavoro.size();k++)
			mountpoint+=lavoro[k];
		if (flagdebug3)
			myprintf("02605: NAME       <<%s>> <<%s>>",name.c_str(),mountpoint.c_str());
		if (i==0)
		{
			if ((name!="NAME") || (mountpoint!="MOUNTPOINT"))
				break;
		}
		else
		name_mountpoint.push_back(std::pair<string,string>(name,mountpoint));
	}

	string	mountpoint	="";
	for (unsigned int i=0;i<name_mountpoint.size();i++)
		myprintf("02606: <<%30s>> <<%30s>>\n",name_mountpoint[i].first.c_str(),name_mountpoint[i].second.c_str());

	/// first try
	for (unsigned int i=0;i<name_mountpoint.size();i++)
		if (name_mountpoint[i].second==storepath)
		{
			thepool		=name_mountpoint[i].first;
			mountpoint	=name_mountpoint[i].second;
			break;
		}

	if (thepool=="")
	{
		myprintf("02607: cannot find store path %s, look for / \n",storepath.c_str());
		for (unsigned int i=0;i<name_mountpoint.size();i++)
			if (name_mountpoint[i].second=="/")
			{
				thepool		=name_mountpoint[i].first;
				mountpoint	=name_mountpoint[i].second;
				break;
			}
	}
	myprintf("02608: thepool    |%s|\n",thepool.c_str());

	if (!isdirectory(mountpoint))
		mountpoint+='/';

	myprintf("02609: mountpoint |%s|\n",mountpoint.c_str());

	if (thepool=="")
	{
		myprintf("02610! GURU: cannot reverse-lookup for %s\n",storepath.c_str());
		return 2;
	}

	if (isdirectory(thepool))
	{
		myprintf("02611! A pool-dataset |%s| cannot end with a / \n",thepool.c_str());
		myprintf("02612! Good examples     zp0/zd0\n");
		return 2;
	}
	string themark	="francoproxmox";
	if (snapmark!="")
		themark=snapmark;

	int	howmanyat		=0;
	for (unsigned int i=0;i<thepool.size();i++)
		if (thepool[i]=='@')
			howmanyat++;

	string purgedpool=thepool;
	for (unsigned int i=0;i<purgedpool.size();i++)
		if (purgedpool[i]=='/')
			purgedpool[i]='_';

	myprintf("02613: Archive        %s\n",archive.c_str());
	myprintf("02614: Pool           %s\n",thepool.c_str());
	myprintf("02615: Purged Pool    %s\n",purgedpool.c_str());
	myprintf("02616: Mark           %s\n",themark.c_str());

	if (howmanyat>0)
	{
		myprintf("02617! A pool-dataset |%s| cannot have @\n",thepool.c_str());
		return 2;
	}
	string fullexpectedsnapshot=thepool+'@'+themark;
	vector<string> thedrives;
	if (!flagforce)
	{
		vector<string> array_primachiocciola;
		vector<string> array_dopochiocciola;
		vector<string> array_size;
		(void)zfs_get_snaplist(thepool,themark,array_primachiocciola,array_dopochiocciola,array_size);

		if (array_primachiocciola.size()!=0)
		{
			myprintf("02618! Found a zombie snapshot |%s| abort (-force to bypass)\n",fullexpectedsnapshot.c_str());
			return 2;
		}
	}

	x_one("zfs destroy "	+fullexpectedsnapshot,"Destroy snapshot (if any)");
	string runresult=x_one("zfs snapshot "	+fullexpectedsnapshot,"Taking snapshot");

	if (mypos("cannot create",runresult)!=-1)
	{
		myprintf("02619! GURU, something seems wrong, %s\n",runresult.c_str());
		return 2;
	}

	for (unsigned int i=0;i<files.size();i++)
	{
		string percorso="";
		if (mountpoint!="/")
			percorso=mountpoint+".zfs/snapshot/"+themark+/*storepath*/+"/images/"+files[i];
		else
			percorso=mountpoint+".zfs/snapshot/"+themark+storepath+"/images/"+files[i];
		myprintf("02620: VM Path        %03d  %s\n",(int)i,percorso.c_str());
		thedrives.push_back(percorso);
	}

	files.clear();
	for (unsigned int i=0;i<conffiles.size();i++)
		files.push_back(conffiles[i]);

	for (unsigned int i=0;i<thedrives.size();i++)
		files.push_back(thedrives[i]);

	command='a'; /// hidden parameter in read_archive with reflex on issel

	int risultato=add();

	if (flagkill)
		x_one("zfs destroy "+fullexpectedsnapshot,"Destroy snapshot (if any)");

	return risultato;
}


int Jidac::zfsproxrestore()
{
	all=false; // if no files => always all
	string	storepath	="/var/lib/vz";
	string 	theconf		="/etc/pve/qemu-server/";

	myprintf("\n\n");
	myprintf("02621: zfsproxmox-restore VERY EXPERIMENTAL!\n");
	myprintf("02622: Works only on %s VM disk(s)\n"		,storepath.c_str());
	myprintf("02623: and        on %s config(s)\n\n\n"		,theconf.c_str());

	if (onlyfiles.size()!=0)
	{
		myprintf("02624! sorry but you cannot use -only here\n");
		return 2;
	}
	if (searchfrom!="")
	{
		myprintf("02625! sorry but you cannot use -searchfrom here\n");
		return 2;
	}
	if (replaceto!="")
	{
		myprintf("02626! sorry but you cannot use -replaceto here\n");
		return 2;
	}
	if (!flagkill)
	{
		if (!direxists(theconf))
		{
			myprintf("02627: conf  kaputt (-kill to bypass) <<%s>>\n",theconf.c_str());
			return 1;
		}
		if (!direxists(storepath))
		{
			myprintf("02628: store kaputt (-kill to bypass) <<%s>>\n",storepath.c_str());
			return 1;

		}
	}
	onlyfiles.clear();
	if  (files.size()==0)
	{
		///	onlyfiles.push_back("*vm-*disk*");
		/// onlyfiles.push_back("*.conf");
		myprintf("02629: zfsproxmox restore all, getting VM configs...\n");
		int errors	=0;
		command		='l';
		g_optional	="versum"; //force isselected
		read_archive(NULL,archive.c_str(),&errors,1); /// AND NOW THE MAGIC ONE!
		jidacreset();
		for (DTMap::iterator a=dt.begin(); a!=dt.end(); ++a)
			if (prendiestensione(a->first)=="conf")
				if (extractfilepath(a->first)==theconf)
					files.push_back(prendinomefileebasta(a->first));
	}

	if  (files.size()==0)
	{
		myprintf("02630! cannot select VM to restore, quit\n");
		return 2;
	}

	for (unsigned int i=0;i<files.size();i++)
	{
		string onlydigit=stringtosomething(files[i],isdigit);
		bool	flagadd=onlydigit!="";
		if (flagadd)
			for (unsigned int j=0;j<notfiles.size();j++)
			{
				string temp=stringtosomething(prendinomefileebasta(notfiles[j]),isdigit);
				if (flagdebug3)
					myprintf("02631: notfiles  %03d temp |%s| ",(int)j,temp.c_str());
				if (onlydigit==temp)
				{
					if (flagdebug3)
						myprintf("02632: discarded because of -not %s %s\n",onlydigit.c_str(),temp.c_str());
					flagadd=false;
					break;
				}
			}

		if (flagadd)
		{
			onlyfiles.push_back("*vm-"	+onlydigit+"-*disk*");
			onlyfiles.push_back("*/"	+onlydigit+".conf");
			myprintf("02633: Getting VM %10s\n",onlydigit.c_str());
		}
		else
			myprintf("02634: Discarding %s\n",onlydigit.c_str());
	}
	if  (onlyfiles.size()==0)
	{
		myprintf("02635! VMIDs selection by digits (ex. 200 300 400) failed\n");
		return 2;
	}
	files	.clear();
	notfiles.clear();
	searchfrom	=".zfs/snapshot/francoproxmox/";
	replaceto	="";
	if (flagdebug3)
		for (unsigned int i=0;i<onlyfiles.size();i++)
			myprintf("02636: onlyfiles %03d %s\n",(int)i,onlyfiles[i].c_str());

	return extract();
}
#endif ///NOSFTPEND

typedef std::pair<uint64_t,string> uint64string;

struct mycomparestringstring
{
	bool operator()(const std::pair<string,string>& value,const string& key)
	{
		return (value.first<key);
	}
	bool operator()(const string& key,const std::pair<string,string>& value)
	{
		return (key<value.first);
	}
};


struct mycompareuint64string
{
	bool operator()(const std::pair<uint64_t,string>& value,const uint64_t& key)
	{
		return (value.first<key);
	}
	bool operator()(const uint64_t& key,const std::pair<uint64_t,string>& value)
	{
		return (key<value.first);
	}
};


///zpaqfranz 1on1 c:\zpaqfranz\prova -deleteinto z:\pippero -verbose -out 2.txt
/// -checksum (delete if == checksum)
int Jidac::oneonone()
{
	myprintf("02637: 1on1 - Julius Erving and Larry Bird Go One on One\n");
	if (g_deleteinto=="")
	{
		myprintf("02638! you must enter a -deleteinto folder\n");
		return 2;
	}
	if (!flagspace)
		if (!saggiascrivibilitacartella(g_deleteinto))
		{
			myprintf("02639! Cannot write in -deleteinto folder <<%Z>>, bypass with -space\n",g_deleteinto.c_str());
			return 2;
		}
	if (files.size()!=1)
	{
		myprintf("02640! you must enter exactly ONE source folder\n");
		return 2;
	}
#ifdef _WIN32
	if (flaglongpath)
		for (unsigned int i=0;i<files.size();i++)
			files[i]=makelongpath(files[i]);
	if (flagdebug3)
		for (unsigned int i=0;i<files.size();i++)
			myprintf("02641: after %03d files[i] %s\n",(int)i,files[i].c_str());
	g_deleteinto=makelongpath(g_deleteinto);
	
#endif // corresponds to #ifdef (#ifdef _WIN32)
	files.push_back(g_deleteinto);
	franzparallelscandir(false,true,true);
	//printbar('Z');
	if (files_edt[0].size()==0)
	{
		myprintf("02642! Cannot find files inside source folder %Z\n",files[0].c_str());
		return 2;
	}

	if (files_edt[1].size()==0)
	{
		myprintf("02643! Cannot find files inside source destination folder %Z\n",files[1].c_str());
		return 2;
	}

	vector<std::pair<uint64_t,string> > bysize;
	for (DTMap::iterator p=files_edt[1].begin(); p!=files_edt[1].end(); ++p)
		if (!isdirectory(p->first))
		{
			if (flagdebug3)
				myprintf("02644: pfirst %s\n",p->first.c_str());
			bysize.push_back(std::pair<uint64_t,string>(p->second.size,makelongpath(p->first)));
		}
	std::sort(bysize.begin(),bysize.end());

	if (flagdebug3)
		for (unsigned int i=0;i<bysize.size();i++)
			myprintf("02645: Destbysize  %08d %21s  %s\n",(int)i,migliaia(bysize[i].first),bysize[i].second.c_str());

	vector<string> 	tobehashedsource;
	vector<int64_t> tobehashedsource_size;
	vector<string> 	tobehasheddest;
	vector<int64_t> tobehasheddest_size;

	int64_t	totalsource	=0;
	for (DTMap::iterator p=files_edt[0].begin(); p!=files_edt[0].end(); ++p)
		if (!isdirectory(p->first))
		{
			bool flagaggiungi=true;
/*
			if (p->second.size==0)
				flagaggiungi=flagzero;
	*/
			if (flagaggiungi)
			{
				vector<std::pair<uint64_t,string> >::iterator basso 	= std::lower_bound(bysize.begin(), bysize.end(), p->second.size,mycompareuint64string());
				if (basso!=bysize.end())
				{
					tobehashedsource.push_back(p->first);
					tobehashedsource_size.push_back(p->second.size);
					totalsource+=p->second.size;

					if (flagdebug3)
						myprintf("02646: source2ha %21s %s\n",migliaia(p->second.size),p->first.c_str());
					vector<std::pair<uint64_t,string> >::iterator alto 	= std::upper_bound(bysize.begin(), bysize.end(), p->second.size,mycompareuint64string());
					for (vector<std::pair<uint64_t,string> >::iterator a=basso; a!=alto; ++a)
					{
						if (flagdebug3)
							myprintf("02647:   ADD2DEST %08d %s\n",a->first,a->second.c_str());
						tobehasheddest.push_back(a->second);
						tobehasheddest_size.push_back(a->first);
					}

				}
			}
		}
	totalsource*=2;	 // estimation
	g_dimensione=0;  // for avanzamento
	printbar(' ');
	myprintf("\n");
	myprintf("02648: Running on hash %s\n",g_thechosenhash_str.c_str());
	if (flagdebug3)
	{
		myprintf("02649: Source card %08d\n",tobehashedsource.size());
		for (unsigned int i=0;i<tobehashedsource.size();i++)
			myprintf("02650: To be hashed source %08d size %21s %s\n",(int)i,migliaia(tobehashedsource_size[i]),tobehashedsource[i].c_str());

		myprintf("02651: Dest   card %08d\n",tobehasheddest.size());
		for (unsigned int i=0;i<tobehasheddest.size();i++)
			myprintf("02652: To be hashed dest   %08d size %21s %s\n",(int)i,migliaia(tobehasheddest_size[i]),tobehasheddest[i].c_str());
	}

	vector<std::pair<string,string> > tobehashedsource_hashname;
	franzparallelhashfiles(g_thechosenhash_str,totalsource,tobehashedsource,false,tobehashedsource_hashname);
	if (flagdebug3)
	{
		myprintf("02653: ----------------- %s\n",migliaia(tobehashedsource_hashname.size()));
		for (unsigned int i=0;i<tobehashedsource_hashname.size();i++)
			myprintf("02654: SOURCE %08d %s %s\n",(int)i,tobehashedsource_hashname[i].first.c_str(),tobehashedsource_hashname[i].second.c_str());

		myprintf("02655: Deduplicating tobehasheddest pre  %9s\n",migliaia(tobehasheddest.size()));
	}
	std::sort(tobehasheddest.begin(), tobehasheddest.end());
	tobehasheddest.erase( unique( tobehasheddest.begin(), tobehasheddest.end() ), tobehasheddest.end() );
	if (flagdebug3)
		myprintf("02656: Deduplication                post %9s\n",migliaia(tobehasheddest.size()));

	vector<std::pair<string,string> > tobehasheddest_hashname;
	franzparallelhashfiles(g_thechosenhash_str,totalsource,tobehasheddest,false,tobehasheddest_hashname);
	if (flagdebug3)
		myprintf("02657: dedup tobehashed_dest hashname pre  ----------------- %s\n",migliaia(tobehasheddest_hashname.size()));
	std::sort(tobehasheddest_hashname.begin(), tobehasheddest_hashname.end());
	tobehasheddest_hashname.erase( unique( tobehasheddest_hashname.begin(), tobehasheddest_hashname.end() ), tobehasheddest_hashname.end() );
	if (flagdebug3)
	{
		myprintf("02658: dedup tobehashed_dest hashname post ----------------- %s\n",migliaia(tobehasheddest_hashname.size()));

		for (unsigned int i=0;i<tobehasheddest_hashname.size();i++)
			myprintf("02659: DEST   %08d %s %s\n",(int)i,tobehasheddest_hashname[i].first.c_str(),tobehasheddest_hashname[i].second.c_str());
		printbar('-');
		myprintf("02660: Source            cardinality %08d\n",tobehashedsource.size());
		myprintf("02661: Source_hashname   cardinality %08d\n",tobehashedsource_hashname.size());
	}
	int	samehash		=0;
	int	veryequal		=0;
	int deleted			=0;
	int tobedeleted		=0;
	int errors			=0;
	int	spared			=0;
	int64_t byteserased	=0;
	int lastpercentuale =0;
	printbar(' ');
	myprintf("\n");

	vector<uint64_t> temp;
	for (unsigned int i=0;i<tobehashedsource_hashname.size();i++)
	{
		string cerco=tobehashedsource_hashname[i].first;
		vector<std::pair<string,string> >::iterator basso 	= std::lower_bound(tobehasheddest_hashname.begin(), tobehasheddest_hashname.end(), cerco,mycomparestringstring());
		if ((basso!=tobehasheddest_hashname.end()))
		{
			vector<std::pair<string,string> >::iterator alto 		= std::upper_bound(tobehasheddest_hashname.begin(), tobehasheddest_hashname.end(), cerco,mycomparestringstring());
			string leftname=extractfilename(tobehashedsource_hashname[i].second);
			for (vector<std::pair<string,string> >::iterator a=basso; a<alto; ++a)
			{
				string rightname	=extractfilename(a->second);
				bool flaguccidi		=true;
				if (rightname!=leftname)
					if (!flagchecksum)
						flaguccidi=false;
				if (flaguccidi)
					temp.push_back(hashastringa(a->second.c_str()));
			}
		}
	}
	if (flagdebug2)
		myprintf("02662: Temp size pre  %12s\n",migliaia(temp.size()));
	std::sort(temp.begin(),temp.end());
	temp.erase(unique(temp.begin(),temp.end()),temp.end());
	tobedeleted=temp.size();
	if (flagdebug2)
		myprintf("02663: Temp size post %12s\n",migliaia(temp.size()));

	temp.clear();

	int64_t startdelete=mtime();
	for (unsigned int i=0;i<tobehashedsource_hashname.size();i++)
	{
		string cerco=tobehashedsource_hashname[i].first;
		vector<std::pair<string,string> >::iterator basso 	= std::lower_bound(tobehasheddest_hashname.begin(), tobehasheddest_hashname.end(), cerco,mycomparestringstring());
		if ((basso!=tobehasheddest_hashname.end()))
		{
			vector<std::pair<string,string> >::iterator alto 		= std::upper_bound(tobehasheddest_hashname.begin(), tobehasheddest_hashname.end(), cerco,mycomparestringstring());
			if (flagdebug3)
				myprintf("02664: %08d search hash       %s (%s)\n",(int)i,cerco.c_str(),tobehashedsource_hashname[i].second.c_str());
			string leftname=extractfilename(tobehashedsource_hashname[i].second);
			for (vector<std::pair<string,string> >::iterator a=basso; a<alto; ++a)
			{
				string rightname=extractfilename(a->second);
				samehash++;

				bool flaguccidi=true;

				if (rightname==leftname)
					veryequal++;
				else
				{
					if (!flagchecksum)
						flaguccidi=false;
				}

				/*
				if (flaguccidi)
					tobedeleted++;
				*/
				if (flagkill)
				{
					if (flaguccidi)
					{
						if (!flagnoeta)
						{
							int percentuale=i*100/tobehashedsource_hashname.size();
							if (percentuale%5==0)
								if (percentuale!=lastpercentuale)
								{
									myprintf("02665: Deleted so far %03d%% (%12s of %12s)\r",percentuale,migliaia(i),migliaia(tobehashedsource_hashname.size()));
									lastpercentuale=percentuale;
								}
						}
						int64_t filesize=prendidimensionefile(a->second.c_str());
						if (!delete_file(a->second.c_str()))
						{
							myprintf("        63939: CANNOT DELETE %s\n",a->second.c_str());
							errors++;
						}
						else
						{
							temp.push_back(hashastringa(a->second.c_str()));
							byteserased+=filesize; /// if file does not exists, filesize will be 0
							if (flagverbose)
								myprintf("        63941: DELETED   %08d %s (%s)\n",a-tobehasheddest_hashname.begin(),a->first.c_str(),a->second.c_str());
						}
					}
					else
						spared++;
				}
				else
				{
					if (flagverbose)
						if (flaguccidi)
						{
							byteserased+=prendidimensionefile(a->second.c_str());
							myprintf("        63944: TO BE ERASED   %08d %s (%s)\n",a-tobehasheddest_hashname.begin(),a->first.c_str(),a->second.c_str());
						}
				}
			}
		}
	}
	std::sort(temp.begin(),temp.end());
	temp.erase(unique(temp.begin(),temp.end()),temp.end());
	deleted=temp.size();

	printbar(' ');
	myprintf("\n");
	if (flagkill)
		if (deleted>0)
			myprintf("02666: Deleted %.0f files/s\n",(deleted/((mtime()-startdelete)/1000.0)));
	myprintf("02667: Same hash             %9s (same name too) %s\n",migliaia(samehash),migliaia(veryequal));
	if (!flagchecksum)
	{
		if (spared>0)
		myprintf("02668: Spared (no -checksum) %9s\n",migliaia(spared));
		myprintf("02669: To be deleted         %9s (same name, same hash)\n",migliaia(tobedeleted));
	}
	else
	myprintf("02670: To be deleted         %9s (=hash, because -checksum)\n",migliaia(tobedeleted));

	if (!flagkill)
		myprintf("02671: DRY RUN because no -kill switch entered\n");
	else
	myprintf("02672: Deleted               %9s\n",migliaia(deleted));

	if (flagkill)
	{
		if (errors>0)
		myprintf("02673: Delete FAIL           %9s\n",migliaia(errors));
		if (byteserased>0)
			myprintf("02674: Space freed       %s (%s)\n",migliaia(byteserased),tohuman(byteserased));
	}
	if ((byteserased>0) && (!flagkill))
	myprintf("02675: Space to be freed %s (%s)\n",migliaia(byteserased),tohuman(byteserased));

	return errors;
}

int64_t Jidac::franzparallelhashfiles(const string i_hashtype,int64_t i_totalsize,vector<string> i_thefiles,bool i_silent,vector<std::pair<string,string> >& o_hashname)
{
	int64_t startscan=mtime();
	unsigned int mythreads=howmanythreads;
	if (flagssd)
	{
		if (i_thefiles.size()<mythreads)
			mythreads=i_thefiles.size();
		vector<tparametrihash> 	vettoreparametrihash;
		tparametrihash 	myblock;
		for (unsigned int i=0;i<mythreads;i++)
		{
			myblock.tnumber		=(i%mythreads);
			myblock.inizio		=mtime();
			myblock.dimensione	=i_totalsize;
			myblock.timestart	=0;
			myblock.timeend		=0;
			vettoreparametrihash.push_back(myblock);
		}
		for (unsigned int i=0;i<i_thefiles.size();i++)
		{
			vettoreparametrihash[i%mythreads].filestobehashed.	push_back(i_thefiles[i]);
			vettoreparametrihash[i%mythreads].algo.				push_back(i_hashtype);
			vettoreparametrihash[i%mythreads].filehash.			push_back("dummy");
			vettoreparametrihash[i%mythreads].originalfilenames.push_back("dummy");
		}
		int totfile=0;
		for (unsigned int i=0;i<mythreads;i++)
		{
			if (flagdebug3)
				myprintf("02676: Thread [%02d] files %s\n",(int)i,migliaia(vettoreparametrihash[i].filestobehashed.size()));
			totfile+=+vettoreparametrihash[i].filestobehashed.size();
		}

		int rc;
		pthread_t* threads = new pthread_t[mythreads];
		g_allocatedram+=sizeof(pthread_t)*mythreads;
		pthread_attr_t attr;
		void *status;
		pthread_attr_init(&attr);
		pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_JOINABLE);
		if (!i_silent)
			if (!flagnoeta)
				myprintf("02677: Files %14s -> %03d threads -> %14s to get\n",migliaia(i_thefiles.size()),mythreads,migliaia2(totfile));
		for(unsigned int i=0; i<mythreads; i++ )
		{
			vettoreparametrihash[i].timestart=mtime();
			rc = pthread_create(&threads[i], &attr, scansionahash, (void*)&vettoreparametrihash[i]);
			if (rc)
			{
				myprintf("02678: Error creating thread\n");
				exit(-1);
			}
		}
		pthread_attr_destroy(&attr);
		for(unsigned int i=0; i <mythreads; i++ )
		{
			rc = pthread_join(threads[i], &status);
			if (rc)
			{
				error("64041: Unable to join\n");
				exit(-1);
			}
		}
		delete [] threads;
		for(unsigned int i=0;i<mythreads;i++)
			for (unsigned int j=0;j<vettoreparametrihash[i].filestobehashed.size();j++)
				o_hashname.push_back(std::pair<string,string>(vettoreparametrihash[i].o_hashcalculated[j],vettoreparametrihash[i].filestobehashed[j]));
	}
	else
	{
		franz_do_hash dummy(i_hashtype);
		for (unsigned i=0; i<i_thefiles.size(); ++i)
		{
			if (flagdebug3)
				myprintf("02679: filehash on %s\n",i_thefiles[i].c_str());

			string gettedhash=dummy.filehash(0,i_thefiles[i],false,
			startscan,i_totalsize);
			o_hashname.push_back(std::pair<string,string>(gettedhash,i_thefiles[i]));
		}
	}
	return mtime()-startscan;
}


int Jidac::last()
{
	if (archive=="")
	{
		myprintf("02689! Need an archive name\n");
		return 2;
	}
	flagpakka	=true; //suppress every output
	flagnoeta	=true;
	flagstdout	=true;
	int64_t	dummy	=0;
	string ultimo	=get_lastfilename(archive,dummy);
	if (ultimo=="")
		return 2;
	myprintf("%Z\n",extractfilename(ultimo).c_str());
	return 0;
}

int Jidac::last2()
{
	if (files.size()!=1)
	{
		myprintf("02690! last2 require 1 file \n");
		return 2;
	}
	int risultato=0;
	if (files.size()==1) /// single file, last 2 lines
	{
		int riga=0;
		string filename=files[0];
		if (flagdebug)
			myprintf("74619: filename is %Z\n",filename.c_str());
		if (!fileexists(filename))
		{
			myprintf("02691! error file does not exists %Z\n",filename.c_str());
			return 2;
		}

		FILE* myfile = freadopen(filename.c_str());
		if (myfile==NULL)
		{
			myprintf("02692! guru cannot open the file\n");
			return 2;
		}

#ifdef ANCIENT
	char 	line[16384];
#else
	char 	line[65536];
#endif // corresponds to #ifdef (#ifdef ANCIENT)

		while (fgets(line, sizeof(line), myfile))
		{
			if (flagdebug3)
				myprintf("02693: %08d %s", riga,line);
			riga++;
		}
		if (riga>0)
		{
			fseeko(myfile,0,SEEK_SET);
			int penultima=riga-2;
			riga=0;
			while (!feof(myfile) && !ferror(myfile) && (riga != penultima))
			{
				if (fgets(line, sizeof(line), myfile) == NULL)
					break;
					
				if (flagdebug3)
					myprintf("02694: %08d %08d %s", riga, penultima, line);
				riga++;
			}
			string spenultima	="";
			string sultima		="";
			spenultima			=line;
			// Pre-emptive check of file status
			if (feof(myfile) || ferror(myfile))
			{
				myprintf("02695! File not in valid state for reading\n");
				seppuku();
				return 2;
			}

			if (fgets(line, sizeof(line), myfile) == NULL)
			{
				// Distinguish between EOF and read error
				if (feof(myfile))
				{
					myprintf("02695! Unexpected end of file\n");
				}
				else if (ferror(myfile))
				{
					myprintf("02695! Error reading from file\n");
				}
				else
				{
					myprintf("02695! GURU running fgets\n");
				}
				seppuku();
				return 2;
			}

			sultima				=line;

			for (unsigned int i=0;i<spenultima.size();i++)
				if ((spenultima[i]==10) || (spenultima[i]==13))
					spenultima[i]=' ';

			for (unsigned int i=0;i<sultima.size();i++)
				if ((sultima[i]==10) || (sultima[i]==13))
					sultima[i]=' ';

			myprintf("02696:      |%s\n",spenultima.c_str());
			myprintf("02697:      |%s\n",sultima.c_str());

			string hashpenultima="";
			for (unsigned int i=0;i<spenultima.size();i++)
				if ((isdigit(spenultima[i])) || (isalpha(spenultima[i])))
					hashpenultima+=spenultima[i];
				else
					break;

			string hashultima="";
			for (unsigned int i=0;i<sultima.size();i++)
				if ((isdigit(sultima[i])) || (isalpha(sultima[i])))
					hashultima+=sultima[i];
				else
					break;
			hashpenultima=stringtolower(hashpenultima);
			hashultima=stringtolower(hashultima);
			myprintf("02698: n-1  |%s|\n",hashpenultima.c_str());
			myprintf("02699: last |%s|\n",hashultima.c_str());
			if (hashultima=="")
				risultato=2;
			else
			{
				if (hashpenultima!=hashultima)
					risultato=2;
			}
		}
		fclose(myfile);
	}
	return risultato;
}
int64_t Jidac::getzpaqsum(string i_archive,int64_t& o_usize,int64_t& o_allsize,int64_t& o_dtsize,int64_t& o_compressedsize)
{
	o_usize				=0;
	o_allsize			=0;
	o_dtsize			=0;
	o_compressedsize	=0;
	int errors			=0;
	g_optional			="versum"; //force isselected

	jidacreset();

	int64_t csize=read_archive(NULL,i_archive.c_str(),&errors,1); /// AND NOW THE MAGIC ONE!
	myprintf("\n");
	int64_t usize=0;
	for (DTMap::iterator p=dt.begin(); p!=dt.end(); ++p)
		if (p->first!="" && (!isdirectory(p->first)))
			usize+=p->second.size;
	int64_t 	allsize=0;
	for (DTMap::const_iterator p=dt.begin(); p!=dt.end(); ++p)
		if (p->second.date)
			for (unsigned j=0; j<p->second.ptr.size(); ++j)
			{
				unsigned k=p->second.ptr[j];
				if (k>0 && k<ht.size())
					if (ht[k].usize>=0)
						allsize+=ht[k].usize;
			}
	o_usize				=usize;
	o_allsize			=allsize;
	o_dtsize			=dt.size();
	o_compressedsize	=(csize+dhsize-dcsize);
	if (flagdebug3)
	{
		myprintf("02700: usize      : %21s\n",migliaia(usize));
		myprintf("02701: allsize    : %21s\n",migliaia(allsize));
		myprintf("02702: dtsize     : %21s\n",migliaia(dt.size()));
		myprintf("02703: compressed : %21s\n",migliaia((csize+dhsize-dcsize)));
	}
	return csize;
}


bool Jidac::isbackuprunning()
{
	if (flagnopid)
	{
		if  (flagdebug)
			myprintf("95280: because of -nopid isbackuprunning() is false\n");
		return false;
	}
	if (g_pidname=="")
	{
		if (flagdebug)
			myprintf("02704: backupname is empty\n");
		return false;
	}
	if (flagdebug)
		myprintf("02705: Pid check |%s|\n",g_pidname.c_str());
	if (!fileexists(g_pidname))
	{
		if (flagdebug)
			myprintf("02706: pid does not exits %s\n",g_pidname.c_str());
		return false;
	}

	vector<string> pidfile;

	if (readfiletoarray(g_pidname,pidfile))
	{
		if (pidfile.size()>0)
			for (unsigned int i=0;i<pidfile.size();i++)
				myprintf("02707: PID %03d %s\n",(int)i,pidfile[i].c_str());
	}
	return true;

}

// Function to check if a string contains only digits
bool isAllDigits(const std::string& str) 
{
    if (str.empty()) 
		return false;
    for (size_t i = 0; i < str.length(); i++) 
	    if (!std::isdigit(str[i])) 
		    return false;
    return true;
}

std::string processBackupFilename(const std::string& filename) 
{
    // Check if it ends with .zpaq
    if (filename.length() < 5 || filename.substr(filename.length() - 5) != ".zpaq") 
	    return filename; // Not a .zpaq file, return unchanged
    
    // Removes .zpaq for analysis
    std::string withoutExt = filename.substr(0, filename.length() - 5);
    
    // Search for the last underscore
    size_t lastUnderscore = withoutExt.find_last_of('_');
    
    // If it doesn't find an underscore, it returns the original filename
    if (lastUnderscore == std::string::npos) 
	    return filename;
    
    // Extract the part after the underscore
    std::string afterUnderscore = withoutExt.substr(lastUnderscore + 1);
    
    // Check if after the underscore there are only numbers
    if (isAllDigits(afterUnderscore)) 
	    // Returns the part before the underscore
        return withoutExt.substr(0, lastUnderscore);
    
    // Check if after the underscore there are exactly 8 '?' characters
    if (afterUnderscore.length() == 8) 
	{
        bool allQuestionMarks = true;
        for (size_t i = 0; i < 8; i++) 
            if (afterUnderscore[i] != '?') 
			{
                allQuestionMarks = false;
                break;
            }
        if (allQuestionMarks)     // Returns the part before the underscore
            return withoutExt.substr(0, lastUnderscore);

    }
    
    // Does not match any pattern, return the original filename
    return filename;
}


int Jidac::testbackup()
{
	flagquick=true;
	if (flagverify)
		flagquick=false;

	if (files.size()!=1)
	{
		myprintf("02708! testbackup require one file parameter\n");
		return 2;
	}
	if (isjolly(files[0]))
	{
		std::string originalName = files[0];
		std::string processedName = processBackupFilename(originalName);

		if (processedName != originalName) 
			files[0] = processedName;
		if (flagdebug)
			myprintf("73522: Automagical testbackup files[0] <<%s>>\n",files[0].c_str());
	}

	if (tofiles.size()>1)
	{
		myprintf("02710! testbackup require zero or one -to (where are the zpaqs?)\n");
		return 2;
	}
	if (mypos("/",files[0])==-1)
	{
		files[0]="./"+files[0];
		myprintf("02711: fixed filename %Z\n",files[0].c_str());
	}

	if (tofiles.size()==0)
		tofiles.push_back(extractfilepath(files[0]));

	if (!flagnopid)
	{
		g_pidname	=extractfilepath(files[0])+prendinomefileebasta(files[0])+"_00000000.pid";

		if (!flagspace)
			if (isbackuprunning())
			{
				myprintf("02712: Quit because backup seems running. -space to bypass\n");
				return 1;
			}
	}

	string	posizione=extractfilepath(files[0]);
	
	if (g_indexname!="")
	{
		g_backupposition=extractfilepath(includetrailingbackslash(g_indexname));
		if (flagverbose)
			myprintf("02713: -index automagically managed g_backuposition |%s|\n",g_backupposition.c_str());
		if (!direxists(g_backupposition))
		{
			myprintf("02714! the folder (of -index) need to (already) exists %Z\n",g_backupposition.c_str());
			return 2;
		}
		g_indexname="";
		index=NULL;
		posizione=g_backupposition;
		if (!flagparanoid)
		{
			color_yellow();
			myprintf("02715$ *** WARNING: due to -index YOU SHOULD REALLY USE -paranoid ***\n");
			color_restore();
		}
	}
				
	string 	indexname	=posizione+prendinomefileebasta(files[0])+"_00000000_backup.index";
	string 	filename	=posizione+prendinomefileebasta(files[0])+"_00000000_backup.txt";
	string	firstzpaq	=extractfilepath(files[0])+prendinomefileebasta(files[0])+"_00000001.zpaq";
	string	zpaqchunks	=extractfilepath(files[0])+prendinomefileebasta(files[0])+"_????????.zpaq";

	string 	onlyname=extractfilename(files[0]);
	myreplace(onlyname,"????????.zpaq","");
	myreplace(onlyname,".zpaq","");

	if (!exists(firstzpaq))
	{
		myprintf("02716! Cannot find first zpaq %Z\n",firstzpaq.c_str());
		return 2;
	}

	if (!exists(filename))
	{
		myprintf("02717! Cannot find backup file %Z\n",filename.c_str());
		return 2;
	}


	if (!flagparanoid)
	{
		string primariga=prendiprimariga(filename);
		if (primariga!="")
		{
			if (flagdebug3)
				myprintf("02718: First row %s\n",primariga.c_str());
			unsigned int lastpipe=primariga.size();
			while (lastpipe>0)
				if (primariga[lastpipe--]=='|')
					break;
			if (flagdebug3)
				myprintf("02719: lastpipe %08d\n",lastpipe);
			if (lastpipe>0)
			{
				string originalname=primariga.substr(lastpipe+2,primariga.size()-lastpipe-3);
				if (flagdebug)
					myprintf("02720: originalname |%s|\n",originalname.c_str());
				string originalpath=extractfilepath(originalname);
				string currentpath=extractfilepath(filename);
				if (flagverbose)
					if (originalpath!=currentpath)
					{
						color_yellow();
						myprintf("02721$ *** WARNING: original backup path <<%s>> != current index path <<%s>>\n",originalpath.c_str(),currentpath.c_str());
						myprintf("02722$ *** I highly recommend using -paranoid! ***\n");
						color_restore();
					}
			}
		}
	}
	
	int64_t starttime=mtime();
	printbar('=');
	multipart archivechunks(zpaqchunks);
	if (archivechunks.isgood)
	{
		if (flagverbose)
			myprintf("02725: Multipart backup looks good\n");
	}
	else
	{
		myprintf("02726! Multipart backup NOT GOOD\n");
		return 2;
	}
	myprintf("02727: Loading backupfile... %Z\n",filename.c_str());
	if (!fileexists(filename))
	{
		myprintf("02728! backup file does not exists\n");
		return 2;
	}
	if (!iszpaqfranzfile(filename,"$zpaqfranz backupfile|"))
	{
		myprintf("02729! File does not seems zpaqfranz's backup\n");
		return 2;
	}
	FILE* myfile = freadopen(filename.c_str());
	if (myfile==NULL)
	{
		myprintf("02730! guru cannot open the backup\n");
		return 2;
	}
#ifdef ANCIENT
	char 	line[16384];
#else
	char 	line[65536];
#endif // corresponds to #ifdef (#ifdef ANCIENT)

	int		riga	=0;
	int		maxriga	=0;
	string 	linea;

	while (fgets(line, sizeof(line), myfile))
		maxriga++;
	fseeko(myfile,0,SEEK_SET);

	if (g_rangefrom!=0)
		myprintf("02731: Rangefrom %08d\n",g_rangefrom);
	if (g_rangeto!=0)
		myprintf("02732: Rangeto   %08d\n",g_rangeto);

	int	minimo	=g_rangefrom;
	int massimo	=g_rangeto;
	if (minimo<1)
		minimo=1;
	if ((massimo>maxriga-1) || (massimo<minimo))
		massimo=maxriga-1;

	myprintf("02733: Rows in backup %08d from %08d to %08d\n",maxriga-1,minimo,massimo);
	vector<string> 	filenames;
	vector<int64_t>	filesizes;
	vector<string>	filehashes;
	vector<string>	filequickhashes;
	vector<int64_t>	filenumbers;
	vector<string>	filedate;
	while (fgets(line, sizeof(line), myfile))
	{
		linea=line;
		if (flagdebug3)
			myprintf("02734: line %s\n",linea.c_str());
		if (linea.size()<40)
		{
			myprintf("02735! getted a too small line |%s| |%s|\n",migliaia(linea.size()),linea.c_str());
			fclose(myfile);
			return 2;
		}
		if (riga==0)
		{
			if (mypos("|XXH3|",linea)>0)
			{
				myprintf("02736: Enabling XXH3 (in reading) hasher\n");
				flagbackupxxh3=true;
			}
			if (mypos("|ZETA|",linea)>0)
			{
				myprintf("94525: Enabling ZETA (in reading) hasher\n");
				flagbackupzeta=true;
			}
		}
		if ((riga>=minimo) && (riga<=massimo))
		{
			string thehash="";
			unsigned int i=0;
			while (i<linea.size())
			{
				if ((isdigit(linea[i])) || (isalpha(linea[i])))
					thehash+=linea[i++];
				else
					break;
			}
			if (flagdebug3)
				myprintf("02737: The hash |%s|\n",thehash.c_str());
			if (thehash.size()!=32)
			{
				myprintf("02738! Hash length not good\n");
				return 2;
			}
			if (linea[i]!=' ')
			{
				myprintf("02739! Space not found\n");
				return 2;
			}
			i++;
			string thefilename="";
			while (i<linea.size())
				if (linea[i]!='|')
					thefilename+=linea[i++];
				else
					break;
			/// this is the file.txt, discard
			if (flagdebug3)
			{
				myprintf("02740: The txt <<%Z>>\n",thefilename.c_str());
			}
			i++;
			if (linea[i]!='[')
			{
				myprintf("02741! File len marker KO\n");
				return 2;
			}
			string sfilesize="";
			i++;
			while (i<linea.size())
			{
				if (linea[i]==']')
					break;
				if (isdigit(linea[i]))
					sfilesize+=linea[i];
				i++;
			}
			uint64_t filesize=myatoll(sfilesize.c_str());
			if (flagdebug3)
				myprintf("02742: filesize |%s|\n",migliaia(filesize));
			i++;
			i++;
			if (linea[i]!='<')
			{
				myprintf("02743! < KO\n");
				return 2;
			}
			i++;
			string thequickhash="";
			while (i<linea.size())
			{
				if (ishex(linea[i]))
					thequickhash+=linea[i];
				else
					break;
				i++;
			}
			if (flagdebug3)
				myprintf("02744: the quickhash |%s|\n",thequickhash.c_str());

			i++;
			if (linea[i]!=' ')
			{
				myprintf("02745! Space filename KO\n");
				return 2;
			}
			i++;
			string thedate="";
			if (linea[i]=='$')
				if ((i+22)<linea.size())
					if (linea[i+20]=='$')
					{
						thedate=linea.substr(i+1,19);
						i+=22;
						if (flagdebug3)
							myprintf("02746: The date $%s$\n",thedate.c_str());
						filedate.push_back(thedate);
					}
				
			thefilename="";
			while (i<linea.size())
			{
				if ((linea[i]!=10) && (linea[i]!=13))
					thefilename+=linea[i];
				i++;
			}
			if (flagdebug3)
			{
				myprintf("02747: The filename <<%Z>>\n",thefilename.c_str());
			}
			int	thepartnumber=getpartnumber(thefilename);
			if (thepartnumber<0)
				myprintf("02748: Houston thefilename is not ok %s\n",thefilename.c_str());
			else
			{
				if (flagdebug3)
					myprintf("02749: zpaq piece %s\n",migliaia(thepartnumber));
				filenumbers.		push_back(thepartnumber);
				filenames.			push_back(thefilename);
				filequickhashes.	push_back(thequickhash);
				filehashes.			push_back(thehash);
				filesizes.			push_back(filesize);
			}
		}
		riga++;
	}
	fclose(myfile);

	if ((!flagverify) && (!flagquick))
	{
		myprintf("02750: First stage syntax check: OK\n");
		return 0;
	}
	string percorso=tofiles[0];
	if (!isdirectory(percorso))
			percorso+="/";
	int64_t	totalsize=0;
	for (unsigned int i=1;i<=filenames.size();i++)
	{
		if (i<filenames.size()-1)
		{
			if (flagverbose)
				myprintf("02751: Working on %08d  %08d %s\n",(int)i,filenumbers[i],filenames[i].c_str());
			if (filenumbers[i]+1!=filenumbers[i+1])
			{
				string 	i_candidato		=extractfilename(filenames[i]);
				string 	i_numerini_i	=i_candidato.substr(i_candidato.size()-13,8);
				int64_t inumerini		=myatoll(i_numerini_i.c_str())+1;

				string 	ip_candidato	=extractfilename(filenames[i+1]);
				string 	ip_numerini_i	=ip_candidato.substr(ip_candidato.size()-13,8);
				int64_t ipnumerini		=myatoll(ip_numerini_i.c_str())-1;

				string partetestuale=extractfilename(filenames[i]);
				partetestuale=partetestuale.substr(0,partetestuale.size()-13);

				myprintf("02752: We have a hole in part numbers [%s..%s], checking if 0-bytes\n",migliaia(inumerini),migliaia2(ipnumerini));
				for (unsigned int k=inumerini;k<=ipnumerini;k++)
				{
					char buffer[16];
					snprintf(buffer,sizeof(buffer),"%08d",(int)k);
					string fileinthehole=extractfilepath(filenames[i])+partetestuale+buffer+".zpaq";
					myprintf("02753: File in the hole %s\n",fileinthehole.c_str());
					if (!fileexists(fileinthehole))
					{
						myprintf("02754! Cannot find expected 'hole' %Z\n",fileinthehole.c_str());
						return 2;
					}
					if (prendidimensionefile(fileinthehole.c_str())!=0)
					{
						myprintf("02755! Expected file not 0-bytes long %Z\n",fileinthehole.c_str());
						return 2;
					}
				}
			}
		}
		string solonomefile=extractfilename(filenames[i-1]);
		string filedefinitivo=percorso+solonomefile;
		franzreplace(filedefinitivo);

		if (!flagnoeta)
		{
			myprintf("02756: Initial check part <<%Z>>\r",filedefinitivo.c_str());
		}

		if (!fileexists(filedefinitivo))
		{
			myprintf("\n");
			myprintf("02758! File does not exists\n");
			return 2;
		}
		int64_t larghezzain=prendidimensionefile(filedefinitivo.c_str());
		if (larghezzain!=filesizes[i-1])
		{
			myprintf("\n");
			myprintf("02759! Filesize does not match real %s vs expected %s\n",migliaia(larghezzain),migliaia2(filesizes[i-1]));
			return 2;
		}
		filenames[i-1]=filedefinitivo;
		totalsize+=larghezzain;
	}
	printbar(' ',true);
	vector<mycoppia> couple_hashname;
	if (flagchecktxt)
		if (checktxt!="")
		{
			printbar('*');
			myprintf("02760: COMPARING CHECKTXT HASHES VS INDEX TXT\n");
			string md5file=checktxt;
			if (!fileexists(md5file))
			{
				myprintf("02761! checksum file not found %Z\n",md5file.c_str());
				return 2;
			}
			vector<string> arraymd5;
			if (!readfiletoarray(md5file,arraymd5))
			{
				myprintf("02763! I quit, cannot read to array!\n");
				return 2;
			}
			unsigned int	trovati				=0;
			unsigned int	nontrovati			=0;
			unsigned int	trovatihashok		=0;
			unsigned int	trovatihashkaputt	=0;
			for (unsigned int i=0;i<arraymd5.size();i++)
			{
				if (flagdebug3)
					myprintf("02764: %08d %s\n",(int)i,arraymd5[i].c_str());

				string	theline		=arraymd5[i];
				string 	thehash		="";
				string	thefilename	="";
				string	thedate		="";
				unsigned int j=0;
				while (j<theline.size())
				{
					if (ishex(theline[j]))
						thehash+=theline[j];
					else
						break;
					j++;
				}
				if (thehash.size()==32)
				{
					if (theline[j]!=' ')
					{
						myprintf("02765: no space after hash\n");
						thehash="";
					}
					else
					{
						j++;
						while (j<theline.size())
							thefilename+=theline[j++];
						if (thefilename.size()>0)
						{
#ifdef _WIN32
							thefilename		=stringtolower(thefilename);
#endif // corresponds to #ifdef (#ifdef _WIN32)
							if (isbackuppart(thefilename,onlyname))
								if (getpartnumber(thefilename)>0)
									couple_hashname.push_back(std::pair<string,string>(stringtolower(thehash),wintolinuxpath(thefilename)));
						}
					}
				}
				else
					thehash="";
			}

			///myprintf("02766: Found %s rows matched\n",migliaia(couple_hashname.size()));
			for (unsigned int i=0;i<couple_hashname.size();i++)
			{
				if (flagverbose)
					myprintf("%08d |%s| |%s|\n",(int)i,couple_hashname[i].first.c_str(),couple_hashname[i].second.c_str());
				string filename=couple_hashname[i].second;
				bool trovatodopotutto=false;

				for (unsigned int j=0;j<filenames.size();j++)
				{
					if (extractfilename(filename)==extractfilename(filenames[j]))
					{
						trovatodopotutto=true;
						trovati++;
						if (flagverbose)
							myprintf("02767: EUREKA : ");
						if (couple_hashname[i].first==filehashes[j])
						{
							if (flagverbose)
							myprintf("02768: HASH MATCH <<");
							trovatihashok++;
						}
						else
						{
							if (flagverbose)
								myprintf("02769: HASH KAPUTT %s %s <<",couple_hashname[i].first.c_str(),filehashes[j].c_str());
							trovatihashkaputt++;
						}
						if (flagverbose)
						{
							printUTF8(extractfilename(filename).c_str());
							myprintf(">>\n");
						}
					}
				}
				if (!trovatodopotutto)
				{
					nontrovati++;
					myprintf("02770: Cannot find %Z\n",extractfilename(filename).c_str());
				}

			}
			myprintf("02772: %8s vs exp %8s :",migliaia(trovati),
			migliaia2(couple_hashname.size()));
			if (trovati==couple_hashname.size())
				myprintf(" THIS IS GOOD\n");
			else
				myprintf(" NOT GOOD!\n");

			myprintf("02773: HASH OK     %12s :",migliaia(trovatihashok));
			if (trovatihashok==trovati)
				myprintf(" THIS IS GOOD\n");
			else
				myprintf(" NOT GOOD!\n");

			myprintf("02774: HASH KAPUTT %12s :",migliaia(trovatihashkaputt));
			if (trovatihashkaputt==0)
				myprintf(" THIS IS GOOD\n");
			else
				myprintf(" NOT GOOD!\n");

			myprintf("02775: NOT FOUND   %12s :",migliaia(nontrovati));
			if (nontrovati==0)
				myprintf(" THIS IS GOOD\n");
			else
				myprintf(" NOT GOOD!\n");

			if ((trovatihashok!=trovati) || (trovati!=couple_hashname.size() || (nontrovati>0)))
			{
				myprintf("02776! Something is wrong, exit (use -verbose or - debug)\n");
				return 2;
			}
			printbar('!');
		}
	if (flagquick)
		myprintf("02777: Quick hash check\n");
	else
		myprintf("02778: Now FULL hash check\n");
	vector<mycoppia> tobehasheddest_hashname;

	string myhashalgo="MD5";
	if (flagbackupxxh3)
		myhashalgo="XXH3";

	if (flagquick)
		myhashalgo="QUICK";
	else
	if (flagbackupzeta)
		myhashalgo="ZETA";
	///myprintf("94886: MMMMMM vado di hash parallelo\n");
	franzparallelhashfiles(myhashalgo,totalsize,filenames,false,tobehasheddest_hashname);

	std::sort(tobehasheddest_hashname.begin(), tobehasheddest_hashname.end(), compare_second);
	printbar(' ',true);
	if (flagverbose)
		myprintf("02779: Report\n");

	bool flagallok=true;
	libzpaq::SHA256 globalesha256;

	for (unsigned int i=0;i<tobehasheddest_hashname.size();i++)
	{
		for (const char* p=tobehasheddest_hashname[i].first.c_str(); *p; ++p)
			globalesha256.put(*p);
		
		if (flagverbose)
			myprintf("02780: %Z:%s:<%Z>\n",tobehasheddest_hashname[i].second.c_str(),myhashalgo.c_str(),tobehasheddest_hashname[i].first.c_str());
	
		string	hashfromfile="";
		if (flagquick)
		{
			hashfromfile=stringtolower(filequickhashes[i]);
	///		myprintf("QUICKKKKKK\n");
		}
		else
		{
		///	myprintf("SLOOOWWW\n");
			hashfromfile=stringtolower(filehashes[i]);
		
			if (flagbackupzeta)
				if (hashfromfile.size()==32) /// -verify
				{
					string temp1=hashfromfile.substr(0, 4);
					string temp2=hashfromfile.substr(4,16);
					string temp3=hashfromfile.substr(20,4);
					string temp4=hashfromfile.substr(24,8);
					if (flagdebug3)
					{
						myprintf("94920: temp1 |%s|\n",temp1.c_str());
						myprintf("94921: temp2 |%s|\n",temp2.c_str());
						myprintf("94922: temp3 |%s|\n",temp3.c_str());
						myprintf("94923: temp4 |%s|\n",temp4.c_str());
					}
					if ((temp1=="zzzz") && (temp3=="wwww"))
					{
						hashfromfile	=temp2;
						filehashes[i]	=temp2;
					}
				}
		}
		///myprintf("+++++++++++++++ %s\n",hashfromfile.c_str());
		if (hashfromfile!=stringtolower(tobehasheddest_hashname[i].first))
		{
			myprintf("02781! ERROR: real hash %s vs expected %s on %Z\n",tobehasheddest_hashname[i].first.c_str(),filehashes[i].c_str(),tobehasheddest_hashname[i].second.c_str());
			flagallok=false;
		}
		else
		{
			if (flagverbose)
				myprintf("02783: OK\n");
		}
	}
	char sha256result[32];
	memcpy(sha256result, globalesha256.result(), 32);
	myprintf("02784: GLOBAL SHA256: ");
	for (int j=0; j <= 31; j++)
		myprintf("%02X", (unsigned char)sha256result[j]);
	myprintf("\n");

	if (flagallok)
	{
		double velocita=totalsize/((mtime()-starttime+1)/1000.0);
		myprintf("02785: Chunks checked OK: %s (%s @ %s/s)\n",migliaia(tobehasheddest_hashname.size()),
		migliaia2(totalsize),
		migliaia3((int64_t)velocita)
		);
	}
	else
	{
		myprintf("02786: *** ALREADY IN ERROR ***\n");
	}
	if (filedate.size()>0)
		myprintf("02787: Last date %s\n",filedate[filedate.size()-1].c_str());
	if (flagparanoid)
	{
		if (fileexists(indexname))
		{
			bool matchok=true;
			printbar('-');
			int64_t	index_usize			=0;
			int64_t index_allsize		=0;
			int64_t	index_dtsize		=0;
			int64_t	index_compressedsize=0;
			getzpaqsum(indexname,index_usize,index_allsize,index_dtsize,index_compressedsize);
			printbar('-');
			int64_t	chunk_usize			=0;
			int64_t chunk_allsize		=0;
			int64_t	chunk_dtsize		=0;
			int64_t	chunk_compressedsize=0;
			getzpaqsum(zpaqchunks,chunk_usize,chunk_allsize,chunk_dtsize,chunk_compressedsize);

			myprintf("02788: dtsize     %21s [i] %21s [c]:",migliaia(index_dtsize),migliaia2(chunk_dtsize));
			if (index_dtsize==chunk_dtsize)
				myprintf(" OK\n");
			else
			{
				myprintf(" ERROR\n");
				matchok=false;
			}

			myprintf("02789: usize      %21s [i] %21s [c]:",migliaia(index_usize),migliaia2(chunk_usize));
			if (index_usize==chunk_usize)
				myprintf(" OK\n");
			else
			{
				myprintf(" ERROR\n");
				matchok=false;
			}
			myprintf("02790: allsize    %21s [i] %21s [c]:",migliaia(index_allsize),migliaia2(chunk_allsize));
			if (index_allsize==chunk_allsize)
				myprintf(" OK\n");
			else
			{
				myprintf(" ERROR\n");
				matchok=false;
			}
			myprintf("02791: compressed %21s [i] %21s [c]:",migliaia(index_compressedsize),migliaia2(chunk_compressedsize));

			if (index_compressedsize==chunk_compressedsize)
				myprintf(" OK\n");
			else
			{
				myprintf(" ERROR\n");
				matchok=false;
			}
			if (!matchok)
			{
				flagallok=false;
				myprintf("02792: Index data != chunks. Wrong append? Manual update?\n");
			}
		}
		else
		{
			myprintf("02793: index does not exists <<%Z>>\n",indexname.c_str());
			flagallok=false;
		}
	}
	if (flagallok)
		return 0;
	else
		return 2;
}
int Jidac::backup()
{
	if (archive=="")
	{
		myprintf("02795! You need a non-empty archive name\n");
		return 2;
	}
	if (strrchr(archive.c_str(), '?'))
	{
		myprintf("02796! Backup is for managed multipart, do not use ?\n");
		return 2;
	}

	archive=format_datetime(archive);

	g_backupposition=extractfilepath(archive);
	if (g_indexname!="")
	{
		g_backupposition=extractfilepath(includetrailingbackslash(g_indexname));
		if (flagverbose)
			myprintf("02797: -index automagically managed g_backuposition |%s|\n",g_backupposition.c_str());
		if (!direxists(g_backupposition))
		{
			myprintf("02798! the folder (of -index) need to (already) exists %Z\n",g_backupposition.c_str());
			return 2;
		}
		color_yellow();
		myprintf("02800$ *** WARNING: It's YOUR job to preserve _backup.index and _backup.txt! ***\n");
		color_restore();
	}
	
	g_indexname			="";
	index=NULL;
	archive=extractfilepath(archive)+prendinomefileebasta(archive)+"_????????.zpaq";
	
	if (!flagnopid)
	{
		g_pidname=g_backupposition+prendinomefileebasta(archive)+".pid";
		myreplaceall(g_pidname,"?","0");

		if (!flagspace)
			if (isbackuprunning())
			{
				myprintf("02801: Quit because backup seems running. -space to bypass\n");
				return 1;
			}
	}

	printbar('+');
	myprintf("96069: Hello, now is %s\n",dateToString(true,now()).c_str());
		
	multipart archivechunks(archive);
	if (archivechunks.isgood)
	{
		if (flagverbose)
			myprintf("02802: Multipart backup seems OK\n");
	}
	else
	{
		myprintf("02803! Multipart backup DOES NOT SEEMS GOOD!\n");
		myprintf("02804! To prevent corruption no 'holes' in numeration allowed\n");
		myprintf("02805! Manually fill with 0-bytes [ex touch] to bypass\n");
		return 2;
	}


	if (flagverbose)
	{
		myprintf("02806: Last part %Z\n",archivechunks.lastpart.c_str());
		myprintf("02807: Next part %Z\n",archivechunks.nextpart.c_str());
		if (!flagnopid)
			myprintf("02808: Pid       %Z\n",g_pidname.c_str());
	}

	if (!flagnopid)
	{
		if (!saggiascrivibilitacartella(g_pidname))
			myprintf("95143$ cannot write pid <<%Z>>\n",g_pidname.c_str());
		FILE* handlepid=fopen(g_pidname.c_str(), "wb");
		if (handlepid==NULL)
		{
			myprintf("02812! cannot write on pid %Z (no writeable folder?)\n",g_pidname.c_str());
			return 2;
		}
		g_pid_handle=handlepid;
		fprintf(handlepid,"Starting backup @ %s\n",dateToString(true,now()).c_str());
		fclose(handlepid);
	}
	int risultato=add();

	if (!flagnopid)
		if (fileexists(g_pidname))
			delete_file(g_pidname.c_str());

	return risultato;
}

string from_delimiter(const string& s, string delim) 
{
    // Find the last position of the delimiter
    size_t last_delim_pos = s.rfind(delim);
    
    // If the delimiter is not found, return the original string
    if (last_delim_pos == string::npos) {
        return s;
    }
    
    // Extract the substring after the last delimiter
    string result = s.substr(last_delim_pos + delim.length());
    
    // Remove characters #10 (Line Feed) and #13 (Carriage Return)
    string cleaned_result;
    for (size_t i=0;i<result.length(); i++) 
        if (result[i] != '\n' && result[i] != '\r') 
            cleaned_result += result[i];
    
    return cleaned_result;

}


bool is_same_path(const std::string& i_old, const std::string& i_new) 
{
	if ((i_old=="") || (i_new==""))
		return false;
		
#ifdef _WIN32
	string percorso_old=extractfilepath(i_old);
	string percorso_new=extractfilepath(i_new);
	myreplaceall(percorso_old,"/","\\");
	myreplaceall(percorso_new,"/","\\");
	std::wstring old_wstr(percorso_old.begin(), percorso_old.end());
	std::wstring new_wstr(percorso_new.begin(), percorso_new.end());
	wchar_t old_resolved[32768], new_resolved[32768];
	wchar_t* old_full = _wfullpath(old_resolved, old_wstr.c_str(), sizeof(old_resolved)/sizeof(wchar_t));
	wchar_t* new_full = _wfullpath(new_resolved, new_wstr.c_str(), sizeof(new_resolved)/sizeof(wchar_t));
	if (flagdebug3)
	{
		myprintf("\n");
		myprintf("96024: old_full %s\n",wtou(old_full).c_str());
		myprintf("96024: new_full %s\n",wtou(new_full).c_str());
	}
	if ((!old_full) || (!new_full))
	{
		myprintf("96038! old_full or new_full KAPUTT\n");
		return false;
	}
	return (_wcsicmp(old_resolved, new_resolved) == 0);
#else
	char old_resolved[32768], new_resolved[32768];
	const char* old_full = realpath(i_old.c_str(), old_resolved);
	const char* new_full = realpath(i_new.c_str(), new_resolved);
	
	if ((!old_full) || (!new_full))
	{
		myprintf("96022! old_full or new_full KAPUTT\n");
		return false;
	}

	return (strcmp(old_resolved, new_resolved) == 0);
#endif // corresponds to #ifdef (#ifdef _WIN32)
	return false;
}

bool copy_or_rename(const std::string& i_old, const std::string& i_new) 
{
	if (i_old=="")
	{
		myprintf("95991! i_old empty\n");
		return false;
	}
	if (i_new=="")
	{
		myprintf("95995! i_new empty\n");
		return false;
	}

	bool same_path=is_same_path(i_old,i_new);
	if (flagdebug3)
	{
		if (same_path)
			myprintf("\nSAAAMEEEE\n");
		else
			myprintf("\nDIFFERENT\n");
	}
	if (same_path) 
		return (myrename(i_old,i_new)==0);
	else 
	{
		string risultato=filecopy(
								true, // singlefile
								false, // append
								i_old,i_new,
								flagverify, //verify
								true,  //donocheckspace
								false, ///overwrite
								0 );
		return (risultato!="");
	}
}

int Jidac::consolidatebackup()
{
	if (flagbackupzeta)
	{
		myprintf("95459! Cannot consolidate with -backupzeta, sorry. Try -backupxxh3\n");
		return 2;
	}
		
	flagquick=true;
	if (flagverify)
		flagquick=false;

	if (files.size()!=1)
	{
		myprintf("02814! consolidate require one file parameter\n");
		return 2;
	}
	if (isjolly(files[0]))
	{
		myprintf("02815! Do not use ? for backups\n");
		return 2;
	}
	
	if (flagdestination)
		if (g_destination!="")
		{
			if (!iszpaq(files[0]))
			{
				myprintf("96097: You must insert a full .zpaq name (ex. z:\\test\\due.zpaq)\n");
				return 2;
			}
			if (!iszpaq(g_destination))
			{
				myprintf("96098: You must insert a full -destination .zpaq name (ex. j:\\output\\new.zpaq)\n");
				return 2;
			}
			
#ifdef _WIN32
			if ((!iswindowspath(files[0])) && (!iswindowsunc(files[0])))
				files[0]=relativetolongpath(files[0]);
			if ((!iswindowspath(g_destination)) && (!iswindowsunc(g_destination)))
				g_destination=relativetolongpath(g_destination);
			files[0]		=stringtolower(files[0]);
			g_destination	=stringtolower(g_destination);
#endif // corresponds to #ifdef (#ifdef _WIN32)
			
			myprintf("95988: Renaming <<%Z>> to -destination <<%Z>>\n",files[0].c_str(),g_destination.c_str());
			
			string 	oldindexname	=extractfilepath(files[0])+prendinomefileebasta(files[0])+"_00000000_backup.index";
			if (!fileexists(oldindexname))
			{
				myprintf("95994! Index zpaq file not found <<%Z>>\n",oldindexname.c_str());
				return 2;
			}
			
			string 	newindexname	=extractfilepath(g_destination)+prendinomefileebasta(g_destination)+"_00000000_backup.index";
			
			
			if (fileexists(newindexname))
			{
				myprintf("96024! New Index zpaq does exists <<%Z>>\n",newindexname.c_str());
				return 2;
			}
			
			string 	theindex=extractfilepath(files[0])+prendinomefileebasta(files[0])+"_00000000_backup.txt";
			if (!fileexists(theindex))
			{
				myprintf("95994! Index file not found <<%Z>>\n",theindex.c_str());
				return 2;
			}
			string 	newindex=extractfilepath(g_destination)+prendinomefileebasta(g_destination)+"_00000000_backup.txt";
			if (fileexists(newindex))
			{
				myprintf("95993! The new index file already exists <<%Z>>\n",newindex.c_str());
				return 2;
			}
			string 	solonomeiniziale	=prendinomefileebasta(files[0]);
			string	solonomefinale		=prendinomefileebasta(g_destination);
						
			if ((solonomeiniziale=="") || (solonomefinale==""))
			{
				myprintf("96008: Initial <<%Z>> or final <<%Z>> name not good\n",solonomeiniziale.c_str(),solonomefinale.c_str());
				return 2;
			}
			if (flagdebug3)
			{
				myprintf("96035: From %Z\n",solonomeiniziale.c_str());
				myprintf("96035: To   %Z\n",solonomefinale.c_str());
			}
			string rinomina_from	=extractfilepath(files[0])+solonomeiniziale;
			string rinomina_to		=extractfilepath(g_destination)+solonomefinale;
			if (flagdebug3)
			{
				myprintf("96034: rinomina_from %Z\n",rinomina_from.c_str());
				myprintf("96032: rinomina_to   %Z\n",rinomina_to.c_str());
			}
			
			string	zpaqchunks	=extractfilepath(files[0])+prendinomefileebasta(files[0])+"_????????.zpaq";
	
			multipart archivechunks(zpaqchunks);
			if (!archivechunks.isgood)
			{
				myprintf("96016! Multipart backup NOT GOOD <<%Z>>\n",zpaqchunks.c_str());
				return 2;
			}
			if (!iszpaqfranzfile(theindex,"$zpaqfranz backupfile|"))
			{
				myprintf("96021! File does not seems zpaqfranz's backup\n");
				return 2;
			}
			FILE* myfile = freadopen(theindex.c_str());
			if (myfile==NULL)
			{
				myprintf("96027! guru cannot open the backup %Z\n",theindex.c_str());
				return 2;
			}
			FILE* backupfile=fopen(newindex.c_str(), "wb");
			if (backupfile==NULL)
			{
				myprintf("96085! Cannot write on newindex %Z\n",newindex.c_str());
				fclose(myfile);
				return 2;
			}
#ifdef ANCIENT
			char 	line[16384];
#else
			char 	line[65536];
#endif // corresponds to #ifdef (#ifdef ANCIENT)

			int		riga	=0;
			string 	linea;

			while (!feof(myfile) && !ferror(myfile))
			{
				if (fgets(line, sizeof(line), myfile) == NULL)
					break;
					
				linea = line;
				if (flagdebug3)
					myprintf("96051: line %s\n", linea.c_str());
					
				if (linea.size() < 40)
				{
					myprintf("96054! getted a too small line |%s| |%s|\n", migliaia(linea.size()), linea.c_str());
					fclose(myfile);
					fclose(backupfile);
					return 2;
				}
				
				string newlinea;
				
				if (riga == 0)
					newlinea = from_delimiter(linea, "|");
				else
					newlinea = from_delimiter(linea, "$ ");
					
				if (flagdebug3)
					myprintf("96187: newlinea |%s|\n", newlinea.c_str());
					
				string nomedelfile = extractfilename(newlinea);
				if (flagdebug3)
					myprintf("96190: nomedelfile (1) %s\n", nomedelfile.c_str());
					
				myreplace(nomedelfile, solonomeiniziale, solonomefinale);
				
				if (flagdebug3)
					myprintf("96193: nomedelfile (2) %s\n", nomedelfile.c_str());
					
				nomedelfile = extractfilepath(g_destination) + nomedelfile;
				if (flagdebug3)
					myprintf("96193: nomedelfile (3) %s\n", nomedelfile.c_str());
				
				string lineacorretta = linea;
				myreplace(lineacorretta, newlinea, nomedelfile);
				
				fprintf(backupfile, "%s", lineacorretta.c_str());
				riga++;
			}

			fclose(myfile);
			fclose(backupfile);

			myprintf("96107: Copy-Rename .index <<%Z>> => <<%Z>> :",oldindexname.c_str(),newindexname.c_str());
			color_green();
			myprintf("OK\n");
			color_restore();
			
			if (!copy_or_rename(oldindexname,newindexname))
			//if (myrename(oldindexname,newindexname)!=0)
			{
				myprintf("\n");
				myprintf("96110! KAPUTT copy_or_rename .index!\n");
				return 2;
			}					
			
			for (unsigned int i=0;i<archivechunks.filenamearray.size();i++)
			{
				string oldfile=archivechunks.filenamearray[i].filename;
				string newfile=oldfile;
		///		myreplace(newfile,solonomeiniziale,solonomefinale);
				myreplace(newfile,rinomina_from,rinomina_to);
				if (flagdebug3)
				{
					myprintf("96332: oldfile       %Z\n",oldfile.c_str());
					myprintf("96333: rinomina_from %s\n",rinomina_from.c_str());
					myprintf("96333: rinomina_to   %s\n",rinomina_to.c_str());
					myprintf("96333: newfile       %Z\n",newfile.c_str());
				}
				
				myprintf("96094: Copy-Rename (1) <<%Z>> => <<%Z>> :",oldfile.c_str(),newfile.c_str());
				if (!copy_or_rename(oldfile,newfile))
				///if (myrename(oldfile,newfile)!=0)
				{
					myprintf("\n");
					myprintf("96123! KAPUTT copy_or_rename!\n");
					return 2;
				}					
				color_green();
				myprintf("OK\n");
				color_restore();
			}
			if (is_same_path(files[0],g_destination))
				if (delete_file(theindex.c_str()))
					myprintf("96335: Deleted the old index <<%Z>>\n",theindex.c_str());
			return 0;
		}
		if (tofiles.size()!=1)
		{
			myprintf("02816! consolidate require one -to (the output zpaq)\n");
			return 2;
		}

#ifdef _WIN32
			if ((!iswindowspath(tofiles[0])) && (!iswindowsunc(tofiles[0])))
				tofiles[0]=relativetolongpath(tofiles[0]);
			tofiles[0]=stringtolower(tofiles[0]);
			
			if ((!iswindowspath(files[0])) && (!iswindowsunc(files[0])))
				files[0]=relativetolongpath(files[0]);
			files[0]=stringtolower(files[0]);
#else
	if (mypos("/",files[0])==-1)
	{
		files[0]="./"+files[0];
		myprintf("02817: fixed filename %Z\n",files[0].c_str());
	}
#endif // corresponds to #ifdef (#ifdef _WIN32)
	myprintf("96376: Consolidating <<%Z>> to <<%Z>>\n",files[0].c_str(),tofiles[0].c_str());
	if (!flagnopid)
	{
		g_pidname	=extractfilepath(files[0])+prendinomefileebasta(files[0])+"_00000000.pid";

		if (!flagspace)
			if (isbackuprunning())
			{
				myprintf("02819: Quit because backup seems running. -space to bypass\n");
				return 1;
			}
	}
	string	firstzpaq	=extractfilepath(files[0])+prendinomefileebasta(files[0])+"_00000001.zpaq";
	string	zpaqchunks	=extractfilepath(files[0])+prendinomefileebasta(files[0])+"_????????.zpaq";
	string	lonezpaq	=extractfilepath(files[0])+prendinomefileebasta(files[0])+".zpaq";

	string 	onlyname=extractfilename(files[0]);
	myreplace(onlyname,"????????.zpaq","");
	myreplace(onlyname,".zpaq","");

	bool esistelone			=fileexists(lonezpaq);
	bool esistebackup		=fileexists(firstzpaq);

	if (esistelone && esistebackup)
	{
		myprintf("02820! I am confused (normal zpaq and backup does co-exists) %Z <-> %Z\n",lonezpaq.c_str(),firstzpaq.c_str());
		return 2;
	}
	if ((!esistelone) && (!esistebackup))
	{
		myprintf("02822! Cannot find normal zpaq or backup %Z <-> %Z\n",lonezpaq.c_str(),firstzpaq.c_str());
		return 2;
	}

	string 	tofilez			=tofiles[0];
	string 	newindexname	=extractfilepath(tofilez)+prendinomefileebasta(tofilez)+"_00000000_backup.index";
	string 	newfilename		=extractfilepath(tofilez)+prendinomefileebasta(tofilez)+"_00000000_backup.txt";
	string	newfirstzpaq	=extractfilepath(tofilez)+prendinomefileebasta(tofilez)+"_00000001.zpaq";
	string	newlonezpaq		=extractfilepath(tofilez)+prendinomefileebasta(tofilez)+".zpaq";

	bool esistenewindex		=fileexists(newindexname);
	bool esistenewtxt		=fileexists(newfilename);
	bool esistenewlonezpaq	=fileexists(newlonezpaq);

	if (esistenewtxt)
	{
		string	newtxt=nomefileseesistegia(newfilename+".bak");
		myprintf("02824: Renaming txt   to %Z\n",newtxt.c_str());
		if (myrename(newfilename,newtxt)!=0)
		{
			myprintf("02826! ===========> KAPUTT RENAMING txt\n");
			return 2;
		}
	}
	if (esistenewindex)
	{
		string	newindex=nomefileseesistegia(newindexname+".bak");
		
		myprintf("02827: Renaming index to %Z\n",newindex.c_str());
		if (myrename(newindexname,newindex)!=0)
		{
			myprintf("02829! ===========> KAPUTT RENAMING index\n");
			return 2;
		}
	}
	if (esistenewlonezpaq)
	{
		string	newlo=nomefileseesistegia(newlonezpaq+".bak");
		
		myprintf("02830: Renaming zpaq to %Z\n",newlo.c_str());
		if (myrename(newlonezpaq,newlo)!=0)
		{
			myprintf("02832! ===========> KAPUTT RENAMING zpaq\n");
			return 2;
		}
	}

	files		.clear();
	tofiles		.clear();
	g_indexname	=newindexname;
	index 		=g_indexname.c_str();

	if (esistebackup)
		archive		=zpaqchunks;
	else
		archive		=lonezpaq;
	command='x';
	extract();
	if (prendidimensionefile(newindexname.c_str())<104)
	{
		myprintf("02833! New index file size too small\n");
		return 2;
	}
	if (esistebackup)
	{
		files.clear();
		files.push_back(newfirstzpaq);
		if (consolidate(zpaqchunks)!=0)
		{
			myprintf("02834! guru for consolidate\n");
			return 2;
		}

	}
	else
	{
		string risultato=filecopy(
		true, // a sigle file
		false, //flagappend
		lonezpaq,
		newfirstzpaq,
		flagverify, //verify
		true,  //donocheckspace
		true, //overwrite
		0); 
		if (risultato=="")
		{
			myprintf("02835! something wrong during filecopy, abort %Z => %Z\n",lonezpaq.c_str(),newfirstzpaq.c_str());
			return 2;
		}
	}

	backuptxt	=newfilename;
	g_archive	=newfirstzpaq;

	int64_t startverify	=mtime();
	int64_t larghezzain	=prendidimensionefile(g_archive.c_str());
	g_dimensione=0;


	string thehash="MD5";
	if (flagbackupxxh3)
		thehash="XXH3";
	if (flagbackupzeta)
		thehash="ZETA";

	myprintf("02837: Getting %s on %s\n",thehash.c_str(),g_archive.c_str());

	franz_do_hash dummy(thehash);
	if (flagdebug3)
		myprintf("02838: filehash on %s\n",g_archive.c_str());

	string hashreloaded=dummy.filehash(0,g_archive,false,startverify,larghezzain);

	if (hashreloaded=="")
	{
		myprintf("02839! Guru calculating %s hash for <<%Z>>\n",thehash.c_str(),g_archive.c_str());
		return 2;
	}
	myprintf("\n");
	myprintf("02841: final %s %s: %s\n",hashreloaded.c_str(),thehash.c_str(),g_archive.c_str());
	myprintf("02842: Doing backup stuff\n");
	myprintf("02843: Creating backup txt %Z\n",backuptxt.c_str());
	FILE* backupfile=fopen(backuptxt.c_str(), "wb");
	if (backupfile==NULL)
	{
		myprintf("02845! Cannot write on backupfile\n");
		return 2;
	}

	fprintf(backupfile,"$zpaqfranz backupfile|2|%s|%s|%s\n",dateToString(true,now()).c_str(),thehash.c_str(),g_archive.c_str());
	franz_do_hash dummyquick("QUICK");
	if (flagdebug3)
		myprintf("02846: filehash on %s\n",g_archive.c_str());

	string quickhash=dummyquick.filehash(0,g_archive,false,startverify,larghezzain);
/*
	if (flagbackupzeta)
	{
		franz_do_hash dummyquick("CRC-32");
		if (flagdebug3)
			myprintf("95652: CRC-32 on %s\n",g_archive.c_str());
		startverify=mtime();
		string zetacrc32=dummyquick.filehash(g_archive,false,startverify,larghezzain);
		hashreloaded="zzzz"+bin2hex_64(g_franzhash_file.hash())+"wwww"+zetacrc32;
	}
	*/
	fprintf(backupfile,"%s %s|[%21s] <%s> $%s$ %s\r\n",stringtolower(hashreloaded).c_str(),checktxt.c_str(),migliaia(larghezzain),quickhash.c_str(),dateToString(true,now()).c_str(),g_archive.c_str());
///	fprintf(backupfile,"%s %s|[%21s] <%s> %s\r\n",     stringtolower(hashreloaded).c_str(),checktxt.c_str(),migliaia(larghezzain),quickhash.c_str(),g_archive.c_str());
	fclose(backupfile);

	g_indexname="";
	archive=newlonezpaq;
	tofiles.push_back(extractfilepath(tofilez));
	files.clear();
	files.push_back(newlonezpaq);
	flagverbose	=true;
	flagverify	=true;
	flagparanoid=true;
	if (check_if_password(newlonezpaq))
		if (plainpassword=="")
			flagparanoid=true;
	g_dimensione=0;
	return testbackup();
}


int Jidac::versum_hashdeep(FILE* i_thefile,
vector<string>& 		o_files,
vector<string>& 		o_filealgo,
vector<string>& 		o_filehash,
vector<int64_t>& 		o_filesize,
int64_t&				o_expected_size,
int&					o_expected_file)
{
	o_expected_size=0;
	o_expected_file=0;

	if (i_thefile==NULL)
	{
		myprintf("02847! file handle is null!\n");
		return 2;
	}


	/// hardcoded file format

#ifdef ANCIENT
	char 	line[16384];
#else
	char 	line[65536];
#endif // corresponds to #ifdef (#ifdef ANCIENT)

	string linea="";
	if (!fgets(line, sizeof(line), i_thefile))
	{
		myprintf("02848! failed reading first line\n");
		return 2;
	}
	linea=line;
	if (linea.size()==0)
	{
		myprintf("02849! first line empty\n");
		return 2;
	}
	if (!fgets(line, sizeof(line), i_thefile))
	{
		myprintf("02850! failed reading second line\n");
		return 2;
	}
	linea=line;
	if (linea.size()==0)
	{
		myprintf("02851! second line empty\n");
		return 2;
	}
	if (linea.size()<6)
	{
		myprintf("02852! second line too short %d\n",linea.size());
		return 2;
	}
	if (linea[0]!='%')
	{
		myprintf("02853! second line char 0 not %%\n");
		return 2;
	}
	if (linea[1]!='%')
	{
		myprintf("02854! second line char 1 not %%\n");
		return 2;
	}
	if (linea[2]!='%')
	{
		myprintf("02855! second line char 2 not %%\n");
		return 2;
	}
	if (linea[3]!='%')
	{
		myprintf("02856! second line char 3 not %%\n");
		return 2;
	}
	if (linea[4]!=' ')
	{
		myprintf("02857! second line char 4 not space\n");
		return 2;
	}
	myreplaceall(linea,"%%%% ","");
	myreplaceall(linea,"\r","");
	myreplaceall(linea,"\n","");
	if (flagdebug3)
	myprintf("02858: $$$$$$$$$$$$ !%s! $$$$$$$$$$$\n",linea.c_str());
	vector<string> pezzi;
	explode(linea,',',pezzi);
	if (flagdebug3)
		for (unsigned int i=0;i<pezzi.size();i++)
			myprintf("%08d !%s!\n",i,pezzi[i].c_str());
	 
	if (pezzi.size()!=3)
	{
		myprintf("02859! second line MUST be of 3 fields (%d here)\n",pezzi.size());
		return 2;
	}
	if (pezzi[0]!="size")
	{
		myprintf("02860! first field is not size |%s|\n",pezzi[0].c_str());
		return 2;
	}
	if (pezzi[2]!="filename")
	{
		myprintf("02861! third field is not filename |%s|\n",pezzi[2].c_str());
		return 2;
	}
	if (pezzi[1]=="tiger")
	{
		myprintf("02862! sorry, tiger hash not supported\n");
		return 2;
	}
	if 	(
		(pezzi[1]!="md5") &&
		(pezzi[1]!="sha-1") &&
		(pezzi[1]!="sha1") &&
		(pezzi[1]!="sha256") &&
		(pezzi[1]!="sha-256") &&
		(pezzi[1]!="whirlpool")
		)
	{
		myprintf("02863! sorry, algo must be md5|sha1|sha256|whirlpool\n");
		return 2;
	}
	myprintf("02864: Hasher selected: %s\n",pezzi[1].c_str());

	while (fgets(line, sizeof(line), i_thefile))
	{
		linea=line;
		if (flagdebug3)
			myprintf("02865: <<%s>>\n",linea.c_str());
		if (linea.size()>0)
			if  (linea[0]!='#')
			{
				string algo		="";
				string hasho	="";
				string sizo		="";
				int64_t isizo	=0;
				string nomeo	="";
				unsigned int 	j=0;
				while (j<linea.size())
				{
					if (isdigit(linea[j]))
						sizo+=linea[j];
					else
						break;
					j++;
				}

				isizo=atoll(sizo.c_str());
				j++;

				while (j<linea.size())
				{
					if (isxdigit(linea[j]))
						hasho+=linea[j];
					else
						break;
					j++;
				}

				j++;
				while (j<linea.size())
					if ((linea[j]!='\r') && (linea[j]!='\n'))
						nomeo+=linea[j++];
					else
						break;
					
				myreplaceall(nomeo,"\\","/");
				franzreplace(nomeo);

				algo	=pezzi[1];
				hasho	=stringtoupper(hasho);
			
				myreplaceall(algo,"sha1","SHA-1");
				myreplaceall(algo,"sha256","SHA-256");
				
				if (flagdebug3)
				{
					myprintf("02866: myfilesize %d\n",isizo);
					myprintf("02867: myfilealgo %s\n",algo.c_str());
					myprintf("02868: myfilehash %s\n",hasho.c_str());
					myprintf("02869: myfiles    %s\n",nomeo.c_str());
				}
				myreplaceall(nomeo,"\\","/");
				franzreplace(nomeo);

				o_filesize	.push_back(isizo);
				o_filealgo	.push_back(algo);
				o_filehash	.push_back(hasho);
				o_files		.push_back(nomeo);
				if (flagdebug3)
					myprintf("02870: Pushed\n");
				o_expected_size+=isizo;
				o_expected_file++;
			}
	}
	if (flagdebug3)
		myprintf("02871: Out of while\n");
	return 0;
}

int Jidac::versum_zpaqfranz(FILE* i_thefile,
vector<string>& 		o_files,
vector<string>& 		o_filealgo,
vector<string>& 		o_filehash,
vector<int64_t>& 		o_filesize,
int64_t&				o_expected_size,
int&					o_expected_file)
{
	o_expected_size=0;
	o_expected_file=0;

	if (i_thefile==NULL)
	{
		myprintf("02872! file handle is null!\n");
		return 2;
	}

#ifdef ANCIENT
	char 	line[16384];
#else
	char 	line[65536];
#endif // corresponds to #ifdef (#ifdef ANCIENT)

	while (fgets(line, sizeof(line), i_thefile))
	{
		string linea=line;
		if (linea.size()==0)
		{
			myprintf("02873! linea.size==0\n");
			return 2;
		}

		if (linea[0]=='|')
		{
			string algo		="";
			string hasho	="";
			string sizo		="";
			int64_t isizo	=0;
			string nomeo	="";
			unsigned int j=1;
			while (j<linea.size())
			{
				if (linea[j]==':')
					break;
				algo+=linea[j];
				j++;
			}
			if (algo=="")
			{
				myprintf("02874! algo is empty\n");
				return 2;
			}
			j+=2;
			while (j<linea.size())
			{
				if (linea[j]==' ')
					break;
				hasho+=linea[j];
				j++;
			}
			j+=2;
			while (j<linea.size())
			{
				if (linea[j]==']')
					break;
				if (isdigit(linea[j]))
					sizo+=linea[j];
				j++;
			}
			isizo=atoll(sizo.c_str());
			j+=2;
			while (j<linea.size())
				if (linea[j++]=='|')
					break;
			while (j<linea.size())
				if ((linea[j]!='\r') && (linea[j]!='\n'))
					nomeo+=linea[j++];
				else
					break;
			o_filesize	.push_back(isizo);
			o_filealgo	.push_back(algo);
			o_filehash	.push_back(hasho);
			o_files		.push_back(nomeo);
			o_expected_size+=isizo;
			o_expected_file++;
		}
	}
	return 0;
}
int Jidac::versum_againstzpaq(vector<string> i_myfiles,vector<string> i_filealgo,vector<string> i_filehash,vector<string>& o_missing,int& o_errori,int64_t& o_total_hashed)
{
	if (tofiles.size()==0)
	{
		myprintf("02875! tofiles size ==0\n");
		return 2;
	}
	/// test against .zpaq
	archive=tofiles[0];
	string estensione=prendiestensione(archive);
	if (estensione!="zpaq")
	{
		myprintf("02876! -to must be a .zpaq archive %Z\n",archive.c_str());
		return 2;
	}
	if (!fileexists(archive))
	{
		myprintf("02878! archive does not exists %Z\n",archive.c_str());
		return 2;
	}
	tofiles.clear();
	int errors=0;
	command='l';
	g_optional="versum"; //force isselected
	read_archive(NULL,archive.c_str(),&errors,1,true);/// silent AND NOW THE MAGIC ONE!
	myprintf("\n");

	myprintf("02880: Total files/fonder in zpaq %s, files in txt %s\n",migliaia(dt.size()),migliaia2(i_myfiles.size()));

	int emptyhash		=0;
	int emptyhashtype	=0;
	int mismatchalgo	=0;

	for (unsigned int i=0;i<i_myfiles.size();i++)
	{
		string	filename=wintolinuxpath(i_myfiles[i]);
		franzreplace(filename);
		
		DTMap::iterator p=dt.find(filename);

		if (p==dt.end())
		{
			o_missing.push_back(filename);
			continue;
		}

		string myhashtype		="";
		string myhash			="";
		string mycrc32			="";
		int64_t	myaccesstime	=0;
		int64_t mycreationtime	=0;
		bool	myisordered		=false;
		int		myversion		=0;
		franz_posix* myposix	=NULL;
		bool	myisadded		=false;
		decode_franz_block(false, //not a dir
		p->second.franz_block,
		myhashtype,
		myhash,
		mycrc32,
		mycreationtime,
		myaccesstime,myisordered,myversion,myposix,myisadded);

		if (myhashtype=="")
		{
			emptyhashtype++;
			if (flagverbose)
				myprintf("02881: empty hashtype %s\n",filename.c_str());
			continue;
		}

		if (myhash=="")
		{
			emptyhash++;
			if (flagverbose)
				myprintf("02882: empty hash %s\n",filename.c_str());
			continue;
		}

		if (stringtoupper(myhashtype)!=stringtoupper(i_filealgo[i]))
		{
			mismatchalgo++;
			if (flagverbose)
				myprintf("02883: mismatch algo zpaq %s txt %s\n",myhashtype.c_str(),i_filealgo[i].c_str());
			continue;
		}
		if (stringtoupper(myhash)!=stringtoupper(i_filehash[i]))
		{
			myprintf("02884! ERROR %s |zpaq=%s|txt=%s| %Z\n",myhashtype.c_str(),i_filehash[i].c_str(),myhash.c_str(),filename.c_str());
			o_errori++;
		}
		o_total_hashed+=p->second.size;
	}
	if (emptyhashtype>0)
		myprintf("02886: Empty hash type %9s\n",migliaia(emptyhashtype));
	if (emptyhash>0)
		myprintf("02887: Empty hash      %9s\n",migliaia(emptyhash));
	if (mismatchalgo>0)
		myprintf("02888: Algo mismatch   %9s\n",migliaia(mismatchalgo));
	if (emptyhashtype+emptyhash+mismatchalgo>0)
		myprintf("02889: Cannot test     %9s\n",migliaia(emptyhashtype+emptyhash+mismatchalgo));
	return 0;
}
void Jidac::franzreplace(string& i_filename)
{
	if ((searchfrom=="") && (replaceto==""))
		return;
	if (searchfrom!="")
	{
		if (flagdebug3)
			myprintf("02890: replace because searchfrom not empty on <<%s>>\n",i_filename.c_str());
#ifdef _WIN32
		replaceinsensitive(i_filename,searchfrom,replaceto);
#else
		replace(i_filename,searchfrom,replaceto);
#endif
		
		if (flagdebug3)
			myprintf("02891: replaced to <<%s>>\n",i_filename.c_str());
		return;
	}
	else
	{
		if (replaceto!="")
		{
			if (flagdebug3)
				myprintf("02892: adjust on <<%s>>\n",i_filename.c_str());
			i_filename=replaceto+i_filename;
			if (flagdebug3)
				myprintf("02893: adjusted to <<%s>>\n",i_filename.c_str());
			return;
		}
	}
}

int Jidac::versum()
{
	if (files.size()==0)
	{
		myprintf("02894! no files selected to be compared\n");
		return 2;
	}
	
	int fastfounded=0;
	for (unsigned int i=0;i<files.size();i++)
	{
		if (!flagads)
			if ((!flagchecktxt) && (!flagfasttxt))
				if (!iswildcard(files[i]))
					if (iszpaq(files[i]))
					{
						string 	thezpaq		=files[i];
						string 	percorso	=extractfilepath		(thezpaq);
						string	nome		=prendinomefileebasta	(thezpaq);
						myprintf("02926: Search for _crc32.txt  ");
						
						if (fileexists(percorso+nome+"_crc32.txt"))
						{
							fastfounded++;
							color_green();
							myprintf(": FOUNDED _crc32.txt!\n");
						}
						else
						{
							color_yellow();
							myprintf(": NOTHING\n");
						}
						color_restore();
					}
	}
	if (files.size()>0)
		if ((int)fastfounded==(int)files.size())
			return fastquicktxt();
			
	/// versum z:\*.zpaq -checktxt
	if ((flagchecktxt) || (flagfasttxt) || (flagads))
		return fastquicktxt();

	for (unsigned int i=0;i<files.size();i++)
		if (iszpaq(files[i]))
		{
			myprintf("02895: Cannot load a zpaq (usually on .txt or -ads) %Z\n",files[i].c_str());
#ifdef _WIN32
			if (exists_fasttxt_ads(files[i]))
			{
				myprintf("02897: Founded fasttxt on ADS!\n");
				flagads=true;
				return fastquicktxt();
			}
#endif // corresponds to #ifdef (#ifdef _WIN32)
			return 2;
		}

	if (tofiles.size()>1)
	{
		myprintf("02898! -to to exactly one .zpaq\n");
		return 2;
	}
	myprintf("02899: Loading text files\n");
	int	risultato			=0;
	int64_t	total_size		=0;
	int64_t	total_hashed	=0;
	int64_t	expected_size	=0;
	int		expected_file	=0;
	int		errori			=0;
	vector<string> 			missing;
	vector<tparametrihash> 	vettoreparametrihash;
	vector<s_stringpair> 	vec;
	vector<string> 			myfiles;
	vector<string> 			myfilealgo;
	vector<string> 			myfilehash;
	vector<int64_t> 		myfilesize;
	for (unsigned int i=0;i<files.size();i++)
	{
		string filename=files[i];
		if (!fileexists(filename))
		{
			myprintf("02900: error file does not exists %Z\n",filename.c_str());
			risultato=2;
			continue;
		}
		if (flaghashdeep)
			myprintf("02902: Working on hashdeep  format <<%Z>>\n",filename.c_str());
		else
			myprintf("02903: Working on zpaqfranz format <<%Z>>\n",filename.c_str());

		FILE* myfile = freadopen(filename.c_str());

		if (myfile==0)
		{
			myprintf("02904: error cannot open %Z\n",filename.c_str());
			risultato=2;
			continue;
		}

		if (flaghashdeep)
			risultato+=	versum_hashdeep	(myfile,myfiles,myfilealgo,myfilehash,myfilesize,expected_size,expected_file);
		else
			risultato+=	versum_zpaqfranz(myfile,myfiles,myfilealgo,myfilehash,myfilesize,expected_size,expected_file);

		if (myfile!=NULL)
		{
			fclose(myfile);
			myfile=NULL;
		}
	}
	myprintf("02906: Loading finished lines %s\n",migliaia(myfiles.size()));
	if (risultato>0)
	{
		myprintf("02907: abort, because some errors\n");
		return risultato;
	}
	if (myfiles.size()==0)
	{
		myprintf("02908: no files to be checked\n");
		return 1;
	}
	int64_t	starthash=mtime();

	if (tofiles.size()==1)
		risultato=versum_againstzpaq(myfiles,myfilealgo,myfilehash,missing,errori,total_hashed);
	else		//filesystem check, one or more threads
	{
		int mythreads=howmanythreads;
		if (!flagssd)
			mythreads=1;
		total_size=expected_size;
		starthash=mtime();
		if (mythreads==1)
		{
			int64_t inizio		=mtime();
			g_dimensione=0;

			myprintf("02909: Total files %s (%s)\n",migliaia(myfiles.size()),tohuman(total_size));
			for (unsigned int i=0;i<myfiles.size();i++)
			{
				string	filename=myfiles[i];
				(void)franzreplace(filename);
				
				franz_do_hash dummy(myfilealgo[i]);
				if (flagdebug3) 
					myprintf("02910: filehash on %s total_size %s  expected %s\n",filename.c_str(),migliaia(total_size),migliaia2(expected_size));
				string risu=dummy.filehash(0,filename,false,inizio,total_size);
				if (risu!="")
				{
					s_stringpair 		mypair;
					mypair.index		=i;
					mypair.first		=myfiles[i];
					mypair.second		=risu;
					vec.push_back(mypair);
					total_hashed+=dummy.o_thefilesize;
				}
				else
					missing.push_back(filename);
			}
		}
		else // multithread
		{
			tparametrihash 	myblock;
			for (int i=0;i<mythreads;i++)
			{
				myblock.tnumber		=(i%mythreads);
				myblock.inizio		=mtime();
				myblock.dimensione	=total_size;
				myblock.timestart	=0;
				myblock.timeend		=0;
				vettoreparametrihash.push_back(myblock);
			}
			for (unsigned int i=0;i<myfiles.size();i++)
			{
				string filename=myfiles[i];
				franzreplace(filename);
				vettoreparametrihash[i%mythreads].filestobehashed.push_back(filename);
				vettoreparametrihash[i%mythreads].algo.push_back(myfilealgo[i]);
				vettoreparametrihash[i%mythreads].originalindex.push_back(i);
			}
			int totfile=0;
			for (int i=0;i<mythreads;i++)
			{
				if (flagdebug3)
					myprintf("02911: Thread [%02d] files %s\n",(int)i,migliaia(vettoreparametrihash[i].filestobehashed.size()));
				totfile+=+vettoreparametrihash[i].filestobehashed.size();
			}
			if (flagverbose)
				myprintf("02912: Total files %s -> in threads %s\n",migliaia(myfiles.size()),migliaia2(totfile));
			int rc;
			pthread_t* threads = new pthread_t[mythreads];
			g_allocatedram+=sizeof(pthread_t)*mythreads;
		
			pthread_attr_t attr;
			void *status;
			pthread_attr_init(&attr);
			pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_JOINABLE);
			if (!flagnoeta)
			{
				myprintf("\n");
				myprintf("02913: Creating %d hashing thread(s)\n",mythreads);
			}
			for(int i = 0; i < mythreads; i++ )
			{
				vettoreparametrihash[i].timestart=mtime();
				rc = pthread_create(&threads[i], &attr, scansionahash, (void*)&vettoreparametrihash[i]);
				if (rc)
				{
					myprintf("02914: Error creating thread\n");
					exit(-1);
				}
			}
			pthread_attr_destroy(&attr);

			for(int i=0;i<mythreads; i++)
			{
				rc = pthread_join(threads[i], &status);
				if (rc)
				{
					error("Unable to join\n");
					exit(-1);
				}
			}
			delete [] threads;
			for(int i=0;i<mythreads;i++)
				for (unsigned int j=0;j<vettoreparametrihash[i].filestobehashed.size();j++)
					if (vettoreparametrihash[i].o_hashcalculated[j]!="")
					{
						s_stringpair mypair;
						mypair.index=vettoreparametrihash[i].originalindex[j];
						mypair.first=vettoreparametrihash[i].filestobehashed[j];
						mypair.second=vettoreparametrihash[i].o_hashcalculated[j];
						vec.push_back(mypair);
						///myprintf("02915: sizegetted %s\n",migliaia(vettoreparametrihash[i].o_sizegetted[j]));
						total_hashed+=vettoreparametrihash[i].o_sizegetted[j];
					}
					else
						missing.push_back(vettoreparametrihash[i].filestobehashed[j]);
		}
	}
	int64_t endhash=mtime();

	printbar(' ');
	myprintf("\r");

	if (missing.size()>0)
	{
		expected_file	-=missing.size();
		errori			+=missing.size();
		myprintf("02916: we got %s missing files (in txt, not on filesystem)\n",migliaia(missing.size()));
		for (unsigned int i=0;i<missing.size();i++)
		{
			myprintf("02917: missing %Z\n",missing[i].c_str());
		}
	}
	printbar('-');
	myprintf("02919: Files %21s vs exp %21s ",migliaia(expected_file),migliaia2(myfiles.size()));
	if ((unsigned int)expected_file!=myfiles.size())
	{
		myprintf(" *** DIFFER %s ***",migliaia(myabs(myfiles.size(),expected_file)));
		risultato=2;
	}
	else
		myprintf(" this is good");

	myprintf("\n");
	myprintf("02920: Bytes %21s vs exp %21s ",migliaia(total_hashed),migliaia2(expected_size));
	if (total_hashed!=expected_size)
	{
		myprintf(" *** DIFFER %s ***",migliaia(myabs(expected_size,total_hashed)));
		risultato=2;
	}
	else
		myprintf(" this is good");

	myprintf("\n");
	printbar('-');
	std::sort(vec.begin(),vec.end(),pairsortbyindex);
	for (unsigned int i=0;i<vec.size();i++)
	{
		string vec_filename	=vec[i].first;
		string vec_hash		=vec[i].second;
		if (vec_hash!=myfilehash[vec[i].index])
		{
			myprintf("02921: ERROR %s |file=%s|txt=%s| %Z\n",myfilealgo[i].c_str(),vec_hash.c_str(),myfilehash[i].c_str(),vec_filename.c_str());
			errori++;
		}
		else
		{
			if (flagverbose)
				myprintf("02923: hash OK in %08d  file %s  txt %s\n",vec[i].index,vec_hash.c_str(),vec_filename.c_str());
		}
	}
	if (errori>0)
		printbar('-');
	int64_t hashtime	=endhash-starthash;
	int64_t myspeed		=(int64_t)(total_hashed*1000.0/(hashtime));
	myprintf("02924: Time  %15.3f s, average speed %s/s (%s/s)\n",hashtime/1000.0,migliaia(myspeed),tohuman(myspeed));

	if (risultato==2)
		return 2;
	
	if (errori==0)
		return 0;
	else
		return 2;
	return 0;
}

int Jidac::fastquicktxt()
{
	if (files.size()==0)
	{
		myprintf("02925! Files size must >1\n");
		return 2;
	}

	if (!flagads)
		if ((!flagchecktxt) && (!flagfasttxt))
			if (!iswildcard(files[0]))
				if (prendiestensione(files[0])=="zpaq")
				{
					myprintf("02926: Automagically search for .txt ");
					string 	thezpaq		=files[0];
					string 	percorso	=extractfilepath		(thezpaq);
					string	nome		=prendinomefileebasta	(thezpaq);
					if (fileexists(percorso+nome+"_md5.txt"))
						flagchecktxt=true;
					if (fileexists(percorso+nome+".md5"))
						flagchecktxt=true;
					if (fileexists(percorso+nome+"_crc32.txt"))
						flagfasttxt=true;
					if (flagchecktxt || flagfasttxt)
						myprintf(": FOUNDED !\n");
					else
						myprintf(": NOTHING\n");
				}

	if (flagchecktxt && flagfasttxt)
	{
		myprintf("02927! Confused by -checktxt and -fasttxt\n");
		return 2;
	}
		
	unsigned int	startline	=0;
	string 			thehash		="MD5";
	unsigned int	thehashlen	=32;
	if (flagchecktxt)
	{
		myprintf("02928: Test MD5 hashes of .zpaq against _md5.txt\n");
		if (flagbackupxxh3)
			thehash="XXH3";
	}
	else
	{
		startline	=1;
		thehash		="CRC-32";
		thehashlen	=8;
		if (flagquick)
		{
			thehash		="QUICK";
			thehashlen	=8;
		}
		///myprintf("02929: Test %s of .zpaq against _crc32.txt\n",thehash.c_str());
		if (flagverbose)
		{
			if (!flagads)
				myprintf("02930: Test %s of .zpaq against _crc32.txt\n",thehash.c_str());
			else
				myprintf("02931: Test %s of .zpaq against ADS\n",thehash.c_str());
		}
		
	}

	DTMap thedt;
	for (unsigned int i=0;i<files.size();i++)
		getjollylist(files[i],&thedt);

	if (thedt.size()==0)
	{
		myprintf("02932: Nothing to do (wrong file selection?)\n");
		return 0;
	}

	int64_t larghezzain			=0;
	for (DTMap::iterator p=thedt.begin(); p!=thedt.end(); ++p)
		larghezzain+=prendidimensionefile(p->first.c_str());

	if (flagverbose)
		myprintf("02933: Bytes to be checked %s (%s) in files %s\n",migliaia(larghezzain),tohuman(larghezzain),migliaia2(thedt.size()));

	unsigned int	testok		=0;
	unsigned int	testwarning	=0;
	unsigned int 	testerror	=0;
	int64_t 	startverify		=mtime();

	for (DTMap::iterator p=thedt.begin(); p!=thedt.end(); ++p)
	{
		string 	thezpaq		=p->first;
		string 	percorso	=extractfilepath		(thezpaq);
		string	nome		=prendinomefileebasta	(thezpaq);
		string 	mychecktxt;
		if (flagchecktxt)
		{
			mychecktxt=percorso+nome+"_md5.txt";
			if (!fileexists(mychecktxt))
				mychecktxt	=percorso+nome+".md5";
		}
		else
			mychecktxt=percorso+nome+"_crc32.txt";

		if (flagads)
			mychecktxt=thezpaq+":fasttxt";

		if (!fileexists(mychecktxt))
		{
			myprintf("02934$ WARN for file %Z missing %Z\n",thezpaq.c_str(),mychecktxt.c_str());
			testwarning++;
			continue;
		}

		if (flagverbose)
		{
			myprintf("02936: Getting %s on %Z\n",thehash.c_str(),thezpaq.c_str());
		}

		vector<string> checktxtlines;
		if (!readfiletoarray(mychecktxt,checktxtlines))
		{
			myprintf("02938: Guru readfiletoarray %Z\n",mychecktxt.c_str());
			continue;
		}

		if (checktxtlines.size()<=startline)
		{
			myprintf("02940: checktxtlines.size %d <= %d\n",checktxtlines.size(),startline);
			continue;
		}

		string	firstline	=checktxtlines[startline];
		if (flagdebug3)
			myprintf("02941: firstline   |%s|\n",firstline.c_str());
		string 	hashfromtxt	=getfirsthash(firstline);
		if (flagdebug3)
			myprintf("02942: hashfromtxt |%s|\n",hashfromtxt.c_str());
		
		if (hashfromtxt.size()!=thehashlen)
		{
			myprintf("02943! hash size %d != %d %s\n",hashfromtxt.size(),thehashlen,firstline.c_str());
			return 2;
			///continue;
		}

		if ((flagfasttxt && flagquick) || (flagquick && flagads))
		{
			firstline	=mytrim(myright(firstline,firstline.size()-8));
			firstline	=getfirsthash(firstline);
			hashfromtxt	=firstline;
		}

		franz_do_hash dummy(thehash);
		if (flagdebug3)
			myprintf("02944: filehash on %s\n",thezpaq.c_str());

		string hashreloaded=dummy.filehash(0,thezpaq,false,startverify,larghezzain);
		printbar(' ');
		myprintf("\r");

		if (hashreloaded=="")
		{
			myprintf("02945: guru doing hash on %Z\n",thezpaq.c_str());
			continue;
		}
		if (flagdebug3)
		{
			myprintf("02947: %s: %s %s for file %Z\n",thehash.c_str(),hashreloaded.c_str(),hashfromtxt.c_str(),thezpaq.c_str());
		}
		myprintf("Working: ");
		if (stringtolower(hashreloaded)==stringtolower(hashfromtxt))
		{
			color_green();
			myprintf("02950: OK %s: ",thehash.c_str());
			color_restore();
			testok++;
		}
		else
		{
			color_red();
			myprintf("02951: ERROR: reloaded %s vs txt %s ",hashreloaded.c_str(),hashfromtxt.c_str());
			color_restore();
			testerror++;
		}
		myprintf("%s\n",thezpaq.c_str());
		///printUTF8(thezpaq.c_str());
		///myprintf("\n");
	}
	
	eol();
	///myprintf("02952: TOTAL  %9s\n",migliaia(thedt.size()));
	string temp=std::string(migliaia(thedt.size()));
	
	string risultatofinale="TOTAL "+temp;
	
	if (testok>0)
	{
		string temp=migliaia(testok);
		risultatofinale+=",OK "+temp;
	}
	if (testwarning>0)
	{
		string temp=migliaia(testwarning);
		risultatofinale+=", WARN "+temp;
	}
	if (testerror>0)
	{
		string temp=migliaia(testerror);
		risultatofinale+=", ERROR "+temp;
	}
	
	if (testwarning>0)
		if (testerror==0)
		{
			color_yellow();
			myprintf("78802: %s\n",risultatofinale.c_str());
			color_restore();
			return 1;
		}
	if (testerror>0)
	{
		color_red();
		myprintf("78803: %s\n",risultatofinale.c_str());
		color_restore();
		return 2;
	}
	if (testok==thedt.size())
		if (testok>=1)
		{
			color_green();
			myprintf("78804: %s VERY GOOD\n",risultatofinale.c_str());
			color_restore();
		}
	return 0;
}
/*
void niente_read_archive(char* i_text)
{

	if (i_text==NULL)
	{
		i_text=1; // compiler be quiet!
	}
}
*/
int Jidac::fzf()
{
	vector<DTMap::iterator> localfilelist;

	if (!fileexists(archive))
		return -1;
	if (flagcomment)
	{
		if (versioncomment=="")
			return -1;
		enumeratecomments();
		vector<DTMap::iterator> myfilelist;
		int versione=searchcomments(versioncomment,myfilelist);
		if (versione==0)
		{
			myprintf("02956: cannot find version comment <<%s>>\n",versioncomment.c_str());
			return 1;
		}
		if (versione==-1)
		{
			myprintf("02957: multiple match for version comment <<%s>>\n",versioncomment.c_str());
			return 1;
		}
		version=versione;
		flagcomment=false;
		jidacreset();
	}

	int errors=0;
	read_archive(NULL/*niente_read_archive*/,archive.c_str(),&errors,1,true); /// AND NOW THE MAGIC ONE!
	for (DTMap::iterator a=dt.begin(); a!=dt.end(); ++a)
		if (a->second.data!='-' && (all || a->second.date))
		{
			a->second.data='-';
			localfilelist.push_back(a);
		}
	for (unsigned int i=0;i<localfilelist.size();i++)
	{
		string temp=localfilelist[i]->first;
		if (all)
			myreplace(temp,"|$1","|");
		if (!isads(temp))
			if (!isdirectory(temp))
			{
				myprintf("%Z\n",temp.c_str());
			}
	}
	return 0;
}

int Jidac::addhome()
{
	myprintf("02958: Adding with -home switch\n");
	if (archive=="")
	{
		myprintf("02959! archive empty => quit\n");
		return 2;
	}
	
	if (files.size()!=1)
	{
		myprintf("02960! you need exactly 1 folder selection => quit (ex. /home)\n");
		return 2;
	}

	string	basehome=files[0];
	if (!isdirectory(basehome))
		basehome+="/";
	vector<string> candidate;
	listfolders(basehome,&candidate);
	if (flagdebug)
		myprintf("02961: candidate %s with pattern %s\n",migliaia(candidate.size()),fullarchive.c_str());
	
	if (candidate.size()==0)
	{
		myprintf("02962: Sorry, cannot find something in <<%Z>>\n",basehome.c_str());
	}
	myprintf("02964: founded %s\n",migliaia(candidate.size()));
	int	risultato	=0;
	int therun		=0;

	vector<string> outcome;
	string basearchive=archive;
	for (unsigned int i=0;i<candidate.size();i++)
	{
		string sourcepath=basehome+candidate[i];
		if (!isdirectory(sourcepath))
			sourcepath+="/";
		files.clear();
		files.push_back(sourcepath);
		string sourcename=candidate[i];
		myreplaceall(sourcename," ","_");
		therun++;
		jidacreset();
		archive=extractfilepath(basearchive)+prendinomefileebasta(basearchive)+"_"+sourcename+".zpaq";
		
		myprintf("02965: adding on <<%Z>> from folder <<%Z>>\n",archive.c_str(),sourcepath.c_str());
		int64_t addstart	=mtime();
		int 	riscomando	=add();
		///int 	riscomando	=0;
		int64_t addtime		=mtime()-addstart;
		
		string stato="";
		if (riscomando==0)
			stato="OK";
		else
		if (riscomando==1)
			stato="WARNING";
		else
		{
			stato="ERROR";
			riscomando=2;
		}
		char	buffer[100];
		snprintf(buffer,sizeof(buffer),"%05d: %d %7s %s %21s ",therun,riscomando,stato.c_str(),timetohuman((uint32_t)(addtime/1000.0),2).c_str(),migliaia(prendidimensionefile(archive.c_str())));
		
		string risul=buffer;
		risul+=archive;
		outcome.push_back(risul);

		risultato+=riscomando;
	}
	
	printbar('-');
	for (unsigned int i=0;i<outcome.size();i++)
	{
		myprintf("%s\n",outcome[i].c_str());
		///printUTF8(outcome[i].c_str());
		///myprintf("\n");
	}
	if (flagbig)
	{
		if (risultato==0)
			bigok();
		else
		if (risultato==1)
			bigwarning();
		else
			bigerror();
	}
	return risultato;
}

///static const int64_t LIST_HT_BAD=   -0x7FFFFFFFFFFFFFFALL;  // no such frag

/////////////////////////// read_archive //////////////////////////////
// Read arc up to -date into ht, dt, ver. Return place to
// append. If errors is not NULL then set it to number of errors found.
int64_t Jidac::read_archive(callback_function i_advance,const char* arc, int *errors, int i_myappend,bool i_quiet)
{
	if (errors) *errors=0;
	dcsize=dhsize=0;
	
	map<int64_t, double> mycompressionratio;  // block offset -> compression ratio

	assert(ver.size()==1);
	const bool i_renamed=command=='l' || command=='a' || command=='5' || command=='Z'; ///5 for dirsize arrggghh hidden parameter!
	const bool i_isinfo=(command=='i') && (!flagstat) && (!flagcomment); // -stat? Do a lot of work

	unsigned files=0;  // count
//	abort if file is open (from something else)
#ifdef _WIN32
	if (flagopen)
		if ((command=='a') || (command=='g') || (command=='q') || (command=='Z'))
			if (isfileopen(arc))
			{
				myprintf("02967: GURU file seems open (-open) %Z\n",arc);
				seppuku();
				return 0;
			}
#endif // corresponds to #ifdef (#ifdef _WIN32)
	// Open archive
	InputArchive in(arc);
	if (!in.isopen())
	{
		if (command!='a')
		{
			fflush(stdout);
			///printUTF8(arc);
			myprintf(" %Z not found.\n",arc);
			g_exec_text=arc;
			g_exec_text+=" not found";
			if (errors) ++*errors;
		}
		return 0;
	}
	if ((command=='l') && (flag715))
	{
		myprintf("%Z",arc);
		if (version==DEFAULT_VERSION) 
			myprintf(": ");
		else 
			myprintf(" -until %1.0f: ", version+0.0);
	  fflush(stdout);
	}
	else
	{
		if (!g_fakewrite)
			if (!i_quiet)
				if (!flagpakka)
				{
					myprintf("\n");
					myprintf("02969: <<%Z>>",arc);
					if (version==DEFAULT_VERSION) 
						myprintf(": ");
					else
						myprintf(" -until %1.0f: ", version+0.0);
					fflush(stdout);
				}
	}		

  // Test password
	char s[4]={0};
	const int nr=in.read(s, 4);
	if (nr>0 && memcmp(s, "7kSt", 4) && (memcmp(s, "zPQ", 3) || s[3]<1))
	{
		myprintf("02970: zpaqfranz error:password incorrect\n");
		error("password incorrect");
	}
    in.seek(-nr, SEEK_CUR);
	// Scan archive contents
	string lastfile=archive; // last named file in streaming format
	if (lastfile.size()>5 && lastfile.substr(lastfile.size()-5)==".zpaq")
		lastfile=lastfile.substr(0, lastfile.size()-5); // drop .zpaq
	int64_t block_offset=32*(g_password!=0);  // start of last block of any type
	int64_t data_offset=block_offset;    // start of last block of d fragments
	bool found_data=false;   // exit if nothing found
	bool first=true;         // first segment in archive?
	StringBuffer os(32832);  // decompressed block
	int toolongfilenames	=0;
	int adsfilenames		=0;
	int utf8names			=0;
#ifdef _WIN32
	int casecollision		=0;
#endif // corresponds to #ifdef (#ifdef _WIN32)
	int reservedfilenames	=0;
	int windowsunc			=0;
	int windowspath			=0;
	int relativepath		=0;
	uint64_t parts			=0;
	int	areordered			=0;
	int aredisordered		=0;
  // Detect archive format and read the filenames, fragment sizes,
  // and hashes. In JIDAC format, these are in the index blocks, allowing
  // data to be skipped. Otherwise the whole archive is scanned to get
  // this information from the segment headers and trailers.
	bool done=false;
	
	if ((command!='l') && (!flag715))
		if ((!i_quiet) && (!flagterse))
			myprintf("\n");
	g_incomplete_version=0;
	int64_t startblock=mtime();
	while (!done)
	{
		libzpaq::Decompresser d;
		try
		{
			d.setInput(&in);
			double mem=0;
			while (d.findBlock(&mem))
			{
				found_data=true;
        // Read the segments in the current block
				StringWriter filename, comment;
				int segs=0;  // segments in block
				bool skip=false;  // skip decompression?
				while (d.findFilename(&filename))
				{
					if (filename.s.size())
					{
						for (unsigned i=0; i<filename.s.size(); ++i)
							if (filename.s[i]=='\\')
								filename.s[i]='/';
						lastfile=filename.s;
						if (flagdebug3)
							myprintf("02971: K3  |%s|\n",lastfile.c_str());
					}
					comment.s="";
					d.readComment(&comment);
          // Test for JIDAC format. Filename is jDC<fdate>[cdhi]<num>
          // and comment ends with " jDC\x01". Skip d (data) blocks.
					if (comment.s.size()>=4 && comment.s.substr(comment.s.size()-4)=="jDC\x01")
					{
						if (filename.s.size()!=28 || filename.s.substr(0, 3)!="jDC")
							error("bad journaling block name");
						if (skip)
							error("mixed journaling and streaming block");
            // Read uncompressed size from comment
						int64_t usize=0;
						unsigned i;
						for (i=0; i<comment.s.size() && isdigit(comment.s[i]); ++i)
						{
							usize=usize*10+comment.s[i]-'0';
							if (usize>0xffffffff)
								error("journaling block too big");
						}
						///myprintf("_____________________ %s\n",migliaia(usize)); /// hic
            // Read the date and number in the filename
						int64_t fdate=0, num=0;
						for (i=3; i<17 && isdigit(filename.s[i]); ++i)
							fdate=fdate*10+filename.s[i]-'0';
						if (i!=17 || fdate<19000000000000LL || fdate>=30000000000000LL)
							error("bad date");
						for (i=18; i<28 && isdigit(filename.s[i]); ++i)
							num=num*10+filename.s[i]-'0';
						if (i!=28 || num>0xffffffff)
							error("bad fragment");
            // Decompress the block.
						os.resize(0);
						os.setLimit(usize);
						d.setOutput(&os);
						libzpaq::SHA1 sha1;
						d.setSHA1(&sha1);
						if (strchr("chi", filename.s[17]))
						{
							if (mem>1.5e9)
							///if (mem>100)
							{
								myprintf("98003! too much mem for block %s %18s\n",lastfile.c_str(),migliaia(int64_t(mem)));
								if (errors)
									(*errors)++;
							}
							d.decompress();
							char sha1result[21]={0};
							d.readSegmentEnd(sha1result);
							if ((int64_t)os.size()!=usize)
								error("bad block size");
							if (usize!=int64_t(sha1.usize()))
								error("bad checksum size");
							if (sha1result[0] && memcmp(sha1result+1, sha1.result(), 20))
								error("bad checksum");
							
							if ( ++parts % 1000 ==0)
								if (!flagnoeta)
									if (!i_quiet)
									{
										if ((command!='l') && (!flag715))
											myprintf("02972: Block %10s K %12s (block/s)\r",migliaia((uint64_t)(parts/1000)),migliaia2((int64_t)(parts/(((mtime()-startblock)+1)/1000.0))));

										if (i_advance!=NULL)
										{
											char buf[1000];
											snprintf(buf,sizeof(buf),"Versions %s files %s (%s/s), longpath %s",migliaia4(ver.size()-1),migliaia((uint64_t)(dt.size())),migliaia3((int64_t)(dt.size()/(((mtime()-startblock)+1)/1000.0))),migliaia2(toolongfilenames));
											i_advance(buf);
										}
									}
						}
						else
							d.readSegmentEnd();
            // Transaction header (type c).
            // If in the future then stop here, else read 8 byte data size
            // from input and jump over it.
						if (filename.s[17]=='c')
						{
							if (os.size()<8)
								error("c block too small");
							data_offset=in.tell()+1-d.buffered();
							const char* s=os.c_str();
							int64_t jmp=btol(s);
							if (flagdebug3)
								myprintf("02973: jump %s\n",migliaia(jmp));
							if (jmp<0)
							{
								myprintf("02974! Incomplete transaction ignored @ %s\n",migliaia(ver.size()));
								g_incomplete_version=ver.size();
							}
							if (jmp<0 ||
							(version<19000000000000LL && int64_t(ver.size())>version)
							|| (version>=19000000000000LL && version<fdate))
							{
								done=true;  // roll back to here
								goto endblock;	// WOW, a goto! I never seen one from C-64 back 1985!
							}
							else
							{
								dcsize+=jmp;
								if (jmp) in.seek(data_offset+jmp, SEEK_SET);
								ver.push_back(VER());
								ver.back().firstFragment=ht.size();
								ver.back().offset=block_offset;
								ver.back().data_offset=data_offset;
								ver.back().date=ver.back().lastdate=fdate;
								ver.back().csize=jmp;
								if (all)
								{

									string fn=itos(ver.size()-1, all)+"/";
									if (i_renamed)
										fn=rename(fn);
									if (isselected(fn.c_str(), false,-1))
										dt[fn].date=fdate;
									///printf("FKA1 KKKKKKKKKKKKKKKKKK %s\n",fn.c_str());
								}
								if (jmp)
									goto endblock;
							}
						}
            // Fragment table (type h).
            // Contents is bsize[4] (sha1[20] usize[4])... for fragment N...
            // where bsize is the compressed block size.
            // Store in ht[].{sha1,usize}. Set ht[].csize to block offset
            // assuming N in ascending order.
						else
						if (filename.s[17]=='h')
						{
							assert(ver.size()>0);
							if (fdate>ver.back().lastdate)
								ver.back().lastdate=fdate;
							if (os.size()%24!=4)
								error("bad h block size");
							const unsigned n=(os.size()-4)/24;
							if (num<1 || num+n>0xffffffff)
								error("bad h fragment");
							const char* s=os.c_str();
							const unsigned bsize=btoi(s);
							dhsize+=bsize;
							assert(ver.size()>0);
							if (int64_t(ht.size())>num)
							{
								fflush(stdout);
								myprintf(
								  "Unordered fragment tables: expected >= %d found %1.0f\n",
								  int(ht.size()), double(num));
								 g_exec_text="Unordered fragment tables";
							}
							for (unsigned ik=0; ik<n; ++ik)
							{
								if (ik==0)
								{
									block.push_back(Block(num, data_offset));
									block.back().usize=8;
									block.back().bsize=bsize;
									block.back().frags=os.size()/24;
								}
								while (int64_t(ht.size())<=num+ik)
									ht.push_back(HT());
								memcpy(ht[num+ik].sha1, s, 20);
								s+=20;
								assert(block.size()>0);
								unsigned f=btoi(s);
								if (f>0x7fffffff)
									error("fragment too big");
								block.back().usize+=(ht[num+ik].usize=f)+4u;
							 }
							double usum=0;  // total uncompressed size
							for (unsigned i=0; i<n; ++i) 
							  usum+=ht[num+i].usize;
							if (usum>0) 
							{
								double theratio=bsize/usum;
								for (unsigned i=0; i<n; ++i) 
									ht[num+i].estimatedratio=theratio;
							}
							data_offset+=bsize;
						}
            // Index (type i)
            // Contents is: 0[8] filename 0 (deletion)
            // or:       date[8] filename 0 na[4] attr[na] ni[4] ptr[ni][4]
            // Read into DT
						else
						if (filename.s[17]=='i')
						{
							assert(ver.size()>0);
							if (fdate>ver.back().lastdate)
								ver.back().lastdate=fdate;
							const char* s=os.c_str();
							const char* const end=s+os.size();
							while (s+9<=end)
							{
								DT dtr;
								dtr.version=ver.size()-1;

								dtr.date=btol(s);  // date
								if (dtr.date)
									++ver.back().updates;
								else
									++ver.back().deletes;
								const int64_t len=strlen(s);
								if (len>65535)
									error("filename too long");
								string fn=s;  // filename ren
								string	originalfilename=s;

								if (!i_isinfo)
								{
									if ((flagstat) && (command!='5') && (command!='6'))
							//-stat, we ask for extended infos
							//not useful with dirsize, setpassword, info
									{
										checkfilename(fn,
										&toolongfilenames,
										&adsfilenames,
										&utf8names,
										NULL,// reserved file names, only on WIN32
										&windowspath,
										&windowsunc,
										&relativepath);
										string fixed;
	
#ifdef _WIN32
										if (isreserved(fn,fixed))
										{
											reservedfilenames++;
											if (flagfixreserved)
											{
												myprintf("02975$ WARNING changed reserved <<%Z>>\n",fn.c_str());
												fn=fixed;
												myprintf("02977: to filesystem compatible <<%Z>>\n",fn.c_str());
											
											}
										}
#endif // corresponds to #ifdef (#ifdef _WIN32)
									}
									else
#ifdef _WIN32
									checkfilename(fn,  /// by default check only toolong and utf
									&toolongfilenames,
									NULL,
									NULL,
									NULL,
									NULL,
									NULL,
									NULL);
								
#else				// *nix can restore (almost) everything, no warnings needed by default
#endif // corresponds to #ifdef (#ifdef _WIN32)
										if (all)
										{
											if ((command=='l') && (flag715))
											{
												myreplaceall(fn,":","");
												if (i_myappend)
													fn=itos(ver.size()-1, all)+"/"+fn;
												else
													fn=append_path(itos(ver.size()-1, all), fn);
											}
											else
											{
												if (i_myappend)
													fn=itos(ver.size()-1, all)+"|$1"+fn;
												else
													fn=append_path(itos(ver.size()-1, all), fn);
											}
											///printf("------------- %s\n",fn.c_str());
										}
								}
					bool issel=false;
					if (!i_isinfo)
						issel=isselected(fn.c_str(), i_renamed,-1);

					if (g_rangefrom>0)
						if (all)
							if (((ver.size()-1)<(unsigned int)g_rangefrom) || ((ver.size()-1)>(unsigned int)g_rangeto))
								issel=false;

					s+=len+1;  // skip filename
					if (s>end)
						error("filename too long");
					if (dtr.date)
					{
						
						++files;
						if (s+4>end)
							error("missing attr");
						unsigned na=0;
						na=btoi(s);  // attr bytes
						if (s+na>end || na>65535)
							error("attr too long");
						if (!i_isinfo)
							if (na>FRANZOFFSETV1) //Get FRANZOFFSETV1
							{
								assert((na-8)<FRANZOFFSETV3); // cannot work on too small buffer
								for (unsigned int ik=0;ik<(na-8);ik++)
									dtr.franz_block[ik]=*(s+(na-(na-8))+ik);
								///dtr.franz_block_size=(na-8);
								dtr.franz_block[(na-8)]=0x0;
								if (flagstat)
								{
									string myhashtype="";
									string myhash="";
									string mycrc32="";
									int64_t mycreationtime=0;
									int64_t myaccesstime=0;
									bool	myisordered=false;
									int		myversion=0;
									franz_posix* myposix=NULL;
									bool	myisadded=false;
									decode_franz_block(false,dtr.franz_block,
									myhashtype,
									myhash,
									mycrc32,
									mycreationtime,
									myaccesstime,
									myisordered,
									myversion,
									myposix,myisadded);
								
									if (strstr(myhash.c_str(),"!ERROR!"))
									{
										if (flagforce)
										{
											if (flagverbose)
												myprintf("02979: *** 'strange' but -force     -> included ");
										}
										else
										{
											if (flagverbose)
												myprintf("02980: *** 'strange' and NOT -force -> skipped  ");
											issel=false;
											if (errors)
												(*errors)++;
										}
										if (flagverbose)
										{
											myprintf("%Z\n",fn.c_str());
											///printUTF8(fn.c_str());
											///myprintf("\n");
										}
									}
								}
							}
						for (unsigned ik=0; ik<na; ++ik, ++s)  // read attr
							if (ik<8)
								dtr.attr+=int64_t(*s&255)<<(ik*8);
						if (flagnoattributes)
							dtr.attr=0;
						if (s+4>end)
							error("missing ptr");
						unsigned ni=btoi(s);  // ptr list size
						if (ni>(end-s)/4u)
							error("ptr list too long");
						if (issel)
							dtr.ptr.resize(ni);
						for (unsigned ik=0; ik<ni; ++ik)
						{  // read ptr
							const unsigned j=btoi(s);
							if (issel)
							{
								dtr.ptr[ik]=j;
								unsigned k=j;
								if (ht[j].csize<0 && ht[j].csize!=LIST_HT_BAD)
									k+=ht[j].csize;
								if (k>0 && k<ht.size() && ht[k].csize!=LIST_HT_BAD && ht[k].csize>=0)
									dtr.kompressedsize+=int64_t(ht[j].estimatedratio*ht[j].usize);
								/// update version size
								ver.back().usize+=ht[j].usize;
							}
						}
						if (flagads)
						{
							dt[fn]=dtr;
							if (flagdebug3)
								myprintf("02981: >>>>>>>>>>>>>>>>>> fn %s %s\n",fn.c_str(),migliaia(dt.size()));
						}
					}
/// UBUNTU
					if (!i_isinfo)		//info command: we want versions, not files (2 times faster)
						if (issel)
						{
							if (flagstdout)
							{
								int fragchunks=compressfraglist(dtr.ptr,flagdebug);
								if (fragchunks<=1)
								{
									dtr.isordered=true;
									if (flagverbose || flagdebug)
									{
										myprintf("02982: Good for stdout (isordered) %Z\n",fn.c_str());
										
									}
									areordered++;
								}
								else
									aredisordered++;

								if (flagdebug3)
									myprintf("02984: fragchunks %08d for %s\n",fragchunks,fn.c_str());
							}
							if (all)
								dtr.outputname=originalfilename;
							dt[fn]=dtr;
							if (flagads && flagdebug)
								myprintf("02985:  ((((((((((((((((((((((((((((((((((((( fn %s\n",fn.c_str());

						}
			///		dt.insert(std::pair<string, DT>(fn,dtr));
				}  // end while more files
            }  // end if 'i'
            else
			{
				myprintf("02986: Skipping %s %s\n",filename.s.c_str(), comment.s.c_str());
				error("Unexpected journaling block 1");
            }
          }  // end if journaling
          // Streaming format
          else
		  {
            // If previous version does not exist, start a new one
            if (ver.size()==1)
			{
				if (version<1)
				{
					done=true;
					goto endblock;
				}
				ver.push_back(VER());
				ver.back().firstFragment=ht.size();
				ver.back().offset=block_offset;
				ver.back().csize=-1;
			}
			char sha1result[21]={0};
			d.readSegmentEnd(sha1result);
            skip=true;
            string fn=lastfile;
            if (all)
			{

				fn=append_path(itos(ver.size()-1, all), fn); ///peusa3
			}
            if (isselected(fn.c_str(), i_renamed,-1)) {
              DT& dtr=dt[fn];
              if (filename.s.size()>0 || first) {
                ++files;
                dtr.date=date;
                dtr.attr=0;
                dtr.ptr.resize(0);
                ++ver.back().updates;
              }
              dtr.ptr.push_back(ht.size());
            }
            assert(ver.size()>0);
            if (segs==0 || block.size()==0)
              block.push_back(Block(ht.size(), block_offset));
            assert(block.size()>0);
            ht.push_back(HT(sha1result+1, -1));
          }  // end else streaming
          ++segs;
          filename.s="";
          first=false;
        }  // end while findFilename
        if (!done) block_offset=in.tell()-d.buffered();
      }  // end while findBlock
      done=true;
    }  // end try
    catch (std::exception& e) {
      in.seek(-d.buffered(), SEEK_CUR);
      fflush(stdout);
      myprintf("02987: Skipping block at %1.0f: %s\n", double(block_offset),
              e.what());
		g_exec_text="Skipping block";
      if (errors) ++*errors;
    }
endblock:;
  }  // end while !done
  if (in.tell()>32*(g_password!=0) && !found_data)
    error("archive contains no data");

	if ((command=='l') && (flag715))
	{
		myprintf("%d versions, %u files, %u fragments, %1.6f MB\n", 
		int(ver.size()-1), files, unsigned(ht.size())-1,
		block_offset/1000000.0);
	}
	else
	{
		if ((command!='a') && (command!='Z'))
			if (!flagnotrim)
				if (g_incomplete_version>0)
				{
					color_red();
					ascii::Ascii font=ascii::Ascii();
					font.print("incomplete");
					myprintf("97554: Detected a 'gap' in the archive due to incomplete transaction(s) %s\n",migliaia(g_incomplete_version));
					myprintf("97555: This means that the archive is corrupted (killed process? out of space?)\n");
					myprintf("97556: Suggestion: use the trim command ASAP to remove the incomplete part,\n");
					myprintf("97557: preventing the issue from spreading\n");
					color_restore();
				}
		if (!g_fakewrite)
			if (!i_quiet)
				if (!flagpakka)
				{
					if (flagverbose)
					myprintf("02988: %d vers, %s files, %s frags, %s blks, %s bytes (%s)\n",
					int(ver.size()-1), migliaia(files), migliaia2(unsigned(ht.size())-1),
					migliaia3(parts),migliaia4(block_offset),tohuman(block_offset));
					else
					myprintf("02989: %d versions, %s files, %s bytes (%s)\n",
					int(ver.size()-1), migliaia(files),
					migliaia4(block_offset),tohuman(block_offset));
					if (flagdebug2)
						myprintf("02990: dt size  %s\n",migliaia(dt.size()));
				}
	}
	if (!i_quiet)
	{
#ifdef _WIN32
		if (flagstat)
		{
			vector<string> kollisioni;
			uint32_t fixati=casekollision(dt,kollisioni,flagfixcase);
			casecollision=kollisioni.size();
			if (casecollision>0)
			{
				myprintf("02991: Case collisions        %9s (try -fixcase)\n",migliaia(casecollision));
				if (flagverbose)
					for (unsigned int i=0;i<kollisioni.size();i++)
					{
						myprintf("     collision  <<%Z>>\n",kollisioni[i].c_str());
					}
			}
			if (flagfixcase)
				if (fixati>0)
					myprintf("02992: -fixcase fixed         %9s files\n",migliaia(fixati));
			kollisioni.clear();
		}
#endif // corresponds to #ifdef (#ifdef _WIN32)
		if (toolongfilenames)
		{
#ifdef _WIN32
			if (!flaglongpath)
				if (!flagtest)
					if (!flagvss)
						if (!flagstdout)
							if (!flagterse)
							myprintf("02993$ Long filenames (>255)  %9s *** WARNING *** (suggest -longpath or -fix255 or -flat)\n",migliaia(toolongfilenames));
#else
			if (!flagtest)
				if (!flagstdout)
					if (!flagterse)
			myprintf("02994: Long filenames (>255)  %9s\n",migliaia(toolongfilenames));
#endif // corresponds to #ifdef (#ifdef _WIN32)
		}

		if (!i_quiet)
		{
			eol();
			if (flagstdout)
			{
				if (areordered)
					myprintf("02995: AVAILABLE -stdout      %9s\n",migliaia(areordered));
				if (aredisordered)
					myprintf("02996: CANNOT    -stdout      %9s\n",migliaia(aredisordered));
			}
			if (utf8names)
			{
				myprintf("02997: Non-latin (UTF-8)      %9s\n",migliaia(utf8names));
			}
			if (adsfilenames)
				myprintf("02999: ADS ($:DATA)           %9s\n",migliaia(adsfilenames));
			if (windowspath)
				myprintf("03000: Windows path           %9s\n",migliaia(windowspath));
			if (windowsunc)
				myprintf("03001: Windows UNC            %9s\n",migliaia(windowsunc));
			if (reservedfilenames)
			{
#ifdef _WIN32
				myprintf("03002$ Reserved WIN filenames %9s *** WARNING *** (suggested -fixreserved or -flat) \n",migliaia(reservedfilenames));
#else
				myprintf("03003: Reserved filenames     %9s\n",migliaia(reservedfilenames));
#endif // corresponds to #ifdef (#ifdef _WIN32)
			}
		}
	}

  // Calculate file sizes
  
	for (DTMap::iterator p=dt.begin(); p!=dt.end(); ++p)
		for (unsigned i=0; i<p->second.ptr.size(); ++i)
		{
			unsigned j=p->second.ptr[i];
			if (j>0 && j<ht.size() && p->second.size>=0)
			{
				if (ht[j].usize>=0)
					p->second.size+=ht[j].usize;
				else
					p->second.size=-1;  // unknown size
			}
		}
	
	return block_offset;
}

int Jidac::checksha1collision(DTMap& i_dtmap,bool i_decodefranzblock)
{
#ifdef ESX
	(void)i_dtmap;
	(void)i_decodefranzblock;
	return 0; ///ESXi old compiler does not like
#else
	if ((flag715) || (flagnochecksum))
		return 0;
	int 	collisionfounded=0;
	int64_t startcollision=mtime();
	sha1collision.clear();
	vector<string> secondpass;
	
	for (DTMap::iterator p=i_dtmap.begin(); p!=i_dtmap.end(); ++p)
	{
		///myprintf("03004: first  %s\n",p->first.c_str());
		string mycrc32			="";
		
		if (i_decodefranzblock)
		{
			string myhashtype		="";
			string myhash			="";
			int64_t mycreationtime	=0;
			int64_t myaccesstime	=0;
			bool	myisordered		=false;
			int		myversion		=0;
			franz_posix* myposix	=NULL;
			bool	myisadded		=false;
			decode_franz_block(false,p->second.franz_block,
			myhashtype,
			myhash,
			mycrc32,
			mycreationtime,
			myaccesstime,
			myisordered,
			myversion,
			myposix,myisadded);
		}
		else
			mycrc32=p->second.hexcrc32.c_str();
			
		///myprintf("03005: mycrc32 %s\n",mycrc32.c_str());
		if (mycrc32!="")
			if (mycrc32!="00000000")
			{
				p->second.hexcrc32=mycrc32;
				const char* 	vectordata	=(char*)p->second.ptr.data();
				size_t 	vectorbytes =sizeof(p->second.ptr[0])*p->second.ptr.size();
				
				uint64_t myseed = 0;
				XXHash64 myhash(myseed);
				myhash.add(vectordata,vectorbytes);
				int64_t hashstringato=myhash.hash();
				
				std::pair<std::map<int64_t,string>::iterator,bool> risultato;
				risultato=sha1collision.insert(std::pair<int64_t,string>(hashstringato,p->first.c_str()));
				if (risultato.second==false) 
				{
					string precedente=risultato.first->second;
					DTMap::iterator myp=i_dtmap.find(precedente);
					if (myp==i_dtmap.end())
						myprintf("03006: ERROR cannot find on dtmap! %s\n",precedente.c_str());
					else
					{
						const char* vectordata2		=(char*)myp->second.ptr.data();
						size_t 	vectorbytes2 	=sizeof(myp->second.ptr[0])*myp->second.ptr.size();
						
						if ((vectordata2==NULL) || (vectordata==NULL))
						{
							myprintf("03007: GURU vectordata or vectordata2 null\n");
							seppuku();
							return 0;
						}
						if (flagdebug3)
						{
							myprintf("03008: vectorbytes  %s\n",migliaia(vectorbytes));
							myprintf("03009: vectorbytes2 %s\n",migliaia(vectorbytes2));
						}
						if (vectorbytes!=vectorbytes2)
							myprintf("03010: ERROR vectorbytes does not match %s vs %s\n",migliaia((int64_t)vectorbytes),migliaia2((int64_t)vectorbytes2));
						else
						{
							if (memcmp(vectordata,vectordata2,vectorbytes)!=0)
								myprintf("03011: ERROR fragment lists does not match! (XXHASH64 collision?)\n");
							else
							{
								string precedentecrc32=myp->second.hexcrc32;
								if (precedentecrc32!=p->second.hexcrc32)
								{
									myprintf("\n");
									printbar('#');
									if (flagverbose)
									{
										myprintf("03012: **** SUSPECTED SHA-1 COLLISION %s ****\n",bin2hex_64(hashstringato).c_str());
										myprintf("03014: File   CRC-32 %s <<%Z>>\n",p->second.hexcrc32.c_str(),p->first.c_str());
										myprintf("03015: map to CRC-32 %s <<%Z>>\n",precedentecrc32.c_str(),risultato.first->second.c_str());
									
									}
									else
									{
										myprintf("03017: Restoring this file will get incorrect data due to suspected SHA-1 collision(s)\n");
										string temp=p->first;
										if (mypos("|$1",temp)>-1)
										{
											myreplace(temp,"|$1","|");
											myprintf("       File template: <<version|filename>>\n");
										}
										else
											secondpass.push_back(temp);
										myprintf("<<%Z>>\n",temp.c_str());
										
									}
									printbar('#');
									myprintf("\n");
									collisionfounded++;
								}
							}
						}
					}
				}
			}
	}
	///if (flagverbose)
		myprintf("03018: SHA-1 collision detection time %s ms\n",migliaia(mtime()-startcollision));

	if (command=='a')
		if (secondpass.size()>0)
		{
			jidacreset();
			tofiles	.clear();
			files	.clear();
			flagforce		=true;
			flagstdout		=true;
			flagnodedup		=true;
			flagcollision	=false;
			for (unsigned int i=0;i<secondpass.size();i++)
			{
				myprintf("03019: Need a second pass on <<%Z>>\n",secondpass[i].c_str());
				files.push_back(secondpass[i]);
			}
			return add();
		}
	return collisionfounded;
#endif // corresponds to #ifdef (#ifdef ESX)
}

int Jidac::collision(bool i_flagall)
{
	if (archive=="")
	{
		myprintf("03021! archive not set!\n");
		return 2;
	}
	myprintf("03022: Checking for SHA-1 collisions\n");
	int errors		=0;
	all				=i_flagall;
	jidacreset();
	read_archive(NULL,archive.c_str(),&errors,1); /// AND NOW THE MAGIC ONE!
	myprintf("\n");
	myprintf("03023: Inspecting %s entries...\n",migliaia((int64_t)dt.size()));
	int howmany=checksha1collision(dt,true);
	myprintf("\n");
	if (howmany>0)
	{
		myprintf("03024$ WARNING: some files cannot be restored correctly due to a suspected SHA-1 collision(s).\n");
		return 1;
	}
	else
		myprintf("03025: No suspected collisions detected (this is good)\n");
	return 0;
}

//////////////////////////////////////////////////////////////////////////////////
/// This is a reworked piece of zpaqd

/// LICENSE_START.21


// Base class of InputFile and OutputFile (OS independent)
class File 
{
	protected:
	enum {BUFSIZE=1<<16};  // buffer size
	int ptr;  // next byte to read or write in buf
	libzpaq::Array<char> buf;  // I/O buffer
	File(): ptr(0), buf(BUFSIZE) {}
};

class InputFile: public File, public libzpaq::Reader 
{
  FILE* in;
  int n;  // number of bytes in buf
public:
  InputFile(): in(0), n(0) {}

  // Open file for reading. Return true if successful
  bool open(const char* filename) 
  {
	in=fopen(filename, "rb");
	if (!in) perror(filename);
	n=ptr=0;
	return in!=0;
  }

  // True if open
  bool isopen() {return in!=0;}

  // Read and return 1 byte (0..255) or EOF
  int get() 
  {
	assert(in);
	if (ptr>=n) 
	{
		assert(ptr==n);
		n=fread(&buf[0], 1, BUFSIZE, in);
		ptr=0;
		if (!n) 
			return EOF;
    }
    assert(ptr<n);
    return buf[ptr++]&255;
  }

  // Read up to m bytes into p and return number read or 0 at EOF.
  int read(char* p, int m) 
  {
    if (ptr==n) 
	{
		ptr=0;
		n=fread(&buf[0], 1, BUFSIZE, in);
    }
    assert(n>=0 && n<=BUFSIZE);
    assert(ptr>=0 && ptr<=n);
    if (m>n-ptr) m=n-ptr;
    memcpy(p, &buf[ptr], m);
    ptr+=m;
    return m;
  }
  // Return file position
  int64_t tell() 
  {
	return ftello(in)-n+ptr;
  }
  

  // Close file if open
  void close() 
  {
	if (in) 
		fclose(in), in=0;
	}
  ~InputFile() {close();}
};


// Read 4 byte little-endian int and advance s
int mybtoi(const char* &s) {
  s+=4;
  return (s[-4]&255)|((s[-3]&255)<<8)|((s[-2]&255)<<16)|((s[-1]&255)<<24);
}

// Read 8 byte little-endian int and advance s
int64_t mybtol(const char* &s) {
  int64_t r=unsigned(mybtoi(s));
  return r+(int64_t(mybtoi(s))<<32);
}

// Display hcomp or pcomp section as ZPAQL source code
void decompile_comp(string s) {
  assert(s.size()<65536);
  s+=char(0);
  s+=char(0);

  // Get a list of jump targets to print labels
  libzpaq::Array<unsigned char> a(1<<16);
  for (unsigned i=0; i+2<s.size(); ++i) {
    if (s[i]==39 || s[i]==47 || s[i]==63)  // JT, JF, JMP
      a[(i+2+s[i+1])&0xffff]=true;
    if ((s[i]&255)==255)  // LJ
      a[(s[i+1]&255)|((s[i+2]<<8)&0xff00)]=true, i+=2;
    else if ((s[i]&7)==7)  // 2 byte opcode
      ++i;
  }

  // Print ZPAQL source
  for (unsigned i=0, j=0; i+2<s.size(); ++i) {
    int c=s[i]&255;
    if (a[i]) {  // print jump label as comment
      if (j) myprintf("\n"), j=0;
      myprintf(" (%d)", i);
    }
    myprintf(" %s", libzpaq::opcodelist[c]);
    if (c==255)  // LJ
      myprintf(" %d", (s[i+1]&255)|((s[i+2]<<8)&0xff00)), i+=2;
    else if (c==39 || c==47 || c==63)  // JT, JF, JMP
      myprintf(" %d (to %d)", s[i+1], i+2+s[i+1]), ++i;
    else if (c%8==7)  // 2 byte opcode
      myprintf(" %d", s[++i]&255);
    if (++j>8 || i+3>=s.size())
      myprintf("\n"), j=0;
  }
}

// Display hcomp and pcomp as ZPAQL source code
void decompile(const string& hcomp, const string& pcomp) {
  if (hcomp.size()>6) {
    int n=hcomp[6]&255;  // number of components
    myprintf("\n");
	myprintf("03026: comp %d %d %d %d %d\n",
      hcomp[2]&255, hcomp[3]&255, hcomp[4]&255, hcomp[5]&255, hcomp[6]&255);
    int j=7;
    for (int i=0; i<n && j<int(hcomp.size()); ++i) {
      const int c=hcomp[j]&255;
      myprintf("03027:  %d %s", i, libzpaq::compname[c]);
      for (int k=j+1; k<j+libzpaq::compsize[c] && k<int(hcomp.size()); ++k)
        myprintf(" %d", hcomp[k]&255);
      myprintf("\n");
      j+=libzpaq::compsize[c];
    }
    myprintf("03028: hcomp\n");
    if (j<int(hcomp.size())-2)
      decompile_comp(hcomp.substr(j+1, hcomp.size()-j-2));
  }
  if (pcomp.size()>=3) {
    myprintf("03029: pcomp ;\n");
    decompile_comp(pcomp.substr(2, pcomp.size()-3));
    myprintf("03030: end\n");
  }
  else
    myprintf("03031: post 0 end\n");
}


int Jidac::dump() 
{
	InputArchive in(archive.c_str());
	if (!in.isopen()) 
	{
		myprintf("03032! GURU cannot open <<%Z>>\n",archive.c_str());

		return 2;
	}
	///int64_t csize=in.get_totalsize();
	
	if (all)
	{
		flagverbose	=true;
		summary		=-1;
	}
	libzpaq::Decompresser d;
	libzpaq::SHA1 sha1;
	d.setInput(&in);
	d.setSHA1(&sha1);
	double mem;
	StringWriter filename, comment, buf;
	char sha1result[21];
	map<string, int> m;
	int block				=0;
	int64_t myoffset		=0;
	unsigned int iblock		=0;
	unsigned int hblock		=0;
	unsigned int cblock		=0;
	unsigned int dblock		=0;
	unsigned int filecount	=0;
	vector<uint64_t> cblock_position;
	vector<uint64_t> dblock_position;
	vector<uint64_t> hblock_position;
	vector<uint64_t> iblock_position;
	uint64_t		block_position;
	MAPPASTRINGINTEGER mappahash;
	MAPPAINTINT mappafranzoblock;

	int64_t expectedfilesize	=in.get_totalsize();	
	int		expectedchunknumber	=in.get_chunknumber();
	int		lastperc=0;
	myprintf("03034: Expected %08d chunks for %21s bytes\n",expectedchunknumber,migliaia(expectedfilesize));
	while (d.findBlock(&mem)) 
	{
		block_position=myoffset;
		
		if (summary>0)
		{
			int percentuale=100*myoffset/expectedfilesize;
			if ((percentuale%5==0) && (percentuale!=lastperc))
			{
				myprintf("03035: Scanning %03d% @              %21s\r",percentuale,migliaia(myoffset));
				lastperc=percentuale;
			}
		}
		bool first=true;
		while (d.findFilename(&filename)) 
		{
			d.readComment(&comment);
			if (first) 
			{  // Print ZPAQL in header
				StringWriter hcomp, pcomp;
				d.hcomp(&hcomp);
				d.setOutput(0);
				d.decompress(0);
				d.pcomp(&pcomp);
				int& b=m[hcomp.s+pcomp.s];
				if (b==0)
				{
					if (all)
						decompile(hcomp.s, pcomp.s), b=block;
				}
				else
					myprintf(" (same model as block %d)\n", b);
				first=false;
				 // Decompress JIDAC index
				if (comment.s.size()>=5
					&& comment.s.substr(comment.s.size()-5)==" jDC\x01"
					&& filename.s.size()==28
					&& filename.s.substr(0, 3)=="jDC"
					&& strchr("chi", filename.s[17])) 
				{
					sha1.result();  // init
					d.setOutput(&buf);
					d.decompress();
				}
			}
			d.readSegmentEnd(sha1result);
			if (buf.s.size()>0 && sha1result[0]==1 && memcmp(sha1.result(), sha1result+1, 20))
				myprintf("03036: CHECKSUM ERROR!\n");
			string purged=comment.s;
			
			myreplace(purged,"jDC\x01","");
			purged=mytrim(purged);
			int64_t sizeint=myatoll(purged.c_str());
			string type="UNKNOWN";
			
			if (filename.s[17]=='d')
				type="D ";
			else
			if (filename.s[17]=='c')
				type="C ";
			else
			if (filename.s[17]=='h')
				type="H ";
			else
			if (filename.s[17]=='i')
				type="I ";
			///mem used for decompression
			
			if (summary<0)
			myprintf("03037: %08d %s%s @ %20s:%11s [%14s] ",++block,type.c_str(),filename.s.c_str(),migliaia(myoffset), migliaia2(in.tell()-d.buffered()-myoffset),migliaia3(sizeint));
			myoffset=in.tell()-d.buffered();
			if (filename.s[17]=='d')  // d block
			{
				dblock++;
				if (summary<0)
					myprintf("\n");
				dblock_position.push_back(block_position);
			}
      // Display JIDAC index blocks
			if (buf.s.size()) 
			{
				assert(filename.s.size()==28);
				const char* p=buf.s.c_str();
				const char* end=p+buf.s.size();
				if (filename.s[17]=='c')  // header
				{
					cblock++;
					if (summary<0)
					myprintf("d-compr  %s\n", migliaia(mybtol(p)));
					cblock_position.push_back(block_position);
				}
				else if (filename.s[17]=='h') 
				{  // fragment table
					hblock++;
					hblock_position.push_back(block_position);
					if (summary<0)
					{
						myprintf("d-compr %s\n", migliaia(mybtoi(p)));
						
						if (flagverbose)
						{
							int n=atoi(filename.s.c_str()+18);  // frag ID
							while (p<=end-24) 
							{
								myprintf("03038: %10d SHA1 ", n++);
								for (int i=0; i<20; ++i)
									myprintf("%02x", *p++&255);  // sha1 hash
								myprintf("      %12s (fragment size )\n", migliaia(mybtoi(p)));  // fsize
							}
						}
					}
				}
				else if (filename.s[17]=='i') 
				{  // index
					iblock++;
					iblock_position.push_back(block_position);

					if (summary<0)
						myprintf("\n");
					while (p<end-8) 
					{
						const int64_t fdate=mybtol(p);
						filecount++;
						if (summary<0)
							if (flagverbose || all)
							{
								///zekka
								myprintf("%s %s", dateToString(false,fdate).c_str(),p);
								///printUTF8(p);
							}
						while (p<end && *p) 
							++p;  // skip filename
						++p;
						if (fdate) 
						{
							if (summary<0)
								if (all)
									myprintf(" ");
							if (p>end-4) break;
							int n=mybtoi(p);  // na
							
							if (n>FRANZOFFSETV1) //Get FRANZOFFSETV1
							{
								mappafranzoblock[n-8]=mappafranzoblock[n-8]+1;
								DT dtr;
								for (int ik=0;ik<(n-8);ik++)
									dtr.franz_block[ik]=*(p+(n-(n-8))+ik);
								dtr.franz_block[(n-8)]=0x0;
								string myhashtype		="";
								string myhash			="";
								int64_t mycreationtime	=0;
								int64_t myaccesstime	=0;
								bool	myisordered		=false;
								int		myversion		=0;
								franz_posix* myposix	=NULL;
								bool	myisadded		=false;
								string	mycrc32			="";
								decode_franz_block(false,dtr.franz_block,
								myhashtype,
								myhash,
								mycrc32,
								mycreationtime,
								myaccesstime,
								myisordered,
								myversion,
								myposix,myisadded);
								if (myhashtype=="")
									myhashtype="UNKNOWN";
								mappahash[myhashtype]=mappahash[myhashtype]+1;
								if (all)
									myprintf(" |%s| ",myhashtype.c_str());
							}
							while (n-->0 && p<end)
								p++;
							if (p>end-4) break;
							n=mybtoi(p);  // ni
						   
							// print fragment pointers
							vector<unsigned> ptr;
							for (; n>0 && p<=end-4; --n)
								ptr.push_back(mybtoi(p));
							bool hyphen=false;
							if (summary<0)
								if (all)
									myprintf(" FRAGS (#%d): ",ptr.size());
							for (int i=0; i<int(ptr.size()); ++i) 
							{
								if (i==0 || i==int(ptr.size())-1 || ptr[i]!=ptr[i-1]+1 || ptr[i]!=ptr[i+1]-1) 
								{
										if (summary<0)
											if (!hyphen) 
											if (all)
												myprintf(" ");
									hyphen=false;
									if (summary<0)
										if (all)
											myprintf("%d", ptr[i]);
								}
								else 
								{
									if (summary<0)
										if (!hyphen) 
											if (all)
												myprintf("-");
									hyphen=true;
								}
							}
							if (summary<0)
								if (all || flagverbose)
									myprintf("\n");
						}
					}	
				}
			}
			buf.s		="";
			filename.s	="";
			comment.s	="";
		}
		myoffset=in.tell()-d.buffered();
	}
	if (summary>0)
	myprintf("03039: Scanning %03d% @              %21s\r",100,migliaia(expectedfilesize));
	myprintf("\n");

	if (flagverbose)
	{
		if (cblock_position.size()>0)
			for (unsigned int i=1;i<cblock_position.size();i++)
				myprintf("03040: c block %08d %21s\n",i,migliaia(cblock_position[i]));
		if (dblock_position.size()>0)
			for (unsigned int i=0;i<dblock_position.size();i++)
				myprintf("03041: d block %08d %21s\n",i,migliaia(dblock_position[i]));
		if (hblock_position.size()>0)
			for (unsigned int i=0;i<hblock_position.size();i++)
				myprintf("03042: h block %08d %21s\n",i,migliaia(hblock_position[i]));
		if (iblock_position.size()>0)
			for (unsigned int i=0;i<iblock_position.size();i++)
				myprintf("03043: i block %08d %21s\n",i,migliaia(iblock_position[i]));
	}
	
	myprintf("03044: c block (jump)  %11s\n",migliaia(cblock));
	myprintf("03045: d block (data)  %11s\n",migliaia(dblock));
	myprintf("03046: h block (hash)  %11s\n",migliaia(hblock));
	myprintf("03047: i block (index) %11s\n",migliaia(iblock));
	myprintf("03048: file count      %11s\n",migliaia(filecount));

	if (mappafranzoblock.size()>0)
		for (MAPPAINTINT::iterator p=mappafranzoblock.begin();p!=mappafranzoblock.end();++p)
			myprintf("03049: FRANZOBLOCK             %03d %11s\n",p->first,migliaia(p->second));
		else
	myprintf("03050: This seems a 715 archive (original zpaq format)\n");
	if (mappahash.size()>0)
	{
		bool zpaqfranz60=false;
		for (MAPPASTRINGINTEGER::iterator p=mappahash.begin();p!=mappahash.end();++p)
		{
			if (p->first[p->first.size()-1]=='B')
				zpaqfranz60=true;
			myprintf("03051: HASHTYPE   %16s %11s\n",p->first.c_str(),migliaia(p->second));
		}
		if (mappafranzoblock.size()==mappahash.size())
			color_green();
		
		if (zpaqfranz60)
			myprintf("03052: This seems 60+ archive (newer zpaqfranz v60)\n");
		else
			myprintf("03053: This seems <60 archive (older zpaqfranz v59)\n");
	
		if (mappafranzoblock.size()==mappahash.size())
			color_restore();
		
		if (mappahash.size()>1)
		{
			color_yellow();
			myprintf("03054$ *** WARNING DO NOT USE -frugal adding data to this archive!\n");
			color_restore();
		}
	}
	return 0;
}
/// LICENSE_END.21





int reduz(vector<string>* i_files,DTMap* i_myedt,vector<DTMap::iterator>* i_vf)
{
	if (i_files==NULL)
	{
		myprintf("03055! GURU reduz i_files null\n");
		seppuku();
		return 2;
	}
	if (i_myedt==NULL)
	{
		myprintf("03056! GURU reduz i_myedt null\n");
		seppuku();
		return 2;
	}
	if (i_vf==NULL)
	{
		myprintf("03057! GURU reduz i_vf null\n");
		seppuku();
		return 2;
	}
	
	if ((*i_files).size()==0)
	{
		if (flagdebug)
			myprintf("03058: reduz i_files size 0\n");
		return 0;
	}
	
	(*i_myedt)	.clear();
	(*i_vf)		.clear();

	string 	mymethod	="04";
	int		myfragment	=6;
		
	vector<HT> myht;
	
	g_scritti				=0;
	int 			errors	=0;
	
	const int log_blocksize=20+atoi(mymethod.c_str()+1);
	if (log_blocksize<20 || log_blocksize>31) 
		error("88499: blocksize must be 0..11");
	const unsigned blocksize=(1u<<log_blocksize)-4096;
	const unsigned MAX_FRAGMENT=myfragment>19 || (8128u<<myfragment)>blocksize-12
      ? blocksize-12 : 8128u<<myfragment;
	const unsigned MIN_FRAGMENT=myfragment>25 || (64u<<myfragment)>MAX_FRAGMENT
      ? MAX_FRAGMENT : 64u<<myfragment;

	myprintf("03059: MIN_FRAGMENT %s MAX_FRAGMENT %s (%s)\n",migliaia2(MIN_FRAGMENT),migliaia(MAX_FRAGMENT),tohuman(MAX_FRAGMENT-64));

  	int64_t total_size	=0;  // size of all input
	
	g_bytescanned		=0;
	g_filescanned		=0;
	g_worked			=0;
	g_arraybytescanned.push_back(0);
	g_arrayfilescanned.push_back(0);

	for (unsigned i=0;i<(*i_files).size(); ++i)
		myscandir(0,(*i_myedt),(*i_files)[i],!flagnorecursion,false);
	eol();
	///printbar(' ',false);
	//myprintf("\r");

	int64_t total_done	=0;
	for (DTMap::iterator p=(*i_myedt).begin(); p!=(*i_myedt).end(); ++p)
		if (!isdirectory(p->first))
		{
			total_size+=p->second.size;
			(*i_vf).push_back(p);
		}

	if (orderby!="")
	{
		myprintf("03060: Sorting files  (orderby |%s|) ",orderby.c_str());
		if (flagdesc)
			myprintf(" descending ");
		std::sort((*i_vf).begin(), (*i_vf).end(), compareorderby);
	}
	else
		std::sort((*i_vf).begin(), (*i_vf).end(), compareFilename);

	if (flagdebug3)
		for (unsigned int i=0;i<(*i_vf).size();i++)
			myprintf("03061: %08d %s\n",(int)i,(*i_vf)[i]->first.c_str());
	
	OutputArchive out("","",NULL,NULL,0);
  
	myprintf("03062: Processing %s (%s) in %s files\n",migliaia(total_size), tohuman(total_size),migliaia2(int((*i_vf).size())));

	HTIndex htinv(myht,myht.size()+(total_size>>(10+myfragment))+(*i_vf).size());
	const unsigned htsize=myht.size();  // fragments at start of update
 
	writeJidacHeader(&out,0,-1,htsize);
	StringBuffer sb(blocksize+4096-128);  // block to compress
	unsigned frags=0;    // number of fragments in sb
	unsigned redundancy=0;  // estimated bytes that can be compressed out of sb
	unsigned text=0;     // number of fragents containing text
	unsigned exe=0;      // number of fragments containing x86 (exe, dll)
	const int ON=4;      // number of order-1 tables to save
	unsigned char o1prev[ON*256]={0};  // last ON order 1 predictions
	libzpaq::Array<char> fragbuf(MAX_FRAGMENT);
 
	char *buf=(char*)franz_malloc(g_ioBUFSIZE);
	///g_allocatedram+=g_ioBUFSIZE;
	if (buf==NULL)
	{
		myprintf("03063! GURU allocating io buf of size %s\n",g_ioBUFSIZE);
		seppuku();
		return 2;
	}

	XXH3_state_t state128;
			
    for (unsigned fi=0; fi<=(*i_vf).size(); ++fi)
	{
		FP in=FPNULL;
		int bufptr=0, buflen=0;  // read pointer and limit
		DTMap::iterator p;
		
		if (fi<(*i_vf).size())
		{
			p=(*i_vf)[fi];
			bufptr=buflen=0;
			in=myfopen(p->first.c_str(), RB);
			if (in==FPNULL)
			{  // skip if not found
				p->second.date=0;
				total_size-=p->second.size;
				int64_t attrib=0;
#ifdef _WIN32
				attrib=getwinattributes(p->first);
#endif // corresponds to #ifdef (#ifdef _WIN32)
				printerr("reduz",p->first.c_str(),attrib);
				++errors;
				continue;
			}
			fseeko(in, 0, SEEK_END);
			p->second.expectedsize=ftello(in);
			fseeko(in, 0, SEEK_SET);
			p->second.data=1;  
		}

		for (unsigned fj=0; true; ++fj)
		{
			int64_t sz		=0;  // fragment size;
			unsigned hits	=0;  // correct prediction count
			unsigned htptr	=0;  // fragment index
			char sha1result[20]={0};  // fragment hash
			unsigned char o1[256]={0};  // order 1 context -> predicted byte
			int c=EOF;  // current byte
			if (fi<(*i_vf).size())
			{
				int c1=0;  // previous byte
				unsigned h=0;  // rolling hash for finding fragment boundaries
				while (true)
				{
					if (bufptr>=buflen) bufptr=0, buflen=fread(buf, 1, g_ioBUFSIZE, in);

					if (bufptr>=buflen)
						c=EOF;
					else
						c=(unsigned char)buf[bufptr++];
					if (c!=EOF)
					{
						if (c==o1[c1])
							h=(h+c+1)*314159265u, ++hits;
						else
							h=(h+c+1)*271828182u;
						o1[c1]=c;
						c1=c;
						///fragbuf[sz++]=c;	
						sz++;
					}
					if (c==EOF
						|| sz>=MAX_FRAGMENT
						|| (myfragment<=22 && h<(1u<<(22-myfragment)) && sz>=MIN_FRAGMENT))
						break;
				}
				assert(sz<=MAX_FRAGMENT);
				total_done+=sz;
				// Look for matching fragment
///				assert(uint64_t(sz)==sha1.usize());
				/*
				libzpaq::SHA1 sha1;
				sha1.write(&fragbuf[0],sz);
				memcpy(sha1result, sha1.result(), 20);
				*/
				(void)XXH3_128bits_reset(&state128);
				(void)XXH3_128bits_update(&state128,&fragbuf[0],sz);
				XXH128_hash_t myhash=XXH3_128bits_digest(&state128);
				memcpy(sha1result,&myhash.high64,8);
				memcpy(sha1result+8,&myhash.low64,8);
				htptr=htinv.find(sha1result);
			}  // end if fiize()


			if (flagdebug2)
				if (fi<(*i_vf).size()) 
					myprintf("03064: done on %s\n",(*i_vf)[fi]->first.c_str());
			if (htptr==0) 
			{  
				int text1=0, exe1=0;
				int64_t h1=sz;
				unsigned char o1ct[256]={0};  // counts of bytes in o1
				static const unsigned char dt[256]=
				{  // 32768/((i+1)*204)
				  160,80,53,40,32,26,22,20,17,16,14,13,12,11,10,10,
					9, 8, 8, 8, 7, 7, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5,
					4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 3, 3, 3,
					3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
					2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
					1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
					1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
					1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
					1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
					1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1};
				for (int i=0; i<256; ++i) 
				{
					if (o1ct[o1[i]]<255) h1-=(sz*dt[o1ct[o1[i]]++])>>15;
					if (o1[i]==' ' && (isalnum(i) || i=='.' || i==',')) ++text1;
					if (o1[i] && (i<9 || i==11 || i==12 || (i>=14 && i<=31) || i>=240))
						--text1;
					if (i>=192 && i<240 && o1[i] && (o1[i]<128 || o1[i]>=192))
						--text1;
					if (o1[i]==139) ++exe1;
				}
				text1=(text1>=3);
				exe1=(exe1>=5);
				if (sz>0) h1=h1*h1/sz; // Test 2: near 0 if random.
				unsigned h2=h1;
				if (h2>hits) hits=h2;
				h2=o1ct[0]*sz/256;  // Test 3: bytes never seen or that predict 0.
				if (h2>hits) hits=h2;
				h2=0;
				for (int i=0; i<256*ON; ++i)  // Test 4: compare to previous o1.
				  h2+=o1prev[i]==o1[i&255];
				h2=h2*sz/(256*ON);
				if (h2>hits) hits=h2;
				if (hits>sz) hits=sz;
			// Start a new block if the current block is almost full, or at
			// the start of a file that won't fit or doesn't share mutual
			// information with the current block, or last file.
				bool newblock=false;
				if (frags>0 && fj==0 && fi<(*i_vf).size()) 
				{
					const int64_t esize=(*i_vf)[fi]->second.size;
					const int64_t newsize=sb.size()+esize+(esize>>14)+4096+frags*4;
					if (newsize>blocksize/4 && redundancy<sb.size()/128) newblock=true;
					if (newblock) 
					{  // test for mutual information
						unsigned ct=0;
						for (unsigned i=0; i<256*ON; ++i)
						  if (o1prev[i] && o1prev[i]==o1[i&255]) ++ct;
						if (ct>ON*2) newblock=false;
					  }
					  if (newsize>=blocksize) newblock=true;  // won't fit?
				}
				if (sb.size()+sz+80+frags*4>=blocksize) newblock=true; // full?
				if (fi==(*i_vf).size()) newblock=true;  // last file?
				if (frags<1) newblock=false;  // block is empty?
				
				int redz=redundancy/(sb.size()/256+1);
				if (fi<(*i_vf).size()) 
				{
					if (flagdebug2)
						myprintf("03065: %03d on %s\n",redz,(*i_vf)[fi]->first.c_str());
					(*i_vf)[fi]->second.red_total+=redz;
					(*i_vf)[fi]->second.red_count++;
					if (redz<(*i_vf)[fi]->second.red_min)
						(*i_vf)[fi]->second.red_min=redz;
					if ((*i_vf)[fi]->second.red_max<redz)
						(*i_vf)[fi]->second.red_max=redz;
					if ((*i_vf)[fi]->second.red_count!=0)
						(*i_vf)[fi]->second.red_avg=((*i_vf)[fi]->second.red_total/(*i_vf)[fi]->second.red_count);
				}
					
				if (newblock) 
				{
					g_scritti+=sb.size();
					print_progress(total_size, total_done,g_scritti,0);
					sb.resize(0);
					frags=redundancy=text=exe=0;
					memset(o1prev, 0, sizeof(o1prev));
				} // newblock
			// Append fragbuf to sb and update block statistics
				assert(sz==0 || fi<(*i_vf).size());
				sb.write(&fragbuf[0], sz);
				++frags;
				redundancy+=hits;
				exe+=exe1*4;
				text+=text1*2;
				if (sz>=MIN_FRAGMENT) 
				{
					memmove(o1prev, o1prev+256, 256*(ON-1));
					memcpy(o1prev+256*(ON-1), o1, 256);
				}
			}  // end if frag not matched or last block
			
		  // Update HT and ptr list
			if (fi<(*i_vf).size())
			{
				if (htptr==0) 
				{
					htptr=myht.size();
					myht.push_back(HT(sha1result, sz));
					htinv.update();
				}
				(*i_vf)[fi]->second.ptr.push_back(htptr);
			}
			if (c==EOF) break;
		}  // end for each fragment fj

		if (fi<(*i_vf).size())
		{
			print_progress(total_size, total_done,g_scritti,0);
			myfclose(&in);
			
		}
	}  // end for each file fi
	sort((*i_vf).begin(),(*i_vf).end(),compareredallavgthenfilename);
	franz_free(buf);

	return errors;
}


int Jidac::redu()
{
	vector<DTMap::iterator> vf;
	int64_t startredu=mtime();
	int risultato=reduz(&files,&edt,&vf);
	myprintf("\n");
	myprintf("03067: Average redundancy [0..255]. 0='random', 255='very compressible'\n");
	for (unsigned i=0;i<vf.size();i++)
		myprintf("03068: %03d [%03d...%03d] %10s %s\n",vf[i]->second.red_avg,vf[i]->second.red_min,vf[i]->second.red_max,tohuman(vf[i]->second.size),vf[i]->first.c_str());
	int64_t totalfilesize=0;
	for (unsigned i=0;i<vf.size();i++)
		totalfilesize+=vf[i]->second.size;
	double seconds=(mtime()-startredu+1)/1000.0;
	myprintf("03069: Redu time %1.3f (%s) / %s (%s) @ %s/s\n",
	seconds,timetohuman((uint32_t)(seconds)).c_str(),
	migliaia(totalfilesize),tohuman(totalfilesize),
	migliaia2((int64_t)(totalfilesize/seconds)));
		
	return risultato;
}


#ifdef _WIN32
int Jidac::read_archive2(int64_t i_starthere,string i_filename) 
{
	dcsize=dhsize=0;
	if (i_filename=="")
	{
		myprintf("03070! i_filename empty\n");
		return 2;
	}
	
	unsigned files=0;  // count

	InputArchive in(i_filename.c_str());
	if (!in.isopen()) 
	{
		myprintf("03071! i_filename does not exits %s\n",i_filename.c_str());
		return 2;
	}
 
  // Test password
	char s[4]={0};
	const int nr=in.read(s, 4);
	if (nr>0 && memcmp(s, "7kSt", 4) && (memcmp(s, "zPQ", 3) || s[3]<1))
		error("87915: password incorrect");
    in.seek(-nr, SEEK_CUR);
 
  // Scan archive contents
	string lastfile=i_filename;
	// last named file in streaming format
	if (lastfile.size()>5 && lastfile.substr(lastfile.size()-5)==".zpaq")
		lastfile=lastfile.substr(0, lastfile.size()-5); // drop .zpaq
	int64_t block_offset=32*(g_password!=0);  // start of last block of any type
	int64_t data_offset=block_offset;    // start of last block of d fragments
	bool found_data=false;   // exit if nothing found
	StringBuffer os(32832);  // decompressed block

	if (i_starthere>0)
	{
		if (flagdebug)
			myprintf("03072: starthere %21s\n",migliaia(i_starthere));
		in.seek(i_starthere,SEEK_SET);
	}
	
	int	parts=0;
	int64_t startblock=mtime();

  // Detect archive format and read the filenames, fragment sizes,
  // and hashes. In JIDAC format, these are in the index blocks, allowing
  // data to be skipped. Otherwise the whole archive is scanned to get
  // this information from the segment headers and trailers.
	bool done=false;
	while (!done) 
	{
		libzpaq::Decompresser d;
		try 
		{
			d.setInput(&in);
			double mem=0;
			while (d.findBlock(&mem)) 
			{
				if ( ++parts % 1000 ==0)
					if (!flagnoeta)
						myprintf("03073: ADS: block %10s K %12s (block/s)\r",migliaia((uint64_t)(parts/1000)),migliaia2((int64_t)(parts/(((mtime()-startblock)+1)/1000.0))));
				
				found_data=true;

				// Read the segments in the current block
				StringWriter filename, comment;
				int segs=0;  // segments in block
				bool skip=false;  // skip decompression?
				while (d.findFilename(&filename)) 
				{
					if (filename.s.size()) 
					{
						for (unsigned i=0; i<filename.s.size(); ++i)
							if (filename.s[i]=='\\') filename.s[i]='/';
								lastfile=filename.s.c_str();
					}
					comment.s="";
					d.readComment(&comment);

					// Test for JIDAC format. Filename is jDC<fdate>[cdhi]<num>
					// and comment ends with " jDC\x01". Skip d (data) blocks.
					if (comment.s.size()>=4 && comment.s.substr(comment.s.size()-4)=="jDC\x01") 
					{
						if (filename.s.size()!=28 || filename.s.substr(0, 3)!="jDC")
							error("87972: bad journaling block name");
						if (skip) 
							error("87974: mixed journaling and streaming block");

						// Read uncompressed size from comment
						int64_t usize=0;
						unsigned i;
						for (i=0; i<comment.s.size() && isdigit(comment.s[i]); ++i) 
						{
							usize=usize*10+comment.s[i]-'0';
							if (usize>0xffffffff) 
								error("87983: journaling block too big");
						}

						// Read the date and number in the filename
						int64_t fdate=0, num=0;
						for (i=3; i<17 && isdigit(filename.s[i]); ++i)
							fdate=fdate*10+filename.s[i]-'0';
						if (i!=17 || fdate<19000000000000LL || fdate>=30000000000000LL)
							error("87991: bad date");
						for (i=18; i<28 && isdigit(filename.s[i]); ++i)
							num=num*10+filename.s[i]-'0';
						if (i!=28 || num>0xffffffff)
							error("87994: bad fragment");

						// Decompress the block.
						os.resize(0);
						os.setLimit(usize);
						d.setOutput(&os);
						libzpaq::SHA1 sha1;
						d.setSHA1(&sha1);
						if (strchr("chi", filename.s[17])) 
						{
							if (mem>1.5e9)
								error("88006: index block requires too much memory (88006)");
							d.decompress();
							char sha1result[21]={0};
							d.readSegmentEnd(sha1result);
							if ((int64_t)os.size()!=usize) 
								error("88011: bad block size");
							if (usize!=int64_t(sha1.usize())) 
								error("88013: bad checksum size");
							if (sha1result[0] && memcmp(sha1result+1, sha1.result(), 20))
								error("88015: bad checksum");
						}
						else
							d.readSegmentEnd();

						// Transaction header (type c).
						// If in the future then stop here, else read 8 byte data size
						// from input and jump over it.
						if (filename.s[17]=='c') 
						{
							if (os.size()<8) 
								error("88026: c block too small");
							data_offset=in.tell()+1-d.buffered();
							const char* s=os.c_str();
							int64_t jmp=btol(s);
							///if (jmp<0) 
								///myprintf("03074: Incomplete transaction ignored\n");
							if (jmp<0
							|| (version<19000000000000LL && int64_t(ver.size())>version)
							|| (version>=19000000000000LL && version<fdate)) 
							{
								done=true;  // roll back to here
								goto endblock;
							}
							else 
							{
								dcsize+=jmp;
								if (jmp) in.seek(data_offset+jmp, SEEK_SET);
								ver.push_back(VER());
								ver.back().firstFragment=ht.size();
								ver.back().offset=block_offset;
								ver.back().data_offset=data_offset;
								ver.back().date=ver.back().lastdate=fdate;
								ver.back().csize=jmp;
								if (jmp) 
									goto endblock;
							}
						}

						// Fragment table (type h).
						// Contents is bsize[4] (sha1[20] usize[4])... for fragment N...
						// where bsize is the compressed block size.
						// Store in ht[].{sha1,usize}. Set ht[].csize to block offset
						// assuming N in ascending order.
						else 
						if (filename.s[17]=='h') 
						{
							assert(ver.size()>0);
							if (fdate>ver.back().lastdate) 
								ver.back().lastdate=fdate;
							if (os.size()%24!=4) 
								error("88068: bad h block size");
							const unsigned n=(os.size()-4)/24;
							if (num<1 || num+n>0xffffffff) 
								error("88071: bad h fragment");
							const char* s=os.c_str();
							const unsigned bsize=btoi(s);
							dhsize+=bsize;
							assert(ver.size()>0);
							
							///if (int64_t(ht.size())>num) 
								///myprintf("03075: Unordered fragment tables: expected >= %d found %1.0f\n",int(ht.size()), double(num));
							
							for (unsigned i=0; i<n; ++i) 
							{
								if (i==0) 
								{
									block.push_back(Block(num, data_offset));
									block.back().usize=8;
									block.back().bsize=bsize;
									block.back().frags=os.size()/24;
								}
								while (int64_t(ht.size())<=num+i) 
									ht.push_back(HT());
								memcpy(ht[num+i].sha1, s, 20);
								s+=20;
								assert(block.size()>0);
								unsigned f=btoi(s);
								if (f>0x7fffffff) 
									error("88096: fragment too big");
								block.back().usize+=(ht[num+i].usize=f)+4u;
							}
							data_offset+=bsize;
						}

            // Index (type i)
            // Contents is: 0[8] filename 0 (deletion)
            // or:       date[8] filename 0 na[4] attr[na] ni[4] ptr[ni][4]
            // Read into DT
						else 
						if (filename.s[17]=='i') 
						{
							assert(ver.size()>0);
							if (fdate>ver.back().lastdate) 
								ver.back().lastdate=fdate;
							const char* s=os.c_str();
							const char* const end=s+os.size();
							while (s+9<=end) 
							{
								DT dtr;
								dtr.date=btol(s);  // date
								if (flagdebug3)
									myprintf("03076: dtr.date %08d\n",dtr.date);
								if (dtr.date) 
									++ver.back().updates;
								else 
									++ver.back().deletes;
								const int64_t len=strlen(s);
								if (len>65535) 
									error("88124: filename too long");
								string fn=s;  // filename renamed
								s+=len+1;  // skip filename
								if (s>end) 
									error("88128: filename too long");
								if (dtr.date) 
								{
									++files;
									if (s+4>end) 
										error("88133: missing attr");
									unsigned na=btoi(s);  // attr bytes
									if (s+na>end || na>65535) 
										error("88136: attr too long");
									for (unsigned i=0; i<na; ++i, ++s)  // read attr
										if (i<8) dtr.attr+=int64_t(*s&255)<<(i*8);
									if (s+4>end) 
										error("88140: missing ptr");
									unsigned ni=btoi(s);  // ptr list size
									if (ni>(end-s)/4u) 
										error("88143: ptr list too long");
									dtr.ptr.resize(ni);
									for (unsigned i=0; i<ni; ++i) 
									{  // read ptr
										const unsigned j=btoi(s);
										dtr.ptr[i]=j;
									}
								}
								
								dt[fn]=dtr;
								if (flagdebug3)
									myprintf("03077: dtsize %s dtr.date %08d\n",migliaia(dt.size()),dtr.date);
							}  // end while more files
						}  // end if 'i'
						else 
						{
							myprintf("03078: Skipping %s %s\n",filename.s.c_str(), comment.s.c_str());
							error("88160:Unexpected journaling block 2");
						}
					}  // end if journaling

				// Streaming format
					else 
					{
						error("88167: streaming detected\n");
					}  // end else streaming
					++segs;
					filename.s="";
				}  // end while findFilename
				if (!done) 
					block_offset=in.tell()-d.buffered();
			}  // end while findBlock
			done=true;
		}  // end try
		catch (std::exception& e) 
		{
			in.seek(-d.buffered(), SEEK_CUR);
			myprintf("03079! Skipping block at %1.0f: %s\n", double(block_offset),e.what());
			return 2;
		}
endblock:;
	}  // end while !done
	if (in.tell()>32*(g_password!=0) && !found_data)
		error("88187: archive contains no data");
	
	/*
	if ((command=='l') && (flag715))
	printf("%d versions, %u files, %u fragments, %1.6f MB\n", 
      int(ver.size()-1), files, unsigned(ht.size())-1,
      block_offset/1000000.0);
*/
	// Calculate file sizes
	for (DTMap::iterator p=dt.begin(); p!=dt.end(); ++p) 
		for (unsigned i=0; i<p->second.ptr.size(); ++i) 
		{
			unsigned j=p->second.ptr[i];
			if (j>0 && j<ht.size() && p->second.size>=0) 
			{
				if (ht[j].usize>=0) p->second.size+=ht[j].usize;
				else 
					p->second.size=-1;  // unknown size
			}
		}
  return 0;
}
#endif // corresponds to #ifdef (#ifdef _WIN32)

#ifdef _WIN32


bool Jidac::exists_fasttxt_ads(string i_filename)
{
	return (exists(i_filename+":fasttxt"));
}


bool Jidac::isonly(string i_filename)
{
	for (unsigned i=0; i<onlyfiles.size();i++)
		if (ispath(onlyfiles[i].c_str(),i_filename.c_str()))
			return true;
	return false;
}

bool Jidac::work_ads(string i_thefile,string i_adsname,string i_description)
{
	if (flagdebug3)
		myprintf("03080: work ADS on %s:%s\n",i_thefile.c_str(),i_adsname.c_str());

	if (onlyfiles.size()>0)
		if (!isonly(i_adsname.c_str()))
		{
			if (flagdebug3)
				myprintf("03081: i_adsname not selected %s\n",i_adsname.c_str());
			return false;
		}
	
	string thepath=i_thefile+":"+i_adsname;
		
	if (flagkill)
	{
		if (DeleteFile(utow(thepath.c_str()).c_str()))
			myprintf("03082: ADS: successfully removed %s\n",thepath.c_str());
		else
			myprintf("03083: ADS: cannot remove %s\n",thepath.c_str());
	}
	else	/// just list
	{
		int64_t adssize=prendidimensionefile(thepath.c_str());
		if (adssize>0)
		{
			myprintf("03084: %-10s => %-25s (%15s) <<%Z>>\n",i_adsname.c_str(),i_description.c_str(),migliaia(adssize),i_thefile.c_str());

			return true;
		}
	}
	return false;
}
int Jidac::ads()
{
	if (files.size()!=1)
	{
		myprintf("03086! only a single file, please\n");
		return 2;
	}
	
		
	string fullarchive=files[0];
	string estensione=prendiestensione(fullarchive);
	if (flagverbose)
		myprintf("03087: Searching for jolly archive(s) in <<%s>> for extension <<%s>>\n",fullarchive.c_str(),estensione.c_str());

	g_bytescanned	=0;
	g_filescanned	=0;
	g_worked		=0;
	flagskipzfs		=true;  // strip down zfs
	DTMap		thedt;

	scandir(false,thedt,fullarchive,false);
	eol();
	//printbar(' ',false);
	//myprintf("\r");
	if (thedt.size()==0)
	{
		myprintf("03088: no archive founded => quit\n");
		return 1;
	}
	if (flagverbose)
		myprintf("03089: Founded %s archive(s)\n",migliaia(thedt.size()));

	int	risultato	=0;
	int therun		=0;

	for (DTMap::iterator p=thedt.begin(); p!=thedt.end(); ++p)
	{
		work_ads(p->first,"zpaqlist",	"List of files in archive");
		work_ads(p->first,"fasttxt",	"CRC-32 of the archive");
	}
	flagads=true;	// we really run on ADS
	if (flagforce)
		for (DTMap::iterator p=thedt.begin(); p!=thedt.end(); ++p)
		{
			therun++;
			string thefile=p->first;
			string thepath=thefile+":zpaqlist";
			if (flagdebug3)
				myprintf("03090: Running on %s\n",thefile.c_str());
			if (fill_ads(thefile,0))
			{
				myprintf("03091: ADS: rebuilded filelist on %Z\n",thefile.c_str());
			}
			else
			{
				myprintf("03093: ADS: error on %Z\n",thefile.c_str());
				risultato++;
			}

			string o_thecrcfile	=thefile+":fasttxt";
			string o_prezpaqcrc32="";
			int64_t o_prezpaqsize=0;
			
			rebuildcrc32(thefile,o_prezpaqcrc32,o_prezpaqsize,o_thecrcfile);

		}
	if  (risultato==0)
		return 0;
	return 2;
}
#endif // corresponds to #ifdef (#ifdef _WIN32)



  
int Jidac::listfast()
{
	if (!flagfast)
	{
		myprintf("03095! GURU. listfast but not -fast\n");
		return 2;
	}
	if (flagdebug4)
	{
		myprintf("03096: flagdebug4 in listfast\n");
		read_archive(NULL,archive.c_str());
		myprintf("03097: fine readarchive\n");
		blockdecoder();
		htdecoder();
		dtdecoder();
		seppuku();
	}
	
	if (archive=="")
	{
		myprintf("03098! archive cannot be empty!\n");
		return 2;
	}
	
	InputArchive in(archive.c_str());
	if (!in.isopen()) 
	{
		myprintf("03099! GURU cannot open <<%Z>>\n",archive.c_str());
		return 2;
	}
 
  	char s[4]={0};
	const int nr=in.read(s, 4);
	if (nr>0 && memcmp(s, "7kSt", 4) && (memcmp(s, "zPQ", 3) || s[3]<1))
		error("91058: password incorrect");
    in.seek(-nr, SEEK_CUR);
 
	int64_t block_offset=32*(g_password!=0);  // start of last block of any type
	bool found_data=false;   // exit if nothing found
	StringBuffer os(32832);  // decompressed block
	
/// get last the last 4KB of the archive
	int64_t thefilesize=in.totalsize();
	if (flagverbose)
		myprintf("03101: Archive size %21s\n",migliaia(thefilesize));
	size_t 	readSize;
	size_t 	blockSize=4096;
	if (thefilesize<(int64_t)blockSize)
		blockSize=thefilesize;
	char buffer[4096];
	in.seek(thefilesize-blockSize,SEEK_SET);
	readSize=in.read(buffer,blockSize);
	if (readSize!=blockSize)
	{
		myprintf("03102! GURU expected %s readed %s\n",migliaia(blockSize),migliaia2(readSize));
		return 2;
	}

/// Search for the magical start of some block.
///	Slow, but who cares? Only 4KB, no "smart-rolling-hash" here
	int64_t thelastblock=0;
	for (unsigned int i=0;i<readSize-4;i++)
		if (buffer[i]=='7')
			if (buffer[i+1]=='k')
				if (buffer[i+2]=='S')
					if (buffer[i+3]=='t')
						thelastblock=thefilesize-blockSize+i;
	if (thelastblock==0)
	{
		myprintf("03103: sorry, cannot find the last jidacblock => going to list()\n");
		flagfast=false;
		return list();
	}

	if (flagverbose)
		myprintf("03104: The last jidacblock %s\n",migliaia(thelastblock));
	
/// jump to the very last block,
	in.seek(thelastblock,SEEK_SET);
///	we expect just one i block	

	string	ifounded="";
	
	bool done=false;
	while (!done) 
	{
		libzpaq::Decompresser d;
		try 
		{
			d.setInput(&in);
			double mem=0;
			while (d.findBlock(&mem)) 
			{
				found_data=true;
				StringWriter filename, comment;
				while (d.findFilename(&filename)) 
				{
					comment.s="";
					d.readComment(&comment);
					if (comment.s.size()>=4 && comment.s.substr(comment.s.size()-4)=="jDC\x01") 
					{
						if (filename.s.size()!=28 || filename.s.substr(0, 3)!="jDC")
							error("91219: bad journaling block name");
						// Read uncompressed size from comment
						int64_t usize=0;
						unsigned i;
						for (i=0; i<comment.s.size() && isdigit(comment.s[i]); ++i) 
						{
							usize=usize*10+comment.s[i]-'0';
							if (usize>0xffffffff) 
								error("91227: journaling block too big");
						}

						// Read the date and number in the filename
						// Just to check for not-compliant (aka corruption)
						int64_t fdate=0, num=0;
						for (i=3; i<17 && isdigit(filename.s[i]); ++i)
							fdate=fdate*10+filename.s[i]-'0';
						if (i!=17 || fdate<19000000000000LL || fdate>=30000000000000LL)
							error("87991: bad date");
						for (i=18; i<28 && isdigit(filename.s[i]); ++i)
							num=num*10+filename.s[i]-'0';
						if (i!=28 || num>0xffffffff)
							error("87994: bad fragment");

						// Decompress the block.
						os.resize(0);
						os.setLimit(usize);
						d.setOutput(&os);
						libzpaq::SHA1 sha1;
						d.setSHA1(&sha1);
						if (strchr("chi", filename.s[17])) 
						{
							if (mem>1.5e9)
								error("91251: index block requires too much memory (91251)");
							d.decompress();
							char sha1result[21]={0};
							d.readSegmentEnd(sha1result);
							if ((int64_t)os.size()!=usize) 
								error("91256: bad block size");
							if (usize!=int64_t(sha1.usize())) 
								error("911258: bad checksum size");
							if (sha1result[0] && memcmp(sha1result+1, sha1.result(), 20))
								error("91259: bad checksum");
						}
						else
							d.readSegmentEnd();

						if (flagverbose)
							myprintf("03105: thefilename <<%s>>\n",filename.s.c_str());
						if (filename.s[17]=='i') 
						{
							const char* s=os.c_str();
							const char* const end=s+os.size();
							while (s+9<=end) 
							{
								DT dtr;
								dtr.date=btol(s);  // date
								const int64_t len=strlen(s);
								if (len>65535) 
									error("88124: filename too long");
								string fn=s;  // filename renamed
								s+=len+1;  // skip filename
								if (s>end) 
									error("88128: filename too long");
								ifounded=fn;
							}  
						}
						else 
						{
							myprintf("03106: Skipping %s %s\n",filename.s.c_str(), comment.s.c_str());
							error("91290: Unexpected journaling block 3");
						}
					}  // end if journaling
				// Streaming format
					else 
						error("91294: streaming format detected\n");
					filename.s="";
				}  // end while findFilename
				if (!done) 
					block_offset=in.tell()-d.buffered();
			}  // end while findBlock
			done=true;
		}  // end try
		catch (std::exception& e) 
		{
			in.seek(-d.buffered(), SEEK_CUR);
			myprintf("03107! Skipping block at %1.0f: %s\n", double(block_offset),e.what());
			return 2;
		}
	} 

	if (in.tell()>32*(g_password!=0) && !found_data)
		error("91309: archive contains no data");
	if (ifounded=="")
	{
		myprintf("03108: iname not founded\n");
		jidacreset();
		flagfast=false;
		return list();
	}
	
///	OK, next step. Decode the filename from "json-like" to data
/// filelistpointer:19870406|3278|19954995|3386|3387|1|XXHASH:C2E21483298016E3|jDC20240103155048d0000003386
	
	string encodedstring=ifounded;
	if (flagverbose)
		myprintf("03109: encoded string |%s|\n",encodedstring.c_str());
	if (mypos("filelistpointer:",encodedstring)==-1)
	{
		myprintf("03110: cannot find filelistpointer\n");
		flagfast=false;
		return list();
	}
	string offsetpointer	="";
	string soffsetpointer_h	="";
	string sfragstart		="";
	string sfragend			="";
	string thetag			="";
	string sthefilesize		="";
	string stheversion		="";
	string sthehash			="";
	
	unsigned int i=0;

	while (i<encodedstring.size())
		if (encodedstring[i]!=':')
			i++;
		else
			break;
	i++;
	while (i<encodedstring.size())
		if (isdigit(encodedstring[i]))
			offsetpointer+=encodedstring[i++];
		else
		break;
		
	i++;
	while (i<encodedstring.size())
		if (isdigit(encodedstring[i]))
			sthefilesize+=encodedstring[i++];
		else
		break;
		
	i++;
	while (i<encodedstring.size())
		if (isdigit(encodedstring[i]))
			soffsetpointer_h+=encodedstring[i++];
		else
		break;
		
	i++;	
	while (i<encodedstring.size())
		if (isdigit(encodedstring[i]))
			sfragstart+=encodedstring[i++];
		else
			break;
		
	i++;	
		while (i<encodedstring.size())
		if (isdigit(encodedstring[i]))
			sfragend+=encodedstring[i++];
		else
			break;
		
	i++;	
	while (i<encodedstring.size())
		if (isdigit(encodedstring[i]))
			stheversion+=encodedstring[i++];
		else
			break;
		
	i++;	
	while (i<encodedstring.size())
		if (encodedstring[i]!='|')
			sthehash+=encodedstring[i++];
		else
			break;
		
	i++;	
	while (i<encodedstring.size())
		thetag+=encodedstring[i++];
	
	
	int64_t thepointer		=myatoll(offsetpointer.c_str());
	int64_t thepointer_h	=myatoll(soffsetpointer_h.c_str());
	int64_t thesize			=myatoll(sthefilesize.c_str());
	int		theversion		=myatoll(stheversion.c_str());
	int		fragstart		=myatoll(sfragstart.c_str());
	int		fragend			=myatoll(sfragend.c_str());

	myreplace(sthehash,"XXHASH:","");
	if (flagverbose)
	{
		myprintf("03111: thepointer    %21s (start of data blocks)\n",migliaia(thepointer));
		myprintf("03112: offset_h      %21s (start of hash blocks)\n",migliaia(thepointer_h));
		myprintf("03113: fragstart     %21s (first monotonic fragment)\n",migliaia(fragstart));
		myprintf("03114: fragend       %21s (last  monotonic fragment)\n",migliaia(fragend));
		myprintf("03115: thesize       %21s (total bytes)\n",migliaia(thesize));
		myprintf("03116: theversion    %21s (just for infos)\n",migliaia(theversion));
		myprintf("03117: tag   |%s|\n",thetag.c_str());
		myprintf("03118: hash  |%s|\n",sthehash.c_str());
	}
	
	if (thepointer==0)
	{
		myprintf("03119: strange thepointer\n");
		jidacreset();
		flagfast=false;
		return list();
	}
	if (thepointer_h==0)
	{
		myprintf("03120: strange thepointer_h\n");
		jidacreset();
		flagfast=false;
		return list();
	}
	if (fragstart==0)
	{
		myprintf("03121: strange fragstart\n");
		jidacreset();
		flagfast=false;
		return list();
	}
	if (fragend==0)
	{
		myprintf("03122: strange fragend\n");
		jidacreset();
		flagfast=false;
		return list();
	}
	if (thesize==0)
	{
		myprintf("03123: strange thesize\n");
		jidacreset();
		flagfast=false;
		return list();
	}
	if (theversion==0)
	{
		myprintf("03124: strange theversion\n");
		jidacreset();
		flagfast=false;
		return list();
	}
	if (sthehash=="")
	{
		myprintf("03125: strange sthehash\n");
		jidacreset();
		flagfast=false;
		return list();
	}
	
	if (flagverbose)
	{
		printbar('+');
		myprintf("03126: Going for the h blocks @ %s\n",migliaia(thepointer_h));
		printbar('-');
	}
	in.seek(thepointer_h,SEEK_SET);
	
	
///	OK, in this case we want just the h blocks
	int64_t data_offset=thepointer;
	done=false;
	while (!done) 
	{
		libzpaq::Decompresser d;
		try 
		{
			d.setInput(&in);
			double mem=0;
			while (d.findBlock(&mem)) 
			{
				found_data=true;

				// Read the segments in the current block
				StringWriter filename, comment;
				while (d.findFilename(&filename)) 
				{
					comment.s="";
					d.readComment(&comment);
					if (comment.s.size()>=4 && comment.s.substr(comment.s.size()-4)=="jDC\x01") 
					{
						if (filename.s.size()!=28 || filename.s.substr(0, 3)!="jDC")
							error("91480: bad journaling block name");

						int64_t usize=0;
						unsigned i;
						for (i=0; i<comment.s.size() && isdigit(comment.s[i]); ++i) 
						{
							usize=usize*10+comment.s[i]-'0';
							if (usize>0xffffffff) 
								error("91491: journaling block too big");
						}

				// Read the date and number in the filename
						int64_t fdate=0, num=0;
						for (i=3; i<17 && isdigit(filename.s[i]); ++i)
						  fdate=fdate*10+filename.s[i]-'0';
						if (i!=17 || fdate<19000000000000LL || fdate>=30000000000000LL)
						  error("91507: bad date");
						for (i=18; i<28 && isdigit(filename.s[i]); ++i)
						  num=num*10+filename.s[i]-'0';
						if (i!=28 || num>0xffffffff) 
							error("91511bad fragment");

            // Decompress the block.
						os.resize(0);
						os.setLimit(usize);
						d.setOutput(&os);
						libzpaq::SHA1 sha1;
						d.setSHA1(&sha1);
						if (strchr("chi", filename.s[17])) 
						{
							if (mem>1.5e9) 
								error("91522: index block requires too much memory (91522)");
							d.decompress();
							char sha1result[21]={0};
							d.readSegmentEnd(sha1result);
							if ((int64_t)os.size()!=usize) 
							  error("91527: bad block size");
							if (usize!=int64_t(sha1.usize())) 
							  error("91529: bad checksum size");
							if (sha1result[0] && memcmp(sha1result+1, sha1.result(), 20))
								error("91531: bad checksum");
						}
						else
							d.readSegmentEnd();
						if (filename.s[17]=='h') 
						{
							if (flagdebug3)
								myprintf("03127: h block %s\n",filename.s.c_str());
							if (os.size()%24!=4) 
								error("91540: bad h block size");
							const unsigned n=(os.size()-4)/24;
							if (num<1 || num+n>0xffffffff) 
								error("91577: bad h fragment");
							const char* s=os.c_str();
							const unsigned bsize=btoi(s);
							dhsize+=bsize;
							assert(ver.size()>0);
							if (int64_t(ht.size())>num) 
							{
							  myprintf("03128: Unordered fragment tables: expected >= %d found %1.0f\n",int(ht.size()), double(num));
							}
							for (unsigned i=0; i<n; ++i) 
							{
								if (i==0) 
								{
									block.push_back(Block(num, data_offset));
									block.back().usize=8;
									block.back().bsize=bsize;
									block.back().frags=os.size()/24;
								}
								while (int64_t(ht.size())<=num+i) 
									ht.push_back(HT());
								memcpy(ht[num+i].sha1, s, 20);
								s+=20;
								assert(block.size()>0);
								unsigned f=btoi(s);
								if (f>0x7fffffff) 
									error("91601: fragment too big");
								block.back().usize+=(ht[num+i].usize=f)+4u;
							}
							data_offset+=bsize;
						}
			
					}  // end if journaling
					else 
						error("91577: some kind of streamed format?");
					
					filename.s="";
				}  // end while findFilename
				if (!done) 
					block_offset=in.tell()-d.buffered();
			}  // end while findBlock
		done=true;
		}  // end try
		catch (std::exception& e) 
		{
			error("91588: GURU Skipping block");
		}
	}  // end while !done
 
	if (in.tell()>32*(g_password!=0) && !found_data)
		error("91592: archive contains no data");
	
/////////////////////////////////////////////
/////////////////// Now we fake an extraction

	string i_filename="MFILE-memfile";
	
	DT mydt;
	mydt.date=now();
	mydt.size=thesize;
#ifdef _WIN32
		mydt.attr				=8311;
#else
		mydt.attr				=8496245; //0644
#endif // corresponds to #ifdef (#ifdef _WIN32)

	mydt.data=0;
	for (int i=fragstart;i<=fragend;i++)
		mydt.ptr.push_back(i);
	dt.clear();
///	just one file
	dt[i_filename]=mydt;
	if (flagdebug3)
	{
		printbar('$');
		blockdecoder();
		printbar('L');
	}
  // test blocks
	for (unsigned i=0; i<block.size(); ++i) 
	{
		if (block[i].bsize<0) 
			error("91648: negative block size");
		if (block[i].start<1) 
			error("91650: block starts at fragment 0");
		if (block[i].start>=ht.size()) 
			error("91652: block start too high");
		if (i>0 && block[i].start<block[i-1].start) 
			error("91654: unordered frags");
		if (i>0 && block[i].start==block[i-1].start) 
			error("91656: empty block");
		if (i>0 && block[i].offset<block[i-1].offset+block[i-1].bsize)
			error("91658: unordered blocks");
		if (i>0 && block[i-1].offset+block[i-1].bsize>block[i].offset)
			error("91660: overlapping blocks");
	}


	if (flagdebug3)
	{
		printbar('M');
		myprintf("03129: block decoder prima lavoro\n");
		blockdecoder();
	}

//	preparing the job
	ExtractJob job(*this);

	for (unsigned int i=0;i<block.size();i++)
	{
		block[i].size=block[i].frags;
		block[i].files.push_back(dt.begin());
		block[i].files[0]->second.ptr.clear();
		for (int j=fragstart;j<fragend;j++)
			block[i].files[0]->second.ptr.push_back(j);
	}
	job.total_size=dt.begin()->second.size;
  
	if (flagdebug3)
	{
		printbar('M');
		myprintf("03130: block decoder after work\n");
		blockdecoder();
	}
  // Decompress archive in parallel

	myprintf("03131: extracting %s with %d thread\n",migliaia(job.total_size),howmanythreads);

///	We will extract the MFILE-memfile to debug.txt in TEMP
///	Quite a lot of work ;)
/// We load with zpaqfranz l 1.zpaq MFILE-memfile -to something -fast
	files.clear();
	files.push_back(i_filename);
	
	tofiles.clear();
#ifdef ZPAQFULL ///NOSFTPSTART
	string kunfile=g_gettempdirectory()+"debug.txt";
	myreplaceall(kunfile,"\\","/");
	tofiles.push_back(nomefileseesistegia(kunfile));
	myprintf("03132: Temp file %s\n",tofiles[0].c_str());
#endif ///NOSFTPEND

	vector<ThreadID> tid(howmanythreads);
	for (unsigned i=0; i<tid.size(); ++i)
		run(tid[i], decompressThread, &job);

	for (unsigned i=0; i<tid.size(); ++i) 
		join(tid[i]);

	int64_t starthash=mtime();
	franz_do_hash dummy("XXHASH64");
	string gettedhash=dummy.filehash(0,tofiles[0].c_str(),false,starthash,job.total_size);
	if (gettedhash!=sthehash)
	{
		myprintf("03133! checksum by file %s\n",gettedhash.c_str());
		myprintf("03134! checksum expecte %s\n",sthehash.c_str());
		return 2;
	}
	FILE* myfile = freadopen(tofiles[0].c_str());
	if (myfile!=FPNULL)
	{
#ifdef ANCIENT
		char data[16384];
#else
		char data[65536*16];
#endif // corresponds to #ifdef (#ifdef ANCIENT)
		///int got=0;

		size_t got;
		while (!feof(myfile) && !ferror(myfile))
		{
			got = fread(data, sizeof(char), sizeof(data), myfile);
			if (got > 0)
			{
				data[got] = '\0'; // Important: terminate the string
				myprintf("%s", data);
			}
		}

//		while ((fread(data,sizeof(char),sizeof(data),myfile)) > 0)
//			myprintf("%s",data);
		fclose(myfile);
	///		delete_file(kunfile.c_str());
		myprintf("\n");
		myprintf("03135: Fast file list for version %s\n",migliaia(theversion));

	}
	else
		return 2;
				
	return 0;
}

void Jidac::dtdecoder()
{
	myprintf("03136: *** dt decoder size %s\n",migliaia(dt.size()));
	for (DTMap::iterator p=dt.begin(); p!=dt.end(); ++p)
	{
		myprintf("03137: ht           %s\n",p->first.c_str());
		myprintf("03138:         date %21s\n",migliaia(p->second.date));
		myprintf("03139:         size %21s\n",migliaia(p->second.size));
		myprintf("03140:         attr %21s\n",migliaia(p->second.attr));
		myprintf("03141:         data %21s\n",migliaia(p->second.data));
		myprintf("03142: ptr size     %21s\n",migliaia(p->second.ptr.size()));
		for (unsigned int j=0;j<p->second.ptr.size();j++)
			myprintf("03143: %08d %21s\n",j,migliaia(p->second.ptr[j]));
	}
}

void Jidac::htdecoder()
{
	myprintf("03144: *** ht decoder size %s\n",migliaia(ht.size()));
	for (unsigned int i=0;i<ht.size();i++)
	{
		myprintf("03145: ht %08d usize %10s ",i,migliaia(ht[i].usize));
		for (int j=0;j<20;j++)
			myprintf("%02x", ht[i].sha1[j]&255);
		myprintf("\n");
	}
}
void Jidac::blockdecoder()
{
	myprintf("03146: *** block decoder size %s\n",migliaia(block.size()));
	for (unsigned int i=0;i<block.size();i++)
	{
		myprintf("03147: block %08d\n",i);
		myprintf("03148: offset     %21s (location in archive)\n",migliaia(block[i].offset));
		myprintf("03149: usize      %21s => bsize %s\n",migliaia(block[i].usize),migliaia2(block[i].bsize));
		myprintf("03150: start      %21s (index in ht of first frag)\n",migliaia(block[i].start));
		myprintf("03151: size       %21s (fragment to decompress)\n",migliaia(block[i].size));
		myprintf("03152: frags      %21s (fragments in block)\n",migliaia(block[i].frags));
		myprintf("03153: extracted  %21s (fragments decompressed OK)\n",migliaia(block[i].extracted));
		myprintf("03154: state      %21s\n",migliaia(int64_t(block[i].state)));
		myprintf("03155: files#     %21s (list of files pointing here)\n",migliaia(block[i].files.size()));
		for (unsigned int j=0;j<block[i].files.size();j++)
		{
			myprintf("03156: %21s  %s\n",migliaia(block[i].files[j]->second.size),block[i].files[j]->first.c_str());
			unsigned fragcount=block[i].files[j]->second.ptr.size();
			myprintf("03157:fragct %21s:",migliaia(fragcount));
		
			bool hyphen=false;
			for (int l=0;l<int(fragcount);l++) 
			{
				if (l==0 || l==int(fragcount)-1 || block[i].files[j]->second.ptr[l]!=block[i].files[j]->second.ptr[l-1]+1 || block[i].files[j]->second.ptr[l]!=block[i].files[j]->second.ptr[l+1]-1) 
				{
					if (!hyphen) 
						myprintf(" ");
					hyphen=false;
					myprintf("%d", block[i].files[j]->second.ptr[l]);
				}
				else 
				{
					if (!hyphen) 
						myprintf("-");
					hyphen=true;
				}
			}
			myprintf("\n");
		}
	}
}	



#ifdef _WIN32

// Read arc (default: archive) up to -date into ht, dt, ver. Return place to
// append. If errors is not NULL then set it to number of errors found.
int64_t Jidac::pakka_read_archive(const char* arc) 
{
	int errors=0;
	dcsize=dhsize=0;

	list_Archive in;
	if (!in.open(false,arc, g_password)) 
	{
		list_printutf8(arc, stderr);
		printf( " not found.\n");
		return 2;
	}
  
	list_print_datetime();

	if (all)
		printf(":all");
	else
	{
		if (version==LIST_DEFAULT_VERSION) 
			printf( ":default");
		else 
			printf( ":until %1.0f: ", version+0.0);
	}
	printf("\n");
  
  // Test password
	if (g_password) 
	{
		char s[4]={0};
		const int nr=in.read(s, 4);
		if (nr>0 && memcmp(s, "7kSt", 4) && (memcmp(s, "zPQ", 3) || s[3]<1))
		{
			list_print_datetime();
			printf( "zpaqlist:password incorrect\n");
			exit(1);
		}
		in.seek(-nr, SEEK_CUR);
	}

	list_global_start=mtime();
	
	// Scan archive contents
	string lastfile=arc; // last named file in streaming format
	if (list_size(lastfile)>5)
		lastfile=lastfile.substr(0, list_size(lastfile)-5); // drop .zpaq
	int64_t block_offset=32*(g_password!=0);  // start of last block of any type
	int64_t data_offset=block_offset;    // start of last block of d fragments
	int64_t segment_offset=block_offset; // start of last segment
	bool found_data=false;   // exit if nothing found
	bool first=true;         // first segment in archive?
	int  pass=LIST_NORMAL;  // recover ht from data blocks?
	list_StringBuffer os(32832);  // decompressed block
	map<int64_t, double> compressionRatio;  // block offset -> compression ratio

	int lastver			=0;
	int blocchini		=0;
	int64_t total_time	=0;
	
	bool done=false;
	while (!done) 
	{
		try {
      // If there is an error in the h blocks, scan a second time in RECOVER
      // mode to recover the redundant fragment data from the d blocks.
				libzpaq2::list_Decompresser d;
				d.setInput(&in);
				if (d.findBlock())
					found_data=true;
				else 
				if (pass==LIST_ERR) 
				{
					segment_offset=block_offset=32*(g_password!=0);
					in.seek(block_offset, SEEK_SET);
					if (!d.findBlock()) break;
					pass=LIST_RECOVER;
					printf( "Attempting to recover fragment tables...\n");
				}
				else
					break;
	
				if ((list_size(list_ver)-1)!=lastver)
				{
					if (flagpakka)
					{
						if (((list_size(list_ver)-1)%2))
						{
							int64_t startprintf=mtime();
							
							
							///printf( "V %06d (%08d) ", list_size(list_ver)-1, list_size(list_dt));
							///list_progress(list_g_dimensione,  block_offset);
							list_progress(list_size(list_ver)-1,list_size(list_dt),list_g_dimensione,  block_offset);
							fflush(stdout);
							total_time+=mtime()-startprintf;
						}
					}
					lastver=list_size(list_ver)-1;
				}
		
		
      // Read the segments in the current block
				list_StringWriter filename, comment;
				int segs=0;
				while (d.findFilename(&filename)) 
				{
					if (filename.s.size()) 
					{
						for (unsigned i=0; i<filename.s.size(); ++i)
							if (filename.s[i]=='\\') filename.s[i]='/';
								lastfile=filename.s.c_str();
					}
					comment.s="";
					d.readComment(&comment);
					if (flagdebug3)
					{
						myprintf("03158: filename %s\n",filename.s.c_str());
						myprintf("03159: comment  %s\n",comment.s.c_str());
						myprintf("03160: in.tell 1 %d\n",in.tell());
					}
					
					if (lastver<2)
					{
						if (flagpakka)
						{
							if (!(blocchini%1000))
							{
								int64_t startprintf=mtime();
								list_print_datetime();
								printf( "Current block %08d\n", blocchini);
								fflush(stdout);
								total_time+=mtime()-startprintf;
							}
						}
						blocchini++;
					}
		

					int64_t usize=0;  // read uncompressed size from comment or -1
					int64_t fdate=0;  // read date from filename or -1
					int64_t fattr=0;  // read attributes from comment as wN or uN
					unsigned num=0;   // read fragment ID from filename
					const char* p=comment.s.c_str();
					for (; isdigit(*p); ++p)  // read size
					  usize=usize*10+*p-'0';
					if (p==comment.s.c_str()) usize=-1;  // size not found
					for (; *p && fdate<19000000000000LL; ++p)  // read date
					  if (isdigit(*p)) fdate=fdate*10+*p-'0';
					if (fdate<19000000000000LL || fdate>=30000000000000LL) fdate=-1;

					// Read the comment attribute wN or uN where N is a number
					int attrchar=0;
					for (; true; ++p) 
					{
						if (*p=='u' || *p=='w') 
						{
							attrchar=*p;
							fattr=0;
						}
						else 
						if (isdigit(*p) && (attrchar=='u' || attrchar=='w'))
							fattr=fattr*10+*p-'0';
						else 
						if (attrchar) 
						{
							fattr=fattr*256+attrchar;
							attrchar=0;
						}
						if (!*p) 
							break;
					}

        // Test for JIDAC format. Filename is jDC<fdate>[cdhi]<num>
        // and comment ends with " jDC\x01"
					if (comment.s.size()>=4
						&& usize>=0
						&& comment.s.substr(comment.s.size()-4)=="jDC\x01"
						&& filename.s.size()==28
						&& filename.s.substr(0, 3)=="jDC"
						&& strchr("cdhi", filename.s[17])) 
						{

						  // Read the date and number in the filename. Skip over zpaqfranz
							num		=0;
							fdate	=0;
							for (unsigned i=3; i<17 && isdigit(filename.s[i]); ++i)
								fdate=fdate*10+filename.s[i]-'0';
							for (unsigned i=18; i<filename.s.size() && isdigit(filename.s[i]);++i)
								num=num*10+filename.s[i]-'0';

							// Decompress the block. In recovery mode, only decompress
							// data blocks containing missing list_HT data.
							os.reset();
							os.setLimit(usize);
							d.setOutput(&os);
							libzpaq::SHA1 sha1;
							d.setSHA1(&sha1);
							if (pass!=LIST_RECOVER || (filename.s[17]=='d' && num>0 &&
							  num<list_ht.size() && list_ht[num].csize==LIST_HT_BAD)) 
								{
									d.decompress();
									char sha1result[21]={0};
									d.readSegmentEnd(sha1result);
									if (usize!=int64_t(sha1.usize())) 
									{
										printf( "%s size should be %1.0f, is %1.0f\n",
											  filename.s.c_str(), double(usize),
											  double(sha1.usize()));
										libzpaq::error("incorrect block size");
									}
									if (sha1result[0] && memcmp(sha1result+1, sha1.result(), 20)) 
									{
										printf( "%s checksum error\n", filename.s.c_str());
										libzpaq::error("bad checksum");
									}
								}
							else
							d.readSegmentEnd();

							
							  // Transaction header (type c).
							  // If in the future then stop here, else read 8 byte data size
							  // from input and jump over it.
							if (filename.s[17]=='c' && fdate>=19000000000000LL
								  && fdate<30000000000000LL && pass!=LIST_RECOVER) 
								{
									data_offset=in.tell()+1;
									bool isbreak=version<19000000000000LL ? list_size(list_ver)>version :
												 version<fdate;
									int64_t jmp=0;
									if (!isbreak && os.size()==8) 
									{  // jump
										const char* s=os.c_str();
										jmp=list_btol(s);
										if (jmp<0) 
										{
											printf( "Incomplete transaction ignored\n");
											isbreak=true;
										}
										else 
										if (jmp>0) 
										{
											dcsize+=jmp;
											in.seek(jmp, SEEK_CUR);
										}
									}
									if (os.size()!=8) 
									{
										printf( "Bad JIDAC header size: %d\n", list_size(os));
										isbreak=true;
										++errors;
									}
									if (isbreak) 
									{
										done=true;
										break;
									}
									list_ver.push_back(list_VER());
									list_ver.back().firstFragment=list_size(list_ht);
									list_ver.back().offset=block_offset;
									list_ver.back().date=fdate;
									list_ver.back().csize=jmp;
								}

          // Fragment table (type h).
          // Contents is bsize[4] (sha1[20] usize[4])... for fragment N...
          // where bsize is the compressed block size.
          // Store in ht[].{sha1,usize}. Set ht[].csize to block offset
          // assuming N in ascending order.
          else if (filename.s[17]=='h' && num>0 && os.size()>=4
                   && pass!=LIST_RECOVER) {
            const char* s=os.c_str();
            const unsigned bsize=list_btoi(s);
            dhsize+=bsize;

            const unsigned n=(os.size()-4)/24;
            if (list_ht.size()>num) {
              printf(
                "Unordered fragment tables: expected >= %d found %1.0f\n",
                list_size(list_ht), double(num));
              pass=LIST_ERR;
            }
            double usum=0;  // total uncompressed size
            for (unsigned i=0; i<n; ++i) {
              while (list_ht.size()<=num+i) list_ht.push_back(list_HT());
              memcpy(list_ht[num+i].sha1, s, 20);
              s+=20;
              if (list_ht[num+i].csize!=LIST_HT_BAD) libzpaq::error("duplicate fragment ID");
              usum+=list_ht[num+i].usize=list_btoi(s);
              list_ht[num+i].csize=i?-int(i):data_offset;
            }
            if (usum>0) compressionRatio[data_offset]=bsize/usum;
            data_offset+=bsize;
          }

          // Index (type i)
          // Contents is: 0[8] filename 0 (deletion)
          // or:       date[8] filename 0 na[4] attr[na] ni[4] ptr[ni][4]
          // Read into list_DT
          else if (filename.s[17]=='i' && pass!=LIST_RECOVER) {
            const char* s=os.c_str();
            const char* const end=s+os.size();
            while (s<=end-9) {
              const char* fp=s+8;  // filename
              list_DT& dtr=list_dt[fp];
              dtr.dtv.push_back(list_DTV());
              list_DTV& dtv=dtr.dtv.back();
              dtv.version=list_size(list_ver)-1;
              dtv.date=list_btol(s);

              if (dtv.date) ++list_ver.back().updates;
              else ++list_ver.back().deletes;
              s+=strlen(fp)+1;  // skip filename
              if (dtv.date && s<=end-8) {
                const unsigned na=list_btoi(s);
                for (unsigned i=0; i<na && s<end; ++i, ++s)  // read attr
                  if (i<8) dtv.attr+=int64_t(*s&255)<<(i*8);
                if (s<=end-4) {
                  const unsigned ni=list_btoi(s);
                  dtv.ptr.resize(ni);
                  for (unsigned i=0; i<ni && s<=end-4; ++i) {  // read ptr
                    const unsigned j=dtv.ptr[i]=list_btoi(s);
                    if (j<1 || j>=list_ht.size()+(1<<24))
                      libzpaq::error("bad fragment ID");
                    while (j>=list_ht.size()) {
                      pass=LIST_ERR;
                      list_ht.push_back(list_HT());
                    }
                    dtv.size+=list_ht[j].usize;
                    list_ver.back().usize+=list_ht[j].usize;

                    // Estimate compressed size
                     {
                      unsigned k=j;
                      if (list_ht[j].csize<0 && list_ht[j].csize!=LIST_HT_BAD)
                        k+=list_ht[j].csize;
                      if (k>0 && k<list_ht.size() && list_ht[k].csize!=LIST_HT_BAD
                          && list_ht[k].csize>=0)
                        dtv.csize+=compressionRatio[list_ht[k].csize]*list_ht[j].usize;
                    }
                  }
                }
              }
          }
	        }

          // Recover fragment sizes and hashes from data block
          else if (pass==LIST_RECOVER && filename.s[17]=='d' && num>0
                   && num<list_ht.size()) {
            if (os.size()>=8 && list_ht[num].csize==LIST_HT_BAD) {
              const char* p=os.c_str()+os.size()-8;
              unsigned n=list_btoi(p);  // first fragment == num or 0
              if (n==0) n=num;
              unsigned f=list_btoi(p);  // number of fragments
              if (n!=num)
                printf( "fragments %u-%u were moved to %u-%u\n",
                    n, n+f-1, num, num+f-1);
              n=num;
              if (f && f*4+8<=os.size()) {
                printf( "Recovering fragments %u-%u at %1.0f\n",
                       n, n+f-1, double(block_offset));
                while (list_ht.size()<=n+f) list_ht.push_back(list_HT());
                p=os.c_str()+os.size()-8-4*f;

                // read fragment sizes into ht[n..n+f-1].usize
                unsigned sum=0;
                for (unsigned i=0; i<f; ++i) {
                  sum+=list_ht[n+i].usize=list_btoi(p);
                  list_ht[n+i].csize=i ? -int(i) : block_offset;
                }

                // Compute hashes
                if (sum+f*4+8==os.size()) {
                  printf( "Computing hashes for %s bytes\n",migliaia(sum));
                  libzpaq::SHA1 sha1;
                  p=os.c_str();
                  for (unsigned i=0; i<f; ++i) {
                    for (int j=0; j<list_ht[n+i].usize; ++j) {

                      sha1.put(*p++);
                    }
                    memcpy(list_ht[n+i].sha1, sha1.result(), 20);
                  }

                }
              }
            }

            // Correct bad offsets

            if (list_ht[num].csize!=block_offset) {
              printf( "Changing block %s offset from %1.0f to %1.0f\n",
                     migliaia(num), double(list_ht[num].csize), double(block_offset));
              list_ht[num].csize=block_offset;
            }
          }

          // Bad JIDAC block
          else if (pass!=LIST_RECOVER) {
            printf( "Bad JIDAC block ignored: %s %s\n",
                    filename.s.c_str(), comment.s.c_str());
            ++errors;
          }
        }

        // Streaming format
        else if (pass!=LIST_RECOVER) {

          // If previous version does not exist, start a new one
          if (list_size(list_ver)==1) {
            if (list_size(list_ver)>version) {
              done=true;
              break;
            }
            list_ver.push_back(list_VER());
            list_ver.back().firstFragment=list_size(list_ht);
            list_ver.back().offset=block_offset;
            list_ver.back().csize=-1;
          }

          char sha1result[21]={0};
          d.readSegmentEnd(sha1result);
          list_DT& dtr=list_dt[lastfile];
          if (filename.s.size()>0 || first) {
            dtr.dtv.push_back(list_DTV());
            dtr.dtv.back().date=fdate;
            dtr.dtv.back().attr=fattr;
            dtr.dtv.back().version=list_size(list_ver)-1;
            ++list_ver.back().updates;
          }

          dtr.dtv.back().ptr.push_back(list_size(list_ht));
          if (usize>=0 && dtr.dtv.back().size>=0) dtr.dtv.back().size+=usize;
          else dtr.dtv.back().size=-1;
          dtr.dtv.back().csize+=in.tell()-segment_offset;
          if (usize>=0) list_ver.back().usize+=usize;
          list_ht.push_back(list_HT(sha1result+1, usize>0x7fffffff ? -1 : usize,
                          segs ? -segs : block_offset));

        }
        ++segs;
        filename.s="";
        first=false;
        segment_offset=in.tell();
		
		///printf("04966: segment_offset  %d\n",segment_offset);
	
      }  // end while findFilename
      if (!done) segment_offset=block_offset=in.tell();
    }  // end try
    catch (std::exception& e) {
      block_offset=in.tell();
      printf( "100918 Skipping block at %1.0f: %s\n", double(block_offset),
              e.what());
      ++errors;
    }
  }  // end while !done
  if (in.tell()>32*(g_password!=0) && !found_data)
  {
	list_print_datetime();
 printf("archive contains no data\n");
  }
  in.close();

  // Recompute file sizes in recover mode
  if (pass==LIST_RECOVER) {
    printf( "Recomputing file sizes\n");
    for (list_DTMap::iterator p=list_dt.begin(); p!=list_dt.end(); ++p) {
      for (unsigned i=0; i<p->second.dtv.size(); ++i) {
        p->second.dtv[i].size=0;
        for (unsigned j=0; j<p->second.dtv[i].ptr.size(); ++j) {
          unsigned k=p->second.dtv[i].ptr[j];
          if (k>0 && k<list_ht.size())
            p->second.dtv[i].size+=list_ht[k].usize;
        }
      }
    }
  }
  
	fprintf(list_outputlog, "!%d\n", list_size(list_ver)-1); 
///	fprintf(list_outputlog, "$%s\n", atoi(block_offset)); 
	list_print_datetime();
	printf( "OUTPUT...V %d, F %d, %s bytes %d blocks Otime %1.3f s\n", 
    list_size(list_ver)-1, list_size(list_dt), migliaia(block_offset),blocchini,(total_time/1000.0));
 	
  return block_offset;
}


/////////////////////////////// mylist //////////////////////////////////
// List contents
int Jidac::pakkalist() 
{
	// Init archive state
	list_ht.resize	(1);  // element 0 not used
	list_ver.resize	(1); // version 0
	dhsize=dcsize=0;

	int64_t csize=0;
	list_outputlog=stdout;
	list_global_start=mtime();  // get start time
		
	if (g_output!="")
		list_outputlog=fopen(g_output.c_str(),"w");
	
	if (list_outputlog==NULL)
	{
		myprintf("03161: GURU cannot open -out log %Z\n",g_output.c_str());
		seppuku();
	}
	csize=pakka_read_archive(archive.c_str());
	if (csize==0)
	{
		myprintf("03163: Readed archive size 0\n");
		seppuku();
	}

	vector<list_DTMap::const_iterator> filelist;
	for (list_DTMap::iterator p=list_dt.begin(); p!=list_dt.end(); ++p)
	{
		if (p->second.dtv.size()<1) 
		{
			printf( "Invalid index entry: %s\n", p->first.c_str());
			libzpaq::error("corrupted index");
		}
		if (!strstr(p->first.c_str(), ":$DATA")) //fuck off windows metadata
			filelist.push_back(p);
	}
	
/// versions
	for (int i=0; i<list_size(list_ver); ++i) 
		if (!(i==0 && list_ver[i].updates==0 && list_ver[i].deletes==0 && list_ver[i].date==0 && list_ver[i].usize==0))
			fprintf(list_outputlog, "| %6d %s\n", i,list_dateToString(list_ver[i].date).c_str());
	  
	string lastfile="?";

	unsigned int dieci=1;
	unsigned int righe=0;
	for (unsigned fi=0; fi<filelist.size(); ++fi) 
	{	
		list_DTMap::const_iterator p=filelist[fi];
		for (unsigned i=0; i<p->second.dtv.size(); ++i) 
			if (p->second.dtv[i].version>=1 //since
			&& (all || (i+1==p->second.dtv.size() && p->second.dtv[i].date))) 
			if (!strstr(p->first.c_str(), ":$DATA"))
				righe+=4;
	
	}
	/// I need line numbers at the head, not at the tail, of the output
	fprintf(list_outputlog, "+%d\n",(int)righe);
	
	unsigned int blocco = (filelist.size() / 10)+1;
	int64_t startoutput=mtime();
	for (unsigned fi=0; fi<filelist.size(); ++fi) 
	{	

		if ((fi+1) % blocco==0)
		{
			list_print_datetime();
			printf("W %03d%% %08d/%.08d\n",int((dieci++)*10),int(fi+1),(int)filelist.size());
		}
		list_DTMap::const_iterator p=filelist[fi];
		for (unsigned i=0; i<p->second.dtv.size(); ++i) 
		{
			if (p->second.dtv[i].version>=1 //since
			&& (all || (i+1==p->second.dtv.size() && p->second.dtv[i].date))) 
			{
					fprintf(list_outputlog, "-%d\n", p->second.dtv[i].version);
					if (p->second.dtv[i].date) 
						fprintf(list_outputlog, "%s\n%s\n",
							list_mydateToString(p->second.dtv[i].date).c_str(),
							migliaia(p->second.dtv[i].size));
					else 
						fprintf(list_outputlog, "D\n0\n");
				
					if (flagdistinct)
						list_printutf8(p->first.c_str(), list_outputlog);
					else
					{
						if (lastfile!=p->first.c_str())
						{
							list_printutf8(p->first.c_str(), list_outputlog);
							lastfile=p->first.c_str();
						}
						else
							fprintf(list_outputlog,"?");
					}
					fprintf(list_outputlog, "\n");
			}
		}
	}

	if (g_output!="")
	{
		fseeko(list_outputlog, 0, SEEK_END);
		uint64_t outsize=ftello(list_outputlog);
		list_print_datetime();
		printf("Output %s bytes / %s lines in %1.3f s\n",migliaia(outsize),migliaia2(righe),(mtime()-startoutput)/1000.0);
		fclose (list_outputlog);
	}
	
	
	list_print_datetime();
	printf( "T=%1.3fs", (mtime()-list_global_start)/1000.0);
  	printf( " (all OK)\n");
	return 0;
}

#endif // corresponds to #ifdef (#ifdef _WIN32)

bool decode_zpaq_version(string i_string,string& o_maj,string& o_minor,string& o_letter)
{
	if (i_string=="") 
		return false;
	if (flagdebug2)
		myprintf("03164: decoding zpaq version %s\n",i_string.c_str());
	o_maj		="";
	o_minor		="";
	o_letter	="";
	
	unsigned int i=0;
	
	while (i<i_string.size())
	{
		if (isdigit(i_string[i]))
			o_maj+=i_string[i++];
		else
			break;
	}
	i++;
	while (i<i_string.size())
	{
		if (isdigit(i_string[i]))
			o_minor+=i_string[i++];
		else
			break;
	}
	while (i<i_string.size())
	{
		if (isalpha(i_string[i]))
			o_letter+=i_string[i++];
		else
			break;
	}
	if (flagdebug2)
	{
		myprintf("03165: maj |%s|\n",o_maj.c_str());
		myprintf("03166: min |%s|\n",o_minor.c_str());
		myprintf("03167: let |%s|\n",o_letter.c_str());
	}
	if ((o_maj.size()+o_minor.size()+o_letter.size())==0)
		return false;
	return true;
}




bool isurl(string i_url)
{
	if ((mypos("http://",i_url)!=0) && (mypos("https://",i_url)!=0))
		return false;

	
	if (myright(i_url,1)=="/")
		return false;
	
	unsigned int barre=0;
	for (unsigned int i=0;i<i_url.size();i++)
		if (i_url[i]=='/')
			barre++;
	if (barre<3)
	{
		myprintf("03189: ERROR: at least 3 slashes needed founded %d\n",barre);
		return false;
	}
	return true;
	
}

#ifdef ZPAQFULL ///NOSFTPSTART
int Jidac::update()
{
#if defined(SOLARIS) || defined(__HAIKU__)
	myprintf("03190: Cannot update SOLARIS or HAIKU\n");
	return 0;
#else
	if (flagverbose)
	myprintf("03192: Checking internet update (-verbose)\n");
	else
	myprintf("03191: Checking internet update (-verbose for details)\n");
	string randnocache="?"+generaterandomstring(10);

#ifdef unix
	randnocache="";
#endif // corresponds to #ifdef (#ifdef unix)

	if (flagdebug)
		myprintf("03192: randnocache %s\n",randnocache.c_str());

	string	http_url="http://www.francocorbelli.it/zpaqfranz/win64/zpaqfranz.sha256";
	string	http_exe="http://www.francocorbelli.it/zpaqfranz/win64/zpaqfranz.exe";
	string	http_p7m="http://www.francocorbelli.it/zpaqfranz/win64/zpaqfranz.sha256.p7m";
	
#if defined(_WIN32) && (!defined(_WIN64))
	http_url="http://www.francocorbelli.it/zpaqfranz/win32/zpaqfranz32.sha256";
	http_exe="http://www.francocorbelli.it/zpaqfranz/win32/zpaqfranz32.exe";
	http_p7m="http://www.francocorbelli.it/zpaqfranz/win32/zpaqfranz32.sha256.p7m";
#endif // corresponds to #if (#if defined(_WIN32) && (!defined(_WIN64)))

#if defined(_WIN64) && ( defined(HWSHA1))
	http_url="http://www.francocorbelli.it/zpaqfranz/win64hw/zpaqfranzhw.sha256";
	http_exe="http://www.francocorbelli.it/zpaqfranz/win64hw/zpaqfranzhw.exe";
	http_p7m="http://www.francocorbelli.it/zpaqfranz/win64hw/zpaqfranzhw.sha256.p7m";
#endif // corresponds to #if (#if defined(_WIN64) && ( defined(HWSHA1)))


	string 	p7murl 	=http_p7m+randnocache;
	string	p7mfile	=g_gettempdirectory()+"zpaqfranz_verfile.sha256.p7m";
	p7mfile			=nomefileseesistegia(p7mfile);
	string hashfromp7m;

	if (files.size()==2)
	{
		http_url=files[0];
		http_exe=files[1];
		myprintf("03193: Command-selected URL\n");
		myprintf("03194: new http_url |%s|\n",http_url.c_str());
		myprintf("03195: new http_exe |%s|\n",http_exe.c_str());
	}
#ifdef _WIN32
	else
	{
		if (!downloadfile(p7murl,p7mfile,false))
			myprintf("00551! Cannot download the signature file!\n");
		else
		{
			myprintf("\n");
			myprintf("00533: Ready to extract from p7m\n");
		
			int 	p7msize=prendidimensionefile(p7mfile.c_str());
			if (p7msize>4000)
			{
				myprintf("03344! The p7m size is too big (%s)\n",migliaia(p7msize));
				return 2;
			}
		
			FILE* p7m_handle=fopen(p7mfile.c_str(), "rb");
			if (p7m_handle==FPNULL)
			{
				myprintf("01926$ cannot read from p7m <<%Z>>\n",p7mfile.c_str());
				return 2;
			}
			fseeko(p7m_handle,0x3C,SEEK_SET);
			char ch;
			while ((ch = fgetc(p7m_handle)) != EOF) 
			{
				if (!ishex(ch))
					break;
				hashfromp7m+=ch;
			}
		
			fclose(p7m_handle);
			if (hashfromp7m.size()!=64)
			{
				myprintf("00586! The hash from .p7m is not 64 chars long, but %d\n",hashfromp7m.size());
				return 2;
			}
		}
		if (flagparanoid)
		{
			myprintf("\n");
			color_yellow();
			printbar('+');
			myprintf("10034: Due to -paranoid you can check yourself the (Italian) digital sign of the sha256 hash\n");
			myprintf("10035: This is a Qualified Electronic Signature (FEQ) in CAdES format\n");
			myprintf("10034: https://www.agid.gov.it/it/piattaforme/firma-elettronica-qualificata/software-verifica\n");
			printbar('+');
			color_restore();
			string winp7m=linuxtowinpath(p7mfile);
			if (OpenClipboard(NULL)) 
			{
				EmptyClipboard();
				const size_t len = winp7m.size()+1;
				HGLOBAL hMem = GlobalAlloc(GMEM_MOVEABLE, len);
				if (hMem==NULL) 
				{
					myprintf("03335$ Error allocating Global!\n");
					CloseClipboard();
				}
				else
				{
					memcpy(GlobalLock(hMem),winp7m.c_str(), len);
					GlobalUnlock(hMem);
					SetClipboardData(CF_TEXT, hMem);
					CloseClipboard();
				}
			}
			myprintf("\n");
			myprintf("03322: Two options\n");
			color_green();
			myprintf("03322: (1) if you have openssl installed => run\n");
			myprintf("03342: openssl smime -verify -in \"%s\" -inform DER  -noverify\n",winp7m.c_str());
			
			const char *notariato = "https://vol.ca.notariato.it/it";
			myprintf("\n");
			myprintf("03322: (2) or paste the clipboard (control-v) on 'Scegli un file firmato'\n");
			myprintf("03333: of the site %s, then click 'Verifica'\n",notariato);
			color_restore();
			printbar('-');
			myprintf("03344: If the digital sign is good repeat the upgrade without -paranoid\n");
			color_yellow();
			myprintf("*** PRESS ANY KEY TO CONTINUE (the default browser will be launched) ***\n");
			color_restore();
			while ((!iskeypressed(0)))
			sleep(1);
			ShellExecuteA(NULL,"open",notariato,NULL,NULL,SW_SHOWNORMAL);
			return 0;
		}
	}
#endif // corresponds to #ifdef (#ifdef _WIN32)

	
	if (!isurl(http_url))
	{
		myprintf("03196! http_url is not a url |%s|\n",http_url.c_str());
		return 2;
	}
	if (!isurl(http_exe))
	{
		myprintf("03197! http_exe is not a url |%s|\n",http_exe.c_str());
		return 2;
	}
	
	string 	verurl 	=http_url+randnocache;
	string	verfile	=g_gettempdirectory()+"zpaqfranz_verfile.sha256";
	verfile			=nomefileseesistegia(verfile);

	if (!downloadfile(verurl,verfile,false))
		return 2;
	myprintf("\n");
	
///	verfile="z:\\test.256";
	if (!sanitizefile(verfile))
	{
		myprintf("03198! ERROR C5 strange downloaded file\n");
		remove_temp_file(verfile);
		seppuku();
		return 2;
	}
	
	myprintf("03199: Testing internet version...\n");
	
	vector<string> versioni;
	readfiletoarray(verfile,versioni);
	if (versioni.size()==0)
	{
		myprintf("03200! version file with 0 lines\n");
		return 2;
	}
	
	string linea;
	
#ifdef _WIN32
	if (versioni.size()!=1)
	{
		myprintf("03201! version file should have 1 line instead of %s\n",migliaia(versioni.size()));
		return 2;
	}
	linea=versioni[0];
#else
	linea=versioni[versioni.size()-1];
	if (flagdebug3)
		myprintf("03202: the last line |%s|\n",linea.c_str());
#endif	 // corresponds to #ifdef (#ifdef _WIN32)
	
	
	if (linea.size()<70)
	{
		myprintf("03203! Line size should be >=70 %08s\n",migliaia(linea.size()));
		return 2;
	}
	
	if (!sanitizeline(linea))
	{
		myprintf("03204! ERROR C5 the downloaded file is not adherent to expected format\n");
		remove_temp_file(verfile);
		seppuku();
		return 2;
	}
	
	string thesha256="";
	for (unsigned int i=0;i<64;i++)
		if ((isdigit(linea[i]) || (isalpha(linea[i]))))
			thesha256+=linea[i];
	if (thesha256.size()!=64)
	{
		myprintf("03205! sha256 len expected 64 vs %s |%s|\n",migliaia(thesha256.size()),thesha256.c_str());
		return 2;
	}
	string theversion	="";
	string maj			="";
	string minor		="";
	string letter		="";
	
	unsigned int i=65;
	
	if (linea[i]=='*')
		i++;
	while (i<linea.size())
	{
		if ((isalnum(linea[i])) || (linea[i]=='.'))
			theversion+=linea[i++];
		else
			break;
	}
	
	string thedate=linea.substr(i+1,linea.size());

	if (flagverbose)
		myprintf("03206: Version to be decoded |%s| date |%s|\n",theversion.c_str(),thedate.c_str());
	
	if (!decode_zpaq_version(theversion,maj,minor,letter))
	{
		myprintf("03207! decode zpaq version failed!\n");
		return 2;
	}
	
	string	internal_version	=ZPAQ_VERSION;
	string  internal_date		=ZPAQ_DATE;
	string 	internal_maj		="";
	string 	internal_minor		="";
	string 	internal_letter		="";
	if (!decode_zpaq_version(internal_version,internal_maj,internal_minor,internal_letter))
	{
		myprintf("03208! decode internal zpaq version failed!\n");
		return 2;
	}
	bool flagnewer=false;

	int	imaj			=atoi(maj.c_str());
	int internal_imaj	=atoi(internal_maj.c_str());
	
	int iminor			=atoi(minor.c_str());
	int internal_iminor	=atoi(internal_minor.c_str());
	flagnewer=
	(imaj>internal_imaj)
	||
	((imaj==internal_imaj) && (iminor>internal_iminor))
	||
	((imaj==internal_imaj) && (iminor==internal_iminor) && (letter>internal_letter));
	
	
	if (flagverbose)
	{
		myprintf("03209: Current major  %4s =>  %4s\n",internal_maj.c_str(),maj.c_str());
		myprintf("03210: Current minor  %4s =>  %4s\n",internal_minor.c_str(),minor.c_str());
		myprintf("03211: Current letter %4s =>  %4s\n",internal_letter.c_str(),letter.c_str());
	}
	
#ifdef unix
	if (flagnewer)
	{	color_red();
		myprintf("03212: PLEASE UPDATE: your %s %s is OLDER of %s %s\n",internal_version.c_str(),internal_date.c_str(),theversion.c_str(),thedate.c_str());
	}
	else
	{
		color_green();
		myprintf("03213: NOTHING TO DO: your %s %s is not older of %s %s\n",internal_version.c_str(),internal_date.c_str(),theversion.c_str(),thedate.c_str());
	}
	color_restore();
	remove(verfile.c_str());
	return 0;
#else
	if ((!flagnewer) && (flagkill))
	{
		color_yellow();
		myprintf("03214: Your %s %s is not older of %s %s BUT -kill => continue anyway\n",
		internal_version.c_str(),
		internal_date.c_str(),
		theversion.c_str(),
		thedate.c_str());
		color_restore();
	}
	else
	if ((!flagnewer) && (!flagkill))
	{
		color_green();
		myprintf("03215: NOTHING TO DO: your %s %s is not older of %s %s\n",internal_version.c_str(),internal_date.c_str(),theversion.c_str(),thedate.c_str());
		color_restore();
		remove_temp_file(verfile);
		return 0;
	}
	
	franz_do_hash myself("SHA-256");
	if (flagdebug3)
		myprintf("03216: filehash on %s\n",fullzpaqexename.c_str());
	
	int64_t startmyself=mtime();
	string myownsha256=myself.filehash(0,fullzpaqexename,false,startmyself,prendidimensionefile(fullzpaqexename.c_str()));
	if (flagverbose)
		myprintf("03217: myownsha256 %s\n",myownsha256.c_str());
	
	if (stringtolower(myownsha256)==stringtolower(thesha256))
	{
		color_yellow();
		myprintf("03218: Really nothing to do because your build is == to the internet one\n");
		color_restore();
		return 0;
	}
	
	color_green();
	myprintf("03219: Candidate %s of %s vs current %s of %s",theversion.c_str(),thedate.c_str(),internal_version.c_str(),internal_date.c_str());
	color_restore();

	if (!flagforce)
	{
		color_red();
		myprintf(" Use -force to update!\n");
		color_restore();
		return 0;
	}
	myprintf("\n");
	
	string 	exeurl 	=http_exe+randnocache;
	string	exefile	=g_gettempdirectory()+"zpaqfranz_exe.exe";
	exefile			=nomefileseesistegia(exefile);

	if (flagverbose)
	{
		myprintf("03220: from     %s\n",exeurl.c_str());
		myprintf("03221: to file  %s\n",exefile.c_str());
	}
	myprintf("03222: Downloading from Internet...\n");

	int64_t startdownload=mtime();

	if (!downloadfile(exeurl,exefile,true))
		return 2;
	myprintf("\n");

	int64_t dimensionescaricata=prendidimensionefile(exefile.c_str());
	if (dimensionescaricata<=1000000)
	{
		myprintf("03223! Downloaded size small, abort (%s)\n",migliaia(dimensionescaricata));
		return 2;
	}
	myprintf("03224: Time %5.2f s, now integrity check (%s bytes)\n",(mtime()-startdownload)/1000.0,migliaia(dimensionescaricata));
	franz_do_hash dummy("SHA-256");
	if (flagdebug3)
		myprintf("03225: filehash on %s\n",exefile.c_str());

	int64_t starthash=mtime();
	string hashreloaded=dummy.filehash(0,exefile,false,starthash,dimensionescaricata);
	if (flagverbose)
	{
		myprintf("03226: hash reloaded %s\n",hashreloaded.c_str());
		myprintf("03227: expected hash %s\n",thesha256.c_str());
	}
	if (stringtolower(hashreloaded)!=stringtolower(thesha256))
	{
		myprintf("03228! Hash mismatch => error C5 => Kaputt\n");
		return 2;
	}
	
	if (hashfromp7m!=thesha256)
	{
		myprintf("0587: Hash from .p7m %s does not match expected %s\n",hashfromp7m.c_str(),thesha256.c_str());
		return 2;
	}

	myprintf("\n");
	color_green();
	myprintf("03229: OK => updating ...\n");
	color_restore();

	if (flagverbose)
	{
		myprintf("03230: zpaqfranzexename %s\n",zpaqfranzexename.c_str());
		myprintf("03231: fullzpaqexename  %s\n",fullzpaqexename.c_str());
	}
	
	string	filebatch	=g_gettempdirectory()+"updatezpaqfranz.bat";
	filebatch=nomefileseesistegia(filebatch);
	if (fileexists(filebatch))
		if (remove(filebatch.c_str())!=0)
		{
			myprintf("03232! Highlander batch  %s\n", filebatch.c_str());
			return 2;
		}
	FILE* batch=fopen(filebatch.c_str(), "wb");
	if (batch==NULL)
	{
		myprintf("03233! cannot write on %s\n",filebatch.c_str());
		return 2;
	}
	
	fullzpaqexename	=linuxtowinpath(fullzpaqexename);
	exefile			=linuxtowinpath(exefile);
	verfile			=linuxtowinpath(verfile);
	filebatch		=linuxtowinpath(filebatch);
	fprintf(batch,"@echo OFF\r\n");
	fprintf(batch,"echo Running update batch (this is good)\r\n");
    fprintf(batch,":again\r\n");
	fprintf(batch,"taskkill /F /IM %s\r\n",zpaqfranzexename.c_str());
	fprintf(batch,"del \"%s\"\r\n",fullzpaqexename.c_str());
    fprintf(batch,"if exist \"%s\" goto again\r\n",fullzpaqexename.c_str());
    fprintf(batch,"copy \"%s\" \"%s\" /y\r\n",exefile.c_str(),fullzpaqexename.c_str());
    fprintf(batch,"del \"%s\"\r\n",verfile.c_str());
    fprintf(batch,"del \"%s\"\r\n",exefile.c_str());
 	fprintf(batch,"echo Update done\r\n"); // this will not work, the calling task should be already killed
	fprintf(batch,"del \"%s\"\r\n",filebatch.c_str());
	fclose(batch);
	if (flagverbose)
		myprintf("03234: filebatch %s\n",filebatch.c_str());
	

	if (flagdebug3)
		myprintf("01373: The file batch is <<%Z>>\n",filebatch.c_str());
	else
		waitexecutepadre(filebatch,"");
#endif // corresponds to #ifdef (#ifdef unix)

#endif // corresponds to #if (#if defined(SOLARIS) || defined(__HAIKU__))
	return 0;
}


#ifdef _WIN32
int Jidac::download()
{
	myprintf("03235: Download file from Internet (something like wget)\n");
	if (files.size()!=2)
	{
		myprintf("03236! Exactly 2 file-parameters required. URL and local file\n");
		return 2;
	}
	
	string randnocache="?"+generaterandomstring(10);
#ifdef unix
	randnocache="";
#endif // corresponds to #ifdef (#ifdef unix)

	if (flagdebug)
		myprintf("03237: randnocache %s\n",randnocache.c_str());

	string	thehashtype="";
	string 	thehash="";
	
	if (flagchecktxt)
		if (checktxt!="")
		{
			if (flagverbose)
				myprintf("03238: Downloading the txt check file\n");
			string http_url=checktxt;
			if (!isurl(http_url))
			{
				myprintf("03239! http_url is not a url |%s|\n",http_url.c_str());
				return 2;
			}
			http_url+=randnocache;
			string	verfile	=g_gettempdirectory()+"zpaqfranz_verfile.txt";
			verfile			=nomefileseesistegia(verfile);
			if (!downloadfile(http_url,verfile,false))
				return 2;
			myprintf("\n");
			if (flagverbose)
				myprintf("03240: Loading hash data...\n");
			
			vector<string> versioni;
			readfiletoarray(verfile,versioni);
			if (versioni.size()==0)
			{
				myprintf("03241! version file with 0 lines\n");
				return 2;
			}
			string linea;
	
			if (versioni.size()!=1)
			{
				myprintf("03242! version file should have 1 line instead of %s\n",migliaia(versioni.size()));
				return 2;
			}
			linea=versioni[0];
			if (flagverbose)
				myprintf("03243: Line %s |%s|\n",migliaia(linea.size()),linea.c_str());

			thehash=getfirsthash(linea);
			
			if (thehash.size()==32)
				thehashtype="MD5";
			if (thehash.size()==40)
				thehashtype="SHA-1";
			if (thehash.size()==64)
				thehashtype="SHA-256";
			
			if (thehashtype=="")
			{
				myprintf("03244! Cannot recognize hash type len (%d). 32=MD5; 40=SHA1; 64=SHA-256\n",thehash.size());
				return 2;
			}
			if (flagverbose)
				myprintf("03245: Hash type |%s| %s |%s|\n",thehashtype.c_str(),migliaia(thehash.size()),thehash.c_str());

			if (!flagforce)
			{
				if (flagverbose)
					myprintf("03246: Deleting verfile (skip with -force)\n");
				remove(verfile.c_str());
			}
		}
		
	string http_url=files[0];
	if (!isurl(http_url))
	{
		myprintf("03247! http_url is not a url |%s|\n",http_url.c_str());
		return 2;
	}
	http_url+=randnocache;
	string output_file=files[1];
	if (!flagforce)
		output_file=nomefileseesistegia(output_file);
	
	if (!flagspace)
		if (!saggiascrivibilitacartella(output_file))
		{
			myprintf("03248! Cannot write on %s (maybe lack of ./? bypass with -space)\n");
			return 2;
		}
	int64_t startdownload=mtime();
	if (!downloadfile(http_url,output_file,true))
	{
		myprintf("\n");
		myprintf("03249! Something wrong on downloadfile()\n");
		return 2;
	}
	myprintf("\n");
	myprintf("03250: Downloaded filesize %s in %5.2f s\n",migliaia(prendidimensionefile(output_file.c_str())),(mtime()-startdownload)/1000.0);
	myprintf("03251: Output file <<%Z>>\n",output_file.c_str());
	if (thehashtype!="")
	{
		franz_do_hash dummy(thehashtype);
		if (flagdebug3)
			myprintf("03252: hashing on %s\n",output_file.c_str());

		int64_t starthash=mtime();
		string hashreloaded=dummy.filehash(0,output_file,false,starthash,prendidimensionefile(output_file.c_str()));
		myprintf("\n");
		if (flagverbose)
		{
			myprintf("03253: hash reloaded %s\n",hashreloaded.c_str());
			myprintf("03254: expected hash %s\n",thehash.c_str());
		}
		if (stringtolower(hashreloaded)!=stringtolower(thehash))
		{
			color_red();
			myprintf("03255! GURU => downloaded hash does not match!\n");
			myprintf("03256: hash type     %s\n",thehashtype.c_str());
			myprintf("03257: hash expected %s\n",thehash.c_str());
			myprintf("03258: hash founded  %s\n",hashreloaded.c_str());
			
			color_restore();
			if (!flagforce)
			{
				myprintf("03259: Deleting corrupted file (skip with -force)\n");
				remove(output_file.c_str());
			}
			return 2;
		}
		color_green();
		myprintf("03260: Expected hash OK (this is very good)\n");
		color_restore();
	}
	return 0;

}

#endif // corresponds to #ifdef (#ifdef _WIN32)
#endif ///NOSFTPEND

int Jidac::crop()
{
	if (iswildcards(archive))
	{
		myprintf("03261! Cannot work on multipart archive\n");
		return 2;
	}
	if ((flagkill) && (!flagforce))
		if (tofiles.size()!=1)
		{
			myprintf("03262! Need a -to for the output\n");
			return 2;
		}
	
	vector<uint64_t> version_position;
	version_position.push_back(0);
	all					=8;
	int64_t wheretotrim	=0;
	int errors			=0;
	int64_t csize=read_archive(NULL,archive.c_str(),&errors,1);

	vector<DTMap::iterator> filelist;
	for (DTMap::iterator a=dt.begin(); a!=dt.end(); ++a)
		if (a->second.data!='-' && (a->second.date))
		{
			a->second.data='-';
			filelist.push_back(a);
		}
	myprintf("03263: ---------------------------------------------------------------------------\n");
	myprintf("03264: <  Ver  > <  date  > < time > <    version size    > < Offset (w/out encr)>\n");
	int maxversion=0;
	for (unsigned fi=0;fi<filelist.size() /*&& (true || int(fi)<summary)*/; ++fi)
	{
		DTMap::iterator p=filelist[fi];
		unsigned v;
		if (p->first.size()==all+1u && (v=atoi(p->first.c_str()))>0 && v<ver.size())
		{
			maxversion++;
			wheretotrim=(int64_t)(version_position.back()+(v+1<ver.size() ? ver[v+1].offset : csize)-ver[v].offset+0.0);
			version_position.push_back(wheretotrim);
			myprintf("03265: V%08u %s [%20s] @ %20s\n",v,dateToString(flagutc,p->second.date).c_str(),
					migliaia((int64_t)((v+1<ver.size() ? ver[v+1].offset : csize)-ver[v].offset+0.0)),migliaia2(wheretotrim));
		}
	}
	int iuntil=0;
	
	if (g_until!="")
		iuntil=myatoll(g_until.c_str());

	if (iuntil>maxversion)
	{
		myprintf("03266! -until %s too big (> maxversion %s) => exit\n",migliaia(iuntil),migliaia2(maxversion));
		return 2;
	}
	if (!flagkill)
	{
		myprintf("03267: no -kill, this is just a dry run\n");
		return 0;
	}
	int64_t archivesize=prendidimensionefile(archive.c_str());
	if (maxsize>0)
		wheretotrim=maxsize;
	
	if (wheretotrim==0)
	{
		myprintf("03268! Guru, wheretotrim == 0\n");
		return 2;
	}
	if (g_password!=NULL)
	{
		wheretotrim+=32;
		myprintf("03269: Due to encrypted archive done a +32 bytes\n");
	}
	if (wheretotrim>archivesize)
	{
		myprintf("03270! wheretotrim %s > archivesize %s\n",migliaia(wheretotrim),migliaia2(archivesize));
		return 2;
	}
	
	if (flagforce)
	{
		if (!getcaptcha("cropplease","Crop in place without backup"))
				return 1;
		if (truncate(archive.c_str(),wheretotrim))
		{
			myprintf("03271! something wrong truncating!\n");
			return 2;
		}
		else
			myprintf("03272: in-place crop done\n");
		return 0;
	}
	
	string	trimmeddestination=tofiles[0];
	if (isdirectory(trimmeddestination))
	{
		myprintf("03273! error -to is a folder, must be a file\n");
		return 2;
	}
	if (!iszpaq(trimmeddestination))
		trimmeddestination+=".zpaq";
	if (!flagspace)
		if (!saggiascrivibilitacartella(trimmeddestination))
		{
			myprintf("03274! sorry -to folder seems not writeable. Use -space to bypass\n");
			return 2;
		}
	int64_t spaziolibero=getfreespace(trimmeddestination);
	if (!flagspace)
		if (spaziolibero<archivesize)
		{	
			printbar('*');
			myprintf("03275! WARNING FREE SPACE SEEMS %s NEEDED %s -space to bypass\n",migliaia(spaziolibero),migliaia2(archivesize));
			printbar('*');
			return 2;
		}
	myprintf("03276: Writing data...\n");
	string risultato=filecopy(true,false,archive,trimmeddestination,flagverify,true,false,wheretotrim); 
	if (risultato=="")
	{
		myprintf("03277! ERROR making copy %s\n",risultato.c_str());
		return 2;
	}
	int64_t nuovadim=prendidimensionefile(risultato.c_str());
	if (nuovadim==wheretotrim)
	{
		myprintf("03278: DONE on %Z (%s)\n",risultato.c_str(),migliaia(nuovadim));
	}
	else
	{
		myprintf("03280! Something goest wrong C5\n");
		return 2;
	}
	return 0;
}

int Jidac::hasha()
{
	if (flagfranzhash)
	{
		if (files.size()!=1)
		{
			myprintf("82165: -franzhash works with EXACTLY 1 file. Use -tX for X threads\n");
			return 2;
		}
		if (!fileexists(files[0].c_str()))
		{
			myprintf("82170: Cannot find <<%Z>>\n",files[0].c_str());
			return 2;
		}
		int mythread=howmanythreads;
		if (mythread<1)
			mythread=1;
		
		std::string straight_hash		= calcolafranzhash(g_thechosenhash_str.c_str(),files[0],mythread,flagfrugal);
		std::string franz_hash_coded 	= codifica_franzhash(straight_hash);
		std::string franz_decoded		= decodifica_franzhash(franz_hash_coded.c_str());
	
		myprintf("\n");
		if (flagverbose)
			myprintf("82178: Straight     %s\n",straight_hash.c_str());
			
		myprintf("82189: %s\n",franz_hash_coded.c_str());
		if (straight_hash!=franz_decoded)
		{
			color_red();
			myprintf("82189: Decoded      %s\n",franz_decoded.c_str());
			myprintf("82814: Encode-decode NOT GOOD!\n");
			color_restore();
			return 2;
		}
		return 0;
	}
	if (flagpakka)
		flagstdout=true;
	if (flagstdout)
		flagnoeta=true;
	if ((!flagpakka) && (!flagstdout) && (!flagterse))
	{
		myprintf("03281: Hashing %s",g_thechosenhash_str.c_str());
		if (flagmm)
			myprintf(" WITH MEMORY MAPPED FILES ");
		if (!flagforcezfs)
			myprintf(" ignoring .zfs and :$DATA\n");
	}

	int quantifiles					=0;
	int64_t total_size				=0;
	uint64_t scannedsize			=0;
	vector<string> myfiles;
	flagskipzfs					=true;  // strip down zfs
	int64_t startscan=mtime();
	g_bytescanned=0;
	g_filescanned=0;
	g_dimensione=0;
	g_worked=0;
	vector<string> mydirs;

	exclude_output();
	for (unsigned i=0; i<files.size(); ++i)
	{
		string thepath=fix_scandir(files[i]);
		scandir(true,edt,thepath,!flagnorecursion);
	}
	eol();
	for (DTMap::iterator p=edt.begin(); p!=edt.end(); ++p)
		if (p->second.date && p->first!="" && (!isdirectory(p->first)) && (!isads(p->first)) )
		{
			if (minsize>0)
			{
				if ((uint64_t)p->second.size>minsize)
				{
					myfiles.push_back(p->first);
					total_size+=p->second.size;
					quantifiles++;
				}
			}
			else
			{
				myfiles.push_back(p->first);
				total_size+=p->second.size;
				quantifiles++;
			}
		}
	scannedsize=total_size;

	if (myfiles.size()==0)
	{
		myprintf("03282: Nothing to do\n");
		return 0;
	}
	
	if (flaglast)
	{
		if (!myfiles.empty()) 
		{
			if (flagdebug)
				myprintf("71008: getting only -last\n");
			
			std::string last = myfiles.back(); // Save the last element
			myfiles.clear();                   // Empty the vector
			myfiles.push_back(last);          // Add the last element
		}
	}
	
	vector<string> myhash;
	vector<tparametrihash> 	vettoreparametrihash;
	vector<s_stringpair> vec;
	int mythreads=howmanythreads;
	if (!flagssd)
		mythreads=1;
	double scantime;
	
	if (mythreads==1)
	{
		flagnosort=true;
		if ((!flagstdout) && (!flagterse))
			printbar(' ');
		int64_t inizio		=mtime();
		scantime=(inizio-startscan)/1000.0;
		if (flagverbose)
		{
			myprintf("03283: No multithread: Found (%s) => %s bytes (%s) / %s files in %f\n",tohuman2(scannedsize),migliaia(total_size),tohuman(total_size),migliaia2(quantifiles),scantime);
			myprintf("03284: Total files %s\n",migliaia(myfiles.size()));
		}
		g_dimensione=0;

		for (unsigned int i=0;i<myfiles.size();i++)
		{
			if (flagdebug3)
				myprintf("03285: franz_do_hash\n");

			franz_do_hash dummy(g_thechosenhash);
			if (flagdebug3)
				myprintf("03286: filehash on %s\n",myfiles[i].c_str());
			string risu=dummy.filehash(0,myfiles[i],false,inizio,total_size);
			int printlen=0;
			if (flagstdout)
				myprintf("%s ",stringtolower(risu).c_str());
			else
				myprintf("03287: %s ",stringtolower(risu).c_str());
			printlen=risu.size()+2;
			printUTF8(myfiles[i].c_str());
			printlen+=myfiles[i].size();
			if (printlen<68)
			{
				string temp;
				while (printlen++<68)
					temp+=" ";
				myprintf("%s",temp.c_str());
			}
			myprintf("\n");
		}
		return 0;
	}
	
	
	/// multithread
	
	flagnosort=false;
	tparametrihash 	myblock;
	for (int i=0;i<mythreads;i++)
	{
		myblock.tnumber=(i%mythreads);
		myblock.inizio=mtime();
		myblock.dimensione=total_size;
		myblock.timestart=0;
		myblock.timeend=0;
		vettoreparametrihash.push_back(myblock);
	}
	if ((!flagstdout) && (!flagterse))
	printbar(' ');
	int64_t inizio		=mtime();
	scantime=(inizio-startscan)/1000.0;
	if (flagverbose)
		myprintf("03288: Found (%s) => %s bytes (%s) / %s files in %f\n",tohuman2(scannedsize),migliaia(total_size),tohuman(total_size),migliaia2(quantifiles),scantime);
	for (unsigned int i=0;i<myfiles.size();i++)
	{
		vettoreparametrihash[i%mythreads].filestobehashed.push_back(myfiles[i]);
		vettoreparametrihash[i%mythreads].algo.				push_back(g_thechosenhash_str.c_str());
	}
	int totfile=0;
	for (int i=0;i<mythreads;i++)
	{
		if (flagdebug3)
			myprintf("03289: Thread [%02d] files %s\n",(int)i,migliaia(vettoreparametrihash[i].filestobehashed.size()));
		totfile+=+vettoreparametrihash[i].filestobehashed.size();
	}
	if (flagverbose)
		myprintf("03290: Total files %s -> in threads %s\n",migliaia(myfiles.size()),migliaia2(totfile));
	int rc;
	///pthread_t threads[mythreads];
	pthread_t* threads = new pthread_t[mythreads];
	g_allocatedram+=sizeof(pthread_t)*mythreads;
		
	pthread_attr_t attr;
	void *status;
		// ini and set thread joinable
	pthread_attr_init(&attr);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_JOINABLE);
	if (flagverbose)
	{
		myprintf("\n");
		myprintf("03291: Creating %d hashing thread(s) with %s\n",mythreads,g_thechosenhash_str.c_str());
	}
	for(int i = 0; i < mythreads; i++ )
	{
		vettoreparametrihash[i].timestart=mtime();
		rc = pthread_create(&threads[i], &attr, scansionahash, (void*)&vettoreparametrihash[i]);
		if (rc)
		{
			myprintf("03292! Error creating thread\n");
			exit(-1);
		}
	}
	pthread_attr_destroy(&attr);

	for(int i = 0; i <mythreads; i++ )
	{
		rc = pthread_join(threads[i], &status);
		if (rc)
		{
			error("Unable to join\n");
			exit(-1);
		}
	}
	delete [] threads;
	for(int i = 0; i <mythreads; i++ )
		for (unsigned int j=0;j<vettoreparametrihash[i].filestobehashed.size();j++)
		{
			s_stringpair mypair;
			mypair.first=vettoreparametrihash[i].filestobehashed[j];
			mypair.second=vettoreparametrihash[i].o_hashcalculated[j];
			vec.push_back(mypair);
		}
	std::sort(vec.begin(), vec.end(),stringpairsortbyfirst);
	int	errori				=0;
	for (unsigned int i=0;i<vec.size();i++)
	{
		myprintf("%s ",stringtolower(vec[i].second).c_str());
		printUTF8(vec[i].first.c_str());
		myprintf("\n");
	}

	return errori;
}



int Jidac::homesize()
{
	myprintf("03293: homesize\n");
	if (files.size()!=1)
	{
		myprintf("03294! Just 1 home folder required => quit (ex. /home)\n");
		return 2;
	}

	string	basehome=files[0];
	if (!isdirectory(basehome))
		basehome+="/";
	vector<string> candidate;
	listfolders(basehome,&candidate);
	if (flagdebug)
		myprintf("03295: candidate %s with pattern %s\n",migliaia(candidate.size()),fullarchive.c_str());
	
	if (candidate.size()==0)
	{
		myprintf("03296: Sorry, cannot find something in <<%Z>>\n",basehome.c_str());
	}

	files.clear();


	///string basearchive=archive;
	for (unsigned int i=0;i<candidate.size();i++)
	{
		string sourcepath=basehome+candidate[i];
		if (!isdirectory(sourcepath))
			sourcepath+="/";
		if (flagdebug3)
		{
			myprintf("03298: >> from folder <<%Z>>\n",sourcepath.c_str());
		}
		files.push_back(sourcepath);
	}
	myprintf("03300: Scanning %s subfolders...\n",migliaia(candidate.size()));
	sort(files.begin(),files.end());
	
	if (!flagverbose)
		flagnoeta=true;
	franzparallelscandir(false,true,false);
	int64_t totalsize	=0;
	int		totalcount	=0;
	printbar('-');
	for (unsigned int i=0;i<files_size.size();i++)
	{
		myprintf("03301: %21s %12s   %08d %s\n",migliaia(files_size[i]),tohuman(files_size[i]),files_edt[i].size(),files[i].c_str());
		totalsize+=files_size[i];
		totalcount+=files_edt[i].size();
	}
	printbar('-');
	myprintf("03302: %21s %12s   %08d\n",migliaia(totalsize),tohuman(totalsize),totalcount);
	return 0;
}

bool isnotevil(int i_char)
{
	return (isdigit(i_char)) || (isalpha(i_char)) || (i_char=='_') || (i_char=='-') || (i_char=='.') || (i_char=='(') || (i_char==')') || (i_char==' ') || (i_char=='*') || (i_char==10) || (i_char==13)|| (i_char==':') || (i_char==',') || (i_char=='/');
}

bool Jidac::sanitizeline(string i_filename)
{
	if ((i_filename.size()<=83) || (i_filename.size()>87))
	{
		myprintf("03303: GURU file size must be [83..87] (founded %s)\n",migliaia(i_filename.size()));
		seppuku();
		return false;
	}
	for (unsigned int i=0;i<64;i++)
	{
		int thechar=i_filename[i];
		if (thechar<0)
		{
			myprintf("03304! GURU unexpected end of file at %d\n",i);
			seppuku();
		}
		if (thechar==EOF)
		{
			myprintf("03305! GURU unexpected end of file at %d\n",i);
			seppuku();
		}
		
		if (!ishex(thechar))
		{
			myprintf("03306! GURU not HEX char at %d\n",i);
			seppuku();
		}
	}
	if (i_filename[64]!=32)
	{
		myprintf("03307! GURU not space after hash!\n");
		seppuku();
	}
	if (i_filename[65]!=42)
	{
		myprintf("03308! GURU not asterisk after space!\n");
		seppuku();
	}
	int verchar;
	for (unsigned int i=66;i<i_filename.size();i++)
	{
		verchar=i_filename[i];
		if (verchar==EOF)
			break;
		if (verchar==10)
			break;
		if (verchar==13)
			break;
		if (!isnotevil(verchar))
		{
			myprintf("03309! GURU unallowed char founded at %d value %d\n",i,verchar);
			seppuku();
		}
	} 
	return true;
}

bool Jidac::sanitizefile(string i_filename)
{
	if (i_filename=="")
	{
		myprintf("03310! sanitize filename empty\n");
		seppuku();
		return false;
	}
	
	int dimensione=prendidimensionefile(i_filename.c_str());
#ifdef unix
	if (dimensione>600)
#else
	if (dimensione>100)
#endif // corresponds to #ifdef (#ifdef unix)
	{
		myprintf("03311! GURU file too big %s\n",migliaia(dimensione));
		seppuku();
		return false;
	}
	
	FILE* myfile = freadopen(i_filename.c_str());
	if (myfile==NULL)
	{
		myprintf("03312! GURU cannot fdreadopen %s\n",i_filename.c_str());
		seppuku();
	}
/*
    We really restrict file size, and we do not want buffer underrun
    
	*nix
	For compatibility reasons (e.g., ESXi, NAS) not 100% hardened 
	I used a “low-level” GET, generating a response file like this

HTTP/1.1 200 OK
date: Fri, 17 May 2024 09:16:40 GMT
content-length: 85
server: Apache
last-modified: Fri, 17 May 2024 08:01:52 GMT
accept-ranges: bytes
x-iplb-request-id: 05C44D80:D712_5E174003:0050_66472078_71CB6:1523
x-iplb-instance: 51915
connection: close

f5bd0843bcfbc7eda8c8a8bf5698dfd35bf79d140d5169ba7b7d8a705f3cb253 *59.6b_(2024-05-17)


    Windows
	Already "clear"
	
5ac9054c08c2f1890502f78c98cf7b88d8d007cddf101ca0e1446fea923de7f5 *59.5g_(2024-05-14)
*/
	int verchar;
#ifdef unix
	for (unsigned int i=0;i<600;i++)
#else
	for (unsigned int i=0;i<100;i++)
#endif // corresponds to #ifdef (#ifdef unix)
	{
		verchar=fgetc(myfile);
		if (verchar==EOF)
			break;
		if (!isnotevil(verchar))
		{
			myprintf("03313! GURU unallowed char founded at %d value %d\n",i,verchar);
			seppuku();
			return false;
		}
	}
		
	fclose(myfile);
	return true;
}


#ifdef ZPAQFULL ///NOSFTPSTART
#ifdef _WIN32
void Jidac::runhigh(string i_addendum)
{
	if (fullcommandline=="")
	{
		myprintf("03314! fullcommand line empty\n");
		return;
	}
	string myexename=fullzpaqexename;
///	get the "right" path is not easy, registry digging needed.
///	too "complex", try to run
	string runme=windowspowerme();
	if (!fileexists(runme))
	{
		myprintf("03315! Sorry, cannot find runme %s\n",runme.c_str());
		return;
	}
	fullcommandline+=i_addendum;
	string parms="-Command \"Start-Process '"+myexename+"' '"+fullcommandline+"' -Wait -Verb runAs\"";
	if (flagdebug2)
	{
		myprintf("03316: runme %s\n",runme.c_str());
		myprintf("03317: parms %s\n",parms.c_str());
	}
	waitexecute(runme,parms,SW_HIDE);
}
#endif // corresponds to #ifdef (#ifdef _WIN32)
#endif ///NOSFTPEND

void Jidac::list_datetime(const int64_t i_seconddate,const bool i_flagnewversion)
{
	if (i_seconddate==0)
	{
		color_yellow();
		///myprintf("deleted /   internal");
		   myprintf("deleted/inacessible");
		color_restore();
		return;
	}
	if (i_flagnewversion)
	{
		color_blackongreen();
		myprintf("%s", dateToString_forcedlocal(flagutc,i_seconddate).c_str());
//		myprintf("%s (%s)", dateToString_forcedlocal(flagutc,i_seconddate).c_str(),migliaia(i_seconddate));
	}
	else
	{
		myprintf("%s", dateToString(flagutc,i_seconddate).c_str());
	}

}
void Jidac::list_filesize(const bool i_isdir,const int64_t i_filesize,int i_thesizesize)
{
	if (g_csvstring!="")
	{
		myprintf("%s",migliaia(i_filesize));
		return;
	}
	if (i_thesizesize==0)
		i_thesizesize=19;
	char lineatemp[200];
	if (i_isdir)
		snprintf(lineatemp,sizeof(lineatemp),"[%*s", i_thesizesize,migliaia(i_filesize));
	else
		snprintf(lineatemp,sizeof(lineatemp)," %*s", i_thesizesize,migliaia(i_filesize));
			
	myprintf(lineatemp);
}
void Jidac::list_compressedfilesize(const int64_t i_compressedfilesize,const int64_t i_filesize,const bool i_flagnewversion,const bool i_isfolder,const bool i_isdeleted)
{
	
	if (i_flagnewversion)
	{
		color_blackongreen();
		if (g_csvstring!="")
		myprintf("Ver");
		else
		myprintf("  Ver");
		return;
	}
	if (i_isdeleted)
	{
		color_yellow();
		if (g_csvstring!="")
		myprintf("del");
		else
		myprintf("  del");
		color_restore();
		return;
	}
	if (i_isfolder)
	{
		color_green();
		if (g_csvstring!="")
		myprintf("dir");
		else
		myprintf("  dir");
		color_restore();
		return;
	}
	
	double ratio=0;
	if (i_filesize!=0)
		ratio=100.0*(double)i_compressedfilesize/(double)i_filesize;
	if (ratio>999)
	{
		color_red();
		myprintf(">999%%");
	}
	else
	if (ratio>100.0)
	{
		color_yellow();
		if (g_csvstring!="")
		myprintf("%.0f%%", (double)ratio);
		else
		myprintf("%4.0f%%", (double)ratio);
	}
	else
	{
		color_green();
		if (g_csvstring!="")
		myprintf("%.0f%%", (double)ratio);
		else
		myprintf("%4.0f%%", (double)ratio);
	}
	///myprintf("(%10s) ", tohuman(i_compressedfilesize));
	color_restore();
}

/*
void Jidac::list_seconddata(const char i_car)
{
	myprintf("%c ",char(i_car));
}
*/
void Jidac::list_creationdate(int64_t i_mycreationtime)
{
	myprintf(" %s ", dateToString(flagutc,i_mycreationtime).c_str());
}
void Jidac::list_attributes(int64_t i_attributes)
{
	string temp=attrToString(i_attributes);
#ifdef _WIN32
	myreplaceall(temp," ",".");
#endif // corresponds to #ifdef (#ifdef _WIN32)
	if (g_csvstring!="")
		myreplaceall(temp," ","");
		
	myprintf("%s", temp.c_str());
}


int64_t Jidac::datacreazione(const string i_file)
{
	if (i_file=="")
		return 0;
#ifndef ANCIENT

#if defined(__APPLE__) && defined(__MACH__)
   struct stat file_stat;
    if (stat(i_file.c_str(),&file_stat)==-1) 
	{
        myprintf("03329! stat KAPUTT (Mac)\n");
        return 0;
    }

    struct tm *t;
	if (file_stat.st_birthtimespec.tv_sec!=0) 
	{
        t=localtime(&file_stat.st_birthtimespec.tv_sec);
 		if (t==NULL)
			return 0;
		return	(t->tm_year+1900)	*10000000000LL
			+	(t->tm_mon+1)		*100000000LL
			+	t->tm_mday			*1000000
			+	t->tm_hour			*10000
			+	t->tm_min			*100
			+	t->tm_sec;
    } 
	else 
	    myprintf("03330! MAC cannot get creation (birth) time\n");
	return 0;
#endif // corresponds to #if (#if defined(__APPLE__) && defined(__MACH__))

#ifdef BSD  // BSD
#ifndef __APPLE__   	// Mac is different (of course)
#ifndef __OpenBSD__
#ifndef  __DragonFly__
	struct stat file_stat;
	if (stat(i_file.c_str(), &file_stat) == -1) 
	{
       myprintf("03331! stat KAPUTT (BSD)\n");
       return 0;
	}
   
	if (file_stat.st_birthtime != 0) 
	{
       struct tm *t = gmtime(&file_stat.st_birthtime); // Changed to gmtime for UTC
       if (t == NULL)
           return 0;
           
       return (t->tm_year+1900) *10000000000LL
            + (t->tm_mon+1)     *100000000LL
            + t->tm_mday        *1000000
            + t->tm_hour        *10000
            + t->tm_min         *100
            + t->tm_sec;
	} 
   myprintf("03332! BSD cannot get creation (birth) time\n");
   return 0;
#endif // corresponds to #ifndef (#ifndef  __DragonFly__)
#endif // corresponds to #ifndef (#ifndef __OpenBSD__)
#endif // corresponds to #ifndef (#ifndef __APPLE__   	// Mac is different (of course))
#endif // corresponds to #ifdef (#ifdef BSD  // BSD)
#ifdef __linux__
	///myprintf("03333: Getting birth linux %s\n", i_file.c_str());
   struct statx statx_buf;
   
   if (statx(AT_FDCWD, i_file.c_str(), AT_STATX_SYNC_AS_STAT, STATX_BTIME, &statx_buf) == -1) {
       myprintf("03334! statx KAPUTT (Linux)\n");
       return 0;
   }

   if (statx_buf.stx_mask & STATX_BTIME) {
       tzset();
       time_t btime_sec = (time_t)statx_buf.stx_btime.tv_sec;
       
       ///myprintf("Raw timestamp: %ld\n", btime_sec);
       ///struct tm *t = localtime(&btime_sec);
	   
	   struct tm *t =  gmtime(&btime_sec);
	   
       
       if (t == NULL) {
           myprintf("03336! localtime failed\n");
           return 0;
       }

       ///myprintf("Local time: year=%d month=%d day=%d hour=%d\n",
         ///      t->tm_year+1900, t->tm_mon+1, t->tm_mday, t->tm_hour);
		int64_t risultato=(t->tm_year+1900) *10000000000LL
            + (t->tm_mon+1)     *100000000LL
            + t->tm_mday        *1000000
            + t->tm_hour        *10000
            + t->tm_min         *100
            + t->tm_sec;
			///myprintf("03724: risultato %s\n",migliaia(risultato));
			return risultato;
   }

   myprintf("03335! cannot get birth time (linux)\n");
   return 0;
   #endif // corresponds to #ifdef (#ifdef __linux__)

#endif // ANCIENT // corresponds to #ifndef (#ifndef ANCIENT)
	myprintf("03336! for some reason cannot get birth time\n");
	return 0;
}


void Jidac::rename_a_dtmap(DTMap& i_source)
{
	DTMap map_fixed;
	for (DTMap::iterator p=i_source.begin(); p!=i_source.end();++p)
	{
		string newkey=rename(p->first);
        map_fixed[newkey]=p->second;
	}
	i_source=map_fixed;
}	

bool match_pattern(const std::string& str, const std::string& pattern) {
    size_t i = 0, j = 0;

    while (i < str.size() && j < pattern.size()) {
        if (pattern[j] == '*') {
            // Skip '*' and try to match the rest of the string
            while (j + 1 < pattern.size() && pattern[j + 1] == '*') {
                j++; // Skip any multiple *
            }
            if (j + 1 == pattern.size()) {
                return true; // '*' alla fine matcha tutto il resto
            }
            while (i < str.size()) {
                if (match_pattern(str.substr(i), pattern.substr(j + 1))) {
                    return true;
                }
                i++;
            }
            return false;
        } else if (pattern[j] == '?' || str[i] == pattern[j]) {
            i++;
            j++;
        } else {
            return false;
        }
    }

    // Check if we have consumed both strings
    while (j < pattern.size() && pattern[j] == '*') {
        j++; // Skip any trailing *
    }
    return i == str.size() && j == pattern.size();
}

std::string pad_left(const std::string& input, size_t target_length) 
{
    if (input.length() >= target_length) 
	    return input;
    return std::string(target_length - input.length(), ' ') + input;
}


// More compact alternative version using counters
int Jidac::comparefilelists(const std::vector<DTMap::iterator>& externalfilelist,
                                 const std::vector<DTMap::iterator>& internalfilelist,
								 DTMap&			thedt) 
{
	myprintf("VERBOSE: INTERNAL-EXTERNAL SYNC\n");
    
    size_t 	extIndex 				=0;
    size_t 	intIndex 				=0;
    int64_t tobetested				=0;
	int 	filedahashare			=0;
	
	int		filelocalinontrovati	=0;
	
	int		internalfilecount		=0;
	int		externalfilecount		=0;
	int		internalfoldercount		=0;
	int		externalfoldercount		=0;
	
	for (unsigned int i=0;i<internalfilelist.size();i++)
		if (internalfilelist[i]->first.size()>255)
		{
			if (isdirectory(internalfilelist[i]->first))
				internalfoldercount++;
			else
				internalfilecount++;
		}

	for (unsigned int i=0;i<externalfilelist.size();i++)
		if (externalfilelist[i]->first.size()>255)
		{
			if (isdirectory(externalfilelist[i]->first))
				externalfoldercount++;
			else
				externalfilecount++;
		}
	
	std::string onlyonehash;
	
	std::map<std::string, std::vector<std::string> > hasherini;
	vector<string> filecorrotti;
	vector<string> soloesterni;
	vector<string> solointerni;
	
	uint64_t internisize 			=0;
    uint64_t esternisize 			=0; 
	uint64_t corrottisize 			=0;
   
    while ((extIndex < externalfilelist.size()) || (intIndex < internalfilelist.size())) 
	{
        
        if (intIndex >= internalfilelist.size()) 
		{
            // Only in EXTERNAL
			soloesterni.push_back(externalfilelist[extIndex]->first);
            esternisize+=externalfilelist[extIndex]->second.size;
            extIndex++;
        }
        else if (extIndex >= externalfilelist.size()) 
		{
            // Only in INTERNAL
        	solointerni.push_back(internalfilelist[intIndex]->first);
			internisize+=internalfilelist[intIndex]->second.size;
            intIndex++;
        }
        else 
		{
            const std::string& extFile = externalfilelist[extIndex]->first;
            const std::string& intFile = internalfilelist[intIndex]->first;
            
            if (extFile < intFile) 
			{
				soloesterni.push_back(externalfilelist[extIndex]->first);
				esternisize+=externalfilelist[extIndex]->second.size;
                extIndex++;
            }
            else if (intFile < extFile) 
			{
                solointerni.push_back(internalfilelist[intIndex]->first);
				internisize+=internalfilelist[intIndex]->second.size;
                intIndex++;
            }
            else 
			{
                extIndex++;
                intIndex++;
				
			//	DTMap::iterator p=externalfilelist[extIndex];
				if (!isdirectory(extFile))
				{
					DTMap::iterator a=thedt.find(extFile);
					if (a!=thedt.end()) 
					{
						int64_t dimensionefileesterno=prendidimensionefile(extFile.c_str());
						
					///	myprintf("FILE TEMP %21s %s\n",migliaia(dimensionefileesterno),extFile.c_str());
						
						///myprintf("a secondi size %d %d\n",a->second.size,dimensionefileesterno);
						if (a->second.size!=dimensionefileesterno)
						{
							if (flagdebug3)
								myprintf("80790: != size internal %21K external %21K\n",a->second.size,dimensionefileesterno);
							
							string temp=pad_left(migliaia(myabs(a->second.size,dimensionefileesterno)),21);

							filecorrotti.push_back("SIZE "+temp+" <<"+a->first+">>");
							corrottisize+=myabs(a->second.size,dimensionefileesterno);
						}
						else
						{
							if (!flagquick)
							{
								string 	myhashtype		="";
								string 	myhash			="";
								string 	mycrc32			="";
								int64_t mycreationtime	=0;
								int64_t myaccesstime	=0;
								bool	myisordered		=false;
								int		myversion		=0;
								franz_posix* myposix	=NULL;
								bool	myisadded		=false;
						
								string 	hashfromfile="";
						
								decode_franz_block(false,a->second.franz_block,
								myhashtype,
								myhash,
								mycrc32,
								mycreationtime,
								myaccesstime,
								myisordered,
								myversion,
								myposix,myisadded);
								tobetested+=a->second.size;
								
								if (myhashtype!="")
								{
									hasherini[myhashtype].push_back(a->first);
									filedahashare++;
								}
							}
						}
					}
				}
            }
        }
    }
    
    myprintf("\n");
	
	if (flagverbose)
		myprintf("\n");
	std::map<std::string, std::vector<std::string> >::iterator it;
	for (it = hasherini.begin(); it != hasherini.end(); ++it) 
	{
		std::string chiave = it->first;
		std::vector<std::string>& valori = it->second;

		if (flagverbose)
			myprintf("80875: HashType: %12s Elements %12s\n",chiave.c_str(),migliaia(valori.size()));
		
		
		vector<std::pair<string,string> > hash_pair;
		int64_t starttriple=mtime();
		franzparallelhashfiles(chiave,tobetested,valori,false,hash_pair);
		if (flagverbose)
			myprintf("01434: Hashing time %14.2fs\n",(mtime()-starttriple)/1000.0);

		for (unsigned int j=0;j<hash_pair.size();j++)
		{
			string thefilename=hash_pair[j].second;
			DTMap::iterator p=thedt.find(thefilename);
			if (p==thedt.end())
			{
				myprintf("01437: GURU cannot find thefilename in hash_pair <<%Z>>\n",thefilename.c_str());
				filelocalinontrovati++;
			}
			else
			{
				string 	myhashtype		="";
				string 	myhash			="";
				string 	mycrc32			="";
				int64_t mycreationtime	=0;
				int64_t myaccesstime	=0;
				bool	myisordered		=false;
				int		myversion		=0;
				franz_posix* myposix	=NULL;
				bool	myisadded		=false;
		
				string 	hashfromfile="";
		
				decode_franz_block(false,p->second.franz_block,
				myhashtype,
				myhash,
				mycrc32,
				mycreationtime,
				myaccesstime,
				myisordered,
				myversion,
				myposix,myisadded);
			
			///	myprintf("Eurekona thefilename %s   edt %s %d\n",thefilename.c_str(),myhash.c_str(),p->second.size);
				if (myhash!=hash_pair[j].first)
				{
					
					string temp=pad_left(migliaia(p->second.size),21);
					
					filecorrotti.push_back("HASH "+temp+" <<"+thefilename+">>");
					corrottisize+=p->second.size;
				}
			}
			
		}
    }
	eol();
	if (soloesterni.size()>0)
	{
		color_yellow();
		myprintf("80829: Only EXT %08d (%K %H) - files on the filesystem but NOT in .zpaq\n",soloesterni.size(),esternisize,esternisize);
	}
	else
	{
		color_green();
		myprintf("80831: There are no external files on the filesystem in excess\n");
	}
	color_restore();
	if (!soloesterni.empty()) 
	{
		size_t ciclomax = flagverbose ? soloesterni.size() : std::min(soloesterni.size(), static_cast<size_t>(10));
        for (size_t i = 0; i < ciclomax; ++i) 
			myprintf("80843:                   <<%Z>>\n", soloesterni[i].c_str());
		if (ciclomax<soloesterni.size())
			myprintf("80963$ ... showed first %d files, use -verbose to get them all\n",ciclomax);
		myprintf("\n");
 	}

	if (solointerni.size()>0)
	{
		color_yellow();
		myprintf("80829: Only INT %08d (%K %H) - files in .zpaq but NOT on filesystem\n",solointerni.size(),internisize,internisize);
	}
	else
	{
		color_green();
		myprintf("80829: There are no files in the .zpaq archive that are not present in the filesystem\n");
	}
	color_restore();
	if (!solointerni.empty()) 
	{
		size_t ciclomax = flagverbose ? solointerni.size() : std::min(solointerni.size(), static_cast<size_t>(10));
        for (size_t i = 0; i < ciclomax; ++i) 
			myprintf("80843:                   <<%Z>>\n",solointerni[i].c_str());
		if (ciclomax<solointerni.size())
			myprintf("80962$ ... showed first %d files, use -verbose to get them all\n",ciclomax);
		myprintf("\n");
 	}
	
	if (filecorrotti.size()>0)
	{
		color_yellow();
		myprintf("80830: BOTH     %08d (%K %H)\n",filedahashare,tobetested,tobetested);
		color_yellow();
		for (unsigned int i=0;i<filecorrotti.size();i++)
			myprintf("80898:              %s\n",filecorrotti[i].c_str());
		myprintf("80935:              Total ABS different size %K (%H)\n",corrottisize,corrottisize);
		color_restore();
	}
	else
	{
		color_green();
		myprintf("80831: No difference internal-external files detected\n");
		color_restore();
	}

	if ((internalfilecount+internalfoldercount+externalfilecount+externalfoldercount)>0)
	{
		color_yellow();
		myprintf("80987: WARNING: longpath (>255) Internal files %s folders %s | external files %s folders %s\n",migliaia(internalfilecount),migliaia2(internalfoldercount),migliaia3(externalfilecount),migliaia4(externalfoldercount));
	}
	else
	{
		color_green();
		myprintf("VERBOSE: No longpath (file/folder names longer than 255 chars) detected\n");
	}
	color_restore();
	int64_t totaldelta=corrottisize+internisize+esternisize+filelocalinontrovati;
	if (totaldelta>0)
	{
		myprintf("80931$	 Total delta %K (%H)\n",corrottisize+internisize+esternisize+filelocalinontrovati,corrottisize+internisize+esternisize+filelocalinontrovati);
		return 2;
	}
	else
	{
		color_green();
		myprintf("80942: No delta (this is VERY GOOD)\n");
		color_restore();
	}
	return 0;
}

std::string get_top_level_folder(const std::string& path) 
{
		
	myprintf("DEBUG: Input path = '%s' (length: %d)\n", path.c_str(), path.length());
    
    // Empty case
    if (path.empty()) 
	{
		myprintf("DEBUG: Path is empty, returning empty string\n");
        return "";
    }
    
    std::string working_path = path;
	myprintf("DEBUG: Initial working_path = '%s'\n", working_path.c_str());
    
    // If the path ends with '/', it's already a folder - return it as is
    if (working_path.length() > 1 && working_path.back() == '/') 
	{
		myprintf("DEBUG: Path ends with '/', returning as-is: '%s'\n", working_path.c_str());
        return working_path;
    }
    
    // Special handling for UNC paths (//server/share)
    if (working_path.length() >= 2 && working_path[0] == '/' && working_path[1] == '/') 
	{
		myprintf("DEBUG: UNC path detected\n");
        int slash_count = 0;
        size_t pos 		= 2;
        
        // Find the second slash after //
        for (size_t i = 2; i < working_path.length(); i++) 
            if (working_path[i] == '/') 
			{
                slash_count++;
				myprintf("DEBUG: Found slash at position %d, count = %d\n", i, slash_count);
                if (slash_count == 2) 
				{
                    pos = i;
                    break;
                }
            }
        
        // If we have found at least the server and the share, return up to the second slash
        if (slash_count >= 2) 
		{
            std::string result = working_path.substr(0, pos + 1);
			myprintf("DEBUG: UNC result = '%s'\n", result.c_str());
            return result;
        } 
		else 
		{
            // Only server or server/share with nothing else, return everything + /
            std::string result = working_path + "/";
			myprintf("DEBUG: UNC partial result = '%s'\n", result.c_str());
            return result;
        }
    }
    
    // For a file, find the last slash and return the folder that contains it
    size_t last_slash = working_path.find_last_of('/');
   	myprintf("DEBUG: Last slash position = %d\n", last_slash);
    
    // If there is no slash, it's a file/folder in the current directory
    if (last_slash == std::string::npos) 
	{
		myprintf("DEBUG: No slash found, returning empty string\n");
        return "";
    }
    
    // Return everything up to the last slash (inclusive)
    std::string result = working_path.substr(0, last_slash + 1);
	myprintf("DEBUG: Final result = '%s'\n", result.c_str());
    return result;
}
int Jidac::testverify()
{
	if (files.size()==0)
	{
		myprintf("03337! no files[] selected\n");
		return 2;
	}
	if (archive=="")
	{
		myprintf("03338! archive empty\n");
		return 2;
	}
	myprintf("03339: Comparing archive content to folder(s)\n");

	command		='l';
	g_optional	="versum"; //force isselected
	int errors	=0;
	int64_t csize=read_archive(NULL,archive.c_str(),&errors,1); 
	if (flagdebug)
		myprintf("03340: dtsize %d\n",dt.size());
	if (csize==0)
	{
		myprintf("03341! cannot read_archive\n");
		return 2;
	}
	if ((searchfrom!="") || (replaceto!=""))
	{
		myprintf("03342: due to -search/replace fixing the filenames\n");
		rename_a_dtmap(dt);
	}
	
	uint64_t howmanyfiles	=0;
	g_bytescanned			=0;
	g_filescanned			=0;
	g_worked				=0;
	files_count.clear();
	edt.clear();
	for (unsigned i=0;i<files.size();++i)
	{
		scandir(true,edt,files[i].c_str());
		files_count.push_back(edt.size()-howmanyfiles);
		howmanyfiles=edt.size();
	}
	eol();
	///myprintf("\n");
	printbar('-');
 	for (unsigned i=0; i<files.size(); ++i)
		if (direxists(files[i]))
			myprintf("03343: %9s in <<%s>>\n",migliaia((int64_t)files_count[i]),files[i].c_str());
	printbar('-');
	myprintf("03344: Total files found: %s\n", migliaia((int64_t)edt.size()));
	myprintf("\n");
	
	
	if (flagdebug3)
	{
		for (DTMap::iterator p=edt.begin(); p!=edt.end(); ++p)
			myprintf("03345: EDT  %s\n",p->first.c_str());
		printbar('-');
		for (DTMap::iterator p=dt.begin(); p!=dt.end(); ++p)
			myprintf("03346: DT   %s\n",p->first.c_str());
	}
	
	vector<DTMap::iterator> filelist;
	for (DTMap::iterator p=edt.begin(); p!=edt.end(); ++p)
	{
		DTMap::iterator a=dt.find(rename(p->first));
		if (a!=dt.end() && (all || a->second.date))
		{
			a->second.data='-';
			filelist.push_back(a);
		}
		p->second.data='+';
		filelist.push_back(p);
	}
	for (DTMap::iterator a=dt.begin(); a!=dt.end(); ++a)
		if (a->second.data!='-' && (all || a->second.date))
		{
			a->second.data='-';
			filelist.push_back(a);
		}
	int64_t usize=0;
	unsigned matches=0, mismatches=0, internal=0, externalfile=0,hashmatches=0,folderscount=0,filescount=0,
	externalfolder=0;
	uint32_t crc32fromfile;
	int64_t	hashchecked=0;
	int64_t	tobetested=0;
	vector<string> risultati;
	vector<bool> risultati_utf8;
	char linebuffer[1000];
	unsigned int ultimapercentuale=200;
	unsigned int percentuale;
	int64_t starttime=mtime();
	for (unsigned fi=0;fi<filelist.size(); ++fi)
	{
		
		DTMap::iterator p=filelist[fi];
		
		if (isdirectory(p->first))
			folderscount++;
		else
			filescount++;
		
		if (menoenne)
			if ((mismatches+externalfile+externalfolder+internal)>menoenne)
				break;
		if (!flagnoeta)
		{
			percentuale=100*fi/filelist.size();
			if (ultimapercentuale!=percentuale)
			{
				int secondi=(mtime()-starttime)/1000;
				if (secondi==0)
					secondi=1;
				if (percentuale==0)
					percentuale=1;
				double eta=(secondi*100/percentuale)-secondi;
				
				myprintf("03347: %03d%% %03d:%02d:%02d %10s/%10s @ %10s/s [+/- %19s]\r",
				percentuale,int(eta/3600), int(eta/60)%60, int(eta)%60,
				tohuman(g_worked),tohuman2(g_bytescanned),tohuman3(g_worked/secondi),migliaia2(usize));
				ultimapercentuale=percentuale;
			}
		}
    // Compare external files
		if (p->second.data=='-' && fi+1<filelist.size() && filelist[fi+1]->second.data=='+')
		{
			DTMap::iterator p1=filelist[fi+1];
			string 	myhashtype		="";
			string 	myhash			="";
			string 	mycrc32			="";
			int64_t mycreationtime	=0;
			int64_t myaccesstime	=0;
			bool	myisordered		=false;
			int		myversion		=0;
			franz_posix* myposix	=NULL;
			bool	myisadded		=false;
		
			string 	hashfromfile="";
			bool	isfolderp1=isdirectory(p1->first);
		
			if (!isdirectory(p1->first))
			{
				decode_franz_block(false,p->second.franz_block,
				myhashtype,
				myhash,
				mycrc32,
				mycreationtime,
				myaccesstime,
				myisordered,
				myversion,
				myposix,myisadded);
				tobetested+=p->second.size;
			}
			if (flagdebug2)
				myprintf("03348:  |%s| |%s| %s\n",myhashtype.c_str(),myhash.c_str(),p->first.c_str());
			
			if (equal(p, p1->first.c_str(),crc32fromfile,myhashtype,myhash,hashfromfile)) //crc32 of second parameters
			{
				if (flagquick)
				{
					p->second.data='=';
					++fi;
					g_worked+=p->second.size;
				}
				else
				{
					if (!isfolderp1)
					{
						if (hashfromfile!="")
						{
							if (flagdebug2)
								myprintf("03349: Check hash for %s\n",p->first.c_str());
							hashchecked+=p->second.size;
							if (hashfromfile!=myhash)
							{
								p->second.data='#';
								snprintf(linebuffer,sizeof(linebuffer),"\nHASH %s NOT MATCH STORED %s vs FROM FILE %s ",myhashtype.c_str(),myhash.c_str(),hashfromfile.c_str());
								risultati.push_back(linebuffer);
								risultati_utf8.push_back(false);
								snprintf(linebuffer,sizeof(linebuffer),"%s\n",p1->first.c_str());
								risultati.push_back(linebuffer);
								risultati_utf8.push_back(true);
							}
							else
							{
								hashmatches++;
								p->second.data='=';
								++fi;
							}
						}
						else
						if (mycrc32!="")
						{
							if (flagdebug2)
								myprintf("03350: Check CRC-32 for %s\n",p->first.c_str());
							uint32_t crc32stored=crchex2int(mycrc32.c_str());
							if (crc32stored!=crc32fromfile)
							{
								p->second.data='#';
								snprintf(linebuffer,sizeof(linebuffer),"\nCRC-32 NOT MATCH STORED %s vs FROM FILE %08X ",mycrc32.c_str(),crc32fromfile);
								risultati.push_back(linebuffer);
								risultati_utf8.push_back(false);
								snprintf(linebuffer,sizeof(linebuffer),"%s\n",p1->first.c_str());
								risultati.push_back(linebuffer);
								risultati_utf8.push_back(true);
							}
							else
							{
							/// if very, do a full hash verify!
								p->second.data='=';
								++fi;
							}
						}
						else
						{
							if (flagdebug2)
								myprintf("03351: No zpaqfranz check for %s\n",p->first.c_str());
							/// crc-32 is not stored in the archive, cannot tell anything
							p->second.data='=';
							++fi;
						}
					}
					else
					{
						/// directory always match
						p->second.data='=';
						++fi;
					}
				}
			}
			else
			{
				p->second.data='#';
				p1->second.data='!';
			}
		}
		if (p->second.data=='=') 
		{
			++matches;
		}
		if (p->second.data=='#') ++mismatches;
		if (p->second.data=='-') ++internal;
		if (p->second.data=='+')
		{
			if (isdirectory(p->first))
				externalfolder++;
			else
				externalfile++;
		}
		if (p->second.data!='=')
		{
			if (!isdirectory(p->first))
				usize+=p->second.size;
			snprintf(linebuffer,sizeof(linebuffer),"%c %s %19s ", char(p->second.data),dateToString(flagutc,p->second.date).c_str(), migliaia(p->second.size));
			risultati.push_back(linebuffer);
			risultati_utf8.push_back(false);
			snprintf(linebuffer,sizeof(linebuffer),"%s\n",p->first.c_str());
			risultati.push_back(linebuffer);
			risultati_utf8.push_back(true);
			if (p->second.data=='!')
			{
				snprintf(linebuffer,sizeof(linebuffer),"\n");
				risultati.push_back(linebuffer);
				risultati_utf8.push_back(false);
			}
		}
	}
	if (!flagnoeta)
	{
		int secondi=(mtime()-starttime)/1000;
		if (secondi==0)
			secondi=1;
		myprintf("03352: %03d%% %03d:%02d:%02d %10s/%10s @ %10s/s [+/- %19s]\r",
				100,0,0,0,
				tohuman(g_worked),tohuman2(g_bytescanned),tohuman3(g_worked/secondi),migliaia2(usize));
				
	///	myprintf("03353: %03d%% %10s/%10s @ %10s/s [+/- %19s]\r",100,tohuman(g_worked),tohuman2(g_bytescanned),tohuman3(g_worked/secondi),migliaia2(usize));
	}
	myprintf("\n\n");
	
	if (flagquick)
	{
		color_yellow();
		myprintf("03354$ WARNING -quick only compare file size/date, NOT hash!\n");
		color_restore();
	}
	bool myerror=false;
	if (menoenne)
		if ((mismatches+externalfile+externalfolder+internal)>menoenne)
			myprintf("03355! **** STOPPED BY TOO MANY ERRORS -n %d\n",menoenne);
	if  (mismatches || externalfile ||externalfolder || internal)
		for (unsigned int i=0;i<risultati.size();i++)
		{
			if (risultati_utf8[i])
				printUTF8(risultati[i].c_str());
			else
			myprintf("%s",risultati[i].c_str());
		}
	if (matches)
		myprintf("%08d =  same (files %s and folders %s)\n",matches,migliaia2(filescount),migliaia(folderscount));
	if (hashmatches)
	{
		if ((hashchecked==tobetested) && (hashmatches==filescount))
		{
			color_green();
			myprintf("%08d == very same bytes %s AND same file count (VERY good)\n",hashmatches,migliaia(hashchecked));
		}
		else
		{
			color_yellow();
			myprintf("%08d == very same files %19s\n",hashmatches,migliaia(hashchecked));
			myprintf("            expected        %19s\n",migliaia(tobetested));
			myprintf("03356: ****** WARN something strange (hash checking)  *******\n");
			myprintf("03357: ******      some file(s) stored without hash?  *******\n");
			myprintf("03358: ******      hash does not match? unknown hash? *******\n");
		}
		color_restore();
	}
	if (mismatches)
	{
		myprintf("%08d #different\n",mismatches);
		myerror=true;
	}
	if (externalfile)
	{
		myprintf("%08d +external (file missing in ZPAQ)\n",externalfile);
		myerror=true;
	}
	if (externalfolder)
	{
		myprintf("%08d +external (empty folders missing in ZPAQ?)\n",externalfolder);
		myerror=true;
	}
	
	if (internal)
	{
		myprintf("%08d -internal (file in ZPAQ but not on disk)\n",internal);
		myerror=true;
	}
	if (myerror)
		color_yellow();
	if (usize>0)
		color_red();
	myprintf("03359: Total different file size: %s bytes\n",migliaia(usize));
	color_restore();
	
 	if  (myerror)
	{	
		if (usize==0)
		{
			color_yellow();
			myprintf("03360: Files seems good, maybe folder mismatch? -verbose for details\n");
			color_restore();
			return 1;
		}
		else
		{
			color_red();
			myprintf("03361: use -verbose to get more details\n");
			color_restore();
			return 2;
		}
	}
	return 0;
}

int Jidac::sync()
{
	if (files.size()==0)
	{
		myprintf("03337! no files[] selected\n");
		return 2;
	}
	if (archive=="")
	{
		myprintf("03338! archive empty\n");
		return 2;
	}
	myprintf("03339: Comparing archive content to folder(s)\n");

/*
	command		='l';
	g_optional	="versum"; //force isselected
	*/
	int errors	=0;
	int64_t csize=read_archive(NULL,archive.c_str(),&errors,1); 
	if (flagdebug)
		myprintf("03340: dtsize %d\n",dt.size());
	if (csize==0)
	{
		myprintf("03341! cannot read_archive\n");
		return 2;
	}
	if ((searchfrom!="") || (replaceto!=""))
	{
		myprintf("03342: due to -search/replace fixing the filenames\n");
		rename_a_dtmap(dt);
	}
	
	uint64_t howmanyfiles	=0;
	g_bytescanned			=0;
	g_filescanned			=0;
	g_worked				=0;
	files_count.clear();
	edt.clear();
	for (unsigned i=0;i<files.size();++i)
	{
		scandir(true,edt,files[i].c_str());
		eol();
		files_count.push_back(edt.size()-howmanyfiles);
		howmanyfiles=edt.size();
	}
	eol();
	///myprintf("\n");
///	printbar('-');
 	for (unsigned i=0; i<files.size(); ++i)
		if (direxists(files[i]))
			myprintf("03343: %9s in <<%s>>\n",migliaia((int64_t)files_count[i]),files[i].c_str());
	///printbar('-');
	myprintf("03344: Total external files found: %s\n", migliaia((int64_t)edt.size()));
	myprintf("\n");
	
	
	if (flagdebug3)
	{
		int j=0;
		for (DTMap::iterator a = dt.begin(); a != dt.end(); a++) // Note: do not increment here
		{
			j++;
			if (j==10)
				break;
			myprintf("start dt %s\n",a->first.c_str());
		}		
	}
	if (flagdebug3)
	{
		for (DTMap::iterator p=edt.begin(); p!=edt.end(); ++p)
			myprintf("03345: EDT  %s\n",p->first.c_str());
		printbar('-');
		for (DTMap::iterator p=dt.begin(); p!=dt.end(); ++p)
			myprintf("03346: DT   %s\n",p->first.c_str());
	}

	
	vector<DTMap::iterator> filelist;
	vector<DTMap::iterator> externalfilelist;
	vector<DTMap::iterator> internalfilelist;

	// Pre-allocare spazio conosciuto
	externalfilelist.reserve(edt.size());  // We already know the size
	internalfilelist.reserve(dt.size());   // Avoid reallocations

/*
	std::string filter=files[0]; //"c:/zpaqfranz/va*.cpp";
	
	if (flagdebug3)
		myprintf("FILTER %s\n",filter.c_str());
*/		
	for (DTMap::iterator p = edt.begin(); p != edt.end(); ++p) 
	{
	///	if (match_pattern(p->first, filter)) 
			externalfilelist.push_back(p);
	}	


	if (flagdebug3)
	{
		int i=0;
		for (DTMap::iterator a = dt.begin(); a != dt.end(); a++) // Note: do not increment here
		{
			i++;
			if (i==10)
				break;
			myprintf("pre dt %s\n",a->first.c_str());
		}		
	}
	for (DTMap::iterator a = dt.begin(); a != dt.end(); a++) // Note: do not increment here
	{
		if (flagdebug3)
			myprintf("DEBUG3: New dt %s\n",a->first.c_str());
		internalfilelist.push_back(a);
	}	
	if (flagdebug3)
	{
		for (unsigned i=0;i<internalfilelist.size(); ++i)
			myprintf("81508: INTERNAL %08d %s\n",i,internalfilelist[i]->first.c_str());
		for (unsigned i=0;i<externalfilelist.size(); ++i)
			myprintf("81509: EXTERNAL %08d %s\n",i,externalfilelist[i]->first.c_str());
	}
	if (internalfilelist.size()==0)
	{
		color_red();
		myprintf("81623! No INTERNAL file in archive (wrong path?)\n");
		color_restore();
	}
	else
		myprintf("81541: Internal count %d\n",internalfilelist.size());
	if (externalfilelist.size()==0)
	{
		color_red();
		myprintf("81661! NO EXTERNAL files (wrong path?)\n");
		color_restore();
	}
	else
		myprintf("81541: External count %d\n",externalfilelist.size());
	
	if ((externalfilelist.size()>0) && (internalfilelist.size()>0))
	{
		string primaesterna=get_top_level_folder(externalfilelist[0]->first);
		myprintf("DEBUG: Internalpath   %s\n",internalfilelist[0]->first.c_str());
		string primainterna=get_top_level_folder(internalfilelist[0]->first);
		myprintf("DEBUG: Thinking       %s\n",primainterna.c_str());
		
		if (primaesterna!=primainterna)
		{
			color_yellow();
			myprintf("81022: External and internal paths does not match. Multiple paths? Fix with -find -replace?\n");
			myprintf("81023: external %Z\n",primaesterna.c_str());
			myprintf("81024: internal %Z\n",primainterna.c_str());
			color_restore();
		}
		
	}
	
	return comparefilelists(externalfilelist,internalfilelist,dt);
}

bool Jidac::grep(const string i_filename,const string i_search)
{
	if (i_filename=="")
	{
		myprintf("03362! i_filename empty\n");
		return false;
	}
	if (i_search=="")
	{
		myprintf("03363! i_search empty\n");
		return false;
	}
		
    FILE *file=freadopen(i_filename.c_str());
    if (file==NULL) 
	{
        myprintf("03364! cannot fdreadopen file %s\n",i_filename.c_str());
		return false;
    }
    
	char line[1024];
    int line_number=1;
    bool found=false;
    while (fgets(line, sizeof(line), file) != NULL) 
	{
        if (strstr(line,i_search.c_str())!=NULL) 
		{
			if (flagdebug)
				myprintf("03365: Founded @ line %d: %s", line_number, line);
			found=true;
			break;
        }
        line_number++;
    }

    fclose(file);
	return found;
}

int	Jidac::checkautotest(string i_path)
{
	if (i_path=="")
	{
		myprintf("03366! i_path empty\n");
		return 2;
	}
	if (!direxists(i_path))
	{
		myprintf("03367! autotest path does not exist %s\n",i_path.c_str());
		return 2;
	}
	stringstringmap elencorisultati;
	elencorisultati["out01.txt"]="NOT renamed files  256";
	elencorisultati["out02.txt"]="67708591460BCE3BC45AE086A342F9F390AD2913A22639EC7AF3646B7D2AEA78";
	elencorisultati["out03.txt"]="(all OK)";
	elencorisultati["out04.txt"]="(all OK)";
	elencorisultati["out05.txt"]="(all OK)";
	elencorisultati["out06.txt"]="SURE    :       42.727 of       42.727 (stored=decompressed=file on disk)";
	elencorisultati["out07.txt"]="GLOBAL SHA256: 7B32DB3F6F0180062773C5A046A2C99D17BE7668202379BA136E7A4D134FFC26";
	elencorisultati["out08.txt"]="GLOBAL SHA256: 5088D26FE31EEE0E04F1569CD4851B6DE4A1CBC00EC56BAC7F390A123A8C1111";
	elencorisultati["out09.txt"]="Files deleted                       42.735";
	elencorisultati["out10.txt"]="10000.dat";
	elencorisultati["out11.txt"]="10000.dat";
	elencorisultati["out12.txt"]="(all OK)";
	elencorisultati["out13.txt"]="OK      XXHASH64B : 00000256 of 00000256";
	elencorisultati["out14.txt"]="== very same bytes 9.472.000";
	elencorisultati["out15.txt"]="===";
	elencorisultati["out16.txt"]="All OK (paranoid test with check against filesystem)";
	elencorisultati["out17.txt"]="+              1";
	elencorisultati["out18.txt"]="GLOBAL SHA256: 9C443D84B87B678E4506AD5F6A2FC89B83546E286F19998899DC4461BB9F97D0";
	elencorisultati["out19.txt"]="GLOBAL SHA256: 9C443D84B87B678E4506AD5F6A2FC89B83546E286F19998899DC4461BB9F97D0";
	elencorisultati["out20.txt"]="GLOBAL SHA256: 9C443D84B87B678E4506AD5F6A2FC89B83546E286F19998899DC4461BB9F97D0";
	elencorisultati["out21.txt"]="GLOBAL SHA256: EEBFFD8399E88CE05BCFD1AAE65C4A118E57638511AF18255C5A295A6378F437";

	i_path=wintolinuxpath(i_path);
	i_path=includetrailingbackslash(i_path);
	myprintf("03368: Checking results (in %Z)\n",i_path.c_str());
	int	errori=0;
	for (stringstringmap::iterator p=elencorisultati.begin();p!=elencorisultati.end();++p)
	{
		myprintf("03370: %s :",p->first.c_str());
		bool trovato=grep(i_path+p->first,p->second);
		if (trovato)
			myprintf(" OK\n");
		else
		{
			myprintf(" ERROR cannot find %s\n",p->second.c_str());
			errori++;
		}
	}
	if (errori>0)
	{
		myprintf("03371! ERRORS %s\n",migliaia(errori));
		return 2;
	}
	else
	{
		myprintf("03372: Everything is OK (this is good)\n");
		myprintf("03373: It is now safe to remove the test folder\n");
	}
	return 0;
}

bool Jidac::isjitable()
{
	bool	risultato=false;
    char buffer		[1024];
    
#ifdef _WIN32
    HKEY hKey;
	char cpu_vendor	[1024];
    DWORD buffer_size=sizeof(cpu_vendor);
    LONG result;
	/// "antisomething" does not like this
	///result = RegOpenKeyEx(HKEY_LOCAL_MACHINE, utow("HARDWARE\\DESCRIPTION\\System\\CentralProcessor\\0").c_str(), 0, KEY_READ, &hKey);
	
	string temp="HARDWARE\\DESCRIPTION\\System\\";
	temp+="Central";
	temp+="Processor\\0";

	result = RegOpenKeyEx(HKEY_LOCAL_MACHINE, utow(temp.c_str()).c_str(), 0, KEY_READ, &hKey);
    if (result!=ERROR_SUCCESS) 
	{
        myprintf("03374! Windows: GURU opening registry key\n");
        return false;
    }

    result = RegQueryValueEx(hKey, utow("VendorIdentifier").c_str(), NULL, NULL, (LPBYTE)cpu_vendor, &buffer_size);
    if (result != ERROR_SUCCESS) 
	{
        myprintf("03375! Guru reading reading registry value\n");
        RegCloseKey(hKey);
        return false;
    }
		
	buffer_size=1024;
	result = RegQueryValueEx(hKey, utow("ProcessorNameString").c_str(), NULL, NULL, (LPBYTE)buffer, &buffer_size);
    if (result != ERROR_SUCCESS) 
	{
        myprintf("03376! Guru reading reading registry value\n");
        RegCloseKey(hKey);
        return false;
    }
	
    RegCloseKey(hKey);
	
	g_processorname=wtou((wchar_t*)buffer);

	g_processorname=mytrim(g_processorname);
	
	myprintf("03377: Processor name |%s|\n",g_processorname.c_str());
	
	string uvendor=wtou((wchar_t*)cpu_vendor);
	if (strstr(uvendor.c_str(), "GenuineIntel") != NULL) 
	{
		if (flagdebug)
			myprintf("03378: Windows - the processor is Intel\n");
		risultato=true;
    } 
	else 
	if (strstr(uvendor.c_str(), "AuthenticAMD") != NULL) 
	{
    	if (flagdebug)
			myprintf("03379: Windows - the processor is AMD\n");
		risultato=true;
    } 
	else 
	{
        myprintf("03380: Windows - who knows: %s\n", uvendor.c_str());
    }
    return risultato;
#elif __linux__
	char vendor_id	[1024];
    FILE *cpuinfo=fopen("/proc/cpuinfo", "r");

    if (cpuinfo==NULL) 
	{
        myprintf("03381! Linux, error opening /proc/cpuinfo");
        return false;
    }
    while (fgets(buffer,1024,cpuinfo)) 
        if (sscanf(buffer, "vendor_id : %s", vendor_id) == 1) 
		{
            if (strcmp(vendor_id,"GenuineIntel") == 0) 
			{
				if (flagdebug)
					myprintf("03382: Linux - the processor is Intel.\n");
				risultato=true;
            } 
			else if (strcmp(vendor_id, "AuthenticAMD") == 0) 
			{
				if (flagdebug)
					myprintf("03383: Linux - The processor is AMD.\n");
				risultato=true;
            } 
			else 
			{
				if (flagdebug)
					myprintf("03384: Linux not-intel vendor_id: %s\n", vendor_id);
            }
            break;
        }
    fclose(cpuinfo);
    return risultato;

#else

    FILE *pipe=NULL;

#ifdef BSD  // BSD
#ifndef __APPLE__   	// Mac is different (of course)
    pipe=popen("sysctl -n hw.model", "r");
#endif // corresponds to #ifndef (#ifndef __APPLE__   	// Mac is different (of course))
#endif // corresponds to #ifdef (#ifdef BSD  // BSD)

#if (defined(__APPLE__) && defined(__MACH__))
    pipe=popen("sysctl -n machdep.cpu.brand_string","r");
#endif // corresponds to #if (#if (defined(__APPLE__) && defined(__MACH__)))

#ifdef SOLARIS
    pipe=popen("psrinfo -pv","r");
#endif // corresponds to #ifdef (#ifdef SOLARIS)

#ifdef HAIKU
	pipe=popen("sysinfo -cpuid","r");
#endif // corresponds to #ifdef (#ifdef HAIKU)

    if (pipe==NULL) 
	{
        myprintf("03385! Error opening pipe");
        return false;
    }

    if (fgets(buffer,1024,pipe)==NULL) 
	{
        myprintf("03386! Error reading from pipe");
        pclose(pipe);
        return false;
	}
	
	char cpu_vendor	[1024];

	strncpy(cpu_vendor,buffer,1024);
	cpu_vendor[strcspn(cpu_vendor,"\n")]=0;

    pclose(pipe);

    if (strstr(cpu_vendor, "Intel")!=NULL) 
	{
		if (flagdebug)
			myprintf("03387: Multiple - the processor is Intel.\n");
		risultato=true;
	}
    else if (strstr(cpu_vendor, "AMD") != NULL) 
	{
     	if (flagdebug)
			myprintf("03388: Multiple - the processor is AMD.\n");
		risultato=true;
    } 
	else 
	{
		if (flagdebug)
			myprintf("03389: Multiple not-intel vendor_id: %s\n",cpu_vendor);
    }

    return risultato;
#endif // corresponds to #ifdef (#ifdef _WIN32)

}

void Jidac::tabba()
{
	if (g_csvstring!="")
		myprintf(g_csvstring.c_str());
	else
		myprintf(" ");
}

string get_hash(const string i_haystack,const string i_line)
{
	if (i_line=="")
	{
		myprintf("03390! i_line empty!\n");
		return "";
	}
	int start=mypos(i_haystack,i_line);
	if (flagdebug)
		myprintf("03391: start at %d\n",start);
	if (start<0)
		return "";
	start+=i_haystack.size();
	string	code;
	unsigned int i=start;
	
	while (i<i_line.size())
	{
		if (i_line[i]==' ')
			i++;
		else
		if (ishex(i_line[i]))
			code+=i_line[i++];
		else
			break;
	}
	return stringtoupper(code);
}
int Jidac::comparehex()
{
	if (files.size()!=4)
	{
		myprintf("03392! You must enter FOUR parameters for comparehex\n");
		myprintf("03393: File1 (ex. z:\\1.txt\n");
		myprintf("03394: File2 (ex. z:\\2.txt\n");
		myprintf("03395: The haystack (ex. \"GLOBAL SHA256:\"");
		myprintf("03396: Expected len (ex. 64\n");
		return 2;
	}
	
	string 	file1		=files[0];
	string 	file2		=files[1];
	string	hashstring	=files[2];
	int		expectedlen	=atoi(files[3].c_str());
	
	myprintf("03397: File 1 <<%Z>>\n",file1.c_str());
	myprintf("03398: File 2 <<%Z>>\n",file2.c_str());
	if (flagdebug)
	{	
		myprintf("03401: Hashstring  |%s|\n",hashstring.c_str());
		myprintf("03402: Expectedlen %d\n",expectedlen);
	}
	
	if (!fileexists(file1))
	{
		myprintf("03403! Sorry, file 1 does not exist\n");
		return 2;
	}
	if (!fileexists(file2))
	{
		myprintf("03404! Sorry, file 2 does not exist\n");
		return 2;
	}
	vector<string> vector1;
	vector<string> vector2;
	
	if (!readfiletoarray(file1,vector1))
	{
		myprintf("03405! Error, cannot read file1 in vector1\n");
		return 2;
	}
	if (!readfiletoarray(file2,vector2))
	{
		myprintf("03406! Error, cannot read file2 in vector2\n");
		return 2;
	}
	
	string sha256_1;
	string sha256_2;
	
	for (unsigned int i=vector1.size()-1; i>0; i--)
		if (mypos(hashstring,vector1[i])>-1)
		{
			sha256_1=vector1[i];
			break;
		}

	for (unsigned int i=vector2.size()-1; i>0; i--)
		if (mypos(hashstring,vector2[i])>-1)
		{
			sha256_2=vector2[i];
			break;
		}
	if (flagdebug)
	{
		myprintf("03407: SHA256_1 %s\n",sha256_1.c_str());
		myprintf("03408: SHA256_2 %s\n",sha256_2.c_str());
	}
	if (sha256_1=="")
	{
		myprintf("03409! Cannot find |%s| in file1\n",hashstring.c_str());
		return 2;
	}
	if (sha256_2=="")
	{
		myprintf("03410! Cannot find |%s| in file2\n",hashstring.c_str());
		return 2;
	}

	string	code1=get_hash(hashstring,sha256_1);
	string	code2=get_hash(hashstring,sha256_2);

	int	risultato=2;
	if ((code1==code2) && ((int)code1.size()==expectedlen))
	{
		color_green();
		risultato=0;
	}
	else
		color_red();
	myprintf("03411: [1] exp len %d/found %d |%s|\n",expectedlen,code1.size(),code1.c_str());
	myprintf("03412: [2] exp len %d/found %d |%s|\n",expectedlen,code2.size(),code2.c_str());
	color_restore();
	
	return risultato;
}

int Jidac::count()
{

	if ((files.size()!=2) && (files.size()!=3))
	{
		myprintf("03413! You must enter TWO or THREE parameters for count\n");
		myprintf("03414: [1] filename (ex. z:\\1.txt\n");
		myprintf("03415: [2] count    (ex. 3)\n");
		myprintf("03416: [3] thestring (optional, ex. \"(all OK)\"");
		return 2;
	}
	
	string 	file1		=files[0];
	int		expectedlen	=atoi(files[1].c_str());
	
	string 	hashstring="#     # ###!";
	if (files.size()==3)
		hashstring	=files[2];
	
	if (!flagterse)
	{
		myprintf("03417: File 1 <<%Z>>\n",file1.c_str());
	}

	if (flagverbose)
		myprintf("03419: Searchstring |%s|\n",hashstring.c_str());

	if (flagdebug)
	{
		myprintf("03420: Expectedcount %d\n",expectedlen);
	}


	g_bytescanned	=0;
	g_filescanned	=0;
	g_worked		=0;
	flagskipzfs		=true;  // strip down zfs
	DTMap			thedt;

#ifdef unix
	if (flagdebug)
		myprintf("03421: running on NIX\n");
	vector<string> candidate;
	string estensione=prendiestensione(file1);

	listfiles(extractfilepath(file1),estensione,true,&candidate);
	if (flagdebug3)
		myprintf("03422: candidate %s with pattern %s\n",migliaia(candidate.size()),file1.c_str());
	for (unsigned int i=0;i<candidate.size();i++)
	{
		string filename=candidate[i];
		if (flagdebug3)
			myprintf("03423: filename %08d %s\n",(int)i,filename.c_str());

		if (jollymatch(file1.c_str(),filename.c_str()))
		{
			if (flagdebug3)
			{
				myprintf("03424: matched <<%Z>>\n",filename.c_str());
			}
			DT& d=thedt[filename];
			d.date			=0;
			d.creationdate	=0;
			d.accessdate	=0;
			d.size			=0;
			d.attr			=0;
			d.data			=0;
		}
		else
		{
			if (flagdebug3)
				myprintf("03426: DISCARDED %s in %s\n",file1.c_str(),filename.c_str());
		}
	}
#else

	scandir(false,thedt,file1,false);
	eol();
	///printbar(' ',false);
	///myprintf("\r");
#endif // corresponds to #ifdef (#ifdef unix)

	if (thedt.size()==0)
	{
		myprintf("03427! no archive founded => quit\n");
		return 2;
	}
	if (flagverbose)
	myprintf("03428: Founded %s archive(s), working\n",migliaia(thedt.size()));
	int	founded		=0;
///	int therun		=0;
	vector<string> vector1;
	
	string filename;
	for (DTMap::iterator p=thedt.begin(); p!=thedt.end(); ++p)
	{
///		therun++;
		filename=p->first;
		if (flagverbose)
		myprintf("03429: Loading %s\n",filename.c_str());
		vector1.clear();
		if (!readfiletoarray(filename,vector1))
		{
			myprintf("03430! Error, cannot read file1 in vector1 %s\n",filename.c_str());
			return 2;
		}

		for (unsigned int i=0;i<vector1.size();i++)
			if (mypos(hashstring,vector1[i])>-1)
				founded++;
		
	///	risultato+=riscomando;
	}
	
	if (founded==expectedlen)
		color_green();
	myprintf("03431: Total founded %s (expected %s)  ",migliaia(founded),migliaia2(expectedlen));
	if (founded==expectedlen)
		myprintf(": THIS IS GOOD\n");
	else
		myprintf(": ERROR!!!\n");
	
	color_restore();
	
	
	if (founded==expectedlen)
		return 0;
		
	return 2;
	
}


/* Funzione per calcolare l'entropia di un file */
double calculate_entropy(std::string filename) 
{
    if (filename.empty())
    {
        myprintf("82872: filename empty\n");
        return -1.0;
    }
    
    FILE *file = fopen(filename.c_str(), "rb");
    if (!file) 
    {
        myprintf("82873: error cannot open %s\n", filename.c_str());
        return -1.0;
    }
    
    /* Array per contare la frequenza di ogni byte (0-255) */
    unsigned long frequency[256] = {0};
    unsigned char buffer[1024];
    size_t bytes_read;
    unsigned long total_bytes = 0;
    
    /* Leggi il file e conta le frequenze */
    while (!feof(file) && !ferror(file)) 
    {
        bytes_read = fread(buffer, 1, sizeof(buffer), file);
        if (bytes_read == 0) {
            break; // EOF reached or error
        }
        
        for (size_t i = 0; i < bytes_read; i++) 
        {
            frequency[buffer[i]]++;
            total_bytes++;
        }
    }
    
    // Check if there was a read error
    if (ferror(file)) 
    {
        myprintf("82874: error reading file %s\n", filename.c_str());
        fclose(file);
        return -1.0;
    }
    
    fclose(file);
    
    if (total_bytes == 0) 
    {
        myprintf("82900: File empty %s is empty\n", filename.c_str());
        return -1.0;
    }
    
    /* Calcola l'entropia di Shannon */
    double entropy = 0.0;
    for (int i = 0; i < 256; i++) 
    {
        if (frequency[i] > 0) 
        {
            double probability = (double)frequency[i] / total_bytes;
            entropy -= probability * log2(probability);
        }
    }
    
    return entropy;
}
// check encrypt key
int evaluate_key_suitability(double entropy,bool i_dooutput=false) 
{
	if (i_dooutput)
		myprintf("82908: Entropy: %.4f bit/byte : ", entropy);
    if (entropy >= 7.5) 
	{
		if (i_dooutput)
		{
			color_green();
			myprintf("Suitable for cryptography\n");
			color_restore();
		}
		return 0;
	}
	else
	if 
	(entropy >= 6.0) 
	{
		if (i_dooutput)
		{
			color_yellow();
			myprintf("Intermediate — I want a better one\n");
			color_restore();
		}
		return 2;
    } 
	else 
	{
		if (i_dooutput)
		{
			color_red();
			myprintf("Not suitable — entropy too low, choose a better one\n");
			color_restore();
		}
		return 2;
	}
	return 2;
}



// Alfabeto Base58 (Bitcoin style)
const char* BASE58_ALPHABET = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";

// Convert a hexadecimal character to a numeric value
int hexCharToInt(char c) {
    if (c >= '0' && c <= '9') return c - '0';
    if (c >= 'a' && c <= 'f') return c - 'a' + 10;
    if (c >= 'A' && c <= 'F') return c - 'A' + 10;
    throw std::invalid_argument("Carattere non valido in input esadecimale");
}

// Convert a hexadecimal string to a byte vector (big-endian)
std::vector<uint8_t> hexToBytes(const std::string& hex) {
    if (hex.size() % 2 != 0)
        throw std::invalid_argument("La stringa hex deve avere lunghezza pari");

    std::vector<uint8_t> bytes;
    bytes.reserve(hex.size() / 2);

    for (size_t i = 0; i < hex.size(); i += 2) {
        int hi = hexCharToInt(hex[i]);
        int lo = hexCharToInt(hex[i + 1]);
        bytes.push_back(static_cast<uint8_t>((hi << 4) | lo));
    }
    return bytes;
}

// Divide "number" (base 256) by 58, return remainder and update number with quotient
uint8_t divmod58(std::vector<uint8_t>& number) {
    int remainder = 0;
    for (size_t i = 0; i < number.size(); i++) {
        int temp = remainder * 256 + number[i];
        number[i] = temp / 58;
        remainder = temp % 58;
    }
    // Remove leading zeros
    while (!number.empty() && number[0] == 0) {
        number.erase(number.begin());
    }
    return static_cast<uint8_t>(remainder);
}

// Convert hexadecimal to Base58
std::string hexToBase58(const std::string& hex) {
    std::vector<uint8_t> bytes = hexToBytes(hex);
    
    // Count how many zeros at the beginning (in bytes, i.e. 0x00)
    size_t zeroCount = 0;
    for (size_t i = 0; i < bytes.size(); i++) {
        if (bytes[i] == 0) zeroCount++;
        else break;
    }
    
    std::string result;
    // Copia vettore perché lo modifichiamo
    std::vector<uint8_t> temp = bytes;
    
    // We repeatedly divide by 58
    while (!temp.empty()) {
        uint8_t mod = divmod58(temp);
        result.push_back(BASE58_ALPHABET[mod]);
    }
    
    // Add '1' for each leading zero
    for (size_t i = 0; i < zeroCount; i++) {
        result.push_back('1');
    }
    
    // The string is in reverse order
    std::reverse(result.begin(), result.end());
    return result;
}

// ---
// Example of use (comment or remove in production)
// int main() {
//     std::string hexInput = "0000000000000000000000000000000000000000000000000000000000000000" // 64 zeri (32 byte)
//                             "FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF"; // 64 F (32 byte)
//     try {
//         std::string base58 = hexToBase58(hexInput);
//         std::cout << "Base58: " << base58 << std::endl;
//     } catch (const std::exception& e) {
//         std::cerr << "Errore: " << e.what() << std::endl;
//     }
//     return 0;
// }

// Reverse map to find the index of a Base58 character
int base58CharToValue(char c) {
    for (int i = 0; i < 58; ++i) {
        if (BASE58_ALPHABET[i] == c) {
            return i;
        }
    }
    throw std::invalid_argument("Carattere non valido nell'input Base58");
}

// Convert a byte vector (large number in base 256) to a hexadecimal string
std::string bytesToHex(const std::vector<uint8_t>& bytes) {
    std::string hexString;
    hexString.reserve(bytes.size() * 2); // Each byte becomes 2 hex characters
    const char* hexDigits = "0123456789abcdef";
    
    for (size_t i = 0; i < bytes.size(); i++) {
        uint8_t byte = bytes[i];
        hexString.push_back(hexDigits[(byte >> 4) & 0x0F]); // Upper nibble
        hexString.push_back(hexDigits[byte & 0x0F]);         // Lower nibble
    }
    
    return hexString;
}

// Multiply "number" (base 256) by 58 and add "digit", return the new number
void muladd256(std::vector<uint8_t>& number, int digit) {
    int carry = digit;
    for (size_t i = 0; i < number.size(); ++i) {
        int temp = number[i] * 58 + carry;
        number[i] = temp % 256;
        carry = temp / 256;
    }
    while (carry > 0) {
        number.push_back(carry % 256);
        carry /= 256;
    }
}

// Convert Base58 to Hexadecimal
std::string base58ToHex(const std::string& base58) {
    std::vector<uint8_t> bytes(1, 0); // Start with a single zero byte
    
    // Check and count the leading '1's
    size_t leadingOnes = 0;
    for (size_t j = 0; j < base58.length(); j++) {
        char c = base58[j];
        if (c == '1') {
            leadingOnes++;
        } else {
            break;
        }
    }
    
    // Process Base58 characters, ignoring initial '1's for arithmetic
    for (size_t i = leadingOnes; i < base58.length(); ++i) {
        int digit = base58CharToValue(base58[i]);
        // This implementation processes bytes in reverse order,
        // so we need to invert first and then handle the carries
        // A simpler approach to avoid continuous inversion would be to use a BigInt library
        // But to stick with simple vector<uint8_t>, we do this.
        // In reality, the standard algorithm decodes from left to right accumulating the result.
        // The correct decoding algorithm is: result = result *58 + digit
        // On bytvector, it's a "big integer multiplication and addition"
        muladd256(bytes, digit);
    }
    
    // Gli zeri iniziali della stringa Base58 ('1's) corrispondono agli zeri iniziali nel vettore di byte
    // We must add them to the result.
    // The `bytes` array was built with the least significant bytes first.
    // Now we must invert it to obtain the big-endian order.
    std::reverse(bytes.begin(), bytes.end());
    
    // If there are leading zeros in the original Base58 (the '1's),
    // we must add equivalent ones to the result in bytes.
    // The `muladd256` algorithm shifts the effective zeros.
    // Gli '1' iniziali nella stringa base58 rappresentano byte 0x00.
    // We must pre-append the correct number of 0x00 bytes.
    std::vector<uint8_t> finalBytes;
    finalBytes.reserve(bytes.size() + leadingOnes);
    
    for(size_t i = 0; i < leadingOnes; ++i) {
        finalBytes.push_back(0x00);
    }
    
    // Remove any spurious leading zeros generated by the arithmetic before copying
    // Useful because  `muladd256` can add zeros
	size_t firstNonZero = 0;
    while (firstNonZero < bytes.size() && bytes[firstNonZero] == 0) {
        firstNonZero++;
    }
    
    for (size_t i = firstNonZero; i < bytes.size(); ++i) {
        finalBytes.push_back(bytes[i]);
    }
    
    // Handling the case of an empty or '1's only Base58 string
    if (finalBytes.empty()) {
        return "00"; // Represents a 0 value in hexadecimal
    }
    
    return bytesToHex(finalBytes);
}

// NOTE: The `muladd256` implementation above is simplified and builds the number "backwards"
// (the least significant byte is at index 0). For a correct Base58 decoding (big-endian),
// `bytes` can be a big number

// Let's review the logic of base58ToHex and muladd256 to be compliant with big-endian and the standard algorithm.

// Standard Base58 decoding algorithm:
// The resulting number is initialized to 0.
// For each character in the Base58 string:
//   The resulting number is multiplied by 58.
//   The value of the current character is added.

// To implement this with a big-endian vector<uint8_t>:
std::vector<uint8_t> base58ToBytesCorrected(const std::string& base58) {
    std::vector<uint8_t> resultBytes;
    
    // Handle the leading '1's
    size_t leadingOnes = 0;
    for (size_t k = 0; k < base58.length(); k++) {
        char c = base58[k];
        if (c == '1') {
            leadingOnes++;
        } else {
            break;
        }
    }
    
    // Decode the remaining Base58 characters
    for (size_t i = leadingOnes; i < base58.length(); ++i) {
        int digit = base58CharToValue(base58[i]);
        // Implement result = result * 58 + digit
        // Work on the bytes from least significant to most significant (from the end of the vector)
        // to handle carries.
        int carry = digit;
        for (size_t j = 0; j < resultBytes.size(); ++j) {
            int temp = resultBytes[j] * 58 + carry;
            resultBytes[j] = temp % 256;
            carry = temp / 256;
        }
        while (carry > 0) {
            resultBytes.push_back(carry % 256);
            carry /= 256;
        }
    }
    
    // Add leading zeros for each '1' in Base58
    for (size_t i = 0; i < leadingOnes; ++i) {
        resultBytes.push_back(0);
    }
    
    // Invert the vector to get big-endian order
    std::reverse(resultBytes.begin(), resultBytes.end());
    
    // Remove any extra leading zeros that do not correspond to a '1' in Base58
    // (can occur if the decoded number actually starts with 0 but there were no explicit '1's)
    size_t firstNonZero = 0;
    while (firstNonZero < resultBytes.size() - 1 && resultBytes[firstNonZero] == 0) {
        firstNonZero++;
    }
    resultBytes.erase(resultBytes.begin(), resultBytes.begin() + firstNonZero);
    
    // Handling the case where the Base58 string was only '1's or empty
    if (resultBytes.empty() && leadingOnes == 0) {
        // If the string was empty or only '1's, and there were no specific '1's, the value is 0
        std::vector<uint8_t> singleZero;
        singleZero.push_back(0x00);
        return singleZero; // A single byte 0
    } else if (resultBytes.empty() && leadingOnes > 0) {
        // If the string was only '1's, the result is as many 0x00s as there were '1's
        std::vector<uint8_t> zeros(leadingOnes, 0x00);
        return zeros;
    }
    
    return resultBytes;
}

// Final function to call
std::string base58ToHexWrapper(const std::string& base58) {
    std::vector<uint8_t> bytes = base58ToBytesCorrected(base58);
    if (bytes.empty()) {
        return ""; // Or "00" depending on how you want to represent zero
    }
    return bytesToHex(bytes);
}


string Jidac::keyfile_to_string(string i_keyfile)
{
	if (i_keyfile=="")
	{
		myprintf("83259: Keyfile empty\n");
		seppuku();
	}
	if (!fileexists(i_keyfile))
	{
		myprintf("83260: Keyfile does not exists <<%Z>>\n",i_keyfile.c_str());
		seppuku();
	}
	int64_t dimensionekeyfile=prendidimensionefile(i_keyfile.c_str());
	if (dimensionekeyfile<=4096)
	{
		myprintf("83270: Keyfile <<%Z>> too small (must be >=4KB) %s\n",i_keyfile.c_str(),migliaia(dimensionekeyfile));
		seppuku();
	}
	if (dimensionekeyfile>50000000)
	{
		myprintf("83243: Keyfile <<%Z>> too large (cannot be larger than 50.000.000) %s\n",i_keyfile.c_str(),migliaia(dimensionekeyfile));
		seppuku();
	}

	
	double entropy = calculate_entropy(i_keyfile.c_str());
	if (entropy >= 0.0) 
	{
		int risultato=evaluate_key_suitability(entropy,false);
		if (risultato>0)
		{
			myprintf("83280: File not good for crypto <<%Z>> (low entropy)\n",i_keyfile.c_str());
			seppuku();
		}
		franz_do_hash dummy("WHIRLPOOL");
		int64_t starthash=mtime();
		string 	hashkeyfile=dummy.filehash(0,i_keyfile,false,starthash,dimensionekeyfile);
		if (hashkeyfile=="")
		{
			myprintf("83420: Cannot get keyfile hash\n");
			seppuku();
		}
		string 	base58=hexToBase58(hashkeyfile);
		std::string newhash=base58ToHexWrapper(base58);
		if (flagdebug)
		{
			myprintf("81375: [1] hash         :%s\n",hashkeyfile.c_str());
			myprintf("81423: [2] newhash      :%s\n",newhash.c_str());
			color_green();
			myprintf("83433: [3] encoded  key :%s (KEEP THIS ONE SAFE!)\n",base58.c_str());
			color_restore();
		}
		return base58;
	}
	else
	{
		myprintf("83283: strange entropy for %s\n",i_keyfile.c_str());
		seppuku();
	}
	
	seppuku();
	return "";
}

std::string translateString(const std::string& input) 
{
    // Configuration constants
    const int COLUMNS = 5;                    // Number of columns
    const int COLUMN_SPACING = 0;             // Spaces between columns
    const char* UPPERCASE_LABEL = "UP";    // Label for uppercase
    const int PHONETIC_WIDTH = 9;             // Larghezza campo fonetico (%-5s)
    const int ALIGNMENT_SPACES = strlen(UPPERCASE_LABEL);  // Alignment spaces based on label length
    
    // Array for digits
    const char* digits[] = {
        "ZERO", "ONE", "TWO", "THREE", "FOUR",
        "FIVE", "SIX", "SEVEN", "EIGHT", "NINE"
    };
    
    // Array for the uppercase ICAO phonetic alphabet
    const char* phonetic_upper[] = {
        "ALPHA", "BRAVO", "CHARLIE", "DELTA", "ECHO",
        "FOXTROT", "GOLF", "HOTEL", "INDIA", "JULIET",
        "KILO", "LIMA", "MIKE", "NOVEMBER", "OSCAR",
        "PAPA", "QUEBEC", "ROMEO", "SIERRA", "TANGO",
        "UNIFORM", "VICTOR", "WHISKEY", "XRAY", "YANKEE", "ZULU"
    };
    
    // Array for the lowercase ICAO phonetic alphabet
    const char* phonetic_lower[] = {
        "alpha", "bravo", "charlie", "delta", "echo",
        "foxtrot", "golf", "hotel", "india", "juliet",
        "kilo", "lima", "mike", "november", "oscar",
        "papa", "quebec", "romeo", "sierra", "tango",
        "uniform", "victor", "whiskey", "xray", "yankee", "zulu"
    };
    
    std::string result;  // String to return
    
    // Calculate the number of rows (division by COLUMNS with rounding up)
    size_t rows = (input.length() + COLUMNS - 1) / COLUMNS;
    
    for (size_t row = 0; row < rows; row++) {
        std::string line;  // Current line for the return string
        
        // Print COLUMNS characters per line, side by side
        for (int col = 0; col < COLUMNS; col++) {
            size_t index = col * rows + row;  // Sort by column
            
            if (index < input.length()) {
                char c = input[index];
                
                // Build the part for the return string
                char buffer[100];
                
                // Print the index (both on the console and in the string)
                snprintf(buffer,sizeof(buffer), "|%02d ", (int)index+1);
                line += buffer;
                printf("|%02d ", (int)index+1);
                
                color_green();
                snprintf(buffer,sizeof(buffer), "%c: ", c);
                line += buffer;
                printf("%c: ", c);
                color_restore();
                
                if (c >= '0' && c <= '9') {
                    // Digit
                    color_cyan();
                    snprintf(buffer,sizeof(buffer), "%-*s", PHONETIC_WIDTH, digits[c - '0']);
                    line += buffer;
                    printf("%-*s", PHONETIC_WIDTH, digits[c - '0']);
                    color_restore();
                    // Spaces to maintain column alignment (length of UPPERCASE_LABEL)
                    line += std::string(ALIGNMENT_SPACES, ' ');
                    printf("%*s", ALIGNMENT_SPACES, "");
                }
                else if (c >= 'A' && c <= 'Z') {
                    // Uppercase letter
                    color_cyan();
                    snprintf(buffer,sizeof(buffer),"%-*s", PHONETIC_WIDTH, phonetic_upper[c - 'A']);
                    line += buffer;
                    printf("%-*s", PHONETIC_WIDTH, phonetic_upper[c - 'A']);
                    color_restore();
                    color_yellow();
                    line += UPPERCASE_LABEL;
                    printf("%s", UPPERCASE_LABEL);
                    color_restore();
                }
                else if (c >= 'a' && c <= 'z') {
                    // Lowercase letter
                    color_cyan();
                    snprintf(buffer,sizeof(buffer), "%-*s", PHONETIC_WIDTH, phonetic_lower[c - 'a']);
                    line += buffer;
                    printf("%-*s", PHONETIC_WIDTH, phonetic_lower[c - 'a']);
                    color_restore();
                    line += std::string(ALIGNMENT_SPACES, ' ');
                    printf("%*s", ALIGNMENT_SPACES, "");
                }
                else {
                    // Special character or other
                    color_red();
                    line += "ERROR!";
                    printf("ERROR!");
                    color_restore();
                    seppuku();
                }
            }
            
            // Spacing between columns (except after the last one)
            if (col < COLUMNS - 1) {
                line += std::string(COLUMN_SPACING, ' ');
                printf("%*s", COLUMN_SPACING, "");
            }
        }
        
        // Add the line to the result and print the newline
        result += line + "\n";
        printf("\n");
    }
    
    return result;
}

void formatAndSplitStringInFourParts(
    const std::string& inputString,
    std::string& o_output1,
    std::string& o_output2,
    std::string& o_output3,
    std::string& o_output4)
{
    // Clear output strings to ensure no previous data lingers
    o_output1.clear();
    o_output2.clear();
    o_output3.clear();
    o_output4.clear();

    if (inputString.empty()) {
        return; // Nothing to process
    }

    // Step 1: Format the string with spaces every 4 characters
    std::string formattedString;
    formattedString.reserve(inputString.length() + (inputString.length() + 3) / 4);

    for (size_t i = 0; i < inputString.length(); ++i) {
        formattedString.push_back(inputString[i]);
        // Add a space after every 4 characters, except at the end of the string
        if ((i + 1) % 4 == 0 && i != inputString.length() - 1) {
            formattedString.push_back(' ');
        }
    }

    // Step 2: Split into four parts, each containing up to 5 blocks of 4 characters
    // Each block is 4 chars + 1 space = 5 chars (except possibly the last block)
    size_t charsPerPart = 5 * 5; // 5 blocks of (4 chars + 1 space) = 25 chars per part
    size_t currentStart = 0;

    // Part 1: First 5 blocks (up to 25 characters)
    o_output1 = formattedString.substr(currentStart, charsPerPart);
    currentStart += charsPerPart;

    // Part 2: Next 5 blocks
    o_output2 = formattedString.substr(currentStart, charsPerPart);
    currentStart += charsPerPart;

    // Part 3: Next 5 blocks
    o_output3 = formattedString.substr(currentStart, charsPerPart);
    currentStart += charsPerPart;

    // Part 4: Remaining characters
    o_output4 = formattedString.substr(currentStart);
}

int Jidac::work()
{
	
    if (files.size() < 1)
    {
        myprintf("03432! no parameter, sorry\n");
        return 2;
    }
 
    string mycommand = files[0];
#ifdef ZPAQFULL ///NOSFTPSTART
#ifdef _WIN32
    if (mycommand == "resetacl")
    {        
		if (files.size() != 2)
        {
            myprintf("94738: You must enter a folder\n");
            return 1;
        }

        if (!direxists(files[1]))
		{
			myprintf("94832$ Cannot find folder <<%Z>>\n", files[1].c_str());
			return 2;
		}

		string	filebatch	=g_gettempdirectory()+"resetacl.bat";
		filebatch=nomefileseesistegia(filebatch);
		if (fileexists(filebatch))
			if (remove(filebatch.c_str())!=0)
			{
				myprintf("95536! Highlander batch  %s\n", filebatch.c_str());
				return 2;
			}
		FILE* batch=fopen(filebatch.c_str(), "wb");
		if (batch==NULL)
		{
			myprintf("95342! cannot write on %s\n",filebatch.c_str());
			seppuku();
		}
		string thefile=files[1];
		myreplaceall(thefile,"/","\\");
		fprintf(batch,"@echo OFF\n");
		fprintf(batch, "SET DIRECTORY_NAME=\"%s\"\n", thefile.c_str());
		fprintf(batch,"TAKEOWN /f %%DIRECTORY_NAME%% /r /d s\n");
		fprintf(batch,"ICACLS %%DIRECTORY_NAME%% /grant administrators:F /t\n");
		fprintf(batch,"ICACLS %%DIRECTORY_NAME%% /reset /T\n");
		fclose(batch);

		if (flagdebug3)
			myprintf("95356: The file batch is <<%Z>>\n",filebatch.c_str());
		else
			waitexecutepadre(filebatch,"");
		
		if (!flagdebug)
			remove_temp_file(filebatch);

		return 0;
    }
#endif
#endif ///NOSFTPEND

	if ((mycommand=="date") || (mycommand=="datetime") || (mycommand=="time"))
	{
		if (files.size()==1)
			myprintf("%s\n",dateToString(true,now()).c_str());
		else
		{
			string thedate=format_datetime(files[1].c_str());
			myprintf("%s\n",thedate.c_str());
		}
		return 0;
	}
	if ((mycommand=="datebig") || (mycommand=="datetimebig") || (mycommand=="timebig"))
	{
		if (files.size()==1)
			printDigitalString(dateToString(true,now()).c_str());
		else
		{
			string thedate=format_datetime(files[1].c_str());
			printDigitalString(thedate.c_str());
		}
		return 0;
	}

	if (mycommand=="printbar")
	{
		if (files.size()==1)
			printbar('-');
		else
			printbar(files[1].at(0));
		return 0;
	}
#ifdef _WIN32	
	if (mycommand=="monitoroff")
	{
		SendMessage(HWND_BROADCAST, WM_SYSCOMMAND, SC_MONITORPOWER,2);
		return 0;
	}
	if (mycommand=="monitoron")
	{
		SendMessage(HWND_BROADCAST, WM_SYSCOMMAND, SC_MONITORPOWER,-1);
		return 0;
	}
#endif
	if ((mycommand=="lastfile")  || (mycommand=="last"))
	{
		if (files.size()<2)
		{
			myprintf("83340: You need at least one pattern ex z:\\pippo*.zpaq\n");
			return 2;
		}
		flagskipzfs					=true;  // strip down zfs

		g_bytescanned=0;
		g_filescanned=0;
		g_dimensione=0;
		g_worked=0;
	
		for (unsigned i=0; i<files.size(); ++i)
			scandir(true,edt,files[i].c_str());
		eol();
		if (!edt.empty()) 
		{
			if (!flagterse)
			{
				myprintf("\n");
				myprintf("Last file\n");
			}
			if (mycommand=="lastfile")
			myprintf("%Z\n", extractfilename(edt.rbegin()->first).c_str());
			else
			myprintf("%Z\n", edt.rbegin()->first.c_str());
			return 0;
		} 
		return 2;
	}
	if ((mycommand=="getsize"))
	{
		if (files.size()<2)
		{
			myprintf("83440: You need at LEAST ONE parameter\n");
			return 2;
		}
		
		flagskipzfs					=true;  // strip down zfs

		g_bytescanned=0;
		g_filescanned=0;
		g_dimensione=0;
		g_worked=0;
	
		for (unsigned i=0; i<files.size(); ++i)
			scandir(true,edt,files[i].c_str());
		
		///myprintf("\r");
		eol();
		int64_t dimensionetotale=0;
		int		scritti=0;
		for (DTMap::iterator a=edt.begin(); a!=edt.end(); ++a)
		{	
			if (!isdirectory(a->first))
			{
				int64_t dimensione=prendidimensionefile(a->first.c_str());
				if (dimensione<0)
				{
					color_red();
					myprintf("72637: Cannot find <<%Z>>\n",a->first.c_str());
					color_restore();
					return 2;
				}
				else
				{
					myprintf("72633: Size  %21s (%10s) <<%Z>>\n",migliaia(dimensione),tohuman(dimensione),a->first.c_str());
					dimensionetotale+=dimensione;
					scritti++;
				}
			}
		}
		if (scritti>1)
		{
			color_green();
			myprintf("72631: Total %21s (%10s)\n",migliaia(dimensionetotale),tohuman(dimensionetotale));
			color_restore();
		}
		
		return 0;
	}

	if (mycommand=="devart")
	{
		for (unsigned int i=1;i<files.size();i++)
			printDigitalString(files[i].c_str());
		return 0;
	}
	if (mycommand=="devart-red")
	{
		color_red();
		for (unsigned int i=1;i<files.size();i++)
			printDigitalString(files[i].c_str());
		color_restore();
		return 0;
	}
	if (mycommand=="devart-green")
	{
		color_green();
		for (unsigned int i=1;i<files.size();i++)
			printDigitalString(files[i].c_str());
		color_restore();
		return 0;
	}
	if (mycommand=="devart-yellow")
	{
		color_yellow();
		for (unsigned int i=1;i<files.size();i++)
			printDigitalString(files[i].c_str());
		color_restore();
		return 0;
	}
	if (mycommand=="devart-green")
	{
		color_green();
		for (unsigned int i=1;i<files.size();i++)
			printDigitalString(files[i].c_str());
		color_restore();
		return 0;
	}



	if (mycommand=="big")
	{
		for (unsigned int i=1;i<files.size();i++)
		{
			ascii::Ascii font=ascii::Ascii();
			font.print(files[i].c_str());
		}
		return 0;
	}
#ifdef ZPAQFULL ///NOSFTPSTART
	if (mycommand=="shutdown")
		return systemshutdown();
	
	if (mycommand=="turbo")
	{
		myprintf("69833$ Setting CPU to full power\n");
		maxcpu(100);
		return 0;
	}
	if (mycommand=="noturbo")
	{
		myprintf("93232$ Limit CPU power (disable TurboBoost)\n");
		maxcpu(99);
		return 0;
	}
#endif ///NOSFTPEND
	if (mycommand=="pad")
	{
		if (files.size()!=2)
		{
			myprintf("03433! pad command needs 1 more parameter\n");
			return 2;
		}
		string thestring=files[1];
		
		for (unsigned int i=0;i<thestring.size();i++)
			if (!isdigit(thestring[i]))
			{
				myprintf("03434! Only digits are allowed\n");
				return 2;
			}
		if (menoenne==0)
			menoenne=8;
		while (thestring.size()<menoenne)
			thestring="0"+thestring;
		myprintf("%s\n",thestring.c_str());
		return 0;
	}
	
	if (mycommand=="filepathnotrailing")
	{
		if (files.size()!=2)
		{
			myprintf("03435! filepathnotrailing command needs 1 more parameter\n");
			return 2;
		}
		string thestring=files[1];
#ifdef _WIN32		
		thestring=wintolinuxpath(thestring);
#endif // corresponds to #ifdef (#ifdef _WIN32		)
		thestring=extractfilepath(thestring);
		
#ifdef _WIN32		
		thestring=linuxtowinpath(thestring);
#endif // corresponds to #ifdef (#ifdef _WIN32		)
		thestring=excludetrailingbackslash(thestring);
		myprintf("%s\n",thestring.c_str());
		return 0;
	}

	if (mycommand=="fileexists")
	{
		if (files.size()!=2)
		{
			myprintf("03436! fileexists command needs 1 more parameter\n");
			return 2;
		}
		string thefile=files[1];
		if (fileexists(thefile))
			return 0;
		return 2;
	}
	if (mycommand=="nomefileseesistegia")
	{
		if (files.size()!=2)
		{
			myprintf("03437! nomefileseesistegia command needs 1 more parameter\n");
			return 2;
		}
		string thefile=files[1];
		string newfile=nomefileseesistegia(thefile);
		myprintf("%s\n",newfile.c_str());
		return 0;
	}
	if (mycommand=="prendinomefileebasta")
	{
		if (files.size()!=2)
		{
			myprintf("03438! prendinomefileebasta command needs 1 more parameter\n");
			return 2;
		}
		string thefile=files[1];
		string newfile=prendinomefileebasta(thefile);
		myprintf("%s\n",newfile.c_str());
		return 0;
	}
	if (mycommand=="linuxtowindows")
	{
		if (files.size()!=2)
		{
			myprintf("03439! linuxtowindows command needs 1 more parameter\n");
			return 2;
		}
		string thefile=files[1];
		myreplaceall(thefile,"/","\\");
		myprintf("%s\n",thefile.c_str());
		return 0;
	}

	if (mycommand=="includetrailingbackslash")
	{
		if (files.size()!=2)
		{
			myprintf("03440! includetrailingbackslash command needs 1 more parameter\n");
			return 2;
		}
		string thestring=files[1];
#ifdef _WIN32		
		thestring=wintolinuxpath(thestring);
#endif // corresponds to #ifdef (#ifdef _WIN32		)
		thestring=includetrailingbackslash(thestring);
		
#ifdef _WIN32		
		thestring=linuxtowinpath(thestring);
#endif // corresponds to #ifdef (#ifdef _WIN32		)
		myprintf("%s\n",thestring.c_str());
		return 0;
	}
	
	if (mycommand=="keyfile")
	{
		if (files.size()!=2)
		{
			myprintf("03445! keyfile command needs 1 more parameter\n");
			return 2;
		}
		string keyfile=files[1];
		if (!fileexists(keyfile.c_str()))
		{
			myprintf("83294: Cannot open keyfile\n");
			return 2;
		}
		int64_t dimensionekeyfile=prendidimensionefile(keyfile.c_str());
		if (dimensionekeyfile<=4096)
		{
			myprintf("83240: Keyfile too small (must be >=4KB) %s\n",migliaia(dimensionekeyfile));
			return 2;
		}
		if (dimensionekeyfile>50000000)
		{
			myprintf("83240: Keyfile too large (cannot be larger than 50.000.000) %s\n",migliaia(dimensionekeyfile));
			return 2;
		}
	
		double entropy = calculate_entropy(keyfile.c_str());
		if (entropy >= 0.0) 
		{
			int risultato=evaluate_key_suitability(entropy,true);
			if (risultato>0)
				return risultato;
			
			franz_do_hash dummy("WHIRLPOOL");
			int64_t starthash=mtime();
			int64_t dimensionekeyfile=prendidimensionefile(keyfile.c_str());
			string 	hashkeyfile=dummy.filehash(0,keyfile,false,starthash,dimensionekeyfile);
			if (hashkeyfile=="")
			{
				myprintf("83420: Cannot get hash\n");
				return 2;
			}
			string 	base58=hexToBase58(hashkeyfile);
			std::string newhash=base58ToHexWrapper(base58);
			
			string doublecheck=keyfile_to_string(keyfile);
			if (doublecheck!=base58)
			{
				myprintf("83717: Internal error!\n");
				seppuku();
			}
			
			if (flagverbose)
			{
				myprintf("83375: hash   : %s\n",hashkeyfile.c_str());
				myprintf("83423: newhash: %s\n",newhash.c_str());
			}
			
			string spaced1;
			string spaced2;
			string spaced3;
			string spaced4;
			
			formatAndSplitStringInFourParts(base58,spaced1,spaced2,spaced3,spaced4);
			string rebuilt=spaced1+spaced2+spaced3+spaced4;
			myreplaceall(rebuilt," ","");
			
			if (rebuilt!=base58)
			{
				myprintf("83889: INTERNAL GURU, rebuild != base58\n");
				seppuku();
			}
			color_green();
			myprintf("83423: encoded: %s\n",base58.c_str());
			myprintf("84000: <<%Z>>\n",keyfile.c_str());
			color_restore();
	
			string icao=translateString(base58);
			
			color_green();
			myprintf("83424: %s%s\n",spaced1.c_str(),spaced2.c_str());
			myprintf("83422: %s%s\n",spaced3.c_str(),spaced4.c_str());
			color_restore();
			
			
			color_yellow();
			myprintf("THIS KEY IS  CRITICAL. Guard it. Losing it means losing your data.\n");
			myprintf("PRIMARY    : Print on paper. Store safely offline.\n");
			myprintf("SECONDARY  : Save  to secure USB drive.\n");
			myprintf("LAST RESORT: Photograph with extreme caution. Avoid cloud auto-upload!\n");
			color_restore();

#ifdef _WIN32
			base58+="\n";
			base58+=icao+"\n";
			base58+=spaced1+"\n";
			base58+=spaced2+"\n";
			base58+=spaced3+"\n";
			base58+=spaced4+"\n";
			
			if (OpenClipboard(NULL)) 
			{
				EmptyClipboard();
				const size_t len = base58.size()+1;
				HGLOBAL hMem = GlobalAlloc(GMEM_MOVEABLE, len);
				if (hMem==NULL) 
				{
					myprintf("05235$ Error allocating Global!\n");
					CloseClipboard();
				}
				else
				{
					memcpy(GlobalLock(hMem),base58.c_str(), len);
					GlobalUnlock(hMem);
					SetClipboardData(CF_TEXT, hMem);
					CloseClipboard();
					myprintf("\n");
					color_green();
					myprintf("83800: Crucial KEY data copied on clipboard. Please safekeeping!\n");
					color_restore();
				}
			}
#endif
		} 
		else 
		{
			myprintf("83304: Cannot get entropy\n");
			return 1;
		}
		return 0;
  	}
	
	
	if (mycommand=="checkspace")
	{
		if (files.size()<3)
		{
			myprintf("84418! for checkspace you need one or more couples\n");
			return 2;
		}
		
		
		// Check if the total number of parameters is odd (excluding the first)
		int risultato=0;
		if ((files.size() - 1) % 2 != 0)
		{
			myprintf("84420: Invalid parameters\n");
			return 2;
		}

		myprintf("84424: Now is %s\n",dateToString(true,now()).c_str());
	
		for (unsigned int i = 1; i < files.size(); i += 2)
		{
			// Check that there is a complete pair (path + space)
			if (i + 1 >= files.size())
			{
				myprintf("84438! Path '%s' without minimum space\n", files[i].c_str());
				break;
			}
			
			string percorso = files[i];
			percorso = includetrailingbackslash(percorso);
			
			int64_t spaziopresente = getfreespace(percorso);
			if (spaziopresente < 0)
				spaziopresente = 0;
			
			int64_t spaziominimo = myatoll(files[i + 1].c_str());
			if (spaziominimo < 0)
				spaziominimo = 0;
			
			// Calculation of the result
			string status;
			if (spaziominimo == 0)
			{
				status = "OK"; // If there is no minimum requirement, it's always OK
				color_green();
			}
			else if (spaziopresente >= spaziominimo * 1.1) // +10%
			{
				status = "OK";
				color_green();
			}
			else if (spaziopresente >= spaziominimo) // Above but <10%
			{
				status = "WARN";
				color_yellow();
				risultato=2;
			}
			else // Below the minimum
			{
				status = "ERROR";
				color_red();
				risultato=2;
			}
			
			myprintf("84464: Free %10s min %10s Status: %-5s <<%Z>>\n", 
					 tohuman(spaziopresente), 
					 tohuman2(spaziominimo), 
					 status.c_str(),
					 percorso.c_str());
			color_restore();
		}
		
		return risultato;
		
	}
#ifdef ZPAQFULL ///NOSFTPSTART

	if ((mycommand=="encode") || (mycommand=="decode"))
	{
		bool flagencode=(mycommand=="encode");
		string myencode		="decode";
		string myencrypted	="decrypted";
		
		if (flagencode)
		{
			myencode		="encode";
			myencrypted		="encrypted";
		}
		if (flagdebug)
			for (unsigned int i=0;i<files.size();i++)
				myprintf("85465: %03d %s\n",i,files[i].c_str());
		
		if ((files.size()!=4))
		{
			myprintf("83418! for %s you need 1) source file 2) dest %s file 3) password (the longer the better)\n",myencode.c_str(),myencrypted.c_str());
			return 2;
		}
		
		string input_filename	=files[1];
		string output_filename	=files[2];
		string thepassword		=files[3];
		
		int threads=howmanythreads;
		if (threads<=0)
			threads=1;
		if (!flagssd)
			threads=1;
		
		int64_t dimensione=prendidimensionefile(input_filename.c_str());
		int64_t startenc=mtime();
		bool success=false;
			
		franzcri fc(thepassword.c_str(),thepassword.length());
		
		if (flagencode)
		{
			if (threads==1)
				myprintf("86083: Single thread encrypting <<%s>> to <<%s>>\n", input_filename.c_str(), output_filename.c_str());
			else
				myprintf("86083: Multi thread encrypting <<%s>> to <<%s>> with %d...\n", input_filename.c_str(), output_filename.c_str(),threads);
			success = fc.encode_parallela(input_filename.c_str(), output_filename.c_str(),threads);
		}
		else
		{
			if (threads==1)
				myprintf("86083: Single thread decrypting <<%s>> to <<%s>>\n", input_filename.c_str(), output_filename.c_str());
			else
				myprintf("86083: Multi thread decrypting <<%s>> to <<%s>> with %d...\n", input_filename.c_str(), output_filename.c_str(),threads);
			success = fc.decode_parallela(input_filename.c_str(), output_filename.c_str(),threads);
		}

		double  tempo=(mtime()-startenc)/1000.0;
		
		eol();
		if (success) 
		{
			color_green();
			myprintf("OK %s (%s) in %f @ %s/s\n",migliaia(dimensione),tohuman(dimensione),tempo,tohuman2(dimensione/tempo));
			color_restore();
			return 0;
		} 
		else 
		{
			color_red();
			myprintf("!FAILED!\n");
			color_restore();
			return 2;
		}
		return 2;
		
			
			/*
			franz_do_hash dummy("CRC-32");
			string crc32_reloaded=dummy.filehash(128,output_filename,false,0,prendidimensionefile(output_filename.c_str()));
			myprintf("CRC32 reloaded %s\n",crc32_reloaded.c_str());
			*/
	}
	

	if ((mycommand=="test"))
	{
		if (flagdebug)
			for (unsigned int i=0;i<files.size();i++)
				myprintf("85465: %03d %s\n",i,files[i].c_str());
		
		if ((files.size()!=3))
		{
			myprintf("83218! for encodetest you need 1) source file 2) password\n");
			return 2;
		}
		
		string input_filename	=files[1];
		string thepassword		=files[2];
		
		int threads=howmanythreads;
		if (threads<=0)
			threads=1;
		if (!flagssd)
			threads=1;
		
		int64_t dimensione=prendidimensionefile(input_filename.c_str());
		int64_t startenc=mtime();
		bool success=false;		
				
		franzcri fc(thepassword.c_str(),thepassword.length());
		if (threads==1)
			myprintf("86183: Single thread test <<%s>>\n", input_filename.c_str());
		else
			myprintf("86083: Multi thread test <<%s>> with %d...\n", input_filename.c_str(), threads);
		success = fc.decode_parallela(input_filename.c_str(), NULL,threads);
		
		double  tempo=(mtime()-startenc)/1000.0;
		
		eol();
		if (success) 
		{
			color_green();
			myprintf("OK %s (%s) in %f @ %s/s\n",migliaia(dimensione),tohuman(dimensione),tempo,tohuman2(dimensione/tempo));
			color_restore();
			return 0;
		} 
		else 
		{
			color_red();
			myprintf("!FAILED!\n");
			color_restore();
			return 2;
		}
		return 2;
	}
	
	
	if ((mycommand=="fulltest"))
	{
		if ((files.size()!=4))
		{
			myprintf("88160! for fulltest you need 1) source file 2) dest file base 3) password (the longer the better)\n");
			return 2;
		}
		
		string input_filename	=files[1];
		string output_filename	=files[2];
		string thepassword		=files[3];
		
		int threads=howmanythreads;
		if (threads<=0)
			threads=1;
		if (!flagssd)
			threads=1;

		if (threads==1)
			myprintf("84083: Single thread full test <<%s>> to <<%s>>\n", input_filename.c_str(), output_filename.c_str());
		else
			myprintf("82083: Multi thread full test <<%s>> to <<%s>> with %d...\n", input_filename.c_str(), output_filename.c_str(),threads);
				
		franzcri fc(thepassword.c_str(),thepassword.length());
		bool success = fc.fulltest(input_filename.c_str(), output_filename.c_str(),thepassword,threads);
		eol();
		if (success) 
			return 0;
		return 2;
	}

	if (mycommand=="autotest")
	{
        franzcri fc("password123",strlen("password12"));
        return fc.criautotest() ? 0 : 2;
	}
	
	if (mycommand == "crc32")
	{
		if (flagdebug)
			for (size_t i = 0; i < files.size(); ++i)
				myprintf("85465: %03d %s\n", (int)i, files[i].c_str());

		if (files.size() != 2)
		{
			myprintf("83218! For crc-32 you need 1) source file\n");
			return 2;
		}
		const std::string& input_filename = files[1];

		franzcri fc("dummy",strlen("dummy"));
		uint32_t thecrcstored = fc.get_crc32(input_filename.c_str());
		if (thecrcstored == 0)
		{
			myprintf("89048: Cannot get the CRC stored!\n");
			return 2;
		}
		std::string s_thecrcstored = bin2hex_32(thecrcstored);

		int64_t file_header_size = sizeof(file_header) + 12; // (int64_t)sizeof(header_nonce)
		if (flagdebug)
			myprintf("88967: Skipping %s\n", migliaia(file_header_size));

		franz_do_hash dummy("CRC-32");
		std::string crc32_reloaded = dummy.filehash(
			file_header_size,
			input_filename,
			false,
			mtime(),
			prendidimensionefile(input_filename.c_str())
		);

		eol();


		if (flagverbose)
		{
			myprintf("89062: CRC-32 reloaded %s\n", crc32_reloaded.c_str());
			myprintf("89063: CRC-32 stored   %s\n", s_thecrcstored.c_str());
		}

		if (crc32_reloaded == s_thecrcstored)
		{
			color_green();
			myprintf("89063: CRC-32 match, this is good! %s\n",crc32_reloaded.c_str());
			color_restore();
			return 0;
		}

		color_red();
		myprintf("89069: CRC32 reloaded %s != CRC32 stored %s\n",
				 crc32_reloaded.c_str(), s_thecrcstored.c_str());
		color_restore();

		return 2;
	}

	if (mycommand=="autotest")
	{
        franzcri fc("password123",strlen("password12"));
        return fc.criautotest() ? 0 : 2;
	}
	
	if (mycommand == "ispasswordok")
	{
		if (flagdebug)
			for (size_t i = 0; i < files.size(); ++i)
				myprintf("85465: %03d %s\n", (int)i, files[i].c_str());

		if (files.size() != 3)
		{
			myprintf("83218! For ispasswordok you need 1) source file 2) password\n");
			return 2;
		}
		const std::string& input_filename = files[1];
		string thepassword		=files[2];

		franzcri fc(thepassword.c_str(),thepassword.length());
		if (fc.is_password_ok(input_filename.c_str()))
		{
			color_green();
			myprintf("90474: PASSWORD IS GOOD\n");
			color_restore();
			return 0;
		}

		color_red();
		myprintf("90480: PASSWORD NOT GOOD\n");
		color_restore();

		return 2;
	}


	
#endif ///NOSFTPEND

	myprintf("03441! Do not understand the command\n");
	return 2;
}


#ifdef ZPAQFULL ///NOSFTPSTART
int	Jidac::external()
{
	if (g_externalname=="")
	{
		myprintf("03442! g_externalname empty\n");
		return 2;
	}
	if (mypos(">",g_externalname)!=-1)
	{
		myprintf("03443! sorry, cannot use > in -external %s\n",g_externalname.c_str());
		return 2;
	}

	string outputfile=g_gettempdirectory()+"VFILE-l-external.txt";
#ifdef _WIN32
	myreplaceall(outputfile,"\\","/");
#endif // corresponds to #ifdef (#ifdef _WIN32)
	outputfile=nomefileseesistegia(outputfile);
	string percorso=extractfilepath(outputfile);
	if (!saggiascrivibilitacartella(percorso))
	{
		myprintf("03444! cannot write on |%s|\n",percorso.c_str());
		return 2;
	}
	string thefiles="";
	for (unsigned int i=0;i<files.size();i++)
		thefiles+=files[i]+" ";
	if (flagverbose)
		myprintf("03445: Thefiles %d |%s|\n",files.size(),thefiles.c_str());
	
#ifdef _WIN32
	myreplaceall(g_externalname,	"/","\\");
	myreplaceall(outputfile,		"/","\\");
#endif // corresponds to #ifdef (#ifdef _WIN32)
	if (flagverbose)
		myprintf("03446: Params       |%s|\n",g_externalname.c_str());

	string singleline=g_externalname+" >"+outputfile;
	myreplaceall(singleline,"%files",thefiles);
	myreplaceall(singleline,"$files",thefiles);
	if (flagverbose)
		myprintf("03447: executing %s\n",singleline.c_str());
	
	string	filebatch	=g_gettempdirectory()+"ext.bat";
	filebatch=nomefileseesistegia(filebatch);
	print_datetime();
	myprintf("03448: Starting External \n");
	if (fileexists(filebatch))
		if (remove(filebatch.c_str())!=0)
		{
			myprintf("03449! Highlander batch  %s\n", filebatch.c_str());
			return 2;
		}
	FILE* batch=fopen(filebatch.c_str(), "wb");
	if (batch==NULL)
	{
		myprintf("03450! cannot write on %s\n",filebatch.c_str());
		seppuku();
	}

#ifdef _WIN32
	fprintf(batch,"@echo OFF\n");
#endif // corresponds to #ifdef (#ifdef _WIN32)
	fprintf(batch,"%s\n",singleline.c_str());
	fclose(batch);
	int64_t startexternal=mtime();
#ifdef _WIN32
	waitexecute(filebatch,"",SW_HIDE);
#else
	if (chmod(filebatch.c_str(),0700)!=0)
	{
		myprintf("03451! error on chmod 700 on <<%s>>\n",filebatch.c_str());
		return 2;
	}
	exec(filebatch.c_str());
#endif // corresponds to #ifdef (#ifdef _WIN32)
	print_datetime();
	myprintf("03452: External time %s output filesize %s\n",migliaia(mtime()-startexternal),migliaia2(prendidimensionefile(outputfile.c_str())));
	
	if (!fileexists(outputfile))
	{
		myprintf("03453! i_output file does not exists %s\n",outputfile.c_str());
		return 2;
	}
	
	int64_t dimensionelista=0;
	int64_t dimensionedata=0;
	int64_t dimensioneattr=0;
	if (getfileinfo(outputfile,dimensionelista,dimensionedata,dimensioneattr))
		addfile(false,edt,outputfile,dimensionedata,dimensionelista,dimensioneattr,0,0);

	return 0;
}
#endif ///NOSFTPEND

string Jidac::getbackupnameifany(const string i_filename)
{
	if (flagdebug)
		myprintf("03454: getbackupname %Z\n",i_filename.c_str());
	
	if (i_filename=="")
	{
		if (flagdebug)
			myprintf("03455! getbackupnameifany empty\n");
		return "";
	}
	if (iswildcards(i_filename))
	{
		if (flagdebug)
			myprintf("03456: getbackupnameifany wildcards <<%Z>>\n",i_filename.c_str());
		return i_filename;
	}
	string temp	=extractfilepath(i_filename)+prendinomefileebasta(i_filename)+"_00000001.zpaq";
	string temp2=extractfilepath(i_filename)+prendinomefileebasta(i_filename)+"_00000000_backup.index";
	string temp3=extractfilepath(i_filename)+prendinomefileebasta(i_filename)+"_00000000_backup.txt";

	if (fileexists(temp))
	{
		if (flagdebug)
			myprintf("03457: temp backup file name EXIST <<%Z>>\n",temp.c_str());
		if (fileexists(temp2))
		{
			if (flagdebug)
				myprintf("03458: temp2 backup file name EXIST <<%Z>>\n",temp2.c_str());
			if (fileexists(temp3))
			{
				if (flagdebug)
					myprintf("03459: temp3 backup file name EXIST <<%Z>>\n",temp3.c_str());
				string finale	=extractfilepath(i_filename)+prendinomefileebasta(i_filename)+"_????????.zpaq";
	
				return finale;
			}
		}
	}
	if (flagdebug)
		myprintf("03460: cannot find backup files\n");
	return i_filename;
}


bool compareSecond(const std::pair<std::string, std::string> &a,
                   const std::pair<std::string, std::string> &b) {
    return a.second < b.second;
}

string shrinkstring(const string i_string,unsigned int i_len)
{
	/// 8 ABCDEFGHIJKL ABC...KL
	if (i_string=="")
		return "";
	if (i_len==0)
		return "";
	if (i_len>i_string.size())
		return i_string;
	 if (i_len < 4) 
        return i_string.substr(0, i_len);  // Simply cut to the first i_len characters
    int head_len = (i_len - 3) / 2;
    int tail_len = i_len - 3 - head_len;
    return i_string.substr(0, head_len)+"..."+i_string.substr(i_string.length() - tail_len);
}


int Jidac::sumhome()
{
	if (files.size()!=1)
	{
		myprintf("03462! you need exactly 1 folder selection => quit (ex. /home)\n");
		return 2;
	}

	string	basehome=files[0];
	if (!isdirectory(basehome))
		basehome+="/";
	vector<string> candidate;
	listfolders(basehome,&candidate);
	if (flagdebug)
		myprintf("03463: candidate %s with pattern %s\n",migliaia(candidate.size()),fullarchive.c_str());
	
	if (candidate.size()==0)
	{
		myprintf("03464: Sorry, cannot find FOLDERS in <<%Z>>\n",basehome.c_str());
		return 1;
	}
	myprintf("03465: Founded %s folders, running on %s\n",migliaia(candidate.size()),g_thechosenhash_str.c_str());
	
	
	vector<string> 			outcome;
	vector<s_stringpair> 	risultati;
	///string 	basearchive		=archive;
	int64_t starthome		=mtime();
	int64_t	totaldalavorare	=0;
	int		totalfiles		=0;
	
	for (unsigned int i=0;i<candidate.size();i++)
	{
		string sourcepath=basehome+candidate[i];
		if (!isdirectory(sourcepath))
			sourcepath+="/";
		printbar('-');
		string temp=sourcepath;
		replace(temp,files[0],"");
		myprintf("03466: Working on %08d/%08d  <<%Z>>\n",i+1,candidate.size(),temp.c_str());

		edt.clear();
		int64_t startscan=mtime();
		scandir(false,edt,sourcepath,true);
		int64_t scantime=mtime()-startscan;
		
		vector<string> filearray;
		int64_t dalavorare=0;
		for (DTMap::iterator p=edt.begin(); p!=edt.end(); ++p)
			if (!isdirectory(p->first))
			{
				dalavorare+=p->second.size;
				filearray.push_back(p->first);
				totalfiles++;
			}
		totaldalavorare+=dalavorare;
		myprintf("03467: %-10s%19s (%10s) in %s files (t=%.2fs)       \n",g_thechosenhash_str.c_str(),migliaia(dalavorare),tohuman(dalavorare),migliaia2(filearray.size()),scantime/1000.0);
		
		vector<std::pair<string,string> > hash_pair;

		int64_t starthash=mtime();
		franzparallelhashfiles(g_thechosenhash_str,dalavorare,filearray,true,hash_pair);

		int64_t tempospeso=mtime()-starthash;
		if (tempospeso==0)
			tempospeso++;
		
		if (flagdebug3)
		{
			myprintf("03468: Before sort\n");
			for (unsigned int i=0;i<hash_pair.size();i++)
				myprintf("03469: hash_pair %08d second %s first %s\n",i,hash_pair[i].second.c_str(),hash_pair[i].first.c_str());
		}
		
		std::sort(hash_pair.begin(), hash_pair.end(), compareSecond);
  	
		if (flagdebug3)
		{
			myprintf("03470: After sort\n");
			for (unsigned int i=0;i<hash_pair.size();i++)
				myprintf("03471: hash_pair %08d second %s first %s\n",i,hash_pair[i].second.c_str(),hash_pair[i].first.c_str());
		}
	
		libzpaq::SHA256 sha256;
		for (unsigned int j=0;j<hash_pair.size();j++)
			for (const char* p=hash_pair[j].first.c_str(); *p; ++p)
				sha256.put(*p);
		
		char sha256result[32];
		memcpy(sha256result, sha256.result(), 32);
		string s_home=binarytohex((const unsigned char*)sha256result,32);

		string tagliato=shrinkstring(s_home,16*2+3);
		myprintf("03472: MAGIC: %s t=%.2fs @ %9s B/s\n",tagliato.c_str(),tempospeso/1000.0,
		migliaia(int64_t(dalavorare/(tempospeso/1000.0))));
			
		s_stringpair mypair;
		mypair.first	=sourcepath;
		mypair.second	=s_home;
		risultati.push_back(mypair);
		if (flagdebug3)
			myprintf("03473: pushed first %s second %s\n",mypair.first.c_str(),mypair.second.c_str());
		
	}

	std::sort(risultati.begin(), risultati.end(),pairsortbyval);
	libzpaq::SHA256 globalesha256;
	if (flagdebug3)
		myprintf("03474: Risultati size %d\n",risultati.size());	
	for (unsigned int j=0;j<risultati.size();j++)
	{
		if (flagdebug3)
			myprintf("03475: Global %03d second %s\n",j,risultati[j].second.c_str());
		for (const char* p=risultati[j].second.c_str(); *p; ++p)
			globalesha256.put(*p);
			
	}
	char sha256result[32];
	memcpy(sha256result,globalesha256.result(),32);
	string s_tutto=binarytohex((const unsigned char*)sha256result,32);
	
	printbar('-');
	myprintf("03476: Base folder <<%Z>>\n",files[0].c_str());
	for (unsigned int i=0;i<risultati.size();i++)
	{
		string temp=risultati[i].first;
		replace(temp,files[0],"");
		myprintf("03477: %s  <<%Z>>\n",risultati[i].second.c_str(),temp.c_str());
	}
	myprintf("\n");
	myprintf("03478: GLOBAL_MAGIC:      %s\n",s_tutto.c_str());
	
	int64_t miotempo=mtime()-starthome;
	if (miotempo==0)
		miotempo++;
	myprintf("03479: Hashed %10s: %s for %s bytes (%s) in %.2fs @ %s B/s\n",g_thechosenhash_str.c_str(),
	migliaia3(totalfiles),
	migliaia(totaldalavorare),
	tohuman(totaldalavorare),(miotempo/1000.0),migliaia2(int64_t(totaldalavorare/(miotempo/1000.0))));

	return 0;
}

/*
	backward-compatible file list
*/
int Jidac::list715() 
{
  // Read archive into dt, which may be "" for empty.
  int64_t csize=0;
	  	int errors=0;
  if (archive!="") 
	  csize=read_archive(NULL,archive.c_str(),&errors,1);

  // Read external files into edt
  for (unsigned i=0; i<files.size(); ++i)
	scandir(true,edt,files[i].c_str(),true);        // scan dirs to edt
  if (files.size()) printf("%d external files.\n", int(edt.size()));
  printf("\n");

  // Compute directory sizes as the sum of their contents
  DTMap* dp[2]={&dt, &edt};
  for (int i=0; i<2; ++i) {
    for (DTMap::iterator p=dp[i]->begin(); p!=dp[i]->end(); ++p) {
      int len=p->first.size();
      if (len>0 && p->first[len]!='/') {
        for (int j=0; j<len; ++j) {
          if (p->first[j]=='/') {
            DTMap::iterator q=dp[i]->find(p->first.substr(0, j+1));
            if (q!=dp[i]->end())
              q->second.size+=p->second.size;
          }
        }
      }
    }
  }

  // Make list of files to list. List each external file preceded
  // by the matching internal file, if any. Then list any unmatched
  // internal files at the end.
  vector<DTMap::iterator> filelist;
  for (DTMap::iterator p=edt.begin(); p!=edt.end(); ++p) {
    DTMap::iterator a=dt.find(rename(p->first));
    if (a!=dt.end() && (all || a->second.date)) {
      a->second.data='-';
      filelist.push_back(a);
    }
    p->second.data='+';
    filelist.push_back(p);
  }
  for (DTMap::iterator a=dt.begin(); a!=dt.end(); ++a) {
    if (a->second.data!='-' && (all || a->second.date)) {
      a->second.data='-';
      filelist.push_back(a);
    }
  }

  // Sort
  if (summary>0)
    sort(filelist.begin(), filelist.end(), compareFragmentList);

  // List
  int64_t usize=0;
  unsigned matches=0, mismatches=0, internal=0, external=0,
           duplicates=0;  // counts
  for (unsigned fi=0;
       fi<filelist.size() && (summary<=0 || int(fi)<summary); ++fi) {
    DTMap::iterator p=filelist[fi];

    // Compare external files
    if (summary<=0 && p->second.data=='-' && fi+1<filelist.size()
        && filelist[fi+1]->second.data=='+') {
      DTMap::const_iterator p1=filelist[fi+1];
	  
	  ///bool 		equal(DTMap::const_iterator p, const char* filename, uint32_t &o_crc32,string i_myhashtype,string i_myhash,string& o_hash);// compare file contents with p
		uint32_t thecrc32=0;
		string dummy;
      if ((flagforce && equal(p, p1->first.c_str(),thecrc32,"","",dummy))
          || (!flagforce && p->second.date==p1->second.date
              && p->second.size==p1->second.size
              && (!p->second.attr || !p1->second.attr
                  || p->second.attr==p1->second.attr))) {
        p->second.data='=';
        ++fi;
      }
      else
        p->second.data='#';
    }

    // Compare with previous file in summary
    if (summary>0 && fi>0 && p->second.date && p->first!=""
        && p->first[p->first.size()-1]!='/'
        && p->second.ptr.size()
        && filelist[fi-1]->second.ptr==p->second.ptr)
      p->second.data='^';

    if (p->second.data=='=') ++matches;
    if (p->second.data=='#') ++mismatches;
    if (p->second.data=='-') ++internal;
    if (p->second.data=='+') ++external;
    if (p->second.data=='^') ++duplicates;

    // List selected comparison results
    if (!strchr(nottype.c_str(), p->second.data)) {
      if (p->first!="" && p->first[p->first.size()-1]!='/')
        usize+=p->second.size;
      printf("%c %s %12.0f ", char(p->second.data),
          dateToString(flagutc,p->second.date).c_str(), p->second.size+0.0);
      if (!flagnoattributes)
        printf("%s ", attrToString(p->second.attr).c_str());
      printUTF8(p->first.c_str());
	  /*
      if (summary<0) {  // frag pointers
        const vector<unsigned>& ptr=p->second.ptr;
        bool hyphen=false;
        for (int j=0; j<int(ptr.size()); ++j) {
          if (j==0 || j==int(ptr.size())-1 || ptr[j]!=ptr[j-1]+1
              || ptr[j]!=ptr[j+1]-1) {
            if (!hyphen) printf(" ");
            hyphen=false;
            printf("%d", ptr[j]);
          }
          else {
            if (!hyphen) printf("-");
            hyphen=true;
          }
        }
      }
	  */
      unsigned v;  // list version updates, deletes, compressed size
      if (all>0 && p->first.size()==all+1u && (v=atoi(p->first.c_str()))>0
          && v<ver.size()) {  // version info
        printf(" +%d -%d -> %1.0f", ver[v].updates, ver[v].deletes,
            (v+1<ver.size() ? ver[v+1].offset : csize)-ver[v].offset+0.0);
        if (summary<0)  // print fragment range
          printf(" %u-%u", ver[v].firstFragment,
              v+1<ver.size()?ver[v+1].firstFragment-1:unsigned(ht.size())-1);
      }
      printf("\n");
    }
  }  // end for i = each file version

  // Compute dedupe size
  int64_t ddsize=0, allsize=0;
  unsigned nfiles=0, nfrags=0, unknown_frags=0, refs=0;
  vector<bool> ref(ht.size());
  for (DTMap::const_iterator p=dt.begin(); p!=dt.end(); ++p) {
    if (p->second.date) {
      ++nfiles;
      for (unsigned j=0; j<p->second.ptr.size(); ++j) {
        unsigned k=p->second.ptr[j];
        if (k>0 && k<ht.size()) {
          ++refs;
          if (ht[k].usize>=0) allsize+=ht[k].usize;
          if (!ref[k]) {
            ref[k]=true;
            ++nfrags;
            if (ht[k].usize>=0) ddsize+=ht[k].usize;
            else ++unknown_frags;
          }
        }
      }
    }
  }

  // Print archive statistics
  printf("\n"
      "%1.6f MB of %1.6f MB (%d files) shown\n"
      "  -> %1.6f MB (%u refs to %u of %u frags) after dedupe\n"
      "  -> %1.6f MB compressed.\n",
       usize/1000000.0, allsize/1000000.0, nfiles, 
       ddsize/1000000.0, refs, nfrags, unsigned(ht.size())-1,
       (csize+dhsize-dcsize)/1000000.0);
  if (unknown_frags)
    printf("%d fragments have unknown size\n", unknown_frags);
  if (files.size())
    printf(
       "%d =same, %d #different, %d +external, %d -internal\n",
        matches, mismatches, external, internal);
  if (summary>0)
    printf("%d of largest %d files are ^duplicates\n",
        duplicates, summary);
  if (dhsize!=dcsize)  // index?
    printf("Note: %1.0f of %1.0f compressed bytes are in archive\n",
        dcsize+0.0, dhsize+0.0);
  return 0;
}

int Jidac::extract()
{
	archive=getbackupnameifany(archive);
	
	if (flagcomment && flagrange)
		if (versioncomment.length()>0)
		{
			int	errors=0;
			read_archive(NULL,archive.c_str(),&errors,0,flagstdout); // we want to be quiet by stdout?
			// try to find the comment, but be careful: 1, and only 1, allowed
			vector<DTMap::iterator> myfilelist;
			int versione=searchcomments(versioncomment,myfilelist);
			if (versione>0)
			{
				jidacreset();
				myprintf("85368: -comment 'something' with -range => extracting single version\n");
				g_rangefrom	=versione;
				g_rangeto	=versione;
				all=8;
			}
			else
			if (versione==0)
				error("85644: Cannot find version comment");
			else
				error("85645: Multiple match for version comment");
		}
		
		
	if (flagstdout)
	{
		howmanythreads=1;
		flagspace	=false;
		flagnoeta	=false;
		tofiles.clear();
#ifdef _WIN32
		setmode(1, O_BINARY);  // yes, we want binary
#endif // corresponds to #ifdef (#ifdef _WIN32)
	}
#ifdef _WIN32
/// check if some kind of UNC Windows path \\franzk\pippo\..., turn OFF flaglongpath
		
	if (flaglongpath)
		{
			for (unsigned int i=0;i<tofiles.size();i++)
			{
				if (islonguncpath(tofiles[i]))
				{
					myprintf("00867! error, cannot extract on explicit UNC -to\n");
					return 2;
				}
				if (iswindowsunc(tofiles[i]))
				{
					myprintf("00868: found UNC Windows, incompatible with -longpath, turning OFF %s\n",tofiles[i].c_str());
					flaglongpath=false;
					break;
				}
			}
			for (DTMap::iterator p=dt.begin(); p!=dt.end(); ++p)
				if (iswindowsunc(p->first))
				{
					myprintf("00869: found UNC Windows, incompatible with -longpath, turning OFF %s\n",p->first.c_str());
					flaglongpath=false;
					break;
				}
			if (tofiles.size()>0)
			{
				for (unsigned int i=0;i<tofiles.size();i++)
					if (!islongpath(tofiles[i]))
						tofiles[i]="//?/"+tofiles[i];
				myprintf("00870: INFO: setting Windows' long filenames\n");
				if (flagdebug3)
					for (unsigned int i=0;i<tofiles.size();i++)
						myprintf("00871: Tofiles %d %s\n",(int)i,tofiles[i].c_str());
			}
		}
	#endif // corresponds to #ifdef (#ifdef _WIN32)
	if (flagparanoid)
	{
		if (tofiles.size()==0)
		{
			myprintf("00872! -paranoid needs a -to\n");
			return 2;
		}
		if (command=='x')
		{
			myprintf("00873! -paranoid is a t (test) thing\n");
			return 1;
		}
	}
	if (!flagspace)
		if (tofiles.size()==1)
		{
			if (files.size()==1)
				if (isdirectory(tofiles[0]))
					if (!isdirectory(files[0]))
					{
						if (iswildcards(files[0]))
						{
							if (flagdebug2)
								myprintf("00874: wildcard in files[0]: do nothing\n");
						}
						else
						{
							if (flagdebug2)
								myprintf("00875: no wildcard, check if a filename is selected\n");
							string onlyname=extractfilename(files[0]);
							if (onlyname!="")
							{
								tofiles[0]+=onlyname;
								myprintf("00876: MAGIC: selected 1 file extracting to a folder => merge to %s\n",tofiles[0].c_str());
							}
						}
					}
			if (!saggiascrivibilitacartella(tofiles[0]))
			{
				myprintf("00877! Cannot write on <<-to %s>>\n",tofiles[0].c_str());
				myprintf("00878: Aborting. Use -space to bypass and enforcing.\n");
				return 2;
				///error("Path seems not writeable");
			}
		}
	if (flagzero)
	{
		if (flagforce)
		{
			myprintf("00879! -kill incompatible with -force\n");
			return 2;
		}
		myprintf("\n");
		myprintf("00880$ ****** WARNING: -zero switch. Create 0 bytes files on filesystem\n");
		myprintf("00881$ ****** Full-scale extraction test (UTF-8 strange filenames, path too long...)\n");
		myprintf("00882$ ****** Highly suggested output on RAMDISK\n\n");
	}
#ifdef ZPAQFULL ///NOSFTPSTART
	string kunfile=g_gettempdirectory()+"VFILE-kun.txt";
	myreplaceall(kunfile,"\\","/");
	kunfile=nomefileseesistegia(kunfile);
	if (flagfilelist)
	{
		myprintf("00883: Autoselect\n"); // too slow DTMap::iterator a=dt.find("VFILE-l-filelist.txt");
			files.clear();
		files.push_back("VFILE-l-filelist.txt");
		flagforce=true;
		tofiles.clear();
		tofiles.push_back(kunfile);
	}
	
	
	string externalkunfile=g_gettempdirectory()+"VFILE-extern.txt";
	myreplaceall(externalkunfile,"\\","/");
	externalkunfile=nomefileseesistegia(externalkunfile);
	if (flagexternal)
	{
		files.clear();
		files.push_back("VFILE-l-external.txt");
		flagforce=true;
		tofiles.clear();
		tofiles.push_back(externalkunfile);
		myprintf("00884: Autoselect external to %s\n",externalkunfile.c_str()); // too slow DTMap::iterator a=dt.find("VFILE-l-filelist.txt");
#ifdef unix
		flagspace=true;
#endif // corresponds to #ifdef (#ifdef unix)

	}
#endif ///NOSFTPEND	
	
	g_scritti=0;
  // Encrypt or decrypt whole archive
	if ((repack!="") && all)
	{
		if (files.size()>0 || tofiles.size()>0 || onlyfiles.size()>0 || flagnoattributes || version!=DEFAULT_VERSION || method!="")
			error("-repack -all does not allow partial copy");
		string part0=subpart(archive, 0);
		if (part0!=archive)
		{
			myprintf("00885! so sorry, this seems a multipart archive, abort\n");
		//	return 2;
		}
		InputArchive in(archive.c_str());
		if (flagforce)
			delete_file(repack.c_str());
		if (exists(repack))
			error("output file exists");
    	char salt[32]={0};
		if (new_password)
			libzpaq::random(salt, 32);
		myprintf("00886: Changing password for %s bytes\n\n",migliaia(in.totalsize()));
		OutputArchive out(archive,repack.c_str(), new_password, salt, 0);
		copywitheta(in.totalsize(),in, out);
		myprintf("\n");
		myprintf("00887: Source      %19s <<%Z>>\n", migliaia(in.tell()),archive.c_str());
		myprintf("00888: Destination %19s <<%Z>>\n", migliaia(out.tell()),repack.c_str());
		out.close();
		return 0;
  }

	decodelastversion();

	int	errors=0;
	int64_t sz=read_archive(NULL,archive.c_str(),&errors,0,flagstdout); // we want to be quiet by stdout?
	if (sz<1) error("archive not found");

	
	if (flagstdout)
		flagsilent=true;
#ifdef _WIN32
	if (flaglongpath)
	{
		if (searchfrom!="")
		{
			/// the rename() function will replace
			if (flagdebug)
				myprintf("00891: -longpath and search and replace ON\n");
		}
		else
		if (tofiles.size()==1)
		{
			/// a special rename() kludge for tofiles.size==1 and flaglongpath
			if (flagdebug)
				myprintf("00892: -longpath and ONE to: deal with rename()\n");
		}
		else
		{
			if (flagdebug)
				myprintf("00893: -longpath, check for some UNC\n");
			/// extract longpath files, from UNC, is not so easy
			/// spaghetti? well, it is not my fault, it is Windows' lasagna-code
			for (DTMap::iterator p=dt.begin(); p!=dt.end(); ++p)
				if (iswindowsunc(p->first))
				{
					myprintf("\n\n");
					myprintf("00894$ WARNING: -longpath with Windows UNC, use ONE -to something /  -find -replace to manually adjust\n");
					myprintf("00895: zpaqfranz x z:\\1.zpaq -find //franzk/z/NS -replace \\\\?\\z:\\here -longpath\n");
					myprintf("00896: zpaqfranz x z:\\1.zpaq -find //franzk/z/NS -replace \\\\?\\UNC\\nas\\share\\somewhere -longpath\n");
					myprintf("00897: zpaqfranz x z:\\1.zpaq -to z:\\here -longpath  [note: ONLY ONE local folder]\n\n");
					break;
				}
		}
	}
#endif // corresponds to #ifdef (#ifdef _WIN32)
	if (flagcomment)
		if (versioncomment.length()>0)
		{
			// try to find the comment, but be careful: 1, and only 1, allowed
			vector<DTMap::iterator> myfilelist;
			int versione=searchcomments(versioncomment,myfilelist);
			if (versione>0)
			{
				myprintf("00898: Found version -until %d scanning again... (2)\n");
				version=versione;
				jidacreset();
				sz=read_archive(NULL,archive.c_str());

			}
			else
			if (versione==0)
				error("Cannot find version comment");
			else
				error("Multiple match for version comment. Please use -until");
		}
  // test blocks
  for (unsigned i=0; i<block.size(); ++i) {
    if (block[i].bsize<0) error("negative block size");
    if (block[i].start<1) error("block starts at fragment 0");
    if (block[i].start>=ht.size()) error("block start too high");
    if (i>0 && block[i].start<block[i-1].start) error("unordered frags");
    if (i>0 && block[i].start==block[i-1].start) error("empty block");
    if (i>0 && block[i].offset<block[i-1].offset+block[i-1].bsize)
      error("unordered blocks");
    if (i>0 && block[i-1].offset+block[i-1].bsize>block[i].offset)
      error("overlapping blocks");
  }
  // Create index instead of extract files
  if (index) {
    if (ver.size()<2) error("no journaling data");
    if (flagforce) delete_file(index);
    if (exists(index)) error("index file exists");
    // Get salt
    char salt[32];
    if (ver[1].offset==32) {  // encrypted?
      FP fp=myfopen(subpart(archive, 1).c_str(), RB);
      if (fp==FPNULL) error("cannot read part 1");
	  if (fp!=NULL)
	  {
		  if (fread(salt, 1, 32, fp)!=32) error("cannot read salt");
		  salt[0]^='7'^'z';  // for index
		  myfclose(&fp);
	  }
    }
    InputArchive in(archive.c_str());
    OutputArchive out(archive,index, g_password, salt, 0);
    for (unsigned i=1; i<ver.size(); ++i) {
      if (in.tell()!=ver[i].offset) error("I'm lost");
      // Read C block. Assume uncompressed and hash is present
      static char hdr[256]={0};  // Read C block
      int hsize=ver[i].data_offset-ver[i].offset;
      if (hsize<70 || hsize>255) error("bad C block size");
      if (in.read(hdr, hsize)!=hsize) error("EOF in header");
      if (hdr[hsize-36]!=9  // size of uncompressed block low byte
          || (hdr[hsize-22]&255)!=253  // start of SHA1 marker
          || (hdr[hsize-1]&255)!=255) {  // end of block marker
        for (int j=0; j<hsize; ++j)
          myprintf("00899: %d%c", hdr[j]&255, j%10==9 ? '\n' : ' ');
        myprintf("at %1.0f\n", ver[i].offset+.0);
        error("C block in weird format");
      }
      memcpy(hdr+hsize-34,
          "\x00\x00\x00\x00\x00\x00\x00\x00"  // csize = 0
          "\x00\x00\x00\x00"  // compressed data terminator
          "\xfd"  // start of hash marker
          "\x05\xfe\x40\x57\x53\x16\x6f\x12\x55\x59\xe7\xc9\xac\x55\x86"
          "\x54\xf1\x07\xc7\xe9"  // SHA-1('0'*8)
          "\xff", 34);  // EOB
      out.write(hdr, hsize);
      in.seek(ver[i].csize, SEEK_CUR);  // skip D blocks
      int64_t end=sz;
      if (i+1<ver.size()) end=ver[i+1].offset;
      int64_t n=end-in.tell();
      if (copy(in, out, n)!=n) error("EOF");  // copy H and I blocks
    }
    printUTF8(index);
    myprintf(" -> %s\n", migliaia(out.tell()));
    out.close();
    return 0;
  }
  // Label files to extract with data=0.
  // Skip existing output files. If force then skip only if equal
  // and set date and attributes.

  ExtractJob job(*this);
  int total_files=0, skipped=0;
  int tobeerased=0,erased=0;
  int real_dirs=0;
  uint32_t crc32fromfile;
	int kollision=0;
	
#ifdef _WIN32
	bool flagunix=false;
	flagunix=searchunixfile();
	if (flagunix)
	{
		myprintf("00900: Found Unix attributes on Windows => checking for collision\n");
		vector<string> kollisioni;
		uint32_t fixati		=casekollision(dt,kollisioni,true);
		int casecollision	=kollisioni.size();
		if (casecollision>0)
		{
			myprintf("00901: Case collisions        %9s (try -fixcase)\n",migliaia(casecollision));
			if (flagverbose)
				for (unsigned int i=0;i<kollisioni.size();i++)
					{
						myprintf("     collision  <<%Z>>\n",kollisioni[i].c_str());
					}
			if (fixati>0)
				myprintf("00902: -fixcase fixed         %9s files\n",migliaia(fixati));
			kollisioni.clear();
		}
		else
			myprintf("00903: No unfixed case collision (extracting Unix filenames on Windows)\n");

	}
#endif // corresponds to #ifdef (#ifdef _WIN32)

#ifdef _WIN32
	if ((flagutf) || (flagflat) || flagfix255 || flagfixcase || (flagparanoid) || (flagfixreserved))
#else
	if ((flagutf) || (flagflat) || flagfix255 || flagfixcase || (flagparanoid) )
#endif // corresponds to #ifdef (#ifdef _WIN32)
	{
/// we make a copy of the map (dt) into mymap, changing the filenames
/// wy do not in rename()? Because we need very dirty string manipulations
		printsanitizeflags();
		int64_t filesbefore=0;
		int64_t dirsbefore=0;
		if (flagdebug3)
			for (DTMap::iterator p=dt.begin(); p!=dt.end(); ++p)
			{
				if ((p->second.date && p->first!="") && (!isdirectory(p->first)))
					dirsbefore++;
				else
					filesbefore++;
			}
		DTMap mymap;
		MAPPAFILEHASH mappacollisioni;
#ifndef ANCIENT
		int kollisioni=0;
		for (DTMap::iterator p=dt.begin(); p!=dt.end(); ++p)
		{
			/*macos*/
			string newname=sanitizzanomefile(p->first,filelength,kollisioni,mappacollisioni);

			std::pair<map<string, DT>::iterator, bool> ret;
			ret = mymap.insert( std::pair<string,DT>(newname,p->second) );
			if (ret.second==false)
				myprintf("00904: KOLLISION! %s\n",newname.c_str());
		}
#endif // corresponds to #ifndef (#ifndef ANCIENT)
		dt=mymap;
		if (flagdebug3)
		{
			int64_t filesafter=0;
			int64_t dirsafter=0;
			for (DTMap::iterator p=dt.begin(); p!=dt.end(); ++p)
			{
				if ((p->second.date && p->first!="") && (!isdirectory(p->first)))
					dirsafter++;
				else
					filesafter++;
			}
			myprintf("00905: size  before %12s\n",migliaia((int64_t)dt.size()));
			myprintf("00906: Files before %12s\n",migliaia(filesbefore));
			myprintf("00907: dirs  before %12s\n",migliaia(dirsbefore));
			myprintf("\n\n");
			myprintf("00908: size  after  %12s\n",migliaia((int64_t)dt.size()));
			myprintf("00909: Files before %12s\n",migliaia(filesafter));
			myprintf("00910: dirs  before %12s\n",migliaia(dirsafter));
		}
	///if (flagdebug)
	}
#ifdef _WIN32
	if (!flaglongpath)
		if (repack=="")
			for (DTMap::iterator p=dt.begin(); p!=dt.end(); ++p)
				if ((p->second.date && p->first!=""))
				{
					string filename=rename(p->first);
					if (filename.length()>254)
					{
						myprintf("00911: WARN: path too long %03d %Z\n",(int)filename.length(),filename.c_str());
					}
				}
#endif // corresponds to #ifdef (#ifdef _WIN32)

	string	goingstdout="";
	bool	isstdourordered=false;
	int		badfrag=0;

	
	for (DTMap::iterator p=dt.begin(); p!=dt.end(); ++p)
	{
		p->second.data=-1;  // skip
		if (p->second.date && p->first!="")
		{
			string fn=rename(p->first);
			
			const bool isdir=isdirectory(p->first);
			if (isdir)
				real_dirs++;
			string dummy="";
			///myprintf("49911\n");
			if ((!flagstdout) && (repack=="") && !flagtest && flagforce && !isdir && equal(p, fn.c_str(),crc32fromfile,"","",dummy))
			{
				// identical
				if (flagverbose)
				{
					myprintf("= %Z\n",fn.c_str());
				}
				close(fn.c_str(), p->second.date, p->second.attr);
				++skipped;
			}
			else
			if ((!flagstdout) && (repack=="") && !flagtest && !flagforce && exists(fn))
			{
				// exists, skip
				
				if (flagverbose)
				{
					myprintf("? %Z\n",fn.c_str());
				}
				++skipped;
			}
			else
			if ((!flagstdout) && isdir)  // update directories later
				p->second.data=0;
			else
			if (block.size()>0)
			{  // files to decompress
				p->second.data=0;
				unsigned lo=0, hi=block.size()-1;  // block indexes for binary search
				for (unsigned i=0; p->second.data>=0 && i<p->second.ptr.size(); ++i)
				{
					unsigned j=p->second.ptr[i];  // fragment index
					if (j==0 || j>=ht.size() || ht[j].usize<-1)
					{
						fflush(stdout);
						printUTF8(p->first.c_str());
						color_red();
						myprintf(": too bad frag IDs, skipping...\n");
						color_restore();
						p->second.data=-1;  // skip
						badfrag++;
						continue;
					}
					assert(j>0 && j<ht.size());
					if (lo!=hi || lo>=block.size() || j<block[lo].start
						|| (lo+1<block.size() && j>=block[lo+1].start))
					{
						lo=0;  // find block with fragment j by binary search
						hi=block.size()-1;
						while (lo<hi)
						{
							unsigned mid=(lo+hi+1)/2;
							assert(mid>lo);
							assert(mid<=hi);
							if (j<block[mid].start)
								hi=mid-1;
							else
							(lo=mid);
						}
					}
					assert(lo==hi);
					assert(lo>=0 && lo<block.size());
					assert(j>=block[lo].start);
					assert(lo+1==block.size() || j<block[lo+1].start);
					unsigned c=j-block[lo].start+1;
					if (block[lo].size<c) block[lo].size=c;
					if (block[lo].files.size()==0 || block[lo].files.back()!=p)
						block[lo].files.push_back(p);
				}
				++total_files;
				goingstdout=p->first;
				isstdourordered=p->second.isordered;

				job.total_size+=p->second.size;
				///myprintf("00913: FACCIO QUALCOSA SU %s per size %d\n",fn.c_str(),p->second.size);
				if ((!flagtest) && (!flagstdout) && (repack==""))
					if (fileexists(fn))
					{
						if (flagverbose)
						{
							myprintf("00914: * %Z\n",fn.c_str());
						}
						tobeerased++;
						if (delete_file(fn.c_str()))
							erased++;
						else
							myprintf("00916: ************ HIGHLANDER FILE! %s\n",fn.c_str());
					}
			}
		}  // end if selected
	}  // end for


	if (flagstdout)
	{
		if (total_files!=1)
		{
			if (flagdebug)
				myprintf("00917! With -stdout only ONE file can be choosed\n");
			return 2;
		}
		if (flagdebug)
		{
			if (isstdourordered)
				myprintf("00918: [ORDERED-THIS IS GOOD] %Z\n",goingstdout.c_str());
			else
				myprintf("00919! *** UNORDERED *** %Z\n",goingstdout.c_str());
		}
		if (!isstdourordered)
		{
			if (flagdebug)
				myprintf("00922! GURU, sorry cannot stdout not ordered file\n");
			return 2;
		}
	}

	if ((!flagstdout) && (!flagterse))
	{
		if (!flagforce && skipped>0)
			myprintf("%08d ?existing files skipped (-force overwrites).\n", skipped);
		if (flagforce && skipped>0)
			myprintf("%08d =identical files skipped.\n", skipped);
		if (flagforce && tobeerased>0)
			myprintf("%08d !=different files to be owerwritten => erased %08d\n",tobeerased,erased);
		if (tobeerased!=erased)
			myprintf("00923: **** GURU **** WE HAVE SOME HIGHLANDER!\n");
	}
	
  // Repack to new archive
	if (repack!="")
	{
    // Get total D block size
    if (ver.size()<2) error("cannot repack streaming archive");
    int64_t csize=0;  // total compressed size of D blocks
    for (unsigned i=0; i<block.size(); ++i) {
      if (block[i].bsize<1) error("empty block");
      if (block[i].size>0) csize+=block[i].bsize;
    }
    InputArchive in(archive.c_str());
    // Open output
    if (!flagforce && exists(repack))
		error("repack output exists");
    delete_file(repack.c_str());
    char salt[32]={0};
    if (new_password) libzpaq::random(salt, 32);
    OutputArchive out(archive,repack.c_str(), new_password, salt, 0);
    int64_t cstart=out.tell();
    // Write C block using first version date

	if (flagdebug2)
		myprintf("00924: writejidacheader 1\n");
    writeJidacHeader(&out, ver[1].date, -1, 1);
    int64_t dstart=out.tell();
    // Copy only referenced D blocks. If method then recompress.
	int64_t totalblocksize=0;
	for (unsigned i=0; i<block.size(); ++i) 
		if (block[i].size>0) 
			totalblocksize+=block[i].bsize;

    myprintf("10543: Referenced D blocks %s block size %s\n",migliaia(block.size()),migliaia2(totalblocksize));
	int64_t startrepack=mtime();

	int64_t copied=0;
	for (unsigned i=0; i<block.size(); ++i) 
		if (block[i].size>0) 
		{
			in.seek(block[i].offset, SEEK_SET);
			copy(in, out, block[i].bsize);
			copied+=block[i].bsize;
			myavanzamentoby1sec(copied,totalblocksize,startrepack);
		}
    myprintf("00925: Data %s -> ",migliaia(csize));
    csize=out.tell()-dstart;
    myprintf(" %s\n", migliaia(csize));
    // Re-create referenced H blocks using latest date
    for (unsigned i=0; i<block.size(); ++i) {
      if (block[i].size>0) {
        StringBuffer is;
        puti(is, block[i].bsize, 4);
        for (unsigned j=0; j<block[i].frags; ++j) {
          const unsigned k=block[i].start+j;
          if (k<1 || k>=ht.size()) error("frag out of range");
          is.write((const char*)ht[k].sha1, 20);
          puti(is, ht[k].usize, 4);
        }
        libzpaq::compressBlock(&is, &out, "0",
            ("jDC"+itos(ver.back().date, 14)+"h"
            +itos(block[i].start, 10)).c_str(),
            "jDC\x01");
      }
    }
    // Append I blocks of selected files
    unsigned dtcount=0;
    StringBuffer is;
    for (DTMap::iterator p=dt.begin();; ++p) {
      if (p!=dt.end() && p->second.date>0 && p->second.data>=0) {
        string filename=rename(p->first);
        puti(is, p->second.date, 8);
        is.write(filename.c_str(), filename.size());//strlen(filename.c_str()));
        is.put(0);
        if ((p->second.attr&255)=='u') // unix attributes
				write715attr(is,p->second.attr,3);
		else
		if ((p->second.attr&255)=='w') // windows attributes
				write715attr(is,p->second.attr,5);
		else
			puti(is, 0, 4);  // no attributes
        puti(is, p->second.ptr.size(), 4);  // list of frag pointers
        for (unsigned i=0; i<p->second.ptr.size(); ++i)
          puti(is, p->second.ptr[i], 4);
      }
      if (is.size()>16000 || (is.size()>0 && p==dt.end())) {
        libzpaq::compressBlock(&is, &out, "1",
            ("jDC"+itos(ver.back().date)+"i"+itos(++dtcount, 10)).c_str(),
            "jDC\x01");
        is.resize(0);
      }
      if (p==dt.end()) break;
    }
    // Summarize result
    printUTF8(archive.c_str());
    myprintf(" %s -> ", migliaia(sz));
    printUTF8(repack.c_str());
    myprintf(" %s\n", migliaia(out.tell()));
    // Rewrite C block
	myprintf("00926: =============>>>>>>>>>> write C block at %s of csize %s\n",migliaia(cstart),migliaia2(csize));
    out.seek(cstart, SEEK_SET);
	if (flagdebug2)
		myprintf("00927: writejidacheader 2\n");
    
    writeJidacHeader(&out, ver[1].date, csize, 1);
    out.close();
    return 0;
  }
	g_crc32.clear();
  // Decompress archive in parallel
	if ((!flagstdout)&& (!flagterse))
		myprintf("00928: Extract %s bytes (%s) in %s files (%s folders) / %d T\n",migliaia(job.total_size), tohuman(job.total_size),migliaia2(total_files), migliaia4(real_dirs),howmanythreads);

	int64_t freeramdisk=getramdisksize()*75/100;
	///freeramdisk=1000;

	if (flaghdd)
		if (!flagspace)
		{
			if (job.total_size>freeramdisk)
			{
				color_yellow();
				myprintf("03360: Free RAM (-25%%) %s > required %s, turning OFF ramdisk (-space to bypass)\n",tohuman(freeramdisk),tohuman2(job.total_size));
				flaghdd		=false;
				flagramdisk	=false;
			}
			else
			{
				color_green();
				myprintf("03364: Enough RAM %s vs %s, going ramdisk!\n",tohuman(freeramdisk),tohuman2(job.total_size));
				flagramdisk	=true;
			}
			color_restore();
		}

	if (flagramdisk)
		if (g_ramdisksize>freeramdisk)
		{
			color_yellow();
			bigwarning();
			myprintf("59613: Free RAM (-25%%) %21s (as reported by OS) vs required %s\n",tohuman(freeramdisk),tohuman2(g_ramdisksize));
			color_restore();
		}


	if (!flagspace)
		if (!flagzero)
			if (tofiles.size()==1)
			{
				if (!saggiascrivibilitacartella(tofiles[0]))
				{
					myprintf("00929: Cannot write on <<-to %s>>\n",tofiles[0].c_str());
					myprintf("00930: Aborting. Use -space to bypass and enforcing.\n");
					error("Path seems not writeable");
				}
				int64_t spazio=getfreespace(tofiles[0]);
				if (spazio<job.total_size)
				{
					myprintf("00931: Free space on <<-to %s>>\n",tofiles[0].c_str());
					myprintf("00932: is      %21s\n",migliaia(spazio));
					myprintf("00933: needed  %21s\n",migliaia(job.total_size));
					if (!isdirectory(tofiles[0]))
						myprintf("00934: -to is a single file, NOT a folder. Maybe you miss the final /?\n");
					myprintf("00935! Not enough free space. Use -space to bypass and enforcing.\n");
					///error("Not enough free space");
					return 2;
				}
			}
	if (flagdebug && flagzero && flagkill)
	{
		myprintf("00936: **** CREATING FILES AND FOLDER STRUCTURE  *****\n");
		myprintf("00937: **** EXTRACTIBILITY TEST (ON FILESYSTEM)  *****\n");
		if (tofiles.size()!=1)
		{
			myprintf("00938: a single -to needed, quit\n");
			return 1;
		}
		if (!flagforce)
		{
			string outputfolder=includetrailingbackslash(tofiles[0]);
			uint64_t 		totalsize	=0;
			unsigned int 	totalfile	=0;
			unsigned int 	totaldir	=0;
			unsigned int 	longfiles	=0;
			getfoldersize(outputfolder,totalsize,totalfile,totaldir,longfiles);
			if (totalsize)
			{
				myprintf("00939: there is something in -to, and no -force. Abort\n");
				return 1;
			}
		}
		int64_t		startcreate=mtime();
		unsigned int folderstocreate=0;
		unsigned int filestocreate	=0;
		unsigned int longfolders	=0;
		unsigned int longfiles		=0;
		myprintf("00940: Start counting...");
		for (DTMap::iterator p=dt.begin(); p!=dt.end(); ++p)
		{
			string fn=rename(p->first);
			if (isdirectory(fn))
			{
				folderstocreate++;
				if (fn.size()>250)
					longfolders++;
			}
			else
			{
				filestocreate++;
				if (fn.size()>250)
					longfiles++;
			}
		}
		myprintf(" done in %.2fs\n",(mtime()-startcreate)*0.001);
		myprintf("00941: Folders  %12s (long %12s)\n",migliaia(folderstocreate),migliaia2(longfolders));
		myprintf("00942: Files    %12s (long %12s)\n",migliaia(filestocreate),migliaia2(longfiles));
#ifdef _WIN32
		if ((longfiles+longfolders)>0)
			if (!flaglongpath)
				myprintf("00943$ WARNING, maybe you want -longpath ?\n");
#endif // corresponds to #ifdef (#ifdef _WIN32)
		if ((folderstocreate+filestocreate)==0)
		{
			myprintf("00944: nothing to do, quit\n");
			return 1;
		}
		unsigned int totaledt		=dt.size();
		unsigned int fileerrors		=0;
		unsigned int fatti			=0;
		unsigned int createdfolders	=0;
		unsigned int createdfiles	=0;
		for (DTMap::iterator p=dt.begin(); p!=dt.end(); ++p)
		{
			fatti++;
			if (!flagnoeta)
				if (fatti % 1000==0)
					myprintf("00945: Done %8sK / %s\r",migliaia(fatti/1000),migliaia2(totaledt));
			string fn=rename(p->first);
			fn=makelongpath(fn);
			///myprintf("00946: makepath %s\n",fn.c_str());

			makepath(fn);
			if (!isdirectory(fn))
				{
					FILE* handle=NULL;
#ifdef _WIN32
					wstring widename=utow(fn.c_str());
					handle=_wfopen(widename.c_str(), L"wb" );
#else
					handle=fopen(fn.c_str(), "wb");
#endif // corresponds to #ifdef (#ifdef _WIN32)
					if (handle==NULL)
					{
						fileerrors++;
						myprintf("00947! ERROR OPENING %Z\n",fn.c_str());
					}
					else
						createdfiles++;
					fclose(handle);
				}
				else
					createdfolders++;
		}
		if (!flagnoeta)
			myprintf("\n");
		myprintf("00949: Time %16.2fs\n",(mtime()-startcreate)*0.001);
		myprintf("00950: Total    %12s\n",migliaia(totaledt));
		myprintf("00951: Folders  %12s\n",migliaia(createdfolders));
		myprintf("00952: Files    %12s\n",migliaia(createdfiles));
		myprintf("00953: Errors   %12s\n",migliaia(fileerrors));
		return fileerrors;
	}
	
	///myprintf("00954: preparo per estrazione\n");
	///blockdecoder();
	
	vector<ThreadID> tid(howmanythreads);
	if (howmanythreads==1)
	{
		if (flagverbose)
			myprintf("00955: monothread decompress (extract)\n");
		decompressThread(&job);
	}
	else
	{
		for (unsigned i=0; i<tid.size(); ++i)
			if (flagramdisk)
				run(tid[i], decompressthreadramdisk, &job);
			else
				run(tid[i], decompressThread, &job);
	}
  // Extract streaming files
	unsigned segments=0;  // count
	InputArchive in(archive.c_str());
	///myprintf();
	if (in.isopen())
	{
		FP outf=FPNULL;
		////myprintf(");
		DTMap::iterator dtptr=dt.end();
		for (unsigned i=0; i<block.size(); ++i)
		{
			if (block[i].usize<0 && block[i].size>0)
			{
				Block& b=block[i];
				try
				{
					in.seek(b.offset, SEEK_SET);
					libzpaq::Decompresser d;
					d.setInput(&in);
					if (!d.findBlock())
						error("block not found");
					StringWriter filename;
					for (unsigned j=0; j<b.size; ++j)
					{
						if (!d.findFilename(&filename))
							error("segment not found");
						d.readComment();
						// Start of new output file
						if (filename.s!="" || segments==0)
						{
							unsigned k;
							///myprintf(");
							for (k=0; k<b.files.size(); ++k)
							{  // find in dt
								if (b.files[k]->second.ptr.size()>0
									&& b.files[k]->second.ptr[0]==b.start+j
									&& b.files[k]->second.date>0
									&& b.files[k]->second.data==0)
										break;
							}
							if (k<b.files.size())
							{  // found new file
								///myprintf();
								if (outf!=FPNULL)
									myfclose(&outf);
								outf=FPNULL;
								string outname=rename(b.files[k]->first);
								dtptr=b.files[k];
								lock(job.mutex);
									myprintf("> %Z\n",outname.c_str());
									if (!flagtest)
									{
										///myprintf();
										///myprintf("00956: makepath %s\n",outname.c_str());

										makepath(outname);
										///myprintf();
										outf=myfopen(outname.c_str(), WB);
										if (outf==FPNULL)
										{
											printerr("18330",outname.c_str(),0);
										}

									}
								release(job.mutex);
							}
							else
							{  // end of file
								if (outf!=FPNULL)
									myfclose(&outf);
								outf=FPNULL;
								dtptr=dt.end();
							}
						}
            // Decompress segment
						libzpaq::SHA1 sha1;
						d.setSHA1(&sha1);
						OutputFile o(outf);
						d.setOutput(&o);
						d.decompress();
            // Verify checksum
						char sha1result[21];
						d.readSegmentEnd(sha1result);
						if (sha1result[0]==1)
						{
							if (memcmp(sha1result+1, sha1.result(), 20)!=0)
								error("checksum failed");
						}
						else
						if (sha1result[0]!=0)
							error("unknown checksum type");
						++b.extracted;
						if (dtptr!=dt.end())
							++dtptr->second.data;
						filename.s="";
						++segments;
					}
				}
				catch(std::exception& e)
				{
					lock(job.mutex);
					myprintf("00957: Skipping block: %s\n", e.what());
					release(job.mutex);
				}
			}
		}
		if (outf!=FPNULL)
			myfclose(&outf);
	}
	if (segments>0)
		myprintf("%u streaming segments extracted\n", segments);
  // Wait for threads to finish
  if (howmanythreads>1)
	  for (unsigned i=0; i<tid.size(); ++i)
		  join(tid[i]);
  // Create empty directories and set file dates and attributes
	if (!flagtest)
		for (DTMap::reverse_iterator p=dt.rbegin(); p!=dt.rend(); ++p)
			if (p->second.data>=0 && p->second.date && p->first!="")
			{
				string s=rename(p->first);
				if (p->first[p->first.size()-1]=='/')
				{
					bool	createpath=true;
					if (flagdebug2)
						myprintf("00958: makepath %s  %d  %d\n",s.c_str(),g_rangefrom,g_rangeto);
					if (all)
						if (g_rangefrom>0)
						{
							/// do not make empty folder extracting by range
							int posizionebarra=0;
							for (int i=s.size()-2; i>0; i--)
								if (s[i]=='/')
								{
									posizionebarra=i;
									break;
								}
							if (posizionebarra>0)
							{
								string lastpath="";
								for (unsigned int i=posizionebarra+1;i<s.size()-1;i++)
									if (isdigit(s[i]))
										lastpath+=s[i];
								int vernumber=atoi(lastpath.c_str());
								createpath= ((vernumber>=g_rangefrom) && (vernumber<=g_rangeto));
							}
						}
					if (createpath)
						makepath(s, p->second.date, p->second.attr);
				}
				else
				if ((p->second.attr&0x1ff)=='w'+256)  // read-only?
					close(s.c_str(), 0, p->second.attr);
			}


	if (flagramdisk)
	{
		/// extract
		int64_t quantifile	=0;
		int64_t quantifolder	=0;
		for (DTMap::iterator p=dt.begin(); p!=dt.end(); ++p)
			if (isdirectory(p->first))
				quantifolder++;
			else
				quantifile++;

		myprintf("\n");
		myprintf("00960: Sequential write from 'ramdisk' to disk\n");
		myprintf("00959: Total   %21s (%10s) for %s files %s folders\n",migliaia(g_ramdisksize),tohuman(g_ramdisksize),migliaia2(quantifile),migliaia3(quantifolder));
		int64_t 	startwrite=mtime();
		int64_t 	expected	=0;
		int64_t 	written		=0;
		int 		tobetested	=0;
		int			hashok		=0;
		int			hashko		=0;
		int64_t		hashtime	=0;
		int64_t		hashsize	=0;
		
		for (DTMap::iterator p=dt.begin(); p!=dt.end(); ++p)
		{
			string fn=rename(p->first);
			makepath(fn);
			if (!isdirectory(fn))
			{
				if (p->second.pramfile!=NULL)
				{
					
					string 	myhashtype		="";
					string 	myhash			="";
					string 	mycrc32			="";
					int64_t mycreationtime	=0;
					int64_t myaccesstime	=0;
					bool	myisordered		=false;
					int		myversion		=0;
					franz_posix* myposix	=NULL;
					bool	myisadded		=false;
					///string 	hashfromfile="";
					decode_franz_block(false,p->second.franz_block,
					myhashtype,
					myhash,
					mycrc32,
					mycreationtime,
					myaccesstime,
					myisordered,
					myversion,
					myposix,myisadded);
					tobetested++;
					
					franz_do_hash hashfrombuffer(myhashtype);
					if (myhashtype!="")
						hashfrombuffer.init();
					expected+=(*p->second.pramfile).filesize;
					if (flagdebug2)
						myprintf("00962: ramdisk-out  %12s %s\n",migliaia((int64_t)(*p->second.pramfile).filesize),fn.c_str());
					FP myfile=myfopen(fn.c_str(), WB);
					if (myfile==FPNULL)
					{
						printerr("ramdisk",fn.c_str(),0);
						if (myhashtype!="")
							hashko++;
						break;
					}
					int64_t	scritti=0;
					int64_t	n=1000000000;
					///int64_t	n=16777216;
					int64_t w;
					///myprintf("04444: file %19s <<%Z>>\n",migliaia((*p->second.pramfile).filesize),fn.c_str());
					while (1)
					{
						int64_t dascrivere=(*p->second.pramfile).filesize-scritti;
						if (dascrivere>n)
							dascrivere=n;
						w=myfwrite((*p->second.pramfile).data+scritti,1,dascrivere,myfile);

						if (myhash!="")
						{
							int64_t starthash=mtime();
							hashfrombuffer.update((*p->second.pramfile).data+scritti,w);
							hashsize+=w;
							hashtime+=mtime()-starthash;
						}
						scritti+=w;
						written+=w;
						if (!flagnoeta)
							myavanzamentoby1sec(written,g_ramdisksize,startwrite,false);
						if (w!=n)
							break;
					}
					myfclose(&myfile);
					
					string hashstringato;
					if (myhash!="")
					{
						hashstringato=hashfrombuffer.finalize();
						if (hashstringato==myhash)
							hashok++;
						else
						{
							hashko++;
							myprintf("59713! HASH: %s expected %s calculated %s on <<%Z>>\n",myhashtype.c_str(),myhash.c_str(),hashstringato.c_str(),fn.c_str());
						}
					}

				}
				else
				{
					///if (flagdebug3)
						if (!iszpaqfranzvirtualfile(fn))
							myprintf("59653! pram file NULL! <<%Z>>\n",fn.c_str());
				}
			}
		}
		double writetime=(1+mtime()-startwrite)*0.001;
		if (written==expected)
			color_green();
		else
			color_yellow();
		myprintf("00964: Written %21s  expected   %21s delta %s\n",migliaia(written),migliaia2(expected),migliaia3(myabs(written,expected)));
		color_restore();
		myprintf("00965: Time %f @ %s/s\n",writetime,tohuman((int64_t)((written/writetime))));

		if (tobetested)
		{
			if (hashok==tobetested)
				color_green();
			else
				color_red();
			myprintf("59742: Rehashed %s files OK: %s, Failed: %s, Time: %s, Size: %s\n",
					migliaia(tobetested), migliaia2(hashok), migliaia3(hashko),
					migliaia4(hashtime), migliaia5(hashsize));
			if ((hashsize == written) && (written == expected) && (hashok == tobetested)) 
				myprintf("59750: Hash verification complete — all data matches (VERY GOOD)\n");

			color_restore();
		}
	}
	unsigned 	extracted		=0;
	int			toolongfilenames=0;
	int 		adsfilenames	=0;
	int			utf8names		=0;
	int			windowspath		=0;
	int			windowsunc		=0;
	int			relativepath	=0;
	if (!flagramdisk)
	{
		// Report failed extractions, plain old 715
		for (DTMap::iterator p=dt.begin(); p!=dt.end(); ++p)
		{
			string fn=rename(p->first);

			if (flagverbose || flagstat)
			{
				checkfilename(fn,
				&toolongfilenames,
				&adsfilenames,
				&utf8names,
				NULL,// reserved file names, only on WIN32
				&windowspath,
				&windowsunc,
				&relativepath);
			}

			if (p->second.data>=0 && p->second.date
				&& fn!="" && fn[fn.size()-1]!='/')
			{
				++extracted;
				if (p->second.ptr.size()!=unsigned(p->second.data))
				{
					fflush(stdout);
					if (++errors==1)
					{
						myprintf("\n");
						myprintf("00965: Failed (extracted/total fragments, file):\n");
					}
					myprintf("00966! UKONE [very bad] %u/%u %Z\n",int(p->second.data), int(p->second.ptr.size()),fn.c_str());
				}
			}
		 }
	}
	myprintf("\n");
	
	errors+=badfrag;
	if (kollision>0)
	{
		myprintf("\n");
		myprintf("00968: Filenames collisions %08d\n",(int)kollision);
	}
	if (errors>0)
	{
		fflush(stdout);
		myprintf("\n");
		myprintf("00969: Extracted %s files (%s errors) using %s bytes x %d threads\n",
			migliaia(extracted), migliaia3(errors), migliaia4((int64_t)job.maxMemory),
			int(tid.size()));
	}
	if (toolongfilenames)
		myprintf("00970: Long filenames %12s\n",migliaia(toolongfilenames));
	if (adsfilenames)
		myprintf("00971: ADS            %12s\n",migliaia(adsfilenames));
	if (utf8names)
		myprintf("00972: UTF-8          %12s\n",migliaia(utf8names));
	if (windowspath)
		myprintf("00973: Windows path   %12s\n",migliaia(windowspath));
	if (windowsunc)
		myprintf("00974: Windows UNC    %12s\n",migliaia(windowsunc));
	if (relativepath)
		myprintf("00975: Relative path  %12s\n",migliaia(relativepath));

#ifdef ZPAQFULL ///NOSFTPSTART
  	if (flagfilelist)
		if (errors==0)
		{
			if (fileexists(kunfile))
			{
				FILE* myfile = freadopen(kunfile.c_str());
				if (myfile!=FPNULL)
				{
#ifdef ANCIENT
					char data[16384];
#else
					char data[65536*16];
#endif // corresponds to #ifdef (#ifdef ANCIENT)
					int got=0;
					while (!feof(myfile) && !ferror(myfile))
					{
						got = fread(data, sizeof(char), sizeof(data), myfile);
						if (got > 0)
							fwrite(data, 1, got, stdout);
					}
//					while ((got=fread(data,sizeof(char),sizeof(data),myfile)) > 0)
//						fwrite(data,1,got,stdout);
					fclose(myfile);
					delete_file(kunfile.c_str());
				}
			}
			else
			{
				myprintf("\n");
				color_red();
				myprintf("00976: filelist not good. Archive created without -filelist ?\n");
				color_restore();
				errors=2;
			}
		}
  	if (flagexternal)
		if (errors==0)
		{
			if (fileexists(externalkunfile))
			{
				FILE* myfile = freadopen(externalkunfile.c_str());
				if (myfile!=FPNULL)
				{
#ifdef ANCIENT
					char data[16384];
#else
					char data[65536*16];
#endif // corresponds to #ifdef (#ifdef ANCIENT)
					int got=0;
					while (!feof(myfile) && !ferror(myfile))
					{
						got = fread(data, sizeof(char), sizeof(data), myfile);
						if (got > 0)
							fwrite(data, 1, got, stdout);
					}
					fclose(myfile);
					delete_file(externalkunfile.c_str());
				}
			}
			else
			{
				myprintf("\n");
				color_red();
				myprintf("00977: VFILE external not good. Archive created without -external ?\n");
				color_restore();
				errors=2;
			}
		}
#endif ///NOSFTPEND

	if (flagparanoid)
	{
		myprintf("\n\n");
		myprintf("00978: FULL-extract hashing check (aka:paranoid)\n");
		int64_t	dimensionetotale=0;
		int		dalavorare=0;
		
		for (DTMap::iterator p=dt.begin(); p!=dt.end(); ++p)
			if (p->second.date && p->first!="")
			{
				string fn=rename(p->first);
				if (!isdirectory(fn))
					if (fileexists(fn))
						if (p->second.hashtype!="")
						{
							dimensionetotale+=p->second.size;
							dalavorare++;
						}
			}
		int64_t inizio		=mtime();
		int		uguali		=0;
		int		diversi		=0;
		int		cancellati	=0;
		int64_t lavorati	=0;
		g_dimensione=0;

		for (DTMap::iterator p=dt.begin(); p!=dt.end(); ++p)
			if (p->second.date && p->first!="")
			{
				string fn=rename(p->first);
				if (iszpaqfranzvirtualfile(p->first))
				{
					if (flagdebug2)
					myprintf("00979: found a virtualfile %s\n",fn.c_str());
					if (fileexists(fn))
						delete_file(fn.c_str());
				}
				if (!isdirectory(fn))
					if (p->second.hashtype!="")
						if (fileexists(fn))			// no fakefile-dirs
						{
							franz_do_hash dummy(p->second.hashtype);
							if (flagdebug3)
								myprintf("00980: filehash on %s\n",fn.c_str());
							string hashfromfile=dummy.filehash(0,fn,false,inizio,dimensionetotale);
							if (hashfromfile==p->second.hexhash)
							{
								lavorati+=dummy.o_thefilesize;
								uguali++;
								if (delete_file(fn.c_str()))
									cancellati++;
							}
							else
							{
								diversi++;
								if (flagverbose)
									myprintf(" != from file %s from archive %s <<%s>>\n",hashfromfile.c_str(),p->second.hexhash.c_str(),fn.c_str());
							}
						}
			}
		
		if (dalavorare>0)
		{
			printbar(' ');
			myprintf("\r");
			myprintf("00981: Total bytes          %21s (should be %s)\n",migliaia(dimensionetotale),migliaia2(lavorati));
			myprintf("00982: Bytes checked        %21s (should be %s)\n",migliaia(lavorati),migliaia2(dimensionetotale));
			myprintf("00983: Files to be checked  %21s\n",migliaia(dalavorare));
			myprintf("00984: Files ==             %21s (should be %s)\n",migliaia(uguali),migliaia(dalavorare));
			myprintf("00985: Files !=             %21s (should be zero)\n",migliaia(diversi));
			myprintf("00986: Files deleted        %21s (should be %s)\n",migliaia(cancellati),migliaia2(dalavorare));
			if ((dalavorare!=uguali) || (lavorati!=dimensionetotale) || (cancellati!=uguali))
			{
				myprintf("00987: *** ERROR IN PARANOID EXTRACT CHECK! ***\n");
				errors=2;
			}
			removetempdirifempty(tofiles[0],true);
		}
  }
  
	if (flagwindate || flagtar)
	{
		int	tobeworked			=0;
		int	tobesetted			=0;
		int setted				=0;
		int	percentuale			=0;
		int	ultimapercentuale	=0;
		
		for (DTMap::iterator p=dt.begin(); p!=dt.end(); ++p)
			if (p->second.date && p->first!="")
			{
				string fn=rename(p->first);
				if ((!isads(fn)) && (!iszfs(fn)))
					tobeworked++;
			}
		myprintf("00988$ Restoring additional information (touching) for %s\n",migliaia(tobeworked));

		for (DTMap::iterator p=dt.begin(); p!=dt.end(); ++p)
			if (p->second.date && p->first!="")
			{
				string fn=rename(p->first);
				if ((!isads(fn)) && (!iszfs(fn)))
				{
					if (flagdebug3)
						myprintf("00989: Restoring metadata on %s\n",fn.c_str());
					tobesetted++;
					percentuale=tobesetted*100/tobeworked;
					if (ultimapercentuale!=percentuale)
					{
						myprintf("00990: Touching files %03d %% done\r",percentuale);
						ultimapercentuale=percentuale;
					}
					string 	myhashtype		="";
					string 	myhash			="";
					string 	mycrc32			="";
					int64_t	mycreationtime	=0;
					int64_t	myaccesstime	=0;
					bool	myisordered=false;
					int		myversion=0;
					franz_posix* myposix=NULL;
					bool	myisadded=false;
	
					decode_franz_block(false,p->second.franz_block,
						myhashtype,
						myhash,
						mycrc32,
						mycreationtime,
						myaccesstime,
						myisordered,
						myversion,
						myposix,myisadded);
					if (flagdebug3)
					{
						myprintf("\n");
						myprintf("00991: creation %s\n",migliaia(mycreationtime));
					}
#ifdef _WIN32
					if (flagwindate)
						if (mycreationtime>0)
							if (wintouch(fn,0,mycreationtime))
								setted++;
#else
					if (flagtar)
						if (myposix)
							if (restorefilemetadata(fn.c_str(),myposix)==0)
								setted++;
#endif


					}
			}
		printbar(' ');
		myprintf("\r");
		if (tobesetted>0)
			myprintf("00992: Files to be worked %s  => founded %s => OK %s\n",migliaia((int64_t)tobeworked),migliaia2((int64_t)tobesetted),migliaia3((int64_t)setted));
	}


	if (flagcomment)
		if (all)
		{
			printbar('-');
			vector<DTMap::iterator> filelist;
			searchcomments(versioncomment,filelist);
			int64_t	dasettare		=0;
			int64_t	settati			=0;
			int64_t	darinominare	=0;
			int64_t	rinominati		=0;
			for (unsigned fi=0;fi<filelist.size(); ++fi)
			{
				DTMap::iterator p=filelist[fi];
				unsigned v;
				if (p->first.size()==all+1u && (v=atoi(p->first.c_str()))>0 && v<ver.size())
				{
					string versione=rename(itos(v, all));
					dasettare++;
					myprintf("%s %s ",dateToString(flagutc,p->second.date).c_str(),versione.c_str());
					if (close(versione.c_str(),p->second.date,0))
					{
						settati++;
						myprintf("[OK] ");
					}
					else
						myprintf("[KO] ");
					std::map<int,string>::iterator commento;
					commento=mappacommenti.find(v);
					if(commento!= mappacommenti.end())
					{
						darinominare++;
						myprintf(" <<%s>> ", commento->second.c_str());
						string finalpath=versione+'_'+commento->second;
						if (myrename(versione,finalpath)==0)
						{
							myprintf("=> renamed to <<%s>>",finalpath.c_str());
							rinominati++;
						}
						else
							myprintf(" FAILED renamed to <<%s>>",finalpath.c_str());
					}
					myprintf("\n");
				}
			}
			if (dasettare>0)
				myprintf("00993: Dir to be set  %s (OK %s)\n",migliaia(dasettare),migliaia2(settati));
			if (darinominare>0)
				myprintf("00994: Dir to be renamed %s (OK %s)\n",migliaia(darinominare),migliaia2(rinominati));
		}

#ifdef unix
	if ((!flagstdout) && (!flagterse))
	{
		if (!flagtar)
		{
			int posix=posix_count();
			if (posix>0)
				myprintf("96329$ Info: there are %s metadata (use -tar if you want to restore)\n",migliaia(posix));
		}
	}
#endif
///myprintf("10485: g_ramwrite %s\n",migliaia(g_ramwrite));
  return errors;
  ///return errors>0;
}



bool Jidac::is_incomplete_trans(const char* arc)
{
#ifdef _WIN32
	int errors=0;
	dcsize=dhsize=0;

	list_Archive in;
	if (!in.open(true,arc, g_password)) 
	{
		myprintf("05328! Not found %Z\n",arc);
		return 2;
	}
  
  // Test password
	if (g_password) 
	{
		char s[4]={0};
		const int nr=in.read(s, 4);
		if (nr>0 && memcmp(s, "7kSt", 4) && (memcmp(s, "zPQ", 3) || s[3]<1))
		{
			myprintf("10533: zpaqlist:password incorrect\n");
			seppuku();
		}
		in.seek(-nr, SEEK_CUR);
	}

	list_global_start=mtime();
	
	// Scan archive contents
	string lastfile=arc; // last named file in streaming format
	if (list_size(lastfile)>5)
		lastfile=lastfile.substr(0, list_size(lastfile)-5); // drop .zpaq
	int64_t block_offset=32*(g_password!=0);  // start of last block of any type
	int64_t data_offset=block_offset;    // start of last block of d fragments
	int64_t segment_offset=block_offset; // start of last segment
	bool found_data=false;   // exit if nothing found
	bool first=true;         // first segment in archive?
	int  pass=LIST_NORMAL;  // recover ht from data blocks?
	list_StringBuffer os(32832);  // decompressed block
	map<int64_t, double> compressionRatio;  // block offset -> compression ratio


	int blocchini		=0;

	
	bool done=false;
	while (!done) 
	{
		try {
      // If there is an error in the h blocks, scan a second time in RECOVER
      // mode to recover the redundant fragment data from the d blocks.
				libzpaq2::list_Decompresser d;
				d.setInput(&in);
				if (d.findBlock())
					found_data=true;
				else 
				if (pass==LIST_ERR) 
				{
					segment_offset=block_offset=32*(g_password!=0);
					in.seek(block_offset, SEEK_SET);
					if (!d.findBlock()) break;
					pass=LIST_RECOVER;
					///myprintf("Attempting to recover fragment tables...\n");
				}
				else
					break;
	
		
      // Read the segments in the current block
				list_StringWriter filename, comment;
				int segs=0;
				while (d.findFilename(&filename)) 
				{
					if (filename.s.size()) 
					{
						for (unsigned i=0; i<filename.s.size(); ++i)
							if (filename.s[i]=='\\') filename.s[i]='/';
								lastfile=filename.s.c_str();
					}
					comment.s="";
					d.readComment(&comment);
					if (filename.s[17]=='c')
						myprintf("03158: Block %12s %s\r",migliaia2(blocchini),filename.s.c_str());

					if (!(blocchini%1000))
						myprintf("03158: Block %12s\r",migliaia2(blocchini));
					blocchini++;
					
		

					int64_t usize=0;  // read uncompressed size from comment or -1
					int64_t fdate=0;  // read date from filename or -1
					int64_t fattr=0;  // read attributes from comment as wN or uN
					unsigned num=0;   // read fragment ID from filename
					const char* p=comment.s.c_str();
					for (; isdigit(*p); ++p)  // read size
					  usize=usize*10+*p-'0';
					if (p==comment.s.c_str()) usize=-1;  // size not found
					for (; *p && fdate<19000000000000LL; ++p)  // read date
					  if (isdigit(*p)) fdate=fdate*10+*p-'0';
					if (fdate<19000000000000LL || fdate>=30000000000000LL) fdate=-1;

					// Read the comment attribute wN or uN where N is a number
					int attrchar=0;
					for (; true; ++p) 
					{
						if (*p=='u' || *p=='w') 
						{
							attrchar=*p;
							fattr=0;
						}
						else 
						if (isdigit(*p) && (attrchar=='u' || attrchar=='w'))
							fattr=fattr*10+*p-'0';
						else 
						if (attrchar) 
						{
							fattr=fattr*256+attrchar;
							attrchar=0;
						}
						if (!*p) 
							break;
					}

        // Test for JIDAC format. Filename is jDC<fdate>[cdhi]<num>
        // and comment ends with " jDC\x01"
					if (comment.s.size()>=4
						&& usize>=0
						&& comment.s.substr(comment.s.size()-4)=="jDC\x01"
						&& filename.s.size()==28
						&& filename.s.substr(0, 3)=="jDC"
						&& strchr("cdhi", filename.s[17])) 
						{

						  // Read the date and number in the filename. Skip over zpaqfranz
							num		=0;
							fdate	=0;
							for (unsigned i=3; i<17 && isdigit(filename.s[i]); ++i)
								fdate=fdate*10+filename.s[i]-'0';
							for (unsigned i=18; i<filename.s.size() && isdigit(filename.s[i]);++i)
								num=num*10+filename.s[i]-'0';

							// Decompress the block. In recovery mode, only decompress
							// data blocks containing missing list_HT data.
							os.reset();
							os.setLimit(usize);
							d.setOutput(&os);
							libzpaq::SHA1 sha1;
							d.setSHA1(&sha1);
							if (pass!=LIST_RECOVER || (filename.s[17]=='d' && num>0 &&
							  num<list_ht.size() && list_ht[num].csize==LIST_HT_BAD)) 
								{
									d.decompress();
									char sha1result[21]={0};
									d.readSegmentEnd(sha1result);
									if (usize!=int64_t(sha1.usize())) 
									{
										///printf( "%s size should be %1.0f, is %1.0f\n",
											///  filename.s.c_str(), double(usize),
											  ///double(sha1.usize()));
										libzpaq::error("incorrect block size");
									}
									if (sha1result[0] && memcmp(sha1result+1, sha1.result(), 20)) 
									{
										///printf( "%s checksum error\n", filename.s.c_str());
										libzpaq::error("bad checksum");
									}
								}
							else
							d.readSegmentEnd();

							
							  // Transaction header (type c).
							  // If in the future then stop here, else read 8 byte data size
							  // from input and jump over it.
							if (filename.s[17]=='c' && fdate>=19000000000000LL
								  && fdate<30000000000000LL && pass!=LIST_RECOVER) 
								{
									data_offset=in.tell()+1;
									bool isbreak=version<19000000000000LL ? list_size(list_ver)>version :
												 version<fdate;
									int64_t jmp=0;
									if (!isbreak && os.size()==8) 
									{  // jump
										const char* s=os.c_str();
										jmp=list_btol(s);
										if (jmp<0) 
										{
											return true;
																			
											isbreak=true;
										}
										else 
										if (jmp>0) 
										{
											dcsize+=jmp;
											in.seek(jmp, SEEK_CUR);
										}
									}
									if (os.size()!=8) 
									{
										///myprintf("05543! Bad JIDAC header size: %d\n", list_size(os));
										isbreak=true;
										++errors;
									}
									if (isbreak) 
									{
										done=true;
										break;
									}
									list_ver.push_back(list_VER());
									list_ver.back().firstFragment=list_size(list_ht);
									list_ver.back().offset=block_offset;
									list_ver.back().date=fdate;
									list_ver.back().csize=jmp;
								}

          // Fragment table (type h).
          // Contents is bsize[4] (sha1[20] usize[4])... for fragment N...
          // where bsize is the compressed block size.
          // Store in ht[].{sha1,usize}. Set ht[].csize to block offset
          // assuming N in ascending order.
          else if (filename.s[17]=='h' && num>0 && os.size()>=4
                   && pass!=LIST_RECOVER) {
            const char* s=os.c_str();
            const unsigned bsize=list_btoi(s);
            dhsize+=bsize;

            const unsigned n=(os.size()-4)/24;
            if (list_ht.size()>num) {
              ///printf(
                ///"Unordered fragment tables: expected >= %d found %1.0f\n",
                ///list_size(list_ht), double(num));
              pass=LIST_ERR;
            }
            double usum=0;  // total uncompressed size
            for (unsigned i=0; i<n; ++i) {
              while (list_ht.size()<=num+i) list_ht.push_back(list_HT());
              memcpy(list_ht[num+i].sha1, s, 20);
              s+=20;
              if (list_ht[num+i].csize!=LIST_HT_BAD) libzpaq::error("duplicate fragment ID");
              usum+=list_ht[num+i].usize=list_btoi(s);
              list_ht[num+i].csize=i?-int(i):data_offset;
            }
            if (usum>0) compressionRatio[data_offset]=bsize/usum;
            data_offset+=bsize;
          }

          // Index (type i)
          // Contents is: 0[8] filename 0 (deletion)
          // or:       date[8] filename 0 na[4] attr[na] ni[4] ptr[ni][4]
          // Read into list_DT
          else if (filename.s[17]=='i' && pass!=LIST_RECOVER) {
            const char* s=os.c_str();
            const char* const end=s+os.size();
            while (s<=end-9) {
              const char* fp=s+8;  // filename
              list_DT& dtr=list_dt[fp];
              dtr.dtv.push_back(list_DTV());
              list_DTV& dtv=dtr.dtv.back();
              dtv.version=list_size(list_ver)-1;
              dtv.date=list_btol(s);

              if (dtv.date) ++list_ver.back().updates;
              else ++list_ver.back().deletes;
              s+=strlen(fp)+1;  // skip filename
              if (dtv.date && s<=end-8) {
                const unsigned na=list_btoi(s);
                for (unsigned i=0; i<na && s<end; ++i, ++s)  // read attr
                  if (i<8) dtv.attr+=int64_t(*s&255)<<(i*8);
                if (s<=end-4) {
                  const unsigned ni=list_btoi(s);
                  dtv.ptr.resize(ni);
                  for (unsigned i=0; i<ni && s<=end-4; ++i) {  // read ptr
                    const unsigned j=dtv.ptr[i]=list_btoi(s);
                    if (j<1 || j>=list_ht.size()+(1<<24))
                      libzpaq::error("bad fragment ID");
                    while (j>=list_ht.size()) {
                      pass=LIST_ERR;
                      list_ht.push_back(list_HT());
                    }
                    dtv.size+=list_ht[j].usize;
                    list_ver.back().usize+=list_ht[j].usize;
                  }
                }
              }
          }
	        }

          // Recover fragment sizes and hashes from data block
          else if (pass==LIST_RECOVER && filename.s[17]=='d' && num>0
                   && num<list_ht.size()) {
            if (os.size()>=8 && list_ht[num].csize==LIST_HT_BAD) {
              const char* p=os.c_str()+os.size()-8;
              unsigned n=list_btoi(p);  // first fragment == num or 0
              if (n==0) n=num;
              unsigned f=list_btoi(p);  // number of fragments
              if (n!=num)
                printf( "fragments %u-%u were moved to %u-%u\n",
                    n, n+f-1, num, num+f-1);
              n=num;
              if (f && f*4+8<=os.size()) {
                printf( "Recovering fragments %u-%u at %1.0f\n",
                       n, n+f-1, double(block_offset));
                while (list_ht.size()<=n+f) list_ht.push_back(list_HT());
                p=os.c_str()+os.size()-8-4*f;

                // read fragment sizes into ht[n..n+f-1].usize
                unsigned sum=0;
                for (unsigned i=0; i<f; ++i) {
                  sum+=list_ht[n+i].usize=list_btoi(p);
                  list_ht[n+i].csize=i ? -int(i) : block_offset;
                }

                // Compute hashes
                if (sum+f*4+8==os.size()) {
                  printf( "Computing hashes for %s bytes\n",migliaia(sum));
                  libzpaq::SHA1 sha1;
                  p=os.c_str();
                  for (unsigned i=0; i<f; ++i) {
                    for (int j=0; j<list_ht[n+i].usize; ++j) {

                      sha1.put(*p++);
                    }
                    memcpy(list_ht[n+i].sha1, sha1.result(), 20);
                  }

                }
              }
            }

            // Correct bad offsets

            if (list_ht[num].csize!=block_offset) {
              ///printf( "Changing block %s offset from %1.0f to %1.0f\n",
                 ///    migliaia(num), double(list_ht[num].csize), double(block_offset));
              list_ht[num].csize=block_offset;
            }
          }

          // Bad JIDAC block
          else if (pass!=LIST_RECOVER) {
            ///printf( "Bad JIDAC block ignored: %s %s\n",filename.s.c_str(), comment.s.c_str());
            ++errors;
          }
        }

        // Streaming format
        else if (pass!=LIST_RECOVER) {

          // If previous version does not exist, start a new one
          if (list_size(list_ver)==1) {
            if (list_size(list_ver)>version) {
              done=true;
              break;
            }
            list_ver.push_back(list_VER());
            list_ver.back().firstFragment=list_size(list_ht);
            list_ver.back().offset=block_offset;
            list_ver.back().csize=-1;
          }

          char sha1result[21]={0};
          d.readSegmentEnd(sha1result);
          list_DT& dtr=list_dt[lastfile];
          if (filename.s.size()>0 || first) {
            dtr.dtv.push_back(list_DTV());
            dtr.dtv.back().date=fdate;
            dtr.dtv.back().attr=fattr;
            dtr.dtv.back().version=list_size(list_ver)-1;
            ++list_ver.back().updates;
          }

          dtr.dtv.back().ptr.push_back(list_size(list_ht));
          if (usize>=0 && dtr.dtv.back().size>=0) dtr.dtv.back().size+=usize;
          else dtr.dtv.back().size=-1;
          dtr.dtv.back().csize+=in.tell()-segment_offset;
          if (usize>=0) list_ver.back().usize+=usize;
          list_ht.push_back(list_HT(sha1result+1, usize>0x7fffffff ? -1 : usize,
                          segs ? -segs : block_offset));

        }
        ++segs;
        filename.s="";
        first=false;
        segment_offset=in.tell();
		
		///printf("04966: segment_offset  %d\n",segment_offset);
	
      }  // end while findFilename
      if (!done) segment_offset=block_offset=in.tell();
    }  // end try
    catch (std::exception& e) {
      block_offset=in.tell();
      ///myprintf("00918 Skipping block at %1.0f: %s\n", double(block_offset),e.what());
      ++errors;
    }
  }  // end while !done
  if (in.tell()>32*(g_password!=0) && !found_data)
	myprintf("05761$ archive contains no data\n");
  in.close();
#endif // corresponds to #ifdef (#ifdef _WIN32)
	if (arc)
		if (flagdebug3)
			myprintf("be quiet\n");
  return false;
}

int Jidac::fix(string i_thearchive)
{
	if (i_thearchive=="")
	{
		myprintf("10603: No archive (files) selected, exit\n");
		return 2;
	}
	easymultipart chunkedinput(i_thearchive);
	if (chunkedinput.filenamearray.size()==0)
	{
		myprintf("05315: Cannot find multipart arc %s\n",i_thearchive.c_str());
		return 2;
	}
	myprintf("00281: Part count %s total size %s bytes\n",migliaia(chunkedinput.filenamearray.size()),migliaia2(chunkedinput.totalchunksize));
	int 			incomplete	=0;
	int 			complete	=0;
	unsigned int 	latest		=0;

	for (unsigned int i=0;i<chunkedinput.filenamearray.size();i++)
	
	{
		myprintf("03158: Block %12s                               <<%Z>>\r",migliaia2(0),chunkedinput.filenamearray[i].filename.c_str());

		bool incomplete_trans=is_incomplete_trans(chunkedinput.filenamearray[i].filename.c_str());
		if (incomplete_trans)
		{
			chunkedinput.filenamearray[i].hashok=false;
			incomplete++;
			color_red();
			myprintf("INCOMPLETE\n");
			color_restore();
			latest=i;
		}
		else
		{
			chunkedinput.filenamearray[i].hashok=true;
			complete++;
			color_green();
			myprintf("COMPLETE\n");
			color_restore();
		}
	}
	if (incomplete>0)
	{
		color_yellow();
		myprintf("05445: Incomplete transactions %9s\n",migliaia(incomplete));
		color_restore();
	}
	else
		color_green();
	
	myprintf("05446: Complete   transactions %9s\n",migliaia(complete));
	
	if ((incomplete==1) && (latest==(chunkedinput.filenamearray.size()-1)))
	{
		color_green();
		myprintf("05446: Incomplete transaction founded, but on the last chunk\n");
		myprintf("05444: Using trim -kill you can get a 'good' archive\n");
	}
	else
	{
		if (incomplete>0)
		{
			color_yellow();
			myprintf("05346: Incomplete transaction founded, NOT on the last chunk     (this is bad)\n");
			myprintf("05244: Using trim -kill you can try to fix to extract data ASAP  (and rebuild)\n");
		}
	}
	
	color_restore();
	
	
	int theresult=incomplete>0;
	
	if ((incomplete>0) && (flagkill))
	{
		unsigned int 	latest			=0;
		int 			ghostfile		=0;
		int 			touched			=0;
		int 			renamefailed	=0;
		myprintf("05443: -kill, try to fix the multipart archive!\n");
	
		for (unsigned int i=0;i<chunkedinput.filenamearray.size();i++)
		{
			if (chunkedinput.filenamearray[i].hashok==false)
			{
				string chunkname=chunkedinput.filenamearray[i].filename;
				myprintf("05319: Chunk to be fixed <<%Z>>\n",chunkname.c_str());
				if (fileexists(chunkname))
				{
					string renamedchunk=chunkname;
					forceextension(renamedchunk,".spaz");
					if (flagdebug3)
						myprintf("05970: New name %Z to %Z\n",chunkname.c_str(),renamedchunk.c_str());
					renamedchunk=nomefileseesistegia(renamedchunk);
					myprintf("05518: Renaming to       <<%Z>>\n",renamedchunk.c_str());
					if (myrename(chunkname,renamedchunk)==0)
					{
						myprintf("05542: Creating empty    transaction:");
						FILE* myfile=fopen(chunkname.c_str(),"wb");
						if (myfile==NULL)
						{
							myprintf("\n");
							myprintf("04231! cannot write on %s\n",chunkname.c_str());
							seppuku();
						}
						fclose(myfile);
						touched++;
						color_green();
						myprintf(" DONE\n");
						color_restore();
						latest=i;
					}
					else
					{
						myprintf("\n");
						myprintf("05554! myrename failed %Z to %Z\n",chunkname.c_str(),renamedchunk.c_str());
						renamefailed++;
					}
				}
				else
				{
					ghostfile++;
				}
			}
			
		}
		if (ghostfile>0)
			myprintf("05814$ ghostfile    %9s (should be zero)\n",migliaia(ghostfile));
		if (renamefailed>0)
			myprintf("05815$ renamefailed %9s (should be zero)\n",migliaia(renamefailed));
		
		if (touched==incomplete)
			color_green();
		myprintf("05816: Fixed chunks     %9s (should be %s)\n",migliaia(touched),migliaia(incomplete));
		color_restore();
		
		if (touched>0)
		{
			if ((touched==1) && (latest==(chunkedinput.filenamearray.size()-1)))
			{
				string thelastfile=chunkedinput.filenamearray[chunkedinput.filenamearray.size()-1].filename;
				if (prendidimensionefile(thelastfile.c_str())==0)
				{
					if (delete_file(thelastfile.c_str()))
					{
						color_green();
						myprintf("05438: The trimmed multipart archive is a 'good archive' now\n");
						color_restore();
						theresult=0;
					}
					else
					{
						myprintf("05431$ Cannot delete last chunk!\n");
						theresult=1;
					}
				}
				else
				{
					myprintf("05432$ The fixed multipart archive (should be) a 'good archive' now\n");
					theresult=1;
				}
			}
			else
			{
				myprintf("05843! Beware: the fixed multipart archive is NOT a 'good archive'\n");
				myprintf("05844!         Please extract the data ASAP, and rebuild a BRAND NEW 'good' archive!\n");
				theresult=1;
			}
		}
	}
	
	return theresult;
}

#ifdef ZPAQFULL ///NOSFTPSTART
#ifdef SFTP
bool update_quick_hash(XXHash64* i_hash,string i_filename)
{
	int64_t piecesize=prendidimensionefile(i_filename.c_str());
	if (flagdebug3)
		myprintf("07791: open %s size %s\n",i_filename.c_str(),migliaia2(piecesize));
	if (piecesize>16384)
	{
		myprintf("07794: piece too big (>16384) %s\n",migliaia(piecesize));
		return false;
	}
	
	FILE* myfilez = freadopen(i_filename.c_str());
	
	if	(myfilez==NULL)
	{
#ifdef _WIN32
		int err=GetLastError();
		string codice=decodewinerror(err,NULL);
		myprintf("07894! error kind %d %s opening <<%Z>>\n",err,codice.c_str(),i_filename.c_str());
#else
		myprintf("07893! error opening <<%Z>>\n",i_filename.c_str());
#endif

		return false;
	}


	const int BUFSIZE	=16384;
	unsigned char 		unzBuf[BUFSIZE];
	int 				n=BUFSIZE;

	int r=fread(unzBuf,1,n,myfilez);
	if (flagdebug3)
		myprintf("07808: readed %s piecesize %s\n",migliaia(r),migliaia2(piecesize));
	if (r!=piecesize)
	{
		myprintf("01802: Error reading data r %s n %s\n",migliaia(r),migliaia2(n));
		fclose(myfilez);
		return false;
	}
	(*i_hash).add(unzBuf,r);
	fclose(myfilez);
	if (!delete_file(i_filename.c_str()))
		myprintf("07837! cannot delete file <<%Z>>\n",i_filename.c_str());
	
	return true;
}


std::string sftp_get_quick(const std::string& i_remotefile, int64_t& o_filesize, double& o_time)
{
    o_time 		= 0;
    o_filesize 	= 0;
    if (flagdebug)
        myprintf("07848: entering sftp_get_quick\n");

    if (i_remotefile.empty())
    {
        myprintf("07896! i_remotefile empty\n");
        return "";
    }

    // Use a single instance for the entire operation
    zpaqfranzsftp2 client;
	if (g_sftp_key!="")
		client.setConnectionSSH(g_sftp_host, g_sftp_port, g_sftp_user, g_sftp_key);
    else
		client.setConnection(g_sftp_host, g_sftp_port, g_sftp_user, g_sftp_password);
    if (!client.connect())
    {
        myprintf("86623: Cannot connect client\n");
        return "";
    }

    // Get file size remoto
    o_filesize = client.remotegetfilesize(i_remotefile);
    if (flagdebug3)
        myprintf("07809: remotefilesize %s\n", migliaia(o_filesize));

    if (o_filesize == -1)
    {	
		if (flagverbose)
			myprintf("07814: cannot get remotefilesize for %s\n", i_remotefile.c_str());
		else
			myprintf("07815: no remotefilesize\n");
		
        return "";
    }

    int64_t startget 	= mtime();
	uint64_t myseed 	= 0;
    XXHash64 myhash(myseed);
    
    if (o_filesize < 65536)
    {
        if (flagdebug3)
            myprintf("07822: full xxdownload because remotefilesize <65536\n");
        std::string file0 = g_gettempdirectory() + "pezzo0.bin";
        file0 = nomefileseesistegia(file0);

        // Use the same client for the download
        if (!client.downfilerange(i_remotefile, file0, 0, o_filesize - 1, false))
        {
            myprintf("86390: Errore download file %s\n", file0.c_str());
            return "";
        }

        if (flagdebug3)
            myprintf("07834: Done file 0 %s size %s\n", file0.c_str(), migliaia(prendidimensionefile(file0.c_str())));

        franz_do_hash dummyquick("QUICK");
        g_dimensione = 0;
        int64_t startverify = mtime();
        std::string temp = dummyquick.filehash(0,file0, false, startverify, prendidimensionefile(file0.c_str()));
        o_time = (mtime() - startverify) / 1000.0;
        delete_file(file0.c_str());
        return temp;
    }
    else
    {
        std::string file1 = g_gettempdirectory() + "pezzo1.bin";
        file1 = nomefileseesistegia(file1);

        std::string file2 = g_gettempdirectory() + "pezzo2.bin";
        file2 = nomefileseesistegia(file2);

        std::string file3 = g_gettempdirectory() + "pezzo3.bin";
        file3 = nomefileseesistegia(file3);

        if (flagdebug3)
            myprintf("07829: Scaricamento 3 chunk per %s\n", i_remotefile.c_str());

        // Use the same client for down3
	   if (!client.down3(o_filesize, i_remotefile, file1, file2, file3))
        {
            myprintf("86390: Errore download 3 chunk per %s\n", i_remotefile.c_str());
            delete_file(file1.c_str());
            delete_file(file2.c_str());
            delete_file(file3.c_str());
            return "";
        }
        if (flagdebug3)
        {
            myprintf("07834: Done file 1 %s size %s\n", file1.c_str(), migliaia(prendidimensionefile(file1.c_str())));
            myprintf("07835: Done file 2 %s size %s\n", file2.c_str(), migliaia(prendidimensionefile(file2.c_str())));
            myprintf("07839: Done file 3 %s size %s\n", file3.c_str(), migliaia(prendidimensionefile(file3.c_str())));
        }

        if (!update_quick_hash(&myhash, file1) ||
            !update_quick_hash(&myhash, file2) ||
            !update_quick_hash(&myhash, file3))
        {
            delete_file(file1.c_str());
            delete_file(file2.c_str());
            delete_file(file3.c_str());
            return "";
        }

        delete_file(file1.c_str());
        delete_file(file2.c_str());
        delete_file(file3.c_str());
    }

    std::string hexhash = bin2hex_64(myhash.hash());
    o_time = (mtime() - startget) / 1000.0;
    if (flagdebug3)
        myprintf("07912: Final %s time %.2f s\n", hexhash.c_str(), o_time);
    return hexhash;
}

bool 	sftp_verify(const string i_localfile,const string i_remotefile,
string& 	o_localhash,
int64_t&	o_localfilesize,
string&		o_remotehash,
int64_t& 	o_remotefilesize,
double& o_time)
{
	o_time				=0;
	o_localhash			="";
	o_localfilesize		=-1;
	o_remotehash		="";
	o_remotefilesize	=-1;
	
	if (flagdebug)
		myprintf("07848: entering sftp_verify\n");
	
	if (i_remotefile=="")
	{
		myprintf("07892! i_remotefile empty\n");
		return false;
	}
	if (i_localfile=="")
	{
		myprintf("07821! i_remotefile empty\n");
		return false;
	}
	if (!fileexists(i_localfile))
	{
		myprintf("08062! cannot find i_localfile <<%Z>>\n",i_localfile.c_str());
		return false;
	}

	franz_do_hash dummyquick("QUICK");
	g_dimensione=0;
	int64_t startverify=mtime();
	o_localhash=dummyquick.filehash(0,i_localfile,false,startverify,prendidimensionefile(i_localfile.c_str()));
		myprintf("80093: Local  %s [%21s] from SFTP...\n",o_localhash.c_str(),migliaia(dummyquick.o_thefilesize));
	
	double	thetime;
	o_remotehash=sftp_get_quick(i_remotefile,o_remotefilesize,thetime);
	if (o_remotehash=="")
	{
		myprintf("08012! cannot get the quickhash\n");
		return false;
	}
	if (flagverbose)
		myprintf("80047: Remote %s [%21s] time %.3f\n",o_remotehash.c_str(),migliaia(o_remotefilesize),thetime);
	o_localfilesize	=dummyquick.o_thefilesize;
		
	if ((dummyquick.o_thefilesize==o_remotefilesize) && (o_localhash==o_remotehash))
	{
		o_time			=thetime;
		return true;
	}
	if (o_localfilesize!=o_remotefilesize)
		myprintf("08536$ local file  size %s != remote file size %s\n",migliaia(o_localfilesize),migliaia2(o_remotefilesize));
	if (o_localhash!=o_remotehash)
		myprintf("08537$ local quick hash %s != remote quick hash %s\n",o_localhash.c_str(),o_remotehash.c_str());
	
	o_localhash			="";
	o_localfilesize		=-1;
	o_remotehash		="";
	o_remotefilesize	=-1;
	return false;

}

string change_path(string i_file,string i_newpath)
{
	if (i_file=="")
	{
		myprintf("08135! i_file ''\n");
		return "";
	}
	if (i_newpath=="")
	{
		myprintf("08137! i_newpath ''\n");
		return "";
	}
	return (includetrailingbackslash(i_newpath)+extractfilename(i_file));
}
		

int Jidac::sftp_dorsync()
{		
	if (files.size()!=3)
	{
		myprintf("07885: You must enter ONE local folder and ONE remote folder\n");
		return 2;
	}

	flagforcezfs=true;
	g_arraybytescanned.push_back(0);
	g_arrayfilescanned.push_back(0);
	edt.clear();
	scandir(false,edt,files[1].c_str(),false);
	std::vector<sftpfileinfo> localfiles;
	for (DTMap::iterator a=edt.begin(); a!=edt.end(); ++a)
	{
		sftpfileinfo info;
		info.name = a->first;
		info.size = a->second.size;
		info.modtime=0;
		info.isdirectory = false;
		localfiles.push_back(info);
	}
	if (localfiles.size()==0)
	{
		myprintf("0043! zero file(s) founded\n");
		return 2;
	}
	int64_t totallocalsize=0;
	for (unsigned int i=0;i<localfiles.size();i++)
	{
		totallocalsize+=localfiles[i].size;
		
		if (flagdebug)
		{
			if (iszpaq(localfiles[i].name.c_str()))
				color_green();
				
			myprintf("08613: %08d %21s <<%Z>>\n",i,
			migliaia(localfiles[i].size),
			localfiles[i].name.c_str());
			color_restore();
		}
	}

	
	string remotepath = files[2];
	myprintf("85447: Creating remote path");
	eol();
	myprintf("\n");
	zpaqfranzsftp2 client1;
	
	if (g_sftp_key!="")
		client1.setConnectionSSH(g_sftp_host,g_sftp_port,g_sftp_user,g_sftp_key);
	else
		client1.setConnection(g_sftp_host,g_sftp_port,g_sftp_user,g_sftp_password);
	if (!client1.connect())
	{
		myprintf("85433: Cannot connect client\n");
		return 2;
	}

	if (!client1.sftpmkdir(remotepath))
		myprintf("85440! Remote path seems kaputt, continue anyway (let's hope for the best) %s\n",remotepath.c_str());
	
	myprintf("85443: Enumerating remote files\n");
	
	std::vector<sftpfileinfo> remotefiles;
	
	zpaqfranzsftp2 sftp2;
	if (g_sftp_key!="")
		sftp2.setConnectionSSH(g_sftp_host,g_sftp_port,g_sftp_user,g_sftp_key);
	else
		sftp2.setConnection(g_sftp_host,g_sftp_port,g_sftp_user,g_sftp_password);
	sftp2.connect(); 
	
	sftp2.listremotedir(remotepath,&remotefiles);
	if (remotefiles.size()==0)
		myprintf("38641$ INFO: no file founded on remote path\n");

	int64_t totalremotesize=0;
	for (unsigned int i=0;i<remotefiles.size();i++)
	{
		remotefiles[i].name=includetrailingbackslash(extractfilepath(remotepath))+remotefiles[i].name;
		totalremotesize+=remotefiles[i].size;

		if (flagdebug)
		{
			if (iszpaq(remotefiles[i].name.c_str()))
				color_green();
			myprintf("58616: %08d %21s <<%Z>>\n",i,
			migliaia(remotefiles[i].size),
			remotefiles[i].name.c_str());
			color_restore();
		}
	}
	
	// Create maps for quick comparison using the full file name (without normalization)
	std::map<string, sftpfileinfo> localmap;
	std::map<string, sftpfileinfo> remotemap;

	// Populate local map
	for (unsigned int i = 0; i < localfiles.size(); i++) 
	{
		string filename = extractfilename(localfiles[i].name); // Full name, including zeros
		localmap[filename] = localfiles[i];
		if (flagdebug)
			myprintf("Locale %08d %21s %s\n",i,migliaia(localfiles[i].size),filename.c_str());
	}

	// Populate remote map
	for (unsigned int i = 0; i < remotefiles.size(); i++) 
	{
		string filename = extractfilename(remotefiles[i].name); // Full name, including zeros
		remotemap[filename] = remotefiles[i];
		if (flagdebug)
			myprintf("Remota %08d %21s %s\n",i,migliaia(remotefiles[i].size),filename.c_str());
	}

	// Vettori per le operazioni
	std::vector<string> files_to_delete;    // Remote files to delete
	std::vector<string> files_to_upload;    // Local files to upload (new)
	std::vector<string> files_to_update;    // Files to update (dimensione diversa)

	// 1. Find remote files to delete (exist remotely but not locally)
	for (std::map<string, sftpfileinfo>::iterator it = remotemap.begin(); it != remotemap.end(); ++it) 
	{
		string filename = it->first;
		if (localmap.find(filename) == localmap.end()) 
			files_to_delete.push_back(it->second.name); // Full name with path
	}

	// 2. Find files to upload and update
	for (std::map<string, sftpfileinfo>::iterator it = localmap.begin(); it != localmap.end(); ++it) 
	{
		string filename = it->first;
		sftpfileinfo localfile = it->second;
		if (flagdebug) 
			myprintf("86794: DEBUG - filename %s\n",filename.c_str());
		std::map<string, sftpfileinfo>::iterator remote_it = remotemap.find(filename);
		if (remote_it == remotemap.end()) 
		{
			// File does not exist remotely -> to upload
			files_to_upload.push_back(localfile.name);
		} 
		else 
		{
			// File exists remotely -> check size
			sftpfileinfo remotefile = remote_it->second;
				// Different size -> to be updated
			if (localfile.size != remotefile.size) 
				files_to_update.push_back(localfile.name);
		}
	}

	
	myprintf("08616: RSYNC  : local bytes %s remote bytes %s",migliaia(totallocalsize),migliaia2(totalremotesize));
	eol();
	myprintf("\n");
	
	// Files to delete
	if (files_to_delete.size() > 0) 
	{
		color_red();
		myprintf("86859: Files to DELETE from remote (%d):\n", (int)files_to_delete.size());	
		for (unsigned int i = 0; i < files_to_delete.size(); i++) 
		{
			string filename = extractfilename(files_to_delete[i]);
			int64_t size = remotemap[filename].size;
			myprintf("  DEL: %21s %s\n", migliaia(size), filename.c_str());
		}
		color_restore();
	} 
	else 
		myprintf("86869: DELETE : No files to delete from remote\n");
	
	int64_t upload_size = 0;
	if (files_to_upload.size() > 0) 
	{
		color_yellow();
		myprintf("86877: Files to UPLOAD to remote (%d):\n", (int)files_to_upload.size());
		for (unsigned int i = 0; i < files_to_upload.size(); i++) 
		{
			string filename = extractfilename(files_to_upload[i]);
			int64_t size = localmap[filename].size;
			upload_size += size;
			myprintf("  NEW: %21s %s\n", migliaia(size), filename.c_str());
		}
		myprintf("Total upload size: %s\n", migliaia(upload_size));
		color_restore();
	} 
	else 
		myprintf("86888: UPLOAD : No new files to upload\n");
	
	int64_t update_size = 0;
	if (files_to_update.size() > 0) 
	{
		color_yellow();
		myprintf("85897: Files to UPDATE on remote (%d):\n", (int)files_to_update.size());
		for (unsigned int i = 0; i < files_to_update.size(); i++) {
			string filename = extractfilename(files_to_update[i]);
			int64_t local_size = localmap[filename].size;
			int64_t remote_size = remotemap[filename].size;
			update_size += local_size;
			myprintf("  UPD: %21s -> %21s %s\n", 
					 migliaia(remote_size), migliaia2(local_size), filename.c_str());
		}
		myprintf("Total update size: %s\n", migliaia(update_size));
		color_restore();
	} 
	else 
		myprintf("86897: UPDATE : No files to update\n");
	
	// Summary
	int total_operations=files_to_delete.size()+files_to_upload.size()+files_to_update.size();
	if (total_operations==0) 
	{
		color_green();
		myprintf("Everything is in sync! No operations needed.\n");
		color_restore();
		return 0;
	}

	myprintf("\n");
	myprintf("Operations total: %d -%d +%d #%d, bytes %s\n", 
	total_operations,
	(int)files_to_delete.size(),(int)files_to_upload.size(),(int)files_to_update.size(),migliaia(update_size + upload_size));


	if (files_to_delete.size() > 0) 
	{
		color_red();
		if (!flagkill)
		{
			printDigitalString("BEWARE");
			myprintf("******* YOU MUST USE -kill TO ENABLE FILE DELETE ********\n");
		}
		else
		{
			unsigned int deleted_ok=0;
			for (unsigned int i=0;i<files_to_delete.size(); i++) 
			{		
				string remotefile = (files_to_delete[i]);
				myprintf("87878: Deleting %s\n",remotefile.c_str());
				zpaqfranzsftp2 mydelete;
	
				if (g_sftp_key!="")
					mydelete.setConnectionSSH(g_sftp_host,g_sftp_port,g_sftp_user,g_sftp_key);
				else
					mydelete.setConnection(g_sftp_host,g_sftp_port,g_sftp_user,g_sftp_password);
				if (!mydelete.connect()) 
				{
					myprintf("87844: Cannot connect SFTP in delete\n");
					return 2;
				}

				if (!sftp2.sftpdeletefile(remotefile))
					myprintf("87889: Cannot delete %Z\n",remotefile.c_str());
				else
					deleted_ok++;
			}
			if (deleted_ok==files_to_delete.size())
			{
				color_green();
				myprintf("87896: Deleting completed\n");
				color_restore();
			}
			else
				myprintf("87900! Expected to be deleted %d done %d\n",files_to_delete.size(),deleted_ok);
		}
		color_restore();
	}
	

	string myremotepath=extractfilepath(remotepath);

	if (howmanythreads<1)
		howmanythreads=numberOfProcessors();
	
	if (!flagssd)
		howmanythreads=1;
	
	int errori=0;
	// Files to update
	if (files_to_update.size() > 0) 
	{
		myprintf("86931: Starting update of %s for %s bytes\n",migliaia(files_to_update.size()),migliaia2(update_size));
		std::vector<string> local_files_array;
		std::vector<string> remote_files_array;
		for (unsigned int i=0;i<files_to_update.size();i++)
		{
			string filename = extractfilename(files_to_update[i]);
			string localname= localmap[filename].name;
			local_files_array.push_back(localname);
			///myprintf("%s ===> %s\n",localname.c_str(),remotename.c_str());
		}
		zpaqfranzsftp2 client;

		if (g_sftp_key!="")
			client.setConnectionSSH(g_sftp_host,g_sftp_port,g_sftp_user,g_sftp_key);
		else
			client.setConnection(g_sftp_host,g_sftp_port,g_sftp_user,g_sftp_password);
		if (!client.connect()) 
		{
			myprintf("86912: Cannot client files_to_update\n");
			return 2;
		}
	
		if (!client.sftp_rsync(local_files_array,myremotepath,flagforce,howmanythreads))
				errori++;
	}

	if (files_to_upload.size() > 0) 
	{
		myprintf("86935: Starting upload of %s for %s bytes\n",migliaia(files_to_upload.size()),migliaia2(upload_size));
		std::vector<string> local_files_array;
		for (unsigned int i=0;i<files_to_upload.size();i++)
		{
			string filename = extractfilename(files_to_upload[i]);
			string localname= localmap[filename].name;
			local_files_array.push_back(localname);
		///	myprintf("%s ===> %s\n",localname.c_str(),remotename.c_str());
		}
		zpaqfranzsftp2 client;
		if (g_sftp_key!="")
		client.setConnectionSSH(g_sftp_host,g_sftp_port,g_sftp_user,g_sftp_key);
		else
		client.setConnection(g_sftp_host,g_sftp_port,g_sftp_user,g_sftp_password);
		if (!client.connect()) 
		{
			myprintf("86914: Cannot client files_to_upload\n");
			return 2;
		}
		if (!client.sftp_rsync(local_files_array,myremotepath,flagforce,howmanythreads))
			errori++;
	}

	return errori;
}		
		
int Jidac::sftp_doupload()
{
	if (files.size()!=3)
	{
		myprintf("07880: You must enter ONE local filename and ONE remote folder\n");
		return 2;
	}
	string localfile	=files[1];
	if (!flaglast)
	{
		if (iswildcard(localfile))
			///			if (strrchr(localfile.c_str(), '?'))
		{
			myprintf("08302! sftp backup is for single file, do not use ? or * (-last). Try rsync\n");
			return 2;
		}
	}
	else
	{
		flagforcezfs=true;
		g_arraybytescanned.push_back(0);
		g_arrayfilescanned.push_back(0);
		edt.clear();
		scandir(false,edt,localfile.c_str(),false);
		vector<string> filename;
		for (DTMap::iterator a=edt.begin(); a!=edt.end(); ++a)
			filename.push_back(a->first.c_str());

		if (filename.size()==0)
		{
			myprintf("00363! no last file founded\n");
			return 2;
		}
		std::sort(filename.begin(),filename.end());

		localfile=filename.back();
		
		myprintf("86500: Filename to upload due to -last %Z\n",localfile.c_str());
		
		return 0;
	}
	if (!fileexists(localfile.c_str()))
	{
		myprintf("08307: local file does not exists <<%Z>>\n",localfile.c_str());
		return 2;
	}
	string	remotepath	=includetrailingbackslash(files[2]);
	
	color_green();
	if (flagverbose)
		myprintf("08645: SFTP upload - checking/making remote path <<%Z>>...\n",remotepath.c_str());
	///else
		///myprintf("08643: Starting SFTP upload\n");
		
	color_restore();
	
	
	zpaqfranzsftp2 client1;
	
	if (g_sftp_key!="")
		client1.setConnectionSSH(g_sftp_host,g_sftp_port,g_sftp_user,g_sftp_key);
	else
		client1.setConnection(g_sftp_host,g_sftp_port,g_sftp_user,g_sftp_password);
	if (!client1.connect())
	{
		myprintf("86623: Cannot connect client\n");
		return 2;
	}

	if (!client1.sftpmkdir(remotepath))
		myprintf("08437! Remote path seems kaputt, continue anyway (let's hope)\n");

	string remotefile=change_path(localfile,remotepath);
	if (flagverbose)
		myprintf("08343: Uploading archive %Z => %Z\n",localfile.c_str(),remotefile.c_str());

	zpaqfranzsftp2 client2;
	if (g_sftp_key!="")
		client2.setConnectionSSH(g_sftp_host,g_sftp_port,g_sftp_user,g_sftp_key);
	else
		client2.setConnection(g_sftp_host,g_sftp_port,g_sftp_user,g_sftp_password);
	if (!client2.connect())
	{
		myprintf("86623: Cannot connect client2\n");
		return 2;
	}
	if (!flagforce)
	{
		
		int64_t thefilesize;
		double	thetime;
		color_yellow();
		
		myprintf("83111: APPEND, checking...");
		string 	thequickhash=sftp_get_quick(remotefile,thefilesize,thetime);
		myprintf("%f s ",thetime);
		color_restore();
		
		if (thefilesize>0)
		{
			if (flagdebug)
			{
				myprintf("\n");
				myprintf("87435: Quick-checking local <<%Z>>\n",localfile.c_str());
			}
			franz_do_hash dummyquick("QUICK");
			int64_t startverify=0;
			g_dimensione = 0;
			int64_t dummy=0;
			std::string tempquick = dummyquick.filehash(0,localfile, false, startverify,dummy,thefilesize);
			if (tempquick!=thequickhash)
			{
				myprintf("\n");
				myprintf("87455! Remote quick %s != local quick %s => abort!\n",thequickhash.c_str(),tempquick.c_str());
				return 2;
			}
			color_green();
			myprintf(" : GOOD!\n");
			color_restore();
		}
	}
	else
	{
		if (flagverbose)
			myprintf("87111: OK, starting transfer from scratch (-force)\n");
	}
	if(!client2.karica(localfile,remotefile,flagforce)) 
	{
		myprintf("87114: karika failed\n");
		return 2;
	}
	
	if (flagverbose)
	{
		color_green();
		myprintf("87118: File uploaded for %s bytes\n",migliaia(prendidimensionefile(localfile.c_str())));
	}

	color_yellow();
	myprintf("08363: Quick ... ");
	int64_t thefilesize;
	double	thetime;
	int64_t remotefilesize;
	string	localhash,remotehash;
	if (sftp_verify(localfile,remotefile,localhash,thefilesize,remotehash,remotefilesize,thetime))
	{
		color_green();
		myprintf("87530: VERIFY OK in %.3f s\n",migliaia(thefilesize),thetime);
		color_restore();
		return 0;
	}
	myprintf("\n");
	myprintf("87536! VERIFY FAILED!!!\n");
	return 2;
}



std::string sftp_get_quick_remote(std::string remotepath,std::vector<sftpfileinfo>&remotefiles,std::vector<sftpget3>& quick_hash3,int i_thread,int64_t& o_totalsize)
{
	o_totalsize=0;

	for (unsigned int i=0;i<remotefiles.size();i++)
	{
		o_totalsize+=remotefiles[i].size;
		if (flagdebug3)
		{
			if (iszpaq(remotefiles[i].name.c_str()))
				color_green();
			myprintf("08316: %21s <<%Z>> <<%Z>>\n",migliaia(remotefiles[i].size),remotefiles[i].name.c_str(),(includetrailingbackslash(remotepath)+remotefiles[i].name).c_str());
			color_restore();
		}
		
		sftpget3 entry;
		entry.i_name = includetrailingbackslash(remotepath)+remotefiles[i].name;
		
		std::string index = std::to_string(i);  // format "01", "02", etc.
	
		entry.i_file1 = g_gettempdirectory()+"uno_"+index;
		entry.i_file1 = nomefileseesistegia(entry.i_file1);
		entry.i_file2 = g_gettempdirectory()+"due_"+index;
		entry.i_file2 = nomefileseesistegia(entry.i_file2);
		entry.i_file3 = g_gettempdirectory()+"tre_"+index;
		entry.i_file3 = nomefileseesistegia(entry.i_file3);
		
		
		entry.o_size = 0;     // to be calculated later
		entry.o_hash = "";    // to be calculated later
		quick_hash3.push_back(entry);
	}
		
	zpaqfranzsftp2 sftp;
	
	if (g_sftp_key!="")
		sftp.setConnectionSSH(g_sftp_host,g_sftp_port,g_sftp_user,g_sftp_key);
	else
		sftp.setConnection(g_sftp_host,g_sftp_port,g_sftp_user,g_sftp_password);
	
	if (!sftp.connect()) 
	{
		myprintf("87406: cannot connect to sftp object\n");
		return "";
	}

	if (i_thread>99)
		i_thread=99; // no excessive hammering
	if ((unsigned)i_thread>remotefiles.size())
		i_thread=remotefiles.size();

	sftp.sftp_down3parallela(quick_hash3,i_thread);
	libzpaq::SHA256 sha256;

	for (unsigned int i=0;i<quick_hash3.size();i++)
	{
		string file1=quick_hash3[i].i_file1;
		string file2=quick_hash3[i].i_file2;
		string file3=quick_hash3[i].i_file3;
		
		quick_hash3[i].o_hash="";
			
		uint64_t myseed = 0;
		XXHash64 myhash(myseed);

		if (quick_hash3[i].o_size<65536)
		{
			franz_do_hash dummyquick("QUICK");
			int64_t startverify=0;
			g_dimensione = 0;
			std::string temp = dummyquick.filehash(0,file1, false, startverify, quick_hash3[i].o_size);
			quick_hash3[i].o_hash=temp;
		}
		else
		{
	
			if (!update_quick_hash(&myhash, file1) ||
				!update_quick_hash(&myhash, file2) ||
				!update_quick_hash(&myhash, file3))
			{
				
			}
			std::string hexhash = bin2hex_64(myhash.hash());
			quick_hash3[i].o_hash=hexhash;
		}

		for (const char* p=quick_hash3[i].o_hash.c_str(); *p; ++p)
			sha256.put(*p);
		if (flagdebug3)
			myprintf("87448: %08d QUICK:%s %20s %s\n",i,quick_hash3[i].o_hash.c_str(),migliaia(quick_hash3[i].o_size),quick_hash3[i].i_name.c_str());
		if (!flagdebug)
		{
			delete_file(file1.c_str());
			delete_file(file2.c_str());
			delete_file(file3.c_str());
		}

	}
	char sha256result[32];
	memcpy(sha256result, sha256.result(), 32);
	std::string risultato=binarytohex((const unsigned char*)sha256result,32);
			
	return risultato;
}

int Jidac::sftp_doquick()
{
	if (!flagssd)
	{
		if (files.size()!=2)
		{
			myprintf("07804: You must enter ONE remote filename\n");
			return 2;
		}
		myprintf("08035: Getting quick hash of remote file...\n");
		int64_t thefilesize;
		double	thetime;

		string 	thequickhash=sftp_get_quick(files[1],thefilesize,thetime);
		if (thequickhash=="")
		{
			myprintf("08008! Cannot get the quickhash (no internet? file does not exists? no access?)\n");
			return 2;
		}
		myprintf("80007: QUICK remote hash %s filesize %s time %.3f\n",thequickhash.c_str(),migliaia(thefilesize),thetime);
		return 0;
	}
	
	/// we get -ssd
	
	if (files.size()!=2)
	{
		myprintf("07883: You must enter ONE remote folder\n");
		return 2;
	}
	string remotepath	=files[1];
	std::vector<sftpfileinfo> remotefiles;
	zpaqfranzsftp2 client;
	if (g_sftp_key!="")
		client.setConnectionSSH(g_sftp_host,g_sftp_port,g_sftp_user,g_sftp_key);
	else
		client.setConnection(g_sftp_host,g_sftp_port,g_sftp_user,g_sftp_password);
	client.connect(); 
	client.listremotedir(remotepath,&remotefiles);
	if (remotefiles.size()==0)
	{
		myprintf("08641! No file found on remote path\n");
		return 1;
	}
	
	std::vector<sftpget3> quick_hash3;
	int64_t dummy;
	string globalremote=sftp_get_quick_remote(remotepath,remotefiles,quick_hash3,howmanythreads,dummy);
	
	for (unsigned int i=0;i<quick_hash3.size();i++)
		myprintf("%08d QUICKZ:%s %21s %s\n",i,quick_hash3[i].o_hash.c_str(),migliaia(quick_hash3[i].o_size),quick_hash3[i].i_name.c_str());
	if (globalremote=="")
		return 2;
	
	myprintf("81340: GLOBAL SHA256: %s\n",globalremote.c_str());
	return 0;
}



// Function to find a file by name in a vector of sftpget3
int findRemoteFile(const std::vector<sftpget3>& remotes, const std::string& fileName) 
{
    for (unsigned int i = 0; i < remotes.size(); i++) 
	{
        std::string remoteName = extractfilename(remotes[i].i_name);
        if (remoteName == fileName) 
		    return (int)i;
    }
    return -1; // not found
}

// Function to find a file by name in a vector of sftpfileinfo
int findLocalFile(const std::vector<sftpfileinfo>& locals, const std::string& fileName) 
{
    for (unsigned int i = 0; i < locals.size(); i++) 
	{
        std::string localName = extractfilename(locals[i].name);
        if (localName == fileName) 
		    return (int)i;
    }
    return -1; // not found
}
bool comparaquick(std::vector<sftpget3>& i_remoti, std::vector<sftpfileinfo>& i_locali) 
{
    bool allMatch = true;
    
    // Use vector to keep track of already checked local files
    std::vector<bool> localChecked(i_locali.size(), false);
    
    if (flagverbose)
        myprintf("81373: Checking remote vs local\n");
    
    // Check all remote files
    for (size_t i = 0; i < i_remoti.size(); i++) 
    {
        std::string remoteFileName = extractfilename(i_remoti[i].i_name);
        std::string remoteHash = i_remoti[i].o_hash;
        int64_t remoteSize = i_remoti[i].o_size;
        
        // Search for the corresponding file in locals
        int localIndex = findLocalFile(i_locali, remoteFileName);
        
        if (localIndex == -1) 
        {
            // File present only remotely
            myprintf("81387! NOT in local : %s (REMOTE idx:%d hash:%s size:%s)\n", 
                   remoteFileName.c_str(), i, remoteHash.c_str(), migliaia(remoteSize));
            allMatch = false;
        } 
        else 
        {
            // Check that the index is valid
            if (localIndex >= 0 && localIndex < static_cast<int>(i_locali.size())) 
            {
                // File present in both - check hash and size
                localChecked[localIndex] = true;
                
                std::string localHash = i_locali[localIndex].hash;
                int64_t localSize = i_locali[localIndex].size;
                
                if (remoteHash != localHash) 
                {
                    myprintf("88402! HASH KAPUTT: %s\n", remoteFileName.c_str());
                    myprintf("88403!  REMOTE (idx:%d): %s size:%21s\n", i, remoteHash.c_str(), migliaia(remoteSize));
                    myprintf("88404!  LOCAL  (idx:%d): %s size:%21s\n", localIndex, localHash.c_str(), migliaia(localSize));
                    allMatch = false;
                } 
                else if (remoteSize != localSize) 
                {
                    myprintf("88405! SIZE KAPUTT: %s\n", remoteFileName.c_str());
                    myprintf("88406!  REMOTE (idx:%d): size:%21s hash:%s\n", i, migliaia(remoteSize), remoteHash.c_str());
                    myprintf("88407!  LOCAL  (idx:%d): size:%21s hash:%s\n", localIndex, migliaia(localSize), localHash.c_str());
                    allMatch = false;
                }
                // If everything is OK, it prints nothing (optional: uncomment the line below for debugging)
                // else { printf("OK: %s (hash:%s size:%lld)\n", remoteFileName.c_str(), remoteHash.c_str(), (long long)remoteSize); }
            }
            else 
            {
                myprintf("88420! ERROR: local index not good %d for %s\n", 
                       localIndex, remoteFileName.c_str());
                allMatch = false;
            }
        }
    }
    
    // Check local files that have not yet been checked
    for (size_t i = 0; i < i_locali.size(); i++) 
    {
        if (!localChecked[i]) 
        {
            // File present only locally
            std::string localFileName = extractfilename(i_locali[i].name);
            std::string localHash = i_locali[i].hash;
            int64_t localSize = i_locali[i].size;
            
            myprintf("81429! NOT in remote : %s (LOCAL idx:%d hash:%s size:%s)\n", 
                   localFileName.c_str(), i, localHash.c_str(), migliaia(localSize));
            allMatch = false;
        }
    }
    
    if (allMatch) 
    {
        color_green();
        myprintf("81436: Perfect match! THIS IS VERY GOOD!\n");
        color_restore();
    } 
    else 
    {
        myprintf("18440$ Something wrong, compare not good\n");
    }
    
    // Non serve delete[], il vector si gestisce automaticamente
    return allMatch;
}
int Jidac::sftp_do1on1()
{
	if (files.size()!=3)
	{
		myprintf("88333: You must enter ONE local folder and ONE remote folder\n");
		return 2;
	}
	
	string remotepath	=files[2];
	if (flagverbose)
		myprintf("86185: 1on1 remotepath %s\n",remotepath.c_str());
	std::vector<sftpfileinfo> remotefiles;
	zpaqfranzsftp2 client;
	if (g_sftp_key!="")
		client.setConnectionSSH(g_sftp_host,g_sftp_port,g_sftp_user,g_sftp_key);
	else
		client.setConnection(g_sftp_host,g_sftp_port,g_sftp_user,g_sftp_password);
	client.connect(); 
	client.listremotedir(remotepath,&remotefiles);
	if (remotefiles.size()==0)
	{
		myprintf("77401! No file found on remote path\n");
		return 1;
	}
	
	std::vector<sftpget3> quick_hash3;
	int64_t remotesize;
	string globalremote=sftp_get_quick_remote(remotepath,remotefiles,quick_hash3,howmanythreads,remotesize);
	
	if (flagverbose)
		for (unsigned int i=0;i<quick_hash3.size();i++)
			myprintf("%08d REMOTE QUICK:%s %21s %s\n",i,quick_hash3[i].o_hash.c_str(),migliaia(quick_hash3[i].o_size),quick_hash3[i].i_name.c_str());
	if (globalremote=="")
		return 2;
	
	flagforcezfs=true;
	g_arraybytescanned.push_back(0);
	g_arrayfilescanned.push_back(0);
	edt.clear();
	scandir(false,edt,files[1].c_str(),false);
	std::vector<sftpfileinfo> localfiles;
	for (DTMap::iterator a=edt.begin(); a!=edt.end(); ++a)
	{
		sftpfileinfo info;
		info.name = a->first;
		info.size = a->second.size;
		info.isdirectory = false;
		localfiles.push_back(info);
	}
	if (localfiles.size()==0)
	{
		myprintf("00433! zero file(s) founded\n");
		return 2;
	}
	
	libzpaq::SHA256 sha256;
	int64_t totallocalsize=0;
	for (unsigned int i=0;i<localfiles.size();i++)
		totallocalsize+=localfiles[i].size;

	if (remotesize>0)
	{
		myprintf("86238: Total remote file size %21s",migliaia(remotesize));
		eol();
		myprintf("\n");
	}

	if (totallocalsize>0)
	{
		myprintf("86235: Total local  file size %21s",migliaia(totallocalsize));
		eol();
		myprintf("\n");
	}
	for (unsigned int i=0;i<localfiles.size();i++)
	{
		int64_t startverify	= 0;
		g_dimensione 		= 0;
		
		franz_do_hash dummyquick("QUICK");
		std::string temp = dummyquick.filehash(0,localfiles[i].name, false, startverify,localfiles[i].size);
		localfiles[i].hash=temp;
		for (const char* p=temp.c_str(); *p; ++p)
			sha256.put(*p);
		if (flagverbose)
			myprintf("%08d LOCAL  QUICK:%s %21s %s\n",i,temp.c_str(),migliaia(localfiles[i].size),localfiles[i].name.c_str());
		
	}

	char sha256result[32];
	memcpy(sha256result, sha256.result(), 32);
	std::string localglobal=binarytohex((const unsigned char*)sha256result,32);
	myprintf("88340: GLOBAL REMOTE SHA256: %s\n",globalremote.c_str());
	myprintf("88375: LOCAL  GLOBAL SHA256: %s\n",localglobal.c_str());
	
	int errors=0;
	if (localfiles.size()!=quick_hash3.size())
	{
		errors++;
		color_red();
		myprintf("88419: Local file count %s != remote file count %s\n",migliaia(localfiles.size()),migliaia2(quick_hash3.size()));
		color_restore();
	}
	if (localglobal!=globalremote)
	{
		errors++;
		color_red();
		myprintf("81420: Local GLOBAL != remote GLOBAL\n");
		color_restore();
	}

	if (!comparaquick(quick_hash3,localfiles))
	{
		errors++;
	}
	
	if (errors>0)
		myprintf("88442: Total errors %d\n",errors);
	return errors;
}


int Jidac::sftp_doverify()
{
	if (files.size()!=3)
	{
		myprintf("07832: You must enter ONE local filename and ONE remote filename\n");
		return 2;
	}
	myprintf("08033: Verify QUICK hash match (TWO filenames, not folders!)\n");
	string localfile	=files[1];
	string remotefile	=files[2];
	if (isdirectory(remotefile))
		remotefile=remotefile+extractfilename(localfile);
	if (flagverbose)
	{
		myprintf("84598: local  file <<%Z>>\n",localfile.c_str());
		myprintf("84593: remote file <<%Z>>\n",remotefile.c_str());
	}
	int64_t thefilesize;
	double	thetime;
	int64_t remotefilesize;
	string	localhash,remotehash;
	if (sftp_verify(localfile,remotefile,localhash,thefilesize,remotehash,remotefilesize,thetime))
	{
		color_green();
		myprintf("08105: VERIFY OK %s %.3f\n",migliaia(thefilesize),thetime);
		color_restore();
		return 0;
	}
	myprintf("08106! VERIFY FAILED\n");
	return 2;
}
int Jidac::sftp_doinfo()
{
#ifdef _WIN32
	zpaqfranzsftp2 sftp2;
	if (g_sftp_key!="")
		sftp2.setConnectionSSH(g_sftp_host,g_sftp_port,g_sftp_user,g_sftp_key);
	else
		sftp2.setConnection(g_sftp_host,g_sftp_port,g_sftp_user,g_sftp_password);
	if (!sftp2.connect()) 
	{
		myprintf("82498: Cannot connect SFTP info\n");
		return 2;
	}

	sftp2.check_ssh_support();
#endif
	return 0;
}

int Jidac::sftp_domd5()
{
	if (files.size()!=2)
	{
		myprintf("37881: You must enter ONE remote file\n");
		return 2;
	}
	string remotefile	=files[1];
	
	zpaqfranzsftp2 sftp2;
	if (g_sftp_key!="")
		sftp2.setConnectionSSH(g_sftp_host,g_sftp_port,g_sftp_user,g_sftp_key);
	else
		sftp2.setConnection(g_sftp_host,g_sftp_port,g_sftp_user,g_sftp_password);
	if (!sftp2.connect()) 
	{
		myprintf("84498: Cannot connect SFTP in md5\n");
		return 2;
	}
	string thecommand="md5sum "+remotefile;
	string theresult;
	if (!sftp2.xremote_command(thecommand,theresult))
	{
		myprintf("34864$ Cannot run %Z\n",thecommand.c_str());
		myprintf("84797! try zpaqfranz sftp info\n");
		return 2;
	}
	color_green();
	myprintf("18490: Run OK\n");
	myprintf(theresult.c_str());
	color_restore();
	return 0;
}

int Jidac::sftp_dodelete()
{
	if (files.size()!=2)
	{
		myprintf("57883: You must enter ONE remote file\n");
		return 2;
	}
	string remotefile	=files[1];
	
	zpaqfranzsftp2 sftp2;
	
	if (g_sftp_key!="")
		sftp2.setConnectionSSH(g_sftp_host,g_sftp_port,g_sftp_user,g_sftp_key);
	else
		sftp2.setConnection(g_sftp_host,g_sftp_port,g_sftp_user,g_sftp_password);
	if (!sftp2.connect()) 
	{
		myprintf("85498: Cannot connect SFTP in delete\n");
		return 2;
	}
	
	if (!sftp2.sftpdeletefile(remotefile))
	{
		myprintf("04864: Cannot delete %Z\n",remotefile.c_str());
		return 2;
	}
	color_green();
	myprintf("08490: Deleted OK\n");
	color_restore();
	return 0;
}

int Jidac::sftp_dosize()
{
	if (files.size()!=2)
		{
			myprintf("07841: You must enter ONE remote file\n");
			return 2;
		}
		string remotefile	=files[1];

		zpaqfranzsftp2 sftp2;
		if (g_sftp_key!="")
			sftp2.setConnectionSSH(g_sftp_host,g_sftp_port,g_sftp_user,g_sftp_key);
		else
			sftp2.setConnection(g_sftp_host,g_sftp_port,g_sftp_user,g_sftp_password);
		if (!sftp2.connect()) 
		{
			myprintf("86498: Cannot connect SFTP in size\n");
			return 2;
		}
		int64_t remotesize=sftp2.remotegetfilesize(remotefile);
		
		if (remotesize==-1)
		{
			myprintf("42865! Cannot get size of %Z\n",remotefile.c_str());
			return 2;
		}
		color_green();
		myprintf("08493: Remote filesize %s of <<%Z>>\n",migliaia(remotesize),remotefile.c_str());
		color_restore();
		return 0;
}
int Jidac::sftp_domkdir()
{
	if (files.size()!=2)
		{
			myprintf("07881: You must enter ONE remote path\n");
			return 2;
		}
		string remotedir	=includetrailingbackslash(extractfilepath(files[1]));
		
		myprintf("86413: INFO: mkdir of <<%s>>\n",remotedir.c_str());
		

		zpaqfranzsftp2 sftp2;
		if (g_sftp_key!="")
			sftp2.setConnectionSSH(g_sftp_host,g_sftp_port,g_sftp_user,g_sftp_key);
		else
			sftp2.setConnection(g_sftp_host,g_sftp_port,g_sftp_user,g_sftp_password);
		if (!sftp2.connect()) 
		{
			myprintf("16498: Cannot connect SFTP in size\n");
			return 2;
		}
		if (sftp2.sftpmkdir(remotedir))
		{
			myprintf("86425: mkdir done %s\n",remotedir.c_str());
			return 0;
		}

		myprintf("86429: cannot mkdir %s\n",remotedir.c_str());
		return 2;
}
		
int Jidac::sftp_dols()
{
	if (files.size()!=2)
		{
			myprintf("57843: You must enter ONE  remote folder\n");
			return 2;
		}
		string remotepath	=files[1];
		std::vector<sftpfileinfo> remotefiles;
		zpaqfranzsftp2 client;
		if (g_sftp_key!="")
			client.setConnectionSSH(g_sftp_host,g_sftp_port,g_sftp_user,g_sftp_key);
		else
			client.setConnection(g_sftp_host,g_sftp_port,g_sftp_user,g_sftp_password);
		client.connect(); 
		client.listremotedir(remotepath,&remotefiles);
		if (remotefiles.size()==0)
		{
			myprintf("58641! No file found on remote path\n");
			return 1;
		}
		int64_t	totalsize=0;
		for (unsigned int i=0;i<remotefiles.size();i++)
		{
			totalsize+=remotefiles[i].size;
			if (!iszpaq(remotefiles[i].name.c_str()))
				color_yellow();
			int64_t dec=decimal_time(remotefiles[i].modtime);
			myprintf("28616: %21s %s <<%Z>>\n",migliaia(remotefiles[i].size),dateToString(flagutc,dec).c_str(),(includetrailingbackslash(remotepath)+remotefiles[i].name).c_str());
			color_restore();
		}
		if (totalsize>0)
			myprintf("38616: Total file size %21s\n",migliaia(totalsize));
		return 0;
}
int Jidac::sftp()
{
	if (files.size()<1)
	{
		myprintf("07017! no parameter, sorry\n");
		return 2;
	}
	
	std::string mycommand=files[0];

	if (mycommand=="mkdir")
		return sftp_domkdir();
	
	if (mycommand=="1on1")
		return sftp_do1on1();

	if (mycommand=="rsync")
		return sftp_dorsync();

	if (mycommand=="ls")
		return sftp_dols();

	if (mycommand=="md5")
		return sftp_domd5();

	if (mycommand=="info")
		return sftp_doinfo();

	if (mycommand=="size")
		return sftp_dosize();
	
	if (mycommand=="delete")
		return sftp_dodelete();

	if (mycommand=="upload")
		return sftp_doupload();

	if (mycommand=="verify")
		return sftp_doverify();

	if (mycommand=="quick")
		return sftp_doquick();

	if (
			(mycommand=="md5sum") ||(mycommand=="sha1sum") ||(mycommand=="sha256sum") ||
			(mycommand=="md5deep") ||(mycommand=="sha1deep") ||(mycommand=="sha256deep") ||
			(mycommand=="md5") ||(mycommand=="sha1") ||(mycommand=="sha256")
		)
		return ssh_dohasha(mycommand);
	
	myprintf("07047! Do not understand the command |%s|\n",mycommand.c_str());
	return 2;
}
int Jidac::ssh()
{
	if (files.size()<1)
	{
		myprintf("07417! no parameter, sorry\n");
		return 2;
	}
	
	std::string mycommand=files[0];

	if (
			(mycommand=="md5sum") ||(mycommand=="sha1sum") ||(mycommand=="sha256sum") ||
			(mycommand=="md5deep") ||(mycommand=="sha1deep") ||(mycommand=="sha256deep") ||
			(mycommand=="md5") ||(mycommand=="sha1") ||(mycommand=="sha256")
		)
		return ssh_dohasha(mycommand);
	
	myprintf("07547! Do not understand the command |%s|\n",mycommand.c_str());
	return 2;
}


#endif // corresponds to #ifdef (#ifdef SFTP)
#endif ///NOSFTPEND

#ifdef _WIN32

#ifndef FILE_ATTRIBUTE_RECALL_ON_DATA_ACCESS
#define FILE_ATTRIBUTE_RECALL_ON_DATA_ACCESS 0x00400000
#endif

bool Jidac::isrealfile(const string& i_filename) 
{
    // Use GetFileAttributesEx to get information about the file
    WIN32_FILE_ATTRIBUTE_DATA fileAttributes;
    if (GetFileAttributesEx((utow(i_filename.c_str()).c_str()),GetFileExInfoStandard, &fileAttributes)) 
	{
        // Check if the file is a "placeholder" (FILE_ATTRIBUTE_RECALL_ON_DATA_ACCESS or FILE_ATTRIBUTE_PINNED are common indicators)
        if (fileAttributes.dwFileAttributes & FILE_ATTRIBUTE_RECALL_ON_DATA_ACCESS) 
            return false; // File not completely downloaded
		else
			return true; // File completely downloaded
    } 
	else 
	{
		if (flagverbose)
			myprintf("10836$ Cannot get attribute for <<%Z>>\n",i_filename.c_str());
		return false; // Assume it is not available in case of error
    }
}
#endif



// Handling keyboard input
	
int get_key() 
{
#ifdef _WIN32
	int ch = _getch();
	if (ch == 0 || ch == 224) {
		ch = _getch();
		switch(ch) {
			case 72: return 'k';  // Up arrow
			case 80: return 'j';  // Down arrow
			case 73: return 'u';  // PagUp
			case 81: return 'd';  // PagDown
			case 71: return 'h';  // Home
			case 79: return 'e';  // End
			case 59: return 128;  // F1
			case 60: return 129;  // F2
			case 61: return 130;  // F3
			case 62: return 131;  // F4
			case 63: return 132;  // F5
			case 64: return 133;  // F6
		}
	}
	return ch;
#else
	struct termios old_settings, new_settings;
	int ch;
	unsigned char buf[4] = {0};
	
	// Save the current terminal settings
	tcgetattr(STDIN_FILENO, &old_settings);
	new_settings = old_settings;
	
	// Disable buffering and echo
	new_settings.c_lflag &= ~(ICANON | ECHO);
	// Important: do not modify the handling of CR/LF
	new_settings.c_iflag &= ~(ICRNL | INLCR);
	new_settings.c_cc[VMIN] = 1;
	new_settings.c_cc[VTIME] = 0;
	
	// Apply the new settings
	tcsetattr(STDIN_FILENO, TCSANOW, &new_settings);
	
	// Read the first character
	if (read(STDIN_FILENO, &buf[0], 1) != 1) {
		tcsetattr(STDIN_FILENO, TCSANOW, &old_settings);
		return -1;
	}
	
	ch = buf[0];
	
	// Debug for the ENTER key
	if (ch == '\r' || ch == '\n' || ch == 0x0D || ch == 0x0A) 
	{
		// Restore the original terminal settings
		tcsetattr(STDIN_FILENO, TCSANOW, &old_settings);
		
	  ///printf("DEBUG: INVIO rilevato (codice: %d, 0x%02X)\n", ch, ch);
	  ///seppuku();
		return 13;  // Hardcoded ASCII code
	}
	
	// Gestione del tasto BACKSPACE (8 = '\b', 127 = DEL)
	if (ch == 8 || ch == 127) 
	{
		tcsetattr(STDIN_FILENO, TCSANOW, &old_settings);
		return 8; //'\b';  // You can use 127 if you prefer
	}
	
	// If it's an escape character, read the sequence
	if (ch == '\x1b') 
	{
		// Read up to 3 additional characters with a minimum timeout
		struct timeval tv = {0, 100};  // 100 microseconds timeout
		fd_set fds;
		FD_ZERO(&fds);
		FD_SET(STDIN_FILENO, &fds);
		
		if (select(STDIN_FILENO + 1, &fds, NULL, NULL, &tv) > 0) {
			if (read(STDIN_FILENO, &buf[1], 1)!=1)
			{
				tcsetattr(STDIN_FILENO, TCSANOW, &old_settings);
				return -1;
			}
			if (buf[1] == '[') {
				if (read(STDIN_FILENO, &buf[2], 1)!=1)
				{
					tcsetattr(STDIN_FILENO, TCSANOW, &old_settings);
					return -1;
				}
				
				switch (buf[2]) {
					case 'A': ch = 'k'; break;  // Up arrow
					case 'B': ch = 'j'; break;  // Down arrow
					case 'H': ch = 'h'; break;  // Home
					case 'F': ch = 'e'; break;  // End
					case '5': 
						if (read(STDIN_FILENO, &buf[3], 1)!=1)  // Read '~'
						{
							tcsetattr(STDIN_FILENO, TCSANOW, &old_settings);
							return -1;
						}
				
						ch = 'u'; break;  // PagSu
					case '6': 
						if (read(STDIN_FILENO, &buf[3], 1)!=1) // Read '~'
						{
							tcsetattr(STDIN_FILENO, TCSANOW, &old_settings);
							return -1;
						}
				
						ch = 'd'; break;  // PagUp
					case '1':
						if (read(STDIN_FILENO, &buf[3], 1)!=1)
									{
										tcsetattr(STDIN_FILENO, TCSANOW, &old_settings);
										return -1;
									}
							
						switch(buf[3]) {
							case '1': if (read(STDIN_FILENO, &buf[3], 1)!=1)
									{
										tcsetattr(STDIN_FILENO, TCSANOW, &old_settings);
										return -1;
									}
									ch = 128; break; // F1
							case '2': 		
									if (read(STDIN_FILENO, &buf[3], 1)!=1)
									{
										tcsetattr(STDIN_FILENO, TCSANOW, &old_settings);
										return -1;
									}
							
										ch = 129; break; // F2
							case '3': if (read(STDIN_FILENO, &buf[3], 1)!=1)
									{
										tcsetattr(STDIN_FILENO, TCSANOW, &old_settings);
										return -1;
									} 
										ch = 130; break; // F3
							case '4': if (read(STDIN_FILENO, &buf[3], 1)!=1)
									{
										tcsetattr(STDIN_FILENO, TCSANOW, &old_settings);
										return -1;
									} 
									ch = 131; break; // F4
							case '5': if (read(STDIN_FILENO, &buf[3], 1)!=1)
									{
										tcsetattr(STDIN_FILENO, TCSANOW, &old_settings);
										return -1;
									}; 
									ch = 132; break; // F5
							case '7': if (read(STDIN_FILENO, &buf[3], 1)!=1)
									{
										tcsetattr(STDIN_FILENO, TCSANOW, &old_settings);
										return -1;
									} 
							ch = 133; break; // F6
						}
						break;
				}
			}
		} 
		else 
		{
			ch = '\x1b';  // It was a real ESC
		}
	}
	
	// Restore the original terminal settings
	tcsetattr(STDIN_FILENO, TCSANOW, &old_settings);
	
	return ch;
#endif
}

string getuserinput(const std::string& i_prompt, const std::string& i_default) 
{
	char buffer[4096] = {0};  // Buffer initialized to 0

// Show the prompt
	printf("%s ", i_prompt.c_str());
	fflush(stdout);  // Ensure that the prompt is printed immediately

// Read the input
	if (fgets(buffer, sizeof(buffer), stdin) == NULL) 
		return i_default;  // If fgets fails,return the default value

// Removes the newline character if present
	size_t len = strlen(buffer);
	if (len > 0 && buffer[len - 1] == '\n') 
		buffer[len - 1] = '\0';

// If the input is empty, use the default value
	return (buffer[0] == '\0') ? i_default : std::string(buffer);
}

void clearscreen() 
{
#ifdef _WIN32
	if (flagdebug5)
	{
		printf("\nSto per pulire\n");
		_getch();
	}
    HANDLE hConsole = GetStdHandle(STD_OUTPUT_HANDLE);
    COORD coordScreen = {0, 0};
    DWORD cCharsWritten;
    CONSOLE_SCREEN_BUFFER_INFO csbi;
    DWORD dwConSize;

    if (!GetConsoleScreenBufferInfo(hConsole, &csbi)) return;
    dwConSize = csbi.dwSize.X * csbi.dwSize.Y;

    FillConsoleOutputCharacter(hConsole, ' ', dwConSize, coordScreen, &cCharsWritten);
    FillConsoleOutputAttribute(hConsole, csbi.wAttributes, dwConSize, coordScreen, &cCharsWritten);
    SetConsoleCursorPosition(hConsole, coordScreen);
#else
	printf("\033[2J\033[H");
#endif
}

#define MYKEY_UP 72
#define MYKEY_DOWN 80
#define MYKEY_PGUP 73
#define MYKEY_PGDN 81
#define MYKEY_HOME 71
#define MYKEY_END 79
#define MYESC 27
#define MYCOLON 58 // ASCII di ':'
#define MYSPACEBAR 32

std::string truncate_with_extension(const std::string& filename, int max_length) 
{
    if ((int)filename.size() <= max_length) // No truncation necessary
	    return filename; 
    size_t dot_pos = filename.find_last_of('.'); // Find the last dot
    if (dot_pos == std::string::npos || dot_pos == 0)         // Nessuna estensione trovata o il file inizia con un punto → Troncamento normale
       return filename.substr(0, max_length - 3) + "...";

    std::string name_part = filename.substr(0, dot_pos); // Part without extension
    std::string extension = filename.substr(dot_pos); // Extension including the dot

    int space_for_name = max_length - extension.size() - 3; // Space available for the name

    if (space_for_name <= 0)     // If the extension is too long to leave space for the name
        return filename.substr(0, max_length - 3) + "...";
    return filename.substr(0, space_for_name) + "..." + extension;
}

bool starts_with(const std::string& str, const std::string& prefix) 
{
	return str.substr(0, prefix.length()) == prefix;
}


// helper function
void add_directory(const std::string& dir_path,vector<string>& i_added_path)
{
   // Make sure the path ends with a slash
	std::string normalized_path = dir_path;
///	if (!normalized_path.empty() && normalized_path.back() != '/') 
	if (!normalized_path.empty() && normalized_path[normalized_path.size() - 1] != '/')
        normalized_path += '/';
	
	///myprintf("Cerco normalized_path %s\n",normalized_path.c_str());
	DTMap::iterator myp=(*pjidac).dt.find(normalized_path);
	if (myp!=(*pjidac).dt.end())
	{
		///myprintf("Esco in quanto duplicato\n");
		return;
	}
	DT& d=(*pjidac).dt[normalized_path];
	d.date			=1;
	d.creationdate	=0;
	d.accessdate	=0;
	d.size			=0;
	d.attr			=0;
	d.data			=0;
	if (flagdebug5)
		myprintf("11400: Added! %s\n",normalized_path.c_str());
	i_added_path.push_back(normalized_path);
}

// Function that generates all intermediate directories from a path
void generate_directories(std::string file_path,vector<string>& i_added_path) 
{
	///myprintf("Genero per |%s|\n",file_path.c_str());
	size_t pos = 0;
	while ((pos = file_path.find('/', pos + 1)) != std::string::npos) 
	{
		std::string dir_path = file_path.substr(0, pos);
		add_directory(dir_path,i_added_path);	
		///myprintf("$$$ %s\n",dir_path.c_str());
	}
	///seppuku();
}
	
/// extracting fullpath of files[]
int	xto(string i_outputpath,string i_currentpath,int64_t i_sizetobeextracted)
{
	if (pjidac==NULL)
	{
		myprintf("14486: GURU in xto pjidac null\n");
		seppuku();
	}
	
	if (i_outputpath=="")
	{
		myprintf("16428! Output path empty\n");
		return -1;
	}
	const vector<string> i_input=(*pjidac).files;
	
	if (i_input.size()==0)
	{
		myprintf("16452! input files empty\n");
		return -1;
	}
	i_outputpath=includetrailingbackslash(i_outputpath);
	///fik
	i_currentpath="";
	
	DTMap saved_dt = (*pjidac).dt;
		
	(*pjidac).jidacreset();
		
#ifdef _WIN32
	if (i_outputpath=="./")
		if (flaglongpath)
		{
			i_outputpath=relativetolongpath(i_outputpath);
			myprintf("=> Windows longpath => %Z\n", i_outputpath.c_str());
		}
#endif
	i_outputpath=includetrailingbackslash(i_outputpath);
	myprintf("16445: Multiple (%s) extraction in folder <<%Z>>\n",migliaia(i_input.size()),i_outputpath.c_str());
		

	flagspace 	= true;
	command 	= 'x';
	g_optional 	= "";
	(*pjidac).dt.clear();
	(*pjidac).tofiles.clear();
	(*pjidac).files.clear();

	// Process each selected file
	for (unsigned int i=0;i<i_input.size();i++)
	{
	///	printf("i_currentpath %s\n",i_currentpath.c_str());
	///	printf("i_input[i]    %s\n",i_input[i].c_str());
		(*pjidac).files.push_back(i_currentpath+i_input[i]);
		
		string temp=i_input[i];
		myreplaceall(temp,":","_");
	
		string dascrivere=i_outputpath+temp;
		
		
	///	printf("Dascrivere %08d %s\n",i,dascrivere.c_str());
		if (!flagforce)
		{
			dascrivere=nomefileseesistegia(dascrivere);
			if (dascrivere!=(i_outputpath+temp))
				myprintf("16027$ Destination already exists and no -force => %Z\n",dascrivere.c_str());
		}
		(*pjidac).tofiles.push_back(dascrivere);
		///if (flagdebug3)
			myprintf("16012: Files %Z => tofiles %Z\n",(i_currentpath+i_input[i]).c_str(),dascrivere.c_str());
	}
	int risultato=(*pjidac).extract();
	
	if (i_sizetobeextracted>0)
	{
		// Overall extraction sum
		int64_t sizeextracted=0;
		for (size_t i=0;i<(*pjidac).tofiles.size();i++)
			sizeextracted+=prendidimensionefile((*pjidac).tofiles[i].c_str());
		if (i_sizetobeextracted==sizeextracted)
		{
			color_green();
			myprintf("16023: File extraction OK\n");
			color_restore();
                 
		}
		else
			myprintf("16028! Something wrong extracted %s vs expected %s\n", migliaia(sizeextracted),migliaia2(i_sizetobeextracted));
	}
		
	(*pjidac).dt = saved_dt;
	(*pjidac).files=i_input;
	
	return risultato;
}



#ifndef ANCIENT

// Function to read a character without enter on Linux
#ifndef _WIN32
int linux_getch() 
{
    struct termios oldt, newt;
    int ch;
    tcgetattr(STDIN_FILENO, &oldt);
    newt = oldt;
    newt.c_lflag &= ~(ICANON | ECHO);
    tcsetattr(STDIN_FILENO, TCSANOW, &newt);
    ch = getchar();
    tcsetattr(STDIN_FILENO, TCSANOW, &oldt);
    return ch;
}
#endif

// Structure to store entries with all their data
// Used for sorting (impossible for dtmap)
struct direntry 
{
	std::string name;
	int64_t size;
	int64_t date;
	bool is_directory;
};

class franzfilesystem 
{
private:
	vector<string> 	added_path;
	vector<string>	tobeprinted;

	bool is_in_current_directory(const std::string& filename, bool recursive = false) 
	{
		if (current_path.empty()) 
		{
        // Root directory: only show top-level directories and files
			size_t first_slash = filename.find('/');
			return first_slash == std::string::npos || 
				(first_slash != std::string::npos && 
					filename.find('/', first_slash + 1) == std::string::npos &&
					first_slash == filename.length() - 1);
		}
    
		// If doesn't start with current path, exclude
		if (!starts_with(filename, current_path + "/")) 
			return false;
        
		std::string remaining = filename.substr(current_path.length() + 1);
    
		// If not recursive, show only direct elements
		if (!recursive) 
		{
			// Ensure there's at most one more slash
			return remaining.find('/') == std::string::npos;
		}
    
		// If recursive, show all files under current directory
		return true;
	}
	
    std::string find_previous_slash(std::string str) 
	{
        size_t last_slash = str.rfind('/');
        if (last_slash == std::string::npos) 
			return "";
        
        return str.substr(0, last_slash);
    }

	bool directory_exists(const std::string& path) 
	{
		// Handles special cases like ".." and "/"
		if (path == ".." || path == "/" || path.empty()) 
			return true;

    // Build the full path
		std::string full_path;
		if (path[0] == '/') 
		{
			// Absolute path
			full_path = path.substr(1);
		} 
		else 
		{
        // Relative path
			full_path = current_path;
			if (!current_path.empty()) 
				full_path += "/";
			full_path += path;
		}

    // Remove the last slash if present
	if (!full_path.empty() && full_path[full_path.size() - 1] == '/')
		full_path.resize(full_path.size() - 1);

		///if (!full_path.empty() && full_path.back() == '/') 
			///full_path.pop_back();

    // Check if there is an entry with this path
	for (DTMap::const_iterator it = (*pjidac).dt.begin(); it != (*pjidac).dt.end(); ++it)
{
    // Check if the path is exactly equal to full_path or if it is a path
    // that starts with full_path and the next character is '/'
    if (it->first == full_path ||
       (it->first.length() > full_path.length() &&
        it->first.substr(0, full_path.length()) == full_path &&
        it->first[full_path.length()] == '/'))
    {
        // If the path ends with '/', it is definitelya directory
        if (!it->first.empty() && it->first[it->first.size() - 1] == '/')
            return true;
    }
}

	/*
		for (const auto& file : (*pjidac).dt) 
		{
			if (file.first == full_path || 
            (file.first.length() > full_path.length() && 
             file.first.substr(0, full_path.length()) == full_path && 
             file.first[full_path.length()] == '/')) 
			 
				if (!file.first.empty() && file.first.back() == '/') 
					
                return true;
        }
		*/
		
		
		return false;
	}


void more_like_display(const std::vector<std::string>& lines, int lines_per_page, int char_for_line) 
{
    int total_lines = lines.size();
    int start = 0;  // Index of the first visible line

    while (true) {
        clearscreen(); // Clears the screen using Windows API

        // Print the visible lines on the screen
        for (int i = 0; i < lines_per_page && (start + i) < total_lines; i++) {
            bool isdir = false;
            if (lines[start + i].size() >= 2) 
                isdir = (lines[start + i][lines[start + i].size() - 2] == '/');
            
            if (isdir) color_yellow();

			std::string truncated_line = truncate_with_extension(lines[start + i], char_for_line);
			
            myprintf("%08d| %Z", start + i, truncated_line.c_str()); // Unique numbering

            if (isdir) color_restore();
        }

        // Show the prompt per i controlli
        color_green();
        printf("\n[↑↓ +/-, PgUp/PgDn pages, Home, End, SPACE=PgDn, : jump, ESC exit]");
        color_restore();

        // Wait for user input
#ifdef _WIN32
        int key = _getch();
#else
        int key = linux_getch();
#endif	
        if (key == MYSPACEBAR) { 
            // SPACE = PAGE DOWN
            start += lines_per_page;
            if (start + lines_per_page > total_lines) 
                start = total_lines - lines_per_page;
            if (start < 0) start = 0;
        } 
        
#ifdef _WIN32	
		else 
		if (key == 224) {  // Special keys
		     key = _getch(); // Acquire the effective code
#endif

            if (key == MYKEY_UP && start > 0) {
                start--; // Scroll back one line
            } 
            else if (key == MYKEY_DOWN && (start + lines_per_page) < total_lines) {
                start++; // Scroll forward one line
            }
            else if (key == MYKEY_PGUP) {
                start -= lines_per_page; // Scroll back one page
                if (start < 0) start = 0;
            }
            else if (key == MYKEY_PGDN) {
                start += lines_per_page; // Scroll forward one page
                if (start + lines_per_page > total_lines) 
                    start = total_lines - lines_per_page;
                if (start < 0) start = 0; // Handles edge cases
            }
            else if (key == MYKEY_HOME) {
                start = 0; // Jump to the beginning
            }
            else if (key == MYKEY_END) {
                start = total_lines - lines_per_page; // Jump to the end
                if (start < 0) start = 0;
            }
#ifdef _WIN32
        } 
#endif
        else if (key == MYCOLON) { // If the user presses ':'
            printf("\nInsert row number: ");
            int new_start;
            if (scanf("%d", &new_start) == 1) {
                if (new_start >= 0 && new_start < total_lines) {
                    start = new_start;
                } else {
                    printf("\nInvalid number, must be 0 to %d\n", total_lines - 1);
#ifdef _WIN32
                    _getch(); // Wait for a key to continue
#else
					linux_getch();
#endif
                }
            }
        }
        else if (key == MYESC || key == 'q' || key == 'Q') {  
            printf("\n");
            break; // Exits the loop
        }
    }
}

public:

    std::string 	current_path;

	std::string tab_complete(const std::string& partial_path) 
	{
    // Determine base_dir and search_term, handling potential spaces
		std::string base_dir, search_term;
		size_t last_slash = partial_path.rfind('/');
    
		if (last_slash != std::string::npos) 
		{
			base_dir = partial_path.substr(0, last_slash);
			search_term = partial_path.substr(last_slash + 1);
		} 
		else 
		{
			base_dir = current_path;
			search_term = partial_path;
		}
    
		// Construct the full search path
		std::string search_path = current_path;
		if (!search_path.empty()) 
			search_path += "/";
		search_path += search_term;
    
		std::vector<std::string> matches;
		const std::string current_path_prefix = current_path.empty() ? "" : current_path + "/";
    
    // Collect potential matches


		for (DTMap::const_iterator it = (*pjidac).dt.begin(); it != (*pjidac).dt.end(); ++it)
		{
			std::string entry_path = it->first;
			
			// Skip non-directory entries
			if (entry_path.empty() || entry_path.back() != '/') 
				continue;
			
			// Remove trailing slash for comparison
			std::string dir_name = entry_path;
			if (!dir_name.empty() && dir_name.back() == '/')
				dir_name.pop_back();
			
			// Strip current path prefix if present
			if (!current_path.empty() && entry_path.find(current_path_prefix) == 0) 
				entry_path = entry_path.substr(current_path_prefix.length());
			
			// Case-insensitive matching with space-aware comparison
			bool is_match = false;
#ifdef _WIN32
			std::string lower_entry = stringtolower(entry_path);
			std::string lower_search = stringtolower(search_term);
			is_match = lower_entry.find(lower_search) == 0;
#else
			is_match = entry_path.find(search_term) == 0;
#endif
			
			// Prevent duplicates
			// Stop after first match to maintain existing behavior
			if (is_match) 
				if (std::find(matches.begin(), matches.end(), entry_path) == matches.end()) 
				{
					matches.push_back(entry_path);
					if (matches.size() > 1) 
						break;
				}
		}
    
		// Handle matching results
		if (matches.empty()) 
			return partial_path;
   
    
		// If single match, return full path
		if (matches.size()==1) 
		{
			std::string full_match = (current_path.empty() ? "" : current_path + "/") + matches[0];
			return full_match;
		}
    
    // Multiple matches - print options and return common prefix
		if (flagdebug5)
		{
			myprintf("\nPossible completions:\n");
			for (std::vector<std::string>::const_iterator it = matches.begin(); it != matches.end(); ++it)
				myprintf("%s\n", it->c_str());
		}
    
		// Find common prefix
		std::string common = matches[0];
		for (size_t i = 1; i < matches.size(); i++) 
		{
			size_t j = 0;
			while (j < common.length() && j < matches[i].length() && 
				   common[j] == matches[i][j]) 				
				   j++;
			common = common.substr(0, j);
		}
		
		return (current_path.empty() ? "" : current_path + "/") + common;
	}

// Function to find the file that matches the pattern
	std::string complete_file(const std::string& partial_path) 
	{
		// Determine base_dir and search_term
		std::string base_dir, search_term;
		size_t last_slash = partial_path.rfind('/');
		
		if (last_slash != std::string::npos) 
		{
			base_dir = partial_path.substr(0, last_slash);
			search_term = partial_path.substr(last_slash + 1);
		} 
		else 
		{
			base_dir = current_path;
			search_term = partial_path;
		}
		
		// Construct the full search path
		std::string search_path = current_path;
		if (!search_path.empty()) 
			search_path += "/";
		search_path += search_term;
		
		std::vector<std::string> matches;
		const std::string current_path_prefix = current_path.empty() ? "" : current_path + "/";
		
		// Collect potential matches - including both files and directories
		for (DTMap::const_iterator file = (*pjidac).dt.begin(); file != (*pjidac).dt.end(); ++file)

		{
			std::string entry_path = file->first;
			
			// Skip if not in current directory
			if (!starts_with(entry_path, current_path_prefix)) 
				continue;
			
			// Remove current path prefix
			if (!current_path.empty()) 
				entry_path = entry_path.substr(current_path_prefix.length());
			
			// Handle paths with spaces
			if (entry_path.find(' ') != std::string::npos)
				entry_path = "\"" + entry_path + "\"";

	
			// Case-insensitive matching
			bool is_match = false;
#ifdef _WIN32
			std::string lower_entry = stringtolower(entry_path);
			std::string lower_search = stringtolower(search_term);
			is_match = lower_entry.find(lower_search) == 0;
#else
			is_match = entry_path.find(search_term) == 0;
#endif
			
			if (is_match) 
				if (std::find(matches.begin(), matches.end(), entry_path) == matches.end()) 
					matches.push_back(entry_path);
		}
		
		// Handle matching results
		if (matches.empty()) 
			return partial_path;
		
		// the first one
		if (matches.size()==1)
			return matches[0];
		
		// Multiple matches - print options and return common prefix
		if (flagdebug5) 
		{
			myprintf("\nPossible completions (2):\n");
			for (std::vector<std::string>::const_iterator it = matches.begin(); it != matches.end(); ++it)
				myprintf("%s\n", it->c_str());

		}
		
		// Find common prefix
		std::string common = matches[0];
		for (size_t i=1;i<matches.size();i++) 
		{
			size_t j = 0;
			while (j < common.length() && j < matches[i].length() && 
				   common[j] == matches[i][j]) 
				j++;
			common = common.substr(0, j);
		}
		
		return common;
	}
	// Updated handle_input method to support file completion for 'get' command
	std::string handle_input(const std::string& partial_input) 
	{
		if (flagdebug5) 
		{
			myprintf("DEBUG: handle_input ENTRY - partial_input='%s'\n", partial_input.c_str());
			myprintf("DEBUG: Current path='%s'\n", current_path.c_str());
		}
		
		if (partial_input.empty()) 
			return partial_input;
		
		// Split input into command and argument
		std::string command, argument;
		size_t space_pos = partial_input.find(' ');
		
		if (space_pos != std::string::npos) 
		{
			command = partial_input.substr(0, space_pos);
			argument = partial_input.substr(space_pos + 1);
			
			// Trim leading and trailing spaces from argument
			while (!argument.empty() && argument[0] == ' ') 
				argument = argument.substr(1);
			while (!argument.empty() && argument.back() == ' ') 
				argument.pop_back();
			
			if (flagdebug5) 
				myprintf("DEBUG: Parsed command='%s', argument='%s'\n", command.c_str(), argument.c_str());
			
			// For directory navigation commands, use directory completion
			if (command == "cd" || command == "ls" || command == "dir" || command == "more" || command == "less") 
			{
				if (flagdebug5) 
					myprintf("DEBUG: Attempting directory completion on argument\n");
				std::string completed_arg = tab_complete(argument);
				
				if (flagdebug5) 
					myprintf("DEBUG: Tab completion result='%s'\n", completed_arg.c_str());
				
				std::string full_input = command + " " + completed_arg;
				if (flagdebug5) 
					myprintf("DEBUG: Returning full input='%s'\n", full_input.c_str());
				return full_input;
			}
			// For get command, use file completion
			else 
			if (command == "get") 
			{
				if (flagdebug5) 
					myprintf("DEBUG: Attempting file completion on argument\n");
				std::string completed_arg = complete_file(argument);
				
				if (flagdebug5) 
					myprintf("DEBUG: File completion result='%s'\n", completed_arg.c_str());
				
				std::string full_input = command + " " + completed_arg;
				if (flagdebug5) 
					myprintf("DEBUG: Returning full input='%s'\n", full_input.c_str());
				return full_input;
			}
		}
		
		return partial_input;
	}

    void help() 
	{
		myprintf("  help or ?            - Show this list of commands\n");
		myprintf("  dir or ls            - List files in the current directory\n");
		myprintf("  ls/dir (..)|more     - More-like output\n");
		myprintf("                         /od sorts by date\n");
		myprintf("                         /os sorts by size\n");
		myprintf("  more or less PATH    - Browse PATH with keyboard");
		
		myprintf("  cd PATH              - Change the current directory\n");
		myprintf("  cd PATH*             - Wildcard (if possible)\n");
		myprintf("  cd PATH<TAB>         - Autocomplete\n");
		myprintf("                         - 'cd ..' goes up one directory level\n");
		myprintf("                         - 'cd /' returns to the root\n");
		myprintf("  get pippo.txt        - Extract pippo.txt in current folder\n");
		myprintf("  get pippo*           - Extract every pippo FILE in current folder\n");
		myprintf("  exit or bye or quit  - Exit zpaqfranz\n");
    }

    franzfilesystem() 
	{
		if (pjidac==NULL)
		{
			myprintf("14792! GURU pjidac null\n");
			seppuku();
		}

		int 	larghezzaconsole=terminalwidth()-4;
		int		ognipunto=0;
		if (larghezzaconsole>0)
			ognipunto=(*pjidac).dt.size()/larghezzaconsole;
		if (ognipunto==0)
			ognipunto++;
	
		int		contatore	=0;
///fik
///		bool	wehaveslash	=false;
		for (DTMap::iterator a=(*pjidac).dt.begin(); a!=(*pjidac).dt.end(); ++a)
		{
			contatore++;
			if ((contatore%ognipunto)==0)
			{
				myprintf("+");
				fflush(stdout);
			}
			/*
			if (!a->first.empty())
				if (a->first[0]=='/')
					wehaveslash=true;
			*/
		    generate_directories(a->first,added_path);
			
			generate_first_level(a->first,added_path);
			
        }
		myprintf("\n");
		dirprimolivello();

    }

    const std::string& get_current_path() const 
	{
        static const std::string root = "/";
        return current_path.empty() ? root : current_path;
    }

	bool more(const char* i_stringa)
	{
		if (!i_stringa) 
			return true;
		int larghezzaconsole		=terminalwidth()-2;
		int altezzaconsole			=terminalheight();
		static int righestampate	=0;
		if ((larghezzaconsole<0) || (altezzaconsole<0))
		{
			myprintf("%s",i_stringa);
			return true;
		}
		myprintf("%s",i_stringa);
		righestampate++;
		if (righestampate>(altezzaconsole-2))
		{
			myprintf("-- More (q, Q to quit) --\r");
			int premuto=mygetch(false);
			righestampate=0;
			if (premuto==3)
			{
				color_restore();
				myprintf("\n");
				myprintf("Goodbye (Control-C detected)\n");
				seppuku();
			}
			if ((premuto==113) || (premuto==81))
			{
				myprintf("\n\n*** STOP DUE to keypress %c  ***\n",premuto);
				return false;
			}
			for (int i=0;i<altezzaconsole;i++)
				myprintf("\n");
		}
		return true;
	}
bool contains(const std::vector<std::string>& list, const std::string& value) 
{
    for (std::vector<std::string>::const_iterator it = list.begin(); it != list.end(); ++it) 
    {
        if (*it == value) 
            return true;
    }
    return false;
}
/*
bool contains(const std::vector<std::string>& list, const std::string& value) 
{
    for (const std::string& item : list) 
    {
        if (item == value) 
            return true;
    }
    return false;
}
*/
string take_first_level_folder(const std::string& path) 
{
    if (path.empty()) return ""; // Skip empty strings

    size_t start = 0;
    std::string first_level;

    // UNC (Windows) es. "//server/share/..."
    if (path.substr(0, 2) == "//") 
    {
        size_t second_slash = path.find('/', 2);
        if (second_slash != std::string::npos) 
        {
            size_t third_slash = path.find('/', second_slash + 1);
            first_level = (third_slash != std::string::npos) ? path.substr(0, third_slash + 1) : path + "/"; 
        }
        else 
        {
            first_level = path + "/";  // Incomplete UNC path? We consider everything
        }
    }
    //  "C:/cartella/file.txt"
    else if (path.length() > 2 && path[1] == ':' && (path[2] == '/' || path[2] == '\\')) 
    {
        size_t first_slash = path.find_first_of("/\\", 3);
        first_level = (first_slash != std::string::npos) ? path.substr(0, first_slash + 1) : path + "/";
    }
    // Linux/macOS es. "/etc/..."
    else if (path[0] == '/') 
    {
        start = 1;
        size_t first_slash = path.find('/', start);
        first_level = (first_slash != std::string::npos) ? path.substr(0, first_slash) : path;
    }
    // "rombone/prova.txt" o "./dormire/ciao"
    else 
    {
        size_t first_slash = path.find('/');
        first_level = (first_slash != std::string::npos) ? path.substr(0, first_slash) : path;
    }

    // Add the folder only if it is not already present
    if (!first_level.empty()) 
		return first_level;
	
	return "";
}
bool isfirstlevel(string i_file)
{
	string string1=extractfilepath(i_file);
	string string2=includetrailingbackslash(take_first_level_folder(i_file));
	///printf("String1 %s  string2 %s\n",string1.c_str(),string2.c_str());
	return string1==string2;
}
void generate_first_level(std::string file_path,vector<string>& i_added_path) 
{
	string thefirst=take_first_level_folder(file_path)+"/";
	///printf("Il first %s %s\n",file_path.c_str(),thefirst.c_str());
    if (!thefirst.empty() && pjidac != nullptr) 
    {
        if ((*pjidac).dt.find(thefirst) == (*pjidac).dt.end()) 
        {
            ///myprintf("Vado ad aggiungere %s\n", thefirst.c_str());

            DT& d = (*pjidac).dt[thefirst];
            d.date = 1;
            d.creationdate = 0;
            d.accessdate = 0;
            d.size = 0;
            d.attr = 0;
            d.data = 0;
            
            myprintf("14400: Added thefirst %s\n", thefirst.c_str());

            if (!contains(i_added_path, thefirst)) 
                i_added_path.push_back(thefirst);
        }
    }
}


void dir(const char* path, bool recursive, bool i_more) 
{
	///myprintf("97548: path |%s| current %s\n",path,current_path.c_str());
    std::string temp_path = current_path;
    std::string sort_option;
    
    // If NULL is passed, show the contents of the current folder
    std::string path_str = (path) ? path : "";
	myprintf("path_str %s  current_path %s\n",path_str.c_str(),current_path.c_str());
	///fik
///	getch();
	
	if (((current_path=="") && (path_str=="")) || (path_str=="/"))
	{
		dirprimolivello();
		return;
	}

    // Check if the user has specified "/s" as an argument
    if (path_str == "/s") 
    {
        recursive = true;  // Enable recursion
        path_str = "";      // Do not treat it as a directory
        path = nullptr;
    }
	///printf("Path ora |%s|\n",path);
    // temp change
	if (!path_str.empty() && path_str[0] != '-')
    {
	///	myprintf("$$$$$$$$$$$$$ to |%s|\n",path_str.c_str());
	///	if (path_str[0] == '/') 
		///path_str.erase(0, 1); // Rimuove il primo carattere
	///		myprintf("$$$$$$$$$$$$$ to |%s|\n",path_str.c_str());
		if ((path_str=="/os") || (path_str=="/on"))
		{
			path_str="";
		}
        if (!cd(path_str.c_str())) 
        {
            myprintf("11313$ Z Directory not found: %s\n", path_str.c_str());
            current_path = temp_path;
            return;
        }
    }

    myprintf("Content of %s%s:\n", path ? path : get_current_path().c_str(), recursive ? " (recursive)" : "");

    std::vector<direntry> entries;
	
    // Collects the files and folders of the current directory
	
	for (DTMap::const_iterator file = (*pjidac).dt.begin(); file != (*pjidac).dt.end(); ++file)
    {
        if (file->second.date != 0) 
        {
            bool already_exists = false;
			if (isdirectory(file->first))
				if (isfirstlevel(file->first))
				{
					direntry entry;
					entry.name = file->first;
					entry.size = file->second.size;
					entry.date = file->second.date;
					entry.is_directory = true;
					entries.push_back(entry);
					myprintf("Primo livello %s\n",file->first.c_str());
					continue;
				}
				
            std::string relative_path = file->first;
			string prefisso=current_path;
				
			/// /etc/pippo.txt 
			///if (!isdirectory(file.first))
				///continue;

			if (!starts_with(file->first,prefisso)) 
				continue;
			
			string temp=file->first;
			myreplace(temp,prefisso,"");
			///myprintf("Temp vale %s\n",temp.c_str());
			string thefirst=take_first_level_folder(temp);
			///myprintf("First level %s prefisso %s\n",thefirst.c_str(),prefisso.c_str());
			
			relative_path=temp;
			if (relative_path[0]=='/')
				relative_path.erase(0,1);
            
            // Convert range-based for loop to iterator-based for loop
            for (std::vector<direntry>::const_iterator it = entries.begin(); it != entries.end(); ++it)
            {
                const direntry& entry = *it;
                if (entry.name == relative_path) 
                {
                    already_exists = true;
				///	myprintf("Esiste gia entry.name %s == relative %s\n",entry.name.c_str(),relative_path.c_str());
                    break;
                }
            }

            if (!already_exists && !relative_path.empty()) 
            {
                direntry entry;
                entry.name = relative_path;
                entry.size = file->second.size;
                entry.date = file->second.date;
                entry.is_directory = !relative_path.empty() && relative_path.back() == '/';
                entries.push_back(entry);
				///printf("Entries count 2 %d\n",entries.size());
            }
        }
		///else
			///printf("Deleted %s\n",file.first.c_str());
    }

    // Print the contents of the current directory
    for (std::vector<direntry>::const_iterator it = entries.begin(); it != entries.end(); ++it)
    {
        const direntry& entry = *it;
        char buffer[4096];
        snprintf(buffer, sizeof(buffer), "%s %21s %s%s", 
            dateToString(flagutc, entry.date).c_str(),
            entry.is_directory ? "<DIR>" : migliaia(entry.size),
            entry.name.c_str(),
            "\n");
		if (i_more)
		{
			if (!more(buffer))
				break;
		}
		else
			myprintf(buffer);
    }

    // If recursive mode is activated, explore subdirectories
    if (recursive) 
    {
        for (std::vector<direntry>::const_iterator it = entries.begin(); it != entries.end(); ++it)
        {
            const direntry& entry = *it;
            if (entry.is_directory) 
            {
				std::string subdir_path;
				if (current_path=="")
				subdir_path = entry.name;
                	else
                subdir_path = current_path + "/" + entry.name;
				if (flagdebug5)
					myprintf("\n--- Entering directory: %s more %d---\n", subdir_path.c_str(),int(i_more));
                dir(subdir_path.c_str(), true, i_more);
            }
        }
    }

    // Restore the original path if it was changed
    if (!path_str.empty() && path_str[0] != '-') 
        current_path = temp_path;
}

void dirprimolivello()
{
    std::vector<direntry> entries;
	
	for (DTMap::const_iterator file = (*pjidac).dt.begin(); file != (*pjidac).dt.end(); ++file)
        if (file->second.date != 0) 
			if (isdirectory(file->first))
				if (isfirstlevel(file->first))
				{
					direntry entry;
					entry.name = file->first;
					entry.size = file->second.size;
					entry.date = file->second.date;
					entry.is_directory = true;
					entries.push_back(entry);
				}
    // Print the contents of the current directory
    for (std::vector<direntry>::const_iterator it = entries.begin(); it != entries.end(); ++it)
    {
        const direntry& entry = *it;
        char buffer[4096];
        snprintf(buffer, sizeof(buffer), "%s %21s %s%s", 
            dateToString(flagutc, entry.date).c_str(),
            entry.is_directory ? "<DIR>" : migliaia(entry.size),
            entry.name.c_str(),
            "\n");
		myprintf(buffer);
    }
}

	bool handle_wildcard_cd(const std::string& path_str) 
	{
		if (flagdebug5)
			myprintf("DEBUG WILDCARD: Original path_str='%s'\n", path_str.c_str());

		// Special handling for drive letter paths
		std::string search_pattern = path_str;
		if (search_pattern.length() == 2 && search_pattern[1] == ':') 
			search_pattern += "*";
		
		// Find prefix for matching
		size_t star_pos = search_pattern.find('*');
		std::string prefix = (star_pos != std::string::npos) 
			? search_pattern.substr(0, star_pos)
			: search_pattern;
		if (flagdebug5)
			myprintf("DEBUG WILDCARD: Adjusted prefix='%s'\n", prefix.c_str());

		std::vector<std::string> matches;


		for (DTMap::const_iterator file = (*pjidac).dt.begin(); file != (*pjidac).dt.end(); ++file)
		{
			if (file->first.empty() || file->first.back() != '/') 
				continue;
			
			std::string dir_name = file->first;
			// Remove trailing slash for comparison
			if (!dir_name.empty() && dir_name.back() == '/') 
				dir_name.pop_back();
			
#ifdef _WIN32
			bool match = stringtolower(dir_name).find(stringtolower(prefix)) == 0;
#else
			bool match = dir_name.find(prefix) == 0;
#endif
			if (match) 
			{
				matches.push_back(file->first);
				if (flagdebug5)
					myprintf("DEBUG WILDCARD: Match found='%s'\n", file->first.c_str());
			}
		}

		if (matches.size() == 1) 
		{
			current_path = matches[0];
			if (!current_path.empty() && current_path.back() == '/') 
				current_path.pop_back();
			if (flagdebug5)
				myprintf("DEBUG WILDCARD: Single match, changing to '%s'\n", current_path.c_str());
			return true;
		}
		if (flagdebug5)
			myprintf("DEBUG WILDCARD: No unique match found\n");
		return false;
	}


	bool cd(const char* path) 
	{
		if (flagdebug5)
		{
			myprintf("DEBUG CD: Entering cd() with full path='%s' current_path %s\n", path,current_path.c_str());
		}
		std::string path_str = path;
		if (flagdebug5)
			myprintf("DEBUG CD: Initial path_str='%s', length=%d\n", path_str.c_str(), path_str.length());

		// Replace backslashes with forward slashes
		std::replace(path_str.begin(), path_str.end(), '\\', '/');
		if (flagdebug5)
			myprintf("DEBUG CD: Normalized path='%s'\n", path_str.c_str());

		// Special root and parent directory handling
		if (path_str == "/" || path_str == "..") 
		{
			if (path_str == "/") 
			{
				if (flagdebug5)
					myprintf("DEBUG CD: Changing to root directory\n");
				current_path.clear();
				return true;
			}
			
			if (flagdebug5)
				myprintf("DEBUG CD: Moving up from current path='%s'\n", current_path.c_str());
			current_path = find_previous_slash(current_path);
			return true;
		}

		// Normalize the path for absolute paths
		std::string search_path = path_str;
		if (path_str[0] == '/') 
		{
			///search_path = path_str.substr(1);  // Remove leading slash for comparison
		} 
		else 
		{
			
			///printf("_____ path_str %s current_path %s\n",path_str.c_str(),current_path.c_str());
			// For relative paths, combine with current path
			///if (!current_path.empty()) 
				///search_path = current_path + "/" + path_str;
		}

		// Remove trailing slash if present
		if (!search_path.empty() && search_path.back() == '/')
			search_path.pop_back();

		if (flagdebug5)
			myprintf("DEBUG CD: (2) Search path='%s'\n", search_path.c_str());

		// Look for exact matches first
		for (DTMap::const_iterator file = (*pjidac).dt.begin(); file != (*pjidac).dt.end(); ++file)
		{
			std::string dir_name = file->first;
			if (dir_name.empty() || dir_name.back() != '/') 
				continue;
			
			// Remove trailing slash for comparison
			if (dir_name.back() == '/') 
				dir_name.pop_back();
			
#ifdef _WIN32
			if (stringtolower(dir_name) == stringtolower(search_path)) {
#else
			if (dir_name == search_path) {
#endif
				current_path = search_path;
				if (flagdebug5)
					myprintf("DEBUG CD: Exact match found, changing to '%s'\n", current_path.c_str());
				return true;
			}
		}

		// If no exact match, try wildcard matching
		if (path_str.find('*') != std::string::npos) 
			return handle_wildcard_cd(path_str);
		
		// Look for partial matches (helpful for directories without full paths)
		std::string partial_search = search_path;
		if (partial_search.find('/') == std::string::npos) 
		{
			
			for (DTMap::const_iterator file = (*pjidac).dt.begin(); file != (*pjidac).dt.end(); ++file)
			{
				std::string dir_name = file->first;
				if (dir_name.empty() || dir_name.back() != '/') 
					continue;

				size_t last_slash = dir_name.rfind('/', dir_name.length() - 2);
				std::string last_component = dir_name.substr(
					last_slash == std::string::npos ? 0 : last_slash + 1,
					dir_name.length() - (last_slash == std::string::npos ? 1 : last_slash + 2)
				);
#ifdef _WIN32
				if (stringtolower(last_component) == stringtolower(partial_search)) {
#else
				if (last_component == partial_search) {
#endif
					current_path = dir_name;
					if (!current_path.empty() && current_path.back() == '/') 
						current_path.pop_back();
					if (flagdebug5)
						myprintf("DEBUG CD: Partial match found, changing to '%s'\n", current_path.c_str());
					return true;
				}
			}
		}

		if (flagdebug5)
			myprintf("DEBUG CD: No matching directory found\n");
		return false;
	}


	int getpipednumber(const std::string& str) 
	{
		if (str.empty() || str.back() != '|') 
			return -1;
    
		string numerini;
		for (size_t i = 0; i < str.size() - 1; ++i) 
		{
			if (!isdigit(str[i])) 
				return -1;
			numerini+=str[i];
		}
    
		return myatoll(numerini.c_str());
	}


	void x(const char* filename) 
	{
		string relative=getuserinput("Where to extract? (default: current): ","./");
		relative=wintolinuxpath(relative);
		
		if (relative=="")
			return;

#ifdef _WIN32
		if (relative=="./")
			if (flaglongpath)
			{
				relative = relativetolongpath(relative);
				myprintf("=> Windows longpath => %Z\n", relative.c_str());
			}
#endif
		relative=includetrailingbackslash(relative);
		myprintf("1554: Multiple extraction in folder <<%Z>>\n",relative.c_str());


		(*pjidac).files.clear();
				
		std::string 	pattern 			= filename;
		bool 			found_any 			= false;
		int64_t			sizetobeextracted	=0;
		///int				selectedfolders		=0;
		
		int	piped=-1;
		if (tobeprinted.size()>0)
			 piped=getpipednumber(filename);
		 
		if (piped>-1)
		{
			string filetobegetted;
			
			if (piped<int(tobeprinted.size()))
				filetobegetted=tobeprinted[piped];
			///|2008-12-04 19:12:14                45.056 2° 183 Fuzzi Moroncelli.doc
///|
///1234567890123456789012345678901234567890123
///2008-12-04 19:12:14                45.056 2° 183 Fuzzi Moroncelli.doc
			if (filetobegetted.size()>=43)
			{
				string lunghezza=filetobegetted.substr(19,22);
				myreplace(lunghezza,".","");
				myreplaceall(lunghezza," ","");
				myprintf("lunghezza |%s|\n",lunghezza.c_str());
				string nomefile=includetrailingbackslash(get_current_path())+filetobegetted.substr(42,filetobegetted.size()-42-1);
				myprintf("file |%s|\n",nomefile.c_str());
				sizetobeextracted+=myatoll(lunghezza.c_str());
				(*pjidac).files.push_back(nomefile);
				found_any=true;
			}		
		}
		else
		{
			bool has_wildcard = (pattern.find('*') != std::string::npos);
			
			// Build the full path per la ricerca
			std::string base_path;
			if (pattern[0] == '/') 
			{
				// Absolute path
				base_path = pattern.substr(1);
			} 
			else 
			{
				// Relative path
				base_path = current_path;
				if (!current_path.empty()) base_path += "/";
				base_path += pattern;
			}
			
			// Divide the pattern into a prefix and suffix part around the asterisk
			std::string prefix, suffix;
			if (has_wildcard) 
			{
				size_t star_pos = base_path.find('*');
				prefix = base_path.substr(0, star_pos);
				suffix = base_path.substr(star_pos + 1);
			}
		// Search for matching files
		
			for (DTMap::const_iterator myfile = (*pjidac).dt.begin(); myfile != (*pjidac).dt.end(); ++myfile)

			{ 
				bool match = false;
				
				if (has_wildcard) 
				{
					std::string filename_to_check = myfile->first;
					
#ifdef _WIN32
					filename_to_check = stringtolower(filename_to_check);
					std::string lower_prefix = stringtolower(prefix);
					std::string lower_suffix = stringtolower(suffix);
					
					match = filename_to_check.find(lower_prefix) == 0 &&
						   (lower_suffix.empty() || 
							(filename_to_check.length() >= lower_suffix.length() &&
							 filename_to_check.substr(filename_to_check.length() - lower_suffix.length()) == lower_suffix));
#else
					match = filename_to_check.find(prefix) == 0 &&
						   (suffix.empty() || 
							(filename_to_check.length() >= suffix.length() &&
							 filename_to_check.substr(filename_to_check.length() - suffix.length()) == suffix));
#endif
				} 
				else 
				{
#ifdef _WIN32
					match = (stringtolower(myfile->first) == stringtolower(base_path));
#else
					match = (myfile->first == base_path);
#endif
				}

				if (match) // && !isdirectory(myfile.first)) 
				{
					found_any = true;
					
					if (flagverbose)
						myprintf("14544: X of <<%Z>>:\n%d\n", myfile->first.c_str(), myfile->second.size);
					
					if (!isdirectory(myfile->first))
						sizetobeextracted+=myfile->second.size;
					//else
					//	selectedfolders++;
					(*pjidac).files.push_back(myfile->first);
				}
			}
		}
		// If we have found files, proceed with the extraction
		if (found_any)
			xto(relative,current_path,sizetobeextracted);
		else
			myprintf("14579! No files found matching '%s'\n", filename);
	}
};



	std::string get_line_with_tab_completion(franzfilesystem& fs) 
	{
		std::string current_input;
		int c;
		const char TAB = '\t';
		const char BACKSPACE = 8;
		const char ENTER = 13;

		while (true) 
		{
#ifdef _WIN32
			c = _getch();
#else
			c = linux_getch();
#endif

			if (c == 3) 
			{
				color_restore();
				myprintf("\n");
				myprintf("Goodbye (Control-C detected)\n");
				seppuku();
			}

			if ((c==ENTER) || (c== '\n')) 
			{
				myprintf("\n");
				break;
			}

			if ((c==BACKSPACE) || (c==127)) // Linux usa 127 per backspace
			{ 
				if (!current_input.empty()) 
				{
					current_input.pop_back();
					myprintf("\b \b");
				}
				continue;
			}

			if (c==TAB) 
			{
				std::string completed = fs.handle_input(current_input);
				if (completed!=current_input) 
				{
					for (size_t i=0;i<current_input.length(); i++) 
						myprintf("\b \b");
					myprintf("%s", completed.c_str());
					current_input = completed;
				}
				continue;
			}

			if ((c<32) && (c!=TAB) && (c!=ENTER) && (c!=BACKSPACE))
				continue;

			current_input+=(char)c;
			myprintf("%c", c);
		}
		return current_input;
	}


	void parse_command(const std::string& input, std::string& command, std::string& arg1, std::string& arg2) 
	{
		command.clear();
		arg1.clear();
		arg2.clear();
		
		size_t pos = 0;
		size_t len = input.length();
		
		// Skip leading spaces
		while ((pos<len) && (isspace(input[pos]))) 
			pos++;
		
		// Get command
		while ((pos<len) && (!isspace(input[pos]))) 
		{
			command += input[pos];
			pos++;
		}
		
		// Skip spaces between command and arg1
		while ((pos<len) && (isspace(input[pos])))
			pos++;
		
		// Get arg1
		while ((pos<len) && (!isspace(input[pos]))) 
		{
			arg1+=input[pos];
			pos++;
		}
		
		// Skip spaces between arg1 and arg2
		while ((pos<len) && (isspace(input[pos]))) 
			pos++;
		
		// Get the rest as arg2 (including spaces)
		while (pos<len) 
		{
			arg2+=input[pos];
			pos++;
		}
		
		// Trim trailing spaces from arg2
		while ((!arg2.empty()) && (isspace(arg2.back()))) 
			arg2.pop_back();
	}

/// This is quite hard to debug

int Jidac::ls()
{
   if (archive=="")
    {
        myprintf("14236! archive is empty\n");
        return 2;
    }

    archive=getbackupnameifany(archive);
    int     errors    	=0;
    command            	='l';
    g_optional        	="versum"; //force isselected
    
	int64_t csize=read_archive(NULL,archive.c_str(),&errors); 
	myprintf("\n");
    
    if (csize==0)
    {
        myprintf("14946! Cannot open archive <<%Z>>\n",archive.c_str());
        return 2;
    }
    
	franzfilesystem fs;
	myprintf("'help' to ... get help. Ready on %s lines\n\n",migliaia((*pjidac).dt.size()));
	
	while (true) 
	{
        color_green();
        myprintf("[? bye exit]");
        color_restore();
        myprintf(" %s> ", fs.get_current_path().c_str());
        fflush(stdout);
        
        std::string input = get_line_with_tab_completion(fs);
        
        if (input.empty()) 
		    continue;
        
        std::string command, arg1, arg2;
        parse_command(input, command, arg1, arg2);
        
        if ((command == "exit") || (command == "bye") || (command == "quit")) 
	        break;
        else 
		if ((command == "help") || (command == "?")) 
	        fs.help();
        else 
		if ((command == "ls") || (command == "dir"))
		{
			bool recursive 		= false;
            const char* path 	= NULL;
            			
            if (!arg1.empty()) 
			{
                if (arg1 == "-r" || arg1 == "/r") 
				{
                    recursive = true;
                    if (!arg2.empty()) 
                        path = arg2.c_str();
                }
                else 
                    path = arg1.c_str();
            }
            
			std::string temp = (path != nullptr) ? path : "";  // Avoid the error

			bool needmore=false;
			size_t pos=temp.find("|more");
			if (pos!=std::string::npos) 
			{
				needmore=true;
				temp.erase(pos,5);
				while ((pos>0) && (temp[pos-1]==' ')) 
				{
					temp.erase(pos-1,1);
					--pos;
				}

				while ((pos<temp.length()) && (temp[pos]==' '))
					temp.erase(pos,1);
			}
            fs.dir(temp.c_str(),recursive,needmore);
        }
		else 
		if ((command == "more") || (command == "less"))
		{
            bool recursive 		= false;
            const char* path 	= NULL;
            
            if (!arg1.empty()) 
			{
                if (arg1 == "-r" || arg1 == "/r") 
				{
                    recursive = true;
                    if (!arg2.empty()) 
                        path = arg2.c_str();
                }
                else 
                    path = arg1.c_str();
            }
            
            fs.dir(path, recursive,true);
        }
		else 
		if (command == "cd") 
		{
            if (arg1.empty()) 
			{
                myprintf("Usage: cd <directory>\n");
                continue;
            }
            if (!fs.cd(arg1.c_str())) 
                myprintf("15313$ Directory not found: %s\n", arg1.c_str());
        }
        else 
		if (command == "get") 
		{
            if (arg1.empty()) 
			{
                myprintf("Usage: get <filename>\n");
                continue;
            }
            fs.x(arg1.c_str());
        }
        else 
		if (command == "debug5") 
		{
			flagdebug5=!flagdebug5;
        }
        else 
		{
            myprintf("15327$ Unknown command: %s\n", command.c_str());
            myprintf("15328$ Type 'help' for list of commands\n");
        }
    }
	return 0;
}


/// TUI ... Text User UI (like DOS :-) 

void hidecursor() 
{
#ifdef _WIN32
    HANDLE hConsole = GetStdHandle(STD_OUTPUT_HANDLE);
    CONSOLE_CURSOR_INFO cursorInfo;
    GetConsoleCursorInfo(hConsole, &cursorInfo);
    cursorInfo.bVisible = FALSE;
    SetConsoleCursorInfo(hConsole, &cursorInfo);
#else
	printf("\x1B[?25l");  // Hide the cursor
    fflush(stdout);
#endif
}

void showcursor() 
{
#ifdef _WIN32
    HANDLE hConsole = GetStdHandle(STD_OUTPUT_HANDLE);
    CONSOLE_CURSOR_INFO cursorInfo;
    GetConsoleCursorInfo(hConsole, &cursorInfo);
    cursorInfo.bVisible = TRUE;
    SetConsoleCursorInfo(hConsole, &cursorInfo);
#else
	printf("\x1B[?25h");  // Show the cursor
    fflush(stdout);
#endif
}

// Structure to store data in a sortable way
struct fileentry 
{
    std::string name;
    int64_t 	date;
    int64_t 	size;
    bool 		selected;
    bool 		is_directory;
    fileentry(const std::string& n, int64_t d, int64_t s, bool dir) : name(n), date(d), size(s), selected(false), is_directory(dir) {}
};

class franztui 
{
private:
    std::vector<fileentry> entries;		// pezzi di dt
    int 				current_pos;    // current cursor position
    int 				top_line;       // first displayed line
    int 				sort_mode;      // current sort mode
    int 				screen_width;   // screen width
    int 				screen_height;  // screen height
    std::string 		current_path;  	// Current path (empty = root)
    std::vector<int> 	path_positions;	// Stack delle posizioni per backspace
	vector<string> 		added_path;		// add path (debug)
	std::string			filtervisible;	// rendi solo parte visibile
	
	void init_console() 
	{
        #ifdef _WIN32
        // Enable ANSI support on Windows
        HANDLE hOut = GetStdHandle(STD_OUTPUT_HANDLE);
        DWORD dwMode = 0;
        GetConsoleMode(hOut, &dwMode);
        dwMode |= ENABLE_VIRTUAL_TERMINAL_PROCESSING;
        SetConsoleMode(hOut, dwMode);
        #endif
    }

    // Functions for color management
    void start_inverse() 
	{
        printf("\033[7m");  // Invert colors
    }

    void end_inverse() 
	{
        printf("\033[0m");  // Reset colors
    }
	
    // Support functions for sorting
    static bool compare_default(const fileentry& a, const fileentry& b) 
	{
        if (a.is_directory != b.is_directory)
            return a.is_directory > b.is_directory;
#ifdef _WIN32
        return stringtolower(a.name) < stringtolower(b.name);
#else
        return a.name < b.name;
#endif
    }
    
    static bool compare_size(const fileentry& a, const fileentry& b) 
	{
        if (a.is_directory != b.is_directory)
            return a.is_directory > b.is_directory;
        if (a.is_directory)
            return a.name < b.name;
        return a.size < b.size;
    }
    
    static bool compare_date(const fileentry& a, const fileentry& b) 
	{
        if (a.is_directory != b.is_directory)
            return a.is_directory > b.is_directory;
        if (a.is_directory)
            return a.name < b.name;
        return a.date < b.date;
    }

    // Sort the entries according to the current mode
    void sort_entries() 
	{
        switch(sort_mode) {
            case 1: // default alphabetical
                std::sort(entries.begin(), entries.end(), compare_default);
                break;
            case 2: // ascending size
                std::sort(entries.begin(), entries.end(), compare_size);
                break;
            case 3: // ascending date
                std::sort(entries.begin(), entries.end(), compare_date);
                break;
            case 4: // reverse alphabetical
                std::sort(entries.begin(), entries.end(), compare_default);
                std::reverse(entries.begin(), entries.end());
                break;
            case 5: // descending size
                std::sort(entries.begin(), entries.end(), compare_size);
                std::reverse(entries.begin(), entries.end());
                break;
            case 6: // descending date
                std::sort(entries.begin(), entries.end(), compare_date);
                std::reverse(entries.begin(), entries.end());
                break;
        }
    }

    
	void move_cursor(int row, int col) 
	{
		printf("\033[%d;%dH", row, col);
	}

	// Function that uses a color code compatible with inversion
	void my_color_green() 
	{
		printf("\033[92m");  // Basic green without modifying the background
	}

	void draw_entry(int index, bool is_current_line) 
	{
		const fileentry& entry = entries[index];
		std::string display_name = truncate_with_extension(entry.name, screen_width - 40);
		
		// Position at the beginning of the line
		printf("\r");
		// Clear the entire line
		printf("\033[K");
		
		// if folder, reset
		if (entry.is_directory) 
			color_restore();
		
		// We apply the inversion first if it is the current line
		if (is_current_line) 
			start_inverse();
		
		// Then the color green for directories
		if (entry.is_directory) 
			my_color_green();
		
		printf("%c[%c] %08d| %s %21s %s",
			is_current_line ? '>' : ' ',
			entry.selected ? 'X' : ' ',
			index + 1,
			dateToString(true, entry.date).c_str(),
			entry.is_directory ? "<DIR>" : migliaia(entry.size),
			display_name.c_str()
		);
		
		// We restore in the same order: first the color then the inversion
		if (entry.is_directory) 
			color_restore();
		
		if (is_current_line) 
			end_inverse();
		fflush(stdout);
	
	}	
	void redraw_changed_lines(int old_pos, int new_pos) 
	{
		// Save cursor position
		printf("\033[s");
		
		// Calculate screen positions (relative to visible area)
		int old_screen_pos = old_pos - top_line + 3; // +3 for header lines
		int new_screen_pos = new_pos - top_line + 3;
		
		// Only redraw if positions are within visible area
		if (old_screen_pos >= 2 && old_screen_pos <(screen_height+2)) 
		{
			// Clear and redraw old position line
			move_cursor(old_screen_pos, 1);
			printf("\033[K"); // Clear the entire line
			draw_entry(old_pos, false);
		}
		
		if (new_screen_pos >= 2 && new_screen_pos <(screen_height+2)) 
		{
			// Clear and redraw new position line
			move_cursor(new_screen_pos, 1);
			printf("\033[K"); // Clear the entire line
			draw_entry(new_pos, true);
		}
		
		// Restore cursor position
		printf("\033[u");
		
		// Move cursor to the bottom for status line
		move_cursor(screen_height, 1);
		
		// Flush output to ensure immediate display
		fflush(stdout);
	}
    // Show the help screen
    void show_help() 
	{
        clearscreen();
		printf("Help on available commands (W=%d) (H=%d)\n\n",screen_width,screen_height);
		printf("ESC, q, Q       - Exit the program\n");
		printf("ENTER           - Enter a folder\n");
		printf("BACKSPACE       - Go back\n");
		printf("Arrows          - Move the cursor up/down\n");
		printf("PageUp/PageDown - Scroll one page up/down\n");
		printf("Home/End        - Go to the beginning/end of the list\n");
		printf("Space           - Select/Deselect the current item\n");
		printf("a               - Select all items\n");
		printf("n               - Deselect all items\n");
		printf("i               - Invert selection\n");
		printf("F1              - Sort alphabetically (A-Z)\n");
		printf("F2              - Sort by size (ascending)\n");
		printf("F3              - Sort by date (ascending)\n");
		printf("F4              - Sort alphabetically (Z-A)\n");
		printf("F5              - Sort by size (descending)\n");
		printf("F6              - Sort by date (descending)\n");
		printf("s               - Search files by name\n");
		printf("f               - Filter files by name\n");
		printf("x, g            - Extract/get selected files\n");
		printf(":               - Go to a specific line\n");
		printf("\nPress any key to return to the list...");
        get_key();
    }

	void filter_files()
	{
		move_cursor_to_input(); // Move the cursor below the help line
		showcursor();
		std::string filter = getuserinput("\nFilter: ", "");
		hidecursor();

		if (filter.empty()) 
			filtervisible.clear();  // Reset filter -> show all
		 else 
		 {
#ifdef _WIN32
			filtervisible = stringtolower(filter);
#else
			filtervisible = filter;
#endif
		}

		update_entries();
		show();
	}

    // Handles file search
    void search_files()
{
    move_cursor_to_input(); // Move the cursor below the help line
    std::string search_str = getuserinput("\nSearchtext: ", "");
    if (search_str=="")
        return;
#ifdef _WIN32
    search_str = stringtolower(search_str);
#endif
    // Deselect all before starting the search
    for (std::vector<fileentry>::iterator it = entries.begin(); it != entries.end(); ++it)
    {
        fileentry& entry = *it;
        std::string name = entry.name;
#ifdef _WIN32
        name = stringtolower(name);
#endif
        entry.selected = (name.find(search_str) != std::string::npos);
    }
}

    // Handles the goto line
    void goto_line() 
	{
		std::string line_str = getuserinput("\nGoto: ", "");
		if (line_str=="")
			return;
        
        int line = atoi(line_str.c_str());
        if (line > 0 && line <= (int)entries.size()) 
		{
            current_pos = line - 1;
            top_line = current_pos - (screen_height / 2);
            if (top_line < 0) top_line = 0;
        }
    }

	
    // Enumerate the selected files for extraction
    void enumerate_selected() 
{	
    clearscreen();
    int64_t sizetobeextracted	= 0;
    int 	selectedfiles		= 0;
    int 	selectedfolders		= 0;
    
    for (std::vector<fileentry>::const_iterator it = entries.begin(); it != entries.end(); ++it) 
    {
        const fileentry& entry = *it;
        if (entry.selected) 
        {
            string fullfile = current_path + entry.name;
            sizetobeextracted += entry.size;
            if (isdirectory(entry.name))
                selectedfolders++;
            else
                selectedfiles++;
            myprintf("%Z\n", fullfile.c_str());
        }
    }
    
    if ((selectedfiles + selectedfolders) == 0)
    {
        myprintf("15597: Nothing selected\n");
        printf("\nPress a key...");
        get_key();
        return;
    }
        
    printbar('-');
    myprintf("15947: Selected files %s folders %s\n", migliaia(selectedfiles), migliaia(selectedfolders));
    if (sizetobeextracted > 0)
        myprintf("15948: Total    files %s bytes\n", migliaia(sizetobeextracted));
    string relative = getuserinput("Where to extract? (default: current): ", "./");
    relative = wintolinuxpath(relative);

    for (std::vector<fileentry>::const_iterator it = entries.begin(); it != entries.end(); ++it) 
    {
        const fileentry& entry = *it;
        if (entry.selected)
            (*pjidac).files.push_back(current_path + entry.name);
    }

    xto(relative, current_path, sizetobeextracted);
    printf("\nPress a key (clear all selected files)...");
    get_key();
		
	for (std::vector<fileentry>::iterator it = entries.begin(); it != entries.end(); ++it) 
    {
		fileentry& entry = *it;
		entry.selected = false;
	}
	show();
}

	int barcount(const string& i_stringa)
	{
		int risultato=0;
		for (unsigned int i=0;i<i_stringa.size();i++)
			if (i_stringa[i]=='/')
				risultato++;
		return risultato;
	}
	
	bool is_in_current_path(const std::string& name) 
	{
        debug_print("checking file", name);
        debug_print("current path", current_path);
        
        if (current_path.empty()) 
		{
            // At the root level, show only the first level files/folders
            size_t first_slash = name.find('/');
            size_t last_slash = name.find_last_of('/');
            
            // If there are no slashes or the slash is at the end (folder), it's at the root
            bool is_root = (first_slash == std::string::npos) || 
                          (first_slash == last_slash && first_slash == name.length() - 1);
            
            debug_print("root check result", is_root ? "true" : "false");
            return is_root;
        }
 		
		if (current_path!="")
		{
			if (flagdebug5)
				printf(" ===================== name %s  current_path %s\n",name.c_str(),current_path.c_str());
			return starts_with(name,current_path);
		}
		else
		{
			// Not at root, we check if the file is in the current folder
			if (name.length() <= current_path.length()) 
			{
				debug_print("too short", name);
				return false;
			}
        }
        // Must start with the current path
        if (name.substr(0, current_path.length()) != current_path) 
		{
            debug_print("wrong prefix", name);
            return false;
        }
        
        // Remove the current path to get the relative name
        std::string relative = name.substr(current_path.length());
        debug_print("relative path", relative);
        
        // Check that it is directly in the current folder
        // (no other slashes except maybe the last one for directories)
        size_t first_slash = relative.find('/');
        bool valid = (first_slash == std::string::npos) || 
                    (first_slash == relative.length() - 1);
        
        debug_print("final result", valid ? "true" : "false");
        return valid;
    }	
    
    // Enter a folder
	void enter_directory(const std::string& dir_name) 
	{
        debug_print("entering directory", dir_name);
        
        // Save the current position for backspace
        path_positions.push_back(current_pos);
        
        // Update the current path
        // If the directory name does not end with '/', add it
        std::string new_dir = dir_name;
        if (new_dir.back() != '/') 
            new_dir += '/';

        
        // If we are at the root, the new path is just the directory name
        if (current_path.empty())
            current_path = new_dir;
        else 
		{
            // Otherwise, we must concatenate to the existing path
            // If the name already includes the full path, we don't add it again
            if (new_dir.find(current_path) == 0) 
                current_path = new_dir;
			else 
                current_path += new_dir;
        }
        
        debug_print("new current path", current_path);
        // Reload the entries for the new path
        update_entries();
    }

    // Go back to the parent folder
    void go_back() 
	{
        if (current_path.empty()) return;  
		
        // Find the last separator in the current path
        size_t last_slash = current_path.find_last_of('/', current_path.length() - 2);
        if (last_slash == std::string::npos) 
            current_path.clear();  // Back to root
		else 
            current_path = current_path.substr(0, last_slash + 1);
        
        // Reload the entries for the new path
        update_entries();
        
        // Restore the previous position
        if (!path_positions.empty()) 
		{
            current_pos = path_positions.back();
            path_positions.pop_back();
            if (current_pos >= (int)entries.size()) 
                current_pos = entries.size() - 1;
        }
    }
	
	void debug_print(const char* msg, const std::string& s) 
	{
		if (flagdebug5)
		{
			printf("DEBUG: %s: '%s'\n", msg, s.c_str());
			fflush(stdout);
		}
    }
	
public:

	franztui(int i_width, int i_height) : current_pos(0), top_line(0), sort_mode(1), screen_width(i_width), screen_height(i_height),current_path("") 
	{
		filtervisible="";
		
        init_console();

        // Load all data from the global DTMap
		for (DTMap::const_iterator pair = (*pjidac).dt.begin(); pair != (*pjidac).dt.end(); ++pair)

        {
            bool is_dir = pair->first.back() == '/';
            entries.push_back(fileentry(
                pair->first,
                pair->second.date,
                pair->second.size,
                is_dir
            ));
        }

		int 	larghezzaconsole=terminalwidth()-4;
		int		ognipunto=0;
		if (larghezzaconsole>0)
			ognipunto=(*pjidac).dt.size()/larghezzaconsole;
		if (ognipunto==0)
			ognipunto++;

		bool	wehaveslash=false;
		int	contatore=0;
		for (DTMap::iterator a=(*pjidac).dt.begin(); a!=(*pjidac).dt.end(); ++a)
		{
			contatore++;
			if ((contatore%ognipunto)==0)
			{
				myprintf("+");
				fflush(stdout);
			}
			if (!a->first.empty())
				wehaveslash=(a->first[0]=='/');

			generate_directories(a->first,added_path);
        }
		myprintf("\n");
		/*
		if (added_path.size()>=1)
			myprintf("14500$ Entering with a cd %Z\n",added_path[0].c_str());
		*/
		///add_directory("/etc/");
		//add_directory("/root/");
		//add_directory("/usr/");
		if (wehaveslash)
			current_path="/"; //LINUX!!
		
        // Filter and sort entries for the root path
        update_entries();
    }
	
	void show() 
	{
		clearscreen();
		string percorsotagliato=current_path.empty() ? "/" : current_path;
		percorsotagliato=truncate_with_extension(percorsotagliato,screen_width-20);
		color_yellow();
		myprintf("ENTR %08d|", entries.size());
		
        start_inverse();
        myprintf("%Z\n",percorsotagliato.c_str());
        end_inverse();
		color_restore();
	    myprintf("\n");
		
        // Show the entries on the current page
        for (int i = 0; i < screen_height - 1 && (top_line + i) < (int)entries.size(); i++) 
		{
            const fileentry& entry = entries[top_line + i];
            std::string display_name = truncate_with_extension(entry.name, screen_width - 40);
            
            // If this is the current line, start the inversion
            if (top_line + i == current_pos) 
			    start_inverse();
            
			if (entry.is_directory)
				color_green();
            // Format the line
            printf("%c[%c] %08d| %s %21s %s",
                (top_line + i == current_pos) ? '>' : ' ',
                entry.selected ? 'X' : ' ',
                top_line + i + 1,  // one-based numbering
                dateToString(true, entry.date).c_str(),
                entry.is_directory ? "<DIR>" : migliaia(entry.size),
                display_name.c_str()
            );
			if (entry.is_directory)
				color_restore();
            
            // If this is the current line, end the inversion
            if (top_line + i == current_pos) 
			    end_inverse();
            
            printf("\n");  // Line break after handling inversion
        }
        
        // Show the information line
	    ///move_cursor(screen_height+2, 1); 
		///fflush(stdout);
		color_yellow();
        printf("ESC/q F1-F6=Sort all not inv search filter get SPACE :go ?help\n");
        color_restore();
		hidecursor();
    }

void process() 
{
    bool running = true;
    show(); // Initial full draw

    while (running) 
    {
        int ch = get_key();
        bool need_full_redraw = false;
        
        switch(ch) 
        {
            case	3: //control-C
                    color_restore();
                    myprintf("\n");
                    myprintf("Goodbye(CONTROL-C detected)\n");
                    seppuku();
                    break;
                    
            case 	27: // ESC
            case 	'q':
            case 	'Q':
                    running = false;
                    break;
            
            case 	'k': // Up arrow
                    if (current_pos > 0) 
                    {
                        int old_pos = current_pos;
                        current_pos--;
                        if (current_pos < top_line) 
                        {
                            top_line = current_pos;
                            need_full_redraw = true;
                        } 
                        else 
                        redraw_changed_lines(old_pos, current_pos);
                    }
                    break;
                
            case 	'j': // Down arrow
                    if (current_pos < (int)entries.size() - 1) 
                    {
                        int old_pos = current_pos;
                        current_pos++;
                        if (current_pos >= top_line + screen_height - 1)
                        {
                            top_line = current_pos - screen_height + 2;
                            need_full_redraw = true;
                        } 
                        else 
                            redraw_changed_lines(old_pos, current_pos);
                    }
                    break;
                
            case 	'u': // PagSu
                    if (current_pos > 0) 
                    { // Do nothing if you are already at the top
                        int step = screen_height - 1;
                        ///printf("\nPRE Step is %d  current_pos %d  currentpos-step %d top_line %d\n",step,current_pos,current_pos-step,top_line);
                        if (current_pos - step < 0) 
                        {
                            ///printf("\nMInore di zero\n");
                            current_pos = 0;
                            top_line = 0;
                        } 
                        else 
                        {
                            ///printf("\nELSE\n");
                            current_pos -= step;
                            top_line -= step;
                        }
                        if (top_line<0)
                            top_line=0;
                        if (current_pos<0)
                            current_pos=0;
                        
                        ///printf("\nPOST current_pos %d  top_line %d\n",current_pos,top_line);
                        ///mygetch(false);
                        ///draw_entry(current_pos, true);
                        show();
                    }
                
                    break;

            case 	'd': // PagDown
                    ///if (current_pos != (int)entries.size() - 1) 
                    {
                        int step = screen_height - 1;
                        if (current_pos + step >= (int)entries.size()) 
                        {
                            current_pos = entries.size() - 1;
                            top_line = current_pos - screen_height + 2;
                            if (top_line < 0) top_line = 0;
                        } 
                        else 
                        {
                            current_pos += step;
                            top_line += step;
                        }
                        show();
                    }
                    break;

            case 	'h': // Home
                    if (current_pos > 0) 
                    { // Do nothing if you are already at the top
                        current_pos 	= 0;
                        top_line 		= 0;
                    ///draw_entry(current_pos, true);
                        show();
                    }
                    break;

            case 	'e': // End
                    if (current_pos < (int)entries.size() - 1) 
                    { // Do nothing if you are already at the bottom
                        current_pos = entries.size() - 1;
                        top_line = current_pos - screen_height + 2;
                        if (top_line < 0) top_line = 0;
                        ///draw_entry(current_pos, true);
                        show();
                    }
                    break;

                
            case 	' ': // Select/Deselect
                    if (current_pos < (int)entries.size()) 
                    {
                        entries[current_pos].selected = !entries[current_pos].selected;
                        if (current_pos < (int)entries.size() - 1) 
                        {
                            int old_pos = current_pos;
                            current_pos++;
                            if (current_pos >= top_line + screen_height - 1) 
                            {
                                top_line = current_pos - screen_height + 2;
                                show();
                            } 
                            else // Redraw both the selected item and the new position 
                                redraw_changed_lines(old_pos, current_pos);
                        } 
                        else // Just redraw the selected item if we're at the end 
                            draw_entry(current_pos, true);
                    }
                    break;
                
            case 	'a': // Select all
                    for (std::vector<fileentry>::iterator it = entries.begin(); it != entries.end(); ++it) 
                    {
                        fileentry& entry = *it;
                        entry.selected = true;
                    }
                    show();
                    break;

            case 	'n': // Deselect all
                    for (std::vector<fileentry>::iterator it = entries.begin(); it != entries.end(); ++it) 
                    {
                        fileentry& entry = *it;
                        entry.selected = false;
                    }
                    show();
                    break;

            case 	'i': // Invert selection
                    for (std::vector<fileentry>::iterator it = entries.begin(); it != entries.end(); ++it) 
                        it->selected = !it->selected;
                    //for (fileentry& entry : entries) 
                    ///	entry.selected = !entry.selected;
                    show();
                    break;
                
            case 	128: // F1 - Default sort
            case 	129: // F2 - Size sort
            case 	130: // F3 - Date sort
            case 	131: // F4 - Default reverse
            case 	132: // F5 - Size reverse
            case 	133: // F6 - Date reverse
                    sort_mode = ch == 128 ? 1 : 
                               ch == 129 ? 2 : 
                               ch == 130 ? 3 :
                               ch == 131 ? 4 :
                               ch == 132 ? 5 : 6;
                    sort_entries();
                    show();
                    break;

            case 	'?': // Help 
            case 	'H': // Help (maiuscolo per evitare conflitto con Home)
                    show_help();
                    show();
                    break;
                    
            case 	's': // Select
                    showcursor();
                    search_files();
                    hidecursor();
                    show();
                    break;
                    
            case 	'f': // filter
                    showcursor();
                    filter_files();
                    hidecursor();
                    show();
                    break;
                
            case 	':': // Goto line
                    showcursor();
                    goto_line();
                    hidecursor();
                    show();
                    break;

            case 	'x': // Process selected
            case 	'g':
                    showcursor();
                    enumerate_selected();
                    hidecursor();
                    show();
                    break;
                
            case 	13: // Enter
                    if ((current_pos < (int)entries.size()) && (entries[current_pos].is_directory)) 
                    {
                        enter_directory(entries[current_pos].name);
                        show();
                    }
                    break;

            case 	8: // Backspace
                    go_back();
                    show();
                    break;

        }
        
        if (need_full_redraw || needs_full_redraw(ch)) 
            show();
    }
    showcursor();
    move_cursor_to_input(); // Position the cursor when you exit
}
	void move_cursor_to_input()
	{
		move_cursor(screen_height+4, 1); // Position the cursor under the help line
		fflush(stdout);
	}

	bool needs_full_redraw(int ch) 
	{
		return ch == ' ' ||  // Selection changes
			   ch == 'a' ||  // Select all
			   ch == 'n' ||  // Deselect all
			   ch == 'i' ||  // Invert selection
			   ch == 'u' ||  // Page up
			   ch == 'd' ||  // Page down
			   ch == 'h' ||  // Home
			   ch == 'e' ||  // End
			   (ch >= 128 && ch <= 133); // F1-F6 sort operations
	}
	void update_entries() 
	{
		if (flagdebug5)
		{
			printf("*************************************\n");
			printf("*************************************\n");
			printf("*************************************\n");
			printf("*************************************\n");
			
			printf("DEBUG: update_entries %s entries on current_path |%s|\n", migliaia(entries.size()),current_path.c_str());
		}
		entries.clear();
		for (DTMap::const_iterator pair = (*pjidac).dt.begin(); pair != (*pjidac).dt.end(); ++pair)

		{
			if (pair->second.date!=0)
			{
				if (flagdebug5)
					printf("Pair.first %s  current_path %s barcount %d\n",pair->first.c_str(),current_path.c_str(),barcount(pair->first));
				bool flagaggiungi=true;

				if (pair->first!=current_path)
					if (starts_with(pair->first,current_path))
					{
						
						string percorsino=pair->first;
						myreplace(percorsino,current_path,"");
					///if (flagdebug5)
						///printf("Percorsino 1 |%s|\n",percorsino.c_str());
						if (!isdirectory(percorsino))
						{
							int limite=0;
							if (iswindowspath(percorsino))
									limite=1;
							///printf("Perkorsino %s barcount %d limite %d\n",percorsino.c_str(),barcount(percorsino),limite);
							if (barcount(percorsino)>limite)
								flagaggiungi=false;
						}
					}
					
	///				flagaggiungi=true;
				if (flagaggiungi)
				{
					bool is_dir = pair->first.back() == '/';
					entries.push_back(fileentry(
						pair->first,
						pair->second.date,
						pair->second.size,
						is_dir
					));
				}
				///else
					///myprintf("Scarto %s\n",pair.first.c_str());
			}
        }
		
		if (flagdebug5)
		{
			printbar('-');
			for (unsigned int i=0;i<entries.size();i++)
			{
				myprintf("%08d %s\n",i,entries[i].name.c_str());
				if (i>100)
					break;
			}
			printbar('-');
		}
		std::vector<fileentry> filtered;

		for (std::vector<fileentry>::const_iterator it = entries.begin(); it != entries.end(); ++it) 
		{
			const fileentry& entry = *it;
			if (is_in_current_path(entry.name)) 
			{
				fileentry new_entry = entry;
				if (!current_path.empty()) 
					new_entry.name = entry.name.substr(current_path.length());
				if (new_entry.name!="")
				{
					bool flagaggiungi=true;
					
					if (!filtervisible.empty()) 
					{
						std::string fullpath = current_path + new_entry.name;  // Full path
#ifdef _WIN32
						fullpath = stringtolower(fullpath);
#endif
						flagaggiungi = fullpath.find(filtervisible) != std::string::npos;
					}
					if (flagaggiungi)
					{
						filtered.push_back(new_entry);
						debug_print("added entry", new_entry.name);
					}
				}
			}
		}
/*
        std::vector<fileentry> filtered;
		
		for (const auto& entry : entries) 
		{
            if (is_in_current_path(entry.name)) 
			{
                fileentry new_entry = entry;
                if (!current_path.empty()) 
				    new_entry.name = entry.name.substr(current_path.length());
                if (new_entry.name!="")
				{
					bool flagaggiungi=true;
					
					if (!filtervisible.empty()) 
					{
						std::string fullpath = current_path + new_entry.name;  // Full path
#ifdef _WIN32
						fullpath = stringtolower(fullpath);
#endif
						flagaggiungi = fullpath.find(filtervisible) != std::string::npos;
					}
					if (flagaggiungi)
					{
						filtered.push_back(new_entry);
						debug_print("added entry", new_entry.name);
					}
				}
            }
        }
		*/
		if (flagdebug5)
			printf("DEBUG: filtered to %s entries\n", migliaia(filtered.size()));
        
        // Replace the entries with the filtered ones
        entries = filtered;  // Changed from swap to direct assignment
        
        // Reset position
        current_pos = 0;
        top_line = 0;
        
		///if (flagdebug5)
			///getch();
        // Reorder according to the current mode
        sort_entries();
    }
};



int Jidac::tui()
{
    myprintf("14235: Entering TUI\n");
    if (archive=="")
    {
        myprintf("14232! archive is empty\n");
        return 2;
    }

    archive=getbackupnameifany(archive);
    command            	='l';
    g_optional        	="versum"; //force isselected
    
	int64_t csize=read_archive(NULL,archive.c_str());//,&errors,0,false); 
	myprintf("\n");
    
    if (csize==0)
    {
        myprintf("14905! Cannot open archive <<%Z>>\n",archive.c_str());
        return 2;
    }

	int altezzaconsole			=terminalheight();
	int larghezzaconsole		=terminalwidth();
			
	if ((altezzaconsole<6) || (larghezzaconsole<21))
	{
		myprintf("16446: Console too small Width %d Height %d\n",larghezzaconsole,altezzaconsole);
		return 1;
	}
    ///franztui fg(80,20);
	franztui fg(larghezzaconsole-21,altezzaconsole-6);
	fg.process();
	showcursor();
	return 0;
}
#endif  // ANCIENT



#ifdef _WIN32
std::string searchfile(const std::string& i_directory, const std::string& i_file) 
{
    std::wstring directory = utow(i_directory.c_str());
    std::wstring file 	   = utow(i_file.c_str());

    if (directory.back() != L'\\') 
        directory += L'\\';
    
    std::wstring searchPath = directory + L"*.*";
    WIN32_FIND_DATAW findData;
    HANDLE hFind = FindFirstFileW(searchPath.c_str(), &findData);

    if (hFind == INVALID_HANDLE_VALUE) 
      return "";  // Return an empty string if there is an error opening the directory

    do {
        // Skip special files "." and ".."
        if (wcscmp(findData.cFileName, L".") == 0 || wcscmp(findData.cFileName, L"..") == 0)
            continue;

        std::wstring fullPath = directory + findData.cFileName;

        if (findData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) 
		{
            std::string result = searchfile(wtou(fullPath.c_str()), i_file);
            if (!result.empty()) 
			{
                FindClose(hFind);  // Close the find manager before returning the result
                return result;  // If a file is found, we return it immediately
            }
        } 
		else 
		{
            // If it's a file, compare the name with the one sought
            if (_wcsicmp(findData.cFileName, file.c_str()) == 0) 
			{
                std::string result = wtou(fullPath.c_str());  // Convert the path to string
				if (flagdebug)
					myprintf("99718: Founded %s\n", result.c_str());
                FindClose(hFind);  // Close the find manager before returning the result
                return result;  // Return the path of the found file
            }
        }
    } while (FindNextFileW(hFind, &findData));

    if (GetLastError() != ERROR_NO_MORE_FILES) 
	    myprintf("99343! Filesystem error: %d\n", GetLastError());
    
    FindClose(hFind);
    return "";
}
#endif

#ifdef ZPAQFULL ///NOSFTPSTART
#ifndef _WIN32
bool findmysql(std::string& o_mysql, std::string& o_mysqldump) 
{
    o_mysql = "";
    o_mysqldump = "";

    // Declaration of vectors without direct initialization
    std::vector<std::string> common_paths;
    std::vector<std::string> mysql_names;
    std::vector<std::string> mysqldump_names;

    // Populating common_paths
    common_paths.push_back("/usr/bin/");
    common_paths.push_back("/usr/local/bin/");
    common_paths.push_back("/bin/");
    common_paths.push_back("/usr/sbin/");
    common_paths.push_back("/opt/mysql/bin/");
    common_paths.push_back("/usr/local/mysql/bin/");
    common_paths.push_back("/usr/local/mariadb/bin/");
    common_paths.push_back("/usr/local/opt/mysql/bin/");
    common_paths.push_back("/opt/bitnami/mysql/bin/");
    common_paths.push_back("/opt/lampp/bin/");
    common_paths.push_back("/snap/bin/");
    common_paths.push_back("/usr/local/var/mysql/bin/");
    common_paths.push_back("/usr/local/lib/mysql/bin/");
    common_paths.push_back("/usr/pkg/mysql/bin/");
    common_paths.push_back("/usr/opt/mysql/bin/");
    common_paths.push_back("/usr/local/mysql-advanced/bin/");
    common_paths.push_back("/opt/plesk/mysql/bin/");
    common_paths.push_back("/opt/azuracast/mysql/bin/");
    common_paths.push_back("/usr/lib/mysql/mysql-bin/");
    common_paths.push_back("/var/lib/mysql/mysql-bin/");
    common_paths.push_back("/usr/share/mysql/");
    common_paths.push_back("/usr/sfw/mysql/bin/");
    common_paths.push_back("/opt/sfw/mysql/bin/");
    common_paths.push_back("/opt/QNAP/mysql/bin/");
    common_paths.push_back("/mnt/HDA_ROOT/opt/mysql/bin/");
    common_paths.push_back("/opt/bin/");
    common_paths.push_back("/usr/local/lib/mysql/bin/");
    common_paths.push_back("/volume1/@appstore/mysql/bin/");
    common_paths.push_back("/volume1/@appstore/mariadb/bin/");
    common_paths.push_back("/opt/mysql/bin/");
    common_paths.push_back("/usr/syno/mysql/bin/");
    common_paths.push_back("/volume1/mysql/bin/");
    common_paths.push_back("/usr/local/mariadb/bin/");
    common_paths.push_back("/usr/local/opt/mysql/bin/");

    // Populating mysql_names
    mysql_names.push_back("mysql");
    mysql_names.push_back("mariadb");

    // Populating mysqldump_names
    mysqldump_names.push_back("mysqldump");
    mysqldump_names.push_back("mariadb-dump");

    bool found_mysql = false;
    bool found_mysqldump = false;

    for (unsigned int i = 0; i < common_paths.size(); ++i) 
    {
        for (unsigned int j = 0; j < mysql_names.size(); ++j) 
        {
            std::string full_path = common_paths[i] + mysql_names[j];
            if (flagdebug2)
                myprintf("52649: Checking <<%Z>>\n", full_path.c_str());
            if (fileexists(full_path.c_str())) 
            {
                o_mysql = full_path;
                found_mysql = true;
                break;
            }
        }
        if (found_mysql) 
            break;
    }

    for (unsigned int i = 0; i < common_paths.size(); ++i) 
    {
        for (unsigned int j = 0; j < mysqldump_names.size(); ++j) 
        {
            std::string full_path = common_paths[i] + mysqldump_names[j];
            if (flagdebug2)
                myprintf("52650: Checking <<%Z>>\n", full_path.c_str());
            if (fileexists(full_path.c_str())) 
            {
                o_mysqldump = full_path;
                found_mysqldump = true;
                break; 
            }
        }
        if (found_mysqldump) 
            break;
    }

    return found_mysql && found_mysqldump;
}
#endif
#endif ///NOSFTPEND



#ifdef unix
void exec_with_realtime_output(const char* cmd)
{
#ifdef ANCIENT
	(void)cmd;
    myprintf("00321: Real-time output not supported in ANCIENT mode\n");
#else
    char buffer[128];
    FILE* pipe = popen(cmd, "r");
    if (!pipe) 
    {
        myprintf("00322! popen kaputt\n");
        return;
    }

    while (fgets(buffer, sizeof(buffer), pipe) != NULL) 
        myprintf("%s", buffer);

    int status = pclose(pipe);
    if (status == -1) 
    {
        myprintf("00323! pclose failed\n");
    }
    else if (status != 0) 
    {
        myprintf("00324! Command '%s' exited with status %d\n", cmd, status);
    }
#endif 
}
#endif

#ifdef ZPAQFULL ///NOSFTPSTART
int Jidac::mysql()
{
	if (archive=="")
    {
        myprintf("14237! archive is empty\n");
        return 2;
    }
	if (g_mysql_host=="")
	{
		myprintf("99656: mysql host empty\n");
		return 2;
	}
	if (g_mysql_user=="")
	{
		myprintf("99661: mysql user empty\n");
		return 2;
	}
	if (flagverbose)
		myprintf("99664: Working on mysql %s port %d user %s bin %s\n",g_mysql_host.c_str(),g_mysql_port,g_mysql_user.c_str(),g_bin.c_str());

	string themysql		="";
	string themysqldump ="";
#ifdef _WIN32
	string	mypath=includetrailingbackslash(getwinexedir());
	#else
	string	mypath=includetrailingbackslash(extractfilepath(fullzpaqexename.c_str()));
#endif
	if (g_bin=="")
	{
#ifdef _WIN32
	
	if (fileexists(mypath + "mysqldump.exe"))
		themysqldump = mypath + "mysqldump.exe";
	else
	{
		myprintf("99761: Searching for mysqldump.exe or mariadb-dump.exe into c:/program files:");
		themysqldump = searchfile("c:/program files", "mysqldump.exe");
		if (themysqldump.empty())
		{
			// Try with mariadb-dump.exe if mysqldump.exe was not found
			themysqldump = searchfile("c:/program files", "mariadb-dump.exe");
			if (themysqldump.empty())
			{
				color_red();
				myprintf("CANNOT FIND\n");
				color_restore();
			}
			else
			{
				color_green();
				myprintf("OK (found mariadb-dump.exe)\n");
				color_restore();
			}
		}
		else
		{
			color_green();
			myprintf("OK (found mysqldump.exe)\n");
			color_restore();
		}
	}

	if (fileexists(mypath + "mysql.exe"))
		themysql = mypath + "mysql.exe";
	else
	{
		myprintf("99768: Searching for mysql.exe or mariadb.exe          into c:/program files:");
		themysql = searchfile("c:/program files", "mysql.exe");
		if (themysql.empty())
		{
			// Try with mariadb.exe if mysql.exe was not found
			themysql = searchfile("c:/program files", "mariadb.exe");
			if (themysql.empty())
			{
				color_red();
				myprintf("CANNOT FIND\n");
				color_restore();
			}
			else
			{
				color_green();
				myprintf("OK (found mariadb.exe)\n");
				color_restore();
			}
		}
		else
		{
			color_green();
			myprintf("OK (found mysql.exe)\n");
			color_restore();
		}
	}
#endif
	}
	else
	{
		themysqldump=includetrailingbackslash(g_bin)+"mysqldump";
		if (fileexists(includetrailingbackslash(g_bin)+"mariadb-dump"))
			themysqldump=includetrailingbackslash(g_bin)+"mariadb-dump";

		themysql=includetrailingbackslash(g_bin)+"mysql";
		if (fileexists(includetrailingbackslash(g_bin)+"mariadb"))
			themysql=includetrailingbackslash(g_bin)+"mariadb";

#ifdef _WIN32
		themysqldump+=".exe";
		themysql+=".exe";
#endif
	}
#ifdef _WIN32
	if (flagspace)
		if ((themysqldump=="") || (themysql==""))
		{
			myprintf("99794$ Cannot find mysql.exe and mysqldump.exe, fixing due to -space for %s...\n",mypath.c_str());
			if (kickstart_resources("MYSQL")==0)
			{
				if (fileexists(mypath+"mysqldump.exe"))
					themysqldump=mypath+"mysqldump.exe";
				if (fileexists(mypath+"mysql.exe"))
					themysql=mypath+"mysql.exe";
				///if (flagdebug3)
				{
					myprintf("96215: after kickstart themysqldump %s\n",themysqldump.c_str());
					myprintf("96214: after kickstart themysql     %s\n",themysql.c_str());
					
				}
			}
			else
				myprintf("96221: kickstart failed\n");
		}
#endif

#ifdef unix
		if ((themysqldump=="") || (themysql==""))
			findmysql(themysql,themysqldump);
#endif

	if (!fileexists(themysqldump))
	{
#ifdef _WIN32
		myprintf("99822! cannot find mysqldump.exe, use -bin to specify the folder or -space to get from Internet\n");
#else
		myprintf("99821! cannot find mysqldump, use -bin to specify the folder\n");
#endif
		return 2;
	}
	if (!fileexists(themysql))
	{
#ifdef _WIN32
		myprintf("91811! cannot find mysql.exe, use -bin to specify the folder or -space to get from Internet\n");
#else
		myprintf("99811! cannot find mysql, use -bin to specify the folder\n");
#endif
		return 2;
	}
	if (flagverbose)
	{
		myprintf("99895: Using mysql     <<%Z>>\n",themysql.c_str());
		myprintf("99894: Using mysqldump <<%Z>>\n",themysqldump.c_str());
	}
	int64_t presize=prendidimensionefile(archive.c_str());

#ifdef _WIN32		
	string	filebatch	=g_gettempdirectory()+"mysqlz.bat";
#else
	string filebatch	="/tmp/mysqlz.sh";
#endif
	filebatch=nomefileseesistegia(filebatch);
	if (fileexists(filebatch))
		if (remove(filebatch.c_str())!=0)
		{
			myprintf("90672! Highlander batch  %s\n", filebatch.c_str());
			return 2;
		}
	FILE* batch=fopen(filebatch.c_str(), "wb");
	if (batch==NULL)
	{
		myprintf("99678! cannot write on %s\n",filebatch.c_str());
		return 2;
	}

	string parametrini;
	parametrini+=" -m"+method;

	if (plainpassword!="")
		parametrini+=" -key "+plainpassword;

	if (flagverbose)
		myprintf("99922: Parameters |%s|\n",parametrini.c_str());
    
	///--single-transaction
#ifdef _WIN32
    string temp         = linuxtowinpath(archive);
    themysql            = linuxtowinpath(themysql);
    themysqldump        = linuxtowinpath(themysqldump);
    string winexename   = linuxtowinpath(fullzpaqexename);
    fprintf(batch, "@echo off\n");
    fprintf(batch, "setlocal enabledelayedexpansion\n");
    fprintf(batch, "set \"MYSQL_HOST=%s\"\n", g_mysql_host.c_str());
    fprintf(batch, "set \"MYSQL_USER=%s\"\n", g_mysql_user.c_str());
    fprintf(batch, "set \"MYSQL_PASSWORD=%s\"\n", g_mysql_password.c_str());
    fprintf(batch, "set \"MYSQL_PORT=%d\"\n", g_mysql_port);
    fprintf(batch, "set \"BACKUP_DEST=%s\"\n", temp.c_str());
    
    // Generate the database list
    fprintf(batch, "\"%s\" -u%%MYSQL_USER%% -p%%MYSQL_PASSWORD%% -h%%MYSQL_HOST%% -P%%MYSQL_PORT%% -e \"SHOW DATABASES;\" > \"%%TEMP%%\\db_list.txt\"\n", themysql.c_str());
    
    // Handling inclusion/exclusion filters with wildcard support
    if (!onlyfiles.empty()) 
	{
        // Inclusion mode: process only the databases that match the specified patterns
        fprintf(batch, "echo Processing only specified database patterns...\n");
        fprintf(batch, "type \"%%TEMP%%\\db_list.txt\" | findstr /v \"Database\" > \"%%TEMP%%\\db_list_clean.txt\"\n");
        fprintf(batch, "for /f \"tokens=1\" %%%%d in ('type \"%%TEMP%%\\db_list_clean.txt\"') do (\n");
        fprintf(batch, "    set \"DB_NAME=%%%%d\"\n");
        fprintf(batch, "    set \"MATCH=0\"\n");
        
        // Check if the database matches any of the specified patterns
        for (size_t i=0;i<onlyfiles.size();i++) 
		{
            // Converti il pattern in uno compatibile con findstr (sostituisci * con .*)
            string winPattern = onlyfiles[i];
            std::replace(winPattern.begin(), winPattern.end(), '*', '.');
            
            fprintf(batch, "    echo !DB_NAME! | findstr /i \"%s\" > nul\n", winPattern.c_str());
            fprintf(batch, "    if !errorlevel! equ 0 set \"MATCH=1\"\n");
        }
        
        fprintf(batch, "    if !MATCH! equ 1 (\n");
        if (flagverbose)
            fprintf(batch, "        echo Processing matched database !DB_NAME!...\n");
        fprintf(batch, "        \"%s\" -u%%MYSQL_USER%% -p%%MYSQL_PASSWORD%% -h%%MYSQL_HOST%% -P%%MYSQL_PORT%% --add-drop-database --databases !DB_NAME! | \"%s\" a \"%%BACKUP_DEST%%\" \"!DB_NAME!.sql\" -stdin -silent %s\n", 
            themysqldump.c_str(), winexename.c_str(), parametrini.c_str());
        fprintf(batch, "        if !errorlevel! equ 0 (\n");
        fprintf(batch, "            echo * Backup !DB_NAME! OK\n");
        fprintf(batch, "        ) else (\n");
        fprintf(batch, "            echo * ERROR on database !DB_NAME!\n");
        fprintf(batch, "        )\n");
        fprintf(batch, "    )\n");
        fprintf(batch, ")\n");
    } 
	else 
	{
        // Process all databases with possible exclusions based on patterns
        fprintf(batch, "for /f \"skip=1 tokens=1\" %%%%d in ('type \"%%TEMP%%\\db_list.txt\"') do (\n");
        fprintf(batch, "    set \"DB_NAME=%%%%d\"\n");
        fprintf(batch, "    set \"EXCLUDE=0\"\n");
        
        // We always exclude system databases
        fprintf(batch, "    echo !DB_NAME! | findstr /i \"information_schema performance_schema sys\" > nul\n");
        fprintf(batch, "    if !errorlevel! equ 0 set \"EXCLUDE=1\"\n");
        
        // Check custom exclusions with wildcards
        if (!notfiles.empty()) 
		{
            for (size_t i=0;i<notfiles.size(); i++) 
			{
                // Converti il pattern in uno compatibile con findstr (sostituisci * con .*)
                string winPattern = notfiles[i];
                std::replace(winPattern.begin(), winPattern.end(), '*', '.');
                fprintf(batch, "    echo !DB_NAME! | findstr /i \"%s\" > nul\n", winPattern.c_str());
                fprintf(batch, "    if !errorlevel! equ 0 set \"EXCLUDE=1\"\n");
            }
        }
        
        // Backup of db
		fprintf(batch, "    if !EXCLUDE! equ 0 (\n");
        if (flagverbose)
            fprintf(batch, "        echo Processing database !DB_NAME!...\n");
        fprintf(batch, "        \"%s\" -u%%MYSQL_USER%% -p%%MYSQL_PASSWORD%% -h%%MYSQL_HOST%% -P%%MYSQL_PORT%% --add-drop-database --databases !DB_NAME! | \"%s\" a \"%%BACKUP_DEST%%\" \"!DB_NAME!.sql\" -stdin -silent %s\n", 
            themysqldump.c_str(), winexename.c_str(), parametrini.c_str());
        fprintf(batch, "        if !errorlevel! equ 0 (\n");
        fprintf(batch, "            echo * Backup !DB_NAME! OK\n");
        fprintf(batch, "        ) else (\n");
        fprintf(batch, "            echo * ERROR on database !DB_NAME!\n");
        fprintf(batch, "        )\n");
        fprintf(batch, "    )\n");
        fprintf(batch, ")\n");
    }
    
    fprintf(batch, "del \"%%TEMP%%\\db_list.txt\" > nul 2>&1\n");
    fprintf(batch, "del \"%%TEMP%%\\db_list_clean.txt\" > nul 2>&1\n");
    fclose(batch);
    if (flagverbose)
        myprintf("91958: Wait Execute %s\n",filebatch.c_str());
    waitexecutepadre(filebatch,"");
#else
	fprintf(batch, "#!/bin/bash\n\n");
	fprintf(batch, "MYSQL_HOST=\"%s\"\n", g_mysql_host.c_str());
	fprintf(batch, "MYSQL_USER=\"%s\"\n", g_mysql_user.c_str());
	fprintf(batch, "MYSQL_PASSWORD=\"%s\"\n", g_mysql_password.c_str());
	fprintf(batch, "MYSQL_PORT=%d\n", g_mysql_port);
	fprintf(batch, "ZPAQ_PATH=\"%s\"\n", extractfilepath(fullzpaqexename.c_str()).c_str());
	fprintf(batch, "BACKUP_DEST=\"%s\"\n", archive.c_str());
	fprintf(batch, "TEMP_DIR=\"/tmp\"\n\n");

	fprintf(batch, "echo \"Starting MySQL backup...\"\n\n");

	// Create the database list
	fprintf(batch, "%s -u${MYSQL_USER} -p${MYSQL_PASSWORD} -h${MYSQL_HOST} -P${MYSQL_PORT} -e \"SHOW DATABASES;\" > \"${TEMP_DIR}/db_list.txt\"\n\n", themysql.c_str());
	fprintf(batch, "grep -v \"Database\" \"${TEMP_DIR}/db_list.txt\" > \"${TEMP_DIR}/db_list_clean.txt\"\n\n");

	// Handling inclusion/exclusion filters with wildcard support
	if (!onlyfiles.empty()) 
	{
		// Inclusion mode: process only the databases that match the specified patterns
		fprintf(batch, "echo \"Processing only specified database patterns...\"\n");
		fprintf(batch, "while read DB_NAME; do\n");
		fprintf(batch, "    MATCH=0\n");

		// Check if the database matches one of the specified patterns
		for (size_t i=0;i<onlyfiles.size(); i++) 
		{
			fprintf(batch, "    if [[ \"$DB_NAME\" == \"%s\" ]]; then\n", onlyfiles[i].c_str()); // Added quotes
			fprintf(batch, "        MATCH=1\n");
			if (flagverbose)
				fprintf(batch, "        echo \"Matched database: $DB_NAME\"\n");
			fprintf(batch, "        %s -u${MYSQL_USER} -p${MYSQL_PASSWORD} -h${MYSQL_HOST} -P${MYSQL_PORT} --single-transaction --add-drop-database --databases ${DB_NAME} | \"${ZPAQ_PATH}/zpaqfranz\" a \"${BACKUP_DEST}\" \"${DB_NAME}.sql\" -stdin -silent %s\n", 
				themysqldump.c_str(), parametrini.c_str());
			fprintf(batch, "        if [ $? -eq 0 ]; then\n");
			fprintf(batch, "            echo \"* Backup ${DB_NAME} OK\"\n");
			fprintf(batch, "        else\n");
			fprintf(batch, "            echo \"* ERROR on database ${DB_NAME} (exit code: $?)\"\n");
			fprintf(batch, "        fi\n");
			fprintf(batch, "    fi\n"); // Removed the break
		}

		if (flagverbose)
			fprintf(batch, "    if [ $MATCH -eq 0 ]; then echo \"Skipping unmatched database: $DB_NAME\"; fi\n");
		fprintf(batch, "done < \"${TEMP_DIR}/db_list_clean.txt\"\n\n");
	} 
	else 
	{
		// Process all databases with possible exclusions based on patterns
		fprintf(batch, "# Esclusioni di sistema\n");
		fprintf(batch, "SYSTEM_DBS=\"information_schema performance_schema sys\"\n\n");

		fprintf(batch, "while read DB_NAME; do\n");
		fprintf(batch, "    EXCLUDE=0\n");

		// Exclusion of system databases
		fprintf(batch, "    for SYS_DB in $SYSTEM_DBS; do\n");
		fprintf(batch, "        if [ \"$DB_NAME\" = \"$SYS_DB\" ]; then\n");
		fprintf(batch, "            EXCLUDE=1\n");
		if (flagverbose)
			fprintf(batch, "            echo \"Skipping system database: $DB_NAME\"\n");
		fprintf(batch, "            break\n");
		fprintf(batch, "        fi\n");
		fprintf(batch, "    done\n\n");

		// Check custom exclusions with wildcards
		if (!notfiles.empty()) {
			fprintf(batch, "    if [ $EXCLUDE -eq 0 ]; then\n");
			for (size_t i = 0; i < notfiles.size(); i++) {
				fprintf(batch, "        if [[ \"$DB_NAME\" == \"%s\" ]]; then\n", notfiles[i].c_str()); // Added quotes
				fprintf(batch, "            EXCLUDE=1\n");
				if (flagverbose)
					fprintf(batch, "            echo \"Skipping excluded database: $DB_NAME\"\n");
				fprintf(batch, "            break\n");
				fprintf(batch, "        fi\n");
			}
			fprintf(batch, "    fi\n\n");
		}

		fprintf(batch, "    if [ $EXCLUDE -eq 0 ]; then\n");
		if (flagverbose)
			fprintf(batch, "        echo \"Processing database: $DB_NAME\"\n");
		fprintf(batch, "        %s -u${MYSQL_USER} -p${MYSQL_PASSWORD} -h${MYSQL_HOST} -P${MYSQL_PORT} --single-transaction --add-drop-database --databases ${DB_NAME} | \"${ZPAQ_PATH}/zpaqfranz\" a \"${BACKUP_DEST}\" \"${DB_NAME}.sql\" -stdin -silent %s\n", themysqldump.c_str(), parametrini.c_str());
		fprintf(batch, "        if [ $? -eq 0 ]; then\n");
		fprintf(batch, "            echo \"* Backup ${DB_NAME} OK\"\n");
		fprintf(batch, "        else\n");
		fprintf(batch, "            echo \"* ERROR on database ${DB_NAME} (exit code: $?)\"\n");
		fprintf(batch, "        fi\n");
		fprintf(batch, "    fi\n");
		fprintf(batch, "done < \"${TEMP_DIR}/db_list_clean.txt\"\n\n");
	}
	if (flagverbose)
		fprintf(batch, "# Pulisci i file temporanei\n");
	fprintf(batch, "rm -f \"${TEMP_DIR}/db_list.txt\" \"${TEMP_DIR}/db_list_clean.txt\"\n");
	fprintf(batch, "echo \"MySQL backup completed\"\n");
	fclose(batch);

	if (flagverbose)
		myprintf("01345: Linux exec %s\n",filebatch.c_str());
	if (chmod(filebatch.c_str(),0700)!=0)
	{
		myprintf("00343! error on chmod 700 on <<%s>>\n",filebatch.c_str());
		return 2;
	}
	exec_with_realtime_output(filebatch.c_str());

#endif

	int64_t postsize=prendidimensionefile(archive.c_str());
	
	if (postsize>presize)
		color_green();
	myprintf("99710: Archive size %s (%s) + %s => %s (%s)\n",migliaia(presize),tohuman(presize),migliaia2(postsize-presize),migliaia3(postsize),tohuman2(postsize));
	color_restore();
	if (!flagdebug)
		remove_temp_file(filebatch);

	return 0;
}
#endif ///NOSFTPEND

#ifdef ZPAQFULL ///NOSFTPSTART
#ifdef _WIN32
int Jidac::maxcpu(int i_percent)
{
    if (i_percent != 100)
        i_percent = 99;
    
    string filebatch = g_gettempdirectory() + "notb.bat";
    filebatch = nomefileseesistegia(filebatch);
    if (fileexists(filebatch))
        if (remove(filebatch.c_str()) != 0)
        {
            myprintf("91673! Highlander batch  %s\n", filebatch.c_str());
            return 2;
        }
    FILE* batch = fopen(filebatch.c_str(), "wb");
    if (batch == NULL)
    {
        myprintf("92672! cannot write on %s\n", filebatch.c_str());
        return 2;
    }
    
	// yep, this is just to fix "antisomething" power*ell, that trigger malware or whatever
	// faking optimizing compiler, just a bit
	string poua;
	poua+="p";
	if (poua=="something")
		poua+=" ";
	poua+="o";
	poua+="w";
	poua+="e";
	poua+="r";
	poua+="s";
	poua+="h";
	if (poua[2]=='Z')
		poua+="K";
	poua+="e";
	poua+="l";
	poua+="l";
	if (flagdebug)
		myprintf("88712: poua |%s|\n",poua.c_str());
	
    // Uso di -WindowStyle Hidden in tutti i comandi power*ell nel batch
    fprintf(batch, "@echo off\n");
    fprintf(batch, "%s -WindowStyle Hidden -Command \"$guid = (Get-CimInstance -ClassName Win32_PowerPlan -Namespace 'root\\cimv2\\power' | Where-Object { $_.IsActive -eq $true }).InstanceID.ToString().Split('{')[1].Split('}')[0]\"\n",poua.c_str());
    fprintf(batch, "%s -WindowStyle Hidden -Command \"powercfg -setacvalueindex scheme_current sub_processor PROCTHROTTLEMAX %d\"\n", poua.c_str(),i_percent);
    fprintf(batch, "%s -WindowStyle Hidden -Command \"powercfg -setdcvalueindex scheme_current sub_processor PROCTHROTTLEMAX %d\"\n", poua.c_str(),i_percent);
    fprintf(batch, "%s -WindowStyle Hidden -Command \"powercfg -setactive scheme_current\"\n",poua.c_str());
	fclose(batch);
 
	
    string runme = windowspowerme();
	if (!fileexists(runme))
	{
		myprintf("10044: cannot find runme %Z. Strange Windows?\n",runme.c_str());
		return 2;
	}
    // Add -WindowStyle Hidden to the main power*ell command
    string parms = "-WindowStyle Hidden -Command \"Start-Process '" + filebatch + "' -WindowStyle Hidden -Wait -Verb runAs\"";
    
    // Declaration of the ShExecInfo structure
    SHELLEXECUTEINFOA ShExecInfo;
    memset(&ShExecInfo, 0, sizeof(SHELLEXECUTEINFOA));
    ShExecInfo.cbSize = sizeof(SHELLEXECUTEINFOA);
    ShExecInfo.fMask = SEE_MASK_NOCLOSEPROCESS;
    ShExecInfo.lpFile = runme.c_str();
    ShExecInfo.lpParameters = parms.c_str();
    ShExecInfo.nShow = SW_HIDE;
    
    ShellExecuteExA(&ShExecInfo);
    WaitForSingleObject(ShExecInfo.hProcess, INFINITE);
    CloseHandle(ShExecInfo.hProcess);
    
    if (!flagdebug)
        remove_temp_file(filebatch);
    
    return 0;
}
#else
	
#if defined(__linux__)
int Jidac::maxcpu(int i_percent)
{
    if (i_percent != 100)
        i_percent = 99;
    
    string script_path = g_gettempdirectory() + "cpu_limit.sh";
    script_path = nomefileseesistegia(script_path);
    
    // Remove existing file if necessary
    if (fileexists(script_path))
        if (remove(script_path.c_str()) != 0)
        {
            myprintf("99673! Cannot remove existing script: %s\n", script_path.c_str());
            return 2;
        }
    
    // Create the shell script
    FILE* script = fopen(script_path.c_str(), "wb");
    if (script == NULL)
    {
        myprintf("91672! Cannot write script: %s\n", script_path.c_str());
        return 2;
    }
    
    // Script content to limit CPU in Linux
    fprintf(script, "#!/bin/bash\n\n");
    
    // Check if turbo boost is supported
    fprintf(script, "# Verifica supporto Turbo Boost\n");
    fprintf(script, "INTEL_PSTATE=\"/sys/devices/system/cpu/intel_pstate\"\n");
    fprintf(script, "CPU_BOOST=\"/sys/devices/system/cpu/cpufreq/boost\"\n");
    fprintf(script, "INTEL_BOOST=\"${INTEL_PSTATE}/no_turbo\"\n\n");
    
    // Set CPU limits using different possible ways
    fprintf(script, "# Funzione per limitare la CPU\n");
    fprintf(script, "limit_cpu() {\n");
    fprintf(script, "  if [ -d \"$INTEL_PSTATE\" ]; then\n");
    fprintf(script, "    # Intel pstate driver\n");
    if (i_percent == 100)
        fprintf(script, "    echo 0 |  tee \"$INTEL_BOOST\" > /dev/null\n");
    else
        fprintf(script, "    echo 1 |  tee \"$INTEL_BOOST\" > /dev/null\n");
    fprintf(script, "    RESULT=$?\n");
    fprintf(script, "    if [ $RESULT -eq 0 ]; then\n");
    fprintf(script, "      echo \"CPU Turbo Boost %s via intel_pstate\"\n", (i_percent == 100) ? "enabled" : "disabled");
    fprintf(script, "      return 0\n");
    fprintf(script, "    fi\n");
    fprintf(script, "  elif [ -f \"$CPU_BOOST\" ]; then\n");
    fprintf(script, "    # Generic CPU boost control\n");
    if (i_percent == 100)
        fprintf(script, "    echo 1 |  tee \"$CPU_BOOST\" > /dev/null\n");
    else
        fprintf(script, "    echo 0 |  tee \"$CPU_BOOST\" > /dev/null\n");
    fprintf(script, "    RESULT=$?\n");
    fprintf(script, "    if [ $RESULT -eq 0 ]; then\n");
    fprintf(script, "      echo \"CPU Turbo Boost %s via cpufreq\"\n", (i_percent == 100) ? "enabled" : "disabled");
    fprintf(script, "      return 0\n");
    fprintf(script, "    fi\n");
    fprintf(script, "  else\n");
    fprintf(script, "    # Fallback usando CPUfreq governor\n");
    fprintf(script, "    for cpu in /sys/devices/system/cpu/cpu[0-9]*; do\n");
    fprintf(script, "      if [ -f \"$cpu/cpufreq/scaling_governor\" ]; then\n");
    if (i_percent == 100)
        fprintf(script, "        echo \"performance\" |  tee \"$cpu/cpufreq/scaling_governor\" > /dev/null\n");
    else
        fprintf(script, "        echo \"powersave\" |  tee \"$cpu/cpufreq/scaling_governor\" > /dev/null\n");
    fprintf(script, "      fi\n");
    fprintf(script, "    done\n");
    fprintf(script, "    echo \"CPU at %d%% scaling governor\"\n", i_percent);
    fprintf(script, "    return 0\n");
    fprintf(script, "  fi\n");
    fprintf(script, "  return 1\n");
    fprintf(script, "}\n\n");
    
    // Execute the function and verify the result
    fprintf(script, "# Esegui la limitazione\n");
    fprintf(script, "limit_cpu\n");
    fprintf(script, "EXIT_CODE=$?\n\n");
    
    // Clean up and exit
    fprintf(script, "exit $EXIT_CODE\n");
    
    fclose(script);
    
    // Rendi lo script eseguibile
    chmod(script_path.c_str(), S_IRWXU);
    
    // Execute the script with administrator privileges using pkexec or sudo
    int result = 0;
    
    if (flagverbose)
        myprintf("93958: Executing CPU limit script %s\n", script_path.c_str());
    
    // First try with pkexec, if available (more user-friendly)
    string command = "pkexec " + script_path + " 2>/dev/null";
    result = system(command.c_str());
    
    // If pkexec fails or is not available, try with sudo
    if (result != 0) 
	{
		if (flagdebug)
			myprintf("10053! Try with sudo\n");
        command = "sudo " + script_path + " 2>/dev/null";;
        result = system(command.c_str());
    }
    if (result != 0) 
	{
		if (flagdebug)
			myprintf("10154! Try without sudo\n");
        command = script_path + " 2>/dev/null";;
        result = system(command.c_str());

    }
    
    // Cleanup
    if (!flagdebug)
        remove_temp_file(script_path);
    
    // Check the result
    if (result != 0) 
	{
        myprintf("99679! Failed to set CPU maximum to %d%%\n", i_percent);
        return 2;
    }
    
    return 0;
}
#else
int Jidac::maxcpu(int i_percent)
{
	if (i_percent!=-200)
		myprintf("10054! Sorry, cannot set maxcpu (not Windows, not Linux)\n");
	return 2;
}	
#endif
#endif


int Jidac::systemshutdown()
{
#ifdef _WIN32
	string runme=windowspowerme();
	
    if (!fileexists(runme))
    {
        myprintf("10045! Error: Power not found at %s\n", runme.c_str());
        // Fallback to cmd.exe shutdown
        string cmdPath = "c:\\Windows\\system32\\cmd.exe";
        if (fileexists(cmdPath))
        {
            string cmdParms = "/c shutdown /s /f /t 0";
            SHELLEXECUTEINFOA ShExecInfoCmd{};
            ShExecInfoCmd.cbSize = sizeof(SHELLEXECUTEINFOA);
            ShExecInfoCmd.fMask = SEE_MASK_NOCLOSEPROCESS;
            ShExecInfoCmd.lpFile = cmdPath.c_str();
            ShExecInfoCmd.lpParameters = cmdParms.c_str();
            ShExecInfoCmd.lpVerb = "runAs";
            ShExecInfoCmd.nShow = SW_HIDE;
            
            if (!ShellExecuteExA(&ShExecInfoCmd))
            {
                myprintf("10046! Error: Fallback CMD shutdown failed: %d\n", GetLastError());
                return 2;
            }
            
            WaitForSingleObject(ShExecInfoCmd.hProcess, 30000);
            CloseHandle(ShExecInfoCmd.hProcess);
            return 0;
        }
        return 2;
    }
    string parms = "-WindowStyle Hidden -Command \"Stop-Computer -Force\"";
    SHELLEXECUTEINFOA ShExecInfo{};
    ShExecInfo.cbSize = sizeof(SHELLEXECUTEINFOA);
    ShExecInfo.fMask = SEE_MASK_NOCLOSEPROCESS;
    ShExecInfo.lpFile = runme.c_str();
    ShExecInfo.lpParameters = parms.c_str();
    ShExecInfo.lpVerb = "runAs";
    ShExecInfo.nShow = SW_HIDE;
    if (!ShellExecuteExA(&ShExecInfo))
    {
        myprintf("99676! Error executing Power shutdown: %d\n", GetLastError());
        return 1;
    }
    DWORD waitResult = WaitForSingleObject(ShExecInfo.hProcess, 30000); // Timeout 30s
    if (waitResult != WAIT_OBJECT_0)
        myprintf("91677! Warning: Power shutdown process wait timed out or failed: %d\n", GetLastError());
    
    CloseHandle(ShExecInfo.hProcess);
    return 2;
#else
    // Unified Unix-like OS shutdown approach
    const char* os_name;// = "Unknown";
    const char* shutdown_cmd = NULL;
    const char* alt_shutdown_cmd = NULL;  // Alternative command if first fails
    int error_base = 99677; // Base for error codes

#if defined(__linux__)
    os_name = "Linux";
    shutdown_cmd = "shutdown -h now";
    alt_shutdown_cmd = "poweroff";
    error_base = 99678;
#elif defined(__FreeBSD__)
    os_name = "FreeBSD";
    shutdown_cmd = "shutdown -p now";
    alt_shutdown_cmd = "poweroff";
    error_base = 99682;
#elif defined(__APPLE__)
    os_name = "macOS";
    shutdown_cmd = "shutdown -h now";
    alt_shutdown_cmd = "halt";
    error_base = 99686;
#elif defined(__sun)
    os_name = "Solaris";
    shutdown_cmd = "poweroff";
    alt_shutdown_cmd = "halt";
    error_base = 99690;
#elif defined(__AIX__)
    os_name = "AIX";
    shutdown_cmd = "shutdown -F -h now";
    alt_shutdown_cmd = "halt";
    error_base = 99694;
#elif defined(__hpux) || defined(hpux) || defined(__HPUX__)
    os_name = "HP-UX";
    shutdown_cmd = "shutdown -h now";
    alt_shutdown_cmd = "halt";
    error_base = 99698;
#elif defined(__sgi) || defined(sgi) || defined(__IRIX__)
    os_name = "IRIX";
    shutdown_cmd = "halt";
    alt_shutdown_cmd = "poweroff";
    error_base = 99702;
#elif defined(_AIX)
    os_name = "AIX";
    shutdown_cmd = "shutdown -F -h now";
    alt_shutdown_cmd = "halt";
    error_base = 99706;
#elif defined(__DragonFly__)
    os_name = "DragonFly BSD";
    shutdown_cmd = "shutdown -p now";
    alt_shutdown_cmd = "halt -p";
    error_base = 99710;
#elif defined(__NetBSD__)
    os_name = "NetBSD";
    shutdown_cmd = "shutdown -p now";
    alt_shutdown_cmd = "halt -p";
    error_base = 99714;
#elif defined(__OpenBSD__)
    os_name = "OpenBSD";
    shutdown_cmd = "shutdown -p now";
    alt_shutdown_cmd = "halt -p";
    error_base = 99718;
#elif defined(__HAIKU__)
    os_name = "Haiku";
    shutdown_cmd = "shutdown";
    alt_shutdown_cmd = "shutdown -r"; // Haiku doesn't have a separate halt command
    error_base = 99722;
#else
	myprintf("99677! Error: Operating system not supported for shutdown\n");
    return 2;
#endif

    // Try direct shutdown
    int result = system(shutdown_cmd);
    if (result == 0) 
        return 0; // Success
    
    if (result == -1) 
        myprintf("%d! Error: %s: %s failed - fork error\n", error_base, os_name, shutdown_cmd);
    else
        myprintf("%d! Error: %s: %s failed with result %d\n", error_base, os_name, shutdown_cmd, result);
    
    // Try alternative command if available
    if (alt_shutdown_cmd != NULL)
    {
        myprintf("%d! Info: %s: Trying alternative command: %s\n", error_base + 5, os_name, alt_shutdown_cmd);
        result = system(alt_shutdown_cmd);
        if (result == 0)
            return 0; // Success with alternative command
    }
    
    // Check if sudo is available (alternative if 'command' is not present)
    bool sudo_available = false;
    if (system("command -v sudo >/dev/null 2>&1") == 0) 
    {
        sudo_available = true;
    } 
    else if (system("which sudo >/dev/null 2>&1") == 0) 
    { // Fallback for systems without 'command'
        sudo_available = true;
    }
    
    if (sudo_available) 
    {
        // Try primary command with sudo
        char sudo_cmd[256];
		if ((size_t)snprintf(sudo_cmd, sizeof(sudo_cmd), "sudo %s", shutdown_cmd) >= sizeof(sudo_cmd)) 
           myprintf("%d! Error: %s: Command too long for buffer\n", error_base + 4, os_name);
        else
        {
            result = system(sudo_cmd);
            if (result == 0) 
                return 0; // Success with sudo
                
            if (result == -1) 
                myprintf("%d! Error: %s: sudo %s failed - fork error\n", error_base + 1, os_name, shutdown_cmd);
            else 
                myprintf("%d! Error: %s: %s failed even with sudo: %d\n", error_base + 2, os_name, shutdown_cmd, result);
            
            // Try alternative command with sudo if primary failed
            if (alt_shutdown_cmd != NULL)
            {
                if ((size_t)snprintf(sudo_cmd, sizeof(sudo_cmd), "sudo %s", alt_shutdown_cmd) >= sizeof(sudo_cmd)) 
                {
                    myprintf("%d! Error: %s: Alternative command too long for buffer\n", error_base + 4, os_name);
                }
                else
                {
                    myprintf("%d! Info: %s: Trying alternative command with sudo: %s\n", error_base + 6, os_name, alt_shutdown_cmd);
                    result = system(sudo_cmd);
                    if (result == 0)
                        return 0; // Success with sudo alternative command
                }
            }
        }
    } 
    else 
        myprintf("%d! Error: %s: %s failed and sudo not available\n", error_base + 3, os_name, shutdown_cmd);
    
    // Last resort - try systemctl if available (mostly for modern Linux systems)
    if (system("command -v systemctl >/dev/null 2>&1") == 0 || 
        system("which systemctl >/dev/null 2>&1") == 0)
    {
        myprintf("%d! Info: %s: Trying systemctl poweroff\n", error_base + 7, os_name);
        result = system("systemctl poweroff");
        if (result == 0)
            return 0;
            
        if (sudo_available)
        {
            myprintf("%d! Info: %s: Trying sudo systemctl poweroff\n", error_base + 8, os_name);
            result = system("sudo systemctl poweroff");
            if (result == 0)
                return 0;
        }
    }
    
    myprintf("%d! Error: %s: All shutdown attempts failed\n", error_base + 9, os_name);
    return 2;
#endif
}
#endif ///NOSFTPEND

int Jidac::posix_count()
{
	int result=0;
	for (DTMap::iterator p=dt.begin(); p!=dt.end(); ++p)
		if (p->second.date && p->first!="")
		{
			string fn=rename(p->first);
			if ((!isads(fn)) && (!iszfs(fn)))
			{
				string 	myhashtype		="";
				string 	myhash			="";
				string 	mycrc32			="";
				int64_t	mycreationtime	=0;
				int64_t	myaccesstime	=0;
				bool	myisordered=false;
				int		myversion=0;
				franz_posix* myposix=NULL;
				bool	myisadded=false;

				decode_franz_block(false,p->second.franz_block,
					myhashtype,
					myhash,
					mycrc32,
					mycreationtime,
					myaccesstime,
					myisordered,
					myversion,
					myposix,myisadded);
					if (myposix)
						result++;
			}
		}
	return result;
}
string Jidac::find_unix_command(const string& i_thecommand)
{
#ifdef _WIN32
	if (flagdebug)
		if (i_thecommand=="quiet")
			myprintf("01773: be quiet\n");
    return "";
#else
    // Optimized path list for Unix-like systems, including non-Linux systems
    vector<string> common_paths;
    common_paths.push_back("/usr/bin/");
    common_paths.push_back("/usr/local/bin/");
    common_paths.push_back("/bin/");
    common_paths.push_back("/usr/sbin/");
    common_paths.push_back("/sbin/");
    common_paths.push_back("/usr/local/sbin/");
    common_paths.push_back("/opt/bin/");
    common_paths.push_back("/opt/local/bin/");
    common_paths.push_back("/usr/ucb/");      // For Solaris, HP-UX
    common_paths.push_back("/usr/xpg4/bin/"); // For POSIX compliance on Solaris

    // On non-Unix systems, return empty immediately
    for (unsigned int i = 0; i < common_paths.size(); ++i) 
    {
        string full_path = common_paths[i] + i_thecommand;
        if (fileexists(full_path.c_str())) 
		{
			myprintf("01795: Returning full_path <<%Z>>\n",full_path.c_str());
            return full_path;
		}
    }
    return "";
#endif
}



////////////////////////////////////////////////////////////////////////////////////////////////

#ifdef _WIN32

int Jidac::restoreimage()
{
	myprintf("02167: NTFS image restorer\n");

	if (archive=="")
	{
		myprintf("02165: You need to choose a .img\n");
		return 2;
	}
	
	string imagename=archive;
	string metadata=imagename+".dat";
	
	if (!fileexists(imagename.c_str()))
	{
		myprintf("02172: Image file not found %Z\n",imagename.c_str());
		return 2;
	}
	if (!fileexists(metadata.c_str()))
	{
		myprintf("02179: Metadata file not found %Z\n",metadata.c_str());
		return 2;
	}
	if (tofiles.size()!=1)
	{
		myprintf("02184: You must use -to something to restore\n");
		return 2;
	}
	
	string outputfile=tofiles[0];
	
	return ripristinantfs(imagename,outputfile);
}

#ifdef ZPAQ_VERSION
int Jidac::elaborantfs(char* buffer, size_t buffer_size)
#else
int elaborantfs(char* buffer, size_t buffer_size)
#endif
{
	ULONGLONG total_clusters = context.metadata.total_clusters;
    const size_t bitmap_offset = 2 * sizeof(ULONGLONG);
    
    // Returns 0 if we have finished all clusters
    if (context.current_cluster >= total_clusters) 
	{
		if (flagdebug6)
			myprintf("DEBUG: End of clusters reached. current=%s, total=%s\n", migliaia(context.current_cluster), migliaia(total_clusters));
        return 0;
    }

    // Find sequence of used contiguous clusters
    ULONGLONG start_cluster = context.current_cluster;
    ULONGLONG contiguous_clusters = 0;
    
    // Advance past any unused clusters first (iteratively, not recursively)
    bool found_used_cluster = false;
    while (context.current_cluster < total_clusters && !found_used_cluster) {
        ULONGLONG byte_index = context.current_cluster / 8;
        BYTE bit_mask = 1 << (context.current_cluster % 8);
        bool is_used = (context.bitmap_buffer[bitmap_offset + byte_index] & bit_mask) != 0;
   
		if (flagdebug6)
			myprintf("DEBUG: Checking cluster %s: %s\n", migliaia(context.current_cluster), is_used ? "used" : "not used");
               
        if (is_used) {
            found_used_cluster = true;
        } else {
            context.current_cluster++;
            if (context.current_cluster >= total_clusters) {
				if (flagdebug6)
					myprintf("DEBUG: End of clusters reached while searching for used clusters\n");
                return 0;
            }
        }
    }
    
    // Reset start_cluster to the first used cluster we found
    start_cluster = context.current_cluster;
    
    // Now count contiguous used clusters
    while (context.current_cluster < total_clusters) {
        ULONGLONG byte_index = context.current_cluster / 8;
        BYTE bit_mask = 1 << (context.current_cluster % 8);
        bool is_used = (context.bitmap_buffer[bitmap_offset + byte_index] & bit_mask) != 0;
        
        if (!is_used) break;
        contiguous_clusters++;
        context.current_cluster++;
    }
	if (flagdebug6)
		myprintf("DEBUG: Found %s contiguous clusters starting at %s\n", migliaia(contiguous_clusters), migliaia(start_cluster));

    // If we didn't find any used clusters, we should have already returned 0 above
    // This is just a safety check
    if (contiguous_clusters == 0) 
	{
		if (flagdebug6)
			myprintf("DEBUG: Error - No used clusters found but should have been caught above\n");
        return 0;
    }

    ULONGLONG read_size = contiguous_clusters * context.cluster_size;
    ULONGLONG offset = start_cluster * context.cluster_size;

	if (flagdebug6)
		myprintf("DEBUG: Reading %s bytes at offset %s\n",migliaia(read_size), migliaia(offset));

    // Position device pointer
    LARGE_INTEGER li;
    li.QuadPart = offset;
    if (!SetFilePointerEx(context.device, li, NULL, FILE_BEGIN)) 
	{
        DWORD error = GetLastError();
        myprintf("01992! cannot set file pointer at offset %s: %s (Error code: %d)\n", migliaia(offset), decodewinerror(error, "").c_str(), error);
        return -1;
    }

    // Read cluster
    DWORD bytes_to_read = static_cast<DWORD>(std::min(static_cast<ULONGLONG>(buffer_size), read_size));
    DWORD bytes_read = 0;
    
	if (flagdebug6)
		myprintf("DEBUG: About to read %s bytes\n", migliaia(bytes_to_read));
    
    BOOL read_result = ReadFile(context.device, buffer, bytes_to_read, &bytes_read, NULL);
    if (!read_result) 
	{
        DWORD error = GetLastError();
        myprintf("02079: READ FAIL at offset %s: %s (Error code: %d)\n", migliaia(offset), decodewinerror(error, "").c_str(), error);
        return -1;
    }
    
	if (flagdebug6)
		myprintf("DEBUG: Read result - requested: %s, actually read: %s\n", migliaia(bytes_to_read), migliaia(bytes_read));
    
    if (bytes_read == 0) 
	{
        // No data read, but it's not an error (endof file)
		if (flagdebug6)
			myprintf("DEBUG: No bytes read - likely at end of file\n");
        return 0;
    }

    // Write data to the backup file
    DWORD bytes_written = 0;
	if (flagdebug6)
	{
		myprintf("DEBUG: About to write %s bytes to backup file\n", migliaia(bytes_read));
		
		BOOL write_result = WriteFile(context.backup_file, buffer, bytes_read, &bytes_written, NULL);
		if (!write_result || bytes_written != bytes_read) {
			DWORD error = GetLastError();
			myprintf("02080: WRITE FAIL: %s (Error code: %d)\n", decodewinerror(error, "").c_str(), error);
			if (flagdebug6)
				myprintf("DEBUG: Bytes to write: %s, actually written: %s\n",migliaia(bytes_read), migliaia(bytes_written));
			return -1;
		}
		
	}
    // Record the processed clusters
    ULONGLONG current_image_offset = context.g_scritti;
    ULONGLONG clusters_in_read = (bytes_read + context.cluster_size - 1) / context.cluster_size;
    
    // Exact number of full clusters read
    clusters_in_read = std::min(clusters_in_read, contiguous_clusters);
    
	if (flagdebug6)
		myprintf("DEBUG: Processing %s clusters from this read\n", migliaia(clusters_in_read));
    
    ULONGLONG current_offset = 0;
    for (ULONGLONG i = 0; i < clusters_in_read; i++) {
        ULONGLONG current_cluster = start_cluster + i;
        ULONGLONG byte_index = current_cluster / 8;
        BYTE bit_mask = 1 << (current_cluster % 8);
        
        if (!(context.bitmap_buffer[bitmap_offset + byte_index] & bit_mask)) 
		{
            myprintf("02089! cluster %s marked as used but not in bitmap\n", migliaia(current_cluster));
            return -1;
        }

        ClusterData cluster_data;
        cluster_data.cluster_number = current_cluster;
        cluster_data.disk_offset = current_cluster * context.cluster_size;
        cluster_data.image_offset = current_image_offset + current_offset;
        
        // Calculate effective cluster size in this read
        DWORD cluster_bytes;
        if (i < clusters_in_read - 1 || bytes_read % context.cluster_size == 0) {
            cluster_bytes = static_cast<DWORD>(context.cluster_size);
        } else {
            cluster_bytes = bytes_read % static_cast<DWORD>(context.cluster_size);
        }
        
        cluster_bytes = std::min(cluster_bytes, static_cast<DWORD>(bytes_read - current_offset));
        cluster_data.size = cluster_bytes;
        
        context.clusters.push_back(cluster_data);
        current_offset += cluster_bytes;
        
        if (i == 0 || i == clusters_in_read - 1 || i % 1000 == 0) {
			if (flagdebug6)
				myprintf("DEBUG: Processed cluster %s (offset %s, size %s)\n", migliaia(current_cluster), migliaia(cluster_data.disk_offset), migliaia(cluster_bytes));
        }
    }

    // Update the counters
    context.total_done += bytes_read;
    context.g_scritti += bytes_read;
    context.processed_clusters += clusters_in_read;

    // If we haven't read all contiguous clusters, we adjust current_cluster
    if (clusters_in_read < contiguous_clusters) {
		if (flagdebug6)
			myprintf("DEBUG: Did not read all contiguous clusters. Adjusting current_cluster from %s to %s\n", migliaia(context.current_cluster), migliaia(start_cluster + clusters_in_read));
        context.current_cluster = start_cluster + clusters_in_read;
    }

	if (flagdebug6)
		myprintf("DEBUG: Elabora returning %s bytes read\n", migliaia(bytes_read));
    return bytes_read;

}


// Auxiliary function to count used clusters in the bitmap
ULONGLONG countUsedClusters(const std::vector<BYTE>& bitmap_buffer, ULONGLONG total_clusters) {
    ULONGLONG used_clusters = 0;
    const size_t bitmap_offset = 2 * sizeof(ULONGLONG);
    for (ULONGLONG cluster = 0; cluster < total_clusters; ++cluster) {
        ULONGLONG byte_index = cluster / 8;
        BYTE bit_mask = 1 << (cluster % 8);
        if (bitmap_buffer[bitmap_offset + byte_index] & bit_mask) {
            used_clusters++;
        }
    }
    return used_clusters;
}



#ifdef ZPAQ_VERSION
bool Jidac::preparantfs(const std::string& image_path, char drive_letter) 
#else
bool preparantfs(const std::string& image_path, char drive_letter) 
#endif
{
	drive_letter=toupper(drive_letter);
		
	if (drive_letter < 'A' || drive_letter > 'Z') 
	{
        myprintf("2482: Drive letter not valid, must be A..Z %c\n", drive_letter);
        return false;
    }
	
	context.clear();
	
	context.lettera				= drive_letter;
    context.device 				= INVALID_HANDLE_VALUE;
    context.backup_file 		= INVALID_HANDLE_VALUE;
    context.startstream 		= mtime();
    context.buffer_size 		= 1024 * 1024;
		
	if (flagverbose)
		myprintf("01984: CREATING IMAGE drive %c: to %s\n", drive_letter,image_path.c_str());
    
    char device_path[10];
    snprintf(device_path, sizeof(device_path), "\\\\.\\%c:", drive_letter);
    std::string letterpath = device_path;
    std::string root_path = std::string(1, drive_letter) + ":\\";
    std::string metadata_path = image_path + ".dat";

    // Check NTFS
    char fs_name[16];
    if (!GetVolumeInformationA(root_path.c_str(), NULL, 0, NULL, NULL, NULL, fs_name, sizeof(fs_name))) 
	{
        myprintf("01983! cannot get volume info: %s\n", decodewinerror(GetLastError(), root_path.c_str()).c_str());
        return false;
    }
    if (strcmp(fs_name, "NTFS") != 0) 
	{
        myprintf("01983! volume %c: is not NTFS (%s), FSCTL_GET_VOLUME_BITMAP not supported\n", drive_letter, fs_name);
        return false;
    }

    // Open device
    context.device = CreateFileA(letterpath.c_str(), GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, 0, NULL);
    if (context.device == INVALID_HANDLE_VALUE) 
	{
        myprintf("01987! cannot open drive %c error %s\n", drive_letter, decodewinerror(GetLastError(), letterpath.c_str()).c_str());
        return false;
    }

	if (flagdebug6)
	{
		// Create image file
		context.backup_file = CreateFileA(image_path.c_str(), GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
		if (context.backup_file == INVALID_HANDLE_VALUE) 
		{
			myprintf("01994! cannot create backup file %s: %s\n", image_path.c_str(), decodewinerror(GetLastError(), image_path.c_str()).c_str());
			CloseHandle(context.device);
			return false;
		}

		// Create metadata file
		context.metadata_file = CreateFileA(metadata_path.c_str(), GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
		if (context.metadata_file == INVALID_HANDLE_VALUE) 
		{
			myprintf("03013! cannot create metadata file: %s: %s\n", metadata_path.c_str(), decodewinerror(GetLastError(), metadata_path.c_str()).c_str());
			CloseHandle(context.device);
			CloseHandle(context.backup_file);
			return false;
		}
	}

    // Get volume dimensions
    PARTITION_INFORMATION_EX sizeofletter;
    memset(&sizeofletter, 0, sizeof(sizeofletter));
    DWORD dummy = 0;
    if (!DeviceIoControl(context.device, IOCTL_DISK_GET_PARTITION_INFO_EX, NULL, 0, &sizeofletter, sizeof(sizeofletter), &dummy, NULL)) 
	{
        myprintf("01989! cannot get partition info: %s\n", decodewinerror(GetLastError(), letterpath.c_str()).c_str());
        CloseHandle(context.device);
		if (flagdebug6)
		{
			CloseHandle(context.backup_file);
			CloseHandle(context.metadata_file);
		}
        return false;
    }
    ///ULONGLONG total_size = sizeofletter.PartitionLength.QuadPart;
	context.total_size = sizeofletter.PartitionLength.QuadPart;
    

    // Get cluster information
    DWORD sectors_per_cluster = 0;
    DWORD bytes_per_sector = 0;
    DWORD free_clusters = 0;
    DWORD disk_total_clusters = 0;
    if (!GetDiskFreeSpaceA(root_path.c_str(), &sectors_per_cluster, &bytes_per_sector, &free_clusters, &disk_total_clusters)) 
	{
        myprintf("01993! Cannot get disk free space: %s\n", decodewinerror(GetLastError(), root_path.c_str()).c_str());
        CloseHandle(context.device);
		if (flagdebug6)
		{
			CloseHandle(context.backup_file);
			CloseHandle(context.metadata_file);
		}
        return false;
    }
    context.cluster_size = sectors_per_cluster * bytes_per_sector;

    // Get bitmap
    STARTING_LCN_INPUT_BUFFER starting_lcn;
    starting_lcn.StartingLcn.QuadPart = 0;
    context.bitmap_buffer.resize(16 * 1024 * 1024);
    VOLUME_BITMAP_BUFFER* volume_bitmap = reinterpret_cast<VOLUME_BITMAP_BUFFER*>(context.bitmap_buffer.data());
    DWORD bytes_returned = 0;
    bool buffer_too_small = false;

    do 
	{
        if (!DeviceIoControl(context.device, FSCTL_GET_VOLUME_BITMAP, &starting_lcn, sizeof(starting_lcn), volume_bitmap, context.bitmap_buffer.size(), &bytes_returned, NULL)) {
            DWORD error = GetLastError();
            if (error == ERROR_INSUFFICIENT_BUFFER || error == ERROR_MORE_DATA) 
			{
                myprintf("01991$ Resizing bitmap buffer from %s to %s bytes (error %lu)\n", migliaia(context.bitmap_buffer.size()), migliaia2(context.bitmap_buffer.size() * 2), error);
                context.bitmap_buffer.resize(context.bitmap_buffer.size() * 2);
                volume_bitmap = reinterpret_cast<VOLUME_BITMAP_BUFFER*>(context.bitmap_buffer.data());
                buffer_too_small = true;
            } 
			else 
			{
                myprintf("01991! cannot get volume bitmap: %s\n", decodewinerror(error, letterpath.c_str()).c_str());
                CloseHandle(context.device);
				if (flagdebug6)
				{
					CloseHandle(context.backup_file);
					CloseHandle(context.metadata_file);
				}
                return false;
            }
        } 
		else 
		{
            buffer_too_small = false;
            myprintf("01991: Successfully retrieved NTFS bitmap, size %s bytes\n", migliaia(bytes_returned));
        }
    } while (buffer_too_small);

    ULONGLONG total_clusters = volume_bitmap->BitmapSize.QuadPart;
    
    // Count correctly used clusters
    ULONGLONG used_clusters = countUsedClusters(context.bitmap_buffer, total_clusters);
    myprintf("01992: Volume %s (%s), used %s clusters %s (used %s) of %s\n", 
	migliaia(context.total_size),
	tohuman(context.total_size),
	tohuman2(used_clusters*context.cluster_size),
	migliaia2(total_clusters), 
	migliaia3(used_clusters),
	tohuman3(context.cluster_size));

    // Initialize metadata
	memset((char*)&context.metadata, 0, sizeof(context.metadata));
    context.metadata.magic = METAMAGIC;
    context.metadata.version = 1;
    memset(context.metadata.filesystem, 0, sizeof(context.metadata.filesystem));
	
	size_t len = strlen(fs_name);
	if (len >= sizeof(context.metadata.filesystem)) 
		len = sizeof(context.metadata.filesystem) - 1;
	memcpy(context.metadata.filesystem, fs_name, len);
	context.metadata.filesystem[len] = '\0';


    ///strncpy(context.metadata.filesystem, fs_name, sizeof(context.metadata.filesystem) - 1);
    context.metadata.total_size = context.total_size;
    context.metadata.total_clusters = total_clusters;
    context.metadata.sectors_per_cluster = sectors_per_cluster;
    context.metadata.bytes_per_sector = bytes_per_sector;
    context.metadata.used_clusters = used_clusters;
    context.metadata.image_size = 0;

    // Write metadata header
    DWORD bytes_written = 0;
	if (flagdebug6)
	{
		if (!WriteFile(context.metadata_file, &context.metadata, sizeof(context.metadata), &bytes_written, NULL) || bytes_written != sizeof(context.metadata)) 
		{
			myprintf("01995! Failed to write metadata header: %s\n", decodewinerror(GetLastError(), metadata_path.c_str()).c_str());
			CloseHandle(context.device);
			if (flagdebug6)
			{
				CloseHandle(context.backup_file);
				CloseHandle(context.metadata_file);
			}
			return false;
		}
	}
    // Allocate buffer
    context.buffer = new BYTE[context.buffer_size];
    if (!context.buffer) 
	{
        myprintf("01995! Memory allocation failed\n");
        CloseHandle(context.device);
        if (flagdebug6)
		{
			CloseHandle(context.backup_file);
			CloseHandle(context.metadata_file);
		}
        return false;
    }
	if (flagdebug)
		myprintf("01993: Starting imaging process (used clusters only)...\n");
    return true;
}


#ifdef ZPAQ_VERSION
bool Jidac::chiudintfs() 
#else
bool chiudintfs() 
#endif
{
	if (flagdebug6)
	    myprintf("DEBUG: chiudintfs() called\n");

    // Update image size
    context.metadata.image_size = context.g_scritti;

    // Overwrite metadata header with updated image
    LARGE_INTEGER li;
    li.QuadPart = 0;
	if (flagdebug6)
		if (!SetFilePointerEx(context.metadata_file, li, NULL, FILE_BEGIN)) 
		{
			myprintf("01996! Failed to set file pointer for metadata: %s\n", decodewinerror(GetLastError(), "").c_str());
			return false;
		}

    DWORD bytes_written = 0;
	if (flagdebug6)
		if (!WriteFile(context.metadata_file, &context.metadata, sizeof(context.metadata), &bytes_written, NULL) || bytes_written != sizeof(context.metadata)) 
		{
			myprintf("01997! failed to write metadata header: %s\n", decodewinerror(GetLastError(), "").c_str());
			return false;
		}

    // Write number of clusters
    ULONGLONG cluster_count = context.clusters.size();
	if (flagdebug6)
	{
		if (!WriteFile(context.metadata_file, &cluster_count, sizeof(cluster_count), &bytes_written, NULL) || bytes_written != sizeof(cluster_count)) 
		{
			myprintf("01998! failed to write cluster count: %s\n", decodewinerror(GetLastError(), "").c_str());
			return false;
		}

		// Write ClusterData with buffering
		const DWORD buffer_size = 1024 * 1024; // 1 MB buffer
		std::vector<BYTE> buffer(buffer_size);
		DWORD buffer_pos = 0;

		for (const auto& cluster : context.clusters) {
			if (buffer_pos + sizeof(ClusterData) > buffer_size) {
				if (!WriteFile(context.metadata_file, buffer.data(), buffer_pos, &bytes_written, NULL) || bytes_written != buffer_pos) 
				{
					myprintf("01999! failed to write cluster data: %s\n", decodewinerror(GetLastError(), "").c_str());
					return false;
				}
				buffer_pos = 0;
			}
			memcpy(buffer.data() + buffer_pos, &cluster, sizeof(ClusterData));
			buffer_pos += sizeof(ClusterData);
		}

		// Write any remaining data in the buffer
		if (buffer_pos > 0) {
			if (!WriteFile(context.metadata_file, buffer.data(), buffer_pos, &bytes_written, NULL) || bytes_written != buffer_pos) {
				printf("02000! failed to write remaining cluster data: %s\n", decodewinerror(GetLastError(), "").c_str());
				return false;
			}
		}

		// Write bitmap
		ULONGLONG bitmap_size = (context.metadata.total_clusters + 7) / 8;
		myprintf("02098: Writing bitmap (%s bytes)\n", migliaia(bitmap_size));
		if (!WriteFile(context.metadata_file, &bitmap_size, sizeof(bitmap_size), &bytes_written, NULL) || bytes_written != sizeof(bitmap_size)) 
		{
			myprintf("02001! failed to write bitmap size: %s\n", decodewinerror(GetLastError(), "").c_str());
			return false;
		}
		if (!WriteFile(context.metadata_file, context.bitmap_buffer.data() + sizeof(ULONGLONG), bitmap_size, &bytes_written, NULL) || bytes_written != bitmap_size) 
		{
			myprintf("02002! failed to write bitmap: %s\n", decodewinerror(GetLastError(), "").c_str());
			return false;
		}


		FlushFileBuffers(context.metadata_file);
		FlushFileBuffers(context.backup_file);
	}

    myprintf("\n");

    if (flagdebug6)
		myprintf("DEBUG: chiudintfs() completed successfully\n");

    return true;

}

// Load metadata and cluster information
bool loadClusterData(const std::string& filename, ImageMetadata& metadata, 
                     std::vector<ClusterData>& clusters) {
    HANDLE infile = CreateFileA(filename.c_str(), GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, NULL);
    if (infile == INVALID_HANDLE_VALUE) 
	{
        myprintf("03007! Cannot open metadata file: %s: %s\n", filename.c_str(), decodewinerror(GetLastError(), filename.c_str()).c_str());
        return false;
    }

    DWORD bytes_read = 0;

    // Read the header
    if (!ReadFile(infile, &metadata, sizeof(metadata), &bytes_read, NULL) || bytes_read != sizeof(metadata)) 
	{
        myprintf("03008! Failed to read metadata header: %s\n", decodewinerror(GetLastError(), filename.c_str()).c_str());
        CloseHandle(infile);
        return false;
    }

    // Check the magic value
    if (metadata.magic != METAMAGIC) 
	{
        myprintf("03009! Invalid metadata file format\n");
        CloseHandle(infile);
        return false;
    }

    // Read the number of clusters
    ULONGLONG cluster_count = 0;
    if (!ReadFile(infile, &cluster_count, sizeof(cluster_count), &bytes_read, NULL) || bytes_read != sizeof(cluster_count)) 
	{
        myprintf("03010! Failed to read cluster count: %s\n", decodewinerror(GetLastError(), filename.c_str()).c_str());
        CloseHandle(infile);
        return false;
    }

    // Read the cluster data
    clusters.resize(cluster_count);
    const DWORD buffer_size = 1024 * 1024; // 1 MB buffer
    std::vector<BYTE> buffer(buffer_size);
    ULONGLONG clusters_to_read = cluster_count;
    size_t clusters_read = 0;

    while (clusters_to_read > 0) {
      DWORD clusters_in_buffer = (clusters_to_read < buffer_size / sizeof(ClusterData)) ? clusters_to_read : buffer_size / sizeof(ClusterData);
        DWORD bytes_to_read = clusters_in_buffer * sizeof(ClusterData);
        if (!ReadFile(infile, buffer.data(), bytes_to_read, &bytes_read, NULL) || bytes_read != bytes_to_read) 
		{
            myprintf("03011! Failed to read cluster data: %s\n", decodewinerror(GetLastError(), filename.c_str()).c_str());
            CloseHandle(infile);
            return false;
        }
        memcpy(clusters.data() + clusters_read, buffer.data(), bytes_to_read);
        clusters_read += clusters_in_buffer;
        clusters_to_read -= clusters_in_buffer;
    }

    CloseHandle(infile);
    myprintf("03012: Metadata loaded from %s (%s clusters)\n", filename.c_str(), migliaia(clusters.size()));
    return true;
}



bool leggibitmap(const std::string& metadata_path, std::vector<BYTE>& bitmap_buffer, ULONGLONG& bitmap_size) {
    HANDLE infile = CreateFileA(metadata_path.c_str(), GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, NULL);
    if (infile == INVALID_HANDLE_VALUE) 
	{
        myprintf("03003! cannot open metadata file: %s: %s\n", metadata_path.c_str(), decodewinerror(GetLastError(), metadata_path.c_str()).c_str());
        return false;
    }

    // Skip header and ClusterData
    LARGE_INTEGER li;
    li.QuadPart = sizeof(ImageMetadata);
    if (!SetFilePointerEx(infile, li, NULL, FILE_BEGIN)) 
	{
        myprintf("03014! failed to set file pointer: %s\n", decodewinerror(GetLastError(), metadata_path.c_str()).c_str());
        CloseHandle(infile);
        return false;
    }

    DWORD bytes_read = 0;
    ULONGLONG cluster_count = 0;
    if (!ReadFile(infile, &cluster_count, sizeof(cluster_count), &bytes_read, NULL) || bytes_read != sizeof(cluster_count)) 
	{
        myprintf("03015! failed to read cluster count: %s\n", decodewinerror(GetLastError(), metadata_path.c_str()).c_str());
        CloseHandle(infile);
        return false;
    }

    li.QuadPart = sizeof(ImageMetadata) + sizeof(cluster_count) + cluster_count * sizeof(ClusterData);
    if (!SetFilePointerEx(infile, li, NULL, FILE_BEGIN)) 
	{
        myprintf("03116! failed to set file pointer: %s\n", decodewinerror(GetLastError(), metadata_path.c_str()).c_str());
        CloseHandle(infile);
        return false;
    }

    // Read bitmap size
    if (!ReadFile(infile, &bitmap_size, sizeof(bitmap_size), &bytes_read, NULL) || bytes_read != sizeof(bitmap_size)) 
	{
        myprintf("03006! failed to read bitmap size: %s\n", decodewinerror(GetLastError(), metadata_path.c_str()).c_str());
        CloseHandle(infile);
        return false;
    }

    // Read the bitmap
    bitmap_buffer.resize(bitmap_size);
    if (!ReadFile(infile, bitmap_buffer.data(), bitmap_size, &bytes_read, NULL) || bytes_read != bitmap_size) 
	{
        myprintf("03007! failed to read bitmap: %s\n", decodewinerror(GetLastError(), metadata_path.c_str()).c_str());
        CloseHandle(infile);
        return false;
    }

    CloseHandle(infile);
    myprintf("03008: Bitmap loaded (%s bytes)\n", migliaia(bitmap_size));
    return true;
}

#ifdef ZPAQ_VERSION
bool Jidac::ripristinantfs(const std::string& image_path, const std::string& raw_path) 
#else
bool ripristinantfs(const std::string& image_path, const std::string& raw_path) 
#endif
{
	    ImageMetadata metadata;
    std::vector<ClusterData> clusters;
    std::vector<BYTE> bitmap_buffer;
    ULONGLONG bitmap_size = 0;

    std::string metadata_path = image_path + ".dat";

    // Load metadata
    if (!loadClusterData(metadata_path, metadata, clusters)) 
	{
        myprintf("03009! failed to load metadata\n");
        return false;
    }

    // Load bitmap
    if (!leggibitmap(metadata_path, bitmap_buffer, bitmap_size)) 
	{
        myprintf("03010! failed to load bitmap\n");
        return false;
    }

    // Open image file
    HANDLE image_file = CreateFileA(image_path.c_str(), GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, NULL);
    if (image_file == INVALID_HANDLE_VALUE) 
	{
        myprintf("03011! cannot open image file %s: %s\n", image_path.c_str(), decodewinerror(GetLastError(), image_path.c_str()).c_str());
        return false;
    }

    // Create raw file
    HANDLE raw_file = CreateFileA(raw_path.c_str(), GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
    if (raw_file == INVALID_HANDLE_VALUE) 
	{
        myprintf("03012! cannot create raw file %s: %s\n", raw_path.c_str(), decodewinerror(GetLastError(), raw_path.c_str()).c_str());
        CloseHandle(image_file);
        return false;
    }

    // Buffer for reading/writing
    const DWORD buffer_size = 1024 * 1024;
    BYTE* buffer = new BYTE[buffer_size];
    if (!buffer) 
	{
        myprintf("03014! memory allocation failed\n");
        CloseHandle(image_file);
        CloseHandle(raw_file);
        return false;
    }
    memset(buffer, 0, buffer_size); // For zeros

    ULONGLONG total_written = 0;
    ULONGLONG total_skipped = 0;
    ULONGLONG start_time = mtime();
    int last_time = -1;
    ULONGLONG cluster_size = metadata.sectors_per_cluster * metadata.bytes_per_sector;
    ULONGLONG total_clusters = metadata.total_clusters;

    // Create a map of cluster numbers to their corresponding ClusterData
    std::map<ULONGLONG, ClusterData> cluster_map;
    for (const auto& cluster_data : clusters) {
        cluster_map[cluster_data.cluster_number] = cluster_data;
    }

    myprintf("03050: Created cluster map with %s entries %s total clusters\n", migliaia(cluster_map.size()),migliaia2(total_clusters));

    // Process clusters in order
    for (ULONGLONG cluster = 0; cluster < total_clusters; cluster++) {
        auto cluster_it = cluster_map.find(cluster);
        bool has_data = cluster_it != cluster_map.end();

        ULONGLONG byte_index = cluster / 8;
        BYTE bit_mask = 1 << (cluster % 8);
        bool is_used = false;
        if (byte_index < bitmap_size) {
            is_used = (bitmap_buffer[byte_index] & bit_mask) != 0;
        }

        if (is_used != has_data) {
            is_used = has_data;
        }

        LARGE_INTEGER raw_position;
        raw_position.QuadPart = cluster * cluster_size;
        if (!SetFilePointerEx(raw_file, raw_position, NULL, FILE_BEGIN)) 
		{
            myprintf("03055! cannot set file pointer at raw offset %s: %s\n", migliaia(raw_position.QuadPart), decodewinerror(GetLastError(), "").c_str());
            delete[] buffer;
            CloseHandle(image_file);
            CloseHandle(raw_file);
            return false;
        }

        if (has_data) {
            const ClusterData& cluster_data = cluster_it->second;
            ULONGLONG read_size = cluster_data.size;
            ULONGLONG bytes_remaining = read_size;

            LARGE_INTEGER li;
            li.QuadPart = cluster_data.image_offset;
            if (!SetFilePointerEx(image_file, li, NULL, FILE_BEGIN)) 
			{
                myprintf("03014! cannot set file pointer at offset %s: %s\n", migliaia(cluster_data.image_offset), decodewinerror(GetLastError(), "").c_str());
                delete[] buffer;
                CloseHandle(image_file);
                CloseHandle(raw_file);
                return false;
            }

            while (bytes_remaining > 0) {
                DWORD chunk_size = static_cast<DWORD>(std::min(static_cast<ULONGLONG>(buffer_size), bytes_remaining));
                DWORD bytes_read = 0;
                if (!ReadFile(image_file, buffer, chunk_size, &bytes_read, NULL)) 
				{
                    myprintf("03015! read failed at offset %s: %s\n", migliaia(cluster_data.image_offset), decodewinerror(GetLastError(), "").c_str());
                    delete[] buffer;
                    CloseHandle(image_file);
                    CloseHandle(raw_file);
                    return false;
                }

                DWORD bytes_written = 0;
                if (!WriteFile(raw_file, buffer, bytes_read, &bytes_written, NULL) || bytes_written != bytes_read) 
				{
                    myprintf("03016! write failed: %s\n", decodewinerror(GetLastError(), "").c_str());
                    delete[] buffer;
                    CloseHandle(image_file);
                    CloseHandle(raw_file);
                    return false;
                }

                total_written += bytes_read;
                bytes_remaining -= bytes_read;

                if (bytes_read == 0) 
				{
                    myprintf("03052! Warning: Read 0 bytes at offset %s\n", migliaia(cluster_data.image_offset));
                    break;
                }
            }
        } else {
            ULONGLONG write_size = cluster_size;
            ULONGLONG bytes_remaining = write_size;

            while (bytes_remaining > 0) {
                DWORD chunk_size = static_cast<DWORD>(std::min(static_cast<ULONGLONG>(buffer_size), bytes_remaining));
                DWORD bytes_written = 0;
                if (!WriteFile(raw_file, buffer, chunk_size, &bytes_written, NULL) || bytes_written != chunk_size) 
				{
                    myprintf("03017! write zeros failed: %s\n", decodewinerror(GetLastError(), "").c_str());
                    delete[] buffer;
                    CloseHandle(image_file);
                    CloseHandle(raw_file);
                    return false;
                }

                total_skipped += chunk_size;
                bytes_remaining -= chunk_size;
            }
        }

		if (flagdebug6)
			if (cluster % 1000000 == 0 && cluster > 0) 
				myprintf("03053: Processed %s clusters (%s written, %s skipped)\n", migliaia(cluster), migliaia2(total_written), migliaia3(total_skipped));

        int seconds = (mtime() - start_time) / 1000;
        if (seconds != last_time) {
            float percentage = 100.0f * cluster / total_clusters;
            float speed = seconds > 0 ? (total_written + total_skipped) / seconds : 0;

            ULONGLONG eta_seconds = 0;
            if (speed > 0) {
                ULONGLONG clusters_remaining = total_clusters - cluster;
                ULONGLONG bytes_remaining_est = clusters_remaining * cluster_size;
                eta_seconds = bytes_remaining_est / speed;
            }

            int eta_hours = eta_seconds / 3600;
            int eta_minutes = (eta_seconds % 3600) / 60;
            int eta_secs = eta_seconds % 60;
			if (eta_hours>=99)
				eta_hours=99;
            myprintf("03018: Restoring %06.2f%% %12s+(0 %12s) @ %10s/s ETA %02d:%02d:%02d\r",
                   percentage, tohuman(total_written), tohuman2(total_skipped), tohuman3(speed),
                   eta_hours, eta_minutes, eta_secs);
            last_time = seconds;
            fflush(stdout);
        }
    }

    LARGE_INTEGER final_size;
    final_size.QuadPart = metadata.total_size;

    if (!SetFilePointerEx(raw_file, final_size, NULL, FILE_BEGIN) || !SetEndOfFile(raw_file))
	{		
        myprintf("03021! failed to set final file size: %s\n", decodewinerror(GetLastError(), "").c_str());
	}
	if (flagverbose)
		if ((total_written + total_skipped) != (metadata.total_size))
			myprintf("03019$ Final size mismatch: %s written + %s skipped != %s expected, fixed with SetEndOfFile\n",migliaia(total_written), migliaia2(total_skipped), migliaia3(metadata.total_size));


    delete[] buffer;
    CloseHandle(image_file);
    CloseHandle(raw_file);

    myprintf("\n");
	myprintf("03020: Restore completed: %s written, %s skipped\n", tohuman(total_written), tohuman2(total_skipped));
    return true;

}
#endif

#ifdef unix

#if defined(__NetBSD__) || defined(__DragonFly__)
#ifndef DIOCGMEDIASIZE
#define DIOCGMEDIASIZE _IOR('d', 129, off_t)
#endif
#else
#ifdef __linux__
    #include <sys/ioctl.h>
///    #include <linux/fs.h>
#elif defined(__FreeBSD__) || defined(__NetBSD__) || defined(__OpenBSD__) || defined(__DragonFly__)
    #include <sys/ioctl.h>
    #include <sys/disk.h>
    #ifdef __FreeBSD__
        #include <sys/disklabel.h>
    #endif
#elif defined(__APPLE__)
    #include <sys/ioctl.h>
    #include <sys/disk.h>
    #include <sys/mount.h>
#elif defined(__sun) || defined(__SVR4)
    #include <sys/ioctl.h>
    #include <sys/dkio.h>
    #include <sys/vtoc.h>
#elif defined(_AIX)
    #include <sys/ioctl.h>
    #include <sys/devinfo.h>
#elif defined(__hpux)
    #include <sys/ioctl.h>
    #include <sys/scsi.h>
#endif
#endif

#ifdef ESX
long long get_device_size_ioctl(int fd)
{
	(void)fd;
	return -1;
}
long long get_device_size_lseek(int fd) 
{
	(void)fd;
	return -1;
}
long long get_device_size(int fd) 
{
	(void)fd;
	return -1;
}

#else
long long get_device_size_ioctl(int fd) 
{
#ifdef __linux__
    // Linux: prova prima BLKGETSIZE64, poi BLKGETSIZE come fallback
    unsigned long long size64;
    if (ioctl(fd, BLKGETSIZE64, &size64) == 0) 
	{
        if (flagdebug) 
			myprintf("04375: Using Linux BLKGETSIZE64\n");
        return (long long)size64;
    }
    
    unsigned long sectors;
    if (ioctl(fd, BLKGETSIZE, &sectors) == 0) 
	{
        if (flagdebug) 
			myprintf("04382: Using Linux BLKGETSIZE (sectors * 512)\n");
        return (long long)sectors * 512;
    }
    
#elif defined(__FreeBSD__) || defined(__DragonFly__)
    // FreeBSD e DragonFly BSD
    off_t size;
    if (ioctl(fd, DIOCGMEDIASIZE, &size) == 0) 
	{
        if (flagdebug) 
			myprintf("04391: Using BSD DIOCGMEDIASIZE\n");
        return (long long)size;
    }
    
#elif defined(__NetBSD__) 
    // NetBSD
	/*
    struct disklabel dl;
    if (ioctl(fd, DIOCGDINFO, &dl) == 0) 
	{
        if (flagdebug) 
			myprintf("04400: Using BSD DIOCGDINFO (disklabel)\n");
        return (long long)dl.d_secsize * dl.d_secperunit;
    }
	*/
	return -1;
#elif defined(__OpenBSD__) 
    if (flagdebug)
		if (fd!=-200)
			myprintf("04410: OpenBSD: not good\n");
	return -1;
    
#elif defined(__APPLE__)
    // macOS
    uint64_t blocksize;
    uint64_t blockcount;
    
    if (ioctl(fd, DKIOCGETBLOCKSIZE, &blocksize) == 0 &&
        ioctl(fd, DKIOCGETBLOCKCOUNT, &blockcount) == 0) 
	{
        if (flagdebug) 
			myprintf("04411: Using macOS DKIOCGET* (blocksize=%s, blockcount=%s)\n", migliaia(blocksize), migliaia2(blockcount));
        return (long long)(blocksize * blockcount);
    }
    
#elif defined(__sun) || defined(__SVR4)
    // Solaris
	/*
    struct dk_minfo dkmp;
    if (ioctl(fd, DKIOCGMEDIAINFO, &dkmp) == 0) 
	{
        if (flagdebug) 
			myprintf("04422: Using Solaris DKIOCGMEDIAINFO\n");
        return (long long)(dkmp.dki_lbsize * dkmp.dki_capacity);
    }
    
    // Fallback per Solaris  vecchi
    struct vtoc vtoc;
    if (ioctl(fd, DKIOCGVTOC, &vtoc) == 0) 
	{
        if (flagdebug) 
			myprintf("04430: Using Solaris DKIOCGVTOC (fallback)\n");
        return (long long)vtoc.v_capacity * 512;
    }
	*/
	return -1;
    
#elif defined(_AIX)
    // AIX
    struct devinfo devinfo;
    if (ioctl(fd, IOCINFO, &devinfo) == 0) 
        if (devinfo.devtype == DD_DISK) 
		{
            if (flagdebug) 
				myprintf("04440: Using AIX IOCINFO\n");
            return (long long)devinfo.un.dk.bytpsec * devinfo.un.dk.numblks;
        }
    
#elif defined(__hpux)
    // HP-UX
    struct capacity cap;
    if (ioctl(fd, SIOC_CAPACITY, &cap) == 0) 
	{
        if (flagdebug) 
			myprintf("04450: Using HP-UX SIOC_CAPACITY\n");
        return (long long)cap.lba * 512;
    }
#endif

    if (flagdebug) 
		myprintf("04456: No ioctl method available for this platform\n");
    return -1;  // No ioctl method available or error
}
/**
 * Ottiene la dimensione usando lseek (metodo universale ma meno affidabile per dispositivi)
 */
long long get_device_size_lseek(int fd) 
{
    if (flagdebug) 
		myprintf("04466: Trying lseek method\n");
    
    off_t current_pos = lseek(fd, 0, SEEK_CUR);
    if (current_pos == -1) 
	{
        if (flagdebug) 
			myprintf("04471: lseek SEEK_CUR failed: %s\n", strerror(errno));
        return -1;
    }
    
    off_t size = lseek(fd, 0, SEEK_END);
    if (size == -1) 
	{
        if (flagdebug) 
			myprintf("04480: lseek SEEK_END failed: %s\n", strerror(errno));
        // Restore original position also in case of error
        lseek(fd, current_pos, SEEK_SET);
        return -1;
    }
    
    if (lseek(fd, current_pos, SEEK_SET) == -1) 
	{
        if (flagdebug) 
			myprintf("04488: lseek SEEK_SET failed: %s\n", strerror(errno));
        return -1;
    }
    
    if (flagdebug) 
		myprintf("04494: method successful, size=%s\n", migliaia(size));
	return (long long)size;
}

/**
 * Funzione principale che prova tutti i metodi disponibili
 */
long long get_device_size(int fd) 
{
    long long size;
    
    if (flagdebug) 
		myprintf("04506: Attempting to get device size for fd=%d\n", fd);
    
    // First try the platform-specific ioctl method
    size = get_device_size_ioctl(fd);
    if (size > 0) 
	{
        if (flagdebug) 
			myprintf("04513: ioctl method successful, size=%s bytes\n", migliaia(size));
        return size;
    }
    
    if (flagdebug) 
		myprintf("04518: ioctl method failed, trying lseek\n");
    
    // Fallback on lseek
    size = get_device_size_lseek(fd);
    if (size > 0) 
	{
        if (flagdebug) 
			myprintf("04525: lseek method successful, size=%s bytes\n", migliaia(size));
        return size;
    }
    
    if (flagdebug) 
		myprintf("04530: All methods failed\n");
    return -1;  // All methods failed
}
#endif

bool Jidac::preparadump(const std::string& image_path) 
{
#ifdef ESX
	(void)image_path;
#else
    if (image_path=="")
    {
        myprintf("04276: image_path empty\n");
        return false;
    }
    
    // Close any previous file descriptor
    if (g_device_fd != -1) 
    {
        close(g_device_fd);
        g_device_fd = -1;
    }
    
    // Open the device in read-only mode
    g_device_fd = open(image_path.c_str(), O_RDONLY);
    
    if (g_device_fd == -1) 
    {
        myprintf("04291: Error opening device %s: %s\n", image_path.c_str(), strerror(errno));
        return false;
    }
    
    // Get the device size
    int64_t device_size = get_device_size(g_device_fd);
	
    if (device_size == -1) 
	    myprintf("04300$ Warning: Cannot determine device size\n");
	else
		g_device_size=device_size;
		
    
    if (flagverbose)
        myprintf("04296: Device %s open\n", image_path.c_str());
#endif
    return true;
}



// Function to read data from the device
int Jidac::elaboradump(char* buffer, size_t buffer_size) 
{
#ifdef ESX
	(void)buffer;
	(void)buffer_size;
	return 0;
#else
    if (g_device_fd == -1) 
	{
        myprintf("04298! Error, device not open\n");
		seppuku();
		return -1;
    }
    
    if ((buffer == NULL) || (buffer_size == 0))
	{
        myprintf("04305: Error, buffer kaputt\n");
		seppuku();
		return -1;
    }
    
    ssize_t bytes_read = read(g_device_fd, buffer, buffer_size);
    
    if (bytes_read == -1) 
	{
        myprintf("04314: Error reading from device: %s\n", strerror(errno));
        return -1;
    }
    
    // Returns the number of bytes read (0 if EOF)
    return (int)bytes_read;
#endif
}

// Function to close the device
bool Jidac::chiudidump() 
{
#ifndef ESX
    if (g_device_fd != -1) 
	{
        if (close(g_device_fd) == -1) 
		{
            myprintf("0423: Error closing: %s\n", strerror(errno));
            g_device_fd = -1;
            return false;
        }
        g_device_fd = -1;
        myprintf("04238: Device closed (this is good)\n");
        return true;
    }
#endif
    return true;
}
#endif

const char* ascii_patterns[95][7] = {
    // 32: space
    {"       ", "       ", "       ", "       ", "       ", "       ", "       "},
    // 33: !
    {"   ██  ", "   ██  ", "   ██  ", "   ██  ", "       ", "   ██  ", "   ██  "},
    // 34: "
    {" ██ ██ ", " ██ ██ ", " ██ ██ ", "       ", "       ", "       ", "       "},
    // 35: #
    {" ██ ██ ", " ██ ██ ", "███████", " ██ ██ ", "███████", " ██ ██ ", " ██ ██ "},
    // 36: $
    {"  ███  ", " █████ ", "██     ", " █████ ", "     ██", " █████ ", "  ███  "},
    // 37: %
    {"██   ██", "██  ██ ", "   ██  ", "  ██   ", " ██  ██", "██   ██", "       "},
    // 38: &
    {" ████  ", "██  ██ ", " ████  ", " ██ ██ ", "██ ██ █", "██  ██ ", " ██ ███"},
    // 39: '
    {"   ██  ", "   ██  ", "   ██  ", "       ", "       ", "       ", "       "},
    // 40: (
    {"    ██ ", "   ██  ", "  ██   ", "  ██   ", "  ██   ", "   ██  ", "    ██ "},
    // 41: )
    {" ██    ", "  ██   ", "   ██  ", "   ██  ", "   ██  ", "  ██   ", " ██    "},
    // 42: *
    {"       ", " ██ ██ ", "  ███  ", "███████", "  ███  ", " ██ ██ ", "       "},
    // 43: +
    {"       ", "   ██  ", "   ██  ", "███████", "   ██  ", "   ██  ", "       "},
    // 44: ,
    {"       ", "       ", "       ", "       ", "   ██  ", "   ██  ", "  ██   "},
    // 45: -
    {"       ", "       ", "       ", "███████", "       ", "       ", "       "},
    // 46: .
    {"       ", "       ", "       ", "       ", "       ", "   ██  ", "   ██  "},
    // 47: /
    {"      █", "     ██", "    ██ ", "   ██  ", "  ██   ", " ██    ", "██     "},
    // 48-57: 0-9
    {" █████ ", "██   ██", "██  ███", "██ █ ██", "███  ██", "██   ██", " █████ "},
    {"   ██  ", "  ███  ", "   ██  ", "   ██  ", "   ██  ", "   ██  ", " ██████"},
    {" █████ ", "██   ██", "     ██", "   ███ ", "  ██   ", " ██    ", "███████"},
    {" █████ ", "██   ██", "     ██", "  ████ ", "     ██", "██   ██", " █████ "},
    {"██   ██", "██   ██", "██   ██", "███████", "     ██", "     ██", "     ██"},
    {"███████", "██     ", "██     ", "██████ ", "     ██", "██   ██", " █████ "},
    {" █████ ", "██   ██", "██     ", "██████ ", "██   ██", "██   ██", " █████ "},
    {"███████", "     ██", "    ██ ", "   ██  ", "  ██   ", " ██    ", "██     "},
    {" █████ ", "██   ██", "██   ██", " █████ ", "██   ██", "██   ██", " █████ "},
    {" █████ ", "██   ██", "██   ██", " ██████", "     ██", "██   ██", " █████ "},
    // 58: :
    {"       ", "   ██  ", "   ██  ", "       ", "   ██  ", "   ██  ", "       "},
    // 59: ;
    {"       ", "   ██  ", "   ██  ", "       ", "   ██  ", "   ██  ", "  ██   "},
    // 60: <
    {"     ██", "    ██ ", "   ██  ", "  ██   ", "   ██  ", "    ██ ", "     ██"},
    // 61: =
    {"       ", "       ", "███████", "       ", "███████", "       ", "       "},
    // 62: >
    {"██     ", " ██    ", "  ██   ", "   ██  ", "  ██   ", " ██    ", "██     "},
    // 63: ?
    {" █████ ", "██   ██", "    ██ ", "   ██  ", "  ██   ", "       ", "  ██   "},
    // 64: @
    {" █████ ", "██   ██", "██ ████", "██ ████", "██ ████", "██     ", " █████ "},
    // 65-90: A-Z
    {" █████ ", "██   ██", "██   ██", "███████", "██   ██", "██   ██", "██   ██"},
    {"██████ ", "██   ██", "██   ██", "██████ ", "██   ██", "██   ██", "██████ "},
    {" █████ ", "██   ██", "██     ", "██     ", "██     ", "██   ██", " █████ "},
    {"██████ ", "██   ██", "██   ██", "██   ██", "██   ██", "██   ██", "██████ "},
    {"███████", "██     ", "██     ", "██████ ", "██     ", "██     ", "███████"},
    {"███████", "██     ", "██     ", "██████ ", "██     ", "██     ", "██     "},
    {" █████ ", "██   ██", "██     ", "██ ████", "██   ██", "██   ██", " █████ "},
    {"██   ██", "██   ██", "██   ██", "███████", "██   ██", "██   ██", "██   ██"},
    {"███████", "   ██  ", "   ██  ", "   ██  ", "   ██  ", "   ██  ", "███████"},
    {"███████", "   ██  ", "   ██  ", "   ██  ", "   ██  ", "██ ██  ", " █████ "},
    {"██   ██", "██  ██ ", "██ ██  ", "████   ", "██ ██  ", "██  ██ ", "██   ██"},
    {"██     ", "██     ", "██     ", "██     ", "██     ", "██     ", "███████"},
    {"██   ██", "███ ███", "██ █ ██", "██   ██", "██   ██", "██   ██", "██   ██"},
    {"██   ██", "███  ██", "██ █ ██", "██  ███", "██   ██", "██   ██", "██   ██"},
    {" █████ ", "██   ██", "██   ██", "██   ██", "██   ██", "██   ██", " █████ "},
    {"██████ ", "██   ██", "██   ██", "██████ ", "██     ", "██     ", "██     "},
    {" █████ ", "██   ██", "██   ██", "██   ██", "██ █ ██", "██  ███", " ██████"},
    {"██████ ", "██   ██", "██   ██", "██████ ", "██  ██ ", "██   ██", "██   ██"},
    {" █████ ", "██   ██", "██     ", " █████ ", "     ██", "██   ██", " █████ "},
    {"███████", "   ██  ", "   ██  ", "   ██  ", "   ██  ", "   ██  ", "   ██  "},
    {"██   ██", "██   ██", "██   ██", "██   ██", "██   ██", "██   ██", " █████ "},
    {"██   ██", "██   ██", "██   ██", "██   ██", "██   ██", " ██ ██ ", "  ███  "},
    {"██   ██", "██   ██", "██   ██", "██ █ ██", "██ █ ██", "███ ███", "██   ██"},
    {"██   ██", " ██ ██ ", "  ███  ", "   █   ", "  ███  ", " ██ ██ ", "██   ██"},
    {"██   ██", " ██ ██ ", "  ███  ", "   ██  ", "   ██  ", "   ██  ", "   ██  "},
    {"███████", "     ██", "    ██ ", "   ██  ", "  ██   ", " ██    ", "███████"},
    // 91: [
    {" █████ ", " ██    ", " ██    ", " ██    ", " ██    ", " ██    ", " █████ "},
    // 92: backslash
    {"██     ", " ██    ", "  ██   ", "   ██  ", "    ██ ", "     ██", "      █"},
    // 93: ]
    {" █████ ", "    ██ ", "    ██ ", "    ██ ", "    ██ ", "    ██ ", " █████ "},
    // 94: ^
    {"   ██  ", "  ████ ", " ██  ██", "       ", "       ", "       ", "       "},
    // 95: _
    {"       ", "       ", "       ", "       ", "       ", "       ", "███████"},
    // 96: `
    {"  ██   ", "   ██  ", "       ", "       ", "       ", "       ", "       "},
    // 97-122: a-z
    {"       ", "       ", " █████ ", "     ██", " ██████", "██   ██", " ██████"},
    {"██     ", "██     ", "██████ ", "██   ██", "██   ██", "██   ██", "██████ "},
    {"       ", "       ", " █████ ", "██     ", "██     ", "██   ██", " █████ "},
    {"     ██", "     ██", " ██████", "██   ██", "██   ██", "██   ██", " ██████"},
    {"       ", "       ", " █████ ", "██   ██", "███████", "██     ", " █████ "},
    {"  ████ ", " ██    ", " ██    ", "██████ ", " ██    ", " ██    ", " ██    "},
    {"       ", "       ", " ██████", "██   ██", "██   ██", " ██████", "     ██"},
    {"██     ", "██     ", "██████ ", "██   ██", "██   ██", "██   ██", "██   ██"},
    {"   ██  ", "       ", "  ███  ", "   ██  ", "   ██  ", "   ██  ", " ██████"},
    {"   ██  ", "       ", "  ███  ", "   ██  ", "   ██  ", "   ██  ", "██ ██  "},
    {"██     ", "██     ", "██  ██ ", "██ ██  ", "████   ", "██ ██  ", "██  ██ "},
    {"  ███  ", "   ██  ", "   ██  ", "   ██  ", "   ██  ", "   ██  ", " ██████"},
    {"       ", "       ", "██ ██  ", "██████ ", "██ █ ██", "██   ██", "██   ██"},
    {"       ", "       ", "██████ ", "██   ██", "██   ██", "██   ██", "██   ██"},
    {"       ", "       ", " █████ ", "██   ██", "██   ██", "██   ██", " █████ "},
    {"       ", "       ", "██████ ", "██   ██", "██   ██", "██████ ", "██     "},
    {"       ", "       ", " ██████", "██   ██", "██   ██", " ██████", "     ██"},
    {"       ", "       ", "██ ███ ", "███    ", "██     ", "██     ", "██     "},
    {"       ", "       ", " █████ ", "██     ", " █████ ", "     ██", " █████ "},
    {" ██    ", " ██    ", "██████ ", " ██    ", " ██    ", " ██    ", "  ████ "},
    {"       ", "       ", "██   ██", "██   ██", "██   ██", "██   ██", " ██████"},
    {"       ", "       ", "██   ██", "██   ██", "██   ██", " ██ ██ ", "  ███  "},
    {"       ", "       ", "██   ██", "██   ██", "██ █ ██", "███████", "██   ██"},
    {"       ", "       ", "██   ██", " ██ ██ ", "  ███  ", " ██ ██ ", "██   ██"},
    {"       ", "       ", "██   ██", "██   ██", " ██████", "     ██", " █████ "},
    {"       ", "       ", "███████", "    ██ ", "   ██  ", "  ██   ", "███████"},
    // 123: {
    {"   ████", "  ██   ", "  ██   ", " ██    ", "  ██   ", "  ██   ", "   ████"},
    // 124: |
    {"   ██  ", "   ██  ", "   ██  ", "   ██  ", "   ██  ", "   ██  ", "   ██  "},
    // 125: }
    {"████   ", "   ██  ", "   ██  ", "    ██ ", "   ██  ", "   ██  ", "████   "},
    // 126: ~
    {"       ", " ██  ██", "████ ██", "██ ████", "██  ██ ", "       ", "       "}
};

int Jidac::getCharIndex(char c) 
{
    // Printable ASCII characters from 32 to 126
    if (c >= 32 && c <= 126) {
        return c - 32;  // Convert to index 0-94
    }
    return -1;  // unsupported character
}

void Jidac::printDigitalString(const char* inputString) 
{
    
    int charCount = 0;
    int charIndices[1000];
    
    // Extract the supported characters from the string
    for (int i = 0; inputString[i] != '\0' && charCount < 1000; i++) {
        int index = getCharIndex(inputString[i]);
        if (index >= 0) {
            charIndices[charCount] = index;
            charCount++;
        }
    }
    
    if (charCount == 0) {
        printf("Nessun carattere valido trovato.\n");
        return;
    }
    
    // Print line by line
    for (int row = 0; row < 7; row++) {
        for (int charIdx = 0; charIdx < charCount; charIdx++) {
            printf("%s", ascii_patterns[charIndices[charIdx]][row]);
            if (charIdx < charCount - 1) {
                printf(" ");
            }
        }
        printf("\n");
    }
}

#ifdef ZPAQFULL ///NOSFTPSTART
#ifdef SFTP

///fima2
void* download_worker_thread(void* arg) 
{
    sftp_downloadthreaddata* data = (sftp_downloadthreaddata*)arg;
    
    if (flagdebug) 
		myprintf("93297: debug Download Thread %d started\n", data->thread_id);
    
    // Initialize the thread's progress data
    pthread_mutex_lock(data->progress_mutex);
    data->thread_progress->thread_id 				= data->thread_id;
    data->thread_progress->current_file 			= "";
    data->thread_progress->current_file_size 		= 0;
    data->thread_progress->thread_bytes_processed 	= 0;
    data->thread_progress->thread_files_processed 	= 0;
    data->thread_progress->thread_start_time 		= mtime();
    data->thread_progress->is_active 				= true;
    data->thread_progress->status 					= "starting";
    pthread_mutex_unlock(data->progress_mutex);
    
    // Create a separate SFTP connection for this thread
    zpaqfranzsftp2 thread_sftp;
    
    // Copy connection settings from the main thread
	if (g_sftp_key!="")
	thread_sftp.setConnectionSSH(data->sftp_instance->getHost(), 
                             data->sftp_instance->getPort(),
                             data->sftp_instance->getUsername(),
                             data->sftp_instance->getKey());
 	else
    thread_sftp.setConnection(data->sftp_instance->getHost(), 
                             data->sftp_instance->getPort(),
                             data->sftp_instance->getUsername(),
                             data->sftp_instance->getPassword());
    
    if (!thread_sftp.connect()) 
	{
		myprintf("93332! ERROR Download Thread %d: SFTP KAPUTT\n", data->thread_id);
        
        pthread_mutex_lock(data->progress_mutex);
        data->thread_progress->status 		= "error";
        data->thread_progress->is_active 	= false;
        pthread_mutex_unlock(data->progress_mutex);
        
        pthread_mutex_lock(data->result_mutex);
        *(data->success_flag) 				= false;
        pthread_mutex_unlock(data->result_mutex);
        return NULL;
    }
    
    while (true) 
	{
        sftpget3* task 	= NULL;
        bool has_task 	= false;
        
        // Update status: waiting
        pthread_mutex_lock(data->progress_mutex);
        data->thread_progress->status = "WAIT";
        pthread_mutex_unlock(data->progress_mutex);
        
        // Take a task from the queue
        pthread_mutex_lock(data->queue_mutex);
        
        while (data->task_queue->empty() && !*(data->all_tasks_added)) 
		    pthread_cond_wait(data->queue_cond, data->queue_mutex);
        
        if (!data->task_queue->empty()) 
		{
            task 		= data->task_queue->front();
            data->task_queue->pop();
            has_task 	= true;
        } 
		else 
		if (*(data->all_tasks_added)) 
		{
            pthread_mutex_unlock(data->queue_mutex);
            break;
        }
        
        pthread_mutex_unlock(data->queue_mutex);
        
        if (has_task) 
		{
            // Update status: downloading
            pthread_mutex_lock(data->progress_mutex);
            data->thread_progress->status 		= "DOWN";
            data->thread_progress->current_file = task->i_name;
            pthread_mutex_unlock(data->progress_mutex);
            
            if (flagdebug) 
				myprintf("93370: debug Thread %d: download %s\n", data->thread_id, task->i_name.c_str());
            
            // First get the remote file size
            int64_t remote_size = thread_sftp.remotegetfilesize(task->i_name);
            if (remote_size < 0) 
			{
				myprintf("93376! Thread %d: cannot get size for %s\n", data->thread_id, task->i_name.c_str());
                
                pthread_mutex_lock(data->progress_mutex);
                data->thread_progress->status = "error";
                pthread_mutex_unlock(data->progress_mutex);
                
                pthread_mutex_lock(data->result_mutex);
                *(data->success_flag) = false;
                pthread_mutex_unlock(data->result_mutex);
                continue;
            }
            
            // Update current file size
            pthread_mutex_lock(data->progress_mutex);
            data->thread_progress->current_file_size = remote_size;
            pthread_mutex_unlock(data->progress_mutex);
            
            task->o_size = remote_size;
            task->o_hash = "QUICK";
            
            // Perform the download of the 3 chunks
            bool download_result = thread_sftp.down3(remote_size, task->i_name, 
                                                    task->i_file1, task->i_file2, task->i_file3);
            
            pthread_mutex_lock(data->result_mutex);
            if (!download_result) 
			{
                *(data->success_flag) = false;
            	myprintf("93404! Thread %d: error download %s\n", data->thread_id, task->i_name.c_str());
                
                pthread_mutex_lock(data->progress_mutex);
                data->thread_progress->status = "error";
                pthread_mutex_unlock(data->progress_mutex);
            } 
			else 
			{
                (*(data->total_files_processed))++;
                (*(data->total_bytes_processed)) += remote_size;
                
                // Update thread statistics
                pthread_mutex_lock(data->progress_mutex);
                data->thread_progress->thread_files_processed++;
                data->thread_progress->thread_bytes_processed += remote_size;
                data->thread_progress->status = "DONE";
                pthread_mutex_unlock(data->progress_mutex);
            }
            
            (*(data->completed_tasks))++;
            if (flagdebug)
				myprintf("93424: Thread %02d: completed %s (%21K bytes) - Progress: %08d/%08d\n", 
                                 data->thread_id, task->i_name.c_str(), remote_size,
                                 *(data->completed_tasks), data->total_tasks);
            pthread_mutex_unlock(data->result_mutex);
        }
        
        // Check if we need to stop for errors
        pthread_mutex_lock(data->result_mutex);
        bool should_stop = *(data->stop_threads);
        pthread_mutex_unlock(data->result_mutex);
        
        if (should_stop) 
		{
            if (flagdebug) 
				myprintf("93438: Download Thread %d: stopped by errors\n", data->thread_id);
            break;
        }
    }
    
    // Mark the thread as not active
    pthread_mutex_lock(data->progress_mutex);
    data->thread_progress->is_active = false;
    data->thread_progress->status = "finished";
    pthread_mutex_unlock(data->progress_mutex);
    if (flagdebug)
		myprintf("93450: Download Thread %d completed\n", data->thread_id);
    return NULL;
}

void sftp_display_progress_down_parallelo(const std::vector<sftp_threadprogressdata>& thread_progress, int total_files, int completed_files, int64_t total_bytes, int64_t start_time, bool verbose, int max_display_threads) 
{
    int64_t current_time 	= mtime(); 
    double elapsed 			= (current_time - start_time) / 1000.0; 
    double progress_percent = (double)completed_files / total_files * 100.0; 
    double file_rate 		= (elapsed > 0) ? completed_files / elapsed : 0; 
    double byte_rate 		= (elapsed > 0) ? total_bytes / elapsed : 0; 
    double eta 				= (file_rate > 0) ? (total_files - completed_files) / file_rate : 0;
    
    int eta_hours 			= (int)(eta / 3600); 
    int eta_minutes 		= (int)((eta - eta_hours * 3600) / 60); 
    int eta_seconds 		= (int)(eta - eta_hours * 3600 - eta_minutes * 60);
    
    if (!verbose) 
	{ 
        // Simple mode: a single line
        clear_line(); 
        myprintf("42875: Download parallel (%5.1f%%) ETA: %02d:%02d:%02d Files: %d/%d @%5.2f file/s Data: %s @%s/s", 
                 progress_percent, eta_hours, eta_minutes, eta_seconds, completed_files, total_files, 
                 file_rate, tohuman(total_bytes), tohuman2((int64_t)byte_rate)); 
        fflush(stdout); 
    } 
	else 
	{ 
        // Verbose mode: global line + thread details
        
        // Global line
        clear_line(); 
        color_green(); 
	    myprintf("GLOBAL: (%5.1f%%) ETA: %02d:%02d:%02d  [%12s] @%12s/s | %08d/%08d @%5.2f file/s\n", 
                 progress_percent, eta_hours, eta_minutes, eta_seconds, 
				 tohuman(total_bytes),tohuman2((int64_t)byte_rate),
				 completed_files, total_files, 
                 file_rate); 
        color_restore(); 
        
        // Details per thread (limited by the maximum visible number) 
        int threads_to_show = std::min(max_display_threads, (int)thread_progress.size());
        
        for (int i = 0; i < threads_to_show; i++) 
		{ 
            const sftp_threadprogressdata& tp = thread_progress[i];
            
            clear_line();
            if (tp.is_active) 
			{ 
                double thread_elapsed 	= (current_time - tp.thread_start_time) / 1000.0; 
                double thread_file_rate = (thread_elapsed > 0) ? tp.thread_files_processed / thread_elapsed : 0; 
                double thread_byte_rate = (thread_elapsed > 0) ? tp.thread_bytes_processed / thread_elapsed : 0;
                
                std::string filename = tp.current_file; 
                if (filename.length() > 33) 
				    filename = "..." + filename.substr(filename.length() - 30); 
                color_cyan();
                printf("T%02d: %-5s # %08d @%4.1f f/s [%12s] @%12s/s | %s", 
                         tp.thread_id, tp.status.c_str(), tp.thread_files_processed, thread_file_rate, 
                         tohuman(tp.thread_bytes_processed), tohuman((int64_t)thread_byte_rate), filename.c_str()); 
            } 
			else 
			{ 
                // Thread finished: calculate total time and average speed
                double thread_total_time 	= (mtime() - tp.thread_start_time) / 1000.0;
                double thread_avg_file_rate = (thread_total_time > 0) ? tp.thread_files_processed / thread_total_time : 0;
                double thread_avg_byte_rate = (thread_total_time > 0) ? tp.thread_bytes_processed / thread_total_time : 0;
                
                int total_hours 	= (int)(thread_total_time / 3600);
                int total_minutes 	= (int)((thread_total_time - total_hours * 3600) / 60);
                int total_seconds 	= (int)(thread_total_time - total_hours * 3600 - total_minutes * 60);
				color_green();
                printf("T%02d: %-5s # %08d        [%12s] @%12s/s | Time:%02d:%02d:%02d Avg:@%5.2f file/s", 
                         tp.thread_id, tp.status.c_str(), tp.thread_files_processed, 
                         tohuman(tp.thread_bytes_processed), 
						 tohuman2((int64_t)thread_avg_byte_rate),total_hours, total_minutes, total_seconds,
                         thread_avg_file_rate); 
	             eol();
            }
   			color_restore();
           
            if (i < threads_to_show - 1) 
				myprintf("\n"); 
        }
        
        // Back to the beginning for the next iteration
#ifdef WIN32 
        gotoxy(0, 0); 
#else 
        move_cursor_up(threads_to_show); 
#endif 
        fflush(stdout); 
    } 
}

bool zpaqfranzsftp2::sftp_down3parallela(std::vector<sftpget3>& file_list, int i_thread) 
{
    
    if (i_thread <= 0) 
	{
        if (flagdebug) 
			myprintf("93537$ Error: thread number invalid (%d)\n", i_thread);
        return false;
    }
    
    if (file_list.empty()) 
	{
        if (flagdebug) 
			myprintf("93544! No file to download\n");
		return true;
    }
    
    // Determine console height and maximum number of visible threads
    int console_height 		= get_console_height();
    int max_display_threads = console_height - 3; // Reserve space for global line + margins
    if (max_display_threads < 1) 
		max_display_threads = 1;
    
    // Limit the number of threads to the number of files
    int actual_threads = std::min(i_thread, (int)file_list.size());
    
    if (flagdebug) 
		myprintf("91557: debug Download parallel: %d file con %d thread (console: %d row, max display: %d)\n", 
                         (int)file_list.size(), actual_threads, console_height, max_display_threads);
    
    // Initialize mutex and condition variable
    pthread_mutex_t queue_mutex 	= PTHREAD_MUTEX_INITIALIZER;
    pthread_cond_t queue_cond 		= PTHREAD_COND_INITIALIZER;
    pthread_mutex_t result_mutex 	= PTHREAD_MUTEX_INITIALIZER;
    pthread_mutex_t progress_mutex	 = PTHREAD_MUTEX_INITIALIZER;
    
    // Task queue (pointers to vector elements)
    std::queue<sftpget3*> task_queue;
    
    // Variabili condivise
    bool all_tasks_added 			= false;
    bool stop_threads 				= false;
    bool success_flag 				= true;
    int completed_tasks 			= 0;
    int total_files_processed 		= 0;
    int64_t total_bytes_processed 	= 0;
    
    // Progress data per thread
    std::vector<sftp_threadprogressdata> thread_progress(actual_threads);
    
    // Prepare tasks (pointers to vector elements)
    for (size_t i = 0; i < file_list.size(); i++) 
	    task_queue.push(&file_list[i]);
    
    // Create the threads
    std::vector<pthread_t> threads(actual_threads);
    std::vector<sftp_downloadthreaddata> thread_data(actual_threads);
    
    for (int i = 0; i < actual_threads; i++) 
	{
        thread_data[i].sftp_instance 			= this;
        thread_data[i].task_queue 				= &task_queue;
        thread_data[i].queue_mutex 				= &queue_mutex;
        thread_data[i].queue_cond 				= &queue_cond;
        thread_data[i].all_tasks_added 			= &all_tasks_added;
        thread_data[i].stop_threads 			= &stop_threads;
        thread_data[i].thread_id 				= i + 1;
        thread_data[i].success_flag 			= &success_flag;
        thread_data[i].result_mutex 			= &result_mutex;
        thread_data[i].completed_tasks 			= &completed_tasks;
        thread_data[i].total_tasks 				= (int)file_list.size();
        thread_data[i].total_files_processed 	= &total_files_processed;
        thread_data[i].total_bytes_processed 	= &total_bytes_processed;
        thread_data[i].thread_progress 			= &thread_progress[i];
        thread_data[i].progress_mutex 			= &progress_mutex;
        
        int result = pthread_create(&threads[i], NULL, download_worker_thread, &thread_data[i]);
        if (result != 0) 
		{
        	myprintf("93609! Error creating download thread %d: %d\n", i + 1, result);
            
            // Stop the threads already created
            pthread_mutex_lock(&result_mutex);
            stop_threads = true;
            pthread_mutex_unlock(&result_mutex);
            
            // Wake up all threads
            pthread_cond_broadcast(&queue_cond);
            
            // Wait for the threads already created
            for (int j = 0; j < i; j++) 
			    pthread_join(threads[j], NULL);
            return false;
        }
    }
    
    // Signal that all tasks have been added
    pthread_mutex_lock(&queue_mutex);
    all_tasks_added = true;
    pthread_cond_broadcast(&queue_cond);
    pthread_mutex_unlock(&queue_mutex);
    
    hide_cursor();
    
	
    // If verbose, prepare space for the output
    if (actual_threads>1) 
	{
		
		if ((!flagsilent) && (!flagnoconsole))
		{
			clearscreen();
			/*
			setupConsole();
			printf("\033[2J"); //cls
			printf("\033[%d;0H",(int)1);
			restoreConsole();
			*/
			
		}

        int lines_needed = std::min(max_display_threads, actual_threads) + 1;
        for (int i = 0; i < lines_needed; i++) 
            printf("\n");
#ifdef _WIN32
        gotoxy(0, 0);
#else
        move_cursor_up(lines_needed);
#endif
    }
    
    // Monitor the progress
    int64_t start_time = mtime();
    int last_completed = -1;
    int64_t last_bytes = -1;
    
	
    while (true) 
	{
        pthread_mutex_lock(&result_mutex);
        int 	current_completed 			= completed_tasks;
        int 	current_files_processed 	= total_files_processed;
        int64_t current_bytes 				= total_bytes_processed;
        bool 	current_success 			= success_flag;
        pthread_mutex_unlock(&result_mutex);
        
        // Update display only if there are changes
        if (current_completed != last_completed || current_bytes != last_bytes) 
		{
            
            // Copy thread progress data in a thread-safe way
            std::vector<sftp_threadprogressdata> current_thread_progress(actual_threads);
            pthread_mutex_lock(&progress_mutex);
            for (int i = 0; i < actual_threads; i++) 
			    current_thread_progress[i] = thread_progress[i];
            pthread_mutex_unlock(&progress_mutex);
            
            sftp_display_progress_down_parallelo(current_thread_progress, (int)file_list.size(),
                           current_files_processed, current_bytes, start_time,
                           actual_threads>1, max_display_threads);
            
            last_completed 	= current_completed;
            last_bytes 		= current_bytes;
        }
        
        if (current_completed >= (int)file_list.size() || !current_success) 
		    break;
        
        // Pause to avoid busy wait
#ifdef _WIN32
        Sleep(500);
#else
        usleep(500000);
#endif
    }
    
    // Restore the cursor
    show_cursor();
    
    if (actual_threads<=1) 
	{
        myprintf("\n"); // New line after progress in simple mode
    } 
	else 
	{
        // In verbose mode, go to the end of the output
        int lines_shown = std::min(max_display_threads, actual_threads) + 1;
#ifdef _WIN32
        gotoxy(0, lines_shown);
#else
        for (int i = 0; i < lines_shown; i++) 
		    myprintf("\n");
#endif
    }
    
    // If there was an error, stop all threads
    pthread_mutex_lock(&result_mutex);
    if (!success_flag) 
	    stop_threads = true;
    pthread_mutex_unlock(&result_mutex);
    
    pthread_cond_broadcast(&queue_cond);
    
    // Wait for all threads to terminate
    for (int i = 0; i < actual_threads; i++) 
	{
        pthread_join(threads[i], NULL);
        if (flagdebug) 
			myprintf("93736: Download Thread %d terminated and released\n", i + 1);
    }
    
    // Cleanup
    pthread_mutex_destroy(&queue_mutex);
    pthread_cond_destroy(&queue_cond);
    pthread_mutex_destroy(&result_mutex);
    pthread_mutex_destroy(&progress_mutex);
    
    bool final_result = success_flag;
    int final_completed = total_files_processed;
    int64_t final_bytes = total_bytes_processed;
    
	if (final_result)
		color_green();
	else
		color_red();
	myprintf("93750: Download parallel done: %d/%d file (%s) - Result: %s\n",
               final_completed, (int)file_list.size(), tohuman(final_bytes),
               final_result ? "SUCCESS" : "ERROR");
	color_restore();
    return final_result;
}
#endif
///finefima2
#endif ///NOSFTPEND



#ifdef _WIN32
std::string Jidac::enumerate_physical_disks(int i_chosendrive)
{
	std::string risultato;
	if (flagdebug)
		myprintf("94752: i_chosendrive %d\n",i_chosendrive);
    for (int diskNum = 0; diskNum < 32; diskNum++) // Max 32 disks
    {
        char diskPath[64];
        snprintf(diskPath, sizeof(diskPath), "\\\\.\\PhysicalDrive%d", diskNum);
        
        HANDLE hDisk = CreateFile(utow(diskPath).c_str(),
                                 0, // Query only, not read
                                 FILE_SHARE_READ | FILE_SHARE_WRITE,
                                 NULL,
                                 OPEN_EXISTING,
                                 0,
                                 NULL);
        
        if (hDisk == INVALID_HANDLE_VALUE)
            continue; // Disk does not exist
        
///        myprintf("\n--- DISK %d: %s ---\n", diskNum, diskPath);
///        myprintf("\n--- DISK %d ---\n", diskNum);

		if (i_chosendrive<0)
			printbar('-');
		
		
        // 1. DISK SIZE
        GET_LENGTH_INFORMATION lengthInfo;
        DWORD bytesReturned = 0;
        
        if (DeviceIoControl(hDisk, IOCTL_DISK_GET_LENGTH_INFO,
                           NULL, 0,
                           &lengthInfo, sizeof(lengthInfo),
                           &bytesReturned, NULL))
        {
			if (i_chosendrive<0)
				myprintf("Size           : %K (%H)\n", lengthInfo.Length.QuadPart,lengthInfo.Length.QuadPart);
        }
        
        // 2. GEOMETRY AND MODEL INFORMATION
        STORAGE_PROPERTY_QUERY query;
        memset(&query, 0, sizeof(query));
        query.PropertyId = StorageDeviceProperty;
        query.QueryType = PropertyStandardQuery;
        
        BYTE buffer[1024];
        memset(buffer, 0, sizeof(buffer));
        
        if (DeviceIoControl(hDisk, IOCTL_STORAGE_QUERY_PROPERTY,
                           &query, sizeof(query),
                           buffer, sizeof(buffer),
                           &bytesReturned, NULL))
        {
            STORAGE_DEVICE_DESCRIPTOR* desc = (STORAGE_DEVICE_DESCRIPTOR*)buffer;
            
           
            if (desc->ProductIdOffset)
            {
                char* product = (char*)buffer + desc->ProductIdOffset;
				
				if (i_chosendrive<0)
				{
					color_green();
					myprintf("Disk          %2d: %s\n", diskNum,product);
					color_restore();
				}
				else
				{
					if (diskNum==i_chosendrive)
						risultato=product;
				}
            }
            
            if (desc->VendorIdOffset)
            {
                char* vendor = (char*)buffer + desc->VendorIdOffset;
				
				if (i_chosendrive<0)
					myprintf("Vendor          : %s\n", vendor);
				else
				{
					if (diskNum==i_chosendrive)
						risultato+=" of "+std::string(vendor);
				}
				
            }
      
			if (desc->SerialNumberOffset)
            {
                char* serial = (char*)buffer + desc->SerialNumberOffset;
				string temp=serial;
				if (!temp.empty() && temp.back() == '.')
					temp.pop_back();
				
				if (i_chosendrive<0)
					myprintf("Serial          : %s\n", temp.c_str());
				else
				{
					if (diskNum==i_chosendrive)
						risultato+=" #:"+temp;
                }
            }
            
            // Bus type (using only compatible values)
            const char* busType = "Unknown";
            switch ((int)desc->BusType)
            {
                case 1: 	busType = "SCSI"; 					break;
                case 2: 	busType = "ATAPI"; 					break;
                case 3: 	busType = "ATA/IDE"; 				break;
                case 6: 	busType = "Fibre Channel"; 			break;
                case 7: 	busType = "USB"; 					break;
                case 4: 	busType = "IEEE 1394"; 				break;
                case 5: 	busType = "SSA"; 					break;
                case 8: 	busType = "RAID"; 					break;
				case 9: 	busType = "iSCSI"; 					break;
				case 10: 	busType = "SAS"; 					break;
				case 11: 	busType = "SATA"; 					break;
				case 12: 	busType = "Secure Digital SD"; 		break;
				case 13: 	busType = "Multimedia Card MMC"; 	break;
				case 14: 	busType = "Virtual"; 				break;
				case 15: 	busType = "File Backed Virtual"; 	break;
				case 16: 	busType = "Storage Spaces"; 		break;
				case 17: 	busType = "NVMe"; 					break;
				default: 	busType = "Unknown"; 				break;
            }
			
			if (i_chosendrive<0)
			{
				myprintf("Bus Type        : %s (%d)\n", busType,desc->BusType);
				myprintf("Removable       : %s\n", desc->RemovableMedia ? "Yes" : "No");
			}
			else
			{
				if (diskNum==i_chosendrive)
					risultato+=" ("+std::string(busType)+")";
			}
			
        }
        
        // 3. PARTITION LAYOUT
        DWORD layoutSize = sizeof(DRIVE_LAYOUT_INFORMATION_EX) + 128 * sizeof(PARTITION_INFORMATION_EX);
        BYTE* layoutBuffer = new BYTE[layoutSize];
        memset(layoutBuffer, 0, layoutSize);
        
        if (DeviceIoControl(hDisk, IOCTL_DISK_GET_DRIVE_LAYOUT_EX,
                           NULL, 0,
                           layoutBuffer, layoutSize,
                           &bytesReturned, NULL))
        {
            DRIVE_LAYOUT_INFORMATION_EX* layout = (DRIVE_LAYOUT_INFORMATION_EX*)layoutBuffer;
            
			if (i_chosendrive<0)
			{
            myprintf("Partition Style : %s\n", 
                    layout->PartitionStyle == PARTITION_STYLE_MBR ? "MBR" : 
                    layout->PartitionStyle == PARTITION_STYLE_GPT ? "GPT" : "RAW");
            myprintf("Partitions      : %K\n", layout->PartitionCount);
            
            // Enumerate the partitions
            for (DWORD i = 0; i < layout->PartitionCount; i++)
            {
                PARTITION_INFORMATION_EX* part = &layout->PartitionEntry[i];
                
                if (part->PartitionLength.QuadPart > 0)
                {
                    myprintf("  Partition %K: %21K (%12H)", 
                            part->PartitionNumber,
                            part->PartitionLength.QuadPart,
                            part->PartitionLength.QuadPart);
                    
                    // Search for the corresponding drive letter
                    char driveLetter = find_drive_letter_for_partition(diskNum, part->PartitionNumber);
                    if (driveLetter != 0)
                    {
                        myprintf(" -> %c:", driveLetter);
                        
                        // Get filesystem information
                        char rootPath[8];
                        snprintf(rootPath, sizeof(rootPath), "%c:\\", driveLetter);
                        
                        char volumeName[MAX_PATH];
                        char fsName[MAX_PATH];
                        DWORD fsFlags;
                        
                        if (GetVolumeInformationA(rootPath, volumeName, sizeof(volumeName),
                                                NULL, NULL, &fsFlags, fsName, sizeof(fsName)))
                        {
                            myprintf(" [%s]", fsName);
                            if (strlen(volumeName) > 0)
                                myprintf(" \"%s\"", volumeName);
                        }
                    }
                    myprintf("\n");
                }
            }
			}
        }
        
        delete[] layoutBuffer;
        CloseHandle(hDisk);
    }
		return risultato;
}

// Helper function to find the drive letter
char Jidac::find_drive_letter_for_partition(int diskNumber, DWORD partitionNumber)
{
    char drives[512];
    if (GetLogicalDriveStringsA(sizeof(drives), drives) == 0)
        return 0;
    
    for (char* drive = drives; *drive; drive += strlen(drive) + 1)
    {
        if (strlen(drive) >= 3 && drive[1] == ':' && drive[2] == '\\')
        {
            char volumePath[16];
            snprintf(volumePath, sizeof(volumePath), "\\\\.\\%c:", drive[0]);
            
            HANDLE hVolume = CreateFile(utow(volumePath).c_str(), 0,
                                      FILE_SHARE_READ | FILE_SHARE_WRITE,
                                      NULL, OPEN_EXISTING, 0, NULL);
            
            if (hVolume != INVALID_HANDLE_VALUE)
            {
                VOLUME_DISK_EXTENTS diskExtents;
                DWORD bytesReturned;
                
                if (DeviceIoControl(hVolume, IOCTL_VOLUME_GET_VOLUME_DISK_EXTENTS,
                                   NULL, 0,
                                   &diskExtents, sizeof(diskExtents),
                                   &bytesReturned, NULL))
                {
                    if (diskExtents.NumberOfDiskExtents > 0 &&
                        diskExtents.Extents[0].DiskNumber == (DWORD)diskNumber)
                    {
                        // Check the partition number via IOCTL_DISK_GET_PARTITION_INFO_EX
                        PARTITION_INFORMATION_EX partInfo;
                        if (DeviceIoControl(hVolume, IOCTL_DISK_GET_PARTITION_INFO_EX,
                                           NULL, 0,
                                           &partInfo, sizeof(partInfo),
                                           &bytesReturned, NULL))
                        {
                            if (partInfo.PartitionNumber == partitionNumber)
                            {
                                CloseHandle(hVolume);
                                return drive[0];
                            }
                        }
                    }
                }
                CloseHandle(hVolume);
            }
        }
    }
    return 0;
}

// Function to check if it's a letter
bool isLetter(char c) 
{
    return (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z');
}

// Function to convert string to number
int stringToInt(const string& str) 
{
    int result = 0;
    for (unsigned int i = 0; i < str.length(); i++) 
	{
        if (!isdigit(str[i])) 
            return -1; // Invalid character
        result = result * 10 + (str[i] - '0');
    }
    return result;
}

bool Jidac::parsediskunit(string i_stringa, char& o_char, int& o_number) 
{
 // Initialize output values
    o_char = '\0';
    o_number = -1;
    
    if (i_stringa.empty()) 
	    return false;
    
    int len = i_stringa.length();
    
    // Case 1: Single letter (a-z, A-Z)
    if (len == 1 && isLetter(i_stringa[0])) 
	{
        o_char = tolower(i_stringa[0]);
        return true;
    }
    
    // Case 2: Letter with : (a:, A:)
    if (len == 2 && isLetter(i_stringa[0]) && i_stringa[1] == ':') 
	{
        o_char = tolower(i_stringa[0]);
        return true;
    }
	
	
    // Caso 3: Lettera con :\ (a:\, A:\)
    if (len == 3 && isLetter(i_stringa[0]) && i_stringa[1] == ':' && i_stringa[2] == '/') 
	{
        o_char = tolower(i_stringa[0]);
        return true;
    }
    
    // Case 4: Number (0-32)
    if (len >= 1 && len <= 2) 
	{
        bool allDigits = true;
        for (int i = 0; i < len; i++) 
		    if (!isdigit(i_stringa[i])) 
			{
                allDigits = false;
                break;
            }
        
        if (allDigits) 
		{
            int num = stringToInt(i_stringa);
            if (num >= 0 && num <= 32) 
			{
                o_number = num;
                return true;
            }
        }
    }
    
    // Case 5: Number with : (0:, 12:)
    if (len >= 2 && len <= 3 && i_stringa[len-1] == ':') 
	{
        string numStr = i_stringa.substr(0, len-1);
        bool allDigits = true;
        for (unsigned int i = 0; i < numStr.length(); i++) 
		{
            if (!isdigit(numStr[i])) 
			{
                allDigits = false;
                break;
            }
        }
        
        if (allDigits) 
		{
            int num = stringToInt(numStr);
            if (num >= 0 && num <= 32) 
			{
                o_number = num;
                return true;
            }
        }
    }
    
    // Unrecognized format
    return false;
}

int Jidac::drive()
{
	enumerate_physical_disks(-1);
	return 0;
}

#endif




// Function to normalize separators (converts all to '/')
std::string normalizePath(const std::string& path) 
{
    std::string normalized = path;
    for (size_t i = 0; i < normalized.length(); i++) 
	    if (normalized[i] == '\\') 
		    normalized[i] = '/';
    return normalized;
}

// Function to check if a path ends with '/'
std::string ensureTrailingSlash(const std::string& path) 
{
    if (path.empty() || path[path.length() - 1] != '/') 
	    return path + '/';
    return path;
}

// Function to check if a path starts with another path
bool startsWith(const std::string& fullPath, const std::string& prefix) 
{
    if (prefix.length() > fullPath.length()) 
	    return false;
    return fullPath.substr(0, prefix.length()) == prefix;
}

// Function to find the position of the next separator
size_t findNextSeparator(const std::string& path, size_t startPos) 
{
    for (size_t i = startPos; i < path.length(); i++) 
	    if (path[i] == '/') 
		    return i;
    return std::string::npos;
}

// Function to check if a folder is already present in the vector
int findFolderIndex(const std::vector<conteggio_file>& vec, const std::string& item) 
{
    for (size_t i = 0; i < vec.size(); i++) 
	    if (vec[i].percorso == item) 
		    return (int)i;
    return -1;
}


// Function to sort by ascending size
bool compareBySizeAsc(const conteggio_file& a, const conteggio_file& b) 
{
    return a.dimensione_totale < b.dimensione_totale;
}

// Function to sort by descending size
bool compareBySizeDesc(const conteggio_file& a, const conteggio_file& b) 
{
    return a.dimensione_totale > b.dimensione_totale;
}

// Function to sort in ascending order using C++ sort
void sortBySize(std::vector<conteggio_file>& vec) 
{
    std::sort(vec.begin(), vec.end(), compareBySizeAsc);
}

// Function to sort in descending order using C++ sort
void sortBySizeDesc(std::vector<conteggio_file>& vec) 
{
    std::sort(vec.begin(), vec.end(), compareBySizeDesc);
}

// Function to extract the first level folder from a path
std::string extractFirstLevelFolder(const std::string& path, const std::string& i_basepath) 
{
    std::string normalizedPath 		= normalizePath(path);
    std::string normalizedBasePath 	= normalizePath(i_basepath);
    
    // If i_basepath is empty, we handle it differently
    if (normalizedBasePath.empty()) 
	{
        // Find the first separator in the path
        size_t firstSeparatorPos = findNextSeparator(normalizedPath, 0);
        
        if (firstSeparatorPos != std::string::npos) 
		{
            // For UNC paths (//server/), consider the first two components
            if (normalizedPath.length() >= 2 && normalizedPath.substr(0, 2) == "//") 
			{
                size_t secondSeparatorPos = findNextSeparator(normalizedPath, 2);
                if (secondSeparatorPos != std::string::npos) 
				{
                    size_t thirdSeparatorPos = findNextSeparator(normalizedPath, secondSeparatorPos + 1);
                    if (thirdSeparatorPos != std::string::npos) 
					    return normalizedPath.substr(0, thirdSeparatorPos + 1);
                }
                return normalizedPath.substr(0, secondSeparatorPos + 1);
            }
            // For Windows paths with drive (c:/)
            else 
			if (normalizedPath.length() >= 2 && normalizedPath[1] == ':') 
			    return normalizedPath.substr(0, firstSeparatorPos + 1);
            // For relative and absolute Linux paths
            else 
			{
                if (normalizedPath[0] == '/')     // Absolute path Linux
                    return normalizedPath.substr(0, firstSeparatorPos + 1);
				else     // Relative path
                    return normalizedPath.substr(0, firstSeparatorPos + 1);
                
            }
        }
        return "";
    }
    
    // Case with non-empty i_basepath (original logic)
    normalizedBasePath = ensureTrailingSlash(normalizedBasePath);
    
    if (startsWith(normalizedPath, normalizedBasePath)) 
	{
        std::string remainder = normalizedPath.substr(normalizedBasePath.length());
        if (remainder.empty()) 
		    return "";
        
        size_t firstSeparatorPos = findNextSeparator(remainder, 0);
        if (firstSeparatorPos != std::string::npos) 
		    return normalizedBasePath + remainder.substr(0, firstSeparatorPos + 1);
    }
    
    return "";
}

void Jidac::getfirstlevelfolders(const DTMap& i_filemap, const std::string& i_basepath, std::vector<conteggio_file>& o_output, bool i_ordinapersize, bool i_flagdesc) 
{
    
    // Clears the output vector
    o_output.clear();
    
    // Iterate through all paths in the map
    for (DTMap::const_iterator it = i_filemap.begin(); it != i_filemap.end(); ++it) 
	{
        std::string currentPath = it->first;
        const DT& metadata = it->second;
        
        // Extract the first level folder
        std::string firstLevelFolder = extractFirstLevelFolder(currentPath, i_basepath);
        
        if (!firstLevelFolder.empty()) 
		{
            // Check if the folder is already present
            int folderIndex = findFolderIndex(o_output, firstLevelFolder);
            
            if (folderIndex == -1) 
			{
                // New folder
                conteggio_file nuovo;
                nuovo.percorso = firstLevelFolder;
                nuovo.dimensione_totale = metadata.size >= 0 ? metadata.size : 0;
                
                if (isdirectory(currentPath)) 
				{
                    nuovo.numero_file = 0;
                    nuovo.numero_directory = 1;
                } 
				else 
				{
                    nuovo.numero_file = 1;
                    nuovo.numero_directory = 0;
                }
                
                nuovo.numero_complessivo = nuovo.numero_file + nuovo.numero_directory;
                o_output.push_back(nuovo);
                
            } 
			else 
			{
                // Existing folder, update counters
                if (metadata.size >= 0) 
				    o_output[folderIndex].dimensione_totale += metadata.size;
                
                if (isdirectory(currentPath)) 
				   o_output[folderIndex].numero_directory++;
                else 
				   o_output[folderIndex].numero_file++;
                o_output[folderIndex].numero_complessivo = o_output[folderIndex].numero_file + o_output[folderIndex].numero_directory;
            }
        }
    }

	if (i_ordinapersize) 
	{
        if (i_flagdesc) 
            sortBySizeDesc(o_output);
        else 
		    sortBySize(o_output);
    }	
}


bool makeprivacy(const std::string& input_file, const std::string& output_file)
{
    // Input validation
    if (input_file.empty()) 
	{
        myprintf("93548! Input file path is empty\n");
        return false;
    }
    
    if (output_file.empty()) 
	{
        myprintf("91549! Output file path is empty\n");
        return false;
    }
    
    // Check that the files are not the same
    if (input_file == output_file) 
	{
        myprintf("93550! Input and output files cannot be the same\n");
        return false;
    }
    
    // Check existence of input file
    FILE* test_file = fopen(input_file.c_str(), "r");
    if (!test_file) 
	{
        myprintf("93551! Cannot find input file: <<%Z>>\n", input_file.c_str());
        return false;
    }
    fclose(test_file);
    
    // Opening input file
    FILE* in = fopen(input_file.c_str(), "r");
    if (!in) 
	{
        myprintf("93552! Cannot open input file: <<%Z>>\n", input_file.c_str());
        return false;
    }
    
    // Opening output file
    FILE* out = fopen(output_file.c_str(), "w");
    if (!out) 
	{
        myprintf("93553: Cannot create output file: <<%Z>>\n", output_file.c_str());
        fclose(in);
        return false;
    }
    
    const char* STAT_PREFIX 	= "|STAT|";
    const size_t PREFIX_LEN 	= 6; // lunghezza di "|STAT|"
    char line[32768]; 					// Larger buffer per linee lunghe
    size_t lines_processed 		= 0;
    size_t lines_filtered 		= 0;
    bool success 				= true;
    
    // Process the file line by line
    while (fgets(line, sizeof(line), in)) 
	{
        lines_processed++;
        
        // Remove final newline if present for more precise control
        size_t len = strlen(line);
		
        bool has_newline = (len > 0 && ((line[len-1] == '\n') || (line[len-1] == '\r')));
        
        // Check for buffer overflow (line too long)
        if (len == sizeof(line)-1 && !has_newline) 
		{
            myprintf("93554$ Line %s too long, may be truncated |%s|\n", migliaia(lines_processed),line);
        }
        // Filtra righe che iniziano con |STAT|
        if (len >= PREFIX_LEN && strncmp(line, STAT_PREFIX, PREFIX_LEN) == 0) 
		{
            lines_filtered++;
            continue; // Skip this line
        }
        
        // Write the line to the output file
        if (fputs(line, out) == EOF) 
		{
            myprintf("93555! Write error to output file at line %s\n", migliaia(lines_processed));
            success = false;
            break;
        }
        
        // Flush periodico per file grandi
        if (lines_processed % 1000 == 0) 
            fflush(out);
    }
    
    // Check for read errors
    if (!feof(in) && ferror(in)) 
	{
        myprintf("93556! Read error from input file\n");
        success = false;
    }
    
    // Check for final write errors
    if (fflush(out) != 0) 
	{
        myprintf("93557! Final flush error to output file\n");
        success = false;
    }
    
    // File closing
    fclose(in);
    fclose(out);
    
    if (success) 
	{
		if (flagverbose)
			myprintf("93652: Privacy filter completed: %s lines processed, %s lines filtered\n", migliaia(lines_processed), migliaia(lines_filtered));
    } 
	else 
		delete_file(output_file.c_str());
    
    return success;
}





bool isemail(const std::string& email)
{
    if (email.empty()) 
        return false;
    
    size_t len = email.length();
    
    // Minimum length: a@b.c (5 characters)
    if ((len < 5) || (len > 254)) // RFC 5321 limite massimo
        return false;
    
    // Find the position of the @
    size_t at_pos = email.find('@');
    if (at_pos == std::string::npos) 
	    return false; // No @
    
    // Check that there is only one @
    if (email.find('@', at_pos + 1) != std::string::npos) 
	    return false; 
	
    // Calculate part lengths
    size_t local_len = at_pos;
    size_t domain_len = len - local_len - 1;
    
    // Check part lengths
    if ((local_len == 0) || (local_len > 64))
	    return false;  // RFC 5321 limite local part
    
    
    if ((domain_len == 0) || (domain_len > 253)) 
        return false;// RFC 1035 limite domain
    
    // Extract the parts
    std::string local_part = email.substr(0, at_pos);
    std::string domain = email.substr(at_pos + 1);
    
    // === LOCAL PART VALIDATION (before the '@') ===
    
    // Cannot start or end with a dot
    if (local_part[0] == '.' || local_part[local_len - 1] == '.') 
	    return false;
    
    // Check valid characters in the local part
    bool prev_was_dot = false;
    for (size_t i = 0; i < local_len; i++) 
	{
        char c = local_part[i];
        
        // Consecutive dots not allowed
        if (c == '.') 
		{
            if (prev_was_dot) 
			    return false;
            prev_was_dot = true;
            continue;
        }
        prev_was_dot = false;
        
        // Allowed characters: letters, numbers, some symbols
        if (!isalnum(c) && c != '.' && c != '-' && c != '_' && c != '+' && c != '=' && c != '~') 
		    return false;
    }
    
    // === DOMAIN VALIDATION (after the '@') ===
    
    // Cannot start or end with a dot o trattino
    if (domain[0] == '.' || domain[0] == '-' || domain[domain_len - 1] == '.' || domain[domain_len - 1] == '-') 
	    return false;
    
    // Must contain at least one dot (for the TLD)
    size_t dot_pos = domain.find('.');
    if (dot_pos == std::string::npos) 
	    return false;
    
    // Check that there is at least one character after the last dot (TLD)
    size_t last_dot = domain.rfind('.');
    if (domain.length() - last_dot - 1 < 2)  
		return false; // Minimum TLD 2 characters
        
    // Check valid characters in the domain
    prev_was_dot = false;
    bool prev_was_dash = false;
    
    for (size_t i = 0; i < domain_len; i++) 
	{
        char c = domain[i];
        
        if (c == '.') 
		{
            // Consecutive dots not allowed
            if (prev_was_dot) 
			    return false;
            // Dot after hyphen not allowed
            if (prev_was_dash) 
			    return false;
            prev_was_dot 	= true;
            prev_was_dash 	= false;
            continue;
        }
        
        if (c == '-') 
		{
            // Hyphen after dot not allowed
            if (prev_was_dot) 
			    return false;
            prev_was_dash 	= true;
            prev_was_dot 	= false;
            continue;
        }
        
        // Reset flags
        prev_was_dot 	= false;
        prev_was_dash 	= false;
        
        // Only letters and numbers allowed (in addition to . and -)
        if (!isalnum(c)) 
		    return false;
    }
    
    // === ADDITIONAL CHECKS ===
    
    // Check that the TLD contains only letters
    std::string tld = domain.substr(last_dot + 1);
    for (size_t i = 0; i < tld.length(); i++) 
	    if (!isalpha(tld[i])) 
		    return false;
    
    // Check that each part of the domain does not exceed 63 characters
    size_t start 	= 0;
    size_t pos 		= 0;
    
    while ((pos = domain.find('.', start)) != std::string::npos) 
	{
        size_t part_len = pos - start;
        if ((part_len == 0) || (part_len > 63))
            return false; // RFC 1035 limite label
        start = pos + 1;
    }
    
    // Check the last part (after the last dot)
    size_t last_part_len = domain.length() - start;
    if ((last_part_len == 0) || (last_part_len > 63))
	    return false;
    
    return true;
}

void reportresult(string i_stringa,int i_risultato)
{
	if (i_risultato==0)
	{
		color_green();
		printf("%25s:OK",i_stringa.c_str());
		color_restore();
	}
	else
	{
		color_red();
		printf("%25s:ERROR",i_stringa.c_str());
		color_restore();
	}

}
#ifdef ZPAQFULL ///NOSFTPSTART
#ifdef _WIN32
int waitexecuteprogram(const std::string& i_filename, const std::string& i_parameters, const std::string& i_fileoutput = "") 
{
    STARTUPINFOA si;
    PROCESS_INFORMATION pi;
    ZeroMemory(&si, sizeof(si));
    si.cb = sizeof(si);
    ZeroMemory(&pi, sizeof(pi));
    
    // Build the complete command line
    std::string cmdLine;
    if (!i_parameters.empty()) 
	    cmdLine = "\"" + i_filename + "\" " + i_parameters;
     else 
	    cmdLine = "\"" + i_filename + "\"";

    
    // Add output redirection if specified
    if (!i_fileoutput.empty()) 
	    cmdLine += " >>" + i_fileoutput;
    
    // Create the process con o senza redirezione
    // If there is redirection, use cmd.exe to handle it
    std::string finalCmdLine;
    if (!i_fileoutput.empty()) 
	    finalCmdLine = "cmd.exe /c \"" + cmdLine + "\"";
    else 
	    finalCmdLine = cmdLine;
    
///    printf("Executing: %s\n", finalCmdLine.c_str());
    
    // Create the process senza reindirizzamento I/O interno
    // The program will have direct access to the console (unless redirected)
    if (!CreateProcessA(
        NULL,                                     // No module name (use command line)
        const_cast<LPSTR>(finalCmdLine.c_str()), // Command line
        NULL,                                     // Process handle not inheritable
        NULL,                                     // Thread handle not inheritable
        FALSE,                                    // Set handle inheritance to FALSE
        0,                                        // No creation flags
        NULL,                                     // Use parent's environment block
        NULL,                                     // Use parent's starting directory 
        &si,                                      // Pointer to STARTUPINFO structure
        &pi)                                      // Pointer to PROCESS_INFORMATION structure
    ) 
    {
        DWORD error = GetLastError();
        printf("Error creating process: %lu\n", error);
        return -1;  // Error in creating the process
    }
    
    // Wait for the process to terminate
    WaitForSingleObject(pi.hProcess, INFINITE);
    
    // Get the process exit code
    DWORD exitCode;
    if (!GetExitCodeProcess(pi.hProcess, &exitCode)) 
	{
        DWORD error = GetLastError();
        printf("Error getting exit code: %lu\n", error);
        exitCode = -2;  // Error in retrieving the exit code
    }
    
    // Cleanup
    CloseHandle(pi.hProcess);
    CloseHandle(pi.hThread);
    
    return static_cast<int>(exitCode);
}
#endif
#endif ///NOSFTPEND

#ifdef ZPAQFULL ///NOSFTPSTART
#ifdef SFTP
int Jidac::cloud()
{
	if (flagforce)
		if (!getcaptcha("overwrite!","Overwrite remote archive"))
			return 2;


	if (g_sftp_mailfull!="")
		if (!isemail(g_sftp_mailfull))
		{
			myprintf("93771: Mail full does not seems OK : %s\n",g_sftp_mailfull.c_str());
			return 2;
		}
	if (g_sftp_mailprivacy!="")
		if (!isemail(g_sftp_mailprivacy))
		{
			myprintf("93774: Mail privacy does not seems OK : %s\n",g_sftp_mailprivacy.c_str());
			return 2;
		}
		
	if (!flagonlyupload)	
		if (fileexists(archive))
		{
			if ((checkpassword())!=0)
			{
				color_red();
				printDigitalString("PASSWORD!");
				color_restore();
				return 2;
			}
		}
		
	string 	percorso		=extractfilepath		(archive);
	string	nome			=prendinomefileebasta	(archive);
	string 	thechecksum		=percorso+nome+"_crc32.txt";

	bool	myflagtest		=flagtest;
	flagtest				=false;

	bool	myflagverify	=flagverify;
	flagverify				=false;

	string	cloudtxt		=g_gettempdirectory()+"report.txt";
	cloudtxt				=nomefileseesistegia(cloudtxt);
	g_output				=cloudtxt;

	open_output(g_output);

	if (flagdebug)
	{
		myprintf("93675: Faccio g_output %s\n",g_output.c_str());
		myprintf("93676: %s\n",migliaia(int64_t(g_output_handle)));
	}
	
	int result_add		=0;
	int result_test		=0;
	int result_info		=0;
	int result_archive	=0;
	int result_versum	=0;
	int result_checksum	=0;
	int result_1on1		=0;
	int	result_deep		=0;

	if (!flagonlyupload)
	{
		color_cyan();
		myprintf("91544: ::::::::::::::::::::: Updating archive\n");
		color_restore();
		flagpakka	=true; 
		//flagpakka	=false;
		flagfasttxt	=true;
		flagstat	=true;
		result_add=add();

///		myprintf("KKKKKKKKKK$$$$$ result_add %d\n",result_add);
		if (myflagtest)
		{
			color_cyan();
			myprintf("93249: ::::::::::::::::::::: Testing\n");	
			color_restore();
			jidacreset();
			files.clear();
			flagpakka=true;
			result_test=test();
		}

		color_cyan();
		myprintf("93349: ::::::::::::::::::::: Enumerating versions\n");	
		color_restore();
		files.clear();
		jidacreset();
		flagpakka		=true;
		flagnoeta		=true;
		flagstat		=false;
		versioncomment	="";
		all				=8;
		command			='i';
		result_info		=enumeratecomments();
		
		
		if (myflagverify)
		{
			flagbig		=false;
			flagsilent	=false;
			color_cyan();
			myprintf("93549: ::::::::::::::::::::: Double check CRC-32\n");	
			color_restore();
			files.clear();
			jidacreset();
			flagfasttxt	=true;
			files.push_back(archive);
			flagpakka	=true; 
			flagnoeta	=false;
			g_dimensione=0;
			result_versum=versum();
		}
	}
	color_cyan();
	myprintf("93586: ::::::::::::::::::::: Starting cloud (main file)\n");
	color_restore();
	flagpakka=true;
	files.clear();
	files.push_back("sftp");
	files.push_back(archive);
	files.push_back(g_sftp_remote);
	result_archive=sftp_doupload();

	color_cyan();
	myprintf("94597: ::::::::::::::::::::: Starting cloud (checksum)\n");
	color_restore();

	flagpakka=true;
	flagforce=true;
	files.clear();
	files.push_back("sftp");
	files.push_back(thechecksum);
	files.push_back(g_sftp_remote);
	result_checksum=sftp_doupload();
	flagforce=false;

	color_cyan();
	myprintf("93614: ::::::::::::::::::::: 	Final check\n");
	color_restore();
	flagssd		=true;
	flagpakka	=false;
	flagterse	=true;
	string dacontrollare=includetrailingbackslash(percorso)+"*";
	files.clear();
	files.push_back("sftp");
	files.push_back(dacontrollare);
	files.push_back(g_sftp_remote);
	result_1on1=sftp_do1on1();

	bool flagdeep=flagsha1deep || flagmd5deep ||flagsha256deep;
	string thealgo;
	
	if (flagdeep)
	{
		if (flagmd5deep)
			thealgo="md5";
		else
		if (flagsha1deep)
			thealgo="sha1";
		else
		if (flagsha256deep)
			thealgo="sha256";	
		color_cyan();
		myprintf("43614: ::::::::::::::::::::: 	Full deep check with %s\n",thealgo.c_str());
		///flagpakka	=true; 
		flagnoeta	=false;
		color_restore();
		files.clear();
		files.push_back("ssh");
		files.push_back(dacontrollare);
		flagverbose=true;
		result_deep=ssh_dohasha(thealgo);
		flagverbose=false;
	}

	printbar('-');
	
	reportresult("Archiving update",result_add);
	
	if (myflagtest)
		reportresult("Full test of archive",result_test);
	
	reportresult("Enumerating versions",result_info);
	printf("\n");
	
	if (myflagverify)
		reportresult("Double-check versum",result_versum);
	
	reportresult("Archive uploading",result_archive);
	reportresult("Checksum uploading",result_checksum);
	printf("\n");
	reportresult("Double check upload",result_1on1);
	if (flagdeep)
		reportresult("Full deep check",result_deep);

	printf("\n");
	string	privacy=g_gettempdirectory()+"privacy.txt";
	privacy=nomefileseesistegia(privacy);
	if (flagdebug3)
	{
		myprintf("93624: report  %s\n",cloudtxt.c_str());
		myprintf("93625: privacy %s\n",privacy.c_str());
	}
	
	if(g_output_handle!=0)
	{
		fclose(g_output_handle);
		g_output_handle=0;
	}

	int somma=result_add+result_test+result_info+result_versum+result_archive+result_checksum+result_1on1+result_deep;
	printbar('-');
	reportresult("Global result",somma);
	printf("\n");
	
	if (g_sftp_maila=="")
	{
		myprintf("94014: No -maila, exit\n");
		
		if (somma==0)
		{
			color_green();
			printDigitalString("OK");
			menoenne=5;
			pause();
			color_restore();
			return 0;
		}
		else
		{
			color_red();
			printDigitalString("ERROR");
			pause();
			color_restore();
		}
		return somma;
	}		

	if (!fileexists(g_sftp_maila))
	{
		myprintf("94040: Cannot launch -maila <<%Z>> not found\n",g_sftp_maila.c_str());
		return 1;
	}
	
	if (!makeprivacy(cloudtxt,privacy))
	{
		myprintf("94028: Cannot make privacy file\n");
		return 2;
	}
	
	string parametri=std::string(migliaia(somma))+" ";
	if (g_sftp_customer=="")
		g_sftp_customer="zpaqfranz";

	parametri+=g_sftp_customer;
	
	
	if (g_sftp_mailfull!="")
	{
		if (flagverbose)
			myprintf("93773: Mail full     : %s\n",g_sftp_mailfull.c_str());
		parametri+=" -full "+g_sftp_mailfull+" \""+cloudtxt+"\"";
	}
	if (g_sftp_mailprivacy!="")
	{
		if (flagverbose)
			myprintf("93734: Mail privacy  : %s\n",g_sftp_mailprivacy.c_str());
		parametri+=" -privacy "+g_sftp_mailprivacy+" \""+privacy+"\"";
	}
	if (flagdebug)
		myprintf("9440: maila parameters |%s|\n",parametri.c_str());
#ifdef _WIN32
	int europe=waitexecuteprogram(g_sftp_maila,parametri);
#else
	int europe=0;
	xcommand(g_sftp_maila,parametri);
#endif

	if ((europe==0) && (somma==0))
	{
		color_green();
		printDigitalString("OK");
		menoenne=5;
		pause();
		color_restore();
		return 0;
	}
	else
	{
		color_red();
		printDigitalString("ERROR");
		pause();
		color_restore();
	}
	
	return 0;
}




#ifdef _WIN32
    #define SLEEP(ms) Sleep(ms)
#else
    #define SLEEP(ms) usleep((ms) * 1000)
    typedef void* HMODULE;
#endif

// Function types for libssh

typedef void* 		ssh_key;
typedef int 		(*ssh_pki_import_privkey_file_t)		(const char* filename, const char* passphrase, void* auth_fn, void* auth_data, ssh_key* pkey);
typedef int 		(*ssh_userauth_publickey_t)				(void* session, const char* username, ssh_key privkey);
typedef void 		(*ssh_key_free_t)						(ssh_key key);
typedef const char* (*ssh_version_t)(int);
typedef void* 		(*ssh_new_t)							();
typedef int 		(*ssh_options_set_t)					(void*, int, const void*);
typedef int 		(*ssh_connect_t)						(void*);
typedef int 		(*ssh_userauth_password_t)				(void*, const char*, const char*);
typedef int 		(*ssh_userauth_publickey_auto_t)		(void*, const char*, const char*);
typedef void* 		(*ssh_channel_new_t)					(void*);
typedef int 		(*ssh_channel_open_session_t)			(void*);
typedef int 		(*ssh_channel_request_exec_t)			(void*, const char*);
typedef int 		(*ssh_channel_read_t)					(void*, void*, uint32_t, int);
typedef int 		(*ssh_channel_read_nonblocking_t)		(void*, void*, uint32_t, int);
typedef void 		(*ssh_channel_close_t)					(void*);
typedef void 		(*ssh_channel_free_t)					(void*);
typedef void 		(*ssh_disconnect_t)						(void*);
typedef void 		(*ssh_free_t)							(void*);
typedef const char* (*ssh_get_error_t)						(void*);
typedef int 		(*ssh_channel_is_open_t)				(void*);
typedef int 		(*ssh_channel_is_eof_t)					(void*);
typedef int 		(*ssh_channel_get_exit_status_t)		(void*);
typedef int 		(*ssh_channel_send_eof_t)				(void*);
typedef int 		(*ssh_channel_select_t)					(void**, void**, void**, struct timeval*);

// Constants for ssh_options_set
#define SSH_OPTIONS_HOST 0
#define SSH_OPTIONS_PORT 1
#define SSH_OPTIONS_USER 2
#define SSH_OPTIONS_TIMEOUT 9

// Variabili globali per le funzioni della DLL/SO
static HMODULE g_sshLib 													= NULL;

static ssh_channel_close_t ssh_channel_close 								= NULL;
static ssh_channel_free_t ssh_channel_free 									= NULL;
static ssh_channel_get_exit_status_t ssh_channel_get_exit_status 			= NULL;
static ssh_channel_is_eof_t ssh_channel_is_eof								= NULL;
static ssh_channel_is_open_t ssh_channel_is_open 							= NULL;
static ssh_channel_new_t ssh_channel_new 									= NULL;
static ssh_channel_open_session_t ssh_channel_open_session 					= NULL;
static ssh_channel_read_nonblocking_t ssh_channel_read_nonblocking 			= NULL;
static ssh_channel_read_t ssh_channel_read 									= NULL;
static ssh_channel_request_exec_t ssh_channel_request_exec 					= NULL;
static ssh_channel_select_t ssh_channel_select           					= NULL;
static ssh_channel_send_eof_t ssh_channel_send_eof         					= NULL;
static ssh_connect_t ssh_connect 											= NULL;
static ssh_disconnect_t ssh_disconnect 										= NULL;
static ssh_free_t ssh_free 													= NULL;
static ssh_get_error_t ssh_get_error 										= NULL;
static ssh_key_free_t ssh_key_free											= NULL;
static ssh_new_t ssh_new 													= NULL;
static ssh_options_set_t ssh_options_set 									= NULL;
static ssh_pki_import_privkey_file_t ssh_pki_import_privkey_file			= NULL;
static ssh_userauth_password_t ssh_userauth_password 						= NULL;
static ssh_userauth_publickey_auto_t ssh_userauth_publickey_auto			= NULL;
static ssh_userauth_publickey_t ssh_userauth_publickey						= NULL;

// Cross-platform functions for dynamic loading
#ifdef _WIN32
bool file_exists(const char* path) 
{
    return GetFileAttributesA(path) != INVALID_FILE_ATTRIBUTES;
}

HMODULE load_library(const char* path) 
{
	HMODULE risultato=LoadLibraryA(path);
	
	if (flagdebug)
	{
		if (risultato)
			myprintf("96871: Loadlibrary OK\n");
		else
			myprintf("96871: Loadlibrary FAILED\n");
	}
    return risultato;
}

void* get_proc_address(HMODULE lib, const char* name) 
{
    return (void*)GetProcAddress(lib, name);
}

void free_library(HMODULE lib) 
{
    FreeLibrary(lib);
}

const char* get_library_error() 
{
    static char buffer[256];
    DWORD error = GetLastError();
    snprintf(buffer, sizeof(buffer), "96468: Win Error |%lu|", error);
    return buffer;
}

const char* get_default_libssh_path() 
{
    static std::string percorsolocale = "./libssh.dll";
	if (getwinexedir()!="")
		percorsolocale = getwinexedir() + "libssh.dll";
    return percorsolocale.c_str();
}




#else // Unix/Linux

bool file_exists(const char* path) 
{
    struct stat st;
    return stat(path, &st) == 0;
}

HMODULE load_library(const char* path) 
{
    return dlopen(path, RTLD_LAZY);
}

void* get_proc_address(HMODULE lib, const char* name) 
{
    return dlsym(lib, name);
}

void free_library(HMODULE lib) 
{
    dlclose(lib);
}

const char* get_library_error() 
{
    return dlerror();
}

const char* get_default_libssh_path() 
{	
    return "libssh.so.4";
}

#endif

// Function to dynamically load the SSH library
int caricadllssh()
{
	if (g_sshLib)
		return 0;

	const char* dllPath	= get_default_libssh_path();
#ifdef _WIN32
    // Check if the library exists
    if (!file_exists(dllPath)) 
	{
        myprintf("96543! Cannot find libssh in %Z\n", dllPath);
        #ifndef _WIN32
			myprintf("96545: Ubuntu/Debian sudo apt-get install libssh-4\n");
			myprintf("96546: CentOS/RHEL   sudo yum install libssh\n");
			myprintf("96547: macOS         brew install libssh\n");
        #endif
        return -1;
    }
    myprintf("DEBUG: libssh founded in %s\n", dllPath);
#endif

    // Load the library
    g_sshLib = load_library(dllPath);
    if (!g_sshLib) 
	{
        myprintf("96557: Cannot load libssh: |%s|\n", get_library_error());
        #ifdef _WIN32
			myprintf("96559: Check libgcc_s_seh-1.dll libwinpthread-1.dll zlib1.dll\n");
        #else
			myprintf("96561: Do you have all the dependencies for libssh installed?\n");
        #endif
        return -1;
    }
    myprintf("DEBUG: libssh loaded\n");



// When loading functions add:
	ssh_version_t ssh_version = (ssh_version_t)get_proc_address(g_sshLib, "ssh_version");
	if (ssh_version) 
		myprintf("DEBUG: libssh version: %s\n", ssh_version(0));
	
    // Resolve functions
	ssh_new 						= (ssh_new_t)							get_proc_address(g_sshLib, "ssh_new");
	ssh_options_set 				= (ssh_options_set_t)					get_proc_address(g_sshLib, "ssh_options_set");
	ssh_connect 					= (ssh_connect_t)						get_proc_address(g_sshLib, "ssh_connect");
	ssh_userauth_password 			= (ssh_userauth_password_t)				get_proc_address(g_sshLib, "ssh_userauth_password");
	ssh_userauth_publickey_auto 	= (ssh_userauth_publickey_auto_t)		get_proc_address(g_sshLib, "ssh_userauth_publickey_auto");
	ssh_pki_import_privkey_file 	= (ssh_pki_import_privkey_file_t)		get_proc_address(g_sshLib, "ssh_pki_import_privkey_file");
	ssh_userauth_publickey 			= (ssh_userauth_publickey_t)			get_proc_address(g_sshLib, "ssh_userauth_publickey");  
	ssh_key_free 					= (ssh_key_free_t)						get_proc_address(g_sshLib, "ssh_key_free");
	ssh_channel_new 				= (ssh_channel_new_t)					get_proc_address(g_sshLib, "ssh_channel_new");
	ssh_channel_open_session 		= (ssh_channel_open_session_t)			get_proc_address(g_sshLib, "ssh_channel_open_session");
	ssh_channel_request_exec 		= (ssh_channel_request_exec_t)			get_proc_address(g_sshLib, "ssh_channel_request_exec");
	ssh_channel_read 				= (ssh_channel_read_t)					get_proc_address(g_sshLib, "ssh_channel_read");
	ssh_channel_read_nonblocking	= (ssh_channel_read_nonblocking_t)		get_proc_address(g_sshLib, "ssh_channel_read_nonblocking");
	ssh_channel_close 				= (ssh_channel_close_t)					get_proc_address(g_sshLib, "ssh_channel_close");
	ssh_channel_free 				= (ssh_channel_free_t)					get_proc_address(g_sshLib, "ssh_channel_free");
	ssh_disconnect 					= (ssh_disconnect_t)					get_proc_address(g_sshLib, "ssh_disconnect");
	ssh_free 						= (ssh_free_t)							get_proc_address(g_sshLib, "ssh_free");
	ssh_get_error 					= (ssh_get_error_t)						get_proc_address(g_sshLib, "ssh_get_error");
	ssh_channel_is_open 			= (ssh_channel_is_open_t)				get_proc_address(g_sshLib, "ssh_channel_is_open");
	ssh_channel_is_eof 				= (ssh_channel_is_eof_t)				get_proc_address(g_sshLib, "ssh_channel_is_eof");
	ssh_channel_get_exit_status 	= (ssh_channel_get_exit_status_t)		get_proc_address(g_sshLib, "ssh_channel_get_exit_status");
	ssh_channel_send_eof			= (ssh_channel_send_eof_t)				get_proc_address(g_sshLib, "ssh_channel_send_eof");
	ssh_channel_select				= (ssh_channel_select_t)				get_proc_address(g_sshLib, "ssh_channel_select");

	if (!ssh_new)						myprintf("97030! cannot find ssh_new\n");
	if (!ssh_options_set) 				myprintf("97031! cannot find ssh_options_set\n");
	if (!ssh_connect) 					myprintf("97032! cannot find ssh_connect\n");
	if (!ssh_userauth_password) 		myprintf("97033! cannot find ssh_userauth_password\n");
	if (!ssh_userauth_publickey_auto) 	myprintf("97034! cannot find ssh_userauth_publickey_auto\n");
	if (!ssh_pki_import_privkey_file) 	myprintf("97035! cannot find ssh_pki_import_privkey_file\n");
	if (!ssh_userauth_publickey) 		myprintf("97036! cannot find ssh_userauth_publickey\n");
	if (!ssh_key_free) 					myprintf("97037! cannot find ssh_key_free\n");
	if (!ssh_channel_new) 				myprintf("97038! cannot find ssh_channel_new\n");
	if (!ssh_channel_open_session) 		myprintf("97039! cannot find ssh_channel_open_session\n");
	if (!ssh_channel_request_exec) 		myprintf("97040! cannot find ssh_channel_request_exec\n");
	if (!ssh_channel_read) 				myprintf("97031! cannot find ssh_channel_read\n");
	if (!ssh_channel_read_nonblocking) 	myprintf("97042! cannot find ssh_channel_read_nonblocking\n");
	if (!ssh_channel_close) 			myprintf("97043! cannot find ssh_channel_close\n");
	if (!ssh_channel_free) 				myprintf("97044! cannot find ssh_channel_free\n");
	if (!ssh_disconnect) 				myprintf("97045! cannot find ssh_disconnect\n");
	if (!ssh_free) 						myprintf("97046! cannot find ssh_free\n");
	if (!ssh_get_error) 				myprintf("97047! cannot find ssh_get_error\n");
	if (!ssh_channel_is_open) 			myprintf("97048! cannot find ssh_channel_is_open\n");
	if (!ssh_channel_is_eof) 			myprintf("97049! cannot find ssh_channel_is_eof\n");
	if (!ssh_channel_get_exit_status) 	myprintf("97050! cannot find ssh_channel_get_exit_status\n");
	if (!ssh_channel_send_eof) 			myprintf("97051! cannot find ssh_channel_send_eof\n");

	if 	(
		!ssh_new 						|| !ssh_options_set 				|| !ssh_connect 				|| 
		!ssh_userauth_password 			|| !ssh_userauth_publickey_auto 	|| !ssh_pki_import_privkey_file || 
		!ssh_userauth_publickey 		|| !ssh_key_free 					|| !ssh_channel_new 			|| 
		!ssh_channel_open_session 		|| !ssh_channel_request_exec 		|| !ssh_channel_read 			|| 
		!ssh_channel_read_nonblocking 	|| !ssh_channel_close 				|| !ssh_channel_free 			|| 
		!ssh_disconnect 				|| !ssh_free 						|| !ssh_get_error 				|| 
		!ssh_channel_is_open			|| !ssh_channel_is_eof 				|| !ssh_channel_get_exit_status || 
		!ssh_channel_send_eof 			|| !ssh_channel_select
		)
	{
        myprintf("96594: Cannot resolve functions. Library too old?\n");
        myprintf("96595: Error: %s\n", get_library_error());
        free_library(g_sshLib);
        g_sshLib = NULL;
        return -1;
    }
	
    myprintf("DEBUG: libssh functions OK (good)\n");
    return 0;
}

// Function to download the library
void scaricadllssh() 
{
    if (g_sshLib) 
	{
        free_library(g_sshLib);
        g_sshLib = NULL;
        myprintf("DEBUG: Libreria SSH scaricata\n");
    }
}

// Function for authentication (first RSA key, then password as fallback)
int autentica_ssh(void* session, const std::string& user, const std::string& password, const std::string& keyfile) 
{
   // Attempt authentication with key if specified and the file exists
   if (!keyfile.empty() && file_exists(keyfile.c_str())) 
   {
       myprintf("DEBUG: RSA keyfile: %s\n", keyfile.c_str());
       
       // Manual key loading
       if (ssh_pki_import_privkey_file && ssh_userauth_publickey && ssh_key_free)
       {
           void* privkey = NULL;
           
           // Try to load the key without a passphrase
           int rc = ssh_pki_import_privkey_file(keyfile.c_str(), NULL, NULL, NULL, &privkey);
           if (rc != 0 && !password.empty()) 
           {
               // Retry with password as passphrase
               rc = ssh_pki_import_privkey_file(keyfile.c_str(), password.c_str(), NULL, NULL, &privkey);
           }
           
           if (rc == 0 && privkey) 
           {
               int result = ssh_userauth_publickey(session, user.c_str(), privkey);
               ssh_key_free(privkey);
               
               if (result == 0) 
               {
                   myprintf("DEBUG: RSA key auth done!\n");
                   return 0;
               }
               myprintf("DEBUG: RSA key auth failed\n");
           }
           else 
           {
               myprintf("DEBUG: Failed to load private key from %s\n", keyfile.c_str());
           }
       }
       else 
       {
           myprintf("DEBUG: No key loading functions available\n");
       }
   } 
   else if (!keyfile.empty()) 
   {
       myprintf("DEBUG: Keyfile '%s' not found, going password\n", keyfile.c_str());
   }
   
   // Fallback with password authentication
   myprintf("DEBUG: Going password for user: %s\n", user.c_str());
   if (ssh_userauth_password(session, user.c_str(), password.c_str()) == 0) 
   {
       myprintf("DEBUG: Password auth OK!\n");
       return 0;
   }
   
   myprintf("96661! Auth failed: %s\n", ssh_get_error(session));
   return -1;
}


enum ssh_error_e 
{
  SSH_OK = 0,
  SSH_ERROR = -1,
  SSH_AGAIN = -2,
};
int eseguicomandossh(uint64_t i_expectedtime,std::string& comando, const std::string& host, int port,
                      const std::string& user, const std::string& password, const std::string& keyfile,
                      std::string& o_output)
{
    o_output = ""; // Clears the previous output
    if (!g_sshLib)
    {
        myprintf("96673: SSH not loaded. Need  caricadllssh()\n");
        return -1;
    }

    myprintf("DEBUG: Running SSH command...\n");
    myprintf("DEBUG: Host=%s, Porta=%d, Utente=%s\n", host.c_str(), port, user.c_str());
    if (flagdebug)
        myprintf("DEBUG: Command=%s\n", comando.c_str());

    // 1. SSH session initialization
    void* session = ssh_new();
    if (!session)
    {
        myprintf("96685: ssh_new kaputt\n");
        return -1;
    }

    // 2. Setting session options with a more conservative timeout
    int timeout_secondi = 20; // Increased for more stable connections
    ssh_options_set(session, SSH_OPTIONS_HOST,      host.c_str());
    ssh_options_set(session, SSH_OPTIONS_PORT,      &port);
    ssh_options_set(session, SSH_OPTIONS_USER,      user.c_str());
    ssh_options_set(session, SSH_OPTIONS_TIMEOUT,   &timeout_secondi);

    // 3. Server connection
    if (ssh_connect(session) != 0)
    {
        myprintf("96700: ssh_connect kaputt: %s\n", ssh_get_error(session));
        ssh_free(session);
        return -1;
    }
    myprintf("DEBUG: Connection to %s done\n", host.c_str());

    // 4. Authentication
    if (autentica_ssh(session, user, password, keyfile) != 0)
    {
        myprintf("96799! autentica_ssh kaputt: %s\n", ssh_get_error(session));
        ssh_disconnect(session);
        ssh_free(session);
        return -1;
    }
    myprintf("DEBUG: Autentica_ssh OK\n");

    // 5. Channel creation
    void* channel = ssh_channel_new(session);
    if (!channel)
    {
        myprintf("96719! ssh_channell_new kaputt %s\n", ssh_get_error(session));
        ssh_disconnect(session);
        ssh_free(session);
        return -1;
    }

    // 6. Opening a session on the channel
    if (ssh_channel_open_session(channel) != 0)
    {
        myprintf("96731! ssh_channel_open_session kaputt: %s\n", ssh_get_error(session));
        ssh_channel_free(channel);
        ssh_disconnect(session);
        ssh_free(session);
        return -1;
    }
    myprintf("DEBUG: Session channel OK\n");

    // 7. Command execution
    if (ssh_channel_request_exec(channel, comando.c_str()) != 0)
    {
        myprintf("96750! exec kaputt: %s\n", ssh_get_error(session));
        ssh_channel_close(channel);
        ssh_channel_free(channel);
        ssh_disconnect(session);
        ssh_free(session);
        return -1;
    }
    myprintf("DEBUG: Waiting for output...\n");

    // 8. *** LOGICA DI LETTURA OTTIMIZZATA ANTI-DEADLOCK ***
    char buffer[8192]; // Larger buffer per maggiore efficienza
    int nbytes;
    std::string stderr_output;
    
    int64_t started = mtime();
    int consecutive_empty_reads = 0;
    const int MAX_EMPTY_READS = 10; // Limit to avoid infinite loops
    
    while (ssh_channel_is_open(channel) && !ssh_channel_is_eof(channel))
    {
        struct timeval timeout;
        timeout.tv_sec 	= 5;  // Balanced timeout
        timeout.tv_usec = 0;

        void* read_channels[2];
        read_channels[0] = channel;
        read_channels[1] = NULL;
      
      
        int seconds = (mtime() - started) / 1000.0;
        if (seconds > 5) // Show progress only after 5 seconds
        {
			if (i_expectedtime > 0) 
            {
                // Calcola tempo rimanente basato su i_expectedtime
                int64_t tempo_rimanente = i_expectedtime - seconds;
				///myprintf("00600: i_expected %s rimanente_ms %s\n",migliaia(i_expectedtime),migliaia2(tempo_rimanente_ms));
				
                if (tempo_rimanente > 0) 
                {
                    int eta_ore = tempo_rimanente / 3600;
                    if (eta_ore > 99) eta_ore = 99;
                    int eta_min = (tempo_rimanente / 60) % 60;
                    int eta_sec = tempo_rimanente % 60;
                    myprintf("96891: Waiting... %02d:%02d:%02d ETA: %02d:%02d:%02d\r", 
                            int(seconds/3600), int(seconds/60)%60, int(seconds)%60,
                            eta_ore, eta_min, eta_sec);
                } 
                else 
                {
                    myprintf("96891: Waiting... %02d:%02d:%02d ETA: --:--:--\r", 
                            int(seconds/3600), int(seconds/60)%60, int(seconds)%60);
                }
            } 
            else 
            {
                myprintf("96891: Waiting... %02d:%02d:%02d\r", 
                        int(seconds/3600), int(seconds/60)%60, int(seconds)%60);
            }
        }
        
        // Wait for data to be ready on the channel
        int rc = ssh_channel_select(read_channels, NULL, NULL, &timeout);

        if (rc == SSH_ERROR) 
		{
            myprintf("\n");
			myprintf("96930! Critical error ssh_channel_select: %s\n", ssh_get_error(session));
            break; // Exits immediately on critical error
        }

        if (rc == SSH_AGAIN) 
		{ // Timeout, no data available
            consecutive_empty_reads++;
            if (consecutive_empty_reads >= MAX_EMPTY_READS) 
			{
                // Check if the channel is still active
                if (ssh_channel_is_eof(channel)) 
				{
                    myprintf("\n");
					myprintf("DEBUG: EOF after multiple timeout\n");
                    break;
                }
            }
            continue;
        }

        // Reset the counter if we have received data
        consecutive_empty_reads = 0;

        // *** BALANCED ANTI-DEADLOCK READ ***
        // ALWAYS read from both channels at each iteration
        bool data_read = false;
        
        // Attempt to read from STDOUT (priority for the main output)
        nbytes = ssh_channel_read_nonblocking(channel, buffer, sizeof(buffer), 0);
        if (nbytes > 0) 
		{
            o_output.append(buffer, nbytes);
            data_read = true;
        } 
		else if (nbytes < 0) 
		{
       ///     myprintf("\n");
		///	myprintf("96935! Error reading STDOUT %s\n", ssh_get_error(session));
        }

        // Attempt to read from STDERR (critical to prevent deadlock)
        nbytes = ssh_channel_read_nonblocking(channel, buffer, sizeof(buffer), 1);
        if (nbytes > 0) 
		{
            stderr_output.append(buffer, nbytes);
            data_read = true;
        } 
		else if (nbytes < 0) 
		{
			///myprintf("\n");
		///	myprintf("96940$ No stderr\n");
        }
        
        // If there is no data on either channel, increment the counter
        if (!data_read) 
            consecutive_empty_reads++;
    }

    myprintf("DEBUG: Completed\n");

    // 9. Management and printing of results with more detailed information
    if (flagdebug)
        myprintf("96818: RESULT FOR comando: |%s|\n", comando.c_str());
    
    if (o_output.empty()) 
	{
        myprintf("96828! No output on STDOUT\n");
    } 
	else 
	{
        if (flagdebug)
            myprintf("96823: STDOUT (%s bytes)\n%s\n", migliaia(o_output.length()), o_output.c_str());
    }

    if (!stderr_output.empty()) 
	{
        myprintf("96833:  STDERR (%s bytes)\n%s\n", migliaia(stderr_output.length()), stderr_output.c_str());
    }

    // 10. Recupero exit status prima della pulizia
    int exit_status = ssh_channel_get_exit_status(channel);
    if (exit_status != 0) 
	{
        myprintf("96841! Terminated with exit code: %d\n", exit_status);
    } else 
	if (flagverbose) 
	{
        myprintf("96840: Done remote with success (exit code: 0)\n");
    }

    // 11. Pulizia finale ottimizzata
    myprintf("DEBUG: Cleanup ssh...\n");
    
    if (ssh_channel_is_open(channel)) 
        ssh_channel_send_eof(channel);
    
    ssh_channel_close(channel);
    ssh_channel_free(channel);
    ssh_disconnect(session);
    ssh_free(session);
    
    myprintf("DEBUG: Cleanup done\n");

    // Returns the exit status of the remote command (0 = success, other = error)
    return exit_status;
}
int Jidac::xssh(uint64_t i_timetorun,std::string i_command,std::string& o_output)
{
	o_output="";
	if (i_command=="")
	{
		myprintf("96788: i_command empty\n");
		return 2;
	}
	if (g_sftp_host=="")
	{
		myprintf("96793: sftp_host empty\n");
		return 2;
	}
	if (g_sftp_user=="")
	{
		myprintf("96794: sftp_user empty\n");
		return 2;
	}

	if (g_sftp_password=="")
		if (g_sftp_key=="")
		{
			myprintf("96805: you need -password or -key!\n");
			return 2;
		}
    // Load the library SSH
    if (caricadllssh()!=0) 
	{
		myprintf("96814: cannot load libssh\n");
        return 2;
    }
    int result = eseguicomandossh(i_timetorun,i_command, g_sftp_host, g_sftp_port, g_sftp_user, g_sftp_password, g_sftp_key,o_output);
    scaricadllssh();

    return result;

}

void parsehashfilelist(const std::string& input, std::vector<std::pair<std::string, std::string> >& o_hashname) 
{
    o_hashname.clear(); // Clears the output vector
    
    if (input.empty()) 
        return; // Empty string, exit

    const char* ptr = input.c_str();
    const char* end = ptr + input.length();
    
    while (ptr < end) 
	{
        // Skip leading spaces e caratteri di controllo
        while (ptr < end && (*ptr == ' ' || *ptr == '\t' || *ptr == '\r' || *ptr == '\n')) 
		    ++ptr;
        
        if (ptr >= end) 
		    break; // Fine input
        
        // Read hash (hex characters)
        std::string hash;
        while (ptr < end && 
               ((*ptr >= '0' && *ptr <= '9') || 
                (*ptr >= 'a' && *ptr <= 'f') || 
                (*ptr >= 'A' && *ptr <= 'F'))) {
            hash += *ptr;
            ++ptr;
        }
        
        // Check hash validity
        if (hash.empty() || hash.length() > 64) 
		{ // Maximum length for SHA-256
            // Skip to the end of the line
            while (ptr < end && *ptr != '\n' && *ptr != '\r') 
			    ++ptr;
            continue;
        }

        // Skip separators (spaces, tabs)
        while (ptr < end && (*ptr == ' ' || *ptr == '\t')) 
		    ++ptr;
        
        // Read filename
        std::string filename;
        while (ptr < end && *ptr != '\n' && *ptr != '\r') 
		{
            filename += *ptr;
            ++ptr;
        }

        // Remove trailing spaces from filename
        while (!filename.empty() && 
               (filename[filename.length() - 1] == ' ' || 
                filename[filename.length() - 1] == '\t')) 
		    filename.erase(filename.length() - 1);
        
        // Check filename validity
        if (!filename.empty()) 
		    o_hashname.push_back(std::make_pair(hash, filename));
        
        // Skip end-of-line characters
        while (ptr < end && (*ptr == '\n' || *ptr == '\r')) 
		    ++ptr;
    }
}



// Function to compare two strings case-sensitively
int strcmp_case(const char* s1, const char* s2) 
{
    return strcmp(s1, s2);
}



// Function to check if a string is a valid hexadecimal hash
int isValidHexHash(const char* hash) 
{
    if (!hash || strlen(hash) == 0) 
		return 0;
    for (size_t i = 0; hash[i] != '\0'; i++) 
	{
        char c = hash[i];
        if (!((c >= '0' && c <= '9') || (c >= 'a' && c <= 'f') || (c >= 'A' && c <= 'F'))) 
		    return 0; // Invalid character found
    }
    return 1; // All characters are valid hex
}

// Function to convert a character to lowercase
char toLowerChar(char c) 
{
    if (c >= 'A' && c <= 'Z') 
        return c + ('a' - 'A');
    return c;
}

// Function to compare two strings case-insensitively
int strcmp_nocase(const char* s1, const char* s2) 
{
    while (*s1 && *s2) 
	{
        char c1 = toLowerChar(*s1);
        char c2 = toLowerChar(*s2);
        if (c1 != c2) return c1 - c2;
        s1++;
        s2++;
    }
    return toLowerChar(*s1) - toLowerChar(*s2);
}

// Function to extract filename from a full path (works for both Windows and Linux paths)
const char* getFilename(const char* path) {
    const char* last_slash = strrchr(path, '/');
    const char* last_backslash = strrchr(path, '\\');
    const char* last = NULL;

    if (!path || strlen(path) == 0) return "";

    // Find the last separator
    if (last_slash == NULL && last_backslash == NULL) {
        return path; // No separator found, return the whole string
    }
    if (last_slash == NULL || (last_backslash != NULL && last_backslash > last_slash)) {
        last = last_backslash;
    } else {
        last = last_slash;
    }
    return last + 1; // Return the part after the last separator
}

// Comparison function
int comparehasharrays(const std::vector<std::pair<std::string, std::string> >& local_hash_array,
                     const std::vector<std::pair<std::string, std::string> >& remote_hash_array) 
{
   int identical = 0; // Assume identical until a difference is found
    unsigned int i, j;
    int found;

    // Check for files in local but not in remote, and compare hashes
    for (i = 0; i < local_hash_array.size(); i++) 
	{
        const char* local_filename 	= getFilename(local_hash_array[i].second.c_str());
        const char* local_hash 		= local_hash_array[i].first.c_str();

        // Validate local hash
        if (!isValidHexHash(local_hash)) 
		{
            myprintf("97054! Invalid hex hash in local: %s for file %s\n", local_hash, local_filename);
			if (identical<2)
				identical = 2;
            continue;
        }

        found = 0;

        // Look for matching filename in remote
        for (j = 0; j < remote_hash_array.size(); j++) 
		{
            const char* remote_filename = getFilename(remote_hash_array[j].second.c_str());
            if (strcmp(local_filename, remote_filename) == 0) {
                const char* remote_hash = remote_hash_array[j].first.c_str();

                // Validate remote hash
                if (!isValidHexHash(remote_hash)) 
				{
                    myprintf("97071! Invalid hex hash in remote: %s for file %s\n", remote_hash, remote_filename);
                    if (identical<2)
						identical = 2;
                    continue;
                }

                found = 1;
                // Compare hashes case-insensitively
                if (strcmp_nocase(local_hash, remote_hash) != 0) 
				{
					color_red();
                    myprintf("97080: local  %s vs remote %s for <<%Z>>\n",local_hash, remote_hash,local_filename);
					color_restore();
                    if (identical<2)
						identical = 2;
                }
				else
				{
					if (flagverbose)
					{
						color_green();
						myprintf("97083: OK %s vs %s for <<%Z>>\n",local_hash, remote_hash,local_filename);
						color_restore();
					}
				}
                break;
            }
        }

        if (!found && strlen(local_filename) > 0) 
		{
			color_yellow();
            myprintf("97089: File only in local: %Z\n", local_filename);
			color_restore();
			if (identical<1)
				identical = 1;
        }
    }

    // Check for files in remote but not in local
    for (j = 0; j < remote_hash_array.size(); j++) 
	{
        const char* remote_filename = getFilename(remote_hash_array[j].second.c_str());
        const char* remote_hash 	= remote_hash_array[j].first.c_str();

        // Validate remote hash
        if (!isValidHexHash(remote_hash)) 
		{
            myprintf("97103$ Invalid hex hash in remote: %s for file %s\n", remote_hash, remote_filename);
			if (identical<2)
				identical = 2;
            continue;
        }

        found = 0;

        for (i = 0; i < local_hash_array.size(); i++) 
		{
            const char* local_filename = getFilename(local_hash_array[i].second.c_str());
            if (strcmp(local_filename, remote_filename) == 0) 
			{
                found = 1;
                break;
            }
        }

        if (!found && strlen(remote_filename) > 0) 
		{
			color_yellow();
            myprintf("97122: File only in remote: %s\n", remote_filename);
			color_restore();
			if (identical<1)
				identical = 1;
            
        }
    }

    // Check for empty or invalid filenames in local
    for (i = 0; i < local_hash_array.size(); i++) 
	{
        const char* local_filename = getFilename(local_hash_array[i].second.c_str());
        if (strlen(local_filename) == 0) 
		{
            myprintf("971133: Invalid or empty filename in local at index %d\n", i);
			if (identical<1)
				identical = 1;
        }
    }

    // Check for empty or invalid filenames in remote
    for (j = 0; j < remote_hash_array.size(); j++) 
	{
        const char* remote_filename = getFilename(remote_hash_array[j].second.c_str());
        if (strlen(remote_filename) == 0) 
		{
            myprintf("97144: Invalid or empty filename in remote at index %d\n", j);
			if (identical<1)
				identical = 1;
        }
    }

    return identical;
}

int Jidac::ssh_dohasha(std::string i_algo)
{
#ifdef _WIN32

// just for Win64, for now
#ifdef _WIN64
	if (pjidac == NULL)
	{
		myprintf("41436: pjidac null\n");
		seppuku();
	}


	if (kickstart_resources("LIBSSH")!=0) 
	{
		color_yellow();
		myprintf("97321: No libssh in current folder\n");
		color_restore();
	}
#endif
#endif

    if (caricadllssh()!=0) 
	{
		myprintf("97711: cannot load libssh\n");
        return 2;
    }
	else
	{
		if (flagdebug)
			myprintf("97715: libssh loaded!\n");
	}

	string localalgo;
	string remotealgo;
	if ((mypos("md5",i_algo)!=-1))
	{
		localalgo="MD5";
		remotealgo="md5sum";
	}
	if ((mypos("sha1",i_algo)!=-1))
	{
		localalgo="SHA-1";
		remotealgo="sha1sum";
	}
	if ((mypos("sha256",i_algo)!=-1))
	{
		localalgo="SHA-256";
		remotealgo="sha256sum";
	}

	if (localalgo.empty() || remotealgo.empty())
	{
		myprintf("97344! Strange i_algo |%s|\n",i_algo.c_str());
		return 2;
	}

	if (files.size()!=2)
	{
		myprintf("96838: you need 1 parameter (local file/folder)\n");
		for (unsigned int i=0;i<files.size();i++)
			myprintf("97832: files %03d %s\n",i,files[i].c_str());
		return 2;
	}
	if (g_sftp_remote=="")
	{
		myprintf("96843: you must enter -remote\n");
		return 2;
	}
	if (flagdebug3) 
		for (unsigned int i=0;i<files.size();i++)
			myprintf("96839: %03d %s\n",i,files[i].c_str());




	string posizionelocale=files[1];
	if (!iswildcard(posizionelocale))
		posizionelocale=includetrailingbackslash(posizionelocale)+"*";
	
	flagforcezfs=true;
	g_arraybytescanned.push_back(0);
	g_arrayfilescanned.push_back(0);
	edt.clear();
	myprintf("DEBUG: posizionelocale %s\n",posizionelocale.c_str());
	scandir(false,edt,posizionelocale.c_str(),false);
	eol();
	vector<std::string> localfiles;
	int64_t totallocalsize=0;
	for (DTMap::iterator a=edt.begin(); a!=edt.end(); ++a)
	{
		if (!isdirectory(a->first))
		{
			localfiles.push_back(a->first);
			totallocalsize+= a->second.size;
		}

	}
	if (flagdebug3)
		for (unsigned int i=0;i<localfiles.size();i++)
			myprintf("97127: Local <<%Z>>\n",localfiles[i].c_str());
		
	if (localfiles.size()==0)
	{
		myprintf("96959: No local file founded\n");
		return 1;
	}

	string hashtype=localalgo;
	
	myprintf("97129: Total local size %s, now hashing with %s...\n",migliaia(totallocalsize),hashtype.c_str());
	
	vector<std::pair<string,string> > local_hash_array;
	int64_t hashtime=franzparallelhashfiles(hashtype,totallocalsize,localfiles,false,local_hash_array);
	eol();
	if (flagverbose)
		myprintf("97197: Completed in %s\n",migliaia(hashtime));
	if (flagdebug3)
		for (unsigned int i=0;i<local_hash_array.size();i++)
			myprintf("97144: parallel hash %08d %s %s\n",i,local_hash_array[i].first.c_str(),local_hash_array[i].second.c_str());
	
	string 	posizioneremota=g_sftp_remote;
	if (!iswildcard(g_sftp_remote))
		posizioneremota=includetrailingbackslash(g_sftp_remote)+"*";
	string	sumcommand=remotealgo+" !1";
	
	string finalcommand=sumcommand;

	myreplaceall(finalcommand,"!1",posizioneremota);
	if (flagdebug)
	{
		myprintf("96837: Remote position %s\n",posizioneremota.c_str());
		myprintf("96850: Remote sum      %s\n",sumcommand.c_str());
		myprintf("96860: Replaced !1     %s\n",finalcommand.c_str());
	}

	uint64_t expectedtime=0;
	if (g_remotespeed>0)
	{
		expectedtime=totallocalsize/g_remotespeed;
		if (flagdebug2)
			myprintf("01245: g_remotespeed %s bytes %s expected time %s\n",migliaia(g_remotespeed),migliaia2(totallocalsize),migliaia3(expectedtime));
	}
	string theoutput;
	int risultato=xssh(expectedtime,finalcommand,theoutput);
	if (risultato!=0)
	{
		color_red();
		myprintf("97406: xssh return an error!\n");
		color_restore();
		return 2;
	}
	
	vector<std::pair<string,string> > remote_hash_array;

	parsehashfilelist(theoutput,remote_hash_array);

	if (flagdebug3)
		for (unsigned int i=0;i<remote_hash_array.size();i++)
			myprintf("97166: remote_hash_array %08d %s %s\n",i,remote_hash_array[i].first.c_str(),remote_hash_array[i].second.c_str());

	printbar('=');
	int comparazioneok=comparehasharrays(local_hash_array,remote_hash_array);
	if (comparazioneok==0)
	{
		color_green();
		myprintf("97237: Compare %s PERFECT MATCH: SUCCESS! (%s)\n",hashtype.c_str(),tohuman(totallocalsize));
		color_restore();
		return 0;
	}
	else
	if (comparazioneok==1)
	{
		color_yellow();
		myprintf("97255: WARNING: you need a resync\n");
		color_restore();
	}
	if (comparazioneok==2)
	{
		color_red();
		myprintf("97254: ERROR: HASH MISMATCH!\n");
		color_restore();
	}
	return comparazioneok;
}		
#endif
#endif ///NOSFTPEND

